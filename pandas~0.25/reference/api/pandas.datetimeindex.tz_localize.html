<h1 id="pandas-datetimeindex-tz-localize">pandas.DatetimeIndex.tz_localize</h1> <dl class="method"> <dt id="pandas.DatetimeIndex.tz_localize">
<code>DatetimeIndex.tz_localize(self, *args, **kwargs)</code> <a class="reference external" href="http://github.com/pandas-dev/pandas/blob/v0.25.0/pandas/core/accessor.py#L92-L93"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index.</p> <p>This method takes a time zone (tz) naive Datetime Array/Index object and makes this time zone aware. It does not move the time to another time zone. Time zone localization helps to switch from time zone aware to time zone unaware objects.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>tz : str, pytz.timezone, dateutil.tz.tzfile or None</code> </dt> <dd>
<p class="first last">Time zone to convert timestamps to. Passing <code>None</code> will remove the time zone information preserving local time.</p> </dd> <dt>
<code>ambiguous : ‘infer’, ‘NaT’, bool array, default ‘raise’</code> </dt> <dd>
<p class="first">When clocks moved backward due to DST, ambiguous times may arise. For example in Central European Time (UTC+01), when going from 03:00 DST to 02:00 non-DST, 02:30:00 local time occurs both at 00:30:00 UTC and at 01:30:00 UTC. In such a situation, the <code>ambiguous</code> parameter dictates how ambiguous times should be handled.</p> <ul class="last simple"> <li>‘infer’ will attempt to infer fall dst-transition hours based on order</li> <li>bool-ndarray where True signifies a DST time, False signifies a non-DST time (note that this flag is only applicable for ambiguous times)</li> <li>‘NaT’ will return NaT where there are ambiguous times</li> <li>‘raise’ will raise an AmbiguousTimeError if there are ambiguous times</li> </ul> </dd> <dt>
<code>nonexistent : ‘shift_forward’, ‘shift_backward, ‘NaT’, timedelta, default ‘raise’</code> </dt> <dd>
<p class="first">A nonexistent time does not exist in a particular timezone where clocks moved forward due to DST.</p> <ul class="simple"> <li>‘shift_forward’ will shift the nonexistent time forward to the closest existing time</li> <li>‘shift_backward’ will shift the nonexistent time backward to the closest existing time</li> <li>‘NaT’ will return NaT where there are nonexistent times</li> <li>timedelta objects will shift nonexistent times by the timedelta</li> <li>‘raise’ will raise an NonExistentTimeError if there are nonexistent times</li> </ul> <div class="last versionadded"> <p><span class="versionmodified">New in version 0.24.0.</span></p> </div> </dd> <dt>
<code>errors : {‘raise’, ‘coerce’}, default None</code> </dt> <dd>
<ul class="first simple"> <li>‘raise’ will raise a NonExistentTimeError if a timestamp is not valid in the specified time zone (e.g. due to a transition from or to DST time). Use <code>nonexistent='raise'</code> instead.</li> <li>‘coerce’ will return NaT if the timestamp can not be converted to the specified time zone. Use <code>nonexistent='NaT'</code> instead.</li> </ul> <div class="last deprecated"> <p><span class="versionmodified">Deprecated since version 0.24.0.</span></p> </div> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first docutils"> <dt>Same type as self</dt> <dd>
<p class="first last">Array/Index converted to the specified time zone.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Raises:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>TypeError</dt> <dd>
<p class="first last">If the Datetime Array/Index is tz-aware and tz is not None.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="pandas.datetimeindex.tz_convert#pandas.DatetimeIndex.tz_convert" title="pandas.DatetimeIndex.tz_convert"><code>DatetimeIndex.tz_convert</code></a>
</dt> <dd>Convert tz-aware DatetimeIndex from one time zone to another.</dd> </dl> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; tz_naive = pd.date_range('2018-03-01 09:00', periods=3)
&gt;&gt;&gt; tz_naive
DatetimeIndex(['2018-03-01 09:00:00', '2018-03-02 09:00:00',
               '2018-03-03 09:00:00'],
              dtype='datetime64[ns]', freq='D')
</pre> <p>Localize DatetimeIndex in US/Eastern time zone:</p> <pre data-language="python">&gt;&gt;&gt; tz_aware = tz_naive.tz_localize(tz='US/Eastern')
&gt;&gt;&gt; tz_aware
DatetimeIndex(['2018-03-01 09:00:00-05:00',
               '2018-03-02 09:00:00-05:00',
               '2018-03-03 09:00:00-05:00'],
              dtype='datetime64[ns, US/Eastern]', freq='D')
</pre> <p>With the <code>tz=None</code>, we can remove the time zone information while keeping the local time (not converted to UTC):</p> <pre data-language="python">&gt;&gt;&gt; tz_aware.tz_localize(None)
DatetimeIndex(['2018-03-01 09:00:00', '2018-03-02 09:00:00',
               '2018-03-03 09:00:00'],
              dtype='datetime64[ns]', freq='D')
</pre> <p>Be careful with DST changes. When there is sequential data, pandas can infer the DST time: &gt;&gt;&gt; s = pd.to_datetime(pd.Series([‘2018-10-28 01:30:00’, … ‘2018-10-28 02:00:00’, … ‘2018-10-28 02:30:00’, … ‘2018-10-28 02:00:00’, … ‘2018-10-28 02:30:00’, … ‘2018-10-28 03:00:00’, … ‘2018-10-28 03:30:00’])) &gt;&gt;&gt; s.dt.tz_localize(‘CET’, ambiguous=’infer’) 0 2018-10-28 01:30:00+02:00 1 2018-10-28 02:00:00+02:00 2 2018-10-28 02:30:00+02:00 3 2018-10-28 02:00:00+01:00 4 2018-10-28 02:30:00+01:00 5 2018-10-28 03:00:00+01:00 6 2018-10-28 03:30:00+01:00 dtype: datetime64[ns, CET]</p> <p>In some cases, inferring the DST is impossible. In such cases, you can pass an ndarray to the ambiguous parameter to set the DST explicitly</p> <pre data-language="python">&gt;&gt;&gt; s = pd.to_datetime(pd.Series(['2018-10-28 01:20:00',
...                               '2018-10-28 02:36:00',
...                               '2018-10-28 03:46:00']))
&gt;&gt;&gt; s.dt.tz_localize('CET', ambiguous=np.array([True, True, False]))
0   2015-03-29 03:00:00+02:00
1   2015-03-29 03:30:00+02:00
dtype: datetime64[ns, Europe/Warsaw]
</pre> <p>If the DST transition causes nonexistent times, you can shift these dates forward or backwards with a timedelta object or <code>‘shift_forward’</code> or <code>‘shift_backwards’</code>. &gt;&gt;&gt; s = pd.to_datetime(pd.Series([‘2015-03-29 02:30:00’, … ‘2015-03-29 03:30:00’])) &gt;&gt;&gt; s.dt.tz_localize(‘Europe/Warsaw’, nonexistent=’shift_forward’) 0 2015-03-29 03:00:00+02:00 1 2015-03-29 03:30:00+02:00 dtype: datetime64[ns, ‘Europe/Warsaw’] &gt;&gt;&gt; s.dt.tz_localize(‘Europe/Warsaw’, nonexistent=’shift_backward’) 0 2015-03-29 01:59:59.999999999+01:00 1 2015-03-29 03:30:00+02:00 dtype: datetime64[ns, ‘Europe/Warsaw’] &gt;&gt;&gt; s.dt.tz_localize(‘Europe/Warsaw’, nonexistent=pd.Timedelta(‘1H’)) 0 2015-03-29 03:30:00+02:00 1 2015-03-29 03:30:00+02:00 dtype: datetime64[ns, ‘Europe/Warsaw’]</p> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2008&ndash;2012, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData Development Team<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://pandas.pydata.org/pandas-docs/version/0.25.0/reference/api/pandas.DatetimeIndex.tz_localize.html" class="_attribution-link">https://pandas.pydata.org/pandas-docs/version/0.25.0/reference/api/pandas.DatetimeIndex.tz_localize.html</a>
  </p>
</div>
