<h1 id="pandas-read-excel">pandas.read_excel</h1> <dl class="function"> <dt id="pandas.read_excel">
<code>pandas.read_excel(io, sheet_name=0, header=0, names=None, index_col=None, usecols=None, squeeze=False, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, keep_default_na=True, verbose=False, parse_dates=False, date_parser=None, thousands=None, comment=None, skip_footer=0, skipfooter=0, convert_float=True, mangle_dupe_cols=True, **kwds)</code> <a class="reference external" href="http://github.com/pandas-dev/pandas/blob/v0.25.0/pandas/io/excel/_base.py#L272-L341"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Read an Excel file into a pandas DataFrame.</p> <p>Support both <code>xls</code> and <code>xlsx</code> file extensions from a local filesystem or URL. Support an option to read a single sheet or a list of sheets.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>io : str, ExcelFile, xlrd.Book, path object or file-like object</code> </dt> <dd>
<p class="first">Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: <code>file://localhost/path/to/table.xlsx</code>.</p> <p>If you want to pass in a path object, pandas accepts any <code>os.PathLike</code>.</p> <p class="last">By file-like object, we refer to objects with a <code>read()</code> method, such as a file handler (e.g. via builtin <code>open</code> function) or <code>StringIO</code>.</p> </dd> <dt>
<code>sheet_name : str, int, list, or None, default 0</code> </dt> <dd>
<p class="first">Strings are used for sheet names. Integers are used in zero-indexed sheet positions. Lists of strings/integers are used to request multiple sheets. Specify None to get all sheets.</p> <p>Available cases:</p> <ul class="last simple"> <li>Defaults to <code>0</code>: 1st sheet as a <code>DataFrame</code>
</li> <li>
<code>1</code>: 2nd sheet as a <code>DataFrame</code>
</li> <li>
<code>"Sheet1"</code>: Load sheet with name “Sheet1”</li> <li>
<code>[0, 1, "Sheet5"]</code>: Load first, second and sheet named “Sheet5” as a dict of <code>DataFrame</code>
</li> <li>None: All sheets.</li> </ul> </dd> <dt>
<code>header : int, list of int, default 0</code> </dt> <dd>
<p class="first last">Row (0-indexed) to use for the column labels of the parsed DataFrame. If a list of integers is passed those row positions will be combined into a <code>MultiIndex</code>. Use None if there is no header.</p> </dd> <dt>
<code>names : array-like, default None</code> </dt> <dd>
<p class="first last">List of column names to use. If file contains no header row, then you should explicitly pass header=None.</p> </dd> <dt>
<code>index_col : int, list of int, default None</code> </dt> <dd>
<p class="first last">Column (0-indexed) to use as the row labels of the DataFrame. Pass None if there is no such column. If a list is passed, those columns will be combined into a <code>MultiIndex</code>. If a subset of data is selected with <code>usecols</code>, index_col is based on the subset.</p> </dd> <dt>
<code>usecols : int, str, list-like, or callable default None</code> </dt> <dd>
<p class="first">Return a subset of the columns.</p> <ul class="last"> <li>If None, then parse all columns. </li> <li>
<p class="first">If int, then indicates last column to be parsed.</p> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 0.24.0: </span>Pass in a list of int instead from 0 to <code>usecols</code> inclusive.</p> </div> </li> <li>If str, then indicates comma separated list of Excel column letters and column ranges (e.g. “A:E” or “A,C,E:F”). Ranges are inclusive of both sides. </li> <li>If list of int, then indicates list of column numbers to be parsed. </li> <li>
<p class="first">If list of string, then indicates list of column names to be parsed.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 0.24.0.</span></p> </div> </li> <li>
<p class="first">If callable, then evaluate each column name against it and parse the column if the callable returns <code>True</code>.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 0.24.0.</span></p> </div> </li> </ul> </dd> <dt>
<code>squeeze : bool, default False</code> </dt> <dd>
<p class="first last">If the parsed data only contains one column then return a Series.</p> </dd> <dt>
<code>dtype : Type name or dict of column -&gt; type, default None</code> </dt> <dd>
<p class="first">Data type for data or columns. E.g. {‘a’: np.float64, ‘b’: np.int32} Use <code>object</code> to preserve data as stored in Excel and not interpret dtype. If converters are specified, they will be applied INSTEAD of dtype conversion.</p> <div class="last versionadded"> <p><span class="versionmodified">New in version 0.20.0.</span></p> </div> </dd> <dt>
<code>engine : str, default None</code> </dt> <dd>
<p class="first last">If io is not a buffer or path, this must be set to identify io. Acceptable values are None or xlrd.</p> </dd> <dt>
<code>converters : dict, default None</code> </dt> <dd>
<p class="first last">Dict of functions for converting values in certain columns. Keys can either be integers or column labels, values are functions that take one input argument, the Excel cell content, and return the transformed content.</p> </dd> <dt>
<code>true_values : list, default None</code> </dt> <dd>
<p class="first">Values to consider as True.</p> <div class="last versionadded"> <p><span class="versionmodified">New in version 0.19.0.</span></p> </div> </dd> <dt>
<code>false_values : list, default None</code> </dt> <dd>
<p class="first">Values to consider as False.</p> <div class="last versionadded"> <p><span class="versionmodified">New in version 0.19.0.</span></p> </div> </dd> <dt>
<code>skiprows : list-like</code> </dt> <dd>
<p class="first last">Rows to skip at the beginning (0-indexed).</p> </dd> <dt>
<code>nrows : int, default None</code> </dt> <dd>
<p class="first">Number of rows to parse.</p> <div class="last versionadded"> <p><span class="versionmodified">New in version 0.23.0.</span></p> </div> </dd> <dt>
<code>na_values : scalar, str, list-like, or dict, default None</code> </dt> <dd>
<p class="first last">Additional strings to recognize as NA/NaN. If dict passed, specific per-column NA values. By default the following values are interpreted as NaN: ‘’, ‘#N/A’, ‘#N/A N/A’, ‘#NA’, ‘-1.#IND’, ‘-1.#QNAN’, ‘-NaN’, ‘-nan’, ‘1.#IND’, ‘1.#QNAN’, ‘N/A’, ‘NA’, ‘NULL’, ‘NaN’, ‘n/a’, ‘nan’, ‘null’.</p> </dd> <dt>
<code>keep_default_na : bool, default True</code> </dt> <dd>
<p class="first last">If na_values are specified and keep_default_na is False the default NaN values are overridden, otherwise they’re appended to.</p> </dd> <dt>
<code>verbose : bool, default False</code> </dt> <dd>
<p class="first last">Indicate number of NA values placed in non-numeric columns.</p> </dd> <dt>
<code>parse_dates : bool, list-like, or dict, default False</code> </dt> <dd>
<p class="first">The behavior is as follows:</p> <ul class="simple"> <li>bool. If True -&gt; try parsing the index.</li> <li>list of int or names. e.g. If [1, 2, 3] -&gt; try parsing columns 1, 2, 3 each as a separate date column.</li> <li>list of lists. e.g. If [[1, 3]] -&gt; combine columns 1 and 3 and parse as a single date column.</li> <li>dict, e.g. {‘foo’ : [1, 3]} -&gt; parse columns 1, 3 as date and call result ‘foo’</li> </ul> <p>If a column or index contains an unparseable date, the entire column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use <code>pd.to_datetime</code> after <code>pd.read_excel</code>.</p> <p class="last">Note: A fast-path exists for iso8601-formatted dates.</p> </dd> <dt>
<code>date_parser : function, optional</code> </dt> <dd>
<p class="first last">Function to use for converting a sequence of string columns to an array of datetime instances. The default uses <code>dateutil.parser.parser</code> to do the conversion. Pandas will try to call <code>date_parser</code> in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by <code>parse_dates</code>) as arguments; 2) concatenate (row-wise) the string values from the columns defined by <code>parse_dates</code> into a single array and pass that; and 3) call <code>date_parser</code> once for each row using one or more strings (corresponding to the columns defined by <code>parse_dates</code>) as arguments.</p> </dd> <dt>
<code>thousands : str, default None</code> </dt> <dd>
<p class="first last">Thousands separator for parsing string columns to numeric. Note that this parameter is only necessary for columns stored as TEXT in Excel, any numeric columns will automatically be parsed, regardless of display format.</p> </dd> <dt>
<code>comment : str, default None</code> </dt> <dd>
<p class="first last">Comments out remainder of line. Pass a character or characters to this argument to indicate comments in the input file. Any data between the comment string and the end of the current line is ignored.</p> </dd> <dt>
<code>skip_footer : int, default 0</code> </dt> <dd>
<p class="first">Alias of <code>skipfooter</code>.</p> <div class="last deprecated"> <p><span class="versionmodified">Deprecated since version 0.23.0: </span>Use <code>skipfooter</code> instead.</p> </div> </dd> <dt>
<code>skipfooter : int, default 0</code> </dt> <dd>
<p class="first last">Rows at the end to skip (0-indexed).</p> </dd> <dt>
<code>convert_float : bool, default True</code> </dt> <dd>
<p class="first last">Convert integral floats to int (i.e., 1.0 –&gt; 1). If False, all numeric data will be read in as floats: Excel stores all numbers as floats internally.</p> </dd> <dt>
<code>mangle_dupe_cols : bool, default True</code> </dt> <dd>
<p class="first last">Duplicate columns will be specified as ‘X’, ‘X.1’, …’X.N’, rather than ‘X’…’X’. Passing in False will cause data to be overwritten if there are duplicate names in the columns.</p> </dd> <dt>
<code>**kwds : optional</code> </dt> <dd>
<p class="first last">Optional keyword arguments can be passed to <code>TextFileReader</code>.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>DataFrame or dict of DataFrames</dt> <dd>
<p class="first last">DataFrame from the passed in Excel file. See notes in sheet_name argument for more information on when a dict of DataFrames is returned.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>to_excel</code> </dt> <dd>Write DataFrame to an Excel file.</dd> <dt>
<code>to_csv</code> </dt> <dd>Write DataFrame to a comma-separated values (csv) file.</dd> <dt>
 <a class="reference internal" href="pandas.read_csv#pandas.read_csv" title="pandas.read_csv"><code>read_csv</code></a>
</dt> <dd>Read a comma-separated values (csv) file into DataFrame.</dd> <dt>
 <a class="reference internal" href="pandas.read_fwf#pandas.read_fwf" title="pandas.read_fwf"><code>read_fwf</code></a>
</dt> <dd>Read a table of fixed-width formatted lines into DataFrame.</dd> </dl> </div> <h4 class="rubric">Examples</h4> <p>The file can be read using the file name as string or an open file object:</p> <pre data-language="python">&gt;&gt;&gt; pd.read_excel('tmp.xlsx', index_col=0)  # doctest: +SKIP
       Name  Value
0   string1      1
1   string2      2
2  #Comment      3
</pre> <pre data-language="python">&gt;&gt;&gt; pd.read_excel(open('tmp.xlsx', 'rb'),
...               sheet_name='Sheet3')  # doctest: +SKIP
   Unnamed: 0      Name  Value
0           0   string1      1
1           1   string2      2
2           2  #Comment      3
</pre> <p>Index and header can be specified via the <code>index_col</code> and <code>header</code> arguments</p> <pre data-language="python">&gt;&gt;&gt; pd.read_excel('tmp.xlsx', index_col=None, header=None)  # doctest: +SKIP
     0         1      2
0  NaN      Name  Value
1  0.0   string1      1
2  1.0   string2      2
3  2.0  #Comment      3
</pre> <p>Column types are inferred but can be explicitly specified</p> <pre data-language="python">&gt;&gt;&gt; pd.read_excel('tmp.xlsx', index_col=0,
...               dtype={'Name': str, 'Value': float})  # doctest: +SKIP
       Name  Value
0   string1    1.0
1   string2    2.0
2  #Comment    3.0
</pre> <p>True, False, and NA values, and thousands separators have defaults, but can be explicitly specified, too. Supply the values you would like as strings or lists of strings!</p> <pre data-language="python">&gt;&gt;&gt; pd.read_excel('tmp.xlsx', index_col=0,
...               na_values=['string1', 'string2'])  # doctest: +SKIP
       Name  Value
0       NaN      1
1       NaN      2
2  #Comment      3
</pre> <p>Comment lines in the excel input file can be skipped using the <code>comment</code> kwarg</p> <pre data-language="python">&gt;&gt;&gt; pd.read_excel('tmp.xlsx', index_col=0, comment='#')  # doctest: +SKIP
      Name  Value
0  string1    1.0
1  string2    2.0
2     None    NaN
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2008&ndash;2012, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData Development Team<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://pandas.pydata.org/pandas-docs/version/0.25.0/reference/api/pandas.read_excel.html" class="_attribution-link">https://pandas.pydata.org/pandas-docs/version/0.25.0/reference/api/pandas.read_excel.html</a>
  </p>
</div>
