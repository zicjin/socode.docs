<h1 id="Sorting-and-Related-Functions">Sorting and Related Functions</h1>
<p>Julia has an extensive, flexible API for sorting and interacting with already-sorted arrays of values. By default, Julia picks reasonable algorithms and sorts in standard ascending order:</p>
<pre data-language="julia">julia&gt; sort([2,3,1])
3-element Vector{Int64}:
 1
 2
 3</pre>
<p>You can easily sort in reverse order as well:</p>
<pre data-language="julia">julia&gt; sort([2,3,1], rev=true)
3-element Vector{Int64}:
 3
 2
 1</pre>
<p>To sort an array in-place, use the "bang" version of the sort function:</p>
<pre data-language="julia">julia&gt; a = [2,3,1];

julia&gt; sort!(a);

julia&gt; a
3-element Vector{Int64}:
 1
 2
 3</pre>
<p>Instead of directly sorting an array, you can compute a permutation of the array's indices that puts the array into sorted order:</p>
<pre data-language="julia">julia&gt; v = randn(5)
5-element Array{Float64,1}:
  0.297288
  0.382396
 -0.597634
 -0.0104452
 -0.839027

julia&gt; p = sortperm(v)
5-element Array{Int64,1}:
 5
 3
 4
 1
 2

julia&gt; v[p]
5-element Array{Float64,1}:
 -0.839027
 -0.597634
 -0.0104452
  0.297288
  0.382396</pre>
<p>Arrays can easily be sorted according to an arbitrary transformation of their values:</p>
<pre data-language="julia">julia&gt; sort(v, by=abs)
5-element Array{Float64,1}:
 -0.0104452
  0.297288
  0.382396
 -0.597634
 -0.839027</pre>
<p>Or in reverse order by a transformation:</p>
<pre data-language="julia">julia&gt; sort(v, by=abs, rev=true)
5-element Array{Float64,1}:
 -0.839027
 -0.597634
  0.382396
  0.297288
 -0.0104452</pre>
<p>If needed, the sorting algorithm can be chosen:</p>
<pre data-language="julia">julia&gt; sort(v, alg=InsertionSort)
5-element Array{Float64,1}:
 -0.839027
 -0.597634
 -0.0104452
  0.297288
  0.382396</pre>
<p>All the sorting and order related functions rely on a "less than" relation defining a total order on the values to be manipulated. The <code>isless</code> function is invoked by default, but the relation can be specified via the <code>lt</code> keyword.</p>
<h2 id="Sorting-Functions">
<a class="docs-heading-anchor" href="#Sorting-Functions">Sorting Functions</a>
</h2>
<h3 id="Base.sort!">
<code>Base.sort!</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">sort!(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</pre>
<p>Sort the vector <code>v</code> in place. <a href="#Base.Sort.QuickSort"><code>QuickSort</code></a> is used by default for numeric arrays while <a href="#Base.Sort.MergeSort"><code>MergeSort</code></a> is used for other arrays. You can specify an algorithm to use via the <code>alg</code> keyword (see <a href="#Sorting-Algorithms">Sorting Algorithms</a> for available algorithms). The <code>by</code> keyword lets you provide a function that will be applied to each element before comparison; the <code>lt</code> keyword allows providing a custom "less than" function (note that for every <code>x</code> and <code>y</code>, only one of <code>lt(x,y)</code> and <code>lt(y,x)</code> can return <code>true</code>); use <code>rev=true</code> to reverse the sorting order. These options are independent and can be used together in all possible combinations: if both <code>by</code> and <code>lt</code> are specified, the <code>lt</code> function is applied to the result of the <code>by</code> function; <code>rev=true</code> reverses whatever ordering specified via the <code>by</code> and <code>lt</code> keywords.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; v = [3, 1, 2]; sort!(v); v
3-element Vector{Int64}:
 1
 2
 3

julia&gt; v = [3, 1, 2]; sort!(v, rev = true); v
3-element Vector{Int64}:
 3
 2
 1

julia&gt; v = [(1, "c"), (3, "a"), (2, "b")]; sort!(v, by = x -&gt; x[1]); v
3-element Vector{Tuple{Int64, String}}:
 (1, "c")
 (2, "b")
 (3, "a")

julia&gt; v = [(1, "c"), (3, "a"), (2, "b")]; sort!(v, by = x -&gt; x[2]); v
3-element Vector{Tuple{Int64, String}}:
 (3, "a")
 (2, "b")
 (1, "c")</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/sort.jl#L665-L704">source</a></section><section><pre data-language="julia">sort!(A; dims::Integer, alg::Algorithm=defalg(A), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</pre>
<p>Sort the multidimensional array <code>A</code> along dimension <code>dims</code>. See <a href="#Base.sort!"><code>sort!</code></a> for a description of possible keyword arguments.</p>
<p>To sort slices of an array, refer to <a href="#Base.sortslices"><code>sortslices</code></a>.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>This function requires at least Julia 1.1.</p></div>
</div>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [4 3; 1 2]
2×2 Matrix{Int64}:
 4  3
 1  2

julia&gt; sort!(A, dims = 1); A
2×2 Matrix{Int64}:
 1  2
 4  3

julia&gt; sort!(A, dims = 2); A
2×2 Matrix{Int64}:
 1  2
 3  4</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/sort.jl#L1059-L1087">source</a></section><h3 id="Base.sort">
<code>Base.sort</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">sort(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</pre>
<p>Variant of <a href="#Base.sort!"><code>sort!</code></a> that returns a sorted copy of <code>v</code> leaving <code>v</code> itself unmodified.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; v = [3, 1, 2];

julia&gt; sort(v)
3-element Vector{Int64}:
 1
 2
 3

julia&gt; v
3-element Vector{Int64}:
 3
 1
 2</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/sort.jl#L748-L769">source</a></section><section><pre data-language="julia">sort(A; dims::Integer, alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</pre>
<p>Sort a multidimensional array <code>A</code> along the given dimension. See <a href="#Base.sort!"><code>sort!</code></a> for a description of possible keyword arguments.</p>
<p>To sort slices of an array, refer to <a href="#Base.sortslices"><code>sortslices</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [4 3; 1 2]
2×2 Matrix{Int64}:
 4  3
 1  2

julia&gt; sort(A, dims = 1)
2×2 Matrix{Int64}:
 1  2
 4  3

julia&gt; sort(A, dims = 2)
2×2 Matrix{Int64}:
 3  4
 1  2</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/sort.jl#L1001-L1027">source</a></section><h3 id="Base.sortperm">
<code>Base.sortperm</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">sortperm(v; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</pre>
<p>Return a permutation vector <code>I</code> that puts <code>v[I]</code> in sorted order. The order is specified using the same keywords as <a href="#Base.sort!"><code>sort!</code></a>. The permutation is guaranteed to be stable even if the sorting algorithm is unstable, meaning that indices of equal elements appear in ascending order.</p>
<p>See also <a href="#Base.Sort.sortperm!"><code>sortperm!</code></a>, <a href="#Base.Sort.partialsortperm"><code>partialsortperm</code></a>, <a href="../arrays/index#Base.invperm"><code>invperm</code></a>, <a href="../collections/index#Base.indexin"><code>indexin</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; v = [3, 1, 2];

julia&gt; p = sortperm(v)
3-element Vector{Int64}:
 2
 3
 1

julia&gt; v[p]
3-element Vector{Int64}:
 1
 2
 3</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/sort.jl#L878-L904">source</a></section><h3 id="Base.Sort.InsertionSort">
<code>Base.Sort.InsertionSort</code><span class="docstring-category">Constant</span>
</h3>
<section><pre data-language="julia">InsertionSort</pre>
<p>Indicate that a sorting function should use the insertion sort algorithm. Insertion sort traverses the collection one element at a time, inserting each element into its correct, sorted position in the output list.</p>
<p>Characteristics:</p>
<ul>
<li>
<em>stable</em>: preserves the ordering of elements which compare equal (e.g. "a" and "A" in a sort of letters which ignores case).</li>
<li>
<em>in-place</em> in memory.</li>
<li>
<em>quadratic performance</em> in the number of elements to be sorted: it is well-suited to small collections but should not be used for large ones.</li>
</ul>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/sort.jl#L447-L462">source</a></section><h3 id="Base.Sort.MergeSort">
<code>Base.Sort.MergeSort</code><span class="docstring-category">Constant</span>
</h3>
<section><pre data-language="julia">MergeSort</pre>
<p>Indicate that a sorting function should use the merge sort algorithm. Merge sort divides the collection into subcollections and repeatedly merges them, sorting each subcollection at each step, until the entire collection has been recombined in sorted form.</p>
<p>Characteristics:</p>
<ul>
<li>
<em>stable</em>: preserves the ordering of elements which compare equal (e.g. "a" and "A" in a sort of letters which ignores case).</li>
<li>
<em>not in-place</em> in memory.</li>
<li>
<em>divide-and-conquer</em> sort strategy.</li>
</ul>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/sort.jl#L479-L494">source</a></section><h3 id="Base.Sort.QuickSort">
<code>Base.Sort.QuickSort</code><span class="docstring-category">Constant</span>
</h3>
<section><pre data-language="julia">QuickSort</pre>
<p>Indicate that a sorting function should use the quick sort algorithm, which is <em>not</em> stable.</p>
<p>Characteristics:</p>
<ul>
<li>
<em>not stable</em>: does not preserve the ordering of elements which compare equal (e.g. "a" and "A" in a sort of letters which ignores case).</li>
<li>
<em>in-place</em> in memory.</li>
<li>
<em>divide-and-conquer</em>: sort strategy similar to <a href="#Base.Sort.MergeSort"><code>MergeSort</code></a>.</li>
<li>
<em>good performance</em> for large collections.</li>
</ul>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/sort.jl#L464-L477">source</a></section><h3 id="Base.Sort.PartialQuickSort">
<code>Base.Sort.PartialQuickSort</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">PartialQuickSort{T &lt;: Union{Integer,OrdinalRange}}</pre>
<p>Indicate that a sorting function should use the partial quick sort algorithm. Partial quick sort returns the smallest <code>k</code> elements sorted from smallest to largest, finding them and sorting them using <a href="#Base.Sort.QuickSort"><code>QuickSort</code></a>.</p>
<p>Characteristics:</p>
<ul>
<li>
<em>not stable</em>: does not preserve the ordering of elements which compare equal (e.g. "a" and "A" in a sort of letters which ignores case).</li>
<li>
<em>in-place</em> in memory.</li>
<li>
<em>divide-and-conquer</em>: sort strategy similar to <a href="#Base.Sort.MergeSort"><code>MergeSort</code></a>.</li>
</ul>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/sort.jl#L428-L441">source</a></section><h3 id="Base.Sort.sortperm!">
<code>Base.Sort.sortperm!</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">sortperm!(ix, v; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward, initialized::Bool=false)</pre>
<p>Like <a href="#Base.sortperm"><code>sortperm</code></a>, but accepts a preallocated index vector <code>ix</code>. If <code>initialized</code> is <code>false</code> (the default), <code>ix</code> is initialized to contain the values <code>1:length(v)</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; v = [3, 1, 2]; p = zeros(Int, 3);

julia&gt; sortperm!(p, v); p
3-element Vector{Int64}:
 2
 3
 1

julia&gt; v[p]
3-element Vector{Int64}:
 1
 2
 3</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/sort.jl#L932-L954">source</a></section><h3 id="Base.sortslices">
<code>Base.sortslices</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">sortslices(A; dims, alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</pre>
<p>Sort slices of an array <code>A</code>. The required keyword argument <code>dims</code> must be either an integer or a tuple of integers. It specifies the dimension(s) over which the slices are sorted.</p>
<p>E.g., if <code>A</code> is a matrix, <code>dims=1</code> will sort rows, <code>dims=2</code> will sort columns. Note that the default comparison function on one dimensional slices sorts lexicographically.</p>
<p>For the remaining keyword arguments, see the documentation of <a href="#Base.sort!"><code>sort!</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1) # Sort rows
3×3 Matrix{Int64}:
 -1   6  4
  7   3  5
  9  -2  8

julia&gt; sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, lt=(x,y)-&gt;isless(x[2],y[2]))
3×3 Matrix{Int64}:
  9  -2  8
  7   3  5
 -1   6  4

julia&gt; sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, rev=true)
3×3 Matrix{Int64}:
  9  -2  8
  7   3  5
 -1   6  4

julia&gt; sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2) # Sort columns
3×3 Matrix{Int64}:
  3   5  7
 -1  -4  6
 -2   8  9

julia&gt; sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, alg=InsertionSort, lt=(x,y)-&gt;isless(x[2],y[2]))
3×3 Matrix{Int64}:
  5   3  7
 -4  -1  6
  8  -2  9

julia&gt; sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, rev=true)
3×3 Matrix{Int64}:
 7   5   3
 6  -4  -1
 9   8  -2</pre>
<p><strong>Higher dimensions</strong></p>
<p><code>sortslices</code> extends naturally to higher dimensions. E.g., if <code>A</code> is a a 2x2x2 array, <code>sortslices(A, dims=3)</code> will sort slices within the 3rd dimension, passing the 2x2 slices <code>A[:, :, 1]</code> and <code>A[:, :, 2]</code> to the comparison function. Note that while there is no default order on higher-dimensional slices, you may use the <code>by</code> or <code>lt</code> keyword argument to specify such an order.</p>
<p>If <code>dims</code> is a tuple, the order of the dimensions in <code>dims</code> is relevant and specifies the linear order of the slices. E.g., if <code>A</code> is three dimensional and <code>dims</code> is <code>(1, 2)</code>, the orderings of the first two dimensions are re-arranged such that the slices (of the remaining third dimension) are sorted. If <code>dims</code> is <code>(2, 1)</code> instead, the same slices will be taken, but the result order will be row-major instead.</p>
<p><strong>Higher dimensional examples</strong></p>
<pre data-language="julia">julia&gt; A = permutedims(reshape([4 3; 2 1; 'A' 'B'; 'C' 'D'], (2, 2, 2)), (1, 3, 2))
2×2×2 Array{Any, 3}:
[:, :, 1] =
 4  3
 2  1

[:, :, 2] =
 'A'  'B'
 'C'  'D'

julia&gt; sortslices(A, dims=(1,2))
2×2×2 Array{Any, 3}:
[:, :, 1] =
 1  3
 2  4

[:, :, 2] =
 'D'  'B'
 'C'  'A'

julia&gt; sortslices(A, dims=(2,1))
2×2×2 Array{Any, 3}:
[:, :, 1] =
 1  2
 3  4

[:, :, 2] =
 'D'  'C'
 'B'  'A'

julia&gt; sortslices(reshape([5; 4; 3; 2; 1], (1,1,5)), dims=3, by=x-&gt;x[1,1])
1×1×5 Array{Int64, 3}:
[:, :, 1] =
 1

[:, :, 2] =
 2

[:, :, 3] =
 3

[:, :, 4] =
 4

[:, :, 5] =
 5</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/multidimensional.jl#L1756-L1872">source</a></section><h2 id="Order-Related-Functions">
<a class="docs-heading-anchor" href="#Order-Related-Functions">Order-Related Functions</a>
</h2>
<h3 id="Base.issorted">
<code>Base.issorted</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">issorted(v, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</pre>
<p>Test whether a vector is in sorted order. The <code>lt</code>, <code>by</code> and <code>rev</code> keywords modify what order is considered to be sorted just as they do for <a href="#Base.sort"><code>sort</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; issorted([1, 2, 3])
true

julia&gt; issorted([(1, "b"), (2, "a")], by = x -&gt; x[1])
true

julia&gt; issorted([(1, "b"), (2, "a")], by = x -&gt; x[2])
false

julia&gt; issorted([(1, "b"), (2, "a")], by = x -&gt; x[2], rev=true)
true</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/sort.jl#L70-L90">source</a></section><h3 id="Base.Sort.searchsorted">
<code>Base.Sort.searchsorted</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">searchsorted(a, x; by=&lt;transform&gt;, lt=&lt;comparison&gt;, rev=false)</pre>
<p>Return the range of indices of <code>a</code> which compare as equal to <code>x</code> (using binary search) according to the order specified by the <code>by</code>, <code>lt</code> and <code>rev</code> keywords, assuming that <code>a</code> is already sorted in that order. Return an empty range located at the insertion point if <code>a</code> does not contain values equal to <code>x</code>.</p>
<p>See also: <a href="#Base.Sort.insorted"><code>insorted</code></a>, <a href="#Base.Sort.searchsortedfirst"><code>searchsortedfirst</code></a>, <a href="#Base.sort"><code>sort</code></a>, <a href="#"><code>findall</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; searchsorted([1, 2, 4, 5, 5, 7], 4) # single match
3:3

julia&gt; searchsorted([1, 2, 4, 5, 5, 7], 5) # multiple matches
4:5

julia&gt; searchsorted([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle
3:2

julia&gt; searchsorted([1, 2, 4, 5, 5, 7], 9) # no match, insert at end
7:6

julia&gt; searchsorted([1, 2, 4, 5, 5, 7], 0) # no match, insert at start
1:0</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/sort.jl#L302-L329">source</a></section><h3 id="Base.Sort.searchsortedfirst">
<code>Base.Sort.searchsortedfirst</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">searchsortedfirst(a, x; by=&lt;transform&gt;, lt=&lt;comparison&gt;, rev=false)</pre>
<p>Return the index of the first value in <code>a</code> greater than or equal to <code>x</code>, according to the specified order. Return <code>length(a) + 1</code> if <code>x</code> is greater than all values in <code>a</code>. <code>a</code> is assumed to be sorted.</p>
<p>See also: <a href="#Base.Sort.searchsortedlast"><code>searchsortedlast</code></a>, <a href="#Base.Sort.searchsorted"><code>searchsorted</code></a>, <a href="#"><code>findfirst</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; searchsortedfirst([1, 2, 4, 5, 5, 7], 4) # single match
3

julia&gt; searchsortedfirst([1, 2, 4, 5, 5, 7], 5) # multiple matches
4

julia&gt; searchsortedfirst([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle
3

julia&gt; searchsortedfirst([1, 2, 4, 5, 5, 7], 9) # no match, insert at end
7

julia&gt; searchsortedfirst([1, 2, 4, 5, 5, 7], 0) # no match, insert at start
1</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/sort.jl#L331-L357">source</a></section><h3 id="Base.Sort.searchsortedlast">
<code>Base.Sort.searchsortedlast</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">searchsortedlast(a, x; by=&lt;transform&gt;, lt=&lt;comparison&gt;, rev=false)</pre>
<p>Return the index of the last value in <code>a</code> less than or equal to <code>x</code>, according to the specified order. Return <code>0</code> if <code>x</code> is less than all values in <code>a</code>. <code>a</code> is assumed to be sorted.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; searchsortedlast([1, 2, 4, 5, 5, 7], 4) # single match
3

julia&gt; searchsortedlast([1, 2, 4, 5, 5, 7], 5) # multiple matches
5

julia&gt; searchsortedlast([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle
2

julia&gt; searchsortedlast([1, 2, 4, 5, 5, 7], 9) # no match, insert at end
6

julia&gt; searchsortedlast([1, 2, 4, 5, 5, 7], 0) # no match, insert at start
0</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/sort.jl#L359-L383">source</a></section><h3 id="Base.Sort.insorted">
<code>Base.Sort.insorted</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">insorted(a, x; by=&lt;transform&gt;, lt=&lt;comparison&gt;, rev=false) -&gt; Bool</pre>
<p>Determine whether an item is in the given sorted collection, in the sense that it is <a href="../math/index#Base.:=="><code>==</code></a> to one of the values of the collection according to the order specified by the <code>by</code>, <code>lt</code> and <code>rev</code> keywords, assuming that <code>a</code> is already sorted in that order, see <a href="#Base.sort"><code>sort</code></a> for the keywords.</p>
<p>See also <a href="../collections/index#Base.in"><code>in</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; insorted(4, [1, 2, 4, 5, 5, 7]) # single match
true

julia&gt; insorted(5, [1, 2, 4, 5, 5, 7]) # multiple matches
true

julia&gt; insorted(3, [1, 2, 4, 5, 5, 7]) # no match
false

julia&gt; insorted(9, [1, 2, 4, 5, 5, 7]) # no match
false

julia&gt; insorted(0, [1, 2, 4, 5, 5, 7]) # no match
false</pre>
<div class="admonition is-compat">

<div class="admonition-body"><p><code>insorted</code> was added in Julia 1.6.</p></div>
</div>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/sort.jl#L385-L415">source</a></section><h3 id="Base.Sort.partialsort!">
<code>Base.Sort.partialsort!</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">partialsort!(v, k; by=&lt;transform&gt;, lt=&lt;comparison&gt;, rev=false)</pre>
<p>Partially sort the vector <code>v</code> in place, according to the order specified by <code>by</code>, <code>lt</code> and <code>rev</code> so that the value at index <code>k</code> (or range of adjacent values if <code>k</code> is a range) occurs at the position where it would appear if the array were fully sorted via a non-stable algorithm. If <code>k</code> is a single index, that value is returned; if <code>k</code> is a range, an array of values at those indices is returned. Note that <code>partialsort!</code> does not fully sort the input array.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = [1, 2, 4, 3, 4]
5-element Vector{Int64}:
 1
 2
 4
 3
 4

julia&gt; partialsort!(a, 4)
4

julia&gt; a
5-element Vector{Int64}:
 1
 2
 3
 4
 4

julia&gt; a = [1, 2, 4, 3, 4]
5-element Vector{Int64}:
 1
 2
 4
 3
 4

julia&gt; partialsort!(a, 4, rev=true)
2

julia&gt; a
5-element Vector{Int64}:
 4
 4
 3
 2
 1</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/sort.jl#L104-L154">source</a></section><h3 id="Base.Sort.partialsort">
<code>Base.Sort.partialsort</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">partialsort(v, k, by=&lt;transform&gt;, lt=&lt;comparison&gt;, rev=false)</pre>
<p>Variant of <a href="#Base.Sort.partialsort!"><code>partialsort!</code></a> which copies <code>v</code> before partially sorting it, thereby returning the same thing as <code>partialsort!</code> but leaving <code>v</code> unmodified.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/sort.jl#L159-L164">source</a></section><h3 id="Base.Sort.partialsortperm">
<code>Base.Sort.partialsortperm</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">partialsortperm(v, k; by=&lt;transform&gt;, lt=&lt;comparison&gt;, rev=false)</pre>
<p>Return a partial permutation <code>I</code> of the vector <code>v</code>, so that <code>v[I]</code> returns values of a fully sorted version of <code>v</code> at index <code>k</code>. If <code>k</code> is a range, a vector of indices is returned; if <code>k</code> is an integer, a single index is returned. The order is specified using the same keywords as <code>sort!</code>. The permutation is stable, meaning that indices of equal elements appear in ascending order.</p>
<p>Note that this function is equivalent to, but more efficient than, calling <code>sortperm(...)[k]</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; v = [3, 1, 2, 1];

julia&gt; v[partialsortperm(v, 1)]
1

julia&gt; p = partialsortperm(v, 1:3)
3-element view(::Vector{Int64}, 1:3) with eltype Int64:
 2
 4
 3

julia&gt; v[p]
3-element Vector{Int64}:
 1
 1
 2</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/sort.jl#L774-L804">source</a></section><h3 id="Base.Sort.partialsortperm!">
<code>Base.Sort.partialsortperm!</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">partialsortperm!(ix, v, k; by=&lt;transform&gt;, lt=&lt;comparison&gt;, rev=false, initialized=false)</pre>
<p>Like <a href="#Base.Sort.partialsortperm"><code>partialsortperm</code></a>, but accepts a preallocated index vector <code>ix</code> the same size as <code>v</code>, which is used to store (a permutation of) the indices of <code>v</code>.</p>
<p>If the index vector <code>ix</code> is initialized with the indices of <code>v</code> (or a permutation thereof), <code>initialized</code> should be set to <code>true</code>.</p>
<p>If <code>initialized</code> is <code>false</code> (the default), then <code>ix</code> is initialized to contain the indices of <code>v</code>.</p>
<p>If <code>initialized</code> is <code>true</code>, but <code>ix</code> does not contain (a permutation of) the indices of <code>v</code>, the behavior of <code>partialsortperm!</code> is undefined.</p>
<p>(Typically, the indices of <code>v</code> will be <code>1:length(v)</code>, although if <code>v</code> has an alternative array type with non-one-based indices, such as an <code>OffsetArray</code>, <code>ix</code> must also be an <code>OffsetArray</code> with the same indices, and must contain as values (a permutation of) these same indices.)</p>
<p>Upon return, <code>ix</code> is guaranteed to have the indices <code>k</code> in their sorted positions, such that</p>
<pre data-language="julia">partialsortperm!(ix, v, k);
v[ix[k]] == partialsort(v, k)</pre>
<p>The return value is the <code>k</code>th element of <code>ix</code> if <code>k</code> is an integer, or view into <code>ix</code> if <code>k</code> is a range.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; v = [3, 1, 2, 1];

julia&gt; ix = Vector{Int}(undef, 4);

julia&gt; partialsortperm!(ix, v, 1)
2

julia&gt; ix = [1:4;];

julia&gt; partialsortperm!(ix, v, 2:3, initialized=true)
2-element view(::Vector{Int64}, 2:3) with eltype Int64:
 4
 3</pre>

<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/sort.jl#L808-L852">source</a></section><h2 id="Sorting-Algorithms">
<a class="docs-heading-anchor" href="#Sorting-Algorithms">Sorting Algorithms</a>
</h2>
<p>There are currently four sorting algorithms available in base Julia:</p>
<ul>
<li><a href="#Base.Sort.InsertionSort"><code>InsertionSort</code></a></li>
<li><a href="#Base.Sort.QuickSort"><code>QuickSort</code></a></li>
<li><a href="#Base.Sort.PartialQuickSort"><code>PartialQuickSort(k)</code></a></li>
<li><a href="#Base.Sort.MergeSort"><code>MergeSort</code></a></li>
</ul>
<p><code>InsertionSort</code> is an O(n^2) stable sorting algorithm. It is efficient for very small <code>n</code>, and is used internally by <code>QuickSort</code>.</p>
<p><code>QuickSort</code> is an O(n log n) sorting algorithm which is in-place, very fast, but not stable – i.e. elements which are considered equal will not remain in the same order in which they originally appeared in the array to be sorted. <code>QuickSort</code> is the default algorithm for numeric values, including integers and floats.</p>
<p><code>PartialQuickSort(k)</code> is similar to <code>QuickSort</code>, but the output array is only sorted up to index <code>k</code> if <code>k</code> is an integer, or in the range of <code>k</code> if <code>k</code> is an <code>OrdinalRange</code>. For example:</p>
<pre data-language="julia">x = rand(1:500, 100)
k = 50
k2 = 50:100
s = sort(x; alg=QuickSort)
ps = sort(x; alg=PartialQuickSort(k))
qs = sort(x; alg=PartialQuickSort(k2))
map(issorted, (s, ps, qs))             # =&gt; (true, false, false)
map(x-&gt;issorted(x[1:k]), (s, ps, qs))  # =&gt; (true, true, false)
map(x-&gt;issorted(x[k2]), (s, ps, qs))   # =&gt; (true, false, true)
s[1:k] == ps[1:k]                      # =&gt; true
s[k2] == qs[k2]                        # =&gt; true</pre>
<p><code>MergeSort</code> is an O(n log n) stable sorting algorithm but is not in-place – it requires a temporary array of half the size of the input array – and is typically not quite as fast as <code>QuickSort</code>. It is the default algorithm for non-numeric data.</p>
<p>The default sorting algorithms are chosen on the basis that they are fast and stable, or <em>appear</em> to be so. For numeric types indeed, <code>QuickSort</code> is selected as it is faster and indistinguishable in this case from a stable sort (unless the array records its mutations in some way). The stability property comes at a non-negligible cost, so if you don't need it, you may want to explicitly specify your preferred algorithm, e.g. <code>sort!(v, alg=QuickSort)</code>.</p>
<p>The mechanism by which Julia picks default sorting algorithms is implemented via the <code>Base.Sort.defalg</code> function. It allows a particular algorithm to be registered as the default in all sorting functions for specific arrays. For example, here are the two default methods from <a href="https://github.com/JuliaLang/julia/blob/master/base/sort.jl"><code>sort.jl</code></a>:</p>
<pre data-language="julia">defalg(v::AbstractArray) = MergeSort
defalg(v::AbstractArray{&lt;:Number}) = QuickSort</pre>
<p>As for numeric arrays, choosing a non-stable default algorithm for array types for which the notion of a stable sort is meaningless (i.e. when two values comparing equal can not be distinguished) may make sense.</p>
<h2 id="Alternate-orderings">
<a class="docs-heading-anchor" href="#Alternate-orderings">Alternate orderings</a>
</h2>
<p>By default, <code>sort</code> and related functions use <a href="../base/index#Base.isless"><code>isless</code></a> to compare two elements in order to determine which should come first. The <a href="#Base.Order.Ordering"><code>Base.Order.Ordering</code></a> abstract type provides a mechanism for defining alternate orderings on the same set of elements. Instances of <code>Ordering</code> define a <a href="https://en.wikipedia.org/wiki/Total_order">total order</a> on a set of elements, so that for any elements <code>a</code>, <code>b</code>, <code>c</code> the following hold:</p>
<ul>
<li>Exactly one of the following is true: <code>a</code> is less than <code>b</code>, <code>b</code> is less than <code>a</code>, or <code>a</code> and <code>b</code> are equal (according to <a href="../base/index#Base.isequal"><code>isequal</code></a>).</li>
<li>The relation is transitive - if <code>a</code> is less than <code>b</code> and <code>b</code> is less than <code>c</code> then <code>a</code> is less than <code>c</code>.</li>
</ul>
<p>The <a href="#Base.Order.lt"><code>Base.Order.lt</code></a> function works as a generalization of <code>isless</code> to test whether <code>a</code> is less than <code>b</code> according to a given order.</p>
<h3 id="Base.Order.Ordering">
<code>Base.Order.Ordering</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Base.Order.Ordering</pre>
<p>Abstract type which represents a total order on some set of elements.</p>
<p>Use <a href="#Base.Order.lt"><code>Base.Order.lt</code></a> to compare two elements according to the ordering.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/ordering.jl#L21-L27">source</a></section><h3 id="Base.Order.lt">
<code>Base.Order.lt</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">lt(o::Ordering, a, b)</pre>
<p>Test whether <code>a</code> is less than <code>b</code> according to the ordering <code>o</code>.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/ordering.jl#L104-L108">source</a></section><h3 id="Base.Order.ord">
<code>Base.Order.ord</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">ord(lt, by, rev::Union{Bool, Nothing}, order::Ordering=Forward)</pre>
<p>Construct an <a href="#Base.Order.Ordering"><code>Ordering</code></a> object from the same arguments used by <a href="#Base.sort!"><code>sort!</code></a>. Elements are first transformed by the function <code>by</code> (which may be <a href="../base/index#Base.identity"><code>identity</code></a>) and are then compared according to either the function <code>lt</code> or an existing ordering <code>order</code>. <code>lt</code> should be <a href="../base/index#Base.isless"><code>isless</code></a> or a function which obeys similar rules. Finally, the resulting order is reversed if <code>rev=true</code>.</p>
<p>Passing an <code>lt</code> other than <code>isless</code> along with an <code>order</code> other than <a href="#Base.Order.Forward"><code>Base.Order.Forward</code></a> or <a href="#Base.Order.Reverse"><code>Base.Order.Reverse</code></a> is not permitted, otherwise all options are independent and can be used together in all possible combinations.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/ordering.jl#L133-L148">source</a></section><h3 id="Base.Order.Forward">
<code>Base.Order.Forward</code><span class="docstring-category">Constant</span>
</h3>
<section><pre data-language="julia">Base.Order.Forward</pre>
<p>Default ordering according to <a href="../base/index#Base.isless"><code>isless</code></a>.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/ordering.jl#L51-L55">source</a></section><h3 id="Base.Order.ReverseOrdering">
<code>Base.Order.ReverseOrdering</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">ReverseOrdering(fwd::Ordering=Forward)</pre>
<p>A wrapper which reverses an ordering.</p>
<p>For a given <code>Ordering</code> <code>o</code>, the following holds for all <code>a</code>, <code>b</code>:</p>
<pre data-language="julia">lt(ReverseOrdering(o), a, b) == lt(o, b, a)</pre>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/ordering.jl#L32-L40">source</a></section><h3 id="Base.Order.Reverse">
<code>Base.Order.Reverse</code><span class="docstring-category">Constant</span>
</h3>
<section><pre data-language="julia">Base.Order.Reverse</pre>
<p>Reverse ordering according to <a href="../base/index#Base.isless"><code>isless</code></a>.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/ordering.jl#L58-L62">source</a></section><h3 id="Base.Order.By">
<code>Base.Order.By</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">By(by, order::Ordering=Forward)</pre>
<p><code>Ordering</code> which applies <code>order</code> to elements after they have been transformed by the function <code>by</code>.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/ordering.jl#L65-L70">source</a></section><h3 id="Base.Order.Lt">
<code>Base.Order.Lt</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Lt(lt)</pre>
<p><code>Ordering</code> which calls <code>lt(a, b)</code> to compare elements. <code>lt</code> should obey the same rules as implementations of <a href="../base/index#Base.isless"><code>isless</code></a>.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/ordering.jl#L79-L84">source</a></section><h3 id="Base.Order.Perm">
<code>Base.Order.Perm</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Perm(order::Ordering, data::AbstractVector)</pre>
<p><code>Ordering</code> on the indices of <code>data</code> where <code>i</code> is less than <code>j</code> if <code>data[i]</code> is less than <code>data[j]</code> according to <code>order</code>. In the case that <code>data[i]</code> and <code>data[j]</code> are equal, <code>i</code> and <code>j</code> are compared by numeric value.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3bf9d1773144bc4943232dc2ffaac307a700853d/base/ordering.jl#L89-L95">source</a></section><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://docs.julialang.org/en/v1.7.0/base/sort/" class="_attribution-link" target="_blank">https://docs.julialang.org/en/v1.7.0/base/sort/</a>
  </p>
</div>
