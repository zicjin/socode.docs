<h1 class="postHeaderTitle">Timers</h1>
<p>Timers are an important part of an application and React Native implements the <a href="https://developer.mozilla.org/en-US/Add-ons/Code_snippets/Timers">browser timers</a>.</p> <h2 id="timers">
Timers</h2> <ul> <li>setTimeout, clearTimeout</li> <li>setInterval, clearInterval</li> <li>setImmediate, clearImmediate</li> <li>requestAnimationFrame, cancelAnimationFrame</li> </ul> <p><code>requestAnimationFrame(fn)</code> is not the same as <code>setTimeout(fn, 0)</code> - the former will fire after all the frame has flushed, whereas the latter will fire as quickly as possible (over 1000x per second on a iPhone 5S).</p> <p><code>setImmediate</code> is executed at the end of the current JavaScript execution block, right before sending the batched response back to native. Note that if you call <code>setImmediate</code> within a <code>setImmediate</code> callback, it will be executed right away, it won't yield back to native in between.</p> <p>The <code>Promise</code> implementation uses <code>setImmediate</code> as its asynchronicity primitive.</p> <h2 id="interactionmanager">
InteractionManager</h2> <p>One reason why well-built native apps feel so smooth is by avoiding expensive operations during interactions and animations. In React Native, we currently have a limitation that there is only a single JS execution thread, but you can use <code>InteractionManager</code> to make sure long-running work is scheduled to start after any interactions/animations have completed.</p> <p>Applications can schedule tasks to run after interactions with the following:</p> <pre data-language="jsx">InteractionManager.runAfterInteractions(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// ...long-running synchronous task...</span>
});
</pre> <p>Compare this to other scheduling alternatives:</p> <ul> <li>requestAnimationFrame(): for code that animates a view over time.</li> <li>setImmediate/setTimeout/setInterval(): run code later, note this may delay animations.</li> <li>runAfterInteractions(): run code later, without delaying active animations.</li> </ul> <p>The touch handling system considers one or more active touches to be an 'interaction' and will delay <code>runAfterInteractions()</code> callbacks until all touches have ended or been cancelled.</p> <p>InteractionManager also allows applications to register animations by creating an interaction 'handle' on animation start, and clearing it upon completion:</p> <pre data-language="jsx"><span class="hljs-keyword">var</span> handle = InteractionManager.createInteractionHandle();
<span class="hljs-comment">// run animation... (`runAfterInteractions` tasks are queued)</span>
<span class="hljs-comment">// later, on animation completion:</span>
InteractionManager.clearInteractionHandle(handle);
<span class="hljs-comment">// queued tasks run if all handles were cleared</span>
</pre> <h2 id="timermixin">
TimerMixin</h2> <p>We found out that the primary cause of fatals in apps created with React Native was due to timers firing after a component was unmounted. To solve this recurring issue, we introduced <code>TimerMixin</code>. If you include <code>TimerMixin</code>, then you can replace your calls to <code>setTimeout(fn, 500)</code> with <code>this.setTimeout(fn, 500)</code> (just prepend <code>this.</code>) and everything will be properly cleaned up for you when the component unmounts.</p> <p>This library does not ship with React Native - in order to use it on your project, you will need to install it with <code>npm i react-timer-mixin --save</code> from your project directory.</p> <pre data-language="jsx"><span class="hljs-keyword">import</span> TimerMixin <span class="hljs-keyword">from</span> <span class="hljs-string">'react-timer-mixin'</span>;

<span class="hljs-keyword">var</span> Component = createReactClass({
  <span class="hljs-attr">mixins</span>: [TimerMixin],
  <span class="hljs-attr">componentDidMount</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
    <span class="hljs-keyword">this</span>.setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'I do not leak!'</span>);
    }, <span class="hljs-number">500</span>);
  },
});
</pre> <p>This will eliminate a lot of hard work tracking down bugs, such as crashes caused by timeouts firing after a component has been unmounted.</p> <p>Keep in mind that if you use ES6 classes for your React components <a href="https://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html#mixins">there is no built-in API for mixins</a>. To use <code>TimerMixin</code> with ES6 classes, we recommend <a href="https://github.com/brigand/react-mixin">react-mixin</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2015&ndash;2018 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>
    <a href="https://facebook.github.io/react-native/docs/timers" class="_attribution-link">https://facebook.github.io/react-native/docs/timers</a>
  </p>
</div>
