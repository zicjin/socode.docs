<h1 class="postHeaderTitle">AppState</h1>
<p><code>AppState</code> can tell you if the app is in the foreground or background, and notify you when the state changes.</p> <p>AppState is frequently used to determine the intent and proper behavior when handling push notifications.</p> <h3 id="app-states">
App States</h3> <ul> <li>
<code>active</code> - The app is running in the foreground</li> <li>
<code>background</code> - The app is running in the background. The user is either: <ul> <li>in another app</li> <li>on the home screen</li> <li>[Android] on another <code>Activity</code> (even if it was launched by your app)</li> </ul>
</li> <li>
<code>inactive</code> - This is a state that occurs when transitioning between foreground &amp; background, and during periods of inactivity such as entering the Multitasking view or in the event of an incoming call</li> </ul> <p>For more information, see <a href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html">Apple's documentation</a></p> <h3 id="basic-usage">
Basic Usage</h3> <p>To see the current state, you can check <code>AppState.currentState</code>, which will be kept up-to-date. However, <code>currentState</code> will be null at launch while <code>AppState</code> retrieves it over the bridge.</p> <pre data-language="jsx"><span class="hljs-keyword">import</span> <span class="hljs-type">React</span>, {<span class="hljs-type">Component</span>} from <span class="hljs-symbol">'reac</span>t'
<span class="hljs-keyword">import</span> {<span class="hljs-type">AppState</span>, <span class="hljs-type">Text</span>} from <span class="hljs-symbol">'react</span>-native'

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppStateExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{

  state = {
    appState: <span class="hljs-type">AppState</span>.currentState
  }

  componentDidMount() {
    <span class="hljs-type">AppState</span>.addEventListener(<span class="hljs-symbol">'chang</span>e', <span class="hljs-keyword">this</span>._handleAppStateChange);
  }

  componentWillUnmount() {
    <span class="hljs-type">AppState</span>.removeEventListener(<span class="hljs-symbol">'chang</span>e', <span class="hljs-keyword">this</span>._handleAppStateChange);
  }

  _handleAppStateChange = (nextAppState) =&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.appState.<span class="hljs-keyword">match</span>(/inactive|background/) &amp;&amp; nextAppState === <span class="hljs-symbol">'activ</span>e') {
      console.log(<span class="hljs-symbol">'App</span> has come to the foreground!')
    }
    <span class="hljs-keyword">this</span>.setState({appState: nextAppState});
  }

  render() {
    <span class="hljs-keyword">return</span> (
      &lt;<span class="hljs-type">Text</span>&gt;<span class="hljs-type">Current</span> state is: {<span class="hljs-keyword">this</span>.state.appState}&lt;/<span class="hljs-type">Text</span>&gt;
    );
  }

}
</pre> <p>This example will only ever appear to say "Current state is: active" because the app is only visible to the user when in the <code>active</code> state, and the null state will happen only momentarily.</p> <h2 id="methods">
Methods</h2> <ul> <li><a href="appstate#addeventlistener"><code>addEventListener</code></a></li> <li><a href="appstate#removeeventlistener"><code>removeEventListener</code></a></li> </ul> <h3 id="properties">
Properties</h3> <ul> <li><a href="appstate#currentState"><code>currentState</code></a></li> </ul>  <h1 id="reference">
Reference</h1> <h2 id="methods-1">
Methods</h2> <h3 id="addeventlistener">
<code>addEventListener()</code>
</h3> <pre data-language="jsx">addEventListener(type, handler);
</pre> <p>Add a handler to AppState changes by listening to the <code>change</code> event type and providing the handler</p> <p>TODO: now that AppState is a subclass of NativeEventEmitter, we could deprecate <code>addEventListener</code> and <code>removeEventListener</code> and just use <code>addListener</code> and <code>listener.remove()</code> directly. That will be a breaking change though, as both the method and event names are different (addListener events are currently required to be globally unique).</p>  <h3 id="removeeventlistener">
<code>removeEventListener()</code>
</h3> <pre data-language="jsx">removeEventListener(type, handler);
</pre> <p>Remove a handler by passing the <code>change</code> event type and the handler</p> <h2 id="properties-1">
Properties</h2> <h3 id="currentstate">
<code>currentState</code>
</h3> <pre data-language="jsx">AppState.currentState;
</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2015&ndash;2018 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>
    <a href="https://facebook.github.io/react-native/docs/appstate" class="_attribution-link">https://facebook.github.io/react-native/docs/appstate</a>
  </p>
</div>
