<h1>RxJS: Glossary And Semantics</h1> <p>When discussing and documenting observables, it's important to have a common language and a known set of rules around what is going on. This document is an attempt to standardize these things so we can try to control the language in our docs, and hopefully other publications about RxJS, so we can discuss reactive programming with RxJS on consistent terms.</p> <p>While not all of the documentation for RxJS reflects this terminology, it is a goal of the team to ensure it does, and to ensure the language and names around the library use this document as a source of truth and unified language.</p> <h2>Major Entities</h2> <p>There are high level entities that are frequently discussed. It's important to define them separately from other lower-level concepts, because they relate to the nature of observable.</p> <h3>Consumer</h3> <p>The code that is subscribing to the observable. This is whoever is being <em>notified</em> of <a href="glossary-and-semantics#Next">nexted</a> values, and <a href="glossary-and-semantics#Error">errors</a> or <a href="glossary-and-semantics#Complete">completions</a>.</p> <h3>Producer</h3> <p>Any system or thing that is the source of values that are being pushed out of the observable subscription to the consumer. This can be a wide variety of things, from a <code>WebSocket</code> to a simple iteration over an <code>Array</code>. The producer is most often created during the <a href="glossary-and-semantics#Subscribe">subscribe</a> action, and therefor "owned" by a <a href="glossary-and-semantics#Subscription">subscription</a> in a 1:1 way, but that is not always the case. A producer may be shared between many subscriptions, if it is created outside of the <a href="glossary-and-semantics#Subscribe">subscribe</a> action, in which case it is one-to-many, resulting in a <a href="glossary-and-semantics#Multicast">multicast</a>.</p> <h3>Subscription</h3> <p>A contract where a <a href="glossary-and-semantics#Consumer">consumer</a> is <a href="glossary-and-semantics#Observation">observing</a> values pushed by a <a href="glossary-and-semantics#Producer">producer</a>. The subscription (not to be confused with the <code>Subscription</code> class or type), is an ongoing process that amounts to the function of the observable from the Consumer's perspective. Subscription starts the moment a <a href="glossary-and-semantics#Subscribe">subscribe</a> action is initiated, even before the <a href="glossary-and-semantics#Subscribe">subscribe</a> action is finished.</p> <h3>Observable</h3> <p>The primary type in RxJS. At its highest level, an observable represents a template for connecting an <a href="glossary-and-semantics#Observer">Observer</a>, as a <a href="glossary-and-semantics#Consumer">consumer</a>, to a <a href="glossary-and-semantics#Producer">producer</a>, via a <a href="glossary-and-semantics#Subscribe">subscribe</a> action, resulting in a <a href="glossary-and-semantics#Subscription">subscription</a>.</p> <h3>Observer</h3> <p>The manifestation of a <a href="glossary-and-semantics#Consumer">consumer</a>. A type that may have some (or all) handlers for each type of <a href="glossary-and-semantics#Notification">notification</a>: <a href="glossary-and-semantics#Next">next</a>, <a href="glossary-and-semantics#Error">error</a>, and <a href="glossary-and-semantics#Complete">complete</a>. Having all three types of handlers generally gets this to be called an "observer", where if it is missing any of the notification handlers, it may be called a <a href="glossary-and-semantics#Partial_Observer">"partial observer"</a>.</p> <h2>Major Actions</h2> <p>There are specific actions and events that occur between major entities in RxJS that need to be defined. These major actions are the highest level events that occur within various parts in RxJS.</p> <h3>Subscribe</h3> <p>The act of a <a href="glossary-and-semantics#Consumer">consumer</a> requesting an Observable set up a <a href="glossary-and-semantics#Subscription">subscription</a> so that it may <a href="glossary-and-semantics#Observation">observe</a> a <a href="glossary-and-semantics#Producer">producer</a>. A subscribe action can occur with an observable via many different mechanisms. The primary mechanism is the <a href="../api/index/class/observable#subscribe"><code>subscribe</code> method</a> on the <a href="../api/index/class/observable">Observable class</a>. Other mechanisms include the <a href="../api/index/class/observable#forEach"><code>forEach</code> method</a>, functions like <a href="../api/index/function/lastvaluefrom"><code>lastValueFrom</code></a>, and <a href="../api/index/function/firstvaluefrom"><code>firstValueFrom</code></a>, and the deprecated <a href="../api/index/class/observable#forEach"><code>toPromise</code> method</a>.</p> <h3>Teardown</h3> <p>The act of cleaning up resources used by a producer. This is guaranteed to happen on <code>error</code>, <code>complete</code>, or if unsubscription occurs. This is not to be confused with <a href="glossary-and-semantics#Unsubscription">unsubscription</a>, but it does always happen during unsubscription.</p> <h3>Unsubscription</h3> <p>The act of a <a href="glossary-and-semantics#Consumer">consumer</a> telling a <a href="glossary-and-semantics#Producer">producer</a> is is no longer interested in receiving values. Causes <a href="glossary-and-semantics#Teardown">Teardown</a></p> <h3>Observation</h3> <p>A <a href="glossary-and-semantics#Consumer">consumer</a> reacting to <a href="glossary-and-semantics#Next">next</a>, <a href="glossary-and-semantics#Error">error</a>, or <a href="glossary-and-semantics#Complete">complete</a> <a href="glossary-and-semantics#Notification">notifications</a>. This can only happen <em>during</em> <a href="glossary-and-semantics#Subscription">subscription</a>.</p> <h3>Observation Chain</h3> <p>When an <a href="glossary-and-semantics#Observable">observable</a> uses another <a href="glossary-and-semantics#Observable">observable</a> as a <a href="glossary-and-semantics#Producer">producer</a>, an "observation chain" is set up. That is a chain of <a href="glossary-and-semantics#Observation">observation</a> such that multiple <a href="glossary-and-semantics#Observer">observers</a> are <a href="glossary-and-semantics#Notification">notifying</a> each other in a unidirectional way toward the final <a href="glossary-and-semantics#Consumer">consumer</a>.</p> <h3>Next</h3> <p>A value has been pushed to the <a href="glossary-and-semantics#Consumer">consumer</a> to be <a href="glossary-and-semantics#Observation">observed</a>. Will only happen during <a href="glossary-and-semantics#Subscription">subscription</a>, and cannot happen after <a href="glossary-and-semantics#Error">error</a>, <a href="glossary-and-semantics#Error">complete</a>, or <a href="glossary-and-semantics#Unsubscription">unsubscription</a>. Logically, this also means it cannot happen after <a href="glossary-and-semantics#Teardown">teardown</a>.</p> <h3>Error</h3> <p>The <a href="glossary-and-semantics#Producer">producer</a> has encountered a problem and is notifying the <a href="glossary-and-semantics#Consumer">consumer</a>. This is a notification that the <a href="glossary-and-semantics#Producer">producer</a> will no longer send values and will <a href="glossary-and-semantics#Teardown">teardown</a>. This cannot occur after <a href="glossary-and-semantics#Complete">complete</a>, any other <a href="glossary-and-semantics#Error">error</a>, or <a href="glossary-and-semantics#Unsubscription">unsubscription</a>. Logically, this also means it cannot happen after <a href="glossary-and-semantics#Teardown">teardown</a>.</p> <h3>Complete</h3> <p>The <a href="glossary-and-semantics#Producer">producer</a> is notifying the <a href="glossary-and-semantics#Consumer">consumer</a> that it is done <a href="glossary-and-semantics#Next">nexting</a> values, without error, will send no more values, and it will <a href="glossary-and-semantics#Teardown">teardown</a>. <a href="glossary-and-semantics#Complete">Completion</a> cannot occur after an <a href="glossary-and-semantics#Error">error</a>, or <a href="glossary-and-semantics#Unsubscription">unsubscribe</a>. <a href="glossary-and-semantics#Complete">Complete</a> cannot be called twice. <a href="glossary-and-semantics#Complete">Complete</a>, if it occurs, will always happen before <a href="glossary-and-semantics#Teardown">teardown</a>.</p> <h3>Notification</h3> <p>The act of a <a href="glossary-and-semantics#Producer">producer</a> pushing <a href="glossary-and-semantics#Next">nexted</a> values, <a href="glossary-and-semantics#Error">errors</a> or <a href="glossary-and-semantics#Complete">completions</a> to a <a href="glossary-and-semantics#Consumer">consumer</a> to be <a href="glossary-and-semantics#Observation">observed</a>. Not to be confused with the <a href="../api/index/class/notification"><code>Notification</code> type</a>, which is notification manifested as a JavaScript object.</p> <h2>Major Concepts</h2> <p>Some of what we discuss is conceptual. These are mostly common traits of behaviors that can manifest in observables or in push-based reactive systems.</p> <h3>Multicast</h3> <p>The act of one <a href="glossary-and-semantics#Producer">producer</a> being <a href="glossary-and-semantics#Observation">observed</a> by <strong>many</strong> <a href="glossary-and-semantics#Consumer">consumers</a>.</p> <h3>Unicast</h3> <p>The act of one <a href="glossary-and-semantics#Producer">producer</a> being <a href="glossary-and-semantics#Observation">observed</a> <strong>only one</strong> <a href="glossary-and-semantics#Consumer">consumer</a>. An observable is "unicast" when it only connects one <a href="glossary-and-semantics#Producer">producer</a> to one <a href="glossary-and-semantics#consumer">consumer</a>. Unicast doesn't necessarily mean <a href="glossary-and-semantics#Cold">"cold"</a>.</p> <h3>Cold</h3> <p>An observable is "cold" when it creates a new <a href="glossary-and-semantics#Producer">producer</a> during <a href="glossary-and-semantics#Subscribe">subscribe</a> for every new <a href="glossary-and-semantics#Subscription">subscription</a>. As a result, a "cold" observables are <em>always</em> <a href="glossary-and-semantics#Unicast">unicast</a>, being one <a href="glossary-and-semantics#Producer">producer</a> <a href="glossary-and-semantics#Observation">observed</a> by one <a href="glossary-and-semantics#Consumer">consumer</a>. Cold observables can be made <a href="glossary-and-semantics#Hot">hot</a> but not the other way around.</p> <h3>Hot</h3> <p>An observable is "hot", when its <a href="glossary-and-semantics#Producer">producer</a> was created outside of the context of the <a href="glossary-and-semantics#Subscribe">subscribe</a> action. This means that the "hot" observable is almost always <a href="glossary-and-semantics#Multicast">multicast</a>. It is possible that a "hot" observable is still <em>technically</em> unicast, if it is engineered to only allow one <a href="glossary-and-semantics#Subscription">subscription</a> at a time, however, there is no straightforward mechanism for this in RxJS, and the scenario is a unlikely. For the purposes of discussion, all "hot" observables can be assumed to be <a href="glossary-and-semantics#Multicast">multicast</a>. Hot observables cannot be made <a href="glossary-and-semantics#Cold">cold</a>.</p> <h3>Push</h3> <p><a href="glossary-and-semantics#Observable">Observables</a> are a push-based type. That means rather than having the <a href="glossary-and-semantics#Consumer">consumer</a> call a function or perform some other action to get a value, the <a href="glossary-and-semantics#Consumer">consumer</a> receives values as soon as the <a href="glossary-and-semantics#Producer">producer</a> has produced them, via a registered <a href="glossary-and-semantics#Next">next</a> handler.</p> <h3>Pull</h3> <p>Pull-based systems are the opposite of <a href="glossary-and-semantics#Push">push</a>-based. In a pull-based type or system, the <a href="glossary-and-semantics#Consumer">consumer</a> must request each value the <a href="glossary-and-semantics#Producer">producer</a> has produced manually, perhaps long after the <a href="glossary-and-semantics#Producer">producer</a> has actually done so. Examples of such systems are <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">Functions</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">Iterators</a> </p> <h2>Minor Entities</h2> <h3>Operator</h3> <p>A factory function that creates an <a href="glossary-and-semantics#Operator_Function">operator function</a>. Examples of this in rxjs are functions like <a href="../api/operators/map"><code>map</code></a> and <a href="../api/operators/mergemap"><code>mergeMap</code></a>, which are generally passed to <a href="../api/index/class/observable#pipe"><code>pipe</code></a>. The result of calling many operators, and passing their resulting <a href="glossary-and-semantics#Operator_Function">operator functions</a> into pipe on an observable <a href="glossary-and-semantics#Source">source</a> will be another <a href="glossary-and-semantics#Observable">observable</a>, and will generally not result in <a href="glossary-and-semantics#Subscription">subscription</a>.</p> <h3>Operator Function</h3> <p>A function that takes an <a href="glossary-and-semantics#Observable">observable</a>, and maps it to a new <a href="glossary-and-semantics#Observable">observable</a>. Nothing more, nothing less. Operator functions are created by <a href="glossary-and-semantics#Operator">operators</a>. If you were to call an rxjs operator like <a href="../api/operators/map">map</a> and put the return value in a variable, the returned value would be an operator function.</p> <h3>Operation</h3> <p>An action taken while handling a <a href="glossary-and-semantics#Notification">notification</a>, as set up by an <a href="glossary-and-semantics#Operator">operator</a> and/or <a href="glossary-and-semantics#Operator_Function">operator function</a>. In RxJS, a developer can chain several <a href="glossary-and-semantics#Operator_Function">operator functions</a> together by calling <a href="glossary-and-semantics#Operator">operators</a> and passing the created <a href="glossary-and-semantics#Operator_Function">operator functions</a> to the <a href="../api/index/class/observable#pipe"><code>pipe</code></a> method of <a href="../api/index/class/observable"><code>Observable</code></a>, which results in a new <a href="glossary-and-semantics#Observable">observable</a>. During <a href="glossary-and-semantics#Subscription">subscription</a> to that observable, operations are performed in an order dictated by the <a href="glossary-and-semantics#Observation_Chain">observation chain</a>.</p> <h3>Stream</h3> <p>A "stream" or "streaming" in the case of observables, refers to the collection of <a href="glossary-and-semantics#Operation">operations</a>, as they are processed during a <a href="glossary-and-semantics#Subscription">subscription</a>. This is not to be confused with node <a href="https://nodejs.org/api/stream.html">Streams</a>, and the word "stream", on its own, should be used <em>sparingly</em> in documentation and articles. Instead, prefer <a href="glossary-and-semantics#Observation_Chain">observation chain</a>, <a href="glossary-and-semantics#Operation">operations</a>, or <a href="glossary-and-semantics#Subscription">subscription</a>. "Streaming" is less ambiguous, and is fine to use given this defined meaning.</p> <h3>Source</h3> <p>A <a href="glossary-and-semantics#Observable">observable</a> or <a href="glossary-and-semantics#Observable_Inputs">valid observable input</a> having been converted to an observable, that will supply values to another <a href="glossary-and-semantics#Observable">observable</a>, either as the result of an <a href="glossary-and-semantics#Operator">operator</a> or other function that creates one observable as another. This <a href="glossary-and-semantics#Source">source</a>, will be the <a href="glossary-and-semantics#Producer">producer</a> for the resulting <a href="glossary-and-semantics#Observable">observable</a> and all of its <a href="glossary-and-semantics#Subscriptions">subscriptions</a>. Sources may generally be any type of observable.</p> <h3>Observable Inputs</h3> <p>A "observable input" (<a href="../api/index/type-alias/observableinput">defined as a type here</a>), is any type that can easily converted to an <a href="glossary-and-semantics#Observable">Observable</a>. Observable Inputs may sometimes be referred to as "valid observable sources".</p> <h3>Notifier</h3> <p>An <a href="glossary-and-semantics#Observable">observable</a> that is being used to notify another <a href="glossary-and-semantics#Observable">observable</a> that it needs to perform some action. The action should only occur on a <a href="glossary-and-semantics#Next">next notification</a>, and never on <a href="glossary-and-semantics#Error">error</a> or <a href="glossary-and-semantics#Complete">complete</a>. Generally, notifiers are used with specific operators, such as <a href="../api/operators/takeuntil"><code>takeUntil</code></a>, <a href="../api/operators/buffer"><code>buffer</code></a>, or <a href="../api/operators/delaywhen"><code>delayWhen</code></a>. A notifier may be passed directly, or it may be returned by a callback.</p> <h3>Inner Source</h3> <p>One, of possibly many <a href="glossary-and-semantics#Source">sources</a>, which are <a href="glossary-and-semantics#Subscribe">subscribed</a> to automatically within a single <a href="glossary-and-semantics#Subscription">subscription</a> to another observable. Examples of an "inner source" include the <a href="glossary-and-semantics#Observable_Inputs">observable inputs</a> returned by the mapping function in a <a href="../api/operators/mergemap">mergeMap</a> <a href="glossary-and-semantics#Operator">operator</a>. (e.g. <code>source.pipe(mergeMap(value =&gt; createInnerSource(value))))</code>, were <code>createInnerSource</code> returns any valid <a href="glossary-and-semantics#Observable_Input">observable input</a>).</p> <h3>Partial Observer</h3> <p>An <a href="glossary-and-semantics#Observer">observer</a> that lacks all necessary <a href="glossary-and-semantics#Notification">notification</a> handlers. Generally these are supplied by user-land <a href="glossary-and-semantics#Consumer">consumer</a> code. A "full observer" or "observer" would simply be an observer than had all <a href="glossary-and-semantics#Notification">notification</a> handlers.</p> <h2>Other Concepts</h2> <h3>Unhandled Errors</h3> <p>An "unhandled error" is any <a href="glossary-and-semantics#Error">error</a> that is not handled by a <a href="glossary-and-semantics#Consumer">consumer</a>-provided function, which is generally provided during the <a href="glossary-and-semantics#Subscribe">subscribe</a> action. If no error handler was provided, RxJS will assume the error is "unhandled" and rethrow the error on a new callstack or prevent <a href="producer_interference">"producer interference"</a></p> <h3>Producer Interference</h3> <p><a href="glossary-and-semantics#Producer">Producer</a> interference happens when an error is allowed to unwind the callstack the RxJS callstack during <a href="glossary-and-semantics#Notification">notification</a>. When this happens, the error could break things like for-loops in <a href="glossary-and-semantics#Upstream_and_Downstream">upstream</a> <a href="glossary-and-semantics#Source">sources</a> that are <a href="glossary-and-semantics#Notification">notifying</a> <a href="glossary-and-semantics#Consumer">consumers</a> during a <a href="glossary-and-semantics#Multicast">multicast</a>. That would cause the other <a href="glossary-and-semantics#Consumer">consumers</a> in that <a href="glossary-and-semantics#Multicast">multicast</a> to suddenly stop receiving values without logical explanation. As of version 6, RxJS goes out of its way to prevent producer interference by ensuring that all unhandled errors are thrown on a separate callstack.</p> <h3>Upstream And Downstream</h3> <p>The order in which <a href="glossary-and-semantics#Notification">notifications</a> are processed by <a href="glossary-and-semantics#Operation">operations</a> in a <a href="glossary-and-semantics#Stream">stream</a> have a directionality to them. "Upstream" refers to an <a href="glossary-and-semantics#Operation">operation</a> that was already processed before the current <a href="glossary-and-semantics#Operation">operation</a>, and "downstream" refers to an <a href="glossary-and-semantics#Operation">operation</a> that <em>will</em> be processed <em>after</em> the current <a href="glossary-and-semantics#Operation">operation</a>. See also: <a href="glossary-and-semantics#Stream">Streaming</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://rxjs.dev/guide/glossary-and-semantics" class="_attribution-link" target="_blank">https://rxjs.dev/guide/glossary-and-semantics</a>
  </p>
</div>
