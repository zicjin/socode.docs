   <h1>shareReplay</h1> <p><code class="api-type-label function">function</code> <code class="api-status-label stable">stable</code></p>   <aio-toc class="embedded"></aio-toc> <div class="api-body"> 
<p>Share source and replay specified number of emissions on subscription.</p>  <h3 data-language="typescript"><code>shareReplay&lt;T&gt;(configOrBufferSize?: number | ShareReplayConfig, windowTime?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction&lt;T&gt;</code></h3> <h4 class="no-anchor">Parameters</h4> <table> <tbody> <tr class="function-overload-parameter"> <td class="param-name">
configOrBufferSize</td> <td class="param-description"> <p>Optional. Default is <code>undefined</code>.</p> <p>Type: <code>number | ShareReplayConfig</code>.</p> </td> </tr> <tr class="function-overload-parameter"> <td class="param-name">
windowTime</td> <td class="param-description"> <p>Optional. Default is <code>undefined</code>.</p> <p>Maximum time length of the replay buffer in milliseconds.</p> </td> </tr> <tr class="function-overload-parameter"> <td class="param-name">
scheduler</td> <td class="param-description"> <p> Optional. Default is <code>undefined</code>.</p> <p> Scheduler where connected observers within the selector function will be invoked on.</p> </td> </tr> </tbody> </table> <h4 class="no-anchor">Returns</h4> <p><code>MonoTypeOperatorFunction&lt;T&gt;</code>: A function that returns an Observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.</p>  <h2>Description</h2> <p>This operator is a specialization of <code>replay</code> that connects to a source observable and multicasts through a <code>ReplaySubject</code> constructed with the specified arguments. A successfully completed source will stay cached in the <code>shareReplayed observable</code> forever, but an errored source can be retried.</p> <h2>Why use shareReplay?</h2> <p>You generally want to use <code>shareReplay</code> when you have side-effects or taxing computations that you do not wish to be executed amongst multiple subscribers. It may also be valuable in situations where you know you will have late subscribers to a stream that need access to previously emitted values. This ability to replay values on subscription is what differentiates <a href="share"><code>share</code></a> and <code>shareReplay</code>.</p> <p><img src="https://rxjs.dev/api/operators/shareReplay.png"></p> <h2>Reference counting</h2> <p>As of RXJS version 6.4.0 a new overload signature was added to allow for manual control over what happens when the operators internal reference counter drops to zero. If <code>refCount</code> is true, the source will be unsubscribed from once the reference count drops to zero, i.e. the inner <code>ReplaySubject</code> will be unsubscribed. All new subscribers will receive value emissions from a new <code>ReplaySubject</code> which in turn will cause a new subscription to the source observable. If <code>refCount</code> is false on the other hand, the source will not be unsubscribed meaning that the inner <code>ReplaySubject</code> will still be subscribed to the source (and potentially run for ever).</p> <h2>Example</h2> <pre data-language="typescript">import { interval } from 'rxjs';
import { shareReplay, take } from 'rxjs/operators';

const obs$ = interval(1000);
const shared$ = obs$.pipe(
  take(4),
  shareReplay(3)
);
shared$.subscribe(x =&gt; console.log('sub A: ', x));
shared$.subscribe(y =&gt; console.log('sub B: ', y));</pre> <h2>Example for refCount usage</h2> <pre data-language="typescript">import { interval, Observable, defer } from 'rxjs';
import { shareReplay, take, tap, finalize } from 'rxjs/operators';

const log = &lt;T&gt;(source: Observable&lt;T&gt;, name: string) =&gt; defer(() =&gt; {
  console.log(`${name}: subscribed`);
  return source.pipe(
    tap({
      next: value =&gt; console.log(`${name}: ${value}`),
      complete: () =&gt; console.log(`${name}: complete`)
    }),
    finalize(() =&gt; console.log(`${name}: unsubscribed`))
  );
});

const obs$ = log(interval(1000), 'source');

const shared$ = log(obs$.pipe(
  shareReplay({bufferSize: 1, refCount: true }),
  take(2),
), 'shared');

shared$.subscribe(x =&gt; console.log('sub A: ', x));
shared$.subscribe(y =&gt; console.log('sub B: ', y));

// PRINTS:
// shared: subscribed &lt;-- reference count = 1
// source: subscribed
// shared: subscribed &lt;-- reference count = 2
// source: 0
// shared: 0
// sub A: 0
// shared: 0
// sub B: 0
// source: 1
// shared: 1
// sub A: 1
// shared: complete &lt;-- take(2) completes the subscription for sub A
// shared: unsubscribed &lt;-- reference count = 1
// shared: 1
// sub B: 1
// shared: complete &lt;-- take(2) completes the subscription for sub B
// shared: unsubscribed &lt;-- reference count = 0
// source: unsubscribed &lt;-- replaySubject unsubscribes from source observable because the reference count dropped to 0 and refCount is true

// In case of refCount being false, the unsubscribe is never called on the source and the source would keep on emitting, even if no subscribers
// are listening.
// source: 2
// source: 3
// source: 4
// ...</pre>   <h2>See Also</h2> <ul> <li>
<a href="publish"><code>publish</code></a> </li> <li>
<a href="share"><code>share</code></a> </li> <li>
<a href="publishreplay"><code>publishReplay</code></a> </li> </ul>  </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://rxjs.dev/api/operators/shareReplay" class="_attribution-link" target="_blank">https://rxjs.dev/api/operators/shareReplay</a>
  </p>
</div>
