   <h1>connect</h1> <p><code class="api-type-label function">function</code> <code class="api-status-label stable">stable</code></p>   <aio-toc class="embedded"></aio-toc> <div class="api-body"> 
<p>Creates an observable by multicasting the source within a function that allows the developer to define the usage of the multicast prior to connection.</p>  <h3 data-language="typescript"><code>connect&lt;T, O extends ObservableInput&lt;unknown&gt;&gt;(selector: (shared: Observable&lt;T&gt;) =&gt; O, config: ConnectConfig&lt;T&gt; = DEFAULT_CONFIG): OperatorFunction&lt;T, ObservedValueOf&lt;O&gt;&gt;</code></h3> <h4 class="no-anchor">Parameters</h4> <table> <tbody> <tr class="function-overload-parameter"> <td class="param-name">
selector</td> <td class="param-description"> <p> A function used to set up the multicast. Gives you a multicast observable that is not yet connected. With that, you're expected to create and return and Observable, that when subscribed to, will utilize the multicast observable. After this function is executed -- and its return value subscribed to -- the the operator will subscribe to the source, and the connection will be made.</p> </td> </tr> <tr class="function-overload-parameter"> <td class="param-name">
config</td> <td class="param-description"> <p>Optional. Default is <code>DEFAULT_CONFIG</code>.</p> <p>The configuration object for <code>connect</code>.</p> </td> </tr> </tbody> </table> <h4 class="no-anchor">Returns</h4> <p><code>OperatorFunction&lt;T, ObservedValueOf&lt;O&gt;&gt;</code></p>  <h2>Description</h2> <p>This is particularly useful if the observable source you wish to multicast could be synchronous or asynchronous. This sets it apart from <a href="share"><code>share</code></a>, which, in the case of totally synchronous sources will fail to share a single subscription with multiple consumers, as by the time the subscription to the result of <a href="share"><code>share</code></a> has returned, if the source is synchronous its internal reference count will jump from 0 to 1 back to 0 and reset.</p> <p>To use <code>connect</code>, you provide a <code>selector</code> function that will give you a multicast observable that is not yet connected. You then use that multicast observable to create a resulting observable that, when subscribed, will set up your multicast. This is generally, but not always, accomplished with <a href="merge"><code>merge</code></a>.</p> <p>Note that using a <a href="takeuntil"><code>takeUntil</code></a> inside of <code>connect</code>'s <code>selector</code> <em>might</em> mean you were looking to use the <a href="takewhile"><code>takeWhile</code></a> operator instead.</p> <p>When you subscribe to the result of <code>connect</code>, the <code>selector</code> function will be called. After the <code>selector</code> function returns, the observable it returns will be subscribed to, <em>then</em> the multicast will be connected to the source.</p> <h4>Example</h4> <p>Sharing a totally synchronous observable</p> <pre data-language="typescript">import { defer, of } from 'rxjs';
import { tap, connect } from 'rxjs/operators';

const source$ = defer(() =&gt; {
 console.log('subscription started');
 return of(1, 2, 3, 4, 5).pipe(
   tap(n =&gt; console.log(`source emitted ${n}`))
 );
});

source$.pipe(
 // Notice in here we're merging 3 subscriptions to `shared$`.
 connect((shared$) =&gt; merge(
     shared$.pipe(map(n =&gt; `all ${n}`)),
     shared$.pipe(filter(n =&gt; n % 2 === 0), map(n =&gt; `even ${n}`)),
     shared$.pipe(filter(n =&gt; n % 2 === 1), map(n =&gt; `odd ${n}`)),
 ))
)
.subscribe(console.log);

// Expected output: (notice only one subscription)
"subscription started"
"source emitted 1"
"all 1"
"odd 1"
"source emitted 2"
"all 2"
"even 2"
"source emitted 3"
"all 3"
"odd 3"
"source emitted 4"
"all 4"
"even 4"
"source emitted 5"
"all 5"
"odd 5"</pre>  </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://rxjs.dev/api/operators/connect" class="_attribution-link" target="_blank">https://rxjs.dev/api/operators/connect</a>
  </p>
</div>
