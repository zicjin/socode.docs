   <h1>distinct</h1> <p><code class="api-type-label function">function</code> <code class="api-status-label stable">stable</code></p>   <aio-toc class="embedded"></aio-toc> <div class="api-body"> 
<p>Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.</p>  <h3 data-language="typescript"><code>distinct&lt;T, K&gt;(keySelector?: (value: T) =&gt; K, flushes?: Observable&lt;any&gt;): MonoTypeOperatorFunction&lt;T&gt;</code></h3> <h4 class="no-anchor">Parameters</h4> <table> <tbody> <tr class="function-overload-parameter"> <td class="param-name">
keySelector</td> <td class="param-description"> <p>Optional. Default is <code>undefined</code>.</p> <p>Optional function to select which value you want to check as distinct.</p> </td> </tr> <tr class="function-overload-parameter"> <td class="param-name">
flushes</td> <td class="param-description"> <p>Optional. Default is <code>undefined</code>.</p> <p>Optional Observable for flushing the internal HashSet of the operator.</p> </td> </tr> </tbody> </table> <h4 class="no-anchor">Returns</h4> <p><code>MonoTypeOperatorFunction&lt;T&gt;</code>: A function that returns an Observable that emits items from the source Observable with distinct values.</p>  <h2>Description</h2> <p>If a keySelector function is provided, then it will project each value from the source observable into a new value that it will check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the source observable directly with an equality check against previous values.</p> <p>In JavaScript runtimes that support <code>Set</code>, this operator will use a <code>Set</code> to improve performance of the distinct value checking.</p> <p>In other runtimes, this operator will use a minimal implementation of <code>Set</code> that relies on an <code>Array</code> and <code>indexOf</code> under the hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running <code>distinct</code> use might result in memory leaks. To help alleviate this in some scenarios, an optional <code>flushes</code> parameter is also provided so that the internal <code>Set</code> can be "flushed", basically clearing it of values.</p> <h2>Examples</h2> <p>A simple example with numbers</p> <pre data-language="typescript">import { of } from 'rxjs';
import { distinct } from 'rxjs/operators';

of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)
  .pipe(
    distinct()
  )
  .subscribe(x =&gt; console.log(x));

// Outputs
// 1
// 2
// 3
// 4</pre> <p>An example using a keySelector function</p> <pre data-language="typescript">import { of } from 'rxjs';
import { distinct } from 'rxjs/operators';

interface Person {
   age: number,
   name: string
}

of(
    { age: 4, name: 'Foo'},
    { age: 7, name: 'Bar'},
    { age: 5, name: 'Foo'}
  ).pipe(
    distinct((p: Person) =&gt; p.name)
  )
  .subscribe(x =&gt; console.log(x));

// Outputs
// { age: 4, name: 'Foo' }
// { age: 7, name: 'Bar' }</pre>   <h2>See Also</h2> <ul> <li>
<a href="distinctuntilchanged"><code>distinctUntilChanged</code></a> </li> <li>
<a href="distinctuntilkeychanged"><code>distinctUntilKeyChanged</code></a> </li> </ul>  </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://rxjs.dev/api/operators/distinct" class="_attribution-link" target="_blank">https://rxjs.dev/api/operators/distinct</a>
  </p>
</div>
