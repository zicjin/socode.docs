   <h1>TestScheduler</h1> <p><code class="api-type-label class">class</code> <code class="api-status-label stable">stable</code></p>   <aio-toc class="embedded"></aio-toc> <div class="api-body">   <pre data-language="typescript">class TestScheduler extends VirtualTimeScheduler {
  static frameTimeFactor: 10
  static parseMarblesAsSubscriptions(marbles: string, runMode: boolean = false): SubscriptionLog
  static parseMarbles(marbles: string, values?: any, errorValue?: any, materializeInnerObservables: boolean = false, runMode: boolean = false): TestMessage[]
  constructor(assertDeepEqual: (actual: any, expected: any) =&gt; boolean | void)
  get hotObservables: HotObservable&lt;any&gt;[]
  get coldObservables: ColdObservable&lt;any&gt;[]
  assertDeepEqual: (actual: any, expected: any) =&gt; boolean | void
  createTime(marbles: string): number
  createColdObservable&lt;T = string&gt;(marbles: string, values?: { [marble: string]: T; }, error?: any): ColdObservable&lt;T&gt;
  createHotObservable&lt;T = string&gt;(marbles: string, values?: { [marble: string]: T; }, error?: any): HotObservable&lt;T&gt;
  expectObservable&lt;T&gt;(observable: Observable&lt;T&gt;, subscriptionMarbles: string = null)
  expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]): {...}
  flush()
  run&lt;T&gt;(callback: (helpers: RunHelpers) =&gt; T): T

  // inherited from index/VirtualTimeScheduler
  static frameTimeFactor: 10
  constructor(schedulerActionCtor: typeof AsyncAction = VirtualAction as any, maxFrames: number = Infinity)
  frame: number
  index: number
  maxFrames: number
  flush(): void
}</pre>   <h2>Static Properties</h2> <table> <thead> <tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr> </thead> <tbody> <tr class="static-property"> <td>
<code class="">frameTimeFactor</code>
</td> <td><code class="property-type-label">10</code></td> <td> <p>The number of virtual time units each character in a marble diagram represents. If the test scheduler is being used in "run mode", via the <code>run</code> method, this is temporarly set to <code>1</code> for the duration of the <code>run</code> block, then set back to whatever value it was.</p> </td> </tr> </tbody> </table>   <h2>Static Methods</h2>  <tbody> <tr> <td> <h3 data-language="typescript"><code>static parseMarblesAsSubscriptions(marbles: string, runMode: boolean = false): SubscriptionLog</code></h3> <h4 class="no-anchor">Parameters</h4> <table> <tbody> <tr class="static-method-overload-parameter"> <td class="param-name">
marbles</td> <td class="param-description"> <p>Type: <code>string</code>.</p> </td> </tr> <tr class="static-method-overload-parameter"> <td class="param-name">
runMode</td> <td class="param-description"> <p>Optional. Default is <code>false</code>.</p> <p>Type: <code>boolean</code>.</p> </td> </tr> </tbody> </table> <h4 class="no-anchor">Returns</h4> <p><code>SubscriptionLog</code></p> </td> </tr> </tbody>  <tbody> <tr> <td> <h3 data-language="typescript"><code>static parseMarbles(marbles: string, values?: any, errorValue?: any, materializeInnerObservables: boolean = false, runMode: boolean = false): TestMessage[]</code></h3> <h4 class="no-anchor">Parameters</h4> <table> <tbody> <tr class="static-method-overload-parameter"> <td class="param-name">
marbles</td> <td class="param-description"> <p>Type: <code>string</code>.</p> </td> </tr> <tr class="static-method-overload-parameter"> <td class="param-name">
values</td> <td class="param-description"> <p>Optional. Default is <code>undefined</code>.</p> <p>Type: <code>any</code>.</p> </td> </tr> <tr class="static-method-overload-parameter"> <td class="param-name">
errorValue</td> <td class="param-description"> <p>Optional. Default is <code>undefined</code>.</p> <p>Type: <code>any</code>.</p> </td> </tr> <tr class="static-method-overload-parameter"> <td class="param-name">
materializeInnerObservables</td> <td class="param-description"> <p>Optional. Default is <code>false</code>.</p> <p>Type: <code>boolean</code>.</p> </td> </tr> <tr class="static-method-overload-parameter"> <td class="param-name">
runMode</td> <td class="param-description"> <p>Optional. Default is <code>false</code>.</p> <p>Type: <code>boolean</code>.</p> </td> </tr> </tbody> </table> <h4 class="no-anchor">Returns</h4> <p><code>TestMessage[]</code></p> </td> </tr> </tbody>  <h2>Constructor</h2>  <tbody> <tr> <td> <h3 data-language="typescript"><code>constructor(assertDeepEqual: (actual: any, expected: any) =&gt; boolean | void)</code></h3> <h4 class="no-anchor">Parameters</h4> <table> <tbody> <tr class="constructor-overload-parameter"> <td class="param-name">
assertDeepEqual</td> <td class="param-description"> <p>A function to set up your assertion for your test harness</p> </td> </tr> </tbody> </table> </td> </tr> </tbody>  <h2>Properties</h2> <table> <thead> <tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr> </thead> <tbody> <tr class="instance-property"> <td>
<code class="deprecated-api-item">hotObservables</code>
</td> <td><code class="property-type-label">HotObservable&lt;any&gt;[]</code></td> <td>
<span class="read-only-property">Read-only.</span> </td> </tr> <tr class="instance-property"> <td>
<code class="deprecated-api-item">coldObservables</code>
</td> <td><code class="property-type-label">ColdObservable&lt;any&gt;[]</code></td> <td>
<span class="read-only-property">Read-only.</span> </td> </tr> <tr class="instance-property"> <td>
<code class="">assertDeepEqual</code>
</td> <td><code class="property-type-label">(actual: any, expected: any) =&gt; boolean | void</code></td> <td> <p>A function to set up your assertion for your test harness</p> <span class="from-constructor">Declared in constructor.</span> </td> </tr> </tbody> </table>   <h2>Methods</h2>  <tbody> <tr> <td> <h3 data-language="typescript" name="createTime" id="createtime-"><code>createTime(marbles: string): number</code></h3> <h4 class="no-anchor">Parameters</h4> <table> <tbody> <tr class="instance-method-overload-parameter"> <td class="param-name">
marbles</td> <td class="param-description"> <p>Type: <code>string</code>.</p> </td> </tr> </tbody> </table> <h4 class="no-anchor">Returns</h4> <p><code>number</code></p> </td> </tr> </tbody>  <tbody> <tr> <td> <h3 data-language="typescript" name="createColdObservable" id="createcoldobservable-"><code>createColdObservable&lt;T = string&gt;(marbles: string, values?: { [marble: string]: T; }, error?: any): ColdObservable&lt;T&gt;</code></h3> <h4 class="no-anchor">Parameters</h4> <table> <tbody> <tr class="instance-method-overload-parameter"> <td class="param-name">
marbles</td> <td class="param-description"> <p>A diagram in the marble DSL. Letters map to keys in <code>values</code> if provided.</p> </td> </tr> <tr class="instance-method-overload-parameter"> <td class="param-name">
values</td> <td class="param-description"> <p>Optional. Default is <code>undefined</code>.</p> <p>Values to use for the letters in <code>marbles</code>. If ommitted, the letters themselves are used.</p> </td> </tr> <tr class="instance-method-overload-parameter"> <td class="param-name">
error</td> <td class="param-description"> <p>Optional. Default is <code>undefined</code>.</p> <p>The error to use for the <code>#</code> marble (if present).</p> </td> </tr> </tbody> </table> <h4 class="no-anchor">Returns</h4> <p><code>ColdObservable&lt;T&gt;</code></p> </td> </tr> </tbody>  <tbody> <tr> <td> <h3 data-language="typescript" name="createHotObservable" id="createhotobservable-"><code>createHotObservable&lt;T = string&gt;(marbles: string, values?: { [marble: string]: T; }, error?: any): HotObservable&lt;T&gt;</code></h3> <h4 class="no-anchor">Parameters</h4> <table> <tbody> <tr class="instance-method-overload-parameter"> <td class="param-name">
marbles</td> <td class="param-description"> <p>A diagram in the marble DSL. Letters map to keys in <code>values</code> if provided.</p> </td> </tr> <tr class="instance-method-overload-parameter"> <td class="param-name">
values</td> <td class="param-description"> <p>Optional. Default is <code>undefined</code>.</p> <p>Values to use for the letters in <code>marbles</code>. If ommitted, the letters themselves are used.</p> </td> </tr> <tr class="instance-method-overload-parameter"> <td class="param-name">
error</td> <td class="param-description"> <p>Optional. Default is <code>undefined</code>.</p> <p>The error to use for the <code>#</code> marble (if present).</p> </td> </tr> </tbody> </table> <h4 class="no-anchor">Returns</h4> <p><code>HotObservable&lt;T&gt;</code></p> </td> </tr> </tbody>  <tbody> <tr> <td> <h3 data-language="typescript" name="expectObservable" id="expectobservable-"><code>expectObservable&lt;T&gt;(observable: Observable&lt;T&gt;, subscriptionMarbles: string = null)</code></h3> <h4 class="no-anchor">Parameters</h4> <table> <tbody> <tr class="instance-method-overload-parameter"> <td class="param-name">
observable</td> <td class="param-description"> <p>Type: <code>Observable</code>.</p> </td> </tr> <tr class="instance-method-overload-parameter"> <td class="param-name">
subscriptionMarbles</td> <td class="param-description"> <p>Optional. Default is <code>null</code>.</p> <p>Type: <code>string</code>.</p> </td> </tr> </tbody> </table> </td> </tr> </tbody>  <tbody> <tr> <td> <h3 data-language="typescript" name="expectSubscriptions" id="expectsubscriptions-"><code>expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]): {
    toBe: subscriptionLogsToBeFn;
}</code></h3> <h4 class="no-anchor">Parameters</h4> <table> <tbody> <tr class="instance-method-overload-parameter"> <td class="param-name">
actualSubscriptionLogs</td> <td class="param-description"> <p>Type: <code>SubscriptionLog[]</code>.</p> </td> </tr> </tbody> </table> <h4 class="no-anchor">Returns</h4> <p><code>{ toBe: subscriptionLogsToBeFn; }</code></p> </td> </tr> </tbody>  <tbody> <tr> <td> <h3 data-language="typescript" name="flush" id="flush-"><code>flush()</code></h3> <h4 class="no-anchor">Parameters</h4> <p>There are no parameters.</p> </td> </tr> </tbody>  <tbody> <tr> <td class="short-description">  </td> </tr> <tr> <td> <h3 data-language="typescript" name="run" id="run-"><code>run&lt;T&gt;(callback: (helpers: RunHelpers) =&gt; T): T</code></h3>
<p>The <code>run</code> method performs the test in 'run mode' - in which schedulers used within the test automatically delegate to the <code>TestScheduler</code>. That is, in 'run mode' there is no need to explicitly pass a <code>TestScheduler</code> instance to observable creators or operators.</p> <h4 class="no-anchor">Parameters</h4> <table> <tbody> <tr class="instance-method-overload-parameter"> <td class="param-name">
callback</td> <td class="param-description"> <p>Type: <code>(helpers: RunHelpers) =&gt; T</code>.</p> </td> </tr> </tbody> </table> <h4 class="no-anchor">Returns</h4> <p><code>T</code></p> </td> </tr> </tbody>  </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://rxjs.dev/api/testing/TestScheduler" class="_attribution-link" target="_blank">https://rxjs.dev/api/testing/TestScheduler</a>
  </p>
</div>
