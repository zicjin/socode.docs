   <h1>timer</h1> <p><code class="api-type-label function">function</code> <code class="api-status-label stable">stable</code></p>   <aio-toc class="embedded"></aio-toc> <div class="api-body">  <h3 data-language="typescript"><code>timer(dueTime: number | Date = 0, intervalOrScheduler?: number | SchedulerLike, scheduler: SchedulerLike = asyncScheduler): Observable&lt;number&gt;</code></h3> <h4 class="no-anchor">Parameters</h4> <table> <tbody> <tr class="function-overload-parameter"> <td class="param-name">
dueTime</td> <td class="param-description"> <p>Optional. Default is <code>0</code>.</p> <p>Type: <code>number | Date</code>.</p> </td> </tr> <tr class="function-overload-parameter"> <td class="param-name">
intervalOrScheduler</td> <td class="param-description"> <p>Optional. Default is <code>undefined</code>.</p> <p>Type: <code>number | SchedulerLike</code>.</p> </td> </tr> <tr class="function-overload-parameter"> <td class="param-name">
scheduler</td> <td class="param-description"> <p>Optional. Default is <code>asyncScheduler</code>.</p> <p>Type: <code>SchedulerLike</code>.</p> </td> </tr> </tbody> </table> <h4 class="no-anchor">Returns</h4> <p><code>Observable&lt;number&gt;</code></p>  <h2>Overloads</h2>
<h3 data-language="typescript"><code>timer(due: number | Date, scheduler?: SchedulerLike): Observable&lt;0&gt;</code></h3>
<div class="short-description"> <p>Creates an observable that will wait for a specified time period, or exact date, before emitting the number 0.</p> </div>
<h4 class="no-anchor">Parameters</h4>
<table> <tbody> <tr class="function-overload-parameter"> <td class="param-name">
due</td> <td class="param-description"> <p> If a <code>number</code>, the amount of time in milliseconds to wait before emitting. If a <code>Date</code>, the exact time at which to emit.</p> </td> </tr> <tr class="function-overload-parameter"> <td class="param-name">
scheduler</td> <td class="param-description"> <p>Optional. Default is <code>undefined</code>.</p> <p>The scheduler to use to schedule the delay. Defaults to <a href="../const/asyncscheduler"><code>asyncScheduler</code></a>.</p> </td> </tr> </tbody> </table>
<h4 class="no-anchor">Returns</h4>
<p><code>Observable&lt;0&gt;</code></p>
<div class="description"> <p><span class="informal">Used to emit a notification after a delay.</span></p> <p>This observable is useful for creating delays in code, or racing against other values for ad-hoc timeouts.</p> <p>The <code>delay</code> is specified by default in milliseconds, however providing a custom scheduler could create a different behavior.</p> <h2>Examples</h2> <h4>Wait 3 seconds and start another observable</h4> <p>You might want to use <code>timer</code> to delay subscription to an observable by a set amount of time. Here we use a timer with <a href="../../operators/concatmapto"><code>concatMapTo</code></a> or <a href="../../operators/concatmap"><code>concatMap</code></a> in order to wait a few seconds and start a subscription to a source.</p> <pre data-language="typescript">import { timer, of } from 'rxjs';
import { concatMapTo } from 'rxjs/operators';

// This could be any observable
const source = of(1, 2, 3);

const result = timer(3000).pipe(
  concatMapTo(source)
)
.subscribe(console.log);</pre> <h4>Take all of the values until the start of the next minute</h4> <p>Using the a date as the trigger for the first emission, you can do things like wait until midnight to fire an event, or in this case, wait until a new minute starts (chosen so the example wouldn't take too long to run) in order to stop watching a stream. Leveraging <a href="../../operators/takeuntil"><code>takeUntil</code></a>.</p> <pre data-language="typescript">import { interval, timer } from 'rxjs';
import { takeUntil } from 'rxjs/operators';

// Build a Date object that marks the
// next minute.
const currentDate = new Date();
const startOfNextMinute = new Date(
  currentDate.getFullYear(),
  currentDate.getMonth(),
  currentDate.getDate(),
  currentDate.getHours(),
  currentDate.getMinutes() + 1,
)

// This could be any observable stream
const source = interval(1000);

const result = source.pipe(
  takeUntil(timer(startOfNextMinute))
);

result.subscribe(console.log);</pre> <h4>Known Limitations</h4> <ul> <li> <p>The <a href="../const/asyncscheduler"><code>asyncScheduler</code></a> uses <code>setTimeout</code> which has limitations for how far in the future it can be scheduled.</p> </li> <li> <p>If a <code>scheduler</code> is provided that returns a timestamp other than an epoch from <code>now()</code>, and a <code>Date</code> object is passed to the <code>dueTime</code> argument, the calculation for when the first emission should occur will be incorrect. In this case, it would be best to do your own calculations ahead of time, and pass a <code>number</code> in as the <code>dueTime</code>.</p> </li> </ul> </div>
<h3 data-language="typescript"><code>timer(startDue: number | Date, intervalDuration: number, scheduler?: SchedulerLike): Observable&lt;number&gt;</code></h3>
<div class="short-description"> <p>Creates an observable that starts an interval after a specified delay, emitting incrementing numbers -- starting at <code>0</code> -- on each interval after words.</p> </div>
<h4 class="no-anchor">Parameters</h4>
<table> <tbody> <tr class="function-overload-parameter"> <td class="param-name">
startDue</td> <td class="param-description"> <p> If a <code>number</code>, is the time to wait before starting the interval. If a <code>Date</code>, is the exact time at which to start the interval.</p> </td> </tr> <tr class="function-overload-parameter"> <td class="param-name">
intervalDuration</td> <td class="param-description"> <p> The delay between each value emitted in the interval. Passing a negative number here will result in immediate completion after the first value is emitted, as though no <code>intervalDuration</code> was passed at all.</p> </td> </tr> <tr class="function-overload-parameter"> <td class="param-name">
scheduler</td> <td class="param-description"> <p>Optional. Default is <code>undefined</code>.</p> <p>The scheduler to use to schedule the delay. Defaults to <a href="../const/asyncscheduler"><code>asyncScheduler</code></a>.</p> </td> </tr> </tbody> </table>
<h4 class="no-anchor">Returns</h4>
<p><code>Observable&lt;number&gt;</code></p>
<div class="description"> <p>The <code>delay</code> and <code>intervalDuration</code> are specified by default in milliseconds, however providing a custom scheduler could create a different behavior.</p> <h2>Example</h2> <h4>Start an interval that starts right away</h4> <p>Since <a href="interval"><code>interval</code></a> waits for the passed delay before starting, sometimes that's not ideal. You may want to start an interval immediately. <code>timer</code> works well for this. Here we have both side-by-side so you can see them in comparison.</p> <p>Note that this observable will never complete.</p> <pre data-language="typescript">import { timer, interval } from 'rxjs';

timer(0, 1000).subscribe(n =&gt; console.log('timer', n));
interval(1000).subscribe(n =&gt; console.log('interval', n));</pre> <h4>Known Limitations</h4> <ul> <li> <p>The <a href="../const/asyncscheduler"><code>asyncScheduler</code></a> uses <code>setTimeout</code> which has limitations for how far in the future it can be scheduled.</p> </li> <li> <p>If a <code>scheduler</code> is provided that returns a timestamp other than an epoch from <code>now()</code>, and a <code>Date</code> object is passed to the <code>dueTime</code> argument, the calculation for when the first emission should occur will be incorrect. In this case, it would be best to do your own calculations ahead of time, and pass a <code>number</code> in as the <code>startDue</code>.</p> </li> </ul> </div>
<h3 data-language="typescript"><code>timer(dueTime: number | Date, unused: undefined, scheduler?: SchedulerLike): Observable&lt;0&gt;</code></h3>
<div class="deprecated"> <h4>Deprecation Notes</h4> <p>The signature allowing <code>undefined</code> to be passed for <code>intervalDuration</code> will be removed in v8. Use the <code>timer(dueTime, scheduler?)</code> signature instead.</p> </div>
<h4 class="no-anchor">Parameters</h4>
<table> <tbody> <tr class="function-overload-parameter"> <td class="param-name">
dueTime</td> <td class="param-description"> <p>Type: <code>number | Date</code>.</p> </td> </tr> <tr class="function-overload-parameter"> <td class="param-name">
unused</td> <td class="param-description"> <p>Type: <code>undefined</code>.</p> </td> </tr> <tr class="function-overload-parameter"> <td class="param-name">
scheduler</td> <td class="param-description"> <p>Optional. Default is <code>undefined</code>.</p> <p>Type: <code>SchedulerLike</code>.</p> </td> </tr> </tbody> </table>
<h4 class="no-anchor">Returns</h4>
<p><code>Observable&lt;0&gt;</code></p>   </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://rxjs.dev/api/index/function/timer" class="_attribution-link" target="_blank">https://rxjs.dev/api/index/function/timer</a>
  </p>
</div>
