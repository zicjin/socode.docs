   <h1>firstValueFrom</h1> <p><code class="api-type-label function">function</code> <code class="api-status-label stable">stable</code></p>   <aio-toc class="embedded"></aio-toc> <div class="api-body"> 
<p>Converts an observable to a promise by subscribing to the observable, and returning a promise that will resolve as soon as the first value arrives from the observable. The subscription will then be closed.</p>  <h3 data-language="typescript"><code>firstValueFrom&lt;T, D&gt;(source: Observable&lt;T&gt;, config?: FirstValueFromConfig&lt;D&gt;): Promise&lt;T | D&gt;</code></h3> <h4 class="no-anchor">Parameters</h4> <table> <tbody> <tr class="function-overload-parameter"> <td class="param-name">
source</td> <td class="param-description"> <p>the observable to convert to a promise</p> </td> </tr> <tr class="function-overload-parameter"> <td class="param-name">
config</td> <td class="param-description"> <p>Optional. Default is <code>undefined</code>.</p> <p>a configuration object to define the <code>defaultValue</code> to use if the source completes without emitting a value</p> </td> </tr> </tbody> </table> <h4 class="no-anchor">Returns</h4> <p><code>Promise&lt;T | D&gt;</code></p>  <h2>Description</h2> <p>If the observable stream completes before any values were emitted, the returned promise will reject with <a href="../interface/emptyerror"><code>EmptyError</code></a> or will resolve with the default value if a default was specified.</p> <p>If the observable stream emits an error, the returned promise will reject with that error.</p> <p><strong>WARNING</strong>: Only use this with observables you <em>know</em> will emit at least one value, <em>OR</em> complete. If the source observable does not emit one value or complete, you will end up with a promise that is hung up, and potentially all of the state of an async function hanging out in memory. To avoid this situation, look into adding something like <a href="../../operators/timeout"><code>timeout</code></a>, <a href="../../operators/take"><code>take</code></a>, <a href="../../operators/takewhile"><code>takeWhile</code></a>, or <a href="../../operators/takeuntil"><code>takeUntil</code></a> amongst others.</p> <h4>Example</h4> <p>Wait for the first value from a stream and emit it from a promise in an async function.</p> <pre data-language="typescript">import { interval, firstValueFrom } from 'rxjs';

async function execute() {
  const source$ = interval(2000);
  const firstNumber = await firstValueFrom(source$);
  console.log(`The first number is ${firstNumber}`);
}

execute();

// Expected output:
// "The first number is 0"</pre>   <h2>See Also</h2> <ul> <li>
<a href="lastvaluefrom"><code>lastValueFrom</code></a> </li> </ul>  </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://rxjs.dev/api/index/function/firstValueFrom" class="_attribution-link" target="_blank">https://rxjs.dev/api/index/function/firstValueFrom</a>
  </p>
</div>
