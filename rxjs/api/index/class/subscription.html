   <h1>Subscription</h1> <p><code class="api-type-label class">class</code> <code class="api-status-label stable">stable</code></p>   <aio-toc class="embedded"></aio-toc> <div class="api-body"> 
<p>Represents a disposable resource, such as the execution of an Observable. A Subscription has one important method, <code>unsubscribe</code>, that takes no argument and just disposes the resource held by the subscription.</p>   <pre data-language="typescript">class Subscription implements SubscriptionLike {
  static EMPTY: (() =&gt; {...})
  constructor(initialTeardown?: () =&gt; void)
  closed: false
  unsubscribe(): void
  add(teardown: TeardownLogic): void
  remove(teardown: Subscription | Unsubscribable | (() =&gt; void)): void
}</pre> <div class="descendants class"> <h2>Subclasses</h2> <ul> <li> <code>Subscriber</code> </li> </ul> </div>   <h2>Description</h2> <p>Additionally, subscriptions may be grouped together through the <code>add()</code> method, which will attach a child Subscription to the current Subscription. When a Subscription is unsubscribed, all its children (and its grandchildren) will be unsubscribed as well.</p>   <h2>Static Properties</h2> <table> <thead> <tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr> </thead> <tbody> <tr class="static-property"> <td>
<code class="">EMPTY</code>
</td> <td><code class="property-type-label">(() =&gt; {
    const empty = new Subscription();
    empty.closed = true;
    return empty;
})()</code></td> <td> </td> </tr> </tbody> </table>  <h2>Constructor</h2>  <tbody> <tr> <td> <h3 data-language="typescript"><code>constructor(initialTeardown?: () =&gt; void)</code></h3> <h4 class="no-anchor">Parameters</h4> <table> <tbody> <tr class="constructor-overload-parameter"> <td class="param-name">
initialTeardown</td> <td class="param-description"> <p> Optional. Default is <code>undefined</code>.</p> <p> A function executed first as part of the teardown process that is kicked off when <a href="subscription#unsubscribe">unsubscribe</a> is called.</p> </td> </tr> </tbody> </table> </td> </tr> </tbody>  <h2>Properties</h2> <table> <thead> <tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr> </thead> <tbody> <tr class="instance-property"> <td>
<code class="">closed</code>
</td> <td><code class="property-type-label">false</code></td> <td> <p>A flag to indicate whether this Subscription has already been unsubscribed.</p> </td> </tr> </tbody> </table>   <h2>Methods</h2>  <tbody> <tr> <td class="short-description">  </td> </tr> <tr> <td> <h3 data-language="typescript" name="unsubscribe" id="unsubscribe-"><code>unsubscribe(): void</code></h3>
<p>Disposes the resources held by the subscription. May, for instance, cancel an ongoing Observable execution or cancel any other type of work that started when the Subscription was created.</p> <h4 class="no-anchor">Parameters</h4> <p>There are no parameters.</p> <h4 class="no-anchor">Returns</h4> <p><code>void</code>: </p> </td> </tr> </tbody>  <tbody> <tr> <td class="short-description">  </td> </tr> <tr> <td> <h3 data-language="typescript" name="add" id="add-"><code>add(teardown: TeardownLogic): void</code></h3>
<p>Adds a teardown to this subscription, so that teardown will be unsubscribed/called when this subscription is unsubscribed. If this subscription is already <a href="subscription#closed">closed</a>, because it has already been unsubscribed, then whatever teardown is passed to it will automatically be executed (unless the teardown itself is also a closed subscription).</p> <h4 class="no-anchor">Parameters</h4> <table> <tbody> <tr class="instance-method-overload-parameter"> <td class="param-name">
teardown</td> <td class="param-description"> <p>The teardown logic to add to this subscription.</p> </td> </tr> </tbody> </table> <h4 class="no-anchor">Returns</h4> <p><code>void</code></p> </td> </tr> <tr> <td class="description"> <p>Closed Subscriptions cannot be added as teardowns to any subscription. Adding a closed subscription to a any subscription will result in no operation. (A noop).</p> <p>Adding a subscription to itself, or adding <code>null</code> or <code>undefined</code> will not perform any operation at all. (A noop).</p> <p><code>Subscription</code> instances that are added to this instance will automatically remove themselves if they are unsubscribed. Functions and <a href="../interface/unsubscribable"><code>Unsubscribable</code></a> objects that you wish to remove will need to be removed manually with <a href="subscription#remove">remove</a></p> </td> </tr> </tbody>  <tbody> <tr> <td class="short-description">  </td> </tr> <tr> <td> <h3 data-language="typescript" name="remove" id="remove-"><code>remove(teardown: Subscription | Unsubscribable | (() =&gt; void)): void</code></h3>
<p>Removes a teardown from this subscription that was previously added with the <a href="subscription#add">add</a> method.</p> <h4 class="no-anchor">Parameters</h4> <table> <tbody> <tr class="instance-method-overload-parameter"> <td class="param-name">
teardown</td> <td class="param-description"> <p>The teardown to remove from this subscription</p> </td> </tr> </tbody> </table> <h4 class="no-anchor">Returns</h4> <p><code>void</code></p> </td> </tr> <tr> <td class="description"> <p>Note that <code>Subscription</code> instances, when unsubscribed, will automatically remove themselves from every other <code>Subscription</code> they have been added to. This means that using the <code>remove</code> method is not a common thing and should be used thoughtfully.</p> <p>If you add the same teardown instance of a function or an unsubscribable object to a <code>Subcription</code> instance more than once, you will need to call <code>remove</code> the same number of times to remove all instances.</p> <p>All teardown instances are removed to free up memory upon unsubscription.</p> </td> </tr> </tbody>  </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://rxjs.dev/api/index/class/Subscription" class="_attribution-link" target="_blank">https://rxjs.dev/api/index/class/Subscription</a>
  </p>
</div>
