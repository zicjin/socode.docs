  <div id="layout"> <div id="layout-content"><div id="language.types.declarations" class="sect1"> <h2 class="title">Type declarations</h2> <p class="para"> Type declarations can be added to function arguments, return values, and, as of PHP 7.4.0, class properties. They ensure that the value is of the specified type at call time, otherwise a <a href="class.typeerror" class="classname">TypeError</a> is thrown. </p> <blockquote class="note">
<p><strong class="note">Note</strong>: </p>
<p class="para"> When overriding a parent method, the child's method must match any return type declaration on the parent. If the parent doesn't define a return type, then the child method may do so. </p> </blockquote> <div class="sect2" id="language.types.declarations.base"> <h3 class="title">Single types</h3> <table class="doctable informaltable"> <thead> <tr> <th>Type</th> <th>Description</th> <th>Version</th> </tr> </thead> <tbody class="tbody"> <tr> <td>Class/interface name</td> <td> The value must be an <a href="language.operators.type" class="link"><code class="literal">instanceof</code></a> the given class or interface. </td> <td class="empty"> </td> </tr> <tr> <td><span class="type"><span class="type self">self</span></span></td> <td> The value must be an <a href="language.operators.type" class="link"><code class="literal">instanceof</code></a> the same class as the one the method is defined on. Can only be used in classes. </td> <td class="empty"> </td> </tr> <tr> <td><span class="type">array</span></td> <td> The value must be an <span class="type">array</span>. </td> <td class="empty"> </td> </tr> <tr> <td><span class="type"><a href="language.types.callable" class="type callable">callable</a></span></td> <td> The value must be a valid <span class="type"><a href="language.types.callable" class="type callable">callable</a></span>. Cannot be used as a class property type declaration. </td> <td class="empty"> </td> </tr> <tr> <td><span class="type">bool</span></td> <td> The value must be a boolean value. </td> <td class="empty"> </td> </tr> <tr> <td><span class="type">float</span></td> <td> The value must be a floating point number. </td> <td class="empty"> </td> </tr> <tr> <td><span class="type">int</span></td> <td> The value must be an integer. </td> <td class="empty"> </td> </tr> <tr> <td><span class="type">string</span></td> <td> The value must be a <span class="type">string</span>. </td> <td class="empty"> </td> </tr> <tr> <td><span class="type"><a href="language.types.iterable" class="type iterable">iterable</a></span></td> <td> The value must be either an <span class="type">array</span> or an <a href="language.operators.type" class="link"><code class="literal">instanceof</code></a> <a href="class.traversable" class="classname">Traversable</a>. </td> <td>PHP 7.1.0</td> </tr> <tr> <td><span class="type">object</span></td> <td> The value must be an <span class="type">object</span>. </td> <td>PHP 7.2.0</td> </tr> <tr> <td><span class="type"><a href="language.types.declarations#language.types.declarations.mixed" class="type mixed">mixed</a></span></td> <td> The value can be any value. </td> <td>PHP 8.0.0</td> </tr> </tbody> </table> <div class="warning">
<strong class="warning">Warning</strong> <p class="para"> Aliases for the above scalar types are not supported. Instead, they are treated as class or interface names. For example, using <code class="literal">boolean</code> as a type declaration will require the value to be an <a href="language.operators.type" class="link"><code class="literal">instanceof</code></a> the class or interface <code class="literal">boolean</code>, rather than of type <span class="type">bool</span>: </p> 
<div class="example" id="example-79"> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
    function test(boolean $param) {}
    test(true);
?&gt;</pre> </div> <div class="example-contents"><p>Output of the above example in PHP 8:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
Warning: "boolean" will be interpreted as a class name. Did you mean "bool"? Write "\boolean" to suppress this warning in /in/9YrUX on line 2

Fatal error: Uncaught TypeError: test(): Argument #1 ($param) must be of type boolean, bool given, called in - on line 3 and defined in -:2
Stack trace:
#0 -(3): test(true)
#1 {main}
  thrown in - on line 2
</pre></div> </div> </div> </div> <div class="sect3" id="language.types.declarations.mixed"> <h4 class="title">mixed</h4> <p class="para"> <span class="type"><a href="language.types.declarations#language.types.declarations.mixed" class="type mixed">mixed</a></span> is equivalent to the <a href="language.types.declarations#language.types.declarations.union" class="link">union type</a> <span class="type"> <span class="type">array</span>|<span class="type">bool</span>|<span class="type"><a href="language.types.callable" class="type callable">callable</a></span>|<span class="type">int</span>|<span class="type">float</span> |<span class="type">object</span>|<span class="type">resource</span>|<span class="type">string</span>|<span class="type">null</span> </span>. Available as of PHP 8.0.0. </p> </div> <div class="sect3" id="language.types.declarations.examples"> <h4 class="title">Examples</h4> <div class="example" id="example-80"> <p><strong>Example #1 Basic class type declaration</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
class C {}
class D extends C {}

// This doesn't extend C.
class E {}

function f(C $c) {
    echo get_class($c)."\n";
}

f(new C);
f(new D);
f(new E);
?&gt;</pre> </div> <div class="example-contents"><p>Output of the above example in PHP 8:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
C
D

Fatal error: Uncaught TypeError: f(): Argument #1 ($c) must be of type C, E given, called in /in/gLonb on line 14 and defined in /in/gLonb:8
Stack trace:
#0 -(14): f(Object(E))
#1 {main}
  thrown in - on line 8
</pre></div> </div> </div> <div class="example" id="language.types.array.examples.loop"> <p><strong>Example #2 Basic interface type declaration</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
interface I { public function f(); }
class C implements I { public function f() {} }

// This doesn't implement I.
class E {}

function f(I $i) {
    echo get_class($i)."\n";
}

f(new C);
f(new E);
?&gt;</pre> </div> <div class="example-contents"><p>Output of the above example in PHP 8:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
C

Fatal error: Uncaught TypeError: f(): Argument #1 ($i) must be of type I, E given, called in - on line 13 and defined in -:8
Stack trace:
#0 -(13): f(Object(E))
#1 {main}
  thrown in - on line 8
</pre></div> </div> </div> <div class="example" id="language.types.array.examples.changeloop"> <p><strong>Example #3 Basic return type declaration</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
function sum($a, $b): float {
    return $a + $b;
}

// Note that a float will be returned.
var_dump(sum(1, 2));
?&gt;</pre> </div> <div class="example-contents"><p>The above example will output:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
float(3)
</pre></div> </div> </div> <div class="example" id="example-83"> <p><strong>Example #4 Returning an object</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
class C {}

function getC(): C {
    return new C;
}

var_dump(getC());
?&gt;</pre> </div> <div class="example-contents"><p>The above example will output:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
object(C)#1 (0) {
}
</pre></div> </div> </div> </div> </div> <div class="sect2" id="language.types.declarations.nullable"> <h3 class="title">Nullable type</h3> <p class="para"> As of PHP 7.1.0, type declarations can be marked nullable by prefixing the type name with a question mark (<code class="literal">?</code>). This signifies that the value can be of the specified type or <strong><code>null</code></strong>. </p> 
<div class="example" id="example-84"> <p><strong>Example #5 Nullable argument type declaration</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
class C {}

function f(?C $c) {
    var_dump($c);
}

f(new C);
f(null);
?&gt;</pre> </div> <div class="example-contents"><p>The above example will output:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
object(C)#1 (0) {
}
NULL
</pre></div> </div> </div> <div class="example" id="example-85"> <p><strong>Example #6 Nullable return type declaration</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
function get_item(): ?string {
    if (isset($_GET['item'])) {
        return $_GET['item'];
    } else {
        return null;
    }
}
?&gt;</pre> </div> </div> <blockquote class="note">
<p><strong class="note">Note</strong>: </p>
<p class="para"> Prior to PHP 7.1.0, it was possible to achieve nullable arguments by making <code class="literal">null</code> the default value. This is not recommended as this breaks during inheritance. </p> <div class="example" id="example-86"> <p><strong>Example #7 Old way to make arguments nullable</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
class C {}

function f(C $c = null) {
    var_dump($c);
}

f(new C);
f(null);
?&gt;</pre> </div> <div class="example-contents"><p>The above example will output:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
object(C)#1 (0) {
}
NULL
</pre></div> </div> </div> </blockquote> </div> <div class="sect2" id="language.types.declarations.union"> <h3 class="title">Union types</h3> <p class="para"> A union type declaration accepts values of multiple different types, rather than a single one. Union types are specified using the syntax <code class="literal">T1|T2|...</code>. Union types are available as of PHP 8.0.0. </p> <div class="sect3" id="language.types.declarations.union.nullable"> <h4 class="title">Nullable union types</h4> <p class="para"> The <code class="literal">null</code> type is supported as part of unions, such that <code class="literal">T1|T2|null</code> can be used to create a nullable union. The existing <code class="literal">?T</code> notation is considered a shorthand for the common case of <code class="literal">T|null</code>. </p> <div class="caution">
<strong class="caution">Caution</strong> <p class="simpara"> <code class="literal">null</code> cannot be used as a standalone type. </p> </div> </div> <div class="sect3" id="language.types.declarations.union.false"> <h4 class="title">false pseudo-type</h4> <p class="para"> The <code class="literal">false</code> literal type is supported as part of unions, and is included as for historical reasons many internal functions return <code class="literal">false</code> instead of <code class="literal">null</code> for failures. A classic example of such a function is <span class="function"><a href="function.strpos" class="function">strpos()</a></span>. </p> <div class="caution">
<strong class="caution">Caution</strong> <p class="simpara"> <code class="literal">false</code> cannot be used as a standalone type (including nullable standalone type). As such, all of <code class="literal">false</code>, <code class="literal">false|null</code> and <code class="literal">?false</code> are not permitted. </p> </div> <div class="caution">
<strong class="caution">Caution</strong> <p class="simpara"> The <code class="literal">true</code> literal type does <em class="emphasis">not</em> exist. </p> </div> </div> <div class="sect3" id="language.types.declarations.union.redundant"> <h4 class="title">Duplicate and redundant types</h4> <p class="para"> To catch simple bugs in union type declarations, redundant types that can be detected without performing class loading will result in a compile-time error. This includes: </p>
<ul class="itemizedlist"> <li class="listitem"> <span class="simpara"> Each name-resolved type may only occur once. Types such as <code class="literal">int|string|INT</code> result in an error. </span> </li> <li class="listitem"> <span class="simpara"> If <span class="type">bool</span> is used, <span class="type"><span class="type false">false</span></span> cannot be used additionally. </span> </li> <li class="listitem"> <span class="simpara"> If <span class="type">object</span> is used, class types cannot be used additionally. </span> </li> <li class="listitem"> <span class="simpara"> If <span class="type"><a href="language.types.iterable" class="type iterable">iterable</a></span> is used, <span class="type">array</span> and <a href="class.traversable" class="classname">Traversable</a> cannot be used additionally. </span> </li> </ul> <blockquote class="note"><p><strong class="note">Note</strong>: <span class="simpara"> This does not guarantee that the type is “minimal”, because doing so would require loading all used class types. </span> </p></blockquote> <p class="para"> For example, if <code class="literal">A</code> and <code class="literal">B</code> are class aliases, then <code class="literal">A|B</code> remains a legal union type, even though it could be reduced to either <code class="literal">A</code> or <code class="literal">B</code>. Similarly, if class <code class="code">B extends A {}</code>, then <code class="literal">A|B</code> is also a legal union type, even though it could be reduced to just <code class="literal">A</code>. </p>
<div class="informalexample"> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
function foo(): int|INT {} // Disallowed
function foo(): bool|false {} // Disallowed

use A as B;
function foo(): A|B {} // Disallowed ("use" is part of name resolution)

class_alias('X', 'Y');
function foo(): X|Y {} // Allowed (redundancy is only known at runtime)
?&gt;</pre> </div> </div> </div> </div> <div class="sect2" id="language.types.declarations.return-only"> <h3 class="title">Return only types</h3> <div class="sect3" id="language.types.declarations.void"> <h4 class="title">void</h4> <p class="para"> <code class="literal">void</code> is a return type indicating the function does not return a value. Therefore it cannot be part of a union type declaration. Available as of PHP 7.1.0. </p> </div> <div class="sect3" id="language.types.declarations.static"> <h4 class="title">static</h4> <p class="para"> The value must be an <a href="language.operators.type" class="link"><code class="literal">instanceof</code></a> the same class as the one the method is called in. Available as of PHP 8.0.0. </p> </div> </div> <div class="sect2" id="language.types.declarations.strict"> <h3 class="title">Strict typing</h3> <p class="para"> By default, PHP will coerce values of the wrong type into the expected scalar type declaration if possible. For example, a function that is given an <span class="type">int</span> for a parameter that expects a <span class="type">string</span> will get a variable of type <span class="type">string</span>. </p> <p class="para"> It is possible to enable strict mode on a per-file basis. In strict mode, only a value corresponding exactly to the type declaration will be accepted, otherwise a <a href="class.typeerror" class="classname">TypeError</a> will be thrown. The only exception to this rule is that an <span class="type">int</span> value will pass a <span class="type">float</span> type declaration. </p> <div class="warning">
<strong class="warning">Warning</strong> <p class="simpara"> Function calls from within internal functions will not be affected by the <code class="literal">strict_types</code> declaration. </p> </div> <p class="para"> To enable strict mode, the <a href="control-structures.declare" class="link"><code class="literal">declare</code></a> statement is used with the <code class="literal">strict_types</code> declaration: </p> <blockquote class="note">
<p><strong class="note">Note</strong>: </p>
<p class="para"> Strict typing applies to function calls made from <em class="emphasis">within</em> the file with strict typing enabled, not to the functions declared within that file. If a file without strict typing enabled makes a call to a function that was defined in a file with strict typing, the caller's preference (coercive typing) will be respected, and the value will be coerced. </p> </blockquote> <blockquote class="note">
<p><strong class="note">Note</strong>: </p>
<p class="para"> Strict typing is only defined for scalar type declarations. </p> </blockquote> <div class="example" id="example-87"> <p><strong>Example #8 Strict typing for arguments values</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1.5, 2.5));
?&gt;</pre> </div> <div class="example-contents"><p>Output of the above example in PHP 8:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
int(3)

Fatal error: Uncaught TypeError: sum(): Argument #1 ($a) must be of type int, float given, called in - on line 9 and defined in -:4
Stack trace:
#0 -(9): sum(1.5, 2.5)
#1 {main}
  thrown in - on line 4
</pre></div> </div> </div> <div class="example" id="example-88"> <p><strong>Example #9 Coercive typing for argument values</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));

// These will be coerced to integers: note the output below!
var_dump(sum(1.5, 2.5));
?&gt;</pre> </div> <div class="example-contents"><p>The above example will output:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
int(3)
int(3)
</pre></div> </div> </div> <div class="example" id="example-89"> <p><strong>Example #10 Strict typing for return values</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
declare(strict_types=1);

function sum($a, $b): int {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1, 2.5));
?&gt;</pre> </div> <div class="example-contents"><p>The above example will output:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
int(3)

Fatal error: Uncaught TypeError: sum(): Return value must be of type int, float returned in -:5
Stack trace:
#0 -(9): sum(1, 2.5)
#1 {main}
  thrown in - on line 5
</pre></div> </div> </div> </div> <div class="sect2" id="language.types.declarations.union.coercive"> <h3 class="title">Coercive typing with union types</h3> <p class="para"> When <code class="literal">strict_types</code> is not enabled, scalar type declarations are subject to limited implicit type coercions. If the exact type of the value is not part of the union, then the target type is chosen in the following order of preference: </p>
<ol type="1"> <li class="listitem"> <span class="simpara"> <span class="type">int</span> </span> </li> <li class="listitem"> <span class="simpara"> <span class="type">float</span> </span> </li> <li class="listitem"> <span class="simpara"> <span class="type">string</span> </span> </li> <li class="listitem"> <span class="simpara"> <span class="type">bool</span> </span> </li> </ol> If the type both exists in the union, and the value can be coerced to the type under PHPs existing type checking semantics, then the type is chosen. Otherwise the next type is tried. <div class="caution">
<strong class="caution">Caution</strong> <p class="para"> As an exception, if the value is a string and both int and float are part of the union, the preferred type is determined by the existing “numeric string” semantics. For example, for <code class="literal">"42"</code> <span class="type">int</span> is chosen, while for <code class="literal">"42.0"</code> <span class="type">float</span> is chosen. </p> </div> <blockquote class="note">
<p><strong class="note">Note</strong>: </p>
<p class="para"> Types that are not part of the above preference list are not eligible targets for implicit coercion. In particular no implicit coercions to the <code class="literal">null</code> and <code class="literal">false</code> types occur. </p> </blockquote> <div class="example" id="example-90"> <p><strong>Example #11 Example of types being coerced into a type part of the union</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
// int|string
42    --&gt; 42          // exact type
"42"  --&gt; "42"        // exact type
new ObjectWithToString --&gt; "Result of __toString()"
                      // object never compatible with int, fall back to string
42.0  --&gt; 42          // float compatible with int
42.1  --&gt; 42          // float compatible with int
1e100 --&gt; "1.0E+100"  // float too large for int type, fall back to string
INF   --&gt; "INF"       // float too large for int type, fall back to string
true  --&gt; 1           // bool compatible with int
[]    --&gt; TypeError   // array not compatible with int or string

// int|float|bool
"45"    --&gt; 45        // int numeric string
"45.0"  --&gt; 45.0      // float numeric string

"45X"   --&gt; true      // not numeric string, fall back to bool
""      --&gt; false     // not numeric string, fall back to bool
"X"     --&gt; true      // not numeric string, fall back to bool
[]      --&gt; TypeError // array not compatible with int, float or bool
?&gt;</pre> </div> </div> </div> <div class="sect2" id="language.types.declarations.misc"> <h3 class="title">Misc</h3> <div class="example" id="example-91"> <p><strong>Example #12 Typed pass-by-reference Parameters</strong></p> <div class="example-contents"><p> Declared types of reference parameters are checked on function entry, but not when the function returns, so after the function had returned, the argument's type may have changed. </p></div> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
function array_baz(array &amp;$param)
{
    $param = 1;
}
$var = [];
array_baz($var);
var_dump($var);
array_baz($var);
?&gt;</pre> </div> <div class="example-contents"><p>Output of the above example in PHP 8:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
int(1)

Fatal error: Uncaught TypeError: array_baz(): Argument #1 ($param) must be of type array, int given, called in - on line 9 and defined in -:2
Stack trace:
#0 -(9): array_baz(1)
#1 {main}
  thrown in - on line 2
</pre></div> </div> </div> <div class="example" id="example-92"> <p><strong>Example #13 Catching <a href="class.typeerror" class="classname">TypeError</a></strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

try {
    var_dump(sum(1, 2));
    var_dump(sum(1.5, 2.5));
} catch (TypeError $e) {
    echo 'Error: ', $e-&gt;getMessage();
}
?&gt;</pre> </div> <div class="example-contents"><p>Output of the above example in PHP 8:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
int(3)
Error: sum(): Argument #1 ($a) must be of type int, float given, called in - on line 10
</pre></div> </div> </div> </div> </div></div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1997&ndash;2020 The PHP Documentation Group<br>Licensed under the Creative Commons Attribution License v3.0 or later.<br>
    <a href="https://www.php.net/manual/en/language.types.declarations.php" class="_attribution-link">https://www.php.net/manual/en/language.types.declarations.php</a>
  </p>
</div>
