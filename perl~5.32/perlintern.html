<h1>perlintern</h1>   <h2><a id="toc">CONTENTS</a></h2> <ul> <li> <a class="text-decoration-none" href="#NAME">NAME</a> </li> <li> <a class="text-decoration-none" href="#DESCRIPTION">DESCRIPTION </a> </li> <li> <a class="text-decoration-none" href="#Array-Manipulation-Functions">Array Manipulation Functions</a> </li> <li> <a class="text-decoration-none" href="#Compile-time-scope-hooks">Compile-time scope hooks</a> </li> <li> <a class="text-decoration-none" href="#Custom-Operators">Custom Operators</a> </li> <li> <a class="text-decoration-none" href="#CV-Manipulation-Functions">CV Manipulation Functions</a> </li> <li> <a class="text-decoration-none" href="#CV-reference-counts-and-CvOUTSIDE">CV reference counts and CvOUTSIDE</a> </li> <li> <a class="text-decoration-none" href="#Embedding-Functions">Embedding Functions</a> </li> <li> <a class="text-decoration-none" href="#Errno">Errno</a> </li> <li> <a class="text-decoration-none" href="#GV-Functions">GV Functions</a> </li> <li> <a class="text-decoration-none" href="#Hash-Manipulation-Functions">Hash Manipulation Functions</a> </li> <li> <a class="text-decoration-none" href="#IO-Functions">IO Functions</a> </li> <li> <a class="text-decoration-none" href="#Lexer-interface">Lexer interface</a> </li> <li> <a class="text-decoration-none" href="#Magical-Functions">Magical Functions</a> </li> <li> <a class="text-decoration-none" href="#Miscellaneous-Functions">Miscellaneous Functions</a> </li> <li> <a class="text-decoration-none" href="#MRO-Functions">MRO Functions</a> </li> <li> <a class="text-decoration-none" href="#Numeric-functions">Numeric functions</a> </li> <li> <a class="text-decoration-none" href="#Obsolete-backwards-compatibility-functions">Obsolete backwards compatibility functions</a> </li> <li> <a class="text-decoration-none" href="#Optree-Manipulation-Functions">Optree Manipulation Functions</a> </li> <li> <a class="text-decoration-none" href="#Pad-Data-Structures">Pad Data Structures</a> </li> <li> <a class="text-decoration-none" href="#Per-Interpreter-Variables">Per-Interpreter Variables</a> </li> <li> <a class="text-decoration-none" href="#Stack-Manipulation-Macros">Stack Manipulation Macros</a> </li> <li> <a class="text-decoration-none" href="#SV-Flags">SV Flags</a> </li> <li> <a class="text-decoration-none" href="#SV-Manipulation-Functions">SV Manipulation Functions</a> </li> <li> <a class="text-decoration-none" href="#Unicode-Support">Unicode Support</a> </li> <li> <a class="text-decoration-none" href="#Undocumented-functions">Undocumented functions</a> </li> <li> <a class="text-decoration-none" href="#AUTHORS">AUTHORS</a> </li> <li> <a class="text-decoration-none" href="#SEE-ALSO">SEE ALSO</a> </li> </ul> <h2 id="NAME">NAME</h2> <p>perlintern - autogenerated documentation of purely <b>internal</b> Perl functions</p> <h2 id="DESCRIPTION">DESCRIPTION </h2> <p>This file is the autogenerated documentation of functions in the Perl interpreter that are documented using Perl's internal documentation format but are not marked as part of the Perl API. In other words, <b>they are not for use in extensions</b>!</p> <h2 id="Array-Manipulation-Functions">
Array Manipulation Functions</h2> <dl> <dt id="AvFILLp">AvFILLp </dt> <dd> <pre data-language="perl"><code>int     AvFILLp(AV* av)</code></pre> </dd> </dl> <h2 id="Compile-time-scope-hooks">
Compile-time scope hooks</h2> <dl> <dt id="BhkENTRY">BhkENTRY </dt> <dd> <p>NOTE: this function is experimental and may change or be removed without notice.</p> <p>Return an entry from the BHK structure. <code>which</code> is a preprocessor token indicating which entry to return. If the appropriate flag is not set this will return <code>NULL</code>. The type of the return value depends on which entry you ask for.</p> <pre data-language="perl"><code>void *  BhkENTRY(BHK *hk, which)</code></pre> </dd> <dt id="BhkFLAGS">BhkFLAGS </dt> <dd> <p>NOTE: this function is experimental and may change or be removed without notice.</p> <p>Return the BHK's flags.</p> <pre data-language="perl"><code>U32     BhkFLAGS(BHK *hk)</code></pre> </dd> <dt id="CALL_BLOCK_HOOKS">CALL_BLOCK_HOOKS </dt> <dd> <p>NOTE: this function is experimental and may change or be removed without notice.</p> <p>Call all the registered block hooks for type <code>which</code>. <code>which</code> is a preprocessing token; the type of <code>arg</code> depends on <code>which</code>.</p> <pre data-language="perl"><code>void    CALL_BLOCK_HOOKS(which, arg)</code></pre> </dd> </dl> <h2 id="Custom-Operators">
Custom Operators</h2> <dl> <dt id="core_prototype">core_prototype </dt> <dd> <p>This function assigns the prototype of the named core function to <code>sv</code>, or to a new mortal SV if <code>sv</code> is <code>NULL</code>. It returns the modified <code>sv</code>, or <code>NULL</code> if the core function has no prototype. <code>code</code> is a code as returned by <code>keyword()</code>. It must not be equal to 0.</p> <pre data-language="perl"><code>SV *    core_prototype(SV *sv, const char *name,
                       const int code,
                       int * const opnum)</code></pre> </dd> </dl> <h2 id="CV-Manipulation-Functions">
CV Manipulation Functions</h2> <dl> <dt id="docatch">docatch </dt> <dd> <p>Check for the cases 0 or 3 of cur_env.je_ret, only used inside an eval context.</p> <p>0 is used as continue inside eval,</p> <p>3 is used for a die caught by an inner eval - continue inner loop</p> <p>See <i>cop.h</i>: je_mustcatch, when set at any runlevel to TRUE, means eval ops must establish a local jmpenv to handle exception traps.</p> <pre data-language="perl"><code>OP*     docatch(Perl_ppaddr_t firstpp)</code></pre> </dd> </dl> <h2 id="CV-reference-counts-and-CvOUTSIDE">
CV reference counts and CvOUTSIDE</h2> <dl> <dt id="CvWEAKOUTSIDE">CvWEAKOUTSIDE </dt> <dd> <p>Each CV has a pointer, <code>CvOUTSIDE()</code>, to its lexically enclosing CV (if any). Because pointers to anonymous sub prototypes are stored in <code>&amp;</code> pad slots, it is a possible to get a circular reference, with the parent pointing to the child and vice-versa. To avoid the ensuing memory leak, we do not increment the reference count of the CV pointed to by <code>CvOUTSIDE</code> in the <i>one specific instance</i> that the parent has a <code>&amp;</code> pad slot pointing back to us. In this case, we set the <code>CvWEAKOUTSIDE</code> flag in the child. This allows us to determine under what circumstances we should decrement the refcount of the parent when freeing the child.</p> <p>There is a further complication with non-closure anonymous subs (i.e. those that do not refer to any lexicals outside that sub). In this case, the anonymous prototype is shared rather than being cloned. This has the consequence that the parent may be freed while there are still active children, <i>e.g.</i>,</p> <pre data-language="perl"><code class="prettyprint">BEGIN { $a = sub { eval '$x' } }</code></pre> <p>In this case, the BEGIN is freed immediately after execution since there are no active references to it: the anon sub prototype has <code>CvWEAKOUTSIDE</code> set since it's not a closure, and $a points to the same CV, so it doesn't contribute to BEGIN's refcount either. When $a is executed, the <code>eval '$x'</code> causes the chain of <code>CvOUTSIDE</code>s to be followed, and the freed BEGIN is accessed.</p> <p>To avoid this, whenever a CV and its associated pad is freed, any <code>&amp;</code> entries in the pad are explicitly removed from the pad, and if the refcount of the pointed-to anon sub is still positive, then that child's <code>CvOUTSIDE</code> is set to point to its grandparent. This will only occur in the single specific case of a non-closure anon prototype having one or more active references (such as <code>$a</code> above).</p> <p>One other thing to consider is that a CV may be merely undefined rather than freed, eg <code>undef &amp;foo</code>. In this case, its refcount may not have reached zero, but we still delete its pad and its <code>CvROOT</code> etc. Since various children may still have their <code>CvOUTSIDE</code> pointing at this undefined CV, we keep its own <code>CvOUTSIDE</code> for the time being, so that the chain of lexical scopes is unbroken. For example, the following should print 123:</p> <pre data-language="perl"><code class="prettyprint">my $x = 123;
sub tmp { sub { eval '$x' } }
my $a = tmp();
undef &amp;tmp;
print  $a-&gt;();

    bool    CvWEAKOUTSIDE(CV *cv)</code></pre> </dd> </dl> <h2 id="Embedding-Functions">
Embedding Functions</h2> <dl> <dt id="cv_dump">cv_dump </dt> <dd> <p>dump the contents of a CV</p> <pre data-language="perl"><code>void    cv_dump(const CV *cv, const char *title)</code></pre> </dd> <dt id="cv_forget_slab">cv_forget_slab </dt> <dd> <p>When a CV has a reference count on its slab (<code>CvSLABBED</code>), it is responsible for making sure it is freed. (Hence, no two CVs should ever have a reference count on the same slab.) The CV only needs to reference the slab during compilation. Once it is compiled and <code>CvROOT</code> attached, it has finished its job, so it can forget the slab.</p> <pre data-language="perl"><code>void    cv_forget_slab(CV *cv)</code></pre> </dd> <dt id="do_dump_pad">do_dump_pad </dt> <dd> <p>Dump the contents of a padlist</p> <pre data-language="perl"><code>void    do_dump_pad(I32 level, PerlIO *file,
                    PADLIST *padlist, int full)</code></pre> </dd> <dt id="pad_alloc_name">pad_alloc_name </dt> <dd> <p>Allocates a place in the currently-compiling pad (via <a href="perlapi#pad_alloc">"pad_alloc" in perlapi</a>) and then stores a name for that entry. <code>name</code> is adopted and becomes the name entry; it must already contain the name string. <code>typestash</code> and <code>ourstash</code> and the <code>padadd_STATE</code> flag get added to <code>name</code>. None of the other processing of <a href="perlapi#pad_add_name_pvn">"pad_add_name_pvn" in perlapi</a> is done. Returns the offset of the allocated pad slot.</p> <pre data-language="perl"><code>PADOFFSET pad_alloc_name(PADNAME *name, U32 flags,
                         HV *typestash, HV *ourstash)</code></pre> </dd> <dt id="pad_block_start">pad_block_start </dt> <dd> <p>Update the pad compilation state variables on entry to a new block.</p> <pre data-language="perl"><code>void    pad_block_start(int full)</code></pre> </dd> <dt id="pad_check_dup">pad_check_dup </dt> <dd> <p>Check for duplicate declarations: report any of:</p> <pre data-language="perl"><code class="prettyprint">* a 'my' in the current scope with the same name;
* an 'our' (anywhere in the pad) with the same name and the
  same stash as 'ourstash'</code></pre> <p><code>is_our</code> indicates that the name to check is an <code>"our"</code> declaration.</p> <pre data-language="perl"><code>void    pad_check_dup(PADNAME *name, U32 flags,
                      const HV *ourstash)</code></pre> </dd> <dt id="pad_findlex">pad_findlex </dt> <dd> <p>Find a named lexical anywhere in a chain of nested pads. Add fake entries in the inner pads if it's found in an outer one.</p> <p>Returns the offset in the bottom pad of the lex or the fake lex. <code>cv</code> is the CV in which to start the search, and seq is the current <code>cop_seq</code> to match against. If <code>warn</code> is true, print appropriate warnings. The <code>out_</code>* vars return values, and so are pointers to where the returned values should be stored. <code>out_capture</code>, if non-null, requests that the innermost instance of the lexical is captured; <code>out_name</code> is set to the innermost matched pad name or fake pad name; <code>out_flags</code> returns the flags normally associated with the <code>PARENT_FAKELEX_FLAGS</code> field of a fake pad name.</p> <p>Note that <code>pad_findlex()</code> is recursive; it recurses up the chain of CVs, then comes back down, adding fake entries as it goes. It has to be this way because fake names in anon protoypes have to store in <code>xpadn_low</code> the index into the parent pad.</p> <pre data-language="perl"><code>PADOFFSET pad_findlex(const char *namepv,
                      STRLEN namelen, U32 flags,
                      const CV* cv, U32 seq, int warn,
                      SV** out_capture,
                      PADNAME** out_name,
                      int *out_flags)</code></pre> </dd> <dt id="pad_fixup_inner_anons">pad_fixup_inner_anons </dt> <dd> <p>For any anon CVs in the pad, change <code>CvOUTSIDE</code> of that CV from <code>old_cv</code> to <code>new_cv</code> if necessary. Needed when a newly-compiled CV has to be moved to a pre-existing CV struct.</p> <pre data-language="perl"><code>void    pad_fixup_inner_anons(PADLIST *padlist,
                              CV *old_cv, CV *new_cv)</code></pre> </dd> <dt id="pad_free">pad_free </dt> <dd> <p>Free the SV at offset po in the current pad.</p> <pre data-language="perl"><code>void    pad_free(PADOFFSET po)</code></pre> </dd> <dt id="pad_leavemy">pad_leavemy </dt> <dd> <p>Cleanup at end of scope during compilation: set the max seq number for lexicals in this scope and warn of any lexicals that never got introduced.</p> <pre data-language="perl"><code>OP *    pad_leavemy()</code></pre> </dd> <dt id="padlist_dup">padlist_dup </dt> <dd> <p>Duplicates a pad.</p> <pre data-language="perl"><code>PADLIST * padlist_dup(PADLIST *srcpad,
                      CLONE_PARAMS *param)</code></pre> </dd> <dt id="padname_dup">padname_dup </dt> <dd> <p>Duplicates a pad name.</p> <pre data-language="perl"><code>PADNAME * padname_dup(PADNAME *src, CLONE_PARAMS *param)</code></pre> </dd> <dt id="padnamelist_dup">padnamelist_dup </dt> <dd> <p>Duplicates a pad name list.</p> <pre data-language="perl"><code>PADNAMELIST * padnamelist_dup(PADNAMELIST *srcpad,
                              CLONE_PARAMS *param)</code></pre> </dd> <dt id="pad_push">pad_push </dt> <dd> <p>Push a new pad frame onto the padlist, unless there's already a pad at this depth, in which case don't bother creating a new one. Then give the new pad an <code>@_</code> in slot zero.</p> <pre data-language="perl"><code>void    pad_push(PADLIST *padlist, int depth)</code></pre> </dd> <dt id="pad_reset">pad_reset </dt> <dd> <p>Mark all the current temporaries for reuse</p> <pre data-language="perl"><code>void    pad_reset()</code></pre> </dd> <dt id="pad_swipe">pad_swipe </dt> <dd> <p>Abandon the tmp in the current pad at offset <code>po</code> and replace with a new one.</p> <pre data-language="perl"><code>void    pad_swipe(PADOFFSET po, bool refadjust)</code></pre> </dd> </dl> <h2 id="Errno">Errno</h2> <dl> <dt id="dSAVEDERRNO">dSAVEDERRNO </dt> <dd> <p>Declare variables needed to save <code>errno</code> and any operating system specific error number.</p> <pre data-language="perl"><code>void    dSAVEDERRNO</code></pre> </dd> <dt id="dSAVE_ERRNO">dSAVE_ERRNO </dt> <dd> <p>Declare variables needed to save <code>errno</code> and any operating system specific error number, and save them for optional later restoration by <code>RESTORE_ERRNO</code>.</p> <pre data-language="perl"><code>void    dSAVE_ERRNO</code></pre> </dd> <dt id="RESTORE_ERRNO">RESTORE_ERRNO </dt> <dd> <p>Restore <code>errno</code> and any operating system specific error number that was saved by <code>dSAVE_ERRNO</code> or <code>RESTORE_ERRNO</code>.</p> <pre data-language="perl"><code>void    RESTORE_ERRNO</code></pre> </dd> <dt id="SAVE_ERRNO">SAVE_ERRNO </dt> <dd> <p>Save <code>errno</code> and any operating system specific error number for optional later restoration by <code>RESTORE_ERRNO</code>. Requires <code>dSAVEDERRNO</code> or <code>dSAVE_ERRNO</code> in scope.</p> <pre data-language="perl"><code>void    SAVE_ERRNO</code></pre> </dd> <dt id="SETERRNO">SETERRNO </dt> <dd> <p>Set <code>errno</code>, and on VMS set <code>vaxc$errno</code>.</p> <pre data-language="perl"><code>void    SETERRNO(int errcode, int vmserrcode)</code></pre> </dd> </dl> <h2 id="GV-Functions">
GV Functions</h2> <dl> <dt id="gv_try_downgrade">gv_try_downgrade </dt> <dd> <p>NOTE: this function is experimental and may change or be removed without notice.</p> <p>If the typeglob <code>gv</code> can be expressed more succinctly, by having something other than a real GV in its place in the stash, replace it with the optimised form. Basic requirements for this are that <code>gv</code> is a real typeglob, is sufficiently ordinary, and is only referenced from its package. This function is meant to be used when a GV has been looked up in part to see what was there, causing upgrading, but based on what was found it turns out that the real GV isn't required after all.</p> <p>If <code>gv</code> is a completely empty typeglob, it is deleted from the stash.</p> <p>If <code>gv</code> is a typeglob containing only a sufficiently-ordinary constant sub, the typeglob is replaced with a scalar-reference placeholder that more compactly represents the same thing.</p> <pre data-language="perl"><code>void    gv_try_downgrade(GV* gv)</code></pre> </dd> </dl> <h2 id="Hash-Manipulation-Functions">
Hash Manipulation Functions</h2> <dl> <dt id="hv_ename_add">hv_ename_add </dt> <dd> <p>Adds a name to a stash's internal list of effective names. See <code><a href="#hv_ename_delete">"hv_ename_delete"</a></code>.</p> <p>This is called when a stash is assigned to a new location in the symbol table.</p> <pre data-language="perl"><code>void    hv_ename_add(HV *hv, const char *name, U32 len,
                     U32 flags)</code></pre> </dd> <dt id="hv_ename_delete">hv_ename_delete </dt> <dd> <p>Removes a name from a stash's internal list of effective names. If this is the name returned by <code>HvENAME</code>, then another name in the list will take its place (<code>HvENAME</code> will use it).</p> <p>This is called when a stash is deleted from the symbol table.</p> <pre data-language="perl"><code>void    hv_ename_delete(HV *hv, const char *name,
                        U32 len, U32 flags)</code></pre> </dd> <dt id="refcounted_he_chain_2hv">refcounted_he_chain_2hv </dt> <dd> <p>Generates and returns a <code>HV *</code> representing the content of a <code>refcounted_he</code> chain. <code>flags</code> is currently unused and must be zero.</p> <pre data-language="perl"><code>HV *    refcounted_he_chain_2hv(
            const struct refcounted_he *c, U32 flags
        )</code></pre> </dd> <dt id="refcounted_he_fetch_pv">refcounted_he_fetch_pv </dt> <dd> <p>Like <a href="#refcounted_he_fetch_pvn">"refcounted_he_fetch_pvn"</a>, but takes a nul-terminated string instead of a string/length pair.</p> <pre data-language="perl"><code>SV *    refcounted_he_fetch_pv(
            const struct refcounted_he *chain,
            const char *key, U32 hash, U32 flags
        )</code></pre> </dd> <dt id="refcounted_he_fetch_pvn">refcounted_he_fetch_pvn </dt> <dd> <p>Search along a <code>refcounted_he</code> chain for an entry with the key specified by <code>keypv</code> and <code>keylen</code>. If <code>flags</code> has the <code>REFCOUNTED_HE_KEY_UTF8</code> bit set, the key octets are interpreted as UTF-8, otherwise they are interpreted as Latin-1. <code>hash</code> is a precomputed hash of the key string, or zero if it has not been precomputed. Returns a mortal scalar representing the value associated with the key, or <code>&amp;PL_sv_placeholder</code> if there is no value associated with the key.</p> <pre data-language="perl"><code>SV *    refcounted_he_fetch_pvn(
            const struct refcounted_he *chain,
            const char *keypv, STRLEN keylen, U32 hash,
            U32 flags
        )</code></pre> </dd> <dt id="refcounted_he_fetch_pvs">refcounted_he_fetch_pvs </dt> <dd> <p>Like <a href="#refcounted_he_fetch_pvn">"refcounted_he_fetch_pvn"</a>, but takes a literal string instead of a string/length pair, and no precomputed hash.</p> <pre data-language="perl"><code>SV *    refcounted_he_fetch_pvs(
            const struct refcounted_he *chain, "key",
            U32 flags
        )</code></pre> </dd> <dt id="refcounted_he_fetch_sv">refcounted_he_fetch_sv </dt> <dd> <p>Like <a href="#refcounted_he_fetch_pvn">"refcounted_he_fetch_pvn"</a>, but takes a Perl scalar instead of a string/length pair.</p> <pre data-language="perl"><code>SV *    refcounted_he_fetch_sv(
            const struct refcounted_he *chain, SV *key,
            U32 hash, U32 flags
        )</code></pre> </dd> <dt id="refcounted_he_free">refcounted_he_free </dt> <dd> <p>Decrements the reference count of a <code>refcounted_he</code> by one. If the reference count reaches zero the structure's memory is freed, which (recursively) causes a reduction of its parent <code>refcounted_he</code>'s reference count. It is safe to pass a null pointer to this function: no action occurs in this case.</p> <pre data-language="perl"><code>void    refcounted_he_free(struct refcounted_he *he)</code></pre> </dd> <dt id="refcounted_he_inc">refcounted_he_inc </dt> <dd> <p>Increment the reference count of a <code>refcounted_he</code>. The pointer to the <code>refcounted_he</code> is also returned. It is safe to pass a null pointer to this function: no action occurs and a null pointer is returned.</p> <pre data-language="perl"><code>struct refcounted_he * refcounted_he_inc(
                           struct refcounted_he *he
                       )</code></pre> </dd> <dt id="refcounted_he_new_pv">refcounted_he_new_pv </dt> <dd> <p>Like <a href="#refcounted_he_new_pvn">"refcounted_he_new_pvn"</a>, but takes a nul-terminated string instead of a string/length pair.</p> <pre data-language="perl"><code>struct refcounted_he * refcounted_he_new_pv(
                           struct refcounted_he *parent,
                           const char *key, U32 hash,
                           SV *value, U32 flags
                       )</code></pre> </dd> <dt id="refcounted_he_new_pvn">refcounted_he_new_pvn </dt> <dd> <p>Creates a new <code>refcounted_he</code>. This consists of a single key/value pair and a reference to an existing <code>refcounted_he</code> chain (which may be empty), and thus forms a longer chain. When using the longer chain, the new key/value pair takes precedence over any entry for the same key further along the chain.</p> <p>The new key is specified by <code>keypv</code> and <code>keylen</code>. If <code>flags</code> has the <code>REFCOUNTED_HE_KEY_UTF8</code> bit set, the key octets are interpreted as UTF-8, otherwise they are interpreted as Latin-1. <code>hash</code> is a precomputed hash of the key string, or zero if it has not been precomputed.</p> <p><code>value</code> is the scalar value to store for this key. <code>value</code> is copied by this function, which thus does not take ownership of any reference to it, and later changes to the scalar will not be reflected in the value visible in the <code>refcounted_he</code>. Complex types of scalar will not be stored with referential integrity, but will be coerced to strings. <code>value</code> may be either null or <code>&amp;PL_sv_placeholder</code> to indicate that no value is to be associated with the key; this, as with any non-null value, takes precedence over the existence of a value for the key further along the chain.</p> <p><code>parent</code> points to the rest of the <code>refcounted_he</code> chain to be attached to the new <code>refcounted_he</code>. This function takes ownership of one reference to <code>parent</code>, and returns one reference to the new <code>refcounted_he</code>.</p> <pre data-language="perl"><code>struct refcounted_he * refcounted_he_new_pvn(
                           struct refcounted_he *parent,
                           const char *keypv,
                           STRLEN keylen, U32 hash,
                           SV *value, U32 flags
                       )</code></pre> </dd> <dt id="refcounted_he_new_pvs">refcounted_he_new_pvs </dt> <dd> <p>Like <a href="#refcounted_he_new_pvn">"refcounted_he_new_pvn"</a>, but takes a literal string instead of a string/length pair, and no precomputed hash.</p> <pre data-language="perl"><code>struct refcounted_he * refcounted_he_new_pvs(
                           struct refcounted_he *parent,
                           "key", SV *value, U32 flags
                       )</code></pre> </dd> <dt id="refcounted_he_new_sv">refcounted_he_new_sv </dt> <dd> <p>Like <a href="#refcounted_he_new_pvn">"refcounted_he_new_pvn"</a>, but takes a Perl scalar instead of a string/length pair.</p> <pre data-language="perl"><code>struct refcounted_he * refcounted_he_new_sv(
                           struct refcounted_he *parent,
                           SV *key, U32 hash, SV *value,
                           U32 flags
                       )</code></pre> </dd> </dl> <h2 id="IO-Functions">
IO Functions</h2> <dl> <dt id="start_glob">start_glob </dt> <dd> <p>NOTE: this function is experimental and may change or be removed without notice.</p> <p>Function called by <code>do_readline</code> to spawn a glob (or do the glob inside perl on VMS). This code used to be inline, but now perl uses <code>File::Glob</code> this glob starter is only used by miniperl during the build process, or when PERL_EXTERNAL_GLOB is defined. Moving it away shrinks <i>pp_hot.c</i>; shrinking <i>pp_hot.c</i> helps speed perl up.</p> <p>NOTE: this function must be explicitly called as Perl_start_glob with an aTHX_ parameter.</p> <pre data-language="perl"><code>PerlIO* Perl_start_glob(pTHX_ SV *tmpglob, IO *io)</code></pre> </dd> </dl> <h2 id="Lexer-interface">
Lexer interface</h2> <dl> <dt id="validate_proto">validate_proto </dt> <dd> <p>NOTE: this function is experimental and may change or be removed without notice.</p> <p>This function performs syntax checking on a prototype, <code>proto</code>. If <code>warn</code> is true, any illegal characters or mismatched brackets will trigger illegalproto warnings, declaring that they were detected in the prototype for <code>name</code>.</p> <p>The return value is <code>true</code> if this is a valid prototype, and <code>false</code> if it is not, regardless of whether <code>warn</code> was <code>true</code> or <code>false</code>.</p> <p>Note that <code>NULL</code> is a valid <code>proto</code> and will always return <code>true</code>.</p> <pre data-language="perl"><code>bool    validate_proto(SV *name, SV *proto, bool warn,
                       bool curstash)</code></pre> </dd> </dl> <h2 id="Magical-Functions">
Magical Functions</h2> <dl> <dt id="magic_clearhint">magic_clearhint </dt> <dd> <p>Triggered by a delete from <code>%^H</code>, records the key to <code>PL_compiling.cop_hints_hash</code>.</p> <pre data-language="perl"><code>int     magic_clearhint(SV* sv, MAGIC* mg)</code></pre> </dd> <dt id="magic_clearhints">magic_clearhints </dt> <dd> <p>Triggered by clearing <code>%^H</code>, resets <code>PL_compiling.cop_hints_hash</code>.</p> <pre data-language="perl"><code>int     magic_clearhints(SV* sv, MAGIC* mg)</code></pre> </dd> <dt id="magic_methcall">magic_methcall </dt> <dd> <p>Invoke a magic method (like FETCH).</p> <p><code>sv</code> and <code>mg</code> are the tied thingy and the tie magic.</p> <p><code>meth</code> is the name of the method to call.</p> <p><code>argc</code> is the number of args (in addition to $self) to pass to the method.</p> <p>The <code>flags</code> can be:</p> <pre data-language="perl"><code>G_DISCARD     invoke method with G_DISCARD flag and don't
              return a value
G_UNDEF_FILL  fill the stack with argc pointers to
              PL_sv_undef</code></pre> <p>The arguments themselves are any values following the <code>flags</code> argument.</p> <p>Returns the SV (if any) returned by the method, or <code>NULL</code> on failure.</p> <p>NOTE: this function must be explicitly called as Perl_magic_methcall with an aTHX_ parameter.</p> <pre data-language="perl"><code>SV*     Perl_magic_methcall(pTHX_ SV *sv,
                            const MAGIC *mg, SV *meth,
                            U32 flags, U32 argc, ...)</code></pre> </dd> <dt id="magic_sethint">magic_sethint </dt> <dd> <p>Triggered by a store to <code>%^H</code>, records the key/value pair to <code>PL_compiling.cop_hints_hash</code>. It is assumed that hints aren't storing anything that would need a deep copy. Maybe we should warn if we find a reference.</p> <pre data-language="perl"><code>int     magic_sethint(SV* sv, MAGIC* mg)</code></pre> </dd> <dt id="mg_localize">mg_localize </dt> <dd> <p>Copy some of the magic from an existing SV to new localized version of that SV. Container magic (<i>e.g.</i>, <code>%ENV</code>, <code>$1</code>, <code>tie</code>) gets copied, value magic doesn't (<i>e.g.</i>, <code>taint</code>, <code>pos</code>).</p> <p>If <code>setmagic</code> is false then no set magic will be called on the new (empty) SV. This typically means that assignment will soon follow (e.g. <span style="white-space: nowrap;"><code>'local $x = $y'</code></span>), and that will handle the magic.</p> <pre data-language="perl"><code>void    mg_localize(SV* sv, SV* nsv, bool setmagic)</code></pre> </dd> </dl> <h2 id="Miscellaneous-Functions">
Miscellaneous Functions</h2> <dl> <dt id="free_c_backtrace">free_c_backtrace </dt> <dd> <p>Deallocates a backtrace received from get_c_bracktrace.</p> <pre data-language="perl"><code>void    free_c_backtrace(Perl_c_backtrace* bt)</code></pre> </dd> <dt id="get_c_backtrace">get_c_backtrace </dt> <dd> <p>Collects the backtrace (aka "stacktrace") into a single linear malloced buffer, which the caller <b>must</b> <code>Perl_free_c_backtrace()</code>.</p> <p>Scans the frames back by <span style="white-space: nowrap;"><code>depth + skip</code></span>, then drops the <code>skip</code> innermost, returning at most <code>depth</code> frames.</p> <pre data-language="perl"><code>Perl_c_backtrace* get_c_backtrace(int max_depth,
                                  int skip)</code></pre> </dd> <dt id="quadmath_format_needed">quadmath_format_needed </dt> <dd> <p><code>quadmath_format_needed()</code> returns true if the <code>format</code> string seems to contain at least one non-Q-prefixed <code>%[efgaEFGA]</code> format specifier, or returns false otherwise.</p> <p>The format specifier detection is not complete printf-syntax detection, but it should catch most common cases.</p> <p>If true is returned, those arguments <b>should</b> in theory be processed with <code>quadmath_snprintf()</code>, but in case there is more than one such format specifier (see <a href="#quadmath_format_valid">"quadmath_format_valid"</a>), and if there is anything else beyond that one (even just a single byte), they <b>cannot</b> be processed because <code>quadmath_snprintf()</code> is very strict, accepting only one format spec, and nothing else. In this case, the code should probably fail.</p> <pre data-language="perl"><code>bool    quadmath_format_needed(const char* format)</code></pre> </dd> <dt id="quadmath_format_valid">quadmath_format_valid </dt> <dd> <p><code>quadmath_snprintf()</code> is very strict about its <code>format</code> string and will fail, returning -1, if the format is invalid. It accepts exactly one format spec.</p> <p><code>quadmath_format_valid()</code> checks that the intended single spec looks sane: begins with <code>%</code>, has only one <code>%</code>, ends with <code>[efgaEFGA]</code>, and has <code>Q</code> before it. This is not a full "printf syntax check", just the basics.</p> <p>Returns true if it is valid, false if not.</p> <p>See also <a href="#quadmath_format_needed">"quadmath_format_needed"</a>.</p> <pre data-language="perl"><code>bool    quadmath_format_valid(const char* format)</code></pre> </dd> </dl> <h2 id="MRO-Functions">
MRO Functions</h2> <dl> <dt id="mro_get_linear_isa_dfs">mro_get_linear_isa_dfs </dt> <dd> <p>Returns the Depth-First Search linearization of <code>@ISA</code> the given stash. The return value is a read-only AV*. <code>level</code> should be 0 (it is used internally in this function's recursion).</p> <p>You are responsible for <code>SvREFCNT_inc()</code> on the return value if you plan to store it anywhere semi-permanently (otherwise it might be deleted out from under you the next time the cache is invalidated).</p> <pre data-language="perl"><code>AV*     mro_get_linear_isa_dfs(HV* stash, U32 level)</code></pre> </dd> <dt id="mro_isa_changed_in">mro_isa_changed_in </dt> <dd> <p>Takes the necessary steps (cache invalidations, mostly) when the <code>@ISA</code> of the given package has changed. Invoked by the <code>setisa</code> magic, should not need to invoke directly.</p> <pre data-language="perl"><code>void    mro_isa_changed_in(HV* stash)</code></pre> </dd> <dt id="mro_package_moved">mro_package_moved </dt> <dd> <p>Call this function to signal to a stash that it has been assigned to another spot in the stash hierarchy. <code>stash</code> is the stash that has been assigned. <code>oldstash</code> is the stash it replaces, if any. <code>gv</code> is the glob that is actually being assigned to.</p> <p>This can also be called with a null first argument to indicate that <code>oldstash</code> has been deleted.</p> <p>This function invalidates isa caches on the old stash, on all subpackages nested inside it, and on the subclasses of all those, including non-existent packages that have corresponding entries in <code>stash</code>.</p> <p>It also sets the effective names (<code>HvENAME</code>) on all the stashes as appropriate.</p> <p>If the <code>gv</code> is present and is not in the symbol table, then this function simply returns. This checked will be skipped if <code>flags &amp; 1</code>.</p> <pre data-language="perl"><code>void    mro_package_moved(HV * const stash,
                          HV * const oldstash,
                          const GV * const gv,
                          U32 flags)</code></pre> </dd> </dl> <h2 id="Numeric-functions">
Numeric functions</h2> <dl> <dt id="grok_atoUV">grok_atoUV </dt> <dd> <p>parse a string, looking for a decimal unsigned integer.</p> <p>On entry, <code>pv</code> points to the beginning of the string; <code>valptr</code> points to a UV that will receive the converted value, if found; <code>endptr</code> is either NULL or points to a variable that points to one byte beyond the point in <code>pv</code> that this routine should examine. If <code>endptr</code> is NULL, <code>pv</code> is assumed to be NUL-terminated.</p> <p>Returns FALSE if <code>pv</code> doesn't represent a valid unsigned integer value (with no leading zeros). Otherwise it returns TRUE, and sets <code>*valptr</code> to that value.</p> <p>If you constrain the portion of <code>pv</code> that is looked at by this function (by passing a non-NULL <code>endptr</code>), and if the intial bytes of that portion form a valid value, it will return TRUE, setting <code>*endptr</code> to the byte following the final digit of the value. But if there is no constraint at what's looked at, all of <code>pv</code> must be valid in order for TRUE to be returned. <code>*endptr</code> is unchanged from its value on input if FALSE is returned;</p> <p>The only characters this accepts are the decimal digits '0'..'9'.</p> <p>As opposed to <a href="http://man.he.net/man3/atoi">atoi(3)</a> or <a href="http://man.he.net/man3/strtol">strtol(3)</a>, <code>grok_atoUV</code> does NOT allow optional leading whitespace, nor negative inputs. If such features are required, the calling code needs to explicitly implement those.</p> <p>Note that this function returns FALSE for inputs that would overflow a UV, or have leading zeros. Thus a single <code>0</code> is accepted, but not <code>00</code> nor <code>01</code>, <code>002</code>, <i>etc</i>.</p> <p>Background: <code>atoi</code> has severe problems with illegal inputs, it cannot be used for incremental parsing, and therefore should be avoided <code>atoi</code> and <code>strtol</code> are also affected by locale settings, which can also be seen as a bug (global state controlled by user environment).</p> <pre data-language="perl"><code>bool    grok_atoUV(const char* pv, UV* valptr,
                   const char** endptr)</code></pre> </dd> <dt id="isinfnansv">isinfnansv </dt> <dd> <p>Checks whether the argument would be either an infinity or <code>NaN</code> when used as a number, but is careful not to trigger non-numeric or uninitialized warnings. it assumes the caller has done <code>SvGETMAGIC(sv)</code> already.</p> <pre data-language="perl"><code>bool    isinfnansv(SV *sv)</code></pre> </dd> </dl> <h2 id="Obsolete-backwards-compatibility-functions">
Obsolete backwards compatibility functions</h2> <dl> <dt id="utf8n_to_uvuni">utf8n_to_uvuni </dt> <dd> <p>DEPRECATED! It is planned to remove this function from a future release of Perl. Do not use it for new code; remove it from existing code.</p> <p>Instead use <a href="perlapi#utf8_to_uvchr_buf">"utf8_to_uvchr_buf" in perlapi</a>, or rarely, <a href="perlapi#utf8n_to_uvchr">"utf8n_to_uvchr" in perlapi</a>.</p> <p>This function was useful for code that wanted to handle both EBCDIC and ASCII platforms with Unicode properties, but starting in Perl v5.20, the distinctions between the platforms have mostly been made invisible to most code, so this function is quite unlikely to be what you want. If you do need this precise functionality, use instead <code><a href="perlapi#utf8_to_uvchr_buf">NATIVE_TO_UNI(utf8_to_uvchr_buf(...))</a></code> or <code><a href="perlapi#utf8n_to_uvchr">NATIVE_TO_UNI(utf8n_to_uvchr(...))</a></code>.</p> <pre data-language="perl"><code>UV      utf8n_to_uvuni(const U8 *s, STRLEN curlen,
                       STRLEN *retlen, U32 flags)</code></pre> </dd> <dt id="utf8_to_uvuni">utf8_to_uvuni </dt> <dd> <p>DEPRECATED! It is planned to remove this function from a future release of Perl. Do not use it for new code; remove it from existing code.</p> <p>Returns the Unicode code point of the first character in the string <code>s</code> which is assumed to be in UTF-8 encoding; <code>retlen</code> will be set to the length, in bytes, of that character.</p> <p>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is one reason why this function is deprecated. The other is that only in extremely limited circumstances should the Unicode versus native code point be of any interest to you. See <a href="#utf8_to_uvuni_buf">"utf8_to_uvuni_buf"</a> for alternatives.</p> <p>If <code>s</code> points to one of the detected malformations, and UTF8 warnings are enabled, zero is returned and <code>*retlen</code> is set (if <code>retlen</code> doesn't point to NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and <code>*retlen</code> is set (if <code>retlen</code> isn't NULL) so that (<span style="white-space: nowrap;"><code>s</code> + <code>*retlen</code></span>) is the next possible position in <code>s</code> that could begin a non-malformed character. See <a href="perlapi#utf8n_to_uvchr">"utf8n_to_uvchr" in perlapi</a> for details on when the REPLACEMENT CHARACTER is returned.</p> <pre data-language="perl"><code>UV      utf8_to_uvuni(const U8 *s, STRLEN *retlen)</code></pre> </dd> <dt id="uvuni_to_utf8_flags">uvuni_to_utf8_flags </dt> <dd> <p>DEPRECATED! It is planned to remove this function from a future release of Perl. Do not use it for new code; remove it from existing code.</p> <p>Instead you almost certainly want to use <a href="perlapi#uvchr_to_utf8">"uvchr_to_utf8" in perlapi</a> or <a href="perlapi#uvchr_to_utf8_flags">"uvchr_to_utf8_flags" in perlapi</a>.</p> <p>This function is a deprecated synonym for <a href="#uvoffuni_to_utf8_flags">"uvoffuni_to_utf8_flags"</a>, which itself, while not deprecated, should be used only in isolated circumstances. These functions were useful for code that wanted to handle both EBCDIC and ASCII platforms with Unicode properties, but starting in Perl v5.20, the distinctions between the platforms have mostly been made invisible to most code, so this function is quite unlikely to be what you want.</p> <pre data-language="perl"><code>U8*     uvuni_to_utf8_flags(U8 *d, UV uv, UV flags)</code></pre> </dd> </dl> <h2 id="Optree-Manipulation-Functions">
Optree Manipulation Functions</h2> <dl> <dt id="finalize_optree">finalize_optree </dt> <dd> <p>This function finalizes the optree. Should be called directly after the complete optree is built. It does some additional checking which can't be done in the normal <code>ck_</code>xxx functions and makes the tree thread-safe.</p> <pre data-language="perl"><code>void    finalize_optree(OP* o)</code></pre> </dd> <dt id="newATTRSUB_x">newATTRSUB_x </dt> <dd> <p>Construct a Perl subroutine, also performing some surrounding jobs.</p> <p>This function is expected to be called in a Perl compilation context, and some aspects of the subroutine are taken from global variables associated with compilation. In particular, <code>PL_compcv</code> represents the subroutine that is currently being compiled. It must be non-null when this function is called, and some aspects of the subroutine being constructed are taken from it. The constructed subroutine may actually be a reuse of the <code>PL_compcv</code> object, but will not necessarily be so.</p> <p>If <code>block</code> is null then the subroutine will have no body, and for the time being it will be an error to call it. This represents a forward subroutine declaration such as <span style="white-space: nowrap;"><code>sub foo ($$);</code></span>. If <code>block</code> is non-null then it provides the Perl code of the subroutine body, which will be executed when the subroutine is called. This body includes any argument unwrapping code resulting from a subroutine signature or similar. The pad use of the code must correspond to the pad attached to <code>PL_compcv</code>. The code is not expected to include a <code>leavesub</code> or <code>leavesublv</code> op; this function will add such an op. <code>block</code> is consumed by this function and will become part of the constructed subroutine.</p> <p><code>proto</code> specifies the subroutine's prototype, unless one is supplied as an attribute (see below). If <code>proto</code> is null, then the subroutine will not have a prototype. If <code>proto</code> is non-null, it must point to a <code>const</code> op whose value is a string, and the subroutine will have that string as its prototype. If a prototype is supplied as an attribute, the attribute takes precedence over <code>proto</code>, but in that case <code>proto</code> should preferably be null. In any case, <code>proto</code> is consumed by this function.</p> <p><code>attrs</code> supplies attributes to be applied the subroutine. A handful of attributes take effect by built-in means, being applied to <code>PL_compcv</code> immediately when seen. Other attributes are collected up and attached to the subroutine by this route. <code>attrs</code> may be null to supply no attributes, or point to a <code>const</code> op for a single attribute, or point to a <code>list</code> op whose children apart from the <code>pushmark</code> are <code>const</code> ops for one or more attributes. Each <code>const</code> op must be a string, giving the attribute name optionally followed by parenthesised arguments, in the manner in which attributes appear in Perl source. The attributes will be applied to the sub by this function. <code>attrs</code> is consumed by this function.</p> <p>If <code>o_is_gv</code> is false and <code>o</code> is null, then the subroutine will be anonymous. If <code>o_is_gv</code> is false and <code>o</code> is non-null, then <code>o</code> must point to a <code>const</code> op, which will be consumed by this function, and its string value supplies a name for the subroutine. The name may be qualified or unqualified, and if it is unqualified then a default stash will be selected in some manner. If <code>o_is_gv</code> is true, then <code>o</code> doesn't point to an <code>OP</code> at all, but is instead a cast pointer to a <code>GV</code> by which the subroutine will be named.</p> <p>If there is already a subroutine of the specified name, then the new sub will either replace the existing one in the glob or be merged with the existing one. A warning may be generated about redefinition.</p> <p>If the subroutine has one of a few special names, such as <code>BEGIN</code> or <code>END</code>, then it will be claimed by the appropriate queue for automatic running of phase-related subroutines. In this case the relevant glob will be left not containing any subroutine, even if it did contain one before. In the case of <code>BEGIN</code>, the subroutine will be executed and the reference to it disposed of before this function returns.</p> <p>The function returns a pointer to the constructed subroutine. If the sub is anonymous then ownership of one counted reference to the subroutine is transferred to the caller. If the sub is named then the caller does not get ownership of a reference. In most such cases, where the sub has a non-phase name, the sub will be alive at the point it is returned by virtue of being contained in the glob that names it. A phase-named subroutine will usually be alive by virtue of the reference owned by the phase's automatic run queue. But a <code>BEGIN</code> subroutine, having already been executed, will quite likely have been destroyed already by the time this function returns, making it erroneous for the caller to make any use of the returned pointer. It is the caller's responsibility to ensure that it knows which of these situations applies.</p> <pre data-language="perl"><code>CV*     newATTRSUB_x(I32 floor, OP *o, OP *proto,
                     OP *attrs, OP *block, bool o_is_gv)</code></pre> </dd> <dt id="newXS_len_flags">newXS_len_flags </dt> <dd> <p>Construct an XS subroutine, also performing some surrounding jobs.</p> <p>The subroutine will have the entry point <code>subaddr</code>. It will have the prototype specified by the nul-terminated string <code>proto</code>, or no prototype if <code>proto</code> is null. The prototype string is copied; the caller can mutate the supplied string afterwards. If <code>filename</code> is non-null, it must be a nul-terminated filename, and the subroutine will have its <code>CvFILE</code> set accordingly. By default <code>CvFILE</code> is set to point directly to the supplied string, which must be static. If <code>flags</code> has the <code>XS_DYNAMIC_FILENAME</code> bit set, then a copy of the string will be taken instead.</p> <p>Other aspects of the subroutine will be left in their default state. If anything else needs to be done to the subroutine for it to function correctly, it is the caller's responsibility to do that after this function has constructed it. However, beware of the subroutine potentially being destroyed before this function returns, as described below.</p> <p>If <code>name</code> is null then the subroutine will be anonymous, with its <code>CvGV</code> referring to an <code>__ANON__</code> glob. If <code>name</code> is non-null then the subroutine will be named accordingly, referenced by the appropriate glob. <code>name</code> is a string of length <code>len</code> bytes giving a sigilless symbol name, in UTF-8 if <code>flags</code> has the <code>SVf_UTF8</code> bit set and in Latin-1 otherwise. The name may be either qualified or unqualified, with the stash defaulting in the same manner as for <code>gv_fetchpvn_flags</code>. <code>flags</code> may contain flag bits understood by <code>gv_fetchpvn_flags</code> with the same meaning as they have there, such as <code>GV_ADDWARN</code>. The symbol is always added to the stash if necessary, with <code>GV_ADDMULTI</code> semantics.</p> <p>If there is already a subroutine of the specified name, then the new sub will replace the existing one in the glob. A warning may be generated about the redefinition. If the old subroutine was <code>CvCONST</code> then the decision about whether to warn is influenced by an expectation about whether the new subroutine will become a constant of similar value. That expectation is determined by <code>const_svp</code>. (Note that the call to this function doesn't make the new subroutine <code>CvCONST</code> in any case; that is left to the caller.) If <code>const_svp</code> is null then it indicates that the new subroutine will not become a constant. If <code>const_svp</code> is non-null then it indicates that the new subroutine will become a constant, and it points to an <code>SV*</code> that provides the constant value that the subroutine will have.</p> <p>If the subroutine has one of a few special names, such as <code>BEGIN</code> or <code>END</code>, then it will be claimed by the appropriate queue for automatic running of phase-related subroutines. In this case the relevant glob will be left not containing any subroutine, even if it did contain one before. In the case of <code>BEGIN</code>, the subroutine will be executed and the reference to it disposed of before this function returns, and also before its prototype is set. If a <code>BEGIN</code> subroutine would not be sufficiently constructed by this function to be ready for execution then the caller must prevent this happening by giving the subroutine a different name.</p> <p>The function returns a pointer to the constructed subroutine. If the sub is anonymous then ownership of one counted reference to the subroutine is transferred to the caller. If the sub is named then the caller does not get ownership of a reference. In most such cases, where the sub has a non-phase name, the sub will be alive at the point it is returned by virtue of being contained in the glob that names it. A phase-named subroutine will usually be alive by virtue of the reference owned by the phase's automatic run queue. But a <code>BEGIN</code> subroutine, having already been executed, will quite likely have been destroyed already by the time this function returns, making it erroneous for the caller to make any use of the returned pointer. It is the caller's responsibility to ensure that it knows which of these situations applies.</p> <pre data-language="perl"><code>CV *    newXS_len_flags(const char *name, STRLEN len,
                        XSUBADDR_t subaddr,
                        const char *const filename,
                        const char *const proto,
                        SV **const_svp, U32 flags)</code></pre> </dd> <dt id="optimize_optree">optimize_optree </dt> <dd> <p>This function applies some optimisations to the optree in top-down order. It is called before the peephole optimizer, which processes ops in execution order. Note that finalize_optree() also does a top-down scan, but is called *after* the peephole optimizer.</p> <pre data-language="perl"><code>void    optimize_optree(OP* o)</code></pre> </dd> <dt id="traverse_op_tree">traverse_op_tree </dt> <dd> <p>Return the next op in a depth-first traversal of the op tree, returning NULL when the traversal is complete.</p> <p>The initial call must supply the root of the tree as both top and o.</p> <p>For now it's static, but it may be exposed to the API in the future.</p> <pre data-language="perl"><code>OP*     traverse_op_tree(OP* top, OP* o)</code></pre> </dd> </dl> <h2 id="Pad-Data-Structures">
Pad Data Structures</h2> <dl> <dt id="CX_CURPAD_SAVE">CX_CURPAD_SAVE </dt> <dd> <p>Save the current pad in the given context block structure.</p> <pre data-language="perl"><code>void    CX_CURPAD_SAVE(struct context)</code></pre> </dd> <dt id="CX_CURPAD_SV">CX_CURPAD_SV </dt> <dd> <p>Access the SV at offset <code>po</code> in the saved current pad in the given context block structure (can be used as an lvalue).</p> <pre data-language="perl"><code>SV *    CX_CURPAD_SV(struct context, PADOFFSET po)</code></pre> </dd> <dt id="PAD_BASE_SV">PAD_BASE_SV </dt> <dd> <p>Get the value from slot <code>po</code> in the base (DEPTH=1) pad of a padlist</p> <pre data-language="perl"><code>SV *    PAD_BASE_SV(PADLIST padlist, PADOFFSET po)</code></pre> </dd> <dt id="PAD_CLONE_VARS">PAD_CLONE_VARS </dt> <dd> <p>Clone the state variables associated with running and compiling pads.</p> <pre data-language="perl"><code>void    PAD_CLONE_VARS(PerlInterpreter *proto_perl,
                       CLONE_PARAMS* param)</code></pre> </dd> <dt id="PAD_COMPNAME_FLAGS">PAD_COMPNAME_FLAGS </dt> <dd> <p>Return the flags for the current compiling pad name at offset <code>po</code>. Assumes a valid slot entry.</p> <pre data-language="perl"><code>U32     PAD_COMPNAME_FLAGS(PADOFFSET po)</code></pre> </dd> <dt id="PAD_COMPNAME_GEN">PAD_COMPNAME_GEN </dt> <dd> <p>The generation number of the name at offset <code>po</code> in the current compiling pad (lvalue).</p> <pre data-language="perl"><code>STRLEN  PAD_COMPNAME_GEN(PADOFFSET po)</code></pre> </dd> <dt id="PAD_COMPNAME_GEN_set">PAD_COMPNAME_GEN_set </dt> <dd> <p>Sets the generation number of the name at offset <code>po</code> in the current ling pad (lvalue) to <code>gen</code>. STRLEN PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)</p> </dd> <dt id="PAD_COMPNAME_OURSTASH">PAD_COMPNAME_OURSTASH </dt> <dd> <p>Return the stash associated with an <code>our</code> variable. Assumes the slot entry is a valid <code>our</code> lexical.</p> <pre data-language="perl"><code>HV *    PAD_COMPNAME_OURSTASH(PADOFFSET po)</code></pre> </dd> <dt id="PAD_COMPNAME_PV">PAD_COMPNAME_PV </dt> <dd> <p>Return the name of the current compiling pad name at offset <code>po</code>. Assumes a valid slot entry.</p> <pre data-language="perl"><code>char *  PAD_COMPNAME_PV(PADOFFSET po)</code></pre> </dd> <dt id="PAD_COMPNAME_TYPE">PAD_COMPNAME_TYPE </dt> <dd> <p>Return the type (stash) of the current compiling pad name at offset <code>po</code>. Must be a valid name. Returns null if not typed.</p> <pre data-language="perl"><code>HV *    PAD_COMPNAME_TYPE(PADOFFSET po)</code></pre> </dd> <dt id="PadnameIsOUR">PadnameIsOUR </dt> <dd> <p>Whether this is an "our" variable.</p> <pre data-language="perl"><code>bool    PadnameIsOUR(PADNAME * pn)</code></pre> </dd> <dt id="PadnameIsSTATE">PadnameIsSTATE </dt> <dd> <p>Whether this is a "state" variable.</p> <pre data-language="perl"><code>bool    PadnameIsSTATE(PADNAME * pn)</code></pre> </dd> <dt id="PadnameOURSTASH">PadnameOURSTASH </dt> <dd> <p>The stash in which this "our" variable was declared.</p> <pre data-language="perl"><code>HV *    PadnameOURSTASH()</code></pre> </dd> <dt id="PadnameOUTER">PadnameOUTER </dt> <dd> <p>Whether this entry belongs to an outer pad. Entries for which this is true are often referred to as 'fake'.</p> <pre data-language="perl"><code>bool    PadnameOUTER(PADNAME * pn)</code></pre> </dd> <dt id="PadnameTYPE">PadnameTYPE </dt> <dd> <p>The stash associated with a typed lexical. This returns the <code>%Foo::</code> hash for <code>my Foo $bar</code>.</p> <pre data-language="perl"><code>HV *    PadnameTYPE(PADNAME * pn)</code></pre> </dd> <dt id="PAD_RESTORE_LOCAL">PAD_RESTORE_LOCAL </dt> <dd> <p>Restore the old pad saved into the local variable <code>opad</code> by <code>PAD_SAVE_LOCAL()</code></p> <pre data-language="perl"><code>void    PAD_RESTORE_LOCAL(PAD *opad)</code></pre> </dd> <dt id="PAD_SAVE_LOCAL">PAD_SAVE_LOCAL </dt> <dd> <p>Save the current pad to the local variable <code>opad</code>, then make the current pad equal to <code>npad</code></p> <pre data-language="perl"><code>void    PAD_SAVE_LOCAL(PAD *opad, PAD *npad)</code></pre> </dd> <dt id="PAD_SAVE_SETNULLPAD">PAD_SAVE_SETNULLPAD </dt> <dd> <p>Save the current pad then set it to null.</p> <pre data-language="perl"><code>void    PAD_SAVE_SETNULLPAD()</code></pre> </dd> <dt id="PAD_SETSV">PAD_SETSV </dt> <dd> <p>Set the slot at offset <code>po</code> in the current pad to <code>sv</code></p> <pre data-language="perl"><code>SV *    PAD_SETSV(PADOFFSET po, SV* sv)</code></pre> </dd> <dt id="PAD_SET_CUR">PAD_SET_CUR </dt> <dd> <p>Set the current pad to be pad <code>n</code> in the padlist, saving the previous current pad. NB currently this macro expands to a string too long for some compilers, so it's best to replace it with</p> <pre data-language="perl"><code class="prettyprint">SAVECOMPPAD();
PAD_SET_CUR_NOSAVE(padlist,n);


    void    PAD_SET_CUR(PADLIST padlist, I32 n)</code></pre> </dd> <dt id="PAD_SET_CUR_NOSAVE">PAD_SET_CUR_NOSAVE </dt> <dd> <p>like PAD_SET_CUR, but without the save</p> <pre data-language="perl"><code>void    PAD_SET_CUR_NOSAVE(PADLIST padlist, I32 n)</code></pre> </dd> <dt id="PAD_SV">PAD_SV </dt> <dd> <p>Get the value at offset <code>po</code> in the current pad</p> <pre data-language="perl"><code>SV *    PAD_SV(PADOFFSET po)</code></pre> </dd> <dt id="PAD_SVl">PAD_SVl </dt> <dd> <p>Lightweight and lvalue version of <code>PAD_SV</code>. Get or set the value at offset <code>po</code> in the current pad. Unlike <code>PAD_SV</code>, does not print diagnostics with -DX. For internal use only.</p> <pre data-language="perl"><code>SV *    PAD_SVl(PADOFFSET po)</code></pre> </dd> <dt id="SAVECLEARSV">SAVECLEARSV </dt> <dd> <p>Clear the pointed to pad value on scope exit. (i.e. the runtime action of <code>my</code>)</p> <pre data-language="perl"><code>void    SAVECLEARSV(SV **svp)</code></pre> </dd> <dt id="SAVECOMPPAD">SAVECOMPPAD </dt> <dd> <p>save <code>PL_comppad</code> and <code>PL_curpad</code></p> <pre data-language="perl"><code>void    SAVECOMPPAD()</code></pre> </dd> <dt id="SAVEPADSV">SAVEPADSV </dt> <dd> <p>Save a pad slot (used to restore after an iteration)</p> <p>XXX DAPM it would make more sense to make the arg a PADOFFSET void SAVEPADSV(PADOFFSET po)</p> </dd> </dl> <h2 id="Per-Interpreter-Variables">
Per-Interpreter Variables</h2> <dl> <dt id="PL_DBsingle">PL_DBsingle </dt> <dd> <p>When Perl is run in debugging mode, with the <b>-d</b> switch, this SV is a boolean which indicates whether subs are being single-stepped. Single-stepping is automatically turned on after every step. This is the C variable which corresponds to Perl's $DB::single variable. See <code><a href="#PL_DBsub">"PL_DBsub"</a></code>.</p> <pre data-language="perl"><code>SV *    PL_DBsingle</code></pre> </dd> <dt id="PL_DBsub">PL_DBsub </dt> <dd> <p>When Perl is run in debugging mode, with the <b>-d</b> switch, this GV contains the SV which holds the name of the sub being debugged. This is the C variable which corresponds to Perl's $DB::sub variable. See <code><a href="#PL_DBsingle">"PL_DBsingle"</a></code>.</p> <pre data-language="perl"><code>GV *    PL_DBsub</code></pre> </dd> <dt id="PL_DBtrace">PL_DBtrace </dt> <dd> <p>Trace variable used when Perl is run in debugging mode, with the <b>-d</b> switch. This is the C variable which corresponds to Perl's $DB::trace variable. See <code><a href="#PL_DBsingle">"PL_DBsingle"</a></code>.</p> <pre data-language="perl"><code>SV *    PL_DBtrace</code></pre> </dd> <dt id="PL_dowarn">PL_dowarn </dt> <dd> <p>The C variable that roughly corresponds to Perl's <code>$^W</code> warning variable. However, <code>$^W</code> is treated as a boolean, whereas <code>PL_dowarn</code> is a collection of flag bits.</p> <pre data-language="perl"><code>U8      PL_dowarn</code></pre> </dd> <dt id="PL_last_in_gv">PL_last_in_gv </dt> <dd> <p>The GV which was last used for a filehandle input operation. (<code>&lt;FH&gt;</code>)</p> <pre data-language="perl"><code>GV*     PL_last_in_gv</code></pre> </dd> <dt id="PL_ofsgv">PL_ofsgv </dt> <dd> <p>The glob containing the output field separator - <code>*,</code> in Perl space.</p> <pre data-language="perl"><code>GV*     PL_ofsgv</code></pre> </dd> <dt id="PL_rs">PL_rs </dt> <dd> <p>The input record separator - <code>$/</code> in Perl space.</p> <pre data-language="perl"><code>SV*     PL_rs</code></pre> </dd> </dl> <h2 id="Stack-Manipulation-Macros">
Stack Manipulation Macros</h2> <dl> <dt id="djSP">djSP </dt> <dd> <p>Declare Just <code>SP</code>. This is actually identical to <code>dSP</code>, and declares a local copy of perl's stack pointer, available via the <code>SP</code> macro. See <code><a href="perlapi#SP">"SP" in perlapi</a></code>. (Available for backward source code compatibility with the old (Perl 5.005) thread model.)</p> <pre data-language="perl"><code class="prettyprint">djSP();</code></pre> </dd> <dt id="LVRET">LVRET </dt> <dd> <p>True if this op will be the return value of an lvalue subroutine</p> </dd> </dl> <h2 id="SV-Flags">
SV Flags</h2> <dl> <dt id="SVt_INVLIST">SVt_INVLIST </dt> <dd> <p>Type flag for scalars. See <a href="perlapi#svtype">"svtype" in perlapi</a>.</p> </dd> </dl> <h2 id="SV-Manipulation-Functions">
SV Manipulation Functions</h2> <p>An SV (or AV, HV, etc.) is allocated in two parts: the head (struct sv, av, hv...) contains type and reference count information, and for many types, a pointer to the body (struct xrv, xpv, xpviv...), which contains fields specific to each type. Some types store all they need in the head, so don't have a body.</p> <p>In all but the most memory-paranoid configurations (ex: PURIFY), heads and bodies are allocated out of arenas, which by default are approximately 4K chunks of memory parcelled up into N heads or bodies. Sv-bodies are allocated by their sv-type, guaranteeing size consistency needed to allocate safely from arrays.</p> <p>For SV-heads, the first slot in each arena is reserved, and holds a link to the next arena, some flags, and a note of the number of slots. Snaked through each arena chain is a linked list of free items; when this becomes empty, an extra arena is allocated and divided up into N items which are threaded into the free list.</p> <p>SV-bodies are similar, but they use arena-sets by default, which separate the link and info from the arena itself, and reclaim the 1st slot in the arena. SV-bodies are further described later.</p> <p>The following global variables are associated with arenas:</p> <pre data-language="perl"><code>PL_sv_arenaroot     pointer to list of SV arenas
PL_sv_root          pointer to list of free SV structures

PL_body_arenas      head of linked-list of body arenas
PL_body_roots[]     array of pointers to list of free bodies of svtype
                    arrays are indexed by the svtype needed</code></pre> <p>A few special SV heads are not allocated from an arena, but are instead directly created in the interpreter structure, eg PL_sv_undef. The size of arenas can be changed from the default by setting PERL_ARENA_SIZE appropriately at compile time.</p> <p>The SV arena serves the secondary purpose of allowing still-live SVs to be located and destroyed during final cleanup.</p> <p>At the lowest level, the macros new_SV() and del_SV() grab and free an SV head. (If debugging with -DD, del_SV() calls the function S_del_sv() to return the SV to the free list with error checking.) new_SV() calls more_sv() / sv_add_arena() to add an extra arena if the free list is empty. SVs in the free list have their SvTYPE field set to all ones.</p> <p>At the time of very final cleanup, sv_free_arenas() is called from perl_destruct() to physically free all the arenas allocated since the start of the interpreter.</p> <p>The function visit() scans the SV arenas list, and calls a specified function for each SV it finds which is still live - ie which has an SvTYPE other than all 1's, and a non-zero SvREFCNT. visit() is used by the following functions (specified as [function that calls visit()] / [function called by visit() for each SV]):</p> <pre data-language="perl"><code>sv_report_used() / do_report_used()
                    dump all remaining SVs (debugging aid)

sv_clean_objs() / do_clean_objs(),do_clean_named_objs(),
                  do_clean_named_io_objs(),do_curse()
                    Attempt to free all objects pointed to by RVs,
                    try to do the same for all objects indir-
                    ectly referenced by typeglobs too, and
                    then do a final sweep, cursing any
                    objects that remain.  Called once from
                    perl_destruct(), prior to calling sv_clean_all()
                    below.

sv_clean_all() / do_clean_all()
                    SvREFCNT_dec(sv) each remaining SV, possibly
                    triggering an sv_free(). It also sets the
                    SVf_BREAK flag on the SV to indicate that the
                    refcnt has been artificially lowered, and thus
                    stopping sv_free() from giving spurious warnings
                    about SVs which unexpectedly have a refcnt
                    of zero.  called repeatedly from perl_destruct()
                    until there are no SVs left.</code></pre> <dl> <dt id="sv_2num">sv_2num </dt> <dd> <p>NOTE: this function is experimental and may change or be removed without notice.</p> <p>Return an SV with the numeric value of the source SV, doing any necessary reference or overload conversion. The caller is expected to have handled get-magic already.</p> <pre data-language="perl"><code>SV*     sv_2num(SV *const sv)</code></pre> </dd> <dt id="sv_add_arena">sv_add_arena </dt> <dd> <p>Given a chunk of memory, link it to the head of the list of arenas, and split it into a list of free SVs.</p> <pre data-language="perl"><code>void    sv_add_arena(char *const ptr, const U32 size,
                     const U32 flags)</code></pre> </dd> <dt id="sv_clean_all">sv_clean_all </dt> <dd> <p>Decrement the refcnt of each remaining SV, possibly triggering a cleanup. This function may have to be called multiple times to free SVs which are in complex self-referential hierarchies.</p> <pre data-language="perl"><code>I32     sv_clean_all()</code></pre> </dd> <dt id="sv_clean_objs">sv_clean_objs </dt> <dd> <p>Attempt to destroy all objects not yet freed.</p> <pre data-language="perl"><code>void    sv_clean_objs()</code></pre> </dd> <dt id="sv_free_arenas">sv_free_arenas </dt> <dd> <p>Deallocate the memory used by all arenas. Note that all the individual SV heads and bodies within the arenas must already have been freed.</p> <pre data-language="perl"><code>void    sv_free_arenas()</code></pre> </dd> <dt id="SvTHINKFIRST">SvTHINKFIRST </dt> <dd> <p>A quick flag check to see whether an <code>sv</code> should be passed to <code>sv_force_normal</code> to be "downgraded" before <code>SvIVX</code> or <code>SvPVX</code> can be modified directly.</p> <p>For example, if your scalar is a reference and you want to modify the <code>SvIVX</code> slot, you can't just do <code>SvROK_off</code>, as that will leak the referent.</p> <p>This is used internally by various sv-modifying functions, such as <code>sv_setsv</code>, <code>sv_setiv</code> and <code>sv_pvn_force</code>.</p> <p>One case that this does not handle is a gv without SvFAKE set. After</p> <pre data-language="perl"><code class="prettyprint">if (SvTHINKFIRST(gv)) sv_force_normal(gv);</code></pre> <p>it will still be a gv.</p> <p><code>SvTHINKFIRST</code> sometimes produces false positives. In those cases <code>sv_force_normal</code> does nothing.</p> <pre data-language="perl"><code>U32     SvTHINKFIRST(SV *sv)</code></pre> </dd> </dl> <h2 id="Unicode-Support">
Unicode Support</h2> <p>These are various utility functions for manipulating UTF8-encoded strings. For the uninitiated, this is a method of representing arbitrary Unicode characters as a variable number of bytes, in such a way that characters in the ASCII range are unmodified, and a zero byte never appears within non-zero characters.</p> <dl> <dt id="find_uninit_var">find_uninit_var </dt> <dd> <p>NOTE: this function is experimental and may change or be removed without notice.</p> <p>Find the name of the undefined variable (if any) that caused the operator to issue a "Use of uninitialized value" warning. If match is true, only return a name if its value matches <code>uninit_sv</code>. So roughly speaking, if a unary operator (such as <code>OP_COS</code>) generates a warning, then following the direct child of the op may yield an <code>OP_PADSV</code> or <code>OP_GV</code> that gives the name of the undefined variable. On the other hand, with <code>OP_ADD</code> there are two branches to follow, so we only print the variable name if we get an exact match. <code>desc_p</code> points to a string pointer holding the description of the op. This may be updated if needed.</p> <p>The name is returned as a mortal SV.</p> <p>Assumes that <code>PL_op</code> is the OP that originally triggered the error, and that <code>PL_comppad</code>/<code>PL_curpad</code> points to the currently executing pad.</p> <pre data-language="perl"><code>SV*     find_uninit_var(const OP *const obase,
                        const SV *const uninit_sv,
                        bool match, const char **desc_p)</code></pre> </dd> <dt id="isSCRIPT_RUN">isSCRIPT_RUN </dt> <dd> <p>Returns a bool as to whether or not the sequence of bytes from <code>s</code> up to but not including <code>send</code> form a "script run". <code>utf8_target</code> is TRUE iff the sequence starting at <code>s</code> is to be treated as UTF-8. To be precise, except for two degenerate cases given below, this function returns TRUE iff all code points in it come from any combination of three "scripts" given by the Unicode "Script Extensions" property: Common, Inherited, and possibly one other. Additionally all decimal digits must come from the same consecutive sequence of 10.</p> <p>For example, if all the characters in the sequence are Greek, or Common, or Inherited, this function will return TRUE, provided any decimal digits in it are from the same block of digits in Common. (These are the ASCII digits "0".."9" and additionally a block for full width forms of these, and several others used in mathematical notation.) For scripts (unlike Greek) that have their own digits defined this will accept either digits from that set or from one of the Common digit sets, but not a combination of the two. Some scripts, such as Arabic, have more than one set of digits. All digits must come from the same set for this function to return TRUE.</p> <p><code>*ret_script</code>, if <code>ret_script</code> is not NULL, will on return of TRUE contain the script found, using the <code>SCX_enum</code> typedef. Its value will be <code>SCX_INVALID</code> if the function returns FALSE.</p> <p>If the sequence is empty, TRUE is returned, but <code>*ret_script</code> (if asked for) will be <code>SCX_INVALID</code>.</p> <p>If the sequence contains a single code point which is unassigned to a character in the version of Unicode being used, the function will return TRUE, and the script will be <code>SCX_Unknown</code>. Any other combination of unassigned code points in the input sequence will result in the function treating the input as not being a script run.</p> <p>The returned script will be <code>SCX_Inherited</code> iff all the code points in it are from the Inherited script.</p> <p>Otherwise, the returned script will be <code>SCX_Common</code> iff all the code points in it are from the Inherited or Common scripts.</p> <pre data-language="perl"><code>bool    isSCRIPT_RUN(const U8 *s, const U8 *send,
                     const bool utf8_target)</code></pre> </dd> <dt id="is_utf8_non_invariant_string">is_utf8_non_invariant_string </dt> <dd> <p>Returns TRUE if <a href="perlapi#is_utf8_invariant_string">"is_utf8_invariant_string" in perlapi</a> returns FALSE for the first <code>len</code> bytes of the string <code>s</code>, but they are, nonetheless, legal Perl-extended UTF-8; otherwise returns FALSE.</p> <p>A TRUE return means that at least one code point represented by the sequence either is a wide character not representable as a single byte, or the representation differs depending on whether the sequence is encoded in UTF-8 or not.</p> <p>See also <code><a href="perlapi#is_utf8_invariant_string">"is_utf8_invariant_string" in perlapi</a></code>, <code><a href="perlapi#is_utf8_string">"is_utf8_string" in perlapi</a></code></p> <pre data-language="perl"><code>bool    is_utf8_non_invariant_string(const U8* const s,
                                     STRLEN len)</code></pre> </dd> <dt id="report_uninit">report_uninit </dt> <dd> <p>Print appropriate "Use of uninitialized variable" warning.</p> <pre data-language="perl"><code>void    report_uninit(const SV *uninit_sv)</code></pre> </dd> <dt id="utf8_to_uvuni_buf">utf8_to_uvuni_buf </dt> <dd> <p>DEPRECATED! It is planned to remove this function from a future release of Perl. Do not use it for new code; remove it from existing code.</p> <p>Only in very rare circumstances should code need to be dealing in Unicode (as opposed to native) code points. In those few cases, use <code><a href="perlapi#utf8_to_uvchr_buf">NATIVE_TO_UNI(utf8_to_uvchr_buf(...))</a></code> instead. If you are not absolutely sure this is one of those cases, then assume it isn't and use plain <code>utf8_to_uvchr_buf</code> instead.</p> <p>Returns the Unicode (not-native) code point of the first character in the string <code>s</code> which is assumed to be in UTF-8 encoding; <code>send</code> points to 1 beyond the end of <code>s</code>. <code>retlen</code> will be set to the length, in bytes, of that character.</p> <p>If <code>s</code> does not point to a well-formed UTF-8 character and UTF8 warnings are enabled, zero is returned and <code>*retlen</code> is set (if <code>retlen</code> isn't NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and <code>*retlen</code> is set (if <code>retlen</code> isn't NULL) so that (<span style="white-space: nowrap;"><code>s</code> + <code>*retlen</code></span>) is the next possible position in <code>s</code> that could begin a non-malformed character. See <a href="perlapi#utf8n_to_uvchr">"utf8n_to_uvchr" in perlapi</a> for details on when the REPLACEMENT CHARACTER is returned.</p> <pre data-language="perl"><code>UV      utf8_to_uvuni_buf(const U8 *s, const U8 *send,
                          STRLEN *retlen)</code></pre> </dd> <dt id="uvoffuni_to_utf8_flags">uvoffuni_to_utf8_flags </dt> <dd> <p>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Instead, <b>Almost all code should use <a href="perlapi#uvchr_to_utf8">"uvchr_to_utf8" in perlapi</a> or <a href="perlapi#uvchr_to_utf8_flags">"uvchr_to_utf8_flags" in perlapi</a></b>.</p> <p>This function is like them, but the input is a strict Unicode (as opposed to native) code point. Only in very rare circumstances should code not be using the native code point.</p> <p>For details, see the description for <a href="perlapi#uvchr_to_utf8_flags">"uvchr_to_utf8_flags" in perlapi</a>.</p> <pre data-language="perl"><code>U8*     uvoffuni_to_utf8_flags(U8 *d, UV uv,
                               const UV flags)</code></pre> </dd> <dt id="valid_utf8_to_uvchr">valid_utf8_to_uvchr </dt> <dd> <p>Like <code><a href="perlapi#utf8_to_uvchr_buf">"utf8_to_uvchr_buf" in perlapi</a></code>, but should only be called when it is known that the next character in the input UTF-8 string <code>s</code> is well-formed (<i>e.g.</i>, it passes <code><a href="perlapi#isUTF8_CHAR">"isUTF8_CHAR" in perlapi</a></code>. Surrogates, non-character code points, and non-Unicode code points are allowed.</p> <pre data-language="perl"><code>UV      valid_utf8_to_uvchr(const U8 *s, STRLEN *retlen)</code></pre> </dd> <dt id="variant_under_utf8_count">variant_under_utf8_count </dt> <dd> <p>This function looks at the sequence of bytes between <code>s</code> and <code>e</code>, which are assumed to be encoded in ASCII/Latin1, and returns how many of them would change should the string be translated into UTF-8. Due to the nature of UTF-8, each of these would occupy two bytes instead of the single one in the input string. Thus, this function returns the precise number of bytes the string would expand by when translated to UTF-8.</p> <p>Unlike most of the other functions that have <code>utf8</code> in their name, the input to this function is NOT a UTF-8-encoded string. The function name is slightly <i>odd</i> to emphasize this.</p> <p>This function is internal to Perl because khw thinks that any XS code that would want this is probably operating too close to the internals. Presenting a valid use case could change that.</p> <p>See also <code><a href="perlapi#is_utf8_invariant_string">"is_utf8_invariant_string" in perlapi</a></code> and <code><a href="perlapi#is_utf8_invariant_string_loc">"is_utf8_invariant_string_loc" in perlapi</a></code>,</p> <pre data-language="perl"><code>Size_t  variant_under_utf8_count(const U8* const s,
                                 const U8* const e)</code></pre> </dd> </dl> <h2 id="Undocumented-functions">
Undocumented functions</h2> <p>The following functions are currently undocumented. If you use one of them, you may wish to consider creating and submitting documentation for it.</p> <dl> <dt id="ASCII_TO_NEED">ASCII_TO_NEED </dt>  <dt id="NATIVE_TO_NEED">NATIVE_TO_NEED </dt>  <dt id="POPMARK">POPMARK </dt>  <dt id="PadnameIN_SCOPE">PadnameIN_SCOPE </dt>  <dt id="PerlIO_restore_errno">PerlIO_restore_errno </dt>  <dt id="PerlIO_save_errno">PerlIO_save_errno </dt>  <dt id="PerlLIO_dup2_cloexec">PerlLIO_dup2_cloexec </dt>  <dt id="PerlLIO_dup_cloexec">PerlLIO_dup_cloexec </dt>  <dt id="PerlLIO_open3_cloexec">PerlLIO_open3_cloexec </dt>  <dt id="PerlLIO_open_cloexec">PerlLIO_open_cloexec </dt>  <dt id="PerlProc_pipe_cloexec">PerlProc_pipe_cloexec </dt>  <dt id="PerlSock_accept_cloexec">PerlSock_accept_cloexec </dt>  <dt id="PerlSock_socket_cloexec">PerlSock_socket_cloexec </dt>  <dt id="PerlSock_socketpair_cloexec">PerlSock_socketpair_cloexec </dt>  <dt id="ReANY">ReANY </dt>  <dt id="Slab_Alloc">Slab_Alloc </dt>  <dt id="Slab_Free">Slab_Free </dt>  <dt id="Slab_to_ro">Slab_to_ro </dt>  <dt id="Slab_to_rw">Slab_to_rw </dt>  <dt id="TOPMARK">TOPMARK </dt>  <dt id="_add_range_to_invlist">
_add_range_to_invlist </dt>  <dt id="_byte_dump_string">
_byte_dump_string </dt>  <dt id="_force_out_malformed_utf8_message">
_force_out_malformed_utf8_message </dt>  <dt id="_inverse_folds">
_inverse_folds </dt>  <dt id="_invlistEQ">
_invlistEQ </dt>  <dt id="_invlist_array_init">
_invlist_array_init </dt>  <dt id="_invlist_contains_cp">
_invlist_contains_cp </dt>  <dt id="_invlist_dump">
_invlist_dump </dt>  <dt id="_invlist_intersection">
_invlist_intersection </dt>  <dt id="_invlist_intersection_maybe_complement_2nd">
_invlist_intersection_maybe_complement_2nd </dt>  <dt id="_invlist_invert">
_invlist_invert </dt>  <dt id="_invlist_len">
_invlist_len </dt>  <dt id="_invlist_search">
_invlist_search </dt>  <dt id="_invlist_subtract">
_invlist_subtract </dt>  <dt id="_invlist_union">
_invlist_union </dt>  <dt id="_invlist_union_maybe_complement_2nd">
_invlist_union_maybe_complement_2nd </dt>  <dt id="_is_cur_LC_category_utf8">
_is_cur_LC_category_utf8 </dt>  <dt id="_is_in_locale_category">
_is_in_locale_category </dt>  <dt id="_is_uni_FOO">
_is_uni_FOO </dt>  <dt id="_is_uni_perl_idcont">
_is_uni_perl_idcont </dt>  <dt id="_is_uni_perl_idstart">
_is_uni_perl_idstart </dt>  <dt id="_is_utf8_FOO">
_is_utf8_FOO </dt>  <dt id="_is_utf8_perl_idcont">
_is_utf8_perl_idcont </dt>  <dt id="_is_utf8_perl_idstart">
_is_utf8_perl_idstart </dt>  <dt id="_mem_collxfrm">
_mem_collxfrm </dt>  <dt id="_new_invlist">
_new_invlist </dt>  <dt id="_new_invlist_C_array">
_new_invlist_C_array </dt>  <dt id="_setup_canned_invlist">
_setup_canned_invlist </dt>  <dt id="_to_fold_latin1">
_to_fold_latin1 </dt>  <dt id="_to_uni_fold_flags">
_to_uni_fold_flags </dt>  <dt id="_to_upper_title_latin1">
_to_upper_title_latin1 </dt>  <dt id="_to_utf8_fold_flags">
_to_utf8_fold_flags </dt>  <dt id="_to_utf8_lower_flags">
_to_utf8_lower_flags </dt>  <dt id="_to_utf8_title_flags">
_to_utf8_title_flags </dt>  <dt id="_to_utf8_upper_flags">
_to_utf8_upper_flags </dt>  <dt id="_utf8n_to_uvchr_msgs_helper">
_utf8n_to_uvchr_msgs_helper </dt>  <dt id="_warn_problematic_locale">
_warn_problematic_locale </dt>  <dt id="abort_execution">abort_execution </dt>  <dt id="add_cp_to_invlist">add_cp_to_invlist </dt>  <dt id="alloc_LOGOP">alloc_LOGOP </dt>  <dt id="allocmy">allocmy </dt>  <dt id="amagic_cmp">amagic_cmp </dt>  <dt id="amagic_cmp_desc">amagic_cmp_desc </dt>  <dt id="amagic_cmp_locale">amagic_cmp_locale </dt>  <dt id="amagic_cmp_locale_desc">amagic_cmp_locale_desc </dt>  <dt id="amagic_i_ncmp">amagic_i_ncmp </dt>  <dt id="amagic_i_ncmp_desc">amagic_i_ncmp_desc </dt>  <dt id="amagic_is_enabled">amagic_is_enabled </dt>  <dt id="amagic_ncmp">amagic_ncmp </dt>  <dt id="amagic_ncmp_desc">amagic_ncmp_desc </dt>  <dt id="append_utf8_from_native_byte">append_utf8_from_native_byte </dt>  <dt id="apply">apply </dt>  <dt id="av_extend_guts">av_extend_guts </dt>  <dt id="av_nonelem">av_nonelem </dt>  <dt id="av_reify">av_reify </dt>  <dt id="bind_match">bind_match </dt>  <dt id="boot_core_PerlIO">boot_core_PerlIO </dt>  <dt id="boot_core_UNIVERSAL">boot_core_UNIVERSAL </dt>  <dt id="boot_core_mro">boot_core_mro </dt>  <dt id="cando">cando </dt>  <dt id="check_utf8_print">check_utf8_print </dt>  <dt id="ck_anoncode">ck_anoncode </dt>  <dt id="ck_backtick">ck_backtick </dt>  <dt id="ck_bitop">ck_bitop </dt>  <dt id="ck_cmp">ck_cmp </dt>  <dt id="ck_concat">ck_concat </dt>  <dt id="ck_defined">ck_defined </dt>  <dt id="ck_delete">ck_delete </dt>  <dt id="ck_each">ck_each </dt>  <dt id="ck_entersub_args_core">ck_entersub_args_core </dt>  <dt id="ck_eof">ck_eof </dt>  <dt id="ck_eval">ck_eval </dt>  <dt id="ck_exec">ck_exec </dt>  <dt id="ck_exists">ck_exists </dt>  <dt id="ck_ftst">ck_ftst </dt>  <dt id="ck_fun">ck_fun </dt>  <dt id="ck_glob">ck_glob </dt>  <dt id="ck_grep">ck_grep </dt>  <dt id="ck_index">ck_index </dt>  <dt id="ck_isa">ck_isa </dt>  <dt id="ck_join">ck_join </dt>  <dt id="ck_length">ck_length </dt>  <dt id="ck_lfun">ck_lfun </dt>  <dt id="ck_listiob">ck_listiob </dt>  <dt id="ck_match">ck_match </dt>  <dt id="ck_method">ck_method </dt>  <dt id="ck_null">ck_null </dt>  <dt id="ck_open">ck_open </dt>  <dt id="ck_prototype">ck_prototype </dt>  <dt id="ck_readline">ck_readline </dt>  <dt id="ck_refassign">ck_refassign </dt>  <dt id="ck_repeat">ck_repeat </dt>  <dt id="ck_require">ck_require </dt>  <dt id="ck_return">ck_return </dt>  <dt id="ck_rfun">ck_rfun </dt>  <dt id="ck_rvconst">ck_rvconst </dt>  <dt id="ck_sassign">ck_sassign </dt>  <dt id="ck_select">ck_select </dt>  <dt id="ck_shift">ck_shift </dt>  <dt id="ck_smartmatch">ck_smartmatch </dt>  <dt id="ck_sort">ck_sort </dt>  <dt id="ck_spair">ck_spair </dt>  <dt id="ck_split">ck_split </dt>  <dt id="ck_stringify">ck_stringify </dt>  <dt id="ck_subr">ck_subr </dt>  <dt id="ck_substr">ck_substr </dt>  <dt id="ck_svconst">ck_svconst </dt>  <dt id="ck_tell">ck_tell </dt>  <dt id="ck_trunc">ck_trunc </dt>  <dt id="closest_cop">closest_cop </dt>  <dt id="cmp_desc">cmp_desc </dt>  <dt id="cmp_locale_desc">cmp_locale_desc </dt>  <dt id="cmpchain_extend">cmpchain_extend </dt>  <dt id="cmpchain_finish">cmpchain_finish </dt>  <dt id="cmpchain_start">cmpchain_start </dt>  <dt id="cntrl_to_mnemonic">cntrl_to_mnemonic </dt>  <dt id="coresub_op">coresub_op </dt>  <dt id="create_eval_scope">create_eval_scope </dt>  <dt id="croak_caller">croak_caller </dt>  <dt id="croak_memory_wrap">croak_memory_wrap </dt>  <dt id="croak_no_mem">croak_no_mem </dt>  <dt id="croak_popstack">croak_popstack </dt>  <dt id="current_re_engine">current_re_engine </dt>  <dt id="custom_op_get_field">custom_op_get_field </dt>  <dt id="cv_ckproto_len_flags">cv_ckproto_len_flags </dt>  <dt id="cv_clone_into">cv_clone_into </dt>  <dt id="cv_const_sv_or_av">cv_const_sv_or_av </dt>  <dt id="cv_undef_flags">cv_undef_flags </dt>  <dt id="cvgv_from_hek">cvgv_from_hek </dt>  <dt id="cvgv_set">cvgv_set </dt>  <dt id="cvstash_set">cvstash_set </dt>  <dt id="deb_stack_all">deb_stack_all </dt>  <dt id="defelem_target">defelem_target </dt>  <dt id="delete_eval_scope">delete_eval_scope </dt>  <dt id="delimcpy_no_escape">delimcpy_no_escape </dt>  <dt id="die_unwind">die_unwind </dt>  <dt id="do_aexec">do_aexec </dt>  <dt id="do_aexec5">do_aexec5 </dt>  <dt id="do_eof">do_eof </dt>  <dt id="do_exec">do_exec </dt>  <dt id="do_exec3">do_exec3 </dt>  <dt id="do_ipcctl">do_ipcctl </dt>  <dt id="do_ipcget">do_ipcget </dt>  <dt id="do_msgrcv">do_msgrcv </dt>  <dt id="do_msgsnd">do_msgsnd </dt>  <dt id="do_ncmp">do_ncmp </dt>  <dt id="do_open6">do_open6 </dt>  <dt id="do_open_raw">do_open_raw </dt>  <dt id="do_print">do_print </dt>  <dt id="do_readline">do_readline </dt>  <dt id="do_seek">do_seek </dt>  <dt id="do_semop">do_semop </dt>  <dt id="do_shmio">do_shmio </dt>  <dt id="do_sysseek">do_sysseek </dt>  <dt id="do_tell">do_tell </dt>  <dt id="do_trans">do_trans </dt>  <dt id="do_uniprop_match">do_uniprop_match </dt>  <dt id="do_vecget">do_vecget </dt>  <dt id="do_vecset">do_vecset </dt>  <dt id="do_vop">do_vop </dt>  <dt id="does_utf8_overflow">does_utf8_overflow </dt>  <dt id="dofile">dofile </dt>  <dt id="drand48_init_r">drand48_init_r </dt>  <dt id="drand48_r">drand48_r </dt>  <dt id="dtrace_probe_call">dtrace_probe_call </dt>  <dt id="dtrace_probe_load">dtrace_probe_load </dt>  <dt id="dtrace_probe_op">dtrace_probe_op </dt>  <dt id="dtrace_probe_phase">dtrace_probe_phase </dt>  <dt id="dump_all_perl">dump_all_perl </dt>  <dt id="dump_packsubs_perl">dump_packsubs_perl </dt>  <dt id="dump_sub_perl">dump_sub_perl </dt>  <dt id="dump_sv_child">dump_sv_child </dt>  <dt id="dup_warnings">dup_warnings </dt>  <dt id="emulate_cop_io">emulate_cop_io </dt>  <dt id="find_first_differing_byte_pos">find_first_differing_byte_pos </dt>  <dt id="find_lexical_cv">find_lexical_cv </dt>  <dt id="find_runcv_where">find_runcv_where </dt>  <dt id="find_script">find_script </dt>  <dt id="foldEQ_latin1_s2_folded">foldEQ_latin1_s2_folded </dt>  <dt id="foldEQ_utf8_flags">foldEQ_utf8_flags </dt>  <dt id="form_alien_digit_msg">form_alien_digit_msg </dt>  <dt id="form_cp_too_large_msg">form_cp_too_large_msg </dt>  <dt id="free_tied_hv_pool">free_tied_hv_pool </dt>  <dt id="get_and_check_backslash_N_name">get_and_check_backslash_N_name </dt>  <dt id="get_db_sub">get_db_sub </dt>  <dt id="get_debug_opts">get_debug_opts </dt>  <dt id="get_deprecated_property_msg">get_deprecated_property_msg </dt>  <dt id="get_hash_seed">get_hash_seed </dt>  <dt id="get_invlist_iter_addr">get_invlist_iter_addr </dt>  <dt id="get_invlist_offset_addr">get_invlist_offset_addr </dt>  <dt id="get_invlist_previous_index_addr">get_invlist_previous_index_addr </dt>  <dt id="get_no_modify">get_no_modify </dt>  <dt id="get_opargs">get_opargs </dt>  <dt id="get_prop_definition">get_prop_definition </dt>  <dt id="get_prop_values">get_prop_values </dt>  <dt id="get_re_arg">get_re_arg </dt>  <dt id="get_re_gclass_nonbitmap_data">get_re_gclass_nonbitmap_data </dt>  <dt id="get_regclass_nonbitmap_data">get_regclass_nonbitmap_data </dt>  <dt id="get_regex_charset_name">get_regex_charset_name </dt>  <dt id="getenv_len">getenv_len </dt>  <dt id="grok_bin_oct_hex">grok_bin_oct_hex </dt>  <dt id="grok_bslash_c">grok_bslash_c </dt>  <dt id="grok_bslash_o">grok_bslash_o </dt>  <dt id="grok_bslash_x">grok_bslash_x </dt>  <dt id="gv_fetchmeth_internal">gv_fetchmeth_internal </dt>  <dt id="gv_override">gv_override </dt>  <dt id="gv_setref">gv_setref </dt>  <dt id="gv_stashpvn_internal">gv_stashpvn_internal </dt>  <dt id="gv_stashsvpvn_cached">gv_stashsvpvn_cached </dt>  <dt id="hfree_next_entry">hfree_next_entry </dt>  <dt id="hv_backreferences_p">hv_backreferences_p </dt>  <dt id="hv_kill_backrefs">hv_kill_backrefs </dt>  <dt id="hv_placeholders_p">hv_placeholders_p </dt>  <dt id="hv_pushkv">hv_pushkv </dt>  <dt id="hv_undef_flags">hv_undef_flags </dt>  <dt id="init_argv_symbols">init_argv_symbols </dt>  <dt id="init_constants">init_constants </dt>  <dt id="init_dbargs">init_dbargs </dt>  <dt id="init_debugger">init_debugger </dt>  <dt id="init_i18nl10n">init_i18nl10n </dt>  <dt id="init_i18nl14n">init_i18nl14n </dt>  <dt id="init_named_cv">init_named_cv </dt>  <dt id="init_uniprops">init_uniprops </dt>  <dt id="invert">invert </dt>  <dt id="invlist_array">invlist_array </dt>  <dt id="invlist_clear">invlist_clear </dt>  <dt id="invlist_clone">invlist_clone </dt>  <dt id="invlist_contents">invlist_contents </dt>  <dt id="invlist_extend">invlist_extend </dt>  <dt id="invlist_highest">invlist_highest </dt>  <dt id="invlist_is_iterating">invlist_is_iterating </dt>  <dt id="invlist_iterfinish">invlist_iterfinish </dt>  <dt id="invlist_iterinit">invlist_iterinit </dt>  <dt id="invlist_iternext">invlist_iternext </dt>  <dt id="invlist_lowest">invlist_lowest </dt>  <dt id="invlist_max">invlist_max </dt>  <dt id="invlist_previous_index">invlist_previous_index </dt>  <dt id="invlist_set_len">invlist_set_len </dt>  <dt id="invlist_set_previous_index">invlist_set_previous_index </dt>  <dt id="invlist_trim">invlist_trim </dt>  <dt id="invmap_dump">invmap_dump </dt>  <dt id="io_close">io_close </dt>  <dt id="isFF_OVERLONG">isFF_OVERLONG </dt>  <dt id="isFOO_lc">isFOO_lc </dt>  <dt id="is_grapheme">is_grapheme </dt>  <dt id="is_invlist">is_invlist </dt>  <dt id="is_utf8_char_helper">is_utf8_char_helper </dt>  <dt id="is_utf8_common">is_utf8_common </dt>  <dt id="is_utf8_overlong_given_start_byte_ok">is_utf8_overlong_given_start_byte_ok </dt>  <dt id="jmaybe">jmaybe </dt>  <dt id="keyword">keyword </dt>  <dt id="keyword_plugin_standard">keyword_plugin_standard </dt>  <dt id="list">list </dt>  <dt id="load_charnames">load_charnames </dt>  <dt id="localize">localize </dt>  <dt id="lossless_NV_to_IV">lossless_NV_to_IV </dt>  <dt id="magic_clear_all_env">magic_clear_all_env </dt>  <dt id="magic_cleararylen_p">magic_cleararylen_p </dt>  <dt id="magic_clearenv">magic_clearenv </dt>  <dt id="magic_clearisa">magic_clearisa </dt>  <dt id="magic_clearpack">magic_clearpack </dt>  <dt id="magic_clearsig">magic_clearsig </dt>  <dt id="magic_copycallchecker">magic_copycallchecker </dt>  <dt id="magic_existspack">magic_existspack </dt>  <dt id="magic_freearylen_p">magic_freearylen_p </dt>  <dt id="magic_freeovrld">magic_freeovrld </dt>  <dt id="magic_get">magic_get </dt>  <dt id="magic_getarylen">magic_getarylen </dt>  <dt id="magic_getdebugvar">magic_getdebugvar </dt>  <dt id="magic_getdefelem">magic_getdefelem </dt>  <dt id="magic_getnkeys">magic_getnkeys </dt>  <dt id="magic_getpack">magic_getpack </dt>  <dt id="magic_getpos">magic_getpos </dt>  <dt id="magic_getsig">magic_getsig </dt>  <dt id="magic_getsubstr">magic_getsubstr </dt>  <dt id="magic_gettaint">magic_gettaint </dt>  <dt id="magic_getuvar">magic_getuvar </dt>  <dt id="magic_getvec">magic_getvec </dt>  <dt id="magic_killbackrefs">magic_killbackrefs </dt>  <dt id="magic_nextpack">magic_nextpack </dt>  <dt id="magic_regdata_cnt">magic_regdata_cnt </dt>  <dt id="magic_regdatum_get">magic_regdatum_get </dt>  <dt id="magic_regdatum_set">magic_regdatum_set </dt>  <dt id="magic_scalarpack">magic_scalarpack </dt>  <dt id="magic_set">magic_set </dt>  <dt id="magic_set_all_env">magic_set_all_env </dt>  <dt id="magic_setarylen">magic_setarylen </dt>  <dt id="magic_setcollxfrm">magic_setcollxfrm </dt>  <dt id="magic_setdbline">magic_setdbline </dt>  <dt id="magic_setdebugvar">magic_setdebugvar </dt>  <dt id="magic_setdefelem">magic_setdefelem </dt>  <dt id="magic_setenv">magic_setenv </dt>  <dt id="magic_setisa">magic_setisa </dt>  <dt id="magic_setlvref">magic_setlvref </dt>  <dt id="magic_setmglob">magic_setmglob </dt>  <dt id="magic_setnkeys">magic_setnkeys </dt>  <dt id="magic_setnonelem">magic_setnonelem </dt>  <dt id="magic_setpack">magic_setpack </dt>  <dt id="magic_setpos">magic_setpos </dt>  <dt id="magic_setregexp">magic_setregexp </dt>  <dt id="magic_setsig">magic_setsig </dt>  <dt id="magic_setsubstr">magic_setsubstr </dt>  <dt id="magic_settaint">magic_settaint </dt>  <dt id="magic_setutf8">magic_setutf8 </dt>  <dt id="magic_setuvar">magic_setuvar </dt>  <dt id="magic_setvec">magic_setvec </dt>  <dt id="magic_sizepack">magic_sizepack </dt>  <dt id="magic_wipepack">magic_wipepack </dt>  <dt id="malloc_good_size">malloc_good_size </dt>  <dt id="malloced_size">malloced_size </dt>  <dt id="mem_collxfrm1">mem_collxfrm </dt>  <dt id="mem_log_alloc">mem_log_alloc </dt>  <dt id="mem_log_free">mem_log_free </dt>  <dt id="mem_log_realloc">mem_log_realloc </dt>  <dt id="mg_find_mglob">mg_find_mglob </dt>  <dt id="mode_from_discipline">mode_from_discipline </dt>  <dt id="more_bodies">more_bodies </dt>  <dt id="mortal_getenv">mortal_getenv </dt>  <dt id="mro_meta_dup">mro_meta_dup </dt>  <dt id="mro_meta_init">mro_meta_init </dt>  <dt id="multiconcat_stringify">multiconcat_stringify </dt>  <dt id="multideref_stringify">multideref_stringify </dt>  <dt id="my_atof2">my_atof2 </dt>  <dt id="my_atof3">my_atof3 </dt>  <dt id="my_attrs">my_attrs </dt>  <dt id="my_clearenv">my_clearenv </dt>  <dt id="my_lstat_flags">my_lstat_flags </dt>  <dt id="my_memrchr">my_memrchr </dt>  <dt id="my_mkostemp">my_mkostemp </dt>  <dt id="my_mkostemp_cloexec">my_mkostemp_cloexec </dt>  <dt id="my_mkstemp">my_mkstemp </dt>  <dt id="my_mkstemp_cloexec">my_mkstemp_cloexec </dt>  <dt id="my_stat_flags">my_stat_flags </dt>  <dt id="my_strerror">my_strerror </dt>  <dt id="my_unexec">my_unexec </dt>  <dt id="newGP">newGP </dt>  <dt id="newMETHOP_internal">newMETHOP_internal </dt>  <dt id="newSTUB">newSTUB </dt>  <dt id="newSVavdefelem">newSVavdefelem </dt>  <dt id="newXS_deffile">newXS_deffile </dt>  <dt id="new_warnings_bitfield">new_warnings_bitfield </dt>  <dt id="nextargv">nextargv </dt>  <dt id="noperl_die">noperl_die </dt>  <dt id="notify_parser_that_changed_to_utf8">notify_parser_that_changed_to_utf8 </dt>  <dt id="oopsAV">oopsAV </dt>  <dt id="oopsHV">oopsHV </dt>  <dt id="op_clear">op_clear </dt>  <dt id="op_integerize">op_integerize </dt>  <dt id="op_lvalue_flags">op_lvalue_flags </dt>  <dt id="op_refcnt_dec">op_refcnt_dec </dt>  <dt id="op_refcnt_inc">op_refcnt_inc </dt>  <dt id="op_relocate_sv">op_relocate_sv </dt>  <dt id="op_std_init">op_std_init </dt>  <dt id="op_unscope">op_unscope </dt>  <dt id="opmethod_stash">opmethod_stash </dt>  <dt id="opslab_force_free">opslab_force_free </dt>  <dt id="opslab_free">opslab_free </dt>  <dt id="opslab_free_nopad">opslab_free_nopad </dt>  <dt id="package">package </dt>  <dt id="package_version">package_version </dt>  <dt id="pad_add_weakref">pad_add_weakref </dt>  <dt id="padlist_store">padlist_store </dt>  <dt id="padname_free">padname_free </dt>  <dt id="padnamelist_free">padnamelist_free </dt>  <dt id="parse_unicode_opts">parse_unicode_opts </dt>  <dt id="parser_free">parser_free </dt>  <dt id="parser_free_nexttoke_ops">parser_free_nexttoke_ops </dt>  <dt id="path_is_searchable">path_is_searchable </dt>  <dt id="peep">peep </dt>  <dt id="pmruntime">pmruntime </dt>  <dt id="populate_isa">populate_isa </dt>  <dt id="ptr_hash">ptr_hash </dt>  <dt id="qerror">qerror </dt>  <dt id="re_exec_indentf">re_exec_indentf </dt>  <dt id="re_indentf">re_indentf </dt>  <dt id="re_intuit_start">re_intuit_start </dt>  <dt id="re_intuit_string">re_intuit_string </dt>  <dt id="re_op_compile">re_op_compile </dt>  <dt id="re_printf">re_printf </dt>  <dt id="reg_named_buff">reg_named_buff </dt>  <dt id="reg_named_buff_iter">reg_named_buff_iter </dt>  <dt id="reg_numbered_buff_fetch">reg_numbered_buff_fetch </dt>  <dt id="reg_numbered_buff_length">reg_numbered_buff_length </dt>  <dt id="reg_numbered_buff_store">reg_numbered_buff_store </dt>  <dt id="reg_qr_package">reg_qr_package </dt>  <dt id="reg_skipcomment">reg_skipcomment </dt>  <dt id="reg_temp_copy">reg_temp_copy </dt>  <dt id="regcurly">regcurly </dt>  <dt id="regprop">regprop </dt>  <dt id="report_evil_fh">report_evil_fh </dt>  <dt id="report_redefined_cv">report_redefined_cv </dt>  <dt id="report_wrongway_fh">report_wrongway_fh </dt>  <dt id="rpeep">rpeep </dt>  <dt id="rsignal_restore">rsignal_restore </dt>  <dt id="rsignal_save">rsignal_save </dt>  <dt id="rxres_save">rxres_save </dt>  <dt id="same_dirent">same_dirent </dt>  <dt id="save_strlen">save_strlen </dt>  <dt id="save_to_buffer">save_to_buffer </dt>  <dt id="sawparens">sawparens </dt>  <dt id="scalar">scalar </dt>  <dt id="scalarvoid">scalarvoid </dt>  <dt id="scan_str">scan_str </dt>  <dt id="scan_word">scan_word </dt>  <dt id="set_caret_X">set_caret_X </dt>  <dt id="set_numeric_standard">set_numeric_standard </dt>  <dt id="set_numeric_underlying">set_numeric_underlying </dt>  <dt id="set_padlist">set_padlist </dt>  <dt id="setfd_cloexec">setfd_cloexec </dt>  <dt id="setfd_cloexec_for_nonsysfd">setfd_cloexec_for_nonsysfd </dt>  <dt id="setfd_cloexec_or_inhexec_by_sysfdness">setfd_cloexec_or_inhexec_by_sysfdness </dt>  <dt id="setfd_inhexec">setfd_inhexec </dt>  <dt id="setfd_inhexec_for_sysfd">setfd_inhexec_for_sysfd </dt>  <dt id="should_warn_nl">should_warn_nl </dt>  <dt id="should_we_output_Debug_r">should_we_output_Debug_r </dt>  <dt id="sighandler">sighandler </dt>  <dt id="sighandler1">sighandler1 </dt>  <dt id="sighandler3">sighandler3 </dt>  <dt id="skipspace_flags">skipspace_flags </dt>  <dt id="softref2xv">softref2xv </dt>  <dt id="sortsv_flags_impl">sortsv_flags_impl </dt>  <dt id="sub_crush_depth">sub_crush_depth </dt>  <dt id="sv_add_backref">sv_add_backref </dt>  <dt id="sv_buf_to_ro">sv_buf_to_ro </dt>  <dt id="sv_del_backref">sv_del_backref </dt>  <dt id="sv_free2">sv_free2 </dt>  <dt id="sv_i_ncmp">sv_i_ncmp </dt>  <dt id="sv_i_ncmp_desc">sv_i_ncmp_desc </dt>  <dt id="sv_kill_backrefs">sv_kill_backrefs </dt>  <dt id="sv_len_utf8_nomg">sv_len_utf8_nomg </dt>  <dt id="sv_magicext_mglob">sv_magicext_mglob </dt>  <dt id="sv_ncmp">sv_ncmp </dt>  <dt id="sv_ncmp_desc">sv_ncmp_desc </dt>  <dt id="sv_only_taint_gmagic">sv_only_taint_gmagic </dt>  <dt id="sv_or_pv_pos_u2b">sv_or_pv_pos_u2b </dt>  <dt id="sv_resetpvn">sv_resetpvn </dt>  <dt id="sv_sethek">sv_sethek </dt>  <dt id="sv_setsv_cow">sv_setsv_cow </dt>  <dt id="sv_unglob">sv_unglob </dt>  <dt id="tied_method">tied_method </dt>  <dt id="tmps_grow_p">tmps_grow_p </dt>  <dt id="to_uni_fold">to_uni_fold </dt>  <dt id="to_uni_lower">to_uni_lower </dt>  <dt id="to_uni_title">to_uni_title </dt>  <dt id="to_uni_upper">to_uni_upper </dt>  <dt id="translate_substr_offsets">translate_substr_offsets </dt>  <dt id="try_amagic_bin">try_amagic_bin </dt>  <dt id="try_amagic_un">try_amagic_un </dt>  <dt id="uiv_2buf">uiv_2buf </dt>  <dt id="unshare_hek">unshare_hek </dt>  <dt id="utf16_to_utf8">utf16_to_utf8 </dt>  <dt id="utf16_to_utf8_reversed">utf16_to_utf8_reversed </dt>  <dt id="utf8_to_uvchr_buf_helper">utf8_to_uvchr_buf_helper </dt>  <dt id="utilize">utilize </dt>  <dt id="uvoffuni_to_utf8_flags_msgs">uvoffuni_to_utf8_flags_msgs </dt>  <dt id="uvuni_to_utf8">uvuni_to_utf8 </dt>  <dt id="valid_utf8_to_uvuni">valid_utf8_to_uvuni </dt>  <dt id="variant_byte_number">variant_byte_number </dt>  <dt id="varname">varname </dt>  <dt id="vivify_defelem">vivify_defelem </dt>  <dt id="vivify_ref">vivify_ref </dt>  <dt id="wait4pid">wait4pid </dt>  <dt id="was_lvalue_sub">was_lvalue_sub </dt>  <dt id="watch">watch </dt>  <dt id="win32_croak_not_implemented">win32_croak_not_implemented </dt>  <dt id="write_to_stderr">write_to_stderr </dt>  <dt id="xs_boot_epilog">xs_boot_epilog </dt>  <dt id="xs_handshake">xs_handshake </dt>  <dt id="yyerror">yyerror </dt>  <dt id="yyerror_pv">yyerror_pv </dt>  <dt id="yyerror_pvn">yyerror_pvn </dt>  <dt id="yylex">yylex </dt>  <dt id="yyparse">yyparse </dt>  <dt id="yyquit">yyquit </dt>  <dt id="yyunlex">yyunlex </dt>  </dl> <h2 id="AUTHORS">AUTHORS</h2> <p>The autodocumentation system was originally added to the Perl core by Benjamin Stuhl. Documentation is by whoever was kind enough to document their functions.</p> <h2 id="SEE-ALSO">
SEE ALSO</h2> <p><i>config.h</i> <a href="perlapi">perlapi</a> <a href="perlapio">perlapio</a> <a href="perlcall">perlcall</a> <a href="perlclib">perlclib</a> <a href="perlfilter">perlfilter</a> <a href="perlguts">perlguts</a> <a href="perlmroapi">perlmroapi</a> <a href="perlxs">perlxs</a> <a href="perlxstut">perlxstut</a> <a href="warnings">warnings</a></p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993&ndash;2020 Larry Wall and others<br>Licensed under the GNU General Public License version 1 or later, or the Artistic License.<br>The Perl logo is a trademark of the Perl Foundation.<br>
    <a href="https://perldoc.perl.org/5.32.0/perlintern" class="_attribution-link">https://perldoc.perl.org/5.32.0/perlintern</a>
  </p>
</div>
