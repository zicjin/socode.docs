<h1 class="command">RPOPLPUSH</h1>
<pre>RPOPLPUSH source destination</pre>   <div class="metadata"> <p><strong>Available since 1.2.0.</strong></p> <p><strong>Time complexity:</strong> O(1)</p> </div> <div class="deprecation"> <p> <strong>Deprecation notice:</strong> as of Redis version 6.2.0 this command is considered as deprecated. While it is unlikely that it will be completely removed, prefer using `LMOVE` with the `RIGHT` and `LEFT` arguments in its stead. </p> </div> <p>Atomically returns and removes the last element (tail) of the list stored at <code>source</code>, and pushes the element at the first element (head) of the list stored at <code>destination</code>.</p> <p>For example: consider <code>source</code> holding the list <code>a,b,c</code>, and <code>destination</code> holding the list <code>x,y,z</code>. Executing <a href="rpoplpush">RPOPLPUSH</a> results in <code>source</code> holding <code>a,b</code> and <code>destination</code> holding <code>c,x,y,z</code>.</p> <p>If <code>source</code> does not exist, the value <code>nil</code> is returned and no operation is performed. If <code>source</code> and <code>destination</code> are the same, the operation is equivalent to removing the last element from the list and pushing it as first element of the list, so it can be considered as a list rotation command.</p> <h2>Return value</h2> <p><a href="https://redis.io/topics/protocol#bulk-string-reply">Bulk string reply</a>: the element being popped and pushed.</p> <h2>Examples</h2> <div class="example" data-session="a3d43693cf3a523759b1fe091a03c82a"> <span class="monospace prompt">redis&gt; </span> <span class="monospace command">RPUSH mylist "one"</span> <code>(integer) 1</code> <span class="monospace prompt">redis&gt; </span> <span class="monospace command">RPUSH mylist "two"</span> <code>(integer) 2</code> <span class="monospace prompt">redis&gt; </span> <span class="monospace command">RPUSH mylist "three"</span> <code>(integer) 3</code> <span class="monospace prompt">redis&gt; </span> <span class="monospace command">RPOPLPUSH mylist myotherlist</span> <code>"three"</code> <span class="monospace prompt">redis&gt; </span> <span class="monospace command">LRANGE mylist 0 -1</span> <code>1) "one"
2) "two"</code> <span class="monospace prompt">redis&gt; </span> <span class="monospace command">LRANGE myotherlist 0 -1</span> <code>1) "three"</code>
</div> <h2>Pattern: Reliable queue</h2> <p>Redis is often used as a messaging server to implement processing of background jobs or other kinds of messaging tasks. A simple form of queue is often obtained pushing values into a list in the producer side, and waiting for this values in the consumer side using <a href="rpop">RPOP</a> (using polling), or <a href="brpop">BRPOP</a> if the client is better served by a blocking operation.</p> <p>However in this context the obtained queue is not <em>reliable</em> as messages can be lost, for example in the case there is a network problem or if the consumer crashes just after the message is received but before it can be processed.</p> <p><a href="rpoplpush">RPOPLPUSH</a> (or <a href="brpoplpush">BRPOPLPUSH</a> for the blocking variant) offers a way to avoid this problem: the consumer fetches the message and at the same time pushes it into a <em>processing</em> list. It will use the <a href="lrem">LREM</a> command in order to remove the message from the <em>processing</em> list once the message has been processed.</p> <p>An additional client may monitor the <em>processing</em> list for items that remain there for too much time, pushing timed out items into the queue again if needed.</p> <h2>Pattern: Circular list</h2> <p>Using <a href="rpoplpush">RPOPLPUSH</a> with the same source and destination key, a client can visit all the elements of an N-elements list, one after the other, in <span class="math">O(N) </span>without transferring the full list from the server to the client using a single <a href="lrange">LRANGE</a> operation.</p> <p>The above pattern works even if one or both of the following conditions occur:</p> <ul> <li>There are multiple clients rotating the list: they'll fetch different elements, until all the elements of the list are visited, and the process restarts.</li> <li>Other clients are actively pushing new items at the end of the list.</li> </ul> <p>The above makes it very simple to implement a system where a set of items must be processed by N workers continuously as fast as possible. An example is a monitoring system that must check that a set of web sites are reachable, with the smallest delay possible, using a number of parallel workers.</p> <p>Note that this implementation of workers is trivially scalable and reliable, because even if a message is lost the item is still in the queue and will be processed at the next iteration.</p>  <div class="_attribution">
  <p class="_attribution-p">
    <a href="https://redis.io/commands/rpoplpush" class="_attribution-link" target="_blank">https://redis.io/commands/rpoplpush</a>
  </p>
</div>
