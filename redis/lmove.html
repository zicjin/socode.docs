<h1 class="command">LMOVE</h1>
<pre>LMOVE source destination LEFT|RIGHT LEFT|RIGHT</pre>   <div class="metadata"> <p><strong>Available since 6.2.0.</strong></p> <p><strong>Time complexity:</strong> O(1)</p> </div> <p>Atomically returns and removes the first/last element (head/tail depending on the <code>wherefrom</code> argument) of the list stored at <code>source</code>, and pushes the element at the first/last element (head/tail depending on the <code>whereto</code> argument) of the list stored at <code>destination</code>.</p> <p>For example: consider <code>source</code> holding the list <code>a,b,c</code>, and <code>destination</code> holding the list <code>x,y,z</code>. Executing <code>LMOVE source destination RIGHT LEFT</code> results in <code>source</code> holding <code>a,b</code> and <code>destination</code> holding <code>c,x,y,z</code>.</p> <p>If <code>source</code> does not exist, the value <code>nil</code> is returned and no operation is performed. If <code>source</code> and <code>destination</code> are the same, the operation is equivalent to removing the first/last element from the list and pushing it as first/last element of the list, so it can be considered as a list rotation command (or a no-op if <code>wherefrom</code> is the same as <code>whereto</code>).</p> <p>This command comes in place of the now deprecated <a href="rpoplpush">RPOPLPUSH</a>. Doing <code>LMOVE RIGHT LEFT</code> is equivalent.</p> <h2>Return value</h2> <p><a href="https://redis.io/topics/protocol#bulk-string-reply">Bulk string reply</a>: the element being popped and pushed.</p> <h2>Examples</h2> <div class="example" data-session="d35cc798d70ffe858bbb9e1b4bd32cc9"> <span class="monospace prompt">redis&gt; </span> <span class="monospace command">RPUSH mylist "one"</span> <code>(integer) 1</code> <span class="monospace prompt">redis&gt; </span> <span class="monospace command">RPUSH mylist "two"</span> <code>(integer) 2</code> <span class="monospace prompt">redis&gt; </span> <span class="monospace command">RPUSH mylist "three"</span> <code>(integer) 3</code> <span class="monospace prompt">redis&gt; </span> <span class="monospace command">LMOVE mylist myotherlist RIGHT LEFT</span> <code>"three"</code> <span class="monospace prompt">redis&gt; </span> <span class="monospace command">LMOVE mylist myotherlist LEFT RIGHT</span> <code>"one"</code> <span class="monospace prompt">redis&gt; </span> <span class="monospace command">LRANGE mylist 0 -1</span> <code>1) "two"</code> <span class="monospace prompt">redis&gt; </span> <span class="monospace command">LRANGE myotherlist 0 -1</span> <code>1) "three"
2) "one"</code>
</div> <h2>Pattern: Reliable queue</h2> <p>Redis is often used as a messaging server to implement processing of background jobs or other kinds of messaging tasks. A simple form of queue is often obtained pushing values into a list in the producer side, and waiting for this values in the consumer side using <a href="rpop">RPOP</a> (using polling), or <a href="brpop">BRPOP</a> if the client is better served by a blocking operation.</p> <p>However in this context the obtained queue is not <em>reliable</em> as messages can be lost, for example in the case there is a network problem or if the consumer crashes just after the message is received but it is still to process.</p> <p><a href="lmove">LMOVE</a> (or <a href="blmove">BLMOVE</a> for the blocking variant) offers a way to avoid this problem: the consumer fetches the message and at the same time pushes it into a <em>processing</em> list. It will use the <a href="lrem">LREM</a> command in order to remove the message from the <em>processing</em> list once the message has been processed.</p> <p>An additional client may monitor the <em>processing</em> list for items that remain there for too much time, and will push those timed out items into the queue again if needed.</p> <h2>Pattern: Circular list</h2> <p>Using <a href="lmove">LMOVE</a> with the same source and destination key, a client can visit all the elements of an N-elements list, one after the other, in <span class="math">O(N) </span>without transferring the full list from the server to the client using a single <a href="lrange">LRANGE</a> operation.</p> <p>The above pattern works even if the following two conditions:</p> <ul> <li>There are multiple clients rotating the list: they'll fetch different elements, until all the elements of the list are visited, and the process restarts.</li> <li>Even if other clients are actively pushing new items at the end of the list.</li> </ul> <p>The above makes it very simple to implement a system where a set of items must be processed by N workers continuously as fast as possible. An example is a monitoring system that must check that a set of web sites are reachable, with the smallest delay possible, using a number of parallel workers.</p> <p>Note that this implementation of workers is trivially scalable and reliable, because even if a message is lost the item is still in the queue and will be processed at the next iteration.</p>  <div class="_attribution">
  <p class="_attribution-p">
    <a href="https://redis.io/commands/lmove" class="_attribution-link" target="_blank">https://redis.io/commands/lmove</a>
  </p>
</div>
