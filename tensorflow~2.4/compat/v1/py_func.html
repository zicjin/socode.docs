<h1 class="devsite-page-title">tf.compat.v1.py_func</h1>       <p>Wraps a python function and uses it as a TensorFlow op.</p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
tf.compat.v1.py_func(
    func, inp, Tout, stateful=True, name=None
)
</pre>  <p>Given a python function <code translate="no" dir="ltr">func</code>, which takes numpy arrays as its arguments and returns numpy arrays as its outputs, wrap this function as an operation in a TensorFlow graph. The following snippet constructs a simple TensorFlow graph that invokes the <code translate="no" dir="ltr">np.sinh()</code> NumPy function as a operation in the graph:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">def my_func(x):
  # x will be a numpy array with the contents of the placeholder below
  return np.sinh(x)
input = tf.compat.v1.placeholder(tf.float32)
y = tf.compat.v1.py_func(my_func, [input], tf.float32)
</pre>
<blockquote class="note">
<strong>Note:</strong><span> The <a href="py_func"><code translate="no" dir="ltr">tf.compat.v1.py_func()</code></a> operation has the following known limitations:</span>
</blockquote> <ul> <li><p>The body of the function (i.e. <code translate="no" dir="ltr">func</code>) will not be serialized in a <code translate="no" dir="ltr">GraphDef</code>. Therefore, you should not use this function if you need to serialize your model and restore it in a different environment.</p></li> <li><p>The operation must run in the same address space as the Python program that calls <a href="py_func"><code translate="no" dir="ltr">tf.compat.v1.py_func()</code></a>. If you are using distributed TensorFlow, you must run a <a href="../../distribute/server"><code translate="no" dir="ltr">tf.distribute.Server</code></a> in the same process as the program that calls <a href="py_func"><code translate="no" dir="ltr">tf.compat.v1.py_func()</code></a> and you must pin the created operation to a device in that server (e.g. using <code translate="no" dir="ltr">with tf.device():</code>).</p></li> </ul>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">func</code> </td> <td> A Python function, which accepts <code translate="no" dir="ltr">ndarray</code> objects as arguments and returns a list of <code translate="no" dir="ltr">ndarray</code> objects (or a single <code translate="no" dir="ltr">ndarray</code>). This function must accept as many arguments as there are tensors in <code translate="no" dir="ltr">inp</code>, and these argument types will match the corresponding <a href="../../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a> objects in <code translate="no" dir="ltr">inp</code>. The returns <code translate="no" dir="ltr">ndarray</code>s must match the number and types defined <code translate="no" dir="ltr">Tout</code>. Important Note: Input and output numpy <code translate="no" dir="ltr">ndarray</code>s of <code translate="no" dir="ltr">func</code> are not guaranteed to be copies. In some cases their underlying memory will be shared with the corresponding TensorFlow tensors. In-place modification or storing <code translate="no" dir="ltr">func</code> input or return values in python datastructures without explicit (np.)copy can have non-deterministic consequences. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">inp</code> </td> <td> A list of <code translate="no" dir="ltr">Tensor</code> objects. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">Tout</code> </td> <td> A list or tuple of tensorflow data types or a single tensorflow data type if there is only one, indicating what <code translate="no" dir="ltr">func</code> returns. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">stateful</code> </td> <td> (Boolean.) If True, the function should be considered stateful. If a function is stateless, when given the same input it will return the same output and have no observable side effects. Optimizations such as common subexpression elimination are only performed on stateless operations. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A list of <code translate="no" dir="ltr">Tensor</code> or a single <code translate="no" dir="ltr">Tensor</code> which <code translate="no" dir="ltr">func</code> computes. </td> </tr> 
</table>  <devsite-thumb-rating position="footer"> </devsite-thumb-rating><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.tensorflow.org/versions/r2.4/api_docs/python/tf/compat/v1/py_func" class="_attribution-link" target="_blank">https://www.tensorflow.org/versions/r2.4/api_docs/python/tf/compat/v1/py_func</a>
  </p>
</div>
