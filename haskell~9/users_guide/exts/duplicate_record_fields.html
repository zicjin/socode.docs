<h1 id="id1">6.5.4. Duplicate record fields</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <dl class="extension" id="duplicate-record-fields"> <dt id="extension-DuplicateRecordFields">
<code>DuplicateRecordFields</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="disambiguate_record_fields#extension-DisambiguateRecordFields"><code>DisambiguateRecordFields</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Allow definition of record types with identically-named fields.</p> </dd>
</dl> <p>Going beyond <a class="reference internal" href="disambiguate_record_fields#extension-DisambiguateRecordFields"><code>DisambiguateRecordFields</code></a> (see <a class="reference internal" href="disambiguate_record_fields#disambiguate-fields"><span class="std std-ref">Record field disambiguation</span></a>), the <a class="reference internal" href="#extension-DuplicateRecordFields"><code>DuplicateRecordFields</code></a> extension allows multiple datatypes to be declared using the same field names in a single module. For example, it allows this:</p> <pre data-language="haskell">module M where
  data S = MkS { x :: Int }
  data T = MkT { x :: Bool }
</pre> <p>Uses of fields that are always unambiguous because they mention the constructor, including construction and pattern-matching, may freely use duplicated field names. For example, the following are permitted (just as with <a class="reference internal" href="disambiguate_record_fields#extension-DisambiguateRecordFields"><code>DisambiguateRecordFields</code></a>):</p> <pre data-language="haskell">s = MkS { x = 3 }

f (MkT { x = b }) = b
</pre> <p>Field names used as selector functions or in record updates must be unambiguous, either because there is only one such field in scope, or because a type signature is supplied, as described in the following sections.</p>  <h2 id="selector-functions">6.5.4.1. Selector functions</h2> <p>Fields may be used as selector functions only if they are unambiguous, so this is still not allowed if both <code>S(x)</code> and <code>T(x)</code> are in scope:</p> <pre data-language="haskell">bad r = x r
</pre> <p>An ambiguous selector may be disambiguated by the type being “pushed down” to the occurrence of the selector (see <a class="reference internal" href="rank_polymorphism#higher-rank-type-inference"><span class="std std-ref">Type inference</span></a> for more details on what “pushed down” means). For example, the following are permitted:</p> <pre data-language="haskell">ok1 = x :: S -&gt; Int

ok2 :: S -&gt; Int
ok2 = x

ok3 = k x -- assuming we already have k :: (S -&gt; Int) -&gt; _
</pre> <p>In addition, the datatype that is meant may be given as a type signature on the argument to the selector:</p> <pre data-language="haskell">ok4 s = x (s :: S)
</pre> <p>However, we do not infer the type of the argument to determine the datatype, or have any way of deferring the choice to the constraint solver. Thus the following is ambiguous:</p> <pre data-language="haskell">bad :: S -&gt; Int
bad s = x s
</pre> <p>Even though a field label is duplicated in its defining module, it may be possible to use the selector unambiguously elsewhere. For example, another module could import <code>S(x)</code> but not <code>T(x)</code>, and then use <code>x</code> unambiguously.</p>   <h2 id="record-updates">6.5.4.2. Record updates</h2> <p>In a record update such as <code>e { x = 1 }</code>, if there are multiple <code>x</code> fields in scope, then the type of the context must fix which record datatype is intended, or a type annotation must be supplied. Consider the following definitions:</p> <pre data-language="haskell">data S = MkS { foo :: Int }
data T = MkT { foo :: Int, bar :: Int }
data U = MkU { bar :: Int, baz :: Int }
</pre> <p>Without <a class="reference internal" href="#extension-DuplicateRecordFields"><code>DuplicateRecordFields</code></a>, an update mentioning <code>foo</code> will always be ambiguous if all these definitions were in scope. When the extension is enabled, there are several options for disambiguating updates:</p> <ul> <li>
<p class="first">Check for types that have all the fields being updated. For example:</p> <pre data-language="haskell">f x = x { foo = 3, bar = 2 }
</pre> <p>Here <code>f</code> must be updating <code>T</code> because neither <code>S</code> nor <code>U</code> have both fields.</p> </li> <li>
<p class="first">Use the type being pushed in to the record update, as in the following:</p> <pre data-language="haskell">g1 :: T -&gt; T
g1 x = x { foo = 3 }

g2 x = x { foo = 3 } :: T

g3 = k (x { foo = 3 }) -- assuming we already have k :: T -&gt; _
</pre> </li> <li>
<p class="first">Use an explicit type signature on the record expression, as in:</p> <pre data-language="haskell">h x = (x :: T) { foo = 3 }
</pre> </li> </ul> <p>The type of the expression being updated will not be inferred, and no constraint-solving will be performed, so the following will be rejected as ambiguous:</p> <pre data-language="haskell">let x :: T
    x = blah
in x { foo = 3 }

\x -&gt; [x { foo = 3 },  blah :: T ]

\ (x :: T) -&gt; x { foo = 3 }
</pre>   <h2 id="import-and-export-of-record-fields">6.5.4.3. Import and export of record fields</h2> <p>When <a class="reference internal" href="#extension-DuplicateRecordFields"><code>DuplicateRecordFields</code></a> is enabled, an ambiguous field must be exported as part of its datatype, rather than at the top level. For example, the following is legal:</p> <pre data-language="haskell">module M (S(x), T(..)) where
  data S = MkS { x :: Int }
  data T = MkT { x :: Bool }
</pre> <p>However, this would not be permitted, because <code>x</code> is ambiguous:</p> <pre data-language="haskell">module M (x) where ...
</pre> <p>Similar restrictions apply on import.</p>   </div> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/duplicate_record_fields.html" class="_attribution-link" target="_blank">https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/duplicate_record_fields.html</a>
  </p>
</div>
