<h1 id="id1">6.4.4. Type operators</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <dl class="extension" id="type-operators"> <dt id="extension-TypeOperators">
<code>TypeOperators</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="explicit_namespaces#extension-ExplicitNamespaces"><code>ExplicitNamespaces</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow the use and definition of types with operator names.</p> </dd>
</dl> <p>In types, an operator symbol like <code>(+)</code> is normally treated as a type <em>variable</em>, just like <code>a</code>. Thus in Haskell 98 you can say</p> <pre data-language="haskell">type T (+) = ((+), (+))
-- Just like: type T a = (a,a)

f :: T Int -&gt; Int
f (x,y)= x
</pre> <p>As you can see, using operators in this way is not very useful, and Haskell 98 does not even allow you to write them infix.</p> <p>The language <a class="reference internal" href="#extension-TypeOperators"><code>TypeOperators</code></a> changes this behaviour:</p> <ul> <li>Operator symbols become type <em>constructors</em> rather than type <em>variables</em>. </li> <li>
<p class="first">Operator symbols in types can be written infix, both in definitions and uses. For example:</p> <pre data-language="haskell">data a + b = Plus a b
type Foo = Int + Bool
</pre> </li> <li>
<p class="first">There is now some potential ambiguity in import and export lists; for example if you write <code>import M( (+) )</code> do you mean the <em>function</em> <code>(+)</code> or the <em>type constructor</em> <code>(+)</code>? The default is the former, but with <a class="reference internal" href="explicit_namespaces#extension-ExplicitNamespaces"><code>ExplicitNamespaces</code></a> (which is implied by <a class="reference internal" href="#extension-TypeOperators"><code>TypeOperators</code></a>) GHC allows you to specify the latter by preceding it with the keyword <code>type</code>, thus:</p> <pre data-language="haskell">import M( type (+) )
</pre> <p>See <a class="reference internal" href="explicit_namespaces#explicit-namespaces"><span class="std std-ref">Explicit namespaces in import/export</span></a>.</p> </li> <li>The fixity of a type operator may be set using the usual fixity declarations but, as in <a class="reference internal" href="infix_tycons#infix-tycons"><span class="std std-ref">Infix type constructors, classes, and type variables</span></a>, the function and type constructor share a single fixity. </li> </ul>  </div> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/type_operators.html" class="_attribution-link" target="_blank">https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/type_operators.html</a>
  </p>
</div>
