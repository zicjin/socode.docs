<h1 id="id1">6.4.16. Impredicative polymorphism</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <dl class="extension" id="impredicative-polymorphism"> <dt id="extension-ImpredicativeTypes">
<code>ImpredicativeTypes</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="rank_polymorphism#extension-RankNTypes"><code>RankNTypes</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.10.1</td> </tr>  </table> <p>Allow impredicative polymorphic types.</p> </dd>
</dl> <p>In general, GHC will only instantiate a polymorphic function at a monomorphic type (one with no foralls). For example,</p> <pre data-language="haskell">runST :: (forall s. ST s a) -&gt; a
id :: forall b. b -&gt; b

foo = id runST   -- Rejected
</pre> <p>The definition of <code>foo</code> is rejected because one would have to instantiate <code>id</code>â€˜s type with <code>b := (forall s. ST s a) -&gt; a</code>, and that is not allowed. Instantiating polymorphic type variables with polymorphic types is called <em>impredicative polymorphism</em>.</p> <p>GHC has robust support for <em>impredicative polymorphism</em>, enabled with <a class="reference internal" href="#extension-ImpredicativeTypes"><code>ImpredicativeTypes</code></a>, using the so-called Quick Look inference algorithm. It is described in the paper <a class="reference external" href="https://www.microsoft.com/en-us/research/publication/a-quick-look-at-impredicativity/">A quick look at impredicativity</a> (Serrano et al, ICFP 2020).</p> <p>Switching on <a class="reference internal" href="#extension-ImpredicativeTypes"><code>ImpredicativeTypes</code></a></p> <ul class="simple"> <li>Switches on :extension: <code>RankNTypes</code>
</li> <li>Allows user-written types to have foralls under type constructors, not just under arrows. For example <code>f :: Maybe (forall a. [a] -&gt; [a])</code> is a legal type signature.</li> <li>Allows polymorphic types in Visible Type Application (when :extension: <code>TypeApplications</code> is enabled). For example, you can write <code>reverse @(forall b. b-&gt;b) xs</code>. Using VTA with a polymorphic type argument is useful in cases when Quick Look cannot infer the correct instantiation.</li> <li>Switches on the Quick Look type inference algorithm, as described in the paper. This allows the compiler to infer impredicative instantiations of polymorphic functions in many cases. For example, <code>reverse xs</code> will typecheck even if <code>xs :: [forall a. a-&gt;a]</code>, by instantiating <code>reverse</code> at type <code>forall a. a-&gt;a</code>.</li> </ul> <p>For many years GHC has a special case for the function <code>($)</code>, that allows it to typecheck an application like <code>runST $ (do { ... })</code>, even though that instantiation may be impredicative. This special case remains: even without <a class="reference internal" href="#extension-ImpredicativeTypes"><code>ImpredicativeTypes</code></a> GHC switches on Quick Look for applications of <code>($)</code>.</p>  </div> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://downloads.haskell.org/~ghc/9.2.1/docs/html/users_guide/exts/impredicative_types.html" class="_attribution-link" target="_blank">https://downloads.haskell.org/~ghc/9.2.1/docs/html/users_guide/exts/impredicative_types.html</a>
  </p>
</div>
