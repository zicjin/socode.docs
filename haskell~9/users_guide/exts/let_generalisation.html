<h1 id="mono-local-binds">6.12.2. Let-generalisation</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <dl class="extension" id="let-generalisation"> <dt id="extension-MonoLocalBinds">
<code>MonoLocalBinds</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.12.1</td> </tr>  </table> <p>Infer less polymorphic types for local bindings by default.</p> </dd>
</dl> <p>An ML-style language usually generalises the type of any <code>let</code>-bound or <code>where</code>-bound variable, so that it is as polymorphic as possible. With the extension <a class="reference internal" href="#extension-MonoLocalBinds"><code>MonoLocalBinds</code></a> GHC implements a slightly more conservative policy, using the following rules:</p> <ul class="simple"> <li>A variable is <em>closed</em> if and only if<ul> <li>the variable is let-bound</li> <li>one of the following holds:<ul> <li>the variable has an explicit type signature that has no free type variables, or</li> <li>its binding group is fully generalised (see next bullet)</li> </ul> </li> </ul> </li> <li>A binding group is <em>fully generalised</em> if and only if<ul> <li>each of its free variables is either imported or closed, and</li> <li>the binding is not affected by the monomorphism restriction (<a class="reference external" href="http://www.haskell.org/onlinereport/decls.html#sect4.5.5">Haskell Report, Section 4.5.5</a>)</li> </ul> </li> </ul> <p>For example, consider</p> <pre data-language="haskell">f x = x + 1
g x = let h y = f y * 2
          k z = z+x
      in  h x + k x
</pre> <p>Here <code>f</code> is generalised because it has no free variables; and its binding group is unaffected by the monomorphism restriction; and hence <code>f</code> is closed. The same reasoning applies to <code>g</code>, except that it has one closed free variable, namely <code>f</code>. Similarly <code>h</code> is closed, <em>even though it is not bound at top level</em>, because its only free variable <code>f</code> is closed. But <code>k</code> is not closed, because it mentions <code>x</code> which is not closed (because it is not let-bound).</p> <p>Notice that a top-level binding that is affected by the monomorphism restriction is not closed, and hence may in turn prevent generalisation of bindings that mention it.</p> <p>The rationale for this more conservative strategy is given in <a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf">the papers</a> “Let should not be generalised” and “Modular type inference with local assumptions”, and a related <a class="reference external" href="https://www.haskell.org/ghc/blog/20100930-LetGeneralisationInGhc7.html">blog post</a>.</p> <p>The extension <a class="reference internal" href="#extension-MonoLocalBinds"><code>MonoLocalBinds</code></a> is implied by <a class="reference internal" href="type_families#extension-TypeFamilies"><code>TypeFamilies</code></a> and <a class="reference internal" href="gadt#extension-GADTs"><code>GADTs</code></a>. You can switch it off again with <a class="reference internal" href="#extension-MonoLocalBinds"><code>NoMonoLocalBinds</code></a> but type inference becomes less predictable if you do so. (Read the papers!)</p>  </div> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/let_generalisation.html" class="_attribution-link" target="_blank">https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/exts/let_generalisation.html</a>
  </p>
</div>
