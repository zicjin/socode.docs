 <h1 id="command-line-interface-application">Command Line Interface Application</h1> <p>Programming Command Line Interface applications (CLI applications) is one of the most entertaining tasks a developer may do. So let‚Äôs have some fun building our first CLI application in Crystal.</p> <p>There are two main topics when building a CLI application:</p> <ul> <li><a href="#input">input</a></li> <li><a href="#output">output</a></li> </ul> <h2 id="input">Input</h2> <p>This topic covers all things related to:</p> <ul> <li><a href="#options">options passed to the app</a></li> <li><a href="#request-for-user-input">request for user input</a></li> </ul> <h3 id="options">Options</h3> <p>It is a very common practice to pass options to the application. For example, we may run <code>crystal -v</code> and Crystal will display:</p> <div class="highlight"><pre data-language="crystal">$ crystal -v
Crystal 1.3.0 [a3ee70ca0] (2022-01-06)

LLVM: 10.0.0
Default target: x86_64-unknown-linux-gnu
</pre></div> <p>and if we run: <code>crystal -h</code>, then Crystal will show all the accepted options and how to use them.</p> <p>So now the question would be: <strong>do we need to implement an options parser?</strong> No need to, Crystal got us covered with the class <code>OptionParser</code>. Let‚Äôs build an application using this parser!</p> <p>At the start our CLI application has two options:</p> <ul> <li>
<code>-v</code> / <code>--version</code>: it will display the application version.</li> <li>
<code>-h</code> / <code>--help</code>: it will display the application help.</li> </ul> <div class="crystal highlight"><pre data-language="crystal">require "option_parser"

OptionParser.parse do |parser|
  parser.banner = "Welcome to The Beatles App!"

  parser.on "-v", "--version", "Show version" do
    puts "version 1.0"
    exit
  end
  parser.on "-h", "--help", "Show help" do
    puts parser
    exit
  end
end
</pre></div> <p>So, how does all this work? Well ‚Ä¶ magic! No, it‚Äôs not really magic! Just Crystal making our life easy. When our application starts, the block passed to <code>OptionParser#parse</code> gets executed. In that block we define all the options. After the block is executed, the parser will start consuming the arguments passed to the application, trying to match each one with the options defined by us. If an option matches then the block passed to <code>parser#on</code> gets executed!</p> <p>We can read all about <code>OptionParser</code> in <a href="https://crystal-lang.org/api/1.3.2/OptionParser.html">the official API documentation</a>. And from there we are one click away from the source code ... the actual proof that it is not magic!</p> <p>Now, let's run our application. We have two ways <a href="../using_the_compiler/index">using the compiler</a>:</p> <ol> <li>
<a href="../using_the_compiler/index#crystal-build">Build the application</a> and then run it.</li> <li>Compile and <a href="../using_the_compiler/index#crystal-run">run the application</a>, all in one command.</li> </ol> <p>We are going to use the second way:</p> <div class="highlight"><pre data-language="crystal">$ crystal run ./help.cr -- -h

Welcome to The Beatles App!
    -v, --version                    Show version
    -h, --help                       Show help
</pre></div> <p>Let's build another <em>fabulous</em> application with the following feature:</p> <p>By default (i.e. no options given) the application will display the names of the Fab Four. But, if we pass the option <code>-t</code> / <code>--twist</code> it will display the names in uppercase:</p> <div class="crystal highlight"><pre data-language="crystal">require "option_parser"

the_beatles = [
  "John Lennon",
  "Paul McCartney",
  "George Harrison",
  "Ringo Starr",
]
shout = false

option_parser = OptionParser.parse do |parser|
  parser.banner = "Welcome to The Beatles App!"

  parser.on "-v", "--version", "Show version" do
    puts "version 1.0"
    exit
  end
  parser.on "-h", "--help", "Show help" do
    puts parser
    exit
  end
  parser.on "-t", "--twist", "Twist and SHOUT" do
    shout = true
  end
end

members = the_beatles
members = the_beatles.map &amp;.upcase if shout

puts ""
puts "Group members:"
puts "=============="
members.each do |member|
  puts member
end
</pre></div> <p>Running the application with the <code>-t</code> option will output:</p> <div class="highlight"><pre data-language="crystal">$ crystal run ./twist_and_shout.cr -- -t

Group members:
==============
JOHN LENNON
PAUL MCCARTNEY
GEORGE HARRISON
RINGO STARR
</pre></div> <h4 id="parameterized-options">Parameterized options</h4> <p>Let‚Äôs create another application: <em>when passing the option <code>-g</code> / <code>--goodbye_hello</code>, the application will say hello to a given name <strong>passed as a parameter to the option</strong></em>.</p> <div class="crystal highlight"><pre data-language="crystal">require "option_parser"

the_beatles = [
  "John Lennon",
  "Paul McCartney",
  "George Harrison",
  "Ringo Starr",
]
say_hi_to = ""

option_parser = OptionParser.parse do |parser|
  parser.banner = "Welcome to The Beatles App!"

  parser.on "-v", "--version", "Show version" do
    puts "version 1.0"
    exit
  end
  parser.on "-h", "--help", "Show help" do
    puts parser
    exit
  end
  parser.on "-g NAME", "--goodbye_hello=NAME", "Say hello to whoever you want" do |name|
    say_hi_to = name
  end
end

unless say_hi_to.empty?
  puts ""
  puts "You say goodbye, and #{the_beatles.sample} says hello to #{say_hi_to}!"
end
</pre></div> <p>In this case, the block receives a parameter that represents the parameter passed to the option.</p> <p>Let‚Äôs try it!</p> <div class="highlight"><pre data-language="crystal">$ crystal run ./hello_goodbye.cr -- -g "Penny Lane"

You say goodbye, and Ringo Starr says hello to Penny Lane!
</pre></div> <p>Great! These applications look awesome! But, <strong>what happens when we pass an option that is not declared?</strong> For example -n</p> <div class="highlight"><pre data-language="crystal">$ crystal run ./hello_goodbye.cr -- -n
Unhandled exception: Invalid option: -n (OptionParser::InvalidOption)
  from ...
</pre></div> <p>Oh no! It‚Äôs broken: we need to handle <strong>invalid options</strong> and <strong>invalid parameters</strong> given to an option! For these two situations, the <code>OptionParser</code> class has two methods: <code>#invalid_option</code> and <code>#missing_option</code></p> <p>So, let's add this option handler and merge all these CLI applications into one fabulous CLI application!</p> <h4 id="all-my-cli-the-complete-application">All My CLI: The complete application!</h4> <p>Here‚Äôs the final result, with invalid/missing options handling, plus other new options:</p> <div class="crystal highlight"><pre data-language="crystal">require "option_parser"

the_beatles = [
  "John Lennon",
  "Paul McCartney",
  "George Harrison",
  "Ringo Starr",
]
shout = false
say_hi_to = ""
strawberry = false

option_parser = OptionParser.parse do |parser|
  parser.banner = "Welcome to The Beatles App!"

  parser.on "-v", "--version", "Show version" do
    puts "version 1.0"
    exit
  end
  parser.on "-h", "--help", "Show help" do
    puts parser
    exit
  end
  parser.on "-t", "--twist", "Twist and SHOUT" do
    shout = true
  end
  parser.on "-g NAME", "--goodbye_hello=NAME", "Say hello to whoever you want" do |name|
    say_hi_to = name
  end
  parser.on "-r", "--random_goodbye_hello", "Say hello to one random member" do
    say_hi_to = the_beatles.sample
  end
  parser.on "-s", "--strawberry", "Strawberry fields forever mode ON" do
    strawberry = true
  end
  parser.missing_option do |option_flag|
    STDERR.puts "ERROR: #{option_flag} is missing something."
    STDERR.puts ""
    STDERR.puts parser
    exit(1)
  end
  parser.invalid_option do |option_flag|
    STDERR.puts "ERROR: #{option_flag} is not a valid option."
    STDERR.puts parser
    exit(1)
  end
end

members = the_beatles
members = the_beatles.map &amp;.upcase if shout

puts "Strawberry fields forever mode ON" if strawberry

puts ""
puts "Group members:"
puts "=============="
members.each do |member|
  puts "#{strawberry ? "üçì" : "-"} #{member}"
end

unless say_hi_to.empty?
  puts ""
  puts "You say goodbye, and I say hello to #{say_hi_to}!"
end
</pre></div> <h3 id="request-for-user-input">Request for user input</h3> <p>Sometimes, we may need the user to input a value. How do we <em>read</em> that value? Easy, peasy! Let‚Äôs create a new application: the Fab Four will sing with us any phrase we want. When running the application, it will request a phrase to the user and the magic will happen!</p> <div class="crystal highlight"><pre data-language="crystal">puts "Welcome to The Beatles Sing-Along version 1.0!"
puts "Enter a phrase you want The Beatles to sing"
print "&gt; "
user_input = gets
puts "The Beatles are singing: üéµ#{user_input}üé∂üé∏ü•Å"
</pre></div> <p>The method <a href="https://crystal-lang.org/api/1.3.2/toplevel.html#gets%28*args,**options%29-class-method"><code>gets</code></a> will <strong>pause</strong> the execution of the application until the user finishes entering the input (pressing the <code>Enter</code> key). When the user presses <code>Enter</code>, then the execution will continue and <code>user_input</code> will have the user value.</p> <p>But what happens if the user doesn‚Äôt enter any value? In that case, we would get an empty string (if the user only presses <code>Enter</code>) or maybe a <code>Nil</code> value (if the input stream is closed, e.g. by pressing <code>Ctrl+D</code>). To illustrate the problem let‚Äôs try the following: we want the input entered by the user to be sung loudly:</p> <div class="crystal highlight"><pre data-language="crystal">puts "Welcome to The Beatles Sing-Along version 1.0!"
puts "Enter a phrase you want The Beatles to sing"
print "&gt; "
user_input = gets
puts "The Beatles are singing: üéµ#{user_input.upcase}üé∂üé∏ü•Å"
</pre></div> <p>When running the example, Crystal will reply:</p> <div class="highlight"><pre data-language="crystal">$ crystal run ./let_it_cli.cr
Showing last frame. Use --error-trace for full trace.

In let_it_cli.cr:5:46

 5 | puts "The Beatles are singing: üéµ#{user_input.upper_case}
                                                  ^---------
Error: undefined method 'upper_case' for Nil (compile-time type is (String | Nil))
</pre></div> <p>Ah! We should have known better: the type of the user input is the <a href="../syntax_and_semantics/type_grammar">union type</a> <code>String | Nil</code>. So, we have to test for <code>Nil</code> and for <code>empty</code> and act naturally for each case:</p> <div class="crystal highlight"><pre data-language="crystal">puts "Welcome to The Beatles Sing-Along version 1.0!"
puts "Enter a phrase you want The Beatles to sing"
print "&gt; "
user_input = gets

exit if user_input.nil? # Ctrl+D

default_lyrics = "Na, na, na, na-na-na na" \
                 " / " \
                 "Na-na-na na, hey Jude"

lyrics = user_input.presence || default_lyrics

puts "The Beatles are singing: üéµ#{lyrics.upcase}üé∂üé∏ü•Å"
</pre></div> <h2 id="output">Output</h2> <p>Now, we will focus on the second main topic: our application‚Äôs output. For starters, our applications already display information but (I think) we could do better. Let‚Äôs add more <em>life</em> (i.e. colors!) to the outputs.</p> <p>And to accomplish this, we will be using the <a href="https://crystal-lang.org/api/1.3.2/Colorize.html"><code>Colorize</code></a> module.</p> <p>Let‚Äôs build a really simple application that shows a string with colors! We will use a yellow font on a black background:</p> <div class="crystal highlight"><pre data-language="crystal">require "colorize"

puts "#{"The Beatles".colorize(:yellow).on(:black)} App"
</pre></div> <p>Great! That was easy! Now imagine using this string as the banner for our All My CLI application, it's easy if you try:</p> <div class="crystal highlight"><pre data-language="crystal">parser.banner = "#{"The Beatles".colorize(:yellow).on(:black)} App"
</pre></div> <p>For our second application, we will add a <em>text decoration</em> (<code>blink</code>in this case):</p> <div class="crystal highlight"><pre data-language="crystal">require "colorize"

puts "Welcome to The Beatles Sing-Along version 1.0!"
puts "Enter a phrase you want The Beatles to sing"
print "&gt; "
user_input = gets

exit if user_input.nil? # Ctrl+D

default_lyrics = "Na, na, na, na-na-na na" \
                 " / " \
                 "Na-na-na na, hey Jude"

lyrics = user_input.presence || default_lyrics

puts "The Beatles are singing: #{"üéµ#{lyrics}üé∂üé∏ü•Å".colorize.mode(:blink)}"
</pre></div> <p>Let‚Äôs try the renewed application ‚Ä¶ and <em>hear</em> the difference!! <strong>Now</strong> we have two fabulous apps!!</p> <p>You may find a list of <strong>available colors</strong> and <strong>text decorations</strong> in the <a href="https://crystal-lang.org/api/1.3.2/Colorize.html">API documentation</a>.</p> <h2 id="testing">Testing</h2> <p>As with any other application, at some point, we would like to <a href="../guides/testing">write tests</a> for the different features.</p> <p>Right now the code containing the logic of each of the applications always gets executed with the <code>OptionParser</code>, i.e. there is no way to include that file without running the whole application. So first we would need to refactor the code, separating the code necessary for parsing options from the logic. Once the refactoring is done, we could start testing the logic and including the file with the logic in the testing files we need. We leave this as an exercise for the reader.</p> <h2 id="using-readline-and-ncurses">Using <code>Readline</code> and <code>NCurses</code>
</h2> <p>In case we want to build richer CLI applications, there are libraries that can help us. Here we will name two well-known libraries: <code>Readline</code> and <code>NCurses</code>.</p> <p>As stated in the documentation for the <a href="http://www.gnu.org/software/readline/">GNU Readline Library</a>, <code>Readline</code> is a library that provides a set of functions for use by applications that allow users to edit command lines as they are typed in. <code>Readline</code> has some great features: filename autocompletion out of the box; custom auto-completion method; keybinding, just to mention a few. If we want to try it then the <a href="https://github.com/crystal-lang/crystal-readline">crystal-lang/crystal-readline</a> shard will give us an easy API to use <code>Readline</code>.</p> <p>On the other hand, we have <code>NCurses</code>(New Curses). This library allows developers to create <em>graphical</em> user interfaces in the terminal. As its name implies, it is an improved version of the library named <code>Curses</code>, which was developed to support a text-based dungeon-crawling adventure game called Rogue! As you can imagine, there are already <a href="https://crystalshards.org/shards/search?q=ncurses">a couple of shards</a> in the ecosystem that will allow us to use <code>NCurses</code> in Crystal!</p> <p>And so we have reached The End üòéüé∂</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://crystal-lang.org/reference/1.3/getting_started/cli.html" class="_attribution-link" target="_blank">https://crystal-lang.org/reference/1.3/getting_started/cli.html</a>
  </p>
</div>
