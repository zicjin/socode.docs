 <h1 id="github-actions">GitHub Actions</h1> <h2 id="build-and-run-specs">Build and run specs</h2> <p>To continuously test <a href="index#the-example-application">our example application</a> -- both whenever a commit is pushed and when someone opens a <a href="https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests">pull request</a>, add this minimal <a href="https://docs.github.com/en/actions/learn-github-actions/introduction-to-github-actions#create-an-example-workflow">workflow file</a>:</p> <div class="highlight">
<span class="filename">.github/workflows/ci.yml</span><pre data-language="crystal">on:
  push:
  pull_request:
    branches: [master]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Download source
        uses: actions/checkout@v2
      - name: Install Crystal
        uses: crystal-lang/install-crystal@v1
      - name: Run tests
        run: crystal spec
</pre>
</div> <p>To get started with <a href="https://docs.github.com/en/actions/guides/about-continuous-integration#about-continuous-integration-using-github-actions">GitHub Actions</a>, commit this YAML file into your Git repository under the directory <code>.github/workflows/</code>, push it to GitHub, and observe the Actions tab.</p> <div class="admonition tip"> <p class="admonition-title">Quickstart</p> <p>Check out <a href="https://crystal-lang.github.io/install-crystal/configurator.html"><strong>Configurator for <em>install-crystal</em> action</strong></a> to quickly get a config with the CI features you need. Or continue reading for more details.</p> </div> <p>This runs on GitHub's <a href="https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-runners-and-hardware-resources">default</a> "latest Ubuntu" container. It downloads the source code from the repository itself (directly into the current directory), installs Crystal via <a href="https://github.com/crystal-lang/install-crystal">Crystal's official GitHub Action</a>, then runs the specs, assuming they are there in the <code>spec/</code> directory.</p> <p>If any step fails, the build will show up as failed, notify the author and, if it's a push, set the overall build status of the project to failing.</p> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>For a healthier codebase, consider these flags for <code>crystal spec</code>:<br> <code>--order=random</code> <code>--error-on-warnings</code></p> </div> <h3 id="no-specs">No specs?</h3> <p>If your test coverage isn't great, consider at least adding an example program, and building it as part of CI:</p> <p>For a library:</p> <div class="highlight"><pre data-language="crystal">          - name: Build example
            run: crystal build examples/hello.cr
</pre></div> <p>For an application (very good to do even if you have specs):</p> <div class="highlight"><pre data-language="crystal">          - name: Build
            run: crystal build src/game_of_life.cr
</pre></div> <h3 id="testing-with-different-versions-of-crystal">Testing with different versions of Crystal</h3> <p>By default, the latest released version of Crystal is installed. But you may want to also test with the "nightly" build of Crystal, and perhaps some older versions that you still support for your project. Change the top of the workflow as follows:</p> <div class="highlight"><pre data-language="crystal">jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        crystal: [0.35.1, latest, nightly]
    runs-on: ubuntu-latest
    steps:
      - name: Download source
        uses: actions/checkout@v2
      - name: Install Crystal
        uses: crystal-lang/install-crystal@v1
        with:
          crystal: ${{ matrix.crystal }}
      - ...
</pre></div> <p>All those versions will be tested for <em>in parallel</em>.</p> <p>By specifying the version of Crystal you could even opt <em>out</em> of supporting the latest version (which <em>is</em> a moving target), and only support particular ones.</p> <h3 id="testing-on-multiple-operating-systems">Testing on multiple operating systems</h3> <p>Typically, developers run tests only on Ubuntu, which is OK if there is no platform-sensitive code. But it's easy to add another <a href="https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-runners-and-hardware-resources">system</a> into the test matrix, just add the following near the top of your job definition:</p> <div class="highlight"><pre data-language="crystal">jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - ...
</pre></div> <h2 id="installing-shards-packages">Installing Shards packages</h2> <p>Most projects will have external dependencies, <a href="https://github.com/crystal-lang/shards#usage">"shards"</a>. Having declared them in <code>shard.yml</code>, just add the installation step into your workflow (after <code>install-crystal</code> and before any testing):</p> <div class="highlight"><pre data-language="crystal">      - name: Install shards
        run: shards install
</pre></div> <h3 id="latest-or-locked-dependencies">Latest or locked dependencies?</h3> <p>If your repository has a checked in <code>shard.lock</code> file (typically good for applications), consider the effect that this has on CI: <code>shards install</code> will always install the exact versions specified in that file. But if you're developing a library, you probably want to be the first to find out in case a new version of a dependency breaks the installation of your library -- otherwise the users will, because the lock doesn't apply transitively. So, strongly consider running <code>shards update</code> instead of <code>shards install</code>, or don't check in <code>shard.lock</code>. And then it makes sense to add <a href="https://www.jeffgeerling.com/blog/2020/running-github-actions-workflow-on-schedule-and-other-events">scheduled runs</a> to your repository.</p> <h2 id="installing-binary-dependencies">Installing binary dependencies</h2> <p>Our application or some shards may require external libraries. The approach to installing them can vary widely. The typical way is to install packages using the <code>apt</code> command in Ubuntu.</p> <p>Add the installation step somewhere near the beginning. For example, with <code>libsqlite3</code>:</p> <div class="highlight"><pre data-language="crystal">      - name: Install packages
        run: sudo apt-get -qy install libsqlite3-dev
</pre></div> <h2 id="enforcing-code-formatting">Enforcing code formatting</h2> <p>If you want to verify that all your code has been formatted with <a href="../writing_shards#coding-style"><code>crystal tool format</code></a>, add the according check as a step near the end of the workflow. If someone pushes code that is not formatted correctly, this will break the build just like failing tests would.</p> <div class="highlight"><pre data-language="crystal">      - name: Check formatting
        run: crystal tool format --check
</pre></div> <p>Consider also adding this check as a <em>Git pre-commit hook</em> for yourself.</p> <h2 id="using-the-official-docker-image">Using the official Docker image</h2> <p>We have been using an "action" to install Crystal into the default OS image that GitHub provides. Which <a href="https://forum.crystal-lang.org/t/github-action-to-install-crystal-and-shards-unified-ci-across-linux-macos-and-windows/2837">has multiple advantages</a>. But you may instead choose to use Crystal's official Docker image(s), though that's applicable only to Linux.</p> <p>The base config becomes this instead:</p> <div class="highlight">
<span class="filename">.github/workflows/ci.yml</span><pre data-language="crystal">jobs:
  build:
    runs-on: ubuntu-latest
    container:
      image: crystallang/crystal:latest
    steps:
      - name: Download source
        uses: actions/checkout@v2

      - name: Run tests
        run: crystal spec
</pre>
</div> <p>Some <a href="https://hub.docker.com/r/crystallang/crystal/tags">other options</a> for containers are <code>crystallang/crystal:nightly</code>, <code>crystallang/crystal:0.36.1</code>, <code>crystallang/crystal:latest-alpine</code>.</p> <h2 id="caching">Caching</h2> <p>The process of downloading and installing dependencies (shards specifically) is done from scratch on every run. With caching in GitHub Actions, we can save some of that duplicated work.</p> <p>The safe approach is to add the <a href="https://github.com/actions/cache">actions/cache</a> step (<strong>before the step that uses <code>shards</code></strong>) defined as follows:</p> <div class="highlight"><pre data-language="crystal">      - name: Cache shards
        uses: actions/cache@v2
        with:
          path: ~/.cache/shards
          key: ${{ runner.os }}-shards-${{ hashFiles('shard.yml') }}
          restore-keys: ${{ runner.os }}-shards-
      - name: Install shards
        run: shards update
</pre></div> <div class="admonition danger"> <p class="admonition-title">Important</p> <p>You <strong>must</strong> use the separate <a href="https://docs.github.com/en/actions/guides/caching-dependencies-to-speed-up-workflows#matching-a-cache-key"><code>key</code> and <code>restore-keys</code></a>. With just a static key, the cache would save only the state after the very first run and then keep reusing it forever, regardless of any changes.</p> </div> <p>But this saves us only the time spent <em>downloading</em> the repositories initially.</p> <p>A "braver" approach is to cache the <code>lib</code> directory itself, but that works only if you fully rely on <code>shard.lock</code> (see <a href="#latest-or-locked-dependencies">Latest or locked dependencies?</a>):</p> <div class="highlight"><pre data-language="crystal">      - name: Cache shards
        uses: actions/cache@v2
        with:
          path: lib
          key: ${{ runner.os }}-shards-${{ hashFiles('**/shard.lock') }}
      - name: Install shards
        run: shards check || shards install
</pre></div> <p>Note that we also made the installation conditional on <code>shards check</code>. That saves even a little more time.</p> <h2 id="publishing-executables">Publishing executables</h2> <p>If your project is an application, you likely want to distribute it as an executable ("binary") file. For the case of Linux x86_64, by far the most popular option is to build and <a href="../static_linking">link statically</a> <a href="../static_linking#linux">on Alpine Linux</a>. This means that you <em>cannot</em> use GitHub's default Ubuntu container and the install action. Instead, just use the official container:</p> <div class="highlight">
<span class="filename">.github/workflows/release.yml</span><pre data-language="crystal">jobs:
  release_linux:
    runs-on: ubuntu-latest
    container:
      image: crystallang/crystal:latest-alpine
    steps:
      - uses: actions/checkout@v2
      - run: shards build --production --release --static --no-debug
</pre>
</div> <p>These steps would be followed by some action to publish the produced executable (<code>bin/*</code>), in one of the two ways (or both of them):</p> <ul> <li> <p>As part of a release: <a href="https://github.com/Blacksmoke16/oq/blob/56bd3d306ede15e86481d7b5db4af7f89b85a37f/.github/workflows/deployment.yml">see complete example</a>.<br> Then in your README you can link to the latest release using a URL such as <a href="https://github.com/:username/:reponame/releases/latest">https://github.com/:username/:reponame/releases/latest</a></p> </li> <li> <p>As part of the CI done for every commit, via <a href="https://github.com/actions/upload-artifact">actions/upload-artifact</a>.<br> Then consider linking to the latest "nightly" build using the external service <a href="https://nightly.link/">https://nightly.link/</a></p> </li> </ul> <p>Distributing executables for macOS (<a href="https://github.com/search?q=%22macos-latest%22+%22shards+build%22+%22--release%22+dylib+path%3A.github%2Fworkflows&amp;type=Code">search for examples</a>) and Windows (<a href="https://github.com/search?l=YAML&amp;q=%22windows-latest%22+%22shards+build%22+%22--release%22+path%3A.github%2Fworkflows&amp;type=Code">search for examples</a>) is also possible.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://crystal-lang.org/reference/1.3/guides/ci/gh-actions.html" class="_attribution-link" target="_blank">https://crystal-lang.org/reference/1.3/guides/ci/gh-actions.html</a>
  </p>
</div>
