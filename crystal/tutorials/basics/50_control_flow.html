 <h1 id="control-flow">Control Flow</h1> <h2 id="primitive-types">Primitive Types</h2> <h3 id="nil">Nil</h3> <p>The most simplistic type is <code>Nil</code>. It has only a single value: <code>nil</code> and represents the absence of an actual value.</p> <p>Remember <a href="40_strings#indexing-substrings"><code>String#index</code> from last lesson</a>? It returns <code>nil</code> if the substring does not exist in the search string. It has no index, so the index position is absent.</p> <div class="crystal-play highlight"><pre data-language="crystal">p! "Crystal is awesome".index("aw"),
  "Crystal is awesome".index("xxxx")
</pre></div> <h3 id="bool">Bool</h3> <p>The <code>Bool</code> type has just two possible values: <code>true</code> and <code>false</code> which represent the truth values of logic and Boolean algebra.</p> <div class="crystal-play highlight"><pre data-language="crystal">p! true, false
</pre></div> <p><a href="https://en.wikipedia.org/wiki/Boolean_data_type">Boolean values</a> are particularly useful for managing control flow in a program.</p> <h2 id="boolean-algebra">Boolean Algebra</h2> <p>The following example shows operators for implementing <a href="https://en.wikipedia.org/wiki/Boolean_algebra">boolean algebra</a> with boolean values:</p> <div class="crystal-play highlight"><pre data-language="crystal">a = true
b = false

p! a &amp;&amp; b, # conjunction (AND)
  a || b,  # disjunction (OR)
  !a,      # negation (NOT)
  a != b,  # inequivalence (XOR)
  a == b   # equivalence
</pre></div> <p>You can try flicking the values of <code>a</code> and <code>b</code> to see the operator behaviour for different input values.</p> <h3 id="truthiness">Truthiness</h3> <p>Boolean algebra isn't limited to just boolean types, though. All values have an implicit truthiness: <code>nil</code>, <code>false</code>, and null pointers (just for completeness, we cover that later) are <em>falsey</em>. Any other value (including <code>0</code>) is <em>truthy</em>.</p> <p>Let's replace <code>true</code> and <code>false</code> in the above example with other values, for example <code>"foo"</code> and <code>nil</code>.</p> <div class="crystal-play highlight"><pre data-language="crystal">a = "foo"
b = nil

p! a &amp;&amp; b, # conjunction (AND)
  a || b,  # disjunction (OR)
  !a,      # negation (NOT)
  a != b,  # inequivalence (XOR)
  a == b   # equivalence
</pre></div> <p>The <code>AND</code> and <code>OR</code> operators return the first operand value matching the operator's truthiness.</p> <div class="crystal-play highlight"><pre data-language="crystal">p! "foo" &amp;&amp; nil,
  "foo" &amp;&amp; false,
  false || "foo",
  "bar" || "foo"
</pre></div> <p>The <code>NOT</code>, <code>XOR</code>, and equivalence operators always return a <code>Bool</code> value (<code>true</code> or <code>false</code>).</p> <h2 id="control-flow_1">Control Flow</h2> <p>Controlling the flow of a program means taking different paths based on conditions. Up until now, every program in this tutorial has been a sequential series of expressions. Now this is going to change.</p> <h3 id="conditionals">Conditionals</h3> <p>A conditional clause puts a branch of code behind a gate that only opens if the condition is met.</p> <p>In the most basic form, it consists of a keyword <code>if</code> followed by an expression serving as the condition. The condition is met when the return value of the expression is <em>truthy</em>. All subsequent expressions are part of the branch until it closes with the keyword <code>end</code>.</p> <p>Per convention, we indent nested branches by two spaces.</p> <p>The following example prints the message only if it meets the condition to start with <code>Hello</code>.</p> <div class="crystal-play highlight"><pre data-language="crystal">message = "Hello World"

if message.starts_with?("Hello")
  puts "Hello to you, too!"
end
</pre></div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Technically, this program still runs in a predefined order. The fixed message always matches and makes the condition truthy. But let's assume we don't define the value of the message in the source code. It could just as well come from user input, for example a chat client.</p> </div> <p>If the message has a value that does not start with <code>Hello</code>, the conditional branch skips, and the program prints nothing.</p> <p>The condition expression can be more complex. With <a href="#boolean-algebra">boolean algebra</a> we can construct a condition that accepts either <code>Hello</code> or <code>Hi</code>:</p> <div class="crystal-play highlight"><pre data-language="crystal">message = "Hello World"

if message.starts_with?("Hello") || message.starts_with?("Hi")
  puts "Hey there!"
end
</pre></div> <p>Let's turn the condition around: Only print the message if it does <em>not</em> start with <code>Hello</code>. That's just a minor deviation from the previous example: We can use the negation operator (<code>!</code>) to turn the condition into the opposite expression.</p> <div class="crystal-play highlight"><pre data-language="crystal">message = "Hello World"

if !message.starts_with?("Hello")
  puts "I didn't understand that."
end
</pre></div> <p>An alternative is to replace <code>if</code> with the keyword <code>unless</code> which expects just the opposite truthiness. <code>unless x</code> is equivalent to <code>if !x</code>.</p> <div class="crystal-play highlight"><pre data-language="crystal">message = "Hello World"

unless message.starts_with?("Hello")
  puts "I didn't understand that."
end
</pre></div> <p>Let's look at an example that uses <code>String#index</code> to find a substring and highlight its location. Remember that it returns <code>nil</code> if it can't find the substring? In that case, we can't highlight anything. So we need an <code>if</code> clause with a condition that checks if the index is <code>nil</code>. The <code>.nil?</code> method is perfect for that.</p> <div class="crystal-play highlight"><pre data-language="crystal">str = "Crystal is awesome"
index = str.index("aw")

if !index.nil?
  puts str
  puts "#{" " * index}^^"
end
</pre></div> <p>The compiler enforces that you handle the <code>nil</code> case. Try to remove the conditional or change the condition to <code>true</code>: a type error shows up and explains that you can't use a <code>Nil</code> value in that expression. With the proper condition, the compiler knows that <code>index</code> can't be <code>nil</code> inside the branch and it can be used as a numeric input.</p> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>A shorter form for <code>if !index.nil?</code> is <code>if index</code>, which is mostly equivalent. It only makes a difference if you wanted to tell apart whether a falsey value is <code>nil</code> or <code>false</code> because the former condition matches for <code>false</code>, while the latter does not.</p> </div> <h3 id="else">Else</h3> <p>Let's refine our program and react in both cases, whether the message meets the condition or not.</p> <p>We can do this as two separate conditionals with negated conditions:</p> <div class="crystal-play highlight"><pre data-language="crystal">message = "Hello World"

if message.starts_with?("Hello")
  puts "Hello to you, too!"
end

if !message.starts_with?("Hello")
  puts "I didn't understand that."
end
</pre></div> <p>This works but there are two drawbacks: The condition expression <code>message.starts_with?("Hello")</code> evaluates twice, which is inefficient. Later, if we change the condition in one place (maybe allowing <code>Hi</code> as well), we might forget to change the other one as well.</p> <p>A conditional can have multiple branches. The alternate branch is indicated by the keyword <code>else</code>. It executes if the condition is not met.</p> <div class="crystal-play highlight"><pre data-language="crystal">message = "Hello World"

if message.starts_with?("Hello")
  puts "Hello to you, too!"
else
  puts "I didn't understand that."
end
</pre></div> <h3 id="more-branches">More branches</h3> <p>Our program only reacts to <code>Hello</code>, but we want more interaction. Let's add a branch to respond to <code>Bye</code> as well. We can have branches for different conditions in the same conditional. It's like an <code>else</code> with another integrated <code>if</code>. Hence the keyword is <code>elsif</code>:</p> <div class="crystal-play highlight"><pre data-language="crystal">message = "Bye World"

if message.starts_with?("Hello")
  puts "Hello to you, too!"
elsif message.starts_with?("Bye")
  puts "See you later!"
else
  puts "I didn't understand that."
end
</pre></div> <p>The <code>else</code> branch still only executes if neither of the previous conditions is met. It can always be omitted, though.</p> <p>Note that the different branches are mutually exclusive and conditions evaluate from top to bottom. In the above example that doesn't matter because both conditions can't be truthy at the same time (the message can't start with both <code>Hello</code> and <code>Bye</code>). However, we can add an alternative condition that is not exclusive to demonstrate this:</p> <div class="crystal-play highlight"><pre data-language="crystal">message = "Hello Crystal"

if message.starts_with?("Hello")
  puts "Hello to you, too!"
elsif message.includes?("Crystal")
  puts "Shine bright like a crystal."
end

if message.includes?("Crystal")
  puts "Shine bright like a crystal."
elsif message.starts_with?("Hello")
  puts "Hello to you, too!"
end
</pre></div> <p>Both clauses have branches with the same conditions but in a different order and they behave differently. The first matching condition selects which branch executes.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://crystal-lang.org/reference/1.3/tutorials/basics/50_control_flow.html" class="_attribution-link" target="_blank">https://crystal-lang.org/reference/1.3/tutorials/basics/50_control_flow.html</a>
  </p>
</div>
