 <h1 id="assignment">Assignment</h1> <p>An assignment expression assigns a value to a named identifier (usually a variable). The <a href="operators#assignments">assignment operator</a> is the equals sign (<code>=</code>).</p> <p>The target of an assignment can be:</p> <ul> <li>a <a href="local_variables">local variable</a>
</li> <li>an <a href="methods_and_instance_variables">instance variable</a>
</li> <li>a <a href="class_variables">class variable</a>
</li> <li>a <a href="constants">constant</a>
</li> <li>an assignment method</li> </ul> <div class="crystal highlight"><pre data-language="crystal"># Assigns to a local variable
local = 1

# Assigns to an instance variable
@instance = 2

# Assigns to a class variable
@@class = 3

# Assigns to a constant
CONST = 4

# Assigns to a setter method
foo.method = 5
foo[0] = 6
</pre></div> <h3 id="method-as-assignment-target">Method as assignment target</h3> <p>A method ending with an equals sign (<code>=</code>) is called a setter method. It can be used as the target of an assignment. The semantics of the assignment operator apply as a form of syntax sugar to the method call.</p> <p>Calling setter methods requires an explicit receiver. The receiver-less syntax <code>x = y</code> is always parsed as an assignment to a local variable, never a call to a method <code>x=</code>. Even adding parentheses does not force a method call, as it would when reading from a local variable.</p> <p>The following example shows two calls to a setter method in typical method notation and with assignment operator. Both assignment expressions are equivalent.</p> <div class="crystal highlight"><pre data-language="crystal">class Thing
  def name=(value); end
end

thing = Thing.new

thing.name=("John")
thing.name = "John"
</pre></div> <p>The following example shows two calls to an indexed assignment method in typical method notation and with index assignment operator. Both assignment expressions are equivalent.</p> <div class="crystal highlight"><pre data-language="crystal">class List
  def []=(key, value); end
end

list = List.new

list.[]=(2, 3)
list[2] = 3
</pre></div> <h3 id="combined-assignments">Combined assignments</h3> <p><a href="operators#combined-assignments">Combined assignments</a> are a combination of an assignment operator and another operator. This works with any target type except constants.</p> <p>Some syntax sugar that contains the <code>=</code> character is available:</p> <div class="highlight"><pre data-language="crystal">local += 1  # same as: local = local + 1
</pre></div> <p>This assumes that the corresponding target <code>local</code> is assignable, either as a variable or via the respective getter and setter methods.</p> <p>The <code>=</code> operator syntax sugar is also available to setter and index assignment methods. Note that <code>||</code> and <code>&amp;&amp;</code> use the <code>[]?</code> method to check for key presence.</p> <div class="crystal highlight"><pre data-language="crystal">person.age += 1 # same as: person.age = person.age + 1

person.name ||= "John" # same as: person.name || (person.name = "John")
person.name &amp;&amp;= "John" # same as: person.name &amp;&amp; (person.name = "John")

objects[1] += 2 # same as: objects[1] = objects[1] + 2

objects[1] ||= 2 # same as: objects[1]? || (objects[1] = 2)
objects[1] &amp;&amp;= 2 # same as: objects[1]? &amp;&amp; (objects[1] = 2)
</pre></div> <h2 id="chained-assignment">Chained assignment</h2> <p>The same value can be assigned to multiple targets using chained assignment. This works with any target type except constants.</p> <div class="crystal highlight"><pre data-language="crystal">a = b = c = 123

# Now a, b and c have the same value:
a # =&gt; 123
b # =&gt; 123
c # =&gt; 123
</pre></div> <h2 id="multiple-assignment">Multiple assignment</h2> <p>You can declare/assign multiple variables at the same time by separating expressions with a comma (<code>,</code>). This works with any target type except constants.</p> <div class="crystal highlight"><pre data-language="crystal">name, age = "Crystal", 1

# The above is the same as this:
temp1 = "Crystal"
temp2 = 1
name = temp1
age = temp2
</pre></div> <p>Note that because expressions are assigned to temporary variables it is possible to exchange variablesâ€™ contents in a single line:</p> <div class="crystal highlight"><pre data-language="crystal">a = 1
b = 2
a, b = b, a
a # =&gt; 2
b # =&gt; 1
</pre></div> <p>Multiple assignment is also available to methods that end with <code>=</code>:</p> <div class="crystal highlight"><pre data-language="crystal">person.name, person.age = "John", 32

# Same as:
temp1 = "John"
temp2 = 32
person.name = temp1
person.age = temp2
</pre></div> <p>And it is also available to <a href="operators#assignments">index assignments</a> (<code>[]=</code>):</p> <div class="crystal highlight"><pre data-language="crystal">objects[1], objects[2] = 3, 4

# Same as:
temp1 = 3
temp2 = 4
objects[1] = temp1
objects[2] = temp2
</pre></div> <h3 id="one-to-many-assignment">One-to-many assignment</h3> <p>If the right-hand side contains just one expression, the type is indexed for each variable on the left-hand side like so:</p> <div class="crystal highlight"><pre data-language="crystal">name, age, source = "Crystal, 123, GitHub".split(", ")

# The above is the same as this:
temp = "Crystal, 123, GitHub".split(", ")
name = temp[0]
age = temp[1]
source = temp[2]
</pre></div> <p>Additionally, if the <a href="compile_time_flags"><code>strict_multi_assign</code> flag</a> is provided, the number of elements must match the number of targets, and the right-hand side must be an <a href="https://crystal-lang.org/api/1.5.0/Indexable.html"><code>Indexable</code></a>:</p> <div class="crystal highlight"><pre data-language="crystal">name, age, source = "Crystal, 123, GitHub".split(", ")

# The above is the same as this:
temp = "Crystal, 123, GitHub".split(", ")
if temp.size != 3 # number of targets
  raise IndexError.new("Multiple assignment count mismatch")
end
name = temp[0]
age = temp[1]
source = temp[2]

a, b = {0 =&gt; "x", 1 =&gt; "y"} # Error: right-hand side of one-to-many assignment must be an Indexable, not Hash(Int32, String)
</pre></div> <h3 id="splat-assignment">Splat assignment</h3> <p>The left-hand side of an assignment may contain one splat, which collects any values not assigned to the other targets. A <a href="literals/range">range</a> index is used if the right-hand side has one expression:</p> <div class="crystal highlight"><pre data-language="crystal">head, *rest = [1, 2, 3, 4, 5]

# Same as:
temp = [1, 2, 3, 4, 5]
head = temp[0]
rest = temp[1..]
</pre></div> <p>Negative indices are used for targets after the splat:</p> <div class="crystal highlight"><pre data-language="crystal">*rest, tail1, tail2 = [1, 2, 3, 4, 5]

# Same as:
temp = [1, 2, 3, 4, 5]
rest = temp[..-3]
tail1 = temp[-2]
tail2 = temp[-1]
</pre></div> <p>If the expression does not have enough elements and the splat appears in the middle of the targets, <a href="https://crystal-lang.org/api/1.5.0/IndexError.html"><code>IndexError</code></a> is raised:</p> <div class="crystal highlight"><pre data-language="crystal">a, b, *c, d, e, f = [1, 2, 3, 4]

# Same as:
temp = [1, 2, 3, 4]
if temp.size &lt; 5 # number of non-splat assignment targets
  raise IndexError.new("Multiple assignment count mismatch")
end
# note that the following assignments would incorrectly not raise if the above check is absent
a = temp[0]
b = temp[1]
c = temp[2..-4]
d = temp[-3]
e = temp[-2]
f = temp[-1]
</pre></div> <p>The right-hand side expression must be an <a href="https://crystal-lang.org/api/1.5.0/Indexable.html"><code>Indexable</code></a>. Both the size check and the <code>Indexable</code> check occur even without the <code>strict_multi_assign</code> flag (see <a href="#one-to-many-assignment">One-to-many assignment</a> above).</p> <p>A <a href="https://crystal-lang.org/api/1.5.0/Tuple.html"><code>Tuple</code></a> is formed if there are multiple values:</p> <div class="crystal highlight"><pre data-language="crystal">*a, b, c = 3, 4, 5, 6, 7

# Same as:
temp1 = {3, 4, 5}
temp2 = 6
temp3 = 7
a = temp1
b = temp2
c = temp3
</pre></div> <h2 id="underscore">Underscore</h2> <p>The underscore can appear on the left-hand side of any assignment. Assigning a value to it has no effect and the underscore cannot be read from:</p> <div class="crystal highlight"><pre data-language="crystal">_ = 1     # no effect
_ = "123" # no effect
puts _    # Error: can't read from _
</pre></div> <p>It is useful in multiple assignment when some of the values returned by the right-hand side are unimportant:</p> <div class="crystal highlight"><pre data-language="crystal">before, _, after = "main.cr".partition(".")

# The above is the same as this:
temp = "main.cr".partition(".")
before = temp[0]
_ = temp[1] # this line has no effect
after = temp[2]
</pre></div> <p>Assignments to <code>*_</code> are dropped altogether, so multiple assignments can be used to extract the first and last elements in a value efficiently, without creating an intermediate object for the elements in the middle:</p> <div class="crystal highlight"><pre data-language="crystal">first, *_, last = "127.0.0.1".split(".")

# Same as:
temp = "127.0.0.1".split(".")
if temp.size &lt; 2
  raise IndexError.new("Multiple assignment count mismatch")
end
first = temp[0]
last = temp[-1]
</pre></div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://crystal-lang.org/reference/1.5/syntax_and_semantics/assignment.html" class="_attribution-link" target="_blank">https://crystal-lang.org/reference/1.5/syntax_and_semantics/assignment.html</a>
  </p>
</div>
