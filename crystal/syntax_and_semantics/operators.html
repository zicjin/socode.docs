 <h1 id="operators">Operators</h1> <p>Crystal supports a number of operators, with one, two or three operands.</p> <p>Operator expressions are actually parsed as method calls. For example <code>a + b</code> is semantically equivalent to <code>a.+(b)</code>, a call to method <code>+</code> on <code>a</code> with argument <code>b</code>.</p> <p>There are however some special rules regarding operator syntax:</p> <ul> <li>The dot (<code>.</code>) usually put between receiver and method name (i.e. the <em>operator</em>) can be omitted.</li> <li>Chained sequences of operator calls are restructured by the compiler in order to implement <a href="#operator-precedence">operator precedence</a>. Enforcing operator precedence makes sure that an expression such as <code>1 * 2 + 3 * 4</code> is parsed as <code>(1 * 2) + (2 * 3)</code> to honour regular math rules.</li> <li>Regular method names must start with a letter or underscore, but operators only consist of special characters. Any method not starting with a letter or underscore is an operator method.</li> <li>Available operators are whitelisted in the compiler (see <a href="#list-of-operators">List of Operators</a> below) which allows symbol-only method names and treats them as operators, including their precedence rules.</li> </ul> <p>Operators are implemented like any regular method, and the standard library offers many implementations, for example for math expressions.</p> <h2 id="defining-operator-methods">Defining operator methods</h2> <p>Most operators can be implemented as regular methods.</p> <p>One can assign any meaning to the operators, but it is advisable to stay within similar semantics to the generic operator meaning to avoid cryptic code that is confusing and behaves unexpectedly.</p> <p>A few operators are defined directly by the compiler and cannot be redefined in user code. Examples for this are the inversion operator <code>!</code>, the assignment operator <code>=</code>, <a href="#combined-assignments">combined assignment operators</a> such as <code>||=</code> and <a href="#range">range operators</a>. Whether a method can be redefined is indicated by the colum <em>Overloadable</em> in the below operator tables.</p> <h3 id="unary-operators">Unary operators</h3> <p>Unary operators are written in prefix notation and have only a single operand. Thus, a method implementation receives no arguments and only operates on <code>self</code>.</p> <p>The following example demonstrates the <code>Vector2</code> type as a two-dimensional vector with a unary operator method <code>-</code> for vector inversion.</p> <div class="crystal highlight"><pre data-language="crystal">struct Vector2
  getter x, y

  def initialize(@x : Int32, @y : Int32)
  end

  # Unary operator. Returns the inverted vector to `self`.
  def - : self
    Vector2.new(-x, -y)
  end
end

v1 = Vector2.new(1, 2)
-v1 # =&gt; Vector2(@x=-1, @y=-2)
</pre></div> <h2 id="binary-operators">Binary operators</h2> <p>Binary operators have two operands. Thus, a method implementation receives exactly one argument representing the second operand. The first operand is the receiver <code>self</code>.</p> <p>The following example demonstrates the <code>Vector2</code> type as a two-dimensional vector with a binary operator method <code>+</code> for vector addition.</p> <div class="crystal highlight"><pre data-language="crystal">struct Vector2
  getter x, y

  def initialize(@x : Int32, @y : Int32)
  end

  # Binary operator. Returns *other* added to `self`.
  def +(other : self) : self
    Vector2.new(x + other.x, y + other.y)
  end
end

v1 = Vector2.new(1, 2)
v2 = Vector2.new(3, 4)
v1 + v2 # =&gt; Vector2(@x=4, @y=6)
</pre></div> <p>Per convention, the return type of a binary operator should be the type of the first operand (the receiver), so that <code>typeof(a &lt;op&gt; b) == typeof(a)</code>. Otherwise the assignment operator (<code>a &lt;op&gt;= b</code>) would unintentionally change the type of <code>a</code>. There can be reasonable exceptions though. For example in the standard library the float division operator <code>/</code> on integer types always returns <code>Float64</code>, because the quotient must not be limited to the value range of integers.</p> <h2 id="ternary-operators">Ternary operators</h2> <p>The <a href="ternary_if">conditional operator (<code>? :</code>)</a> is the only ternary operator. It not parsed as a method, and its meaning cannot be changed. The compiler transforms it to an <code>if</code> expression.</p> <h2 id="operator-precedence">Operator Precedence</h2> <p>This list is sorted by precedence, so upper entries bind stronger than lower ones.</p> <table> <thead> <tr> <th>Category</th> <th>Operators</th> </tr> </thead> <tbody> <tr> <td>Index accessors</td> <td>
<code>[]</code>, <code>[]?</code>
</td> </tr> <tr> <td>Unary</td> <td>
<code>+</code>, <code>&amp;+</code>, <code>-</code>, <code>&amp;-</code>, <code>!</code>, <code>~</code>
</td> </tr> <tr> <td>Exponential</td> <td>
<code>**</code>, <code>&amp;**</code>
</td> </tr> <tr> <td>Multiplicative</td> <td>
<code>*</code>, <code>&amp;*</code>, <code>/</code>, <code>//</code>, <code>%</code>
</td> </tr> <tr> <td>Additive</td> <td>
<code>+</code>, <code>&amp;+</code>, <code>-</code>, <code>&amp;-</code>
</td> </tr> <tr> <td>Shift</td> <td>
<code>&lt;&lt;</code>, <code>&gt;&gt;</code>
</td> </tr> <tr> <td>Binary AND</td> <td><code>&amp;</code></td> </tr> <tr> <td>Binary OR/XOR</td> <td>
<code>|</code>,<code>^</code>
</td> </tr> <tr> <td>Equality</td> <td>
<code>==</code>, <code>!=</code>, <code>=~</code>, <code>!~</code>, <code>===</code>
</td> </tr> <tr> <td>Comparison</td> <td>
<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;=&gt;</code>
</td> </tr> <tr> <td>Logical AND</td> <td><code>&amp;&amp;</code></td> </tr> <tr> <td>Logical OR</td> <td><code>||</code></td> </tr> <tr> <td>Range</td> <td>
<code>..</code>, <code>...</code>
</td> </tr> <tr> <td>Conditional</td> <td><code>?:</code></td> </tr> <tr> <td>Assignment</td> <td>
<code>=</code>, <code>[]=</code>, <code>+=</code>, <code>&amp;+=</code>, <code>-=</code>, <code>&amp;-=</code>, <code>*=</code>, <code>&amp;*=</code>, <code>/=</code>, <code>//=</code>, <code>%=</code>, <code>|=</code>, <code>&amp;=</code>,<code>^=</code>,<code>**=</code>,<code>&lt;&lt;=</code>,<code>&gt;&gt;=</code>, <code>||=</code>, <code>&amp;&amp;=</code>
</td> </tr> <tr> <td>Splat</td> <td>
<code>*</code>, <code>**</code>
</td> </tr> </tbody> </table> <h2 id="list-of-operators">List of operators</h2> <h3 id="arithmetic-operators">Arithmetic operators</h3> <h4 id="unary">Unary</h4> <table> <thead> <tr> <th>Operator</th> <th>Description</th> <th>Example</th> <th>Overloadable</th> <th>Associativity</th> </tr> </thead> <tbody> <tr> <td><code>+</code></td> <td>positive</td> <td><code>+1</code></td> <td>yes</td> <td>right</td> </tr> <tr> <td><code>&amp;+</code></td> <td>wrapping positive</td> <td><code>&amp;+1</code></td> <td>yes</td> <td>right</td> </tr> <tr> <td><code>-</code></td> <td>negative</td> <td><code>-1</code></td> <td>yes</td> <td>right</td> </tr> <tr> <td><code>&amp;-</code></td> <td>wrapping negative</td> <td><code>&amp;-1</code></td> <td>yes</td> <td>right</td> </tr> </tbody> </table> <h4 id="multiplicative">Multiplicative</h4> <table> <thead> <tr> <th>Operator</th> <th>Description</th> <th>Example</th> <th>Overloadable</th> <th>Associativity</th> </tr> </thead> <tbody> <tr> <td><code>**</code></td> <td>exponentiation</td> <td><code>1 ** 2</code></td> <td>yes</td> <td>right</td> </tr> <tr> <td><code>&amp;**</code></td> <td>wrapping exponentiation</td> <td><code>1 &amp;** 2</code></td> <td>yes</td> <td>right</td> </tr> <tr> <td><code>*</code></td> <td>multiplication</td> <td><code>1 * 2</code></td> <td>yes</td> <td>left</td> </tr> <tr> <td><code>&amp;*</code></td> <td>wrapping multiplication</td> <td><code>1 &amp;* 2</code></td> <td>yes</td> <td>left</td> </tr> <tr> <td><code>/</code></td> <td>division</td> <td><code>1 / 2</code></td> <td>yes</td> <td>left</td> </tr> <tr> <td><code>//</code></td> <td>floor division</td> <td><code>1 // 2</code></td> <td>yes</td> <td>left</td> </tr> <tr> <td><code>%</code></td> <td>modulus</td> <td><code>1 % 2</code></td> <td>yes</td> <td>left</td> </tr> </tbody> </table> <h4 id="additive">Additive</h4> <table> <thead> <tr> <th>Operator</th> <th>Description</th> <th>Example</th> <th>Overloadable</th> <th>Associativity</th> </tr> </thead> <tbody> <tr> <td><code>+</code></td> <td>addition</td> <td><code>1 + 2</code></td> <td>yes</td> <td>left</td> </tr> <tr> <td><code>&amp;+</code></td> <td>wrapping addition</td> <td><code>1 &amp;+ 2</code></td> <td>yes</td> <td>left</td> </tr> <tr> <td><code>-</code></td> <td>subtraction</td> <td><code>1 - 2</code></td> <td>yes</td> <td>left</td> </tr> <tr> <td><code>&amp;-</code></td> <td>wrapping subtraction</td> <td><code>1 &amp;- 2</code></td> <td>yes</td> <td>left</td> </tr> </tbody> </table> <h3 id="other-unary-operators">Other unary operators</h3> <table> <thead> <tr> <th>Operator</th> <th>Description</th> <th>Example</th> <th>Overloadable</th> <th>Associativity</th> </tr> </thead> <tbody> <tr> <td><code>!</code></td> <td>inversion</td> <td><code>!true</code></td> <td>no</td> <td>right</td> </tr> <tr> <td><code>~</code></td> <td>binary complement</td> <td><code>~1</code></td> <td>yes</td> <td>right</td> </tr> </tbody> </table> <h3 id="shifts">Shifts</h3> <table> <thead> <tr> <th>Operator</th> <th>Description</th> <th>Example</th> <th>Overloadable</th> <th>Associativity</th> </tr> </thead> <tbody> <tr> <td><code>&lt;&lt;</code></td> <td>shift left, append</td> <td>
<code>1 &lt;&lt; 2</code>, <code>STDOUT &lt;&lt; "foo"</code>
</td> <td>yes</td> <td>left</td> </tr> <tr> <td><code>&gt;&gt;</code></td> <td>shift right</td> <td><code>1 &gt;&gt; 2</code></td> <td>yes</td> <td>left</td> </tr> </tbody> </table> <h3 id="binary">Binary</h3> <table> <thead> <tr> <th>Operator</th> <th>Description</th> <th>Example</th> <th>Overloadable</th> <th>Associativity</th> </tr> </thead> <tbody> <tr> <td><code>&amp;</code></td> <td>binary AND</td> <td><code>1 &amp; 2</code></td> <td>yes</td> <td>left</td> </tr> <tr> <td><code>|</code></td> <td>binary OR</td> <td><code>1 | 2</code></td> <td>yes</td> <td>left</td> </tr> <tr> <td><code>^</code></td> <td>binary XOR</td> <td><code>1 ^ 2</code></td> <td>yes</td> <td>left</td> </tr> </tbody> </table> <h3 id="equality-and-comparison">Equality and Comparison</h3> <h4 id="equality">Equality</h4> <p>Three base operators test equality:</p> <ul> <li>
<code>==</code>: Checks whether the values of the operands are equal</li> <li>
<code>=~</code>: Checks whether the value of the first operand matches the value of the second operand with pattern matching.</li> <li>
<code>===</code>: Checks whether the left hand operand matches the right hand operand in <a href="case">case equality</a>. This operator is applied in <code>case ... when</code> conditions.</li> </ul> <p>The first two operators also have inversion operators (<code>!=</code> and <code>!~</code>) whose semantical intention is just the inverse of the base operator: <code>a != b</code> is supposed to be equivalent to <code>!(a == b)</code> and <code>a !~ b</code> to <code>!(a =~ b)</code>. Nevertheless, these inversions can be defined with a custom implementation. This can be useful for example to improve performance (non-equality can often be proven faster than equality).</p> <table> <thead> <tr> <th>Operator</th> <th>Description</th> <th>Example</th> <th>Overloadable</th> <th>Associativity</th> </tr> </thead> <tbody> <tr> <td><code>==</code></td> <td>equals</td> <td><code>1 == 2</code></td> <td>yes</td> <td>left</td> </tr> <tr> <td><code>!=</code></td> <td>not equals</td> <td><code>1 != 2</code></td> <td>yes</td> <td>left</td> </tr> <tr> <td><code>=~</code></td> <td>pattern match</td> <td><code>"foo" =~ /fo/</code></td> <td>yes</td> <td>left</td> </tr> <tr> <td><code>!~</code></td> <td>no pattern match</td> <td><code>"foo" !~ /fo/</code></td> <td>yes</td> <td>left</td> </tr> <tr> <td><code>===</code></td> <td><a href="case">case equality</a></td> <td><code>/foo/ === "foo"</code></td> <td>yes</td> <td>left</td> </tr> </tbody> </table> <h4 id="comparison">Comparison</h4> <table> <thead> <tr> <th>Operator</th> <th>Description</th> <th>Example</th> <th>Overloadable</th> <th>Associativity</th> </tr> </thead> <tbody> <tr> <td><code>&lt;</code></td> <td>less</td> <td><code>1 &lt; 2</code></td> <td>yes</td> <td>left</td> </tr> <tr> <td><code>&lt;=</code></td> <td>less or equal</td> <td><code>1 &lt;= 2</code></td> <td>yes</td> <td>left</td> </tr> <tr> <td><code>&gt;</code></td> <td>greater</td> <td><code>1 &gt; 2</code></td> <td>yes</td> <td>left</td> </tr> <tr> <td><code>&gt;=</code></td> <td>greater or equal</td> <td><code>1 &gt;= 2</code></td> <td>yes</td> <td>left</td> </tr> <tr> <td><code>&lt;=&gt;</code></td> <td>comparison</td> <td><code>1 &lt;=&gt; 2</code></td> <td>yes</td> <td>left</td> </tr> </tbody> </table> <h4 id="chaining-equality-and-comparison">Chaining Equality and Comparison</h4> <p>Equality and comparison operators <code>==</code>, <code>!=</code>, <code>===</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> can be chained together and are interpreted as a compound expression. For example <code>a &lt;= b &lt;= c</code> is treated as <code>a &lt;= b &amp;&amp; b &lt;= c</code> and it is even possible to mix operators of the same <a href="#operator-precedence">operator precedence</a> like <code>a &gt;= b &lt;= c &gt; d</code>. Operators with different precedences can be chained too, however, it is advised to avoid it, since it is makes the code harder to understand. For instance <code>a == b &lt;= c</code> is interpreted as <code>a == b &amp;&amp; b &lt;= c</code>, while <code>a &lt;= b == c</code> is interpreted as <code>a &lt;= (b == c)</code>. </p> <h3 id="logical">Logical</h3> <table> <thead> <tr> <th>Operator</th> <th>Description</th> <th>Example</th> <th>Overloadable</th> <th>Associativity</th> </tr> </thead> <tbody> <tr> <td><code>&amp;&amp;</code></td> <td><a href="and">logical AND</a></td> <td><code>true &amp;&amp; false</code></td> <td>no</td> <td>left</td> </tr> <tr> <td><code>||</code></td> <td><a href="or">logical OR</a></td> <td><code>true || false</code></td> <td>no</td> <td>left</td> </tr> </tbody> </table> <h3 id="range">Range</h3> <p>The range operators are used in <a href="literals/range">Range</a> literals.</p> <table> <thead> <tr> <th>Operator</th> <th>Description</th> <th>Example</th> <th>Overloadable</th> </tr> </thead> <tbody> <tr> <td><code>..</code></td> <td>range</td> <td><code>1..10</code></td> <td>no</td> </tr> <tr> <td><code>...</code></td> <td>exclusive range</td> <td><code>1...10</code></td> <td>no</td> </tr> </tbody> </table> <h3 id="splats">Splats</h3> <p>Splat operators can only be used for destructing tuples in method arguments. See <a href="splats_and_tuples">Splats and Tuples</a> for details.</p> <table> <thead> <tr> <th>Operator</th> <th>Description</th> <th>Example</th> <th>Overloadable</th> </tr> </thead> <tbody> <tr> <td><code>*</code></td> <td>splat</td> <td><code>*foo</code></td> <td>no</td> </tr> <tr> <td><code>**</code></td> <td>double splat</td> <td><code>**foo</code></td> <td>no</td> </tr> </tbody> </table> <h3 id="conditional">Conditional</h3> <p>The <a href="ternary_if">conditional operator (<code>? :</code>)</a> is internally rewritten to an <code>if</code> expression by the compiler.</p> <table> <thead> <tr> <th>Operator</th> <th>Description</th> <th>Example</th> <th>Overloadable</th> <th>Associativity</th> </tr> </thead> <tbody> <tr> <td><code>? :</code></td> <td>conditional</td> <td><code>a == b ? c : d</code></td> <td>no</td> <td>right</td> </tr> </tbody> </table> <h3 id="assignments">Assignments</h3> <p>The assignment operator <code>=</code> assigns the value of the second operand to the first operand. The first operand is either a variable (in this case the operator can't be redefined) or a call (in this case the operator can be redefined). See <a href="assignment">assignment</a> for details.</p> <table> <thead> <tr> <th>Operator</th> <th>Description</th> <th>Example</th> <th>Overloadable</th> <th>Associativity</th> </tr> </thead> <tbody> <tr> <td><code>=</code></td> <td>variable assignment</td> <td><code>a = 1</code></td> <td>no</td> <td>right</td> </tr> <tr> <td><code>=</code></td> <td>call assignment</td> <td><code>a.b = 1</code></td> <td>yes</td> <td>right</td> </tr> <tr> <td><code>[]=</code></td> <td>index assignment</td> <td><code>a[0] = 1</code></td> <td>yes</td> <td>right</td> </tr> </tbody> </table> <h3 id="combined-assignments">Combined assignments</h3> <p>The assignment operator <code>=</code> is the basis for all operators that combine an operator with assignment. The general form is <code>a &lt;op&gt;= b</code> and the compiler transform that into <code>a = a &lt;op&gt; b</code>.</p> <p>Exceptions to the general expansion formula are the logical operators:</p> <ul> <li>
<code>a ||= b</code> transforms to <code>a || (a = b)</code>
</li> <li>
<code>a &amp;&amp;= b</code> transforms to <code>a &amp;&amp; (a = b)</code>
</li> </ul> <p>There is another special case when <code>a</code> is an index accessor (<code>[]</code>), it is changed to the nilable variant (<code>[]?</code> on the right hand side:</p> <ul> <li>
<code>a[i] ||= b</code> transforms to <code>a[i] = (a[i]? || b)</code>
</li> <li>
<code>a[i] &amp;&amp;= b</code> transforms to <code>a[i] = (a[i]? &amp;&amp; b)</code>
</li> </ul> <p>All transformations assume the receiver (<code>a</code>) is a variable. If it is a call, the replacements are semantically equivalent but the implementation is a bit more complex (introducing an anonymous temporary variable) and expects <code>a=</code> to be callable.</p> <p>The receiver can't be anything else than a variable or call.</p> <table> <thead> <tr> <th>Operator</th> <th>Description</th> <th>Example</th> <th>Overloadable</th> <th>Associativity</th> </tr> </thead> <tbody> <tr> <td><code>+=</code></td> <td>addition <em>and</em> assignment</td> <td><code>i += 1</code></td> <td>no</td> <td>right</td> </tr> <tr> <td><code>&amp;+=</code></td> <td>wrapping addition <em>and</em> assignment</td> <td><code>i &amp;+= 1</code></td> <td>no</td> <td>right</td> </tr> <tr> <td><code>-=</code></td> <td>subtraction <em>and</em> assignment</td> <td><code>i -= 1</code></td> <td>no</td> <td>right</td> </tr> <tr> <td><code>&amp;-=</code></td> <td>wrapping subtraction <em>and</em> assignment</td> <td><code>i &amp;-= 1</code></td> <td>no</td> <td>right</td> </tr> <tr> <td><code>*=</code></td> <td>multiplication <em>and</em> assignment</td> <td><code>i *= 1</code></td> <td>no</td> <td>right</td> </tr> <tr> <td><code>&amp;*=</code></td> <td>wrapping multiplication <em>and</em> assignment</td> <td><code>i &amp;*= 1</code></td> <td>no</td> <td>right</td> </tr> <tr> <td><code>/=</code></td> <td>division <em>and</em> assignment</td> <td><code>i /= 1</code></td> <td>no</td> <td>right</td> </tr> <tr> <td><code>//=</code></td> <td>floor division <em>and</em> assignment</td> <td><code>i //= 1</code></td> <td>no</td> <td>right</td> </tr> <tr> <td><code>%=</code></td> <td>modulo <em>and</em> assignment</td> <td><code>i %= 1</code></td> <td>yes</td> <td>right</td> </tr> <tr> <td><code>|=</code></td> <td>binary or <em>and</em> assignment</td> <td><code>i |= 1</code></td> <td>no</td> <td>right</td> </tr> <tr> <td><code>&amp;=</code></td> <td>binary and <em>and</em> assignment</td> <td><code>i &amp;= 1</code></td> <td>no</td> <td>right</td> </tr> <tr> <td><code>^=</code></td> <td>binary xor <em>and</em> assignment</td> <td><code>i ^= 1</code></td> <td>no</td> <td>right</td> </tr> <tr> <td><code>**=</code></td> <td>exponential <em>and</em> assignment</td> <td><code>i **= 1</code></td> <td>no</td> <td>right</td> </tr> <tr> <td><code>&lt;&lt;=</code></td> <td>left shift <em>and</em> assignment</td> <td><code>i &lt;&lt;= 1</code></td> <td>no</td> <td>right</td> </tr> <tr> <td><code>&gt;&gt;=</code></td> <td>right shift <em>and</em> assignment</td> <td><code>i &gt;&gt;= 1</code></td> <td>no</td> <td>right</td> </tr> <tr> <td><code>||=</code></td> <td>logical or <em>and</em> assignment</td> <td><code>i ||= true</code></td> <td>no</td> <td>right</td> </tr> <tr> <td><code>&amp;&amp;=</code></td> <td>logical and <em>and</em> assignment</td> <td><code>i &amp;&amp;= true</code></td> <td>no</td> <td>right</td> </tr> </tbody> </table> <h3 id="index-accessors">Index Accessors</h3> <p>Index accessors are used to query a value by index or key, for example an array item or map entry. The nilable variant <code>[]?</code> is supposed to return <code>nil</code> when the index is not found, while the non-nilable variant raises in that case. Implementations in the standard-library usually raise <a href="https://crystal-lang.org/api/1.5.0/KeyError.html"><code>KeyError</code></a> or <a href="https://crystal-lang.org/api/1.5.0/IndexError.html"><code>IndexError</code></a>.</p> <table> <thead> <tr> <th>Operator</th> <th>Description</th> <th>Example</th> <th>Overloadable</th> </tr> </thead> <tbody> <tr> <td><code>[]</code></td> <td>index accessor</td> <td><code>ary[i]</code></td> <td>yes</td> </tr> <tr> <td><code>[]?</code></td> <td>nilable index accessor</td> <td><code>ary[i]?</code></td> <td>yes</td> </tr> </tbody> </table><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://crystal-lang.org/reference/1.5/syntax_and_semantics/operators.html" class="_attribution-link" target="_blank">https://crystal-lang.org/reference/1.5/syntax_and_semantics/operators.html</a>
  </p>
</div>
