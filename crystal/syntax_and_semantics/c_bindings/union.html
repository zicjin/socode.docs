 <h1 id="union">union</h1> <p>A <code>union</code> declaration inside a <code>lib</code> declares a C union:</p> <div class="crystal highlight"><pre data-language="crystal">lib U
  # In C:
  #
  #  union IntOrFloat {
  #    int some_int;
  #    double some_float;
  #  };
  union IntOrFloat
    some_int : Int32
    some_float : Float64
  end
end
</pre></div> <p>To create an instance of a union use <code>new</code>:</p> <div class="crystal highlight"><pre data-language="crystal">value = U::IntOrFloat.new
</pre></div> <p>This allocates the union on the stack.</p> <p>A C union starts with all its fields set to "zero": integers and floats start at zero, pointers start with an address of zero, etc.</p> <p>To avoid this initialization you can use <code>uninitialized</code>:</p> <div class="crystal highlight"><pre data-language="crystal">value = uninitialized U::IntOrFloat
value.some_int # =&gt; some garbage value
</pre></div> <p>You can set and get its properties:</p> <div class="crystal highlight"><pre data-language="crystal">value = U::IntOrFloat.new
value.some_int = 1
value.some_int   # =&gt; 1
value.some_float # =&gt; 4.94066e-324
</pre></div> <p>If the assigned value is not exactly the same as the property's type, <a href="to_unsafe">to_unsafe</a> will be tried.</p> <p>A C union is passed by value (as a copy) to functions and methods, and also passed by value when it is returned from a method:</p> <div class="crystal highlight"><pre data-language="crystal">def change_it(value)
  value.some_int = 1
end

value = U::IntOrFloat.new
change_it value
value.some_int # =&gt; 0
</pre></div> <p>Refer to the <a href="../type_grammar">type grammar</a> for the notation used in union field types.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://crystal-lang.org/reference/1.5/syntax_and_semantics/c_bindings/union.html" class="_attribution-link" target="_blank">https://crystal-lang.org/reference/1.5/syntax_and_semantics/c_bindings/union.html</a>
  </p>
</div>
