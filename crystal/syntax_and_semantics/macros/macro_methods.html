 <h1 id="macro-methods">Macro methods</h1> <p>Macro defs allow you to define a method for a class hierarchy which is then instantiated for each concrete subtype.</p> <p>A <code>def</code> is implicitly considered a <code>macro def</code> if it contains a macro expression which refers to <code>@type</code>. For example:</p> <div class="crystal highlight"><pre data-language="crystal">class Object
  def instance_vars_names
    {{ @type.instance_vars.map &amp;.name.stringify }}
  end
end

class Person
  def initialize(@name : String, @age : Int32)
  end
end

person = Person.new "John", 30
person.instance_vars_names # =&gt; ["name", "age"]
</pre></div> <p>In macro definitions, arguments are passed as their AST nodes, giving you access to them in macro expansions (<code>{{some_macro_argument}}</code>). However that is not true for macro defs. Here the parameter list is that of the method generated by the macro def. You cannot access the call arguments during compile-time.</p> <div class="crystal highlight"><pre data-language="crystal">class Object
  def has_instance_var?(name) : Bool
    # We cannot access name inside the macro expansion here,
    # instead we need to use the macro language to construct an array
    # and do the inclusion check at runtime.
    {{ @type.instance_vars.map &amp;.name.stringify }}.includes? name
  end
end

person = Person.new "John", 30
person.has_instance_var?("name")     # =&gt; true
person.has_instance_var?("birthday") # =&gt; false
</pre></div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://crystal-lang.org/reference/1.3/syntax_and_semantics/macros/macro_methods.html" class="_attribution-link" target="_blank">https://crystal-lang.org/reference/1.3/syntax_and_semantics/macros/macro_methods.html</a>
  </p>
</div>
