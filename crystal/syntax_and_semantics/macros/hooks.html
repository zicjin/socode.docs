 <h1 id="hooks">Hooks</h1> <p>Special macros exist that are invoked in some situations as hooks, at compile time:</p> <ul> <li>
<code>inherited</code> is invoked when a subclass is defined. <code>@type</code> is the inheriting type.</li> <li>
<code>included</code> is invoked when a module is included. <code>@type</code> is the including type.</li> <li>
<code>extended</code> is invoked when a module is extended. <code>@type</code> is the extending type.</li> <li>
<code>method_missing</code> is invoked when a method is not found.</li> <li>
<code>method_added</code> is invoked when a new method is defined in the current scope.</li> <li>
<code>finished</code> is invoked after parsing finished, so all types and their methods are known.</li> </ul> <p>Example of <code>inherited</code>:</p> <div class="crystal highlight"><pre data-language="crystal">class Parent
  macro inherited
    def lineage
      "{{@type.name.id}} &lt; Parent"
    end
  end
end

class Child &lt; Parent
end

Child.new.lineage # =&gt; "Child &lt; Parent"
</pre></div> <p>Example of <code>method_missing</code>:</p> <div class="crystal highlight"><pre data-language="crystal">macro method_missing(call)
  print "Got ", {{call.name.id.stringify}}, " with ", {{call.args.size}}, " arguments", '\n'
end

foo          # Prints: Got foo with 0 arguments
bar 'a', 'b' # Prints: Got bar with 2 arguments
</pre></div> <p>Example of <code>method_added</code>:</p> <div class="crystal highlight"><pre data-language="crystal">macro method_added(method)
  {% puts "Method added:", method.name.stringify %}
end

def generate_random_number
  4
end
# =&gt; Method added: generate_random_number
</pre></div> <p>Both <code>method_missing</code> and <code>method_added</code> only apply to calls or methods in the same class that the macro is defined in, or only in the top level if the macro is defined outside of a class. For example:</p> <div class="crystal highlight"><pre data-language="crystal">macro method_missing(call)
  puts "In outer scope, got call: ", {{ call.name.stringify }}
end

class SomeClass
  macro method_missing(call)
    puts "Inside SomeClass, got call: ", {{ call.name.stringify }}
  end
end

class OtherClass
end

# This call is handled by the top-level `method_missing`
foo # =&gt; In outer scope, got call: foo

obj = SomeClass.new
# This is handled by the one inside SomeClass
obj.bar # =&gt; Inside SomeClass, got call: bar

other = OtherClass.new
# Neither OtherClass or its parents define a `method_missing` macro
other.baz # =&gt; Error: Undefined method 'baz' for OtherClass
</pre></div> <p><code>finished</code> is called once a type has been completely defined - this includes extensions on that class. Consider the following program:</p> <div class="crystal highlight"><pre data-language="crystal">macro print_methods
  {% puts @type.methods.map &amp;.name %}
end

class Foo
  macro finished
    {% puts @type.methods.map &amp;.name %}
  end

  print_methods
end

class Foo
  def bar
    puts "I'm a method!"
  end
end

Foo.new.bar
</pre></div> <p>The <code>print_methods</code> macro will be run as soon as it is encountered - and will print an empty list as there are no methods defined at that point. Once the second declaration of <code>Foo</code> is compiled the <code>finished</code> macro will be run, which will print <code>[bar]</code>.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://crystal-lang.org/reference/1.3/syntax_and_semantics/macros/hooks.html" class="_attribution-link" target="_blank">https://crystal-lang.org/reference/1.3/syntax_and_semantics/macros/hooks.html</a>
  </p>
</div>
