 <h1 id="annotations">Annotations</h1> <p>Annotations can be used to add metadata to certain features in the source code. Types, methods and instance variables may be annotated. User-defined annotations, such as the standard library's <a href="https://crystal-lang.org/api/1.3.2/JSON/Field.html">JSON::Field</a>, are defined using the <code>annotation</code> keyword. A number of <a href="built_in_annotations">built-in annotations</a> are provided by the compiler.</p> <p>Users can define their own annotations using the <code>annotation</code> keyword, which works similarly to defining a <code>class</code> or <code>struct</code>.</p> <div class="crystal highlight"><pre data-language="crystal">annotation MyAnnotation
end
</pre></div> <p>The annotation can then be applied to various items, including:</p> <ul> <li>Instance and class methods</li> <li>Instance variables</li> <li>Classes, structs, enums, and modules</li> </ul> <div class="crystal highlight"><pre data-language="crystal">annotation MyAnnotation
end

@[MyAnnotation]
def foo
  "foo"
end

@[MyAnnotation]
class Klass
end

@[MyAnnotation]
module MyModule
end
</pre></div> <h2 id="applications">Applications</h2> <p>Annotations are best used to store metadata about a given instance variable, type, or method so that it can be read at compile time using macros. One of the main benefits of annotations is that they are applied directly to instance variables/methods, which causes classes to look more natural since a standard macro is not needed to create these properties/methods.</p> <p>A few applications for annotations:</p> <h3 id="object-serialization">Object Serialization</h3> <p>Have an annotation that when applied to an instance variable determines if that instance variable should be serialized, or with what key. Crystal's <a href="https://crystal-lang.org/api/1.3.2/JSON/Serializable.html"><code>JSON::Serializable</code></a> and <a href="https://crystal-lang.org/api/1.3.2/YAML/Serializable.html"><code>YAML::Serializable</code></a> are examples of this.</p> <h3 id="orms">ORMs</h3> <p>An annotation could be used to designate a property as an ORM column. The name and type of the instance variable can be read off the <code>TypeNode</code> in addition to the annotation; removing the need for any ORM specific macro. The annotation itself could also be used to store metadata about the column, such as if it is nullable, the name of the column, or if it is the primary key.</p> <h2 id="fields">Fields</h2> <p>Data can be stored within an annotation.</p> <div class="crystal highlight"><pre data-language="crystal">annotation MyAnnotaion
end

# The fields can either be a key/value pair
@[MyAnnotation(key: "value", value: 123)]

# Or positional
@[MyAnnotation("foo", 123, false)]
</pre></div> <h3 id="keyvalue">Key/value</h3> <p>The values of annotation key/value pairs can be accessed at compile time via the <a href="https://crystal-lang.org/api/1.3.2/Crystal/Macros/Annotation.html#%5B%5D%28name%3ASymbolLiteral%7CStringLiteral%7CMacroId%29%3AASTNode-instance-method"><code>[]</code></a> method.</p> <div class="crystal highlight"><pre data-language="crystal">annotation MyAnnotation
end

@[MyAnnotation(value: 2)]
def annotation_value
  # The name can be a `String`, `Symbol`, or `MacroId`
  {{ @def.annotation(MyAnnotation)[:value] }}
end

annotation_value # =&gt; 2
</pre></div> <p>The <code>named_args</code> method can be used to read all key/value pairs on an annotation as a <code>NamedTupleLiteral</code>. This method is defined on all annotations by default, and is unique to each applied annotation.</p> <div class="crystal highlight"><pre data-language="crystal">annotation MyAnnotation
end

@[MyAnnotation(value: 2, name: "Jim")]
def annotation_named_args
  {{ @def.annotation(MyAnnotation).named_args }}
end

annotation_named_args # =&gt; {value: 2, name: "Jim"}
</pre></div> <p>Since this method returns a <code>NamedTupleLiteral</code>, all of the <a href="https://crystal-lang.org/api/1.3.2/Crystal/Macros/NamedTupleLiteral.html">methods</a> on that type are available for use. Especially <code>#double_splat</code> which makes it easy to pass annotation arguments to methods.</p> <div class="crystal highlight"><pre data-language="crystal">annotation MyAnnotation
end

class SomeClass
  def initialize(@value : Int32, @name : String); end
end

@[MyAnnotation(value: 2, name: "Jim")]
def new_test
  {% begin %}
    SomeClass.new {{ @def.annotation(MyAnnotation).named_args.double_splat }}
  {% end %}
end

new_test # =&gt; #&lt;SomeClass:0x5621a19ddf00 @name="Jim", @value=2&gt;
</pre></div> <h3 id="positional">Positional</h3> <p>Positional values can be accessed at compile time via the <a href="https://crystal-lang.org/api/1.3.2/Crystal/Macros/Annotation.html#%5B%5D%28index%3ANumberLiteral%29%3AASTNode-instance-method"><code>[]</code></a> method; however, only one index can be accessed at a time.</p> <div class="crystal highlight"><pre data-language="crystal">annotation MyAnnotation
end

@[MyAnnotation(1, 2, 3, 4)]
def annotation_read
  {% for idx in [0, 1, 2, 3, 4] %}
    {% value = @def.annotation(MyAnnotation)[idx] %}
    pp "{{ idx }} = {{ value }}"
  {% end %}
end

annotation_read

# Which would print
"0 = 1"
"1 = 2"
"2 = 3"
"3 = 4"
"4 = nil"
</pre></div> <p>The <code>args</code> method can be used to read all positional arguments on an annotation as a <code>TupleLiteral</code>. This method is defined on all annotations by default, and is unique to each applied annotation.</p> <div class="crystal highlight"><pre data-language="crystal">annotation MyAnnotation
end

@[MyAnnotation(1, 2, 3, 4)]
def annotation_args
  {{ @def.annotation(MyAnnotation).args }}
end

annotation_args # =&gt; {1, 2, 3, 4}
</pre></div> <p>Since the return type of <code>TupleLiteral</code> is iterable, we can rewrite the previous example in a better way. By extension, all of the <a href="https://crystal-lang.org/api/1.3.2/Crystal/Macros/TupleLiteral.html">methods</a> on <code>TupleLiteral</code> are available for use as well.</p> <div class="crystal highlight"><pre data-language="crystal">annotation MyAnnotation
end

@[MyAnnotation(1, "foo", true, 17.0)]
def annotation_read
  {% for value, idx in @def.annotation(MyAnnotation).args %}
    pp "{{ idx }} = #{{{ value }}}"
  {% end %}
end

annotation_read

# Which would print
"0 = 1"
"1 = foo"
"2 = true"
"3 = 17.0"
</pre></div> <h2 id="reading">Reading</h2> <p>Annotations can be read off of a <a href="https://crystal-lang.org/api/1.3.2/Crystal/Macros/TypeNode.html"><code>TypeNode</code></a>, <a href="https://crystal-lang.org/api/1.3.2/Crystal/Macros/Def.html"><code>Def</code></a>, or <a href="https://crystal-lang.org/api/1.3.2/Crystal/Macros/MetaVar.html"><code>MetaVar</code></a> using the <code>.annotation(type : TypeNode)</code> method. This method return an <a href="https://crystal-lang.org/api/1.3.2/Crystal/Macros/Annotation.html"><code>Annotation</code></a> object representing the applied annotation of the supplied type.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If multiple annotations of the same type are applied, the <code>.annotation</code> method will return the <em>last</em> one.</p> </div> <p>The <a href="../macros/index#type-information"><code>@type</code></a> and <a href="../macros/index#method-information"><code>@def</code></a> variables can be used to get a <code>TypeNode</code> or <code>Def</code> object to use the <code>.annotation</code> method on. However, it is also possible to get <code>TypeNode</code>/<code>Def</code> types using other methods on <code>TypeNode</code>. For example <code>TypeNode.all_subclasses</code> or <code>TypeNode.methods</code>, respectively.</p> <p>The <code>TypeNode.instance_vars</code> can be used to get an array of instance variable <code>MetaVar</code> objects that would allow reading annotations defined on those instance variables.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code>TypeNode.instance_vars</code> currently only works in the context of an instance/class method.</p> </div> <div class="crystal highlight"><pre data-language="crystal">annotation MyClass
end

annotation MyMethod
end

annotation MyIvar
end

@[MyClass]
class Foo
  pp {{ @type.annotation(MyClass).stringify }}

  @[MyIvar]
  @num : Int32 = 1

  @[MyIvar]
  property name : String = "jim"

  def properties
    {% for ivar in @type.instance_vars %}
      pp {{ ivar.annotation(MyIvar).stringify }}
    {% end %}
  end
end

@[MyMethod]
def my_method
  pp {{ @def.annotation(MyMethod).stringify }}
end

Foo.new.properties
my_method
pp {{ Foo.annotation(MyClass).stringify }}

# Which would print
"@[MyClass]"
"@[MyIvar]"
"@[MyIvar]"
"@[MyMethod]"
"@[MyClass]"
</pre></div> <h3 id="reading-multiple-annotations">Reading Multiple Annotations</h3> <p>If there are multiple annotations of the same type applied to the same instance variable/method/type, the <code>.annotations(type : TypeNode)</code> method can be used. This will work on anything that <code>.annotation(type : TypeNode)</code> would, but instead returns an <code>ArrayLiteral(Annotation)</code>.</p> <div class="crystal highlight"><pre data-language="crystal">annotation MyAnnotation
end

@[MyAnnotation("foo")]
@[MyAnnotation(123)]
@[MyAnnotation(123)]
def annotation_read
  {% for ann, idx in @def.annotations(MyAnnotation) %}
    pp "Annotation {{ idx }} = {{ ann[0].id }}"
  {% end %}
end

annotation_read

# Which would print
"Annotation 0 = foo"
"Annotation 1 = 123"
"Annotation 2 = 123"
</pre></div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://crystal-lang.org/reference/1.3/syntax_and_semantics/annotations/index.html" class="_attribution-link" target="_blank">https://crystal-lang.org/reference/1.3/syntax_and_semantics/annotations/index.html</a>
  </p>
</div>
