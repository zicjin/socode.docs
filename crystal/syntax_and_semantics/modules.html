 <h1 id="modules">Modules</h1> <p>Modules serve two purposes:</p> <ul> <li>as namespaces for defining other types, methods and constants</li> <li>as partial types that can be mixed in other types</li> </ul> <p>An example of a module as a namespace:</p> <div class="crystal highlight"><pre data-language="crystal">module Curses
  class Window
  end
end

Curses::Window.new
</pre></div> <p>Library authors are advised to put their definitions inside a module to avoid name clashes. The standard library usually doesn't have a namespace as its types and methods are very common, to avoid writing long names.</p> <p>To use a module as a partial type you use <code>include</code> or <code>extend</code>.</p> <p>An <code>include</code> makes a type include methods defined in that module as instance methods:</p> <div class="crystal highlight"><pre data-language="crystal">module ItemsSize
  def size
    items.size
  end
end

class Items
  include ItemsSize

  def items
    [1, 2, 3]
  end
end

items = Items.new
items.size # =&gt; 3
</pre></div> <p>In the above example, it is as if we pasted the <code>size</code> method from the module into the <code>Items</code> class. The way this really works is by making each type have a list of ancestors, or parents. By default this list starts with the superclass. As modules are included they are <strong>prepended</strong> to this list. When a method is not found in a type it is looked up in this list. When you invoke <code>super</code>, the first type in this ancestors list is used.</p> <p>A <code>module</code> can include other modules, so when a method is not found in it it will be looked up in the included modules.</p> <p>An <code>extend</code> makes a type include methods defined in that module as class methods:</p> <div class="crystal highlight"><pre data-language="crystal">module SomeSize
  def size
    3
  end
end

class Items
  extend SomeSize
end

Items.size # =&gt; 3
</pre></div> <p>Both <code>include</code> and <code>extend</code> make constants defined in the module available to the including/extending type.</p> <p>Both of them can be used at the top level to avoid writing a namespace over and over (although the chances of name clashes increase):</p> <div class="crystal highlight"><pre data-language="crystal">module SomeModule
  class SomeType
  end

  def some_method
    1
  end
end

include SomeModule

SomeType.new # OK, same as SomeModule::SomeType
some_method  # OK, 1
</pre></div> <h2 id="extend-self">extend self</h2> <p>A common pattern for modules is <code>extend self</code>:</p> <div class="crystal highlight"><pre data-language="crystal">module Base64
  extend self

  def encode64(string)
    # ...
  end

  def decode64(string)
    # ...
  end
end
</pre></div> <p>In this way a module can be used as a namespace:</p> <div class="crystal highlight"><pre data-language="crystal">Base64.encode64 "hello" # =&gt; "aGVsbG8="
</pre></div> <p>But also it can be included in the program and its methods can be invoked without a namespace:</p> <div class="crystal highlight"><pre data-language="crystal">include Base64

encode64 "hello" # =&gt; "aGVsbG8="
</pre></div> <p>For this to be useful the method name should have some reference to the module, otherwise chances of name clashes are high.</p> <p>A module cannot be instantiated:</p> <div class="crystal highlight"><pre data-language="crystal">module Moo
end

Moo.new # undefined method 'new' for Moo:Module
</pre></div> <h2 id="module-type-checking">Module Type Checking</h2> <p>Modules can also be used for type checking.</p> <p>If we define two modules with names <code>A</code> and <code>B</code>:</p> <div class="crystal highlight"><pre data-language="crystal">module A; end

module B; end
</pre></div> <p>These can be included into classes:</p> <div class="crystal highlight"><pre data-language="crystal">class One
  include A
end

class Two
  include B
end

class Three &lt; Two
  include A
end
</pre></div> <p>We can then type check against instances of these classes with not only their class, but the included modules as well:</p> <div class="crystal highlight"><pre data-language="crystal">one = One.new
typeof(one)  # =&gt; One
one.is_a?(A) # =&gt; true
one.is_a?(B) # =&gt; false

three = Three.new
typeof(three)  # =&gt; Three
three.is_a?(A) # =&gt; true
three.is_a?(B) # =&gt; true
</pre></div> <p>This allows you to define arrays and methods based on module type instead of class:</p> <div class="crystal highlight"><pre data-language="crystal">one = One.new
two = Two.new
three = Three.new

new_array = Array(A).new
new_array &lt;&lt; one   # Ok, One inherits module A
new_array &lt;&lt; three # Ok, Three includes module A

new_array &lt;&lt; two # Error, because Two does not inherit module A
</pre></div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://crystal-lang.org/reference/1.3/syntax_and_semantics/modules.html" class="_attribution-link" target="_blank">https://crystal-lang.org/reference/1.3/syntax_and_semantics/modules.html</a>
  </p>
</div>
