 <h1 id="structs">Structs</h1> <p>Instead of defining a type with <code>class</code> you can do so with <code>struct</code>:</p> <div class="crystal highlight"><pre data-language="crystal">struct Point
  property x, y

  def initialize(@x : Int32, @y : Int32)
  end
end
</pre></div> <p>Structs inherit from <a href="https://crystal-lang.org/api/latest/Value.html">Value</a> so they are allocated on the stack and passed by value: when passed to methods, returned from methods or assigned to variables, a copy of the value is actually passed (while classes inherit from <a href="https://crystal-lang.org/api/latest/Reference.html">Reference</a>, are allocated on the heap and passed by reference).</p> <p>Therefore structs are mostly useful for immutable data types and/or stateless wrappers of other types, usually for performance reasons to avoid lots of small memory allocations when passing small copies might be more efficient (for more details, see the <a href="https://crystal-lang.org/docs/guides/performance.html#use-structs-when-possible">performance guide</a>).</p> <p>Mutable structs are still allowed, but you should be careful when writing code involving mutability if you want to avoid surprises that are described below.</p> <h2 id="passing-by-value">Passing by value</h2> <p>A struct is <em>always</em> passed by value, even when you return <code>self</code> from the method of that struct:</p> <div class="crystal highlight"><pre data-language="crystal">struct Counter
  def initialize(@count : Int32)
  end

  def plus
    @count += 1
    self
  end
end

counter = Counter.new(0)
counter.plus.plus # =&gt; Counter(@count=2)
puts counter      # =&gt; Counter(@count=1)
</pre></div> <p>Notice that the chained calls of <code>plus</code> return the expected result, but only the first call to it modifies the variable <code>counter</code>, as the second call operates on the <em>copy</em> of the struct passed to it from the first call, and this copy is discarded after the expression is executed.</p> <p>You should also be careful when working on mutable types inside of the struct:</p> <div class="crystal highlight"><pre data-language="crystal">class Klass
  property array = ["str"]
end

struct Strukt
  property array = ["str"]
end

def modify(object)
  object.array &lt;&lt; "foo"
  object.array = ["new"]
  object.array &lt;&lt; "bar"
end

klass = Klass.new
puts modify(klass) # =&gt; ["new", "bar"]
puts klass.array   # =&gt; ["new", "bar"]

strukt = Strukt.new
puts modify(strukt) # =&gt; ["new", "bar"]
puts strukt.array   # =&gt; ["str", "foo"]
</pre></div> <p>What happens with the <code>strukt</code> here:</p> <ul> <li>
<code>Array</code> is passed by reference, so the reference to <code>["str"]</code> is stored in the property of <code>strukt</code>
</li> <li>when <code>strukt</code> is passed to <code>modify</code>, a <em>copy</em> of the <code>strukt</code> is passed with the reference to array inside it</li> <li>the array referenced by <code>array</code> is modified (element inside it is added) by <code>object.array &lt;&lt; "foo"</code>
</li> <li>this is also reflected in the original <code>strukt</code> as it holds reference to the same array</li> <li>
<code>object.array = ["new"]</code> replaces the reference in the <em>copy</em> of <code>strukt</code> with the reference to the new array</li> <li>
<code>object.array &lt;&lt; "bar"</code> appends to this newly created array</li> <li>
<code>modify</code> returns the reference to this new array and its content is printed</li> <li>the reference to this new array was held only in the <em>copy</em> of <code>strukt</code>, but not in the original, so that's why the original <code>strukt</code> only retained the result of the first statement, but not of the other two statements</li> </ul> <p><code>Klass</code> is a class, so it is passed by reference to <code>modify</code>, and <code>object.array = ["new"]</code> saves the reference to the newly created array in the original <code>klass</code> object, not in the copy as it was with the <code>strukt</code>.</p> <h2 id="inheritance">Inheritance</h2> <ul> <li>A struct implicitly inherits from <a href="https://crystal-lang.org/api/latest/Struct.html">Struct</a>, which inherits from <a href="https://crystal-lang.org/api/latest/Value.html">Value</a>. A class implicitly inherits from <a href="https://crystal-lang.org/api/latest/Reference.html">Reference</a>.</li> <li>A struct cannot inherit from a non-abstract struct.</li> </ul> <p>The second point has a reason to it: a struct has a very well defined memory layout. For example, the above <code>Point</code> struct occupies 8 bytes. If you have an array of points the points are embedded inside the array's buffer:</p> <div class="crystal highlight"><pre data-language="crystal"># The array's buffer will have 8 bytes dedicated to each Point
ary = [] of Point
</pre></div> <p>If <code>Point</code> is inherited, an array of such type should also account for the fact that other types can be inside it, so the size of each element should grow to accommodate that. That is certainly unexpected. So, non-abstract structs can't be inherited from. Abstract structs, on the other hand, will have descendants, so it is expected that an array of them will account for the possibility of having multiple types inside it.</p> <p>A struct can also include modules and can be generic, just like a class.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://crystal-lang.org/reference/syntax_and_semantics/structs.html" class="_attribution-link" target="_blank">https://crystal-lang.org/reference/syntax_and_semantics/structs.html</a>
  </p>
</div>
