 <h1 id="block-forwarding">Block forwarding</h1> <p>To forward captured blocks, you use a block argument, prefixing an expression with <code>&amp;</code>:</p> <div class="crystal highlight"><pre data-language="crystal">def capture(&amp;block)
  block
end

def invoke(&amp;block)
  block.call
end

proc = capture { puts "Hello" }
invoke(&amp;proc) # prints "Hello"
</pre></div> <p>In the above example, <code>invoke</code> receives a block. We can't pass <code>proc</code> directly to it because <code>invoke</code> doesn't receive regular arguments, just a block argument. We use <code>&amp;</code> to specify that we really want to pass <code>proc</code> as the block argument. Otherwise:</p> <div class="crystal highlight"><pre data-language="crystal">invoke(proc) # Error: wrong number of arguments for 'invoke' (1 for 0)
</pre></div> <p>You can actually pass a proc to a method that yields:</p> <div class="crystal highlight"><pre data-language="crystal">def capture(&amp;block)
  block
end

def twice
  yield
  yield
end

proc = capture { puts "Hello" }
twice &amp;proc
</pre></div> <p>The above is simply rewritten to:</p> <div class="crystal highlight"><pre data-language="crystal">proc = capture { puts "Hello" }
twice do
  proc.call
end
</pre></div> <p>Or, combining the <code>&amp;</code> and <code>-&gt;</code> syntaxes:</p> <div class="crystal highlight"><pre data-language="crystal">twice &amp;-&gt;{ puts "Hello" }
</pre></div> <p>Or:</p> <div class="crystal highlight"><pre data-language="crystal">def say_hello
  puts "Hello"
end

twice &amp;-&gt;say_hello
</pre></div> <h2 id="forwarding-non-captured-blocks">Forwarding non-captured blocks</h2> <p>To forward non-captured blocks, you must use <code>yield</code>:</p> <div class="crystal highlight"><pre data-language="crystal">def foo
  yield 1
end

def wrap_foo
  puts "Before foo"
  foo do |x|
    yield x
  end
  puts "After foo"
end

wrap_foo do |i|
  puts i
end

# Output:
# Before foo
# 1
# After foo
</pre></div> <p>You can also use the <code>&amp;block</code> syntax to forward blocks, but then you have to at least specify the input types, and the generated code will involve closures and will be slower:</p> <div class="crystal highlight"><pre data-language="crystal">def foo
  yield 1
end

def wrap_foo(&amp;block : Int32 -&gt; _)
  puts "Before foo"
  foo(&amp;block)
  puts "After foo"
end

wrap_foo do |i|
  puts i
end

# Output:
# Before foo
# 1
# After foo
</pre></div> <p>Try to avoid forwarding blocks like this if doing <code>yield</code> is enough. There's also the issue that <code>break</code> and <code>next</code> are not allowed inside captured blocks, so the following won't work when using <code>&amp;block</code> forwarding:</p> <div class="crystal highlight"><pre data-language="crystal">foo_forward do |i|
  break # error
end
</pre></div> <p>In short, avoid <code>&amp;block</code> forwarding when <code>yield</code> is involved.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://crystal-lang.org/reference/syntax_and_semantics/block_forwarding.html" class="_attribution-link" target="_blank">https://crystal-lang.org/reference/syntax_and_semantics/block_forwarding.html</a>
  </p>
</div>
