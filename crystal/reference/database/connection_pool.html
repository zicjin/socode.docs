 <h1 id="connection-pool">Connection pool</h1> <p>When a connection is established it usually means opening a TCP connection or Socket. The socket will handle one statement at a time. If a program needs to perform many queries simultaneously, or if it handles concurrent requests that aim to use a database, it will need more than one active connection.</p> <p>Since databases are separate services from the application using them, the connections might go down, the services might be restarted, and other sort of things the program might not want to care about.</p> <p>To address this issues usually a connection pool is a neat solution.</p> <p>When a database is opened with <code>crystal-db</code> there is already a connection pool working. <code>DB.open</code> returns a <code>DB::Database</code> object which manages the whole connection pool and not just a single connection.</p> <div class="crystal highlight"><pre data-language="crystal">DB.open("mysql://root@localhost/test") do |db|
  # db is a DB::Database
end
</pre></div> <p>When executing statements using <code>db.query</code>, <code>db.exec</code>, <code>db.scalar</code>, etc. the algorithm goes:</p> <ol> <li>Find an available connection in the pool.<ol> <li>Create one if needed and possible.</li> <li>If the pool is not allowed to create a new connection, wait a for a connection to become available.<ol> <li>But this wait should be aborted if it takes too long.</li> </ol> </li> </ol> </li> <li>Checkout that connection from the pool.</li> <li>Execute the SQL command.</li> <li>If there is no <code>DB::ResultSet</code> yielded, return the connection to the pool. Otherwise, the connection will be returned to the pool when the ResultSet is closed.</li> <li>Return the statement result.</li> </ol> <p>If a connection can't be created, or if a connection loss occurs while the statement is performed the above process is repeated.</p> <blockquote> <p>The retry logic only happens when the statement is sent through the <code>DB::Database</code> . If it is sent through a <code>DB::Connection</code> or <code>DB::Transaction</code> no retry is performed since the code will state that certain connection object was expected to be used.</p> </blockquote> <h2 id="configuration">Configuration</h2> <p>The behavior of the pool can be configured from a set of parameters that can appear as query string in the connection URI.</p> <table> <thead> <tr> <th align="left">Name</th> <th align="left">Default value</th> </tr> </thead> <tbody> <tr> <td align="left">initial_pool_size</td> <td align="left">1</td> </tr> <tr> <td align="left">max_pool_size</td> <td align="left">0 (unlimited)</td> </tr> <tr> <td align="left">max_idle_pool_size</td> <td align="left">1</td> </tr> <tr> <td align="left">checkout_timeout</td> <td align="left">5.0 (seconds)</td> </tr> <tr> <td align="left">retry_attempts</td> <td align="left">1</td> </tr> <tr> <td align="left">retry_delay</td> <td align="left">1.0 (seconds)</td> </tr> </tbody> </table> <p>When <code>DB::Database</code> is opened an initial number of <code>initial_pool_size</code> connections will be created. The pool will never hold more than <code>max_pool_size</code> connections. When returning/releasing a connection to the pool it will be closed if there are already <code>max_idle_pool_size</code> idle connections.</p> <p>If the <code>max_pool_size</code> was reached and a connection is needed, wait up to <code>checkout_timeout</code> seconds for an existing connection to become available.</p> <p>If a connection is lost or can't be established retry at most <code>retry_attempts</code> times waiting <code>retry_delay</code> seconds between each try.</p> <h2 id="sample">Sample</h2> <p>The following program will print the current time from MySQL but if the connection is lost or the whole server is down for a few seconds the program will still run without raising exceptions.</p> <div class="admonition example"> <p class="admonition-title">sample.cr</p> <div class="crystal highlight"><pre data-language="crystal">require "mysql"

DB.open "mysql://root@localhost?retry_attempts=8&amp;retry_delay=3" do |db|
  loop do
    pp db.scalar("SELECT NOW()")
    sleep 0.5
  end
end
</pre></div> </div> <div class="highlight"><pre data-language="crystal">$ crystal sample.cr
db.scalar("SELECT NOW()") # =&gt; 2016-12-16 16:36:57
db.scalar("SELECT NOW()") # =&gt; 2016-12-16 16:36:57
db.scalar("SELECT NOW()") # =&gt; 2016-12-16 16:36:58
db.scalar("SELECT NOW()") # =&gt; 2016-12-16 16:36:58
db.scalar("SELECT NOW()") # =&gt; 2016-12-16 16:36:59
db.scalar("SELECT NOW()") # =&gt; 2016-12-16 16:36:59
# stop mysql server for some seconds
db.scalar("SELECT NOW()") # =&gt; 2016-12-16 16:37:06
db.scalar("SELECT NOW()") # =&gt; 2016-12-16 16:37:06
db.scalar("SELECT NOW()") # =&gt; 2016-12-16 16:37:07
</pre></div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://crystal-lang.org/reference/database/connection_pool.html" class="_attribution-link" target="_blank">https://crystal-lang.org/reference/database/connection_pool.html</a>
  </p>
</div>
