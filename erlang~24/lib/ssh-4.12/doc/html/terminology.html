<div class="innertube"> <h1>3 Terminology</h1> <h2><span onmouseover="document.getElementById('ghlink-general-information-idm430').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-general-information-idm430').style.visibility = 'hidden';">3.1 General Information</span></h2> <p>In the following terms that may cause confusion are explained. </p> <h2><span onmouseover="document.getElementById('ghlink-the-term--user--idm433').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-the-term--user--idm433').style.visibility = 'hidden';">3.2 The term "user"</span></h2> <p>A "user" is a term that everyone understands intuitively. However, the understandings may differ which can cause confusion. </p> <p>The term is used differently in <code><a href="http://www.openssh.com">OpenSSH</a></code> and SSH in Erlang/OTP. The reason is the different environments and use cases that are not immediatly obvious. </p> <p>This chapter aims at explaining the differences and giving a rationale for why Erlang/OTP handles "user" as it does. </p> <h4><span onmouseover="document.getElementById('ghlink-in-openssh-idm439').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-in-openssh-idm439').style.visibility = 'hidden';">In OpenSSH</span></h4> <p>Many have been in contact with the command 'ssh' on a Linux machine (or similar) to remotly log in on another machine. One types </p> <pre data-language="erlang">ssh host</pre> <p>to log in on the machine named <code class="code">host</code>. The command prompts for your password on the remote <code class="code">host</code> and then you can read, write and execute as your <i>user name</i> has rights on the remote <code class="code">host</code>. There are stronger variants with pre-distributed keys or certificates, but that are for now just details in the authentication process. </p> <p>You could log in as the user <code class="code">anotheruser</code> with </p> <pre data-language="erlang">ssh anotheruser@host</pre> <p>and you will then be enabled to act as <code class="code">anotheruser</code> on the <code class="code">host</code> if authorized correctly. </p> <p>So what does <i>"your user name has rights"</i> mean? In a UNIX/Linux/etc context it is exactly as that context: The <i>user</i> could read, write and execute programs according to the OS rules. In addition, the user has a home directory (<code class="code">$HOME</code>) and there is a <code class="code">$HOME/.ssh/</code> directory with ssh-specific files. </p> <h5>SSH password authentication</h5> <p>When SSH tries to log in to a host, the ssh protocol communicates the user name (as a string) and a password. The remote ssh server checks that there is such a user defined and that the provided password is acceptable. </p> <p>If so, the user is authorized. </p> <h5>SSH public key authentication</h5> <p>This is a stronger method where the ssh protocol brings the user name, the user's public key and some cryptographic information which we could ignore here. </p> <p>The ssh server on the remote host checks: </p> <ul> <li>That the <i>user</i> has a home directory,</li> <li>that home directory contains a .ssh/ directory and</li> <li>the .ssh/ directory contains the public key just received in the <code class="code">authorized_keys</code> file</li> </ul> <p>if so, the user is authorized. </p> <h5>The SSH server on UNIX/Linux/etc after a succesful authentication</h5> <p>After a succesful incoming authentication, a new process runs as the just authenticated user.</p> <p>Next step is to start a service according to the ssh request. In case of a request of a shell, a new one is started which handles the OS-commands that arrives from the client (that's "you"). </p> <p>In case of a sftp request, an sftp server is started in with the user's rights. So it could read, write or delete files if allowed for that user. </p> <h4><span onmouseover="document.getElementById('ghlink-in-erlang-otp-ssh-idm479').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-in-erlang-otp-ssh-idm479').style.visibility = 'hidden';">In Erlang/OTP SSH</span></h4> <p>For the Erlang/OTP SSH server the situation is different. The server executes in an Erlang process in the Erlang emulator which in turn executes in an OS process. The emulator does not try to change its user when authenticated over the SSH protocol. So the remote user name is only for authentication purposes in the Erlang/OTP SSH application. </p> <h5>Password authentication in Erlang SSH</h5> <p>The Erlang/OTP SSH server checks the user name and password in the following order: </p> <ol> <li>If a <code><span class="code">pwdfun</span></code> is defined, that one is called and the returned boolean is the authentication result. </li> <li>Else, if the <code><span class="code">user_passwords</span></code> option is defined and the username and the password matches, the authentication is a success. </li> <li>Else, if the option <code><span class="code">password</span></code> is defined and matches the password the authentication is a success. Note that the use of this option is not recommended in non-test code. </li> </ol> <h5>Public key authentication in Erlang SSH</h5> <p>The user name, public key and cryptographic data (a signature) that is sent by the client, are used as follows (some steps left out for clearity): </p> <ol> <li>A callback module is selected using the options <code><span class="code">key_cb</span></code>. </li> <li>The callback module is used to check that the provided public key is one of the user's pre-stored. In case of the default callback module, the files <code class="code">authorized_keys</code> and <code class="code">authorized_keys2</code> are searched in a directory found in the following order: <ul> <li>If the option <code><span class="code">user_dir_fun</span></code> is defined, that fun is called and the returned directory is used, </li> <li>Else, If the option <code><span class="code">user_dir</span></code> is defined, that directory is used, </li> <li>Else the subdirectory <code class="code">.ssh</code> in the home directory of the user executing the OS process of the Erlang emulator is used. </li> </ul> If the provided public key is not found, the authentication fails. </li> <li>Finally, if the provided public key is found, the signature provided by the client is checked with the public key. </li> </ol> <h5>The Erlang/OTP SSH server after a succesful authentication</h5> <p>After a successful authentication an <i>Erlang process</i> is handling the service request from the remote ssh client. The rights of that process are those of the user of the OS process running the Erlang emulator. </p> <p>If a shell service request arrives to the server, an <i>Erlang shell</i> is opened in the server's emulator. The rights in that shell is independent of the just authenticated user. </p> <p>In case of an sftp request, an sftp server is started with the rights of the user of the Erlang emulator's OS process. So with sftp the authenticated user does not influence the rights. </p> <p>So after an authentication, the user name is not used anymore and has no influence. </p> </div> <div class="footer"> <hr> <p>Copyright Â© 2005-2021 Ericsson AB. All Rights Reserved.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2021 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
