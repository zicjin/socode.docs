<div class="innertube"> <h1>2 Socket Usage</h1> <h2><span onmouseover="document.getElementById('ghlink-introduction-idm76').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-introduction-idm76').style.visibility = 'hidden';">2.1 Introduction</span></h2> <p>The socket interface (module) is basically a "thin" layer on top of the OS socket interface. It is assumed that, unless you have special needs, gen_[tcp|udp|sctp] should be sufficent (when they become available). </p> <p>Note that just because we have a documented and described option, it does <strong>not</strong> mean that the OS supports it. So its recommended that the user reads the platform specific documentation for the option used. </p> <h4><span onmouseover="document.getElementById('ghlink-asynchronous-calls-idm81').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-asynchronous-calls-idm81').style.visibility = 'hidden';">Asynchronous calls</span></h4> <p>Some functions allow for an <i>asynchronous</i> call (<code><a href="socket#accept-nowait"><span class="code">accept/2</span></a></code>, <code><a href="socket#connect-nowait"><span class="code">connect/3</span></a></code>, <code><a href="socket#recv-nowait"><span class="code">recv/3,4</span></a></code>, <code><a href="socket#recvfrom-nowait"><span class="code">recvfrom/3,4</span></a></code>, <code><a href="socket#recvmsg-nowait"><span class="code">recvmsg/2,3,5</span></a></code>, <code><a href="socket#send-nowait"><span class="code">send/3,4</span></a></code>, <code><a href="socket#sendmsg-nowait"><span class="code">sendmsg/3,4</span></a></code> and <code><a href="socket#sendto-nowait"><span class="code">sendto/4,5</span></a></code>). This is achieved by setting the <code class="code">Timeout</code> argument to <code class="code">nowait</code>. For instance, if calling the <code><a href="socket#recv-nowait"><span class="code">recv/3</span></a></code> function with Timeout set to <code class="code">nowait</code> (i.e. <code class="code">recv(Sock, 0, nowait)</code>) when there is actually nothing to read, it will return with <code class="code">{select,</code> <code><a href="socket#type-select_info"><span class="code">SelectInfo</span></a></code><code class="code">}</code> (<code class="code">SelectInfo</code> contains the <code><a href="socket#type-select_handle"><span class="code">SelectHandle</span></a></code>). When data eventually arrives a 'select message' will be sent to the caller:</p> <dl>  <dd><code class="code">{'$socket', socket(), select, SelectHandle}</code></dd> </dl> <p>The caller can then make another call to the recv function and now expect data.</p> <p>Note that all other users are <strong>locked out</strong> until the 'current user' has called the function (recv in this case). So either immediately call the function or <code><a href="socket#cancel-2"><span class="code">cancel</span></a></code>. </p> <p>The user must also be prepared to receive an abort message: </p> <dl>  <dd><code class="code">{'$socket', socket(), abort, Info}</code></dd> </dl> <p>If the operation is aborted for whatever reason (e.g. if the socket is closed "by someone else"). The <code class="code">Info</code> part contains the abort reason (in this case that the socket has been closed <code class="code">Info = {SelectHandle, closed}</code>). </p> <p>The general form of the 'socket' message is: </p> <dl>  <dd><code class="code">{'$socket', Sock :: socket(), Tag :: atom(), Info :: term()}</code></dd> </dl> <p>Where the format of <code class="code">Info</code> is a function of <code class="code">Tag</code>:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Tag</strong></td> <td><strong>Info value type</strong></td> </tr> <tr> <td>select</td> <td>select_handle()</td> </tr> <tr> <td>abort</td> <td>{select_handle(), Reason :: term()}</td> </tr> </table> <p class="doc-table-caption">Table 2.1: socket message info value type</p> </div> <p>The <code class="code">select_handle()</code> is the same as was returned in the <code><a href="socket#type-select_info"><span class="code">SelectInfo</span></a></code>. </p> <h2><span onmouseover="document.getElementById('ghlink-socket-registry-idm156').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-socket-registry-idm156').style.visibility = 'hidden';">2.2 Socket Registry</span></h2> <p>The <strong>socket registry</strong> is how we keep track of sockets. There are two functions that can be used for interaction: <code><a href="socket#number_of-0"><span class="code">socket:number_of/0</span></a></code> and <code><a href="socket#which_sockets-1"><span class="code">socket:which_sockets/1</span></a></code>. </p> <p>In systems which create and delete <strong>many</strong> sockets dynamically, it (the socket registry) could become a bottleneck. For such systems, there are a couple of ways to control the use of the socket registry. </p> <p>Firstly, its possible to effect the global default value when building OTP from source with the two configure options:</p> <pre data-language="erlang">--enable-esock-socket-registry (default) | --disable-esock-socket-registry</pre> <p>Second, its possible to effect the global default value by setting the environment variable <code class="code">ESOCK_USE_SOCKET_REGISTRY</code> (boolean) before starting the erlang. </p> <p>Third, its possible to alter the global default value in runtime by calling the function <code><a href="socket#use_registry-1"><span class="code">use_registry/1</span></a></code>.</p> <p>And finally, its possible to override the global default when creating a socket (with <code><a href="socket#open-2"><span class="code">open/2</span></a></code> and <code><a href="socket#open-4"><span class="code">open/4</span></a></code>) by providing the attribute <code class="code">use_registry</code> (boolean) in the their <code class="code">Opts</code> argument (which effects <strong>that</strong> specific socket).</p> <h2> <span onmouseover="document.getElementById('ghlink-socket-options-idm181').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-socket-options-idm181').style.visibility = 'hidden';" id="socket_options">2.3 Socket Options</span> </h2> <p>Options for level <code class="code">otp</code>: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Option Name</strong></td> <td><strong>Value Type</strong></td> <td><strong>Set</strong></td> <td><strong>Get</strong></td> <td><strong>Other Requirements and comments</strong></td> </tr> <tr> <td>assoc_id</td> <td>integer()</td> <td>no</td> <td>yes</td> <td>type = seqpacket, protocol = sctp, is an association</td> </tr> <tr> <td>debug</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>iow</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>controlling_process</td> <td>pid()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>rcvbuf</td> <td>default | pos_integer() | {pos_integer(), pos_ineteger()}</td> <td>yes</td> <td>yes</td> <td>'default' only valid for set. The tuple form is only valid for type 'stream' and protocol 'tcp'.</td> </tr> <tr> <td>rcvctrlbuf</td> <td>default | pos_integer()</td> <td>yes</td> <td>yes</td> <td>default only valid for set</td> </tr> <tr> <td>sndctrlbuf</td> <td>default | pos_integer()</td> <td>yes</td> <td>yes</td> <td>default only valid for set</td> </tr> <tr> <td>fd</td> <td>integer()</td> <td>no</td> <td>yes</td> <td>none</td> </tr> <tr> <td>use_registry</td> <td>boolean()</td> <td>no</td> <td>yes</td> <td>the value is set when the socket is created, by a call to <code><a href="socket#open-2"><span class="code">open/2</span></a></code> or <code><a href="socket#open-4"><span class="code">open/4</span></a></code>.</td> </tr> </table> <p class="doc-table-caption">Table 2.2: option levels</p> </div> <p>Options for level <code class="code">socket</code>: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Option Name</strong></td> <td><strong>Value Type</strong></td> <td><strong>Set</strong></td> <td><strong>Get</strong></td> <td><strong>Other Requirements and comments</strong></td> </tr> <tr> <td>acceptconn</td> <td>boolean()</td> <td>no</td> <td>yes</td> <td>none</td> </tr> <tr> <td>bindtodevice</td> <td>string()</td> <td>yes</td> <td>yes</td> <td>Before Linux 3.8, this socket option could be set, but not get. Only works for some socket types (e.g. <code class="code">inet</code>). If empty value is set, the binding is removed.</td> </tr> <tr> <td>broadcast</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram</td> </tr> <tr> <td>debug</td> <td>integer()</td> <td>yes</td> <td>yes</td> <td>may require admin capability</td> </tr> <tr> <td>domain</td> <td>domain()</td> <td>no</td> <td>yes</td> <td> <strong>Not</strong> on FreeBSD (for instance)</td> </tr> <tr> <td>dontroute</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>keepalive</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>linger</td> <td>abort | linger()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>oobinline</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>peek_off</td> <td>integer()</td> <td>yes</td> <td>yes</td> <td>domain = local (unix). Currently disabled due to a possible infinite loop when calling recv([peek]) the second time. </td> </tr> <tr> <td>priority</td> <td>integer()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>protocol</td> <td>protocol()</td> <td>no</td> <td>yes</td> <td> <strong>Not</strong> on (some) Darwin (for instance)</td> </tr> <tr> <td>rcvbuf</td> <td>non_neg_integer()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>rcvlowat</td> <td>non_neg_integer()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>rcvtimeo</td> <td>timeval()</td> <td>yes</td> <td>yes</td> <td> This option is not normally supported (see why below). OTP has to be explicitly built with the <code class="code">--enable-esock-rcvsndtime</code> configure option for this to be available. Since our implementation is <strong>nonblocking</strong>, its unknown if and how this option works, or even if it may cause malfunctions. Therefor, we do not recommend setting this option. Instead, use the <code class="code">Timeout</code> argument to, for instance, the <code><a href="socket#recv-3"><span class="code">recv/3</span></a></code> function. </td> </tr> <tr> <td>reuseaddr</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>reuseport</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>domain = inet | inet6</td> </tr> <tr> <td>sndbuf</td> <td>non_neg_integer()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>sndlowat</td> <td>non_neg_integer()</td> <td>yes</td> <td>yes</td> <td>not changeable on Linux</td> </tr> <tr> <td>sndtimeo</td> <td>timeval()</td> <td>yes</td> <td>yes</td> <td> This option is not normally supported (see why below). OTP has to be explicitly built with the <code class="code">--enable-esock-rcvsndtime</code> configure option for this to be available. Since our implementation is <strong>nonblocking</strong>, its unknown if and how this option works, or even if it may cause malfunctions. Therefor, we do not recommend setting this option. Instead, use the <code class="code">Timeout</code> argument to, for instance, the <code><a href="socket#send-3"><span class="code">send/3</span></a></code> function. </td> </tr> <tr> <td>timestamp</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>type</td> <td>type()</td> <td>no</td> <td>yes</td> <td>none</td> </tr> </table> <p class="doc-table-caption">Table 2.3: socket options</p> </div> <p>Options for level <code class="code">ip</code>: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Option Name</strong></td> <td><strong>Value Type</strong></td> <td><strong>Set</strong></td> <td><strong>Get</strong></td> <td><strong>Other Requirements and comments</strong></td> </tr> <tr> <td>add_membership</td> <td>ip_mreq()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> <tr> <td>add_source_membership</td> <td>ip_mreq_source()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> <tr> <td>block_source</td> <td>ip_mreq_source()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> <tr> <td>drop_membership</td> <td>ip_mreq()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> <tr> <td>drop_source_membership</td> <td>ip_mreq_source()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> <tr> <td>freebind</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>hdrincl</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = raw</td> </tr> <tr> <td>minttl</td> <td>integer()</td> <td>yes</td> <td>yes</td> <td>type = raw</td> </tr> <tr> <td>msfilter</td> <td>null | ip_msfilter()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> <tr> <td>mtu</td> <td>integer()</td> <td>no</td> <td>yes</td> <td>type = raw</td> </tr> <tr> <td>mtu_discover</td> <td>ip_pmtudisc()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>multicast_all</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>multicast_if</td> <td>any | ip4_address()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>multicast_loop</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>multicast_ttl</td> <td>uint8()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>nodefrag</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = raw</td> </tr> <tr> <td>pktinfo</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram</td> </tr> <tr> <td>recvdstaddr</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram</td> </tr> <tr> <td>recverr</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>recvif</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw</td> </tr> <tr> <td>recvopts</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type =/= stream</td> </tr> <tr> <td>recvorigdstaddr</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>recvttl</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type =/= stream</td> </tr> <tr> <td>retopts</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type =/= stream</td> </tr> <tr> <td>router_alert</td> <td>integer()</td> <td>yes</td> <td>yes</td> <td>type = raw</td> </tr> <tr> <td>sendsrcaddr</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>tos</td> <td>ip_tos()</td> <td>yes</td> <td>yes</td> <td>some high-priority levels may require superuser capability</td> </tr> <tr> <td>transparent</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>requires admin capability</td> </tr> <tr> <td>ttl</td> <td>integer()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>unblock_source</td> <td>ip_mreq_source()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> </table> <p class="doc-table-caption">Table 2.4: ip options</p> </div> <p>Options for level <code class="code">ipv6</code>: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Option Name</strong></td> <td><strong>Value Type</strong></td> <td><strong>Set</strong></td> <td><strong>Get</strong></td> <td><strong>Other Requirements and comments</strong></td> </tr> <tr> <td>addrform</td> <td>inet</td> <td>yes</td> <td>no</td> <td>allowed only for IPv6 sockets that are connected and bound to a v4-mapped-on-v6 address</td> </tr> <tr> <td>add_membership</td> <td>ipv6_mreq()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> <tr> <td>authhdr</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw, obsolete?</td> </tr> <tr> <td>drop_membership</td> <td>ipv6_mreq()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> <tr> <td>dstopts</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw, requires superuser privileges to update</td> </tr> <tr> <td>flowinfo</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw, requires superuser privileges to update</td> </tr> <tr> <td>hoplimit</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw. On some platforms (e.g. FreeBSD) is used to set in order to get <code class="code">hoplimit</code> as a control message heeader. On others (e.g. Linux), <code class="code">recvhoplimit</code> is set in order to get <code class="code">hoplimit</code>. </td> </tr> <tr> <td>hopopts</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw, requires superuser privileges to update</td> </tr> <tr> <td>mtu</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>Get: Only after the socket has been connected</td> </tr> <tr> <td>mtu_discover</td> <td>ipv6_pmtudisc()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>multicast_hops</td> <td>default | uint8()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>multicast_if</td> <td>integer()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw</td> </tr> <tr> <td>multicast_loop</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>recverr</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>recvhoplimit</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw. On some platforms (e.g. Linux), <code class="code">recvhoplimit</code> is set in order to get <code class="code">hoplimit</code> </td> </tr> <tr> <td>recvpktinfo | pktinfo</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw. On some platforms (e.g. FreeBSD) is used to set in order to get <code class="code">hoplimit</code> as a control message heeader. On others (e.g. Linux), <code class="code">recvhoplimit</code> is set in order to get <code class="code">hoplimit</code>. </td> </tr> <tr> <td>recvtclass</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw. On some platforms is used to set (=true) in order to get the <code class="code">tclass</code> control message heeader. On others, <code class="code">tclass</code> is set in order to get <code class="code">tclass</code> control message heeader. </td> </tr> <tr> <td>router_alert</td> <td>integer()</td> <td>yes</td> <td>yes</td> <td>type = raw</td> </tr> <tr> <td>rthdr</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>type = dgram | raw, requires superuser privileges to update</td> </tr> <tr> <td>tclass</td> <td>integer()</td> <td>yes</td> <td>yes</td> <td>Set the traffic class associated with outgoing packets. RFC3542. </td> </tr> <tr> <td>unicast_hops</td> <td>default | uint8()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>v6only</td> <td>boolean()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> </table> <p class="doc-table-caption">Table 2.5: ipv6 options</p> </div> <p>Options for level <code class="code">tcp</code>: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Option Name</strong></td> <td><strong>Value Type</strong></td> <td><strong>Set</strong></td> <td><strong>Get</strong></td> <td><strong>Other Requirements and comments</strong></td> </tr> <tr> <td>congestion</td> <td>string()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>maxseg</td> <td>integer()</td> <td>yes</td> <td>yes</td> <td>Set not allowed on all platforms.</td> </tr> <tr> <td>nodelay</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> </table> <p class="doc-table-caption">Table 2.6: tcp options</p> </div> <p>Options for level <code class="code">udp</code>: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Option Name</strong></td> <td><strong>Value Type</strong></td> <td><strong>Set</strong></td> <td><strong>Get</strong></td> <td><strong>Other Requirements and comments</strong></td> </tr> <tr> <td>cork</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> </table> <p class="doc-table-caption">Table 2.7: udp options</p> </div> <p>Options for level <code class="code">sctp</code>: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Option Name</strong></td> <td><strong>Value Type</strong></td> <td><strong>Set</strong></td> <td><strong>Get</strong></td> <td><strong>Other Requirements and comments</strong></td> </tr> <tr> <td>associnfo</td> <td>sctp_assocparams()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>autoclose</td> <td>non_neg_integer()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>disable_fragments</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>events</td> <td>sctp_event_subscribe()</td> <td>yes</td> <td>no</td> <td>none</td> </tr> <tr> <td>initmsg</td> <td>sctp_initmsg()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>maxseg</td> <td>non_neg_integer()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>nodelay</td> <td>boolean()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> <tr> <td>rtoinfo</td> <td>sctp_rtoinfo()</td> <td>yes</td> <td>yes</td> <td>none</td> </tr> </table> <p class="doc-table-caption">Table 2.8: sctp options</p> </div> </div> <div class="footer"> <hr> <p>Copyright © 1997-2021 Ericsson AB. All Rights Reserved.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2021 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
