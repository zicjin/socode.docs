<div class="innertube"> <h1>10 Code Coverage Analysis</h1> <h2> <span onmouseover="document.getElementById('ghlink-general-idm2519').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-general-idm2519').style.visibility = 'hidden';" id="cover">10.1 General</span> </h2> <p>Although <code class="code">Common Test</code> was created primarily for black-box testing, nothing prevents it from working perfectly as a white-box testing tool as well. This is especially true when the application to test is written in Erlang. Then the test ports are easily realized with Erlang function calls.</p> <p>When white-box testing an Erlang application, it is useful to be able to measure the code coverage of the test. <code class="code">Common Test</code> provides simple access to the OTP Cover tool for this purpose. <code class="code">Common Test</code> handles all necessary communication with the Cover tool (starting, compiling, analysing, and so on). The <code class="code">Common Test</code> user only needs to specify the extent of the code coverage analysis.</p> <h2><span onmouseover="document.getElementById('ghlink-use-idm2528').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-use-idm2528').style.visibility = 'hidden';">10.2 Use</span></h2> <p>To specify the modules to be included in the code coverage test, provide a cover specification file. With this file you can point out specific modules or specify directories containing modules to be included in the analysis. You can also specify modules to be excluded from the analysis.</p> <p>If you are testing a distributed Erlang application, it is likely that code you want included in the code coverage analysis gets executed on another Erlang node than the one <code class="code">Common Test</code> is running on. If so, you must specify these other nodes in the cover specification file or add them dynamically to the code coverage set of nodes. For details on the latter, see module <code><a href="ct_cover"><span class="code">ct_cover</span></a></code>.</p> <p>In the cover specification file you can also specify your required level of the code coverage analysis; <code class="code">details</code> or <code class="code">overview</code>. In detailed mode, you get a coverage overview page, showing per module and total coverage percentages. You also get an HTML file printed for each module included in the analysis showing exactly what parts of the code have been executed during the test. In overview mode, only the code coverage overview page is printed.</p> <p>You can choose to export and import code coverage data between tests. If you specify the name of an export file in the cover specification file, <code class="code">Common Test</code> exports collected coverage data to this file at the end of the test. You can similarly specify previously exported data to be imported and included in the analysis for a test (multiple import files can be specified). This way, the total code coverage can be analyzed without necessarily running all tests at once.</p> <p>To activate the code coverage support, specify the name of the cover specification file as you start <code class="code">Common Test</code>. Do this by using flag <code class="code">-cover</code> with <code><a href="ct_run"><span class="code">ct_run</span></a></code>, for example:</p> <pre data-language="erlang">
$ ct_run -dir $TESTOBJS/db -cover $TESTOBJS/db/config/db.coverspec</pre> <p>You can also pass the cover specification file name in a call to <code><a href="ct#run_test-1"><span class="code">ct:run_test/1</span></a></code>, by adding a <code class="code">{cover,CoverSpec}</code> tuple to argument <code class="code">Opts</code>.</p> <p>You can also enable code coverage in your test specifications (see section <code><a href="run_test_chapter#test_specifications">Test Specifications</a></code> in section Running Tests and Analyzing Results).</p> <h2> <span onmouseover="document.getElementById('ghlink-stopping-the-cover-tool-when-tests-are-completed-idm2553').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-stopping-the-cover-tool-when-tests-are-completed-idm2553').style.visibility = 'hidden';" id="cover_stop">10.3 Stopping the Cover Tool When Tests Are Completed</span> </h2> <p>By default, the Cover tool is automatically stopped when the tests are completed. This causes the original (non-cover compiled) modules to be loaded back into the test node. If a process at this point still runs old code of any of the modules that are cover compiled, meaning that it has not done any fully qualified function call after the cover compilation, the process is killed. To avoid this, set the value of option <code class="code">cover_stop</code> to <code class="code">false</code>. This means that the modules stay cover compiled. Therefore, this is only recommended if the Erlang nodes under test are terminated after the test is completed, or if cover can be manually stopped.</p> <p>The option can be set by using flag <code class="code">-cover_stop</code> with <code class="code">ct_run</code>, by adding <code class="code">{cover_stop,true|false}</code> to argument <code class="code">Opts</code> to <code><a href="ct#run_test-1"><span class="code">ct:run_test/1</span></a></code>, or by adding a <code class="code">cover_stop</code> term in the test specification (see section <code><a href="run_test_chapter#test_specifications">Test Specifications</a></code> in section Running Tests and Analyzing Results).</p> <h2><span onmouseover="document.getElementById('ghlink-the-cover-specification-file-idm2568').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-the-cover-specification-file-idm2568').style.visibility = 'hidden';">10.4 The Cover Specification File</span></h2> <h4><span onmouseover="document.getElementById('ghlink-general-config-idm2570').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-general-config-idm2570').style.visibility = 'hidden';">General Config</span></h4> <p>Here follows the general configuration terms that are allowed in a cover specification file:</p> <pre data-language="erlang">
%% List of Nodes on which cover will be active during test.
%% Nodes = [atom()]
{nodes, Nodes}.       

%% Files with previously exported cover data to include in analysis.
%% CoverDataFiles = [string()]
{import, CoverDataFiles}.

%% Cover data file to export from this session.
%% CoverDataFile = string()
{export, CoverDataFile}.

%% Cover analysis level.
%% Level = details | overview
{level, Level}.       

%% Directories to include in cover.
%% Dirs = [string()]
{incl_dirs, Dirs}.

%% Directories, including subdirectories, to include.
{incl_dirs_r, Dirs}.

%% Specific modules to include in cover.
%% Mods = [atom()]
{incl_mods, Mods}.

%% Directories to exclude in cover.
{excl_dirs, Dirs}.

%% Directories, including subdirectories, to exclude.
{excl_dirs_r, Dirs}.

%% Specific modules to exclude in cover.
{excl_mods, Mods}.

%% Cross cover compilation
%% Tag = atom(), an identifier for a test run
%% Mod = [atom()], modules to compile for accumulated analysis
{cross,[{Tag,Mods}]}.</pre> <p>The terms <code class="code">incl_dirs_r</code> and <code class="code">excl_dirs_r</code> tell <code class="code">Common Test</code> to search the specified directories recursively and include or exclude any module found during the search. The terms <code class="code">incl_dirs</code> and <code class="code">excl_dirs</code> result in a non-recursive search for modules (that is, only modules found in the specified directories are included or excluded).</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Directories containing Erlang modules to be included in a code coverage test must exist in the code server path. Otherwise, the Cover tool fails to recompile the modules. It is not sufficient to specify these directories in the cover specification file for <code class="code">Common Test</code>.</p>
</div> </div> <h4><span onmouseover="document.getElementById('ghlink-otp-application-config-idm2583').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-otp-application-config-idm2583').style.visibility = 'hidden';">OTP application Config</span></h4> <p>When using a cover specification in the testing of an OTP application itself, there is a special incl_app directive that includes the applications modules for the cover compilation.</p> <pre data-language="erlang">
{incl_app, AppName, Cover:: overview | details}.
</pre> <div class="note"> <div class="label">Note</div> <div class="content">

<p>If you desire to also use some other general cover configuration together with this option you should insert the AppName in between the option and its value creating a three tuple. </p>
</div> </div> <h2> <span onmouseover="document.getElementById('ghlink-cross-cover-analysis-idm2589').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-cross-cover-analysis-idm2589').style.visibility = 'hidden';" id="cross_cover">10.5 Cross Cover Analysis</span> </h2> <p>The cross cover mechanism allows cover analysis of modules across multiple tests. It is useful if some code, for example, a library module, is used by many different tests and the accumulated cover result is desirable.</p> <p>This can also be achieved in a more customized way by using parameter <code class="code">export</code> in the cover specification and analysing the result off line. However, the cross cover mechanism is a built-in solution that also provides logging.</p> <p>The mechanism is easiest explained by an example:</p> <p>Assume that there are two systems, <code class="code">s1</code> and <code class="code">s2</code>, that are tested in separate test runs. System <code class="code">s1</code> contains a library module <code class="code">m1</code> tested by test run <code class="code">s1</code> and is included in the cover specification of <code class="code">s1</code> as follows:</p> <pre data-language="erlang">s1.cover:
  {incl_mods,[m1]}.</pre> <p>When analysing code coverage, the result for <code class="code">m1</code> can be seen in the cover log in the <code class="code">s1</code> test result.</p> <p>Now, imagine that as <code class="code">m1</code> is a library module, it is also often used by system <code class="code">s2</code>. Test run <code class="code">s2</code> does not specifically test <code class="code">m1</code>, but it can still be interesting to see which parts of <code class="code">m1</code> that are covered by the <code class="code">s2</code> tests. To do this, <code class="code">m1</code> can be included also in the cover specification of <code class="code">s2</code> as follows:</p> <pre data-language="erlang">s2.cover:
  {incl_mods,[m1]}.</pre> <p>This gives an entry for <code class="code">m1</code> also in the cover log for test run <code class="code">s2</code>. The problem is that this only reflects the coverage by <code class="code">s2</code> tests, not the accumulated result over <code class="code">s1</code> and <code class="code">s2</code>. This is where the cross cover mechanism comes in handy.</p> <p>If instead the cover specification for <code class="code">s2</code> is like the following:</p> <pre data-language="erlang">s2.cover:
  {cross,[{s1,[m1]}]}.</pre> <p>Then <code class="code">m1</code> is cover compiled in test run <code class="code">s2</code>, but not shown in the coverage log. Instead, if <code><a href="ct_cover#cross_cover_analyse-2"><span class="code">ct_cover:cross_cover_analyse/2</span></a></code> is called after both <code class="code">s1</code> and <code class="code">s2</code> test runs are completed, the accumulated result for <code class="code">m1</code> is available in the cross cover log for test run <code class="code">s1</code>.</p> <p>The call to the analyze function must be as follows:</p> <pre data-language="erlang">ct_cover:cross_cover_analyse(Level, [{s1,S1LogDir},{s2,S2LogDir}]).</pre> <p>Here, <code class="code">S1LogDir</code> and <code class="code">S2LogDir</code> are the directories named <code class="code">&lt;TestName&gt;.logs</code> for each test respectively.</p> <p>Notice the tags <code class="code">s1</code> and <code class="code">s2</code>, which are used in the cover specification file and in the call to <code class="code">ct_cover:cross_cover_analyse/2</code>. The purpose of these is only to map the modules specified in the cover specification to the log directory specified in the call to the analyze function. The tag name has no meaning beyond this.</p> <h2><span onmouseover="document.getElementById('ghlink-logging-idm2645').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-logging-idm2645').style.visibility = 'hidden';">10.6 Logging</span></h2> <p>To view the result of a code coverage test, click the button labeled "COVER LOG" in the top-level index page for the test run.</p> <p>Before Erlang/OTP 17.1, if your test run consisted of multiple tests, cover would be started and stopped for each test within the test run. Separate logs would be available through the "Coverage log" link on the test suite result pages. These links are still available, but now they all point to the same page as the button on the top-level index page. The log contains the accumulated results for the complete test run. For details about this change, see the release notes.</p> <p>The button takes you to the code coverage overview page. If you have successfully performed a detailed coverage analysis, links to each individual module coverage page are found here.</p> <p>If cross cover analysis is performed, and there are accumulated coverage results for the current test, the link "Coverdata collected over all tests" takes you to these results.</p> </div> <div class="footer"> <hr> <p>Copyright © 2003-2021 Ericsson AB. All Rights Reserved.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2021 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
