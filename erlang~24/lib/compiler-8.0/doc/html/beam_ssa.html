<div class="innertube"> <h1>1 Invariants on the Structure and Format of BEAM SSA</h1> <h2> <span onmouseover="document.getElementById('ghlink-function-calls-idm4950').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-function-calls-idm4950').style.visibility = 'hidden';" id="Function-Calls">1.1 Function Calls</span> </h2> <p> All function calls not in a tail call position must be followed by a succeeded:body-instruction unless one of the following exceptions apply: </p> <ul> <li> <p>The function call can statically be proven to always fail. </p> </li> <li> <p>The function call is to the <code class="code">erlang</code>-module and can statically be proven to always succeed or fail. </p> </li> </ul> <h2> <span onmouseover="document.getElementById('ghlink-variable-naming-idm4960').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-variable-naming-idm4960').style.visibility = 'hidden';" id="Variable-Naming">1.2 Variable Naming</span> </h2> <p> A variable name in BEAM SSA is either an atom, a non-negative integer or a tuple: <code class="code">atom() | non_neg_integer() | {atom() | non_neg_integer(), non_neg_integer()}</code>. In order to generate fresh unused variable names, all compiler transforms maintain a counter, the <code class="code">cnt</code>-field in the <code class="code">opt_st</code>-record, which is incremented each time a new variable or label is created. In the following description the value of the <code class="code">cnt</code>-field is called <code class="code">Cnt</code>. </p> <p> Due to peculiarities in the BEAM SSA code generator, a compiler transformation unfortunately cannot just use the <code class="code">cnt</code>-value directly as a fresh name. There are three basic strategies for creating fresh variable names which can by used by a compiler pass: </p> <p> 1) A name can be derived from an existing name of the form <code class="code">V :: atom() | non_neg_integer()</code> by selecting an atom, which is unique to the compiler pass, to form a new name <code class="code">{A, V}</code>. The same <code class="code">A</code> cannot be used by strategy 3) below. </p> <p> 2) A name can be derived from an existing name of the form <code class="code">V :: non_neg_integer()</code> by combining it with the <code class="code">cnt</code>-field into <code class="code">{V, Cnt}</code>. </p> <p> 3) A fresh name can be created by selecting an atom <code class="code">A</code>, which is unique to the compiler pass, to form the new name <code class="code">{A, Cnt}</code>. The same <code class="code">A</code> cannot be used by strategy 1) above. </p> </div> <div class="footer"> <hr> <p>Copyright Â© 1997-2021 Ericsson AB. All Rights Reserved.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2021 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
