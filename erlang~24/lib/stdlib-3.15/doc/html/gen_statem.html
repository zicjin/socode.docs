  <div class="innertube"> <h2><span onmouseover="document.getElementById('ghlink-module-idm13953').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-module-idm13953').style.visibility = 'hidden';">Module</span></h2> <p class="REFBODY module-body">gen_statem</p> </div> <div class="innertube"> <h2><span onmouseover="document.getElementById('ghlink-module-summary-idm13954').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-module-summary-idm13954').style.visibility = 'hidden';">Module Summary</span></h2> <p class="REFBODY module-summary-body">Generic state machine behavior.</p> <h2><span onmouseover="document.getElementById('ghlink-since-idm13954').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-since-idm13954').style.visibility = 'hidden';">Since</span></h2> <p class="REFBODY module-since"> Module gen_statem was introduced in OTP 19.0. </p> </div> <div class="innertube"> <h2><span onmouseover="document.getElementById('ghlink-description-idm13955').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-description-idm13955').style.visibility = 'hidden';">Description</span></h2> 
<p> <code class="code">gen_statem</code> provides a generic state machine behaviour that for new code replaces its predecessor <code><a href="gen_fsm"><span class="code">gen_fsm</span></a></code> since Erlang/OTP 20.0. The <code class="code">gen_fsm</code> behaviour remains in OTP "as is". </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> If you are new to <code class="code">gen_statem</code> and want an overview of concepts and operation the section <code> <span class="code">gen_statem</span> Behaviour </code> located in the User's Guide <code> OTP Design Principles </code> is recommended to read before this reference manual, possibly after the Description section you are reading here. </p> </div> </div> <p> This reference manual contains type descriptions generated from types in the <code class="code">gen_statem</code> source code, so they are correct. However, the generated descriptions also reflect the type hierarchy, which sometimes makes it hard to get a good overview. If so, see the section <code> <span class="code">gen_statem</span> Behaviour </code> in the <code> OTP Design Principles </code> User's Guide. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<ul> <li>This behavior appeared in Erlang/OTP 19.0.</li> <li> In OTP 19.1 a backwards incompatible change of the return tuple from <code><a href="#Module:init-1"><span class="code">Module:init/1</span></a></code> was made and the mandatory callback function <code><a href="#Module:callback_mode-0"> <span class="code">Module:callback_mode/0</span> </a></code> was introduced. </li> <li> In OTP 20.0 <code><a href="#type-generic_timeout"> generic time-outs </a></code> were added. </li> <li> In OTP 22.1 time-out content <code><a href="#type-timeout_update_action"> <span class="code">update</span> </a></code> and explicit time-out <code><a href="#type-timeout_cancel_action"> <span class="code">cancel</span> </a></code> were added. </li> <li> In OTP 22.3 the possibility to change the callback module with actions <code><a href="#type-action"><span class="code">change_callback_module</span></a></code>, <code><a href="#type-action"><span class="code">push_callback_module</span></a></code> and <code><a href="#type-action"><span class="code">pop_callback_module</span></a></code>, was added. </li> </ul> </div> </div> <p> <code class="code">gen_statem</code> has got the same features that <code><a href="gen_fsm"><span class="code">gen_fsm</span></a></code> had and adds some really useful: </p> <ul> <li>Co-located state code</li> <li>Arbitrary term state</li> <li>Event postponing</li> <li>Self-generated events</li> <li>State time-out</li> <li>Multiple generic named time-outs</li> <li>Absolute time-out time</li> <li>Automatic state enter calls</li> <li> Reply from other state than the request, <code class="code">sys</code> traceable </li> <li>Multiple <code class="code">sys</code> traceable replies</li> <li>Changing the callback module</li> </ul> <p> Two <code><a href="#type-callback_mode"><strong>callback modes</strong></a></code> are supported: </p> <ul> <li> <p> One for finite-state machines (<code><a href="gen_fsm"><span class="code">gen_fsm</span></a></code> like), which requires the state to be an atom and uses that state as the name of the current callback function. </p> </li> <li> <p> One that allows the state to be any term and that uses one callback function for all states. </p> </li> </ul> <p> The callback model(s) for <code class="code">gen_statem</code> differs from the one for <code><a href="gen_fsm"><span class="code">gen_fsm</span></a></code>, but it is still fairly easy to <code><a href="gen_fsm#Migration%20to%20gen_statem"> rewrite from </a></code> <code class="code">gen_fsm</code> to <code class="code">gen_statem</code>. </p> <p> A generic state machine server process (<code class="code">gen_statem</code>) implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see <code>OTP Design Principles</code>. </p> <p> A <code class="code">gen_statem</code> assumes all specific parts to be located in a callback module exporting a predefined set of functions. The relationship between the behavior functions and the callback functions is as follows:</p> <pre data-language="erlang">
gen_statem module            Callback module
-----------------            ---------------
gen_statem:start
gen_statem:start_monitor
gen_statem:start_link -----&gt; Module:init/1

Server start or code change
                      -----&gt; Module:callback_mode/0

gen_statem:stop       -----&gt; Module:terminate/3

gen_statem:call
gen_statem:cast
gen_statem:send_request
erlang:send
erlang:'!'            -----&gt; Module:StateName/3
                             Module:handle_event/4

-                     -----&gt; Module:terminate/3

-                     -----&gt; Module:code_change/4</pre> <p> Events are of different <code><a href="#type-event_type">types</a></code>, so the callback functions can know the origin of an event and how to respond. </p> <p> If a callback function fails or returns a bad value, the <code class="code">gen_statem</code> terminates, unless otherwise stated. However, an exception of class <code><span class="code">throw</span></code> is not regarded as an error but as a valid return from all callback functions. </p>  <p id="state%20callback"> The <strong>state callback</strong> for a specific <code><a href="#type-state">state</a></code> in a <code class="code">gen_statem</code> is the callback function that is called for all events in this state. It is selected depending on which <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> that the callback module defines with the callback function <code><a href="#Module:callback_mode-0"><span class="code">Module:callback_mode/0</span></a></code>. </p> <p> When the <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> is <code class="code">state_functions</code>, the state must be an atom and is used as the <strong>state callback</strong> name; see <code><a href="#Module:StateName-3"><span class="code">Module:StateName/3</span></a></code>. This co-locates all code for a specific state in one function as the <code class="code">gen_statem</code> engine branches depending on state name. Note the fact that the callback function <code><a href="#Module:terminate-3"><span class="code">Module:terminate/3</span></a></code> makes the state name <code class="code">terminate</code> unusable in this mode. </p> <p> When the <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> is <code class="code">handle_event_function</code>, the state can be any term and the <strong>state callback</strong> name is <code><a href="#Module:handle_event-4"><span class="code">Module:handle_event/4</span></a></code>. This makes it easy to branch depending on state or event as you desire. Be careful about which events you handle in which states so that you do not accidentally postpone an event forever creating an infinite busy loop. </p> <p> When <code class="code">gen_statem</code> receives a process message it is converted into an event and the <code><a href="#state%20callback"><strong>state callback</strong></a></code> is called with the event as two arguments: type and content. When the <code><a href="#state%20callback"><strong>state callback</strong></a></code> has processed the event it returns to <code class="code">gen_statem</code> which does a <strong>state transition</strong>. If this <strong>state transition</strong> is to a different state, that is: <code class="code">NextState =/= State</code>, it is a <strong>state change</strong>. </p> <p> The <code><a href="#state%20callback"><strong>state callback</strong></a></code> may return <code><a href="#type-action"><strong>transition actions</strong></a></code> for <code class="code">gen_statem</code> to execute during the <strong>state transition</strong>, for example to reply to a <code><a href="#call-2"><span class="code">gen_statem:call/2,3</span></a></code>. </p> <p> One of the possible <strong>transition actions</strong> is to postpone the current event. Then it is not retried in the current state. The <code class="code">gen_statem</code> engine keeps a queue of events divided into the postponed events and the events still to process. After a <strong>state change</strong> the queue restarts with the postponed events. </p> <p> The <code class="code">gen_statem</code> event queue model is sufficient to emulate the normal process message queue with selective receive. Postponing an event corresponds to not matching it in a receive statement, and changing states corresponds to entering a new receive statement. </p> <p> The <code><a href="#state%20callback"><strong>state callback</strong></a></code> can insert events using the <code><a href="#type-action"><strong>transition actions</strong></a></code> <code class="code">next_event</code> and such an event is inserted in the event queue as the next to call the <code><a href="#state%20callback"><strong>state callback</strong></a></code> with. That is, as if it is the oldest incoming event. A dedicated <code><a href="#type-event_type"><span class="code">event_type()</span></a></code> <code class="code">internal</code> can be used for such events making them impossible to mistake for external events. </p> <p> Inserting an event replaces the trick of calling your own state handling functions that you often would have to resort to in, for example, <code><a href="gen_fsm"><span class="code">gen_fsm</span></a></code> to force processing an inserted event before others. </p> <p> The <code class="code">gen_statem</code> engine can automatically make a specialized call to the <code><a href="#state%20callback"><strong>state callback</strong></a></code> whenever a new state is entered; see <code><a href="#type-state_enter"><span class="code">state_enter()</span></a></code>. This is for writing code common to all state entries. Another way to do it is to explicitly insert an event at the <strong>state transition</strong>, and/or to use a dedicated <strong>state transition</strong> function, but that is something you will have to remember at every <strong>state transition</strong> to the state(s) that need it. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>If you in <code class="code">gen_statem</code>, for example, postpone an event in one state and then call another <strong>state callback</strong> of yours, you have not done a <strong>state change</strong> and hence the postponed event is not retried, which is logical but can be confusing. </p> </div> </div> <p> For the details of a <strong>state transition</strong>, see type <code><a href="#type-transition_option"><span class="code">transition_option()</span></a></code>. </p> <p> A <code class="code">gen_statem</code> handles system messages as described in <code><a href="sys"><span class="code">sys</span></a></code>. The <code class="code">sys</code> module can be used for debugging a <code class="code">gen_statem</code>. </p> <p> Notice that a <code class="code">gen_statem</code> does not trap exit signals automatically, this must be explicitly initiated in the callback module (by calling <code><span class="code">process_flag(trap_exit, true)</span></code>. </p> <p> Unless otherwise stated, all functions in this module fail if the specified <code class="code">gen_statem</code> does not exist or if bad arguments are specified. </p> <p> The <code class="code">gen_statem</code> process can go into hibernation; see <code><a href="proc_lib#hibernate-3"><span class="code">proc_lib:hibernate/3</span></a></code>. It is done when a <code><a href="#state%20callback"><strong>state callback</strong></a></code> or <code><a href="#Module:init-1"><span class="code">Module:init/1</span></a></code> specifies <code class="code">hibernate</code> in the returned <code><a href="#type-action"><span class="code">Actions</span></a></code> list. This feature can be useful to reclaim process heap memory while the server is expected to be idle for a long time. However, use this feature with care, as hibernation can be too costly to use after every event; see <code><span class="code">erlang:hibernate/3</span></code>. </p> <p> There is also a server start option <code><a href="#type-enter_loop_opt"> <span class="code">{hibernate_after, Timeout}</span> </a></code> for <code><a href="#start-3"><span class="code">start/3,4</span></a></code>, <code><a href="#start_monitor-3"><span class="code">start_monitor/3,4</span></a></code>, <code><a href="#start_link-3"><span class="code">start_link/3,4</span></a></code> or <code><a href="#enter_loop-4"><span class="code">enter_loop/4,5,6</span></a></code>, that may be used to automatically hibernate the server. </p> <p> If the <code class="code">gen_statem</code> process terminates, e.g. as a result of a function in the callback module returning <code class="code">{stop,Reason}</code>, an exit signal with this <code class="code">Reason</code> is sent to linked processes and ports. See <code> Processes</code> in the Reference Manual for details regarding error handling using exit signals. </p>  </div> <div class="innertube"> <h2><span onmouseover="document.getElementById('ghlink-example-idm14167').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-example-idm14167').style.visibility = 'hidden';">Example</span></h2>  <p> The following example shows a simple pushbutton model for a toggling pushbutton implemented with <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> <code class="code">state_functions</code>. You can push the button and it replies if it went on or off, and you can ask for a count of how many times it has been pushed to switch on. </p> <p>The following is the complete callback module file <code class="code">pushbutton.erl</code>:</p> <pre data-language="erlang">-module(pushbutton).
-behaviour(gen_statem).

-export([start/0,push/0,get_count/0,stop/0]).
-export([terminate/3,code_change/4,init/1,callback_mode/0]).
-export([on/3,off/3]).

name() -&gt; pushbutton_statem. % The registered server name

%% API.  This example uses a registered name name()
%% and does not link to the caller.
start() -&gt;
    gen_statem:start({local,name()}, ?MODULE, [], []).
push() -&gt;
    gen_statem:call(name(), push).
get_count() -&gt;
    gen_statem:call(name(), get_count).
stop() -&gt;
    gen_statem:stop(name()).

%% Mandatory callback functions
terminate(_Reason, _State, _Data) -&gt;
    void.
code_change(_Vsn, State, Data, _Extra) -&gt;
    {ok,State,Data}.
init([]) -&gt;
    %% Set the initial state + data.  Data is used only as a counter.
    State = off, Data = 0,
    {ok,State,Data}.
callback_mode() -&gt; state_functions.

%%% state callback(s)

off({call,From}, push, Data) -&gt;
    %% Go to 'on', increment count and reply
    %% that the resulting status is 'on'
    {next_state,on,Data+1,[{reply,From,on}]};
off(EventType, EventContent, Data) -&gt;
    handle_event(EventType, EventContent, Data).

on({call,From}, push, Data) -&gt;
    %% Go to 'off' and reply that the resulting status is 'off'
    {next_state,off,Data,[{reply,From,off}]};
on(EventType, EventContent, Data) -&gt;
    handle_event(EventType, EventContent, Data).

%% Handle events common to all states
handle_event({call,From}, get_count, Data) -&gt;
    %% Reply with the current count
    {keep_state,Data,[{reply,From,Data}]};
handle_event(_, _, Data) -&gt;
    %% Ignore all other events
    {keep_state,Data}.</pre> <p>The following is a shell session when running it:</p> <pre data-language="erlang">
1&gt; pushbutton:start().
{ok,&lt;0.36.0&gt;}
2&gt; pushbutton:get_count().
0
3&gt; pushbutton:push().
on
4&gt; pushbutton:get_count().
1
5&gt; pushbutton:push().
off
6&gt; pushbutton:get_count().
1
7&gt; pushbutton:stop().
ok
8&gt; pushbutton:push().
** exception exit: {noproc,{gen_statem,call,[pushbutton_statem,push,infinity]}}
     in function  gen:do_for_proc/2 (gen.erl, line 261)
     in call from gen_statem:call/3 (gen_statem.erl, line 386)
    </pre> <p> To compare styles, here follows the same example using <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> <code class="code">handle_event_function</code>, or rather the code to replace after function <code class="code">init/1</code> of the <code class="code">pushbutton.erl</code> example file above: </p> <pre data-language="erlang">callback_mode() -&gt; handle_event_function.

%%% state callback(s)

handle_event({call,From}, push, off, Data) -&gt;
    %% Go to 'on', increment count and reply
    %% that the resulting status is 'on'
    {next_state,on,Data+1,[{reply,From,on}]};
handle_event({call,From}, push, on, Data) -&gt;
    %% Go to 'off' and reply that the resulting status is 'off'
    {next_state,off,Data,[{reply,From,off}]};
%%
%% Event handling common to all states
handle_event({call,From}, get_count, State, Data) -&gt;
    %% Reply with the current count
    {next_state,State,Data,[{reply,From,Data}]};
handle_event(_, _, State, Data) -&gt;
    %% Ignore all other events
    {next_state,State,Data}.</pre>  </div> <div class="innertube"> <h2><span onmouseover="document.getElementById('ghlink-data-types-idm14185').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-data-types-idm14185').style.visibility = 'hidden';">Data Types</span></h2> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-server_name').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-server_name').style.visibility = 'hidden';">  <code>server_name() = <br id="type-server_name">    {global, GlobalName :: term()} |<br>    {via, RegMod :: module(), Name :: term()} |<br>    {local, atom()}</code><br> </div> <div class="data-type-desc">

<p> Name specification to use when starting a <code class="code">gen_statem</code> server. See <code><a href="#start_link-3"><span class="code">start_link/3</span></a></code> and <code><a href="#type-server_ref"><span class="code">server_ref()</span></a></code> below. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-server_ref').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-server_ref').style.visibility = 'hidden';">  <code>server_ref() = <br id="type-server_ref">    pid() |<br>    (LocalName :: atom()) |<br>    {Name :: atom(), Node :: atom()} |<br>    {global, GlobalName :: term()} |<br>    {via, RegMod :: module(), ViaName :: term()}</code><br> </div> <div class="data-type-desc">

<p> Server specification to use when addressing a <code class="code">gen_statem</code> server. See <code><a href="#call-2"><span class="code">call/2</span></a></code> and <code><a href="#type-server_name"><span class="code">server_name()</span></a></code> above. </p> <p>It can be:</p> <dl> <dt><strong><code class="code">pid() | LocalName</code></strong></dt> <dd> <p> The <code class="code">gen_statem</code> is locally registered. </p> </dd> <dt><strong><code class="code">{Name,Node}</code></strong></dt> <dd> <p> The <code class="code">gen_statem</code> is locally registered on another node. </p> </dd> <dt><strong><code class="code">{global,GlobalName}</code></strong></dt> <dd> <p> The <code class="code">gen_statem</code> is globally registered in <code><span class="code">global</span></code>. </p> </dd> <dt><strong><code class="code">{via,RegMod,ViaName}</code></strong></dt> <dd> <p> The <code class="code">gen_statem</code> is registered in an alternative process registry. The registry callback module <code class="code">RegMod</code> is to export functions <code class="code">register_name/2</code>, <code class="code">unregister_name/1</code>, <code class="code">whereis_name/1</code>, and <code class="code">send/2</code>, which are to behave like the corresponding functions in <code><span class="code">global</span></code>. Thus, <code class="code">{via,global,GlobalName}</code> is the same as <code class="code">{global,GlobalName}</code>. </p> </dd> </dl> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-start_opt').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-start_opt').style.visibility = 'hidden';">  <code>start_opt() = <br id="type-start_opt">    {timeout, Time :: timeout()} |<br>    {spawn_opt, [<span>proc_lib:start_spawn_option()</span>]} |<br>    <span><a href="#type-enter_loop_opt">enter_loop_opt()</a></span></code><br> </div> <div class="data-type-desc">

<p> Options that can be used when starting a <code class="code">gen_statem</code> server through, for example, <code><a href="#start_link-3"><span class="code">start_link/3</span></a></code>. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-start_ret').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-start_ret').style.visibility = 'hidden';">  <code id="type-start_ret">start_ret() = {ok, pid()} | ignore | {error, term()}</code><br> </div> <div class="data-type-desc">

<p> Return value from the <code class="code">start()</code> and <code class="code">start_link()</code> functions, for example, <code><a href="#start_link-3"><span class="code">start_link/3</span></a></code>. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-start_mon_ret').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-start_mon_ret').style.visibility = 'hidden';">  <code>start_mon_ret() = <br id="type-start_mon_ret">    {ok, {pid(), reference()}} | ignore | {error, term()}</code><br> </div> <div class="data-type-desc">

<p> Return value from the <code><a href="#start_monitor-3"><span class="code">start_monitor()</span></a></code> functions. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-enter_loop_opt').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-enter_loop_opt').style.visibility = 'hidden';">  <code>enter_loop_opt() = <br id="type-enter_loop_opt">    {hibernate_after, HibernateAfterTimeout :: timeout()} |<br>    {debug, Dbgs :: [<span>sys:debug_option()</span>]}</code><br> </div> <div class="data-type-desc">

<p> Options that can be used when starting a <code class="code">gen_statem</code> server through, <code><a href="#enter_loop-4"><span class="code">enter_loop/4-6</span></a></code>. </p> <dl> <dt><strong><code class="code">hibernate_after</code></strong></dt> <dd> <p> <code class="code">HibernateAfterTimeout</code> specifies that the <code class="code">gen_statem</code> process awaits any message for <code class="code">HibernateAfterTimeout</code> milliseconds and if no message is received, the process goes into hibernation automatically (by calling <code><a href="proc_lib#hibernate-3"><span class="code">proc_lib:hibernate/3</span></a></code>). </p> </dd> <dt><strong><code class="code">debug</code></strong></dt> <dd> <p> For every entry in <code class="code">Dbgs</code>, the corresponding function in <code><a href="sys"><span class="code">sys</span></a></code> is called. </p> </dd> </dl> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-from').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-from').style.visibility = 'hidden';">  <code id="type-from">from() = {To :: pid(), Tag :: term()}</code><br> </div> <div class="data-type-desc">

<p> Destination to use when replying through, for example, the <code><a href="#type-action"><span class="code">action()</span></a></code> <code class="code">{reply,From,Reply}</code> to a process that has called the <code class="code">gen_statem</code> server using <code><a href="#call-2"><span class="code">call/2</span></a></code>. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-state').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-state').style.visibility = 'hidden';">  <code>state() = <span id="type-state"><a href="#type-state_name">state_name()</a></span> | term()</code><br> </div> <div class="data-type-desc">

<p> If the <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> is <code class="code">handle_event_function</code>, the state can be any term. After a <strong>state change</strong> (<code class="code">NextState =/= State</code>), all postponed events are retried. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-state_name').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-state_name').style.visibility = 'hidden';">  <code id="type-state_name">state_name() = atom()</code><br> </div> <div class="data-type-desc">

<p> If the <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> is <code class="code">state_functions</code>, the state must be an atom. After a <strong>state change</strong> (<code class="code">NextState =/= State</code>), all postponed events are retried. Note that the state <code class="code">terminate</code> is not possible to use since it would collide with the optional callback function <code><a href="#Module:terminate-3"><span class="code">Module:terminate/3</span></a></code>. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-data').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-data').style.visibility = 'hidden';">  <code id="type-data">data() = term()</code><br> </div> <div class="data-type-desc">

<p> A term in which the state machine implementation is to store any server data it needs. The difference between this and the <code><a href="#type-state"><span class="code">state()</span></a></code> itself is that a change in this data does not cause postponed events to be retried. Hence, if a change in this data would change the set of events that are handled, then that data item is to be made a part of the state. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-event_type').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-event_type').style.visibility = 'hidden';">  <code>event_type() = <br id="type-event_type">    <span><a href="#type-external_event_type">external_event_type()</a></span> | <span><a href="#type-timeout_event_type">timeout_event_type()</a></span> | internal</code><br> </div> <div class="data-type-desc">

<p> There are 3 categories of events: <code><a href="#type-external_event_type">external</a></code>, <code><a href="#type-timeout_event_type">timeout</a></code>, and <code class="code">internal</code>. </p> <p> <code class="code">internal</code> events can only be generated by the state machine itself through the <strong>transition action</strong> <code><a href="#type-action"><span class="code">next_event</span></a></code>. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-external_event_type').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-external_event_type').style.visibility = 'hidden';">  <code>external_event_type() = {call, From :: <span id="type-external_event_type"><a href="#type-from">from()</a></span>} | cast | info</code><br> </div> <div class="data-type-desc">

<p> External events are of 3 types: <code class="code">{call,From}</code>, <code class="code">cast</code>, or <code class="code">info</code>. Type <code class="code">call</code> originates from the API functions <code><a href="#call-2"><span class="code">call/2</span></a></code> and <code><a href="#send_request-2"><span class="code">send_request/2</span></a></code>. For calls, the event contains whom to reply to. Type <code class="code">cast</code> originates from the API function <code><a href="#cast-2"><span class="code">cast/2</span></a></code>. Type <code class="code">info</code> originates from regular process messages sent to the <code class="code">gen_statem</code>. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-timeout_event_type').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-timeout_event_type').style.visibility = 'hidden';">  <code>timeout_event_type() = <br id="type-timeout_event_type">    timeout | {timeout, Name :: term()} | state_timeout</code><br> </div> <div class="data-type-desc">

<p> There are 3 types of time-out events that the state machine can generate for itself with the corresponding <code><a href="#type-timeout_action">timeout_action()</a></code>s. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-callback_mode_result').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-callback_mode_result').style.visibility = 'hidden';">  <code>callback_mode_result() = <br id="type-callback_mode_result">    <span><a href="#type-callback_mode">callback_mode()</a></span> | [<span><a href="#type-callback_mode">callback_mode()</a></span> | <span><a href="#type-state_enter">state_enter()</a></span>]</code><br> </div> <div class="data-type-desc">

<p> This is the return type from <code><a href="#Module:callback_mode-0"><span class="code">Module:callback_mode/0</span></a></code> and selects <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> and whether to do <code><a href="#type-state_enter"><strong>state enter calls</strong></a></code>, or not. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-callback_mode').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-callback_mode').style.visibility = 'hidden';">  <code id="type-callback_mode">callback_mode() = state_functions | handle_event_function</code><br> </div> <div class="data-type-desc">

<p> The <strong>callback mode</strong> is selected with the return value from <code><a href="#Module:callback_mode-0"><span class="code">Module:callback_mode/0</span></a></code>: </p> <dl> <dt><strong><code class="code">state_functions</code></strong></dt> <dd> <p> The state must be of type <code><a href="#type-state_name"><span class="code">state_name()</span></a></code> and one callback function per state, that is, <code><a href="#Module:StateName-3"><span class="code">Module:StateName/3</span></a></code>, is used. </p> </dd> <dt><strong><code class="code">handle_event_function</code></strong></dt> <dd> <p> The state can be any term and the callback function <code><a href="#Module:handle_event-4"><span class="code">Module:handle_event/4</span></a></code> is used for all states. </p> </dd> </dl> <p> The function <code><a href="#Module:callback_mode-0"><span class="code">Module:callback_mode/0</span></a></code> is called when starting the <code class="code">gen_statem</code>, after code change and after changing the callback module with any of the actions <code><a href="#type-action"><span class="code">change_callback_module</span></a></code>, <code><a href="#type-action"><span class="code">push_callback_module</span></a></code> or <code><a href="#type-action"><span class="code">pop_callback_module</span></a></code>. The result is cached for subsequent calls to <code><a href="#state%20callback">state callbacks</a></code>. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-state_enter').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-state_enter').style.visibility = 'hidden';">  <code id="type-state_enter">state_enter() = state_enter</code><br> </div> <div class="data-type-desc">

<p> Whether the state machine should use <strong>state enter calls</strong> or not is selected when starting the <code class="code">gen_statem</code> and after code change using the return value from <code><a href="#Module:callback_mode-0"><span class="code">Module:callback_mode/0</span></a></code>. </p> <p> If <code><a href="#Module:callback_mode-0"><span class="code">Module:callback_mode/0</span></a></code> returns a list containing <code class="code">state_enter</code>, the <code class="code">gen_statem</code> engine will, at every <strong>state change</strong>, call the <code><a href="#state%20callback">state callback</a></code> with arguments <code class="code">(enter, OldState, Data)</code> or <code class="code">(enter, OldState, State, Data)</code>, depending on the <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code>. This may look like an event but is really a call performed after the previous <code><a href="#state%20callback"><strong>state callback</strong></a></code> returned and before any event is delivered to the new <code><a href="#state%20callback"><strong>state callback</strong></a></code>. See <code><a href="#Module:StateName-3"><span class="code">Module:StateName/3</span></a></code> and <code><a href="#Module:handle_event-4"><span class="code">Module:handle_event/4</span></a></code>. Such a call can be repeated by returning a <code><a href="#type-state_callback_result"> <span class="code">repeat_state</span> </a></code> or <code><a href="#type-state_callback_result"> <span class="code">repeat_state_and_data</span> </a></code> tuple from the <strong>state callback</strong>. </p> <p> If <code><a href="#Module:callback_mode-0"><span class="code">Module:callback_mode/0</span></a></code> does not return such a list, no <strong>state enter calls</strong> are done. </p> <p> If <code><a href="#Module:code_change-4"><span class="code">Module:code_change/4</span></a></code> should transform the state, it is regarded as a state rename and not a <strong>state change</strong>, which will not cause a <strong>state enter call</strong>. </p> <p> Note that a <strong>state enter call</strong> <strong>will</strong> be done right before entering the initial state even though this actually is not a <strong>state change</strong>. In this case <code class="code">OldState =:= State</code>, which cannot happen for a subsequent state change, but will happen when repeating the <strong>state enter call</strong>. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-transition_option').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-transition_option').style.visibility = 'hidden';">  <code>transition_option() = <br id="type-transition_option">    <span><a href="#type-postpone">postpone()</a></span> |<br>    <span><a href="#type-hibernate">hibernate()</a></span> |<br>    <span><a href="#type-event_timeout">event_timeout()</a></span> |<br>    <span><a href="#type-generic_timeout">generic_timeout()</a></span> |<br>    <span><a href="#type-state_timeout">state_timeout()</a></span></code><br> </div> <div class="data-type-desc">

<p> Transition options can be set by <code><a href="#type-action">actions</a></code> and modify the <strong>state transition</strong>. The <strong>state transition</strong> takes place when the <code><a href="#state%20callback"><strong>state callback</strong></a></code> has processed an event and returns. Here are the sequence of steps for a <strong>state transition</strong>: </p> <ol> <li> <p> All returned <code><a href="#type-action">actions</a></code> are processed in order of appearance. In this step all replies generated by any <code><a href="#type-reply_action"><span class="code">reply_action()</span></a></code> are sent. Other actions set <code class="code">transition_option()</code>s that come into play in subsequent steps. </p> </li> <li> <p> If <code><a href="#type-state_enter"> <strong>state enter calls</strong> </a></code> are used, and either it is the initial state or one of the callback results <code><a href="#type-state_callback_result"> <span class="code">repeat_state_and_data</span> </a></code> or <code><a href="#type-state_callback_result"> <span class="code">repeat_state_and_data</span> </a></code> is used the <code class="code">gen_statem</code> engine calls the current state callback with arguments <code><a href="#type-state_enter"><span class="code">(enter, State, Data)</span></a></code> or <code><a href="#type-state_enter"><span class="code">(enter, State, State, Data)</span></a></code> (depending on <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code>) and when it returns starts again from the top of this sequence. </p> <p> If <code><a href="#type-state_enter"> <strong>state enter calls</strong> </a></code> are used, and the state changes the <code class="code">gen_statem</code> engine calls the new state callback with arguments <code><a href="#type-state_enter"><span class="code">(enter, OldState, Data)</span></a></code> or <code><a href="#type-state_enter"><span class="code">(enter, OldState, State, Data)</span></a></code> (depending on <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code>) and when it returns starts again from the top of this sequence. </p> </li> <li> <p> If <code><a href="#type-postpone"><span class="code">postpone()</span></a></code> is <code class="code">true</code>, the current event is postponed. </p> </li> <li> <p> If this is a <strong>state change</strong>, the queue of incoming events is reset to start with the oldest postponed. </p> </li> <li> <p> All events stored with <code><a href="#type-action"><span class="code">action()</span></a></code> <code class="code">next_event</code> are inserted to be processed before previously queued events. </p> </li> <li> <p> Time-out timers <code><a href="#type-event_timeout"><span class="code">event_timeout()</span></a></code>, <code><a href="#type-generic_timeout"><span class="code">generic_timeout()</span></a></code> and <code><a href="#type-state_timeout"><span class="code">state_timeout()</span></a></code> are handled. Time-outs with zero time are guaranteed to be delivered to the state machine before any external not yet received event so if there is such a time-out requested, the corresponding time-out zero event is enqueued as the newest received event; that is after already queued events such as inserted and postponed events. </p> <p> Any event cancels an <code><a href="#type-event_timeout"><span class="code">event_timeout()</span></a></code> so a zero time event time-out is only generated if the event queue is empty. </p> <p> A <strong>state change</strong> cancels a <code><a href="#type-state_timeout"><span class="code">state_timeout()</span></a></code> and any new transition option of this type belongs to the new state, that is; a <code><a href="#type-state_timeout"><span class="code">state_timeout()</span></a></code> applies to the state the state machine enters. </p> </li> <li> <p> If there are enqueued events the <code><a href="#state%20callback"><strong>state callback</strong></a></code> for the possibly new state is called with the oldest enqueued event, and we start again from the top of this sequence. </p> </li> <li> <p> Otherwise the <code class="code">gen_statem</code> goes into <code class="code">receive</code> or hibernation (if <code><a href="#type-hibernate"><span class="code">hibernate()</span></a></code> is <code class="code">true</code>) to wait for the next message. In hibernation the next non-system event awakens the <code class="code">gen_statem</code>, or rather the next incoming message awakens the <code class="code">gen_statem</code>, but if it is a system event it goes right back into hibernation. When a new message arrives the <code><a href="#state%20callback"><strong>state callback</strong></a></code> is called with the corresponding event, and we start again from the top of this sequence. </p> </li> </ol> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-postpone').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-postpone').style.visibility = 'hidden';">  <code id="type-postpone">postpone() = boolean()</code><br> </div> <div class="data-type-desc">

<p> If <code class="code">true</code>, postpones the current event and retries it after a <strong>state change</strong> (<code class="code">NextState =/= State</code>). </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-hibernate').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-hibernate').style.visibility = 'hidden';">  <code id="type-hibernate">hibernate() = boolean()</code><br> </div> <div class="data-type-desc">

<p> If <code class="code">true</code>, hibernates the <code class="code">gen_statem</code> by calling <code><a href="proc_lib#hibernate-3"><span class="code">proc_lib:hibernate/3</span></a></code> before going into <code class="code">receive</code> to wait for a new external event. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> If there are enqueued events to process when hibrnation is requested, this is optimized by not hibernating but instead calling <code> <span class="code">erlang:garbage_collect/0</span> </code> to simulate that the <code class="code">gen_statem</code> entered hibernation and immediately got awakened by an enqueued event. </p> </div> </div> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-event_timeout').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-event_timeout').style.visibility = 'hidden';">  <code id="type-event_timeout">event_timeout() = timeout() | integer()</code><br> </div> <div class="data-type-desc">

<p> Starts a timer set by <code><a href="#type-enter_action"><span class="code">enter_action()</span></a></code> <code class="code">timeout</code>. When the timer expires an event of <code><a href="#type-event_type"><span class="code">event_type()</span></a></code> <code class="code">timeout</code> will be generated. See <code><span class="code">erlang:start_timer/4</span></code> for how <code class="code">Time</code> and <code><a href="#type-timeout_option"><span class="code">Options</span></a></code> are interpreted. Future <code class="code">erlang:start_timer/4</code> <code class="code">Options</code> will not necessarily be supported. </p> <p> Any event that arrives cancels this time-out. Note that a retried or inserted event counts as arrived. So does a state time-out zero event, if it was generated before this time-out is requested. </p> <p> If <code class="code">Time</code> is <code class="code">infinity</code>, no timer is started, as it never would expire anyway. </p> <p> If <code class="code">Time</code> is relative and <code class="code">0</code> no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event, but after already queued events. </p> <p> Note that it is not possible nor needed to cancel this time-out, as it is cancelled automatically by any other event. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-generic_timeout').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-generic_timeout').style.visibility = 'hidden';">  <code id="type-generic_timeout">generic_timeout() = timeout() | integer()</code><br> </div> <div class="data-type-desc">

<p> Starts a timer set by <code><a href="#type-enter_action"><span class="code">enter_action()</span></a></code> <code class="code">{timeout,Name}</code>. When the timer expires an event of <code><a href="#type-event_type"><span class="code">event_type()</span></a></code> <code class="code">{timeout,Name}</code> will be generated. See <code><span class="code">erlang:start_timer/4</span></code> for how <code class="code">Time</code> and <code><a href="#type-timeout_option"><span class="code">Options</span></a></code> are interpreted. Future <code class="code">erlang:start_timer/4</code> <code class="code">Options</code> will not necessarily be supported. </p> <p> If <code class="code">Time</code> is <code class="code">infinity</code>, no timer is started, as it never would expire anyway. </p> <p> If <code class="code">Time</code> is relative and <code class="code">0</code> no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event. </p> <p> Setting a timer with the same <code class="code">Name</code> while it is running will restart it with the new time-out value. Therefore it is possible to cancel a specific time-out by setting it to <code class="code">infinity</code>. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-state_timeout').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-state_timeout').style.visibility = 'hidden';">  <code id="type-state_timeout">state_timeout() = timeout() | integer()</code><br> </div> <div class="data-type-desc">

<p> Starts a timer set by <code><a href="#type-enter_action"><span class="code">enter_action()</span></a></code> <code class="code">state_timeout</code>. When the timer expires an event of <code><a href="#type-event_type"><span class="code">event_type()</span></a></code> <code class="code">state_timeout</code> will be generated. See <code><span class="code">erlang:start_timer/4</span></code> for how <code class="code">Time</code> and <code><a href="#type-timeout_option"><span class="code">Options</span></a></code> are interpreted. Future <code class="code">erlang:start_timer/4</code> <code class="code">Options</code> will not necessarily be supported. </p> <p> If <code class="code">Time</code> is <code class="code">infinity</code>, no timer is started, as it never would expire anyway. </p> <p> If <code class="code">Time</code> is relative and <code class="code">0</code> no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event. </p> <p> Setting this timer while it is running will restart it with the new time-out value. Therefore it is possible to cancel this time-out by setting it to <code class="code">infinity</code>. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-timeout_option').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-timeout_option').style.visibility = 'hidden';">  <code id="type-timeout_option">timeout_option() = {abs, Abs :: boolean()}</code><br> </div> <div class="data-type-desc">

<p> If <code class="code">Abs</code> is <code class="code">true</code> an absolute timer is started, and if it is <code class="code">false</code> a relative, which is the default. See <code> <span class="code">erlang:start_timer/4</span> </code> for details. </p>  </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-action').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-action').style.visibility = 'hidden';">  <code>action() = <br id="type-action">    postpone |<br>    {postpone, Postpone :: <span><a href="#type-postpone">postpone()</a></span>} |<br>    {next_event,<br>     EventType :: <span><a href="#type-event_type">event_type()</a></span>,<br>     EventContent :: term()} |<br>    {change_callback_module, NewModule :: module()} |<br>    {push_callback_module, NewModule :: module()} |<br>    pop_callback_module |<br>    <span><a href="#type-enter_action">enter_action()</a></span></code><br> </div> <div class="data-type-desc">

<p> These <strong>transition actions</strong> can be invoked by returning them from the <code><a href="#state%20callback"><strong>state callback</strong></a></code> when it is called with an <code><a href="#type-event_type">event</a></code>, from <code><a href="#Module:init-1"><span class="code">Module:init/1</span></a></code> or by giving them to <code><a href="#enter_loop-5"><span class="code">enter_loop/5,6</span></a></code>. </p> <p> Actions are executed in the containing list order. </p> <p> Actions that set <code><a href="#type-transition_option"> transition options </a></code> override any previous of the same type, so the last in the containing list wins. For example, the last <code><a href="#type-postpone"><span class="code">postpone()</span></a></code> overrides any previous <code class="code">postpone()</code> in the list. </p> <dl> <dt><strong><code class="code">postpone</code></strong></dt> <dd> <p> Sets the <code><a href="#type-transition_option"> <span class="code">transition_option()</span> </a></code> <code><a href="#type-postpone"><span class="code">postpone()</span></a></code> for this <strong>state transition</strong>. This action is ignored when returned from <code><a href="#Module:init-1"><span class="code">Module:init/1</span></a></code> or given to <code><a href="#enter_loop-5"><span class="code">enter_loop/5,6</span></a></code>, as there is no event to postpone in those cases. </p> </dd> <dt><strong><code class="code">next_event</code></strong></dt> <dd> <p> This action does not set any <code><a href="#type-transition_option"> <span class="code">transition_option()</span> </a></code> but instead stores the specified <code class="code">EventType</code> and <code class="code">EventContent</code> for insertion after all actions have been executed. </p> <p> The stored events are inserted in the queue as the next to process before any already queued events. The order of these stored events is preserved, so the first <code class="code">next_event</code> in the containing list becomes the first to process. </p> <p> An event of type <code><a href="#type-event_type"><span class="code">internal</span></a></code> is to be used when you want to reliably distinguish an event inserted this way from any external event. </p> </dd> <dt><strong> <code class="code">change_callback_module</code> </strong></dt> <dd> <p> Changes the callback module to <code class="code">NewModule</code> which will be used when calling all subsequent <code><a href="#state%20callback">state callbacks</a></code>. </p> <p> The <code class="code">gen_statem</code> engine will find out the <code><a href="#type-callback_mode"> <strong>callback mode</strong> </a></code> of <code class="code">NewModule</code> by calling <code><a href="#Module:callback_mode-0"> <span class="code">NewModule:callback_mode/0</span> </a></code> before the next <code><a href="#state%20callback">state callback</a></code>. </p> <p> Changing the callback module does not affect the <strong>state transition</strong> in any way, it only changes which module that handles the events. Be aware that all relevant callback functions in <code class="code">NewModule</code> such as the <code><a href="#state%20callback">state callback</a></code>, <code><a href="#Module:code_change-4"><span class="code">NewModule:code_change/4</span></a></code>, <code><a href="#Module:format_status-2"> <span class="code">NewModule:format_status/2</span> </a></code> and <code><a href="#Module:terminate-3"> <span class="code">NewModule:terminate/3</span> </a></code> must be able to handle the state and data from the old module. </p> </dd> <dt><strong> <code class="code">push_callback_module</code> </strong></dt> <dd> <p> Pushes the current callback module to the top of an internal stack of callback modules and changes the callback module to <code class="code">NewModule</code>. Otherwise like <code class="code">{change_callback_module, NewModule}</code> above. </p> </dd> <dt><strong> <code class="code">pop_callback_module</code> </strong></dt> <dd> Pops the top module from the internal stack of callback modules and changes the callback module to be the popped module. If the stack is empty the server fails. Otherwise like <code class="code">{change_callback_module, NewModule}</code> above. </dd> </dl> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-enter_action').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-enter_action').style.visibility = 'hidden';">  <code>enter_action() = <br id="type-enter_action">    hibernate |<br>    {hibernate, Hibernate :: <span><a href="#type-hibernate">hibernate()</a></span>} |<br>    <span><a href="#type-timeout_action">timeout_action()</a></span> |<br>    <span><a href="#type-reply_action">reply_action()</a></span></code><br> </div> <div class="data-type-desc">

<p> These <strong>transition actions</strong> can be invoked by returning them from the <code><a href="#state%20callback"><strong>state callback</strong></a></code>, from <code><a href="#Module:init-1"><span class="code">Module:init/1</span></a></code> or by giving them to <code><a href="#enter_loop-5"><span class="code">enter_loop/5,6</span></a></code>. </p> <p> Actions are executed in the containing list order. </p> <p> Actions that set <code><a href="#type-transition_option">transition options</a></code> override any previous of the same type, so the last in the containing list wins. For example, the last <code><a href="#type-event_timeout"><span class="code">event_timeout()</span></a></code> overrides any previous <code class="code">event_timeout()</code> in the list. </p> <dl> <dt><strong><code class="code">hibernate</code></strong></dt> <dd> <p> Sets the <code><a href="#type-transition_option"><span class="code">transition_option()</span></a></code> <code><a href="#type-hibernate"><span class="code">hibernate()</span></a></code> for this <strong>state transition</strong>. </p> </dd> </dl> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-timeout_action').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-timeout_action').style.visibility = 'hidden';">  <code>timeout_action() = <br id="type-timeout_action">    (Time :: <span><a href="#type-event_timeout">event_timeout()</a></span>) |<br>    {timeout, Time :: <span><a href="#type-event_timeout">event_timeout()</a></span>, EventContent :: term()} |<br>    {timeout,<br>     Time :: <span><a href="#type-event_timeout">event_timeout()</a></span>,<br>     EventContent :: term(),<br>     Options :: <span><a href="#type-timeout_option">timeout_option()</a></span> | [<span><a href="#type-timeout_option">timeout_option()</a></span>]} |<br>    {{timeout, Name :: term()},<br>     Time :: <span><a href="#type-generic_timeout">generic_timeout()</a></span>,<br>     EventContent :: term()} |<br>    {{timeout, Name :: term()},<br>     Time :: <span><a href="#type-generic_timeout">generic_timeout()</a></span>,<br>     EventContent :: term(),<br>     Options :: <span><a href="#type-timeout_option">timeout_option()</a></span> | [<span><a href="#type-timeout_option">timeout_option()</a></span>]} |<br>    {state_timeout,<br>     Time :: <span><a href="#type-state_timeout">state_timeout()</a></span>,<br>     EventContent :: term()} |<br>    {state_timeout,<br>     Time :: <span><a href="#type-state_timeout">state_timeout()</a></span>,<br>     EventContent :: term(),<br>     Options :: <span><a href="#type-timeout_option">timeout_option()</a></span> | [<span><a href="#type-timeout_option">timeout_option()</a></span>]} |<br>    <span><a href="#type-timeout_cancel_action">timeout_cancel_action()</a></span> |<br>    <span><a href="#type-timeout_update_action">timeout_update_action()</a></span></code><br> </div> <div class="data-type-desc">

<p> These <strong>transition actions</strong> can be invoked by returning them from the <code><a href="#state%20callback"><strong>state callback</strong></a></code>, from <code><a href="#Module:init-1"><span class="code">Module:init/1</span></a></code> or by giving them to <code><a href="#enter_loop-5"><span class="code">enter_loop/5,6</span></a></code>. </p> <p> These time-out actions sets time-out <code><a href="#type-transition_option">transition options</a></code>. </p> <dl> <dt><strong><code class="code">Time</code></strong></dt> <dd> <p> Short for <code class="code">{timeout,Time,Time}</code>, that is, the time-out message is the time-out time. This form exists to make the <code><a href="#state%20callback"><strong>state callback</strong></a></code> return value <code class="code">{next_state,NextState,NewData,Time}</code> allowed like for <code class="code">gen_fsm</code>. </p> </dd> <dt><strong><code class="code">timeout</code></strong></dt> <dd> <p> Sets the <code><a href="#type-transition_option"><span class="code">transition_option()</span></a></code> <code><a href="#type-event_timeout"><span class="code">event_timeout()</span></a></code> to <code class="code">Time</code> with <code class="code">EventContent</code> and time-out options <code><a href="#type-timeout_option"><span class="code">Options</span></a></code>. </p> </dd> <dt><strong><code class="code">{timeout,Name}</code></strong></dt> <dd> <p> Sets the <code><a href="#type-transition_option"><span class="code">transition_option()</span></a></code> <code><a href="#type-generic_timeout"><span class="code">generic_timeout()</span></a></code> to <code class="code">Time</code> for <code class="code">Name</code> with <code class="code">EventContent</code> and time-out options <code><a href="#type-timeout_option"><span class="code">Options</span></a></code>. </p> </dd> <dt><strong><code class="code">state_timeout</code></strong></dt> <dd> <p> Sets the <code><a href="#type-transition_option"><span class="code">transition_option()</span></a></code> <code><a href="#type-state_timeout"><span class="code">state_timeout()</span></a></code> to <code class="code">Time</code> with <code class="code">EventContent</code> and time-out options <code><a href="#type-timeout_option"><span class="code">Options</span></a></code>. </p> </dd> </dl> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-timeout_cancel_action').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-timeout_cancel_action').style.visibility = 'hidden';">  <code>timeout_cancel_action() = <br id="type-timeout_cancel_action">    {timeout, cancel} |<br>    {{timeout, Name :: term()}, cancel} |<br>    {state_timeout, cancel}</code><br> </div> <div class="data-type-desc">

<p> This is a shorter and clearer form of <code><a href="#type-timeout_action"> timeout_action() </a></code> with <code class="code">Time = infinity</code> which cancels a time-out. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-timeout_update_action').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-timeout_update_action').style.visibility = 'hidden';">  <code>timeout_update_action() = <br id="type-timeout_update_action">    {timeout, update, EventContent :: term()} |<br>    {{timeout, Name :: term()}, update, EventContent :: term()} |<br>    {state_timeout, update, EventContent :: term()}</code><br> </div> <div class="data-type-desc">

<p> Updates a time-out with a new <code class="code">EventContent</code>. See <code><a href="#type-timeout_action"> timeout_action() </a></code> for how to start a time-out. </p> <p> If no time-out of the same type is active instead insert the time-out event just like when starting a time-out with relative <code class="code">Time = 0</code>. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-reply_action').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-reply_action').style.visibility = 'hidden';">  <code>reply_action() = {reply, From :: <span id="type-reply_action"><a href="#type-from">from()</a></span>, Reply :: term()}</code><br> </div> <div class="data-type-desc">

<p> This <strong>transition action</strong> can be invoked by returning it from the <code><a href="#state%20callback"><strong>state callback</strong></a></code>, from <code><a href="#Module:init-1"><span class="code">Module:init/1</span></a></code> or by giving it to <code><a href="#enter_loop-5"><span class="code">enter_loop/5,6</span></a></code>. </p> <p> It does not set any <code><a href="#type-transition_option"> <span class="code">transition_option()</span> </a></code> but instead replies to a caller waiting for a reply in <code><a href="#call-2"><span class="code">call/2</span></a></code>. <code class="code">From</code> must be the term from argument <code><a href="#type-event_type"><span class="code">{call,From}</span></a></code> in a call to a <code><a href="#state%20callback"><strong>state callback</strong></a></code>. </p> <p> Note that using this action from <code><a href="#Module:init-1"><span class="code">Module:init/1</span></a></code> or <code><a href="#enter_loop-5"><span class="code">enter_loop/5,6</span></a></code> would be weird on the border of witchcraft since there has been no earlier call to a <code><a href="#state%20callback"><strong>state callback</strong></a></code> in this server. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-init_result').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-init_result').style.visibility = 'hidden';">  <code>init_result(StateType) = <br id="type-init_result">    {ok, State :: StateType, Data :: <span><a href="#type-data">data()</a></span>} |<br>    {ok,<br>     State :: StateType,<br>     Data :: <span><a href="#type-data">data()</a></span>,<br>     Actions :: [<span><a href="#type-action">action()</a></span>] | <span><a href="#type-action">action()</a></span>} |<br>    ignore |<br>    {stop, Reason :: term()}</code><br> </div> <div class="data-type-desc">

<p> For a succesful initialization, <code class="code">State</code> is the initial <code><a href="#type-state"><span class="code">state()</span></a></code> and <code class="code">Data</code> the initial server <code><a href="#type-data"><span class="code">data()</span></a></code> of the <code class="code">gen_statem</code>. </p> <p> The <code><a href="#type-action"><span class="code">Actions</span></a></code> are executed when entering the first <code><a href="#type-state">state</a></code> just as for a <code><a href="#state%20callback"><strong>state callback</strong></a></code>, except that the action <code class="code">postpone</code> is forced to <code class="code">false</code> since there is no event to postpone. </p> <p> For an unsuccesful initialization, <code class="code">{stop,Reason}</code> or <code class="code">ignore</code> should be used; see <code><a href="#start_link-3"><span class="code">start_link/3,4</span></a></code>. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-state_enter_result').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-state_enter_result').style.visibility = 'hidden';">  <code>state_enter_result(State) = <br id="type-state_enter_result">    {next_state, State, NewData :: <span><a href="#type-data">data()</a></span>} |<br>    {next_state, State,<br>     NewData :: <span><a href="#type-data">data()</a></span>,<br>     Actions :: [<span><a href="#type-enter_action">enter_action()</a></span>] | <span><a href="#type-enter_action">enter_action()</a></span>} |<br>    <span><a href="#type-state_callback_result">state_callback_result</a></span>(<span><a href="#type-enter_action">enter_action()</a></span>)</code><br> </div> <div class="data-type-desc">

<p> <code class="code">State</code> is the current state and it cannot be changed since the state callback was called with a <code><a href="#type-state_enter"><strong>state enter call</strong></a></code>. </p> <dl> <dt><strong><code class="code">next_state</code></strong></dt> <dd> <p> The <code class="code">gen_statem</code> does a state transition to <code class="code">State</code>, which has to be the current state, sets <code class="code">NewData</code>, and executes all <code class="code">Actions</code>. </p> </dd> </dl> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-event_handler_result').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-event_handler_result').style.visibility = 'hidden';">  <code>event_handler_result(StateType) = <br id="type-event_handler_result">    {next_state, NextState :: StateType, NewData :: <span><a href="#type-data">data()</a></span>} |<br>    {next_state,<br>     NextState :: StateType,<br>     NewData :: <span><a href="#type-data">data()</a></span>,<br>     Actions :: [<span><a href="#type-action">action()</a></span>] | <span><a href="#type-action">action()</a></span>} |<br>    <span><a href="#type-state_callback_result">state_callback_result</a></span>(<span><a href="#type-action">action()</a></span>)</code><br> </div> <div class="data-type-desc">

<p> <code class="code">StateType</code> is <code><a href="#type-state_name"><span class="code">state_name()</span></a></code> if <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> is <code class="code">state_functions</code>, or <code><a href="#type-state"><span class="code">state()</span></a></code> if <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> is <code class="code">handle_event_function</code>. </p> <dl> <dt><strong><code class="code">next_state</code></strong></dt> <dd> <p> The <code class="code">gen_statem</code> does a <strong>state transition</strong> to <code class="code">NextState</code> (which can be the same as the current state), sets <code class="code">NewData</code>, and executes all <code class="code">Actions</code>. If <code class="code">NextState =/= CurrentState</code> the <strong>state transition</strong> is a <strong>state change</strong>. </p> </dd> </dl> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-state_callback_result').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-state_callback_result').style.visibility = 'hidden';">  <code>state_callback_result(ActionType) = <br id="type-state_callback_result">    {keep_state, NewData :: <span><a href="#type-data">data()</a></span>} |<br>    {keep_state,<br>     NewData :: <span><a href="#type-data">data()</a></span>,<br>     Actions :: [ActionType] | ActionType} |<br>    keep_state_and_data |<br>    {keep_state_and_data, Actions :: [ActionType] | ActionType} |<br>    {repeat_state, NewData :: <span><a href="#type-data">data()</a></span>} |<br>    {repeat_state,<br>     NewData :: <span><a href="#type-data">data()</a></span>,<br>     Actions :: [ActionType] | ActionType} |<br>    repeat_state_and_data |<br>    {repeat_state_and_data, Actions :: [ActionType] | ActionType} |<br>    stop |<br>    {stop, Reason :: term()} |<br>    {stop, Reason :: term(), NewData :: <span><a href="#type-data">data()</a></span>} |<br>    {stop_and_reply,<br>     Reason :: term(),<br>     Replies :: [<span><a href="#type-reply_action">reply_action()</a></span>] | <span><a href="#type-reply_action">reply_action()</a></span>} |<br>    {stop_and_reply,<br>     Reason :: term(),<br>     Replies :: [<span><a href="#type-reply_action">reply_action()</a></span>] | <span><a href="#type-reply_action">reply_action()</a></span>,<br>     NewData :: <span><a href="#type-data">data()</a></span>}</code><br> </div> <div class="data-type-desc">

<p> <code class="code">ActionType</code> is <code><a href="#type-enter_action"><span class="code">enter_action()</span></a></code> if the state callback was called with a <code><a href="#type-state_enter"><strong>state enter call</strong></a></code> and <code><a href="#type-action"><span class="code">action()</span></a></code> if the state callback was called with an event. </p> <dl> <dt><strong><code class="code">keep_state</code></strong></dt> <dd> <p> The same as <code class="code">{next_state,CurrentState,NewData,Actions}</code>. </p> </dd> <dt><strong><code class="code">keep_state_and_data</code></strong></dt> <dd> <p> The same as <code class="code">{keep_state,CurrentData,Actions}</code>. </p> </dd> <dt><strong><code class="code">repeat_state</code></strong></dt> <dd> <p> If the <code class="code">gen_statem</code> runs with <code><a href="#type-state_enter"><strong>state enter calls</strong></a></code>, the <strong>state enter call</strong> is repeated, see type <code><a href="#type-transition_option"><span class="code">transition_option()</span></a></code>, other than that <code class="code">repeat_state</code> is the same as <code class="code">keep_state</code>. </p> </dd> <dt><strong><code class="code">repeat_state_and_data</code></strong></dt> <dd> <p> The same as <code class="code">{repeat_state,CurrentData,Actions}</code>. </p> </dd> <dt><strong><code class="code">stop</code></strong></dt> <dd> <p> Terminates the <code class="code">gen_statem</code> by calling <code><a href="#Module:terminate-3"><span class="code">Module:terminate/3</span></a></code> with <code class="code">Reason</code> and <code class="code">NewData</code>, if specified. An exit signal with this reason is sent to linked processes and ports. The default <code class="code">Reason</code> is <code class="code">normal</code>. </p> </dd> <dt><strong><code class="code">stop_and_reply</code></strong></dt> <dd> <p> Sends all <code class="code">Replies</code>, then terminates the <code class="code">gen_statem</code> by calling <code><a href="#Module:terminate-3"><span class="code">Module:terminate/3</span></a></code> with <code class="code">Reason</code> and <code class="code">NewData</code>, if specified. An exit signal with this reason is sent to linked processes and ports. </p> </dd> </dl> <p> All these terms are tuples or atoms and this property will hold in any future version of <code class="code">gen_statem</code>. </p> </div> </div> <div class="data-types-body"> <div class="data-type-name" onmouseover="document.getElementById('ghlink-type-request_id').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-request_id').style.visibility = 'hidden';">  <code id="type-request_id">request_id() = term()</code><br> </div> <div class="data-type-desc">

<p> A request handle, see <code><a href="#send_request-2"> <span class="code">send_request/2</span> </a></code> for details. </p> </div> </div> </div> <div class="innertube"><h2><span onmouseover="document.getElementById('ghlink-exports-idm15025').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-exports-idm15025').style.visibility = 'hidden';">Exports</span></h2></div> <div class="exports-body"> <table class="func-table" id="call-2"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-call-2-idp570').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-call-2-idp570').style.visibility = 'hidden';"> call(ServerRef :: <code><a href="#type-server_ref">server_ref()</a></code>, Request :: term()) -&gt;<br> Reply :: term()</div></td> <td class="func-since-td"><span class="since">OTP 19.0</span></td> </tr></table> <table class="func-table" id="call-3"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-call-3-idp571').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-call-3-idp571').style.visibility = 'hidden';"> call(ServerRef :: <code><a href="#type-server_ref">server_ref()</a></code>,<br> Request :: term(),<br> Timeout ::<br> timeout() |<br> {clean_timeout, T :: timeout()} |<br> {dirty_timeout, T :: timeout()}) -&gt;<br> Reply :: term()</div></td> <td class="func-since-td"><span class="since">OTP 19.0</span></td> </tr></table> <div class="exports-tube">

<p> Makes a synchronous call to the <code class="code">gen_statem</code> <code><a href="#type-server_ref"><span class="code">ServerRef</span></a></code> by sending a request and waiting until its reply arrives. The <code class="code">gen_statem</code> calls the <code><a href="#state%20callback"><strong>state callback</strong></a></code> with <code><a href="#type-event_type"><span class="code">event_type()</span></a></code> <code class="code">{call,From}</code> and event content <code class="code">Request</code>. </p> <p> A <code class="code">Reply</code> is generated when a <code><a href="#state%20callback"><strong>state callback</strong></a></code> returns with <code class="code">{reply,From,Reply}</code> as one <code><a href="#type-action"><span class="code">action()</span></a></code>, and that <code class="code">Reply</code> becomes the return value of this function. </p> <p> <code class="code">Timeout</code> is an integer &gt; 0, which specifies how many milliseconds to wait for a reply, or the atom <code class="code">infinity</code> to wait indefinitely, which is the default. If no reply is received within the specified time, the function call fails. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> For <code class="code">Timeout &lt; infinity</code>, to avoid getting a late reply in the caller's inbox if the caller should catch exceptions, this function spawns a proxy process that does the call. A late reply gets delivered to the dead proxy process, hence gets discarded. This is less efficient than using <code class="code">Timeout == infinity</code>. </p> </div> </div> <p> <code class="code">Timeout</code> can also be a tuple <code class="code">{clean_timeout,T}</code> or <code class="code">{dirty_timeout,T}</code>, where <code class="code">T</code> is the time-out time. <code class="code">{clean_timeout,T}</code> works like just <code class="code">T</code> described in the note above and uses a proxy process while <code class="code">{dirty_timeout,T}</code> bypasses the proxy process which is more lightweight. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> If you combine catching exceptions from this function with <code class="code">{dirty_timeout,T}</code> to avoid that the calling process dies when the call times out, you will have to be prepared to handle a late reply. Note that there is an odd chance to get a late reply even with <code class="code">{dirty_timeout,infinity}</code> or <code class="code">infinity</code> for example in the event of network problems. So why not just let the calling process die by not catching the exception? </p> </div> </div> <p> The call can also fail, for example, if the <code class="code">gen_statem</code> dies before or during this function call. </p> </div> <table class="func-table" id="cast-2"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-cast-2-idp572').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-cast-2-idp572').style.visibility = 'hidden';"> cast(ServerRef :: <code><a href="#type-server_ref">server_ref()</a></code>, Msg :: term()) -&gt; ok</div></td> <td class="func-since-td"><span class="since">OTP 19.0</span></td> </tr></table> <div class="exports-tube">

<p> Sends an asynchronous event to the <code class="code">gen_statem</code> <code><a href="#type-server_ref"><span class="code">ServerRef</span></a></code> and returns <code class="code">ok</code> immediately, ignoring if the destination node or <code class="code">gen_statem</code> does not exist. The <code class="code">gen_statem</code> calls the <code><a href="#state%20callback"><strong>state callback</strong></a></code> with <code><a href="#type-event_type"><span class="code">event_type()</span></a></code> <code class="code">cast</code> and event content <code class="code">Msg</code>. </p> </div> <table class="func-table" id="check_response-2"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-check_response-2-idp573').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-check_response-2-idp573').style.visibility = 'hidden';"> check_response(Msg :: term(), RequestId :: <code><a href="#type-request_id">request_id()</a></code>) -&gt;<br> {reply, Reply :: term()} |<br> no_reply |<br> {error, {term(), <code><a href="#type-server_ref">server_ref()</a></code>}}</div></td> <td class="func-since-td"><span class="since">OTP-23</span></td> </tr></table> <div class="exports-tube">

<p> This function is used to check if a previously received message, for example by <code class="code">receive</code> or <code class="code">handle_info/2</code>, is a result of a request made with <code><a href="#send_request-2"><span class="code">send_request/2</span></a></code>. If <code class="code">Msg</code> is a reply to the handle <code class="code">RequestId</code> the result of the request is returned in <code class="code">Reply</code>. Otherwise returns <code class="code">no_reply</code> and no cleanup is done, and thus the function shall be invoked repeatedly until a reply is returned. </p> <p> The return value <code class="code">Reply</code> is generated when a <code><a href="#state%20callback"><strong>state callback</strong></a></code> returns with <code class="code">{reply,From,Reply}</code> as one <code><a href="#type-action"><span class="code">action()</span></a></code>, and that <code class="code">Reply</code> becomes the return value of this function. </p> <p> The function returns an error if the <code class="code">gen_statem</code> dies before or during this request. </p> </div> <table class="func-table" id="enter_loop-4"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-enter_loop-4-idp574').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-enter_loop-4-idp574').style.visibility = 'hidden';"> enter_loop(Module :: module(),<br> Opts :: [<code><a href="#type-enter_loop_opt">enter_loop_opt()</a></code>],<br> State :: <code><a href="#type-state">state()</a></code>,<br> Data :: <code><a href="#type-data">data()</a></code>) -&gt;<br> no_return()</div></td> <td class="func-since-td"><span class="since">OTP 19.1</span></td> </tr></table> <div class="exports-tube">

<p> The same as <code><a href="#enter_loop-6"><span class="code">enter_loop/6</span></a></code> with <code class="code">Actions = []</code> except that no <code><a href="#type-server_name"><span class="code">server_name()</span></a></code> must have been registered. This creates an anonymous server. </p> </div> <table class="func-table" id="enter_loop-5"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-enter_loop-5-idp575').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-enter_loop-5-idp575').style.visibility = 'hidden';"> enter_loop(Module :: module(),<br> Opts :: [<code><a href="#type-enter_loop_opt">enter_loop_opt()</a></code>],<br> State :: <code><a href="#type-state">state()</a></code>,<br> Data :: <code><a href="#type-data">data()</a></code>,<br> Server_or_Actions :: <code><a href="#type-server_name">server_name()</a></code> | pid() | [<code><a href="#type-action">action()</a></code>]) -&gt;<br> no_return()</div></td> <td class="func-since-td"><span class="since">OTP 19.0</span></td> </tr></table> <div class="exports-tube">

<p> If <code class="code">Server_or_Actions</code> is a <code class="code">list()</code>, the same as <code><a href="#enter_loop-6"><span class="code">enter_loop/6</span></a></code> except that no <code><a href="#type-server_name"><span class="code">server_name()</span></a></code> must have been registered and <code class="code">Actions = Server_or_Actions</code>. This creates an anonymous server. </p> <p> Otherwise the same as <code><a href="#enter_loop-6"><span class="code">enter_loop/6</span></a></code> with <code class="code">Server = Server_or_Actions</code> and <code class="code">Actions = []</code>. </p> </div> <table class="func-table" id="enter_loop-6"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-enter_loop-6-idp576').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-enter_loop-6-idp576').style.visibility = 'hidden';"> enter_loop(Module :: module(),<br> Opts :: [<code><a href="#type-enter_loop_opt">enter_loop_opt()</a></code>],<br> State :: <code><a href="#type-state">state()</a></code>,<br> Data :: <code><a href="#type-data">data()</a></code>,<br> Server :: <code><a href="#type-server_name">server_name()</a></code> | pid(),<br> Actions :: [<code><a href="#type-action">action()</a></code>] | <code><a href="#type-action">action()</a></code>) -&gt;<br> no_return()</div></td> <td class="func-since-td"><span class="since">OTP 19.0</span></td> </tr></table> <div class="exports-tube">

<p> Makes the calling process become a <code class="code">gen_statem</code>. Does not return, instead the calling process enters the <code class="code">gen_statem</code> receive loop and becomes a <code class="code">gen_statem</code> server. The process <strong>must</strong> have been started using one of the start functions in <code><a href="proc_lib"><span class="code">proc_lib</span></a></code>. The user is responsible for any initialization of the process, including registering a name for it. </p> <p> This function is useful when a more complex initialization procedure is needed than the <code class="code">gen_statem</code> behavior provides. </p> <p> <code class="code">Module</code>, <code class="code">Opts</code> have the same meaning as when calling <code><a href="#start_link-3"><span class="code">start[_link|_monitor]/3,4</span></a></code>. </p> <p> If <code class="code">Server</code> is <code class="code">self()</code> an anonymous server is created just as when using <code><a href="#start_link-3"><span class="code">start[_link|_monitor]/3</span></a></code>. If <code class="code">Server</code> is a <code><a href="#type-server_name"><span class="code">server_name()</span></a></code> a named server is created just as when using <code><a href="#start_link-4"><span class="code">start[_link|_monitor]/4</span></a></code>. However, the <code><a href="#type-server_name"><span class="code">server_name()</span></a></code> name must have been registered accordingly <strong>before</strong> this function is called. </p> <p> <code class="code">State</code>, <code class="code">Data</code>, and <code class="code">Actions</code> have the same meanings as in the return value of <code><a href="#Module:init-1"><span class="code">Module:init/1</span></a></code>. Also, the callback module does not need to export a <code><a href="#Module:init-1"><span class="code">Module:init/1</span></a></code> function. </p> <p> The function fails if the calling process was not started by a <code><a href="proc_lib"><span class="code">proc_lib</span></a></code> start function, or if it is not registered according to <code><a href="#type-server_name"><span class="code">server_name()</span></a></code>. </p> </div> <table class="func-table" id="receive_response-1"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-receive_response-1-idp577').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-receive_response-1-idp577').style.visibility = 'hidden';"> receive_response(RequestId :: <code><a href="#type-request_id">request_id()</a></code>) -&gt;<br> {reply, Reply :: term()} |<br> {error, {term(), <code><a href="#type-server_ref">server_ref()</a></code>}}</div></td> <td class="func-since-td"><span class="since">OTP 24.0</span></td> </tr></table> <table class="func-table" id="receive_response-2"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-receive_response-2-idp578').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-receive_response-2-idp578').style.visibility = 'hidden';"> receive_response(RequestId :: <code><a href="#type-request_id">request_id()</a></code>, Timeout :: timeout()) -&gt;<br> {reply, Reply :: term()} |<br> timeout |<br> {error, {term(), <code><a href="#type-server_ref">server_ref()</a></code>}}</div></td> <td class="func-since-td"><span class="since">OTP 24.0</span></td> </tr></table> <div class="exports-tube">

<p> This function is used to receive for a reply of a request made with <code><a href="#send_request-2"><span class="code">send_request/2</span></a></code> to the <code class="code">gen_statem</code> process. This function must be called from the same process from which <code><a href="#send_request-2"><span class="code">send_request/2</span></a></code> was made. </p> <p> <code class="code">Timeout</code> is an integer greater then or equal to zero that specifies how many milliseconds to wait for an reply, or the atom <code class="code">infinity</code> to wait indefinitely. Defaults to <code class="code">infinity</code>. If no reply is received within the specified time, the function returns <code class="code">timeout</code>. Assuming that the server executes on a node supporting aliases (introduced in OTP 24) no response will be received after a timeout. Otherwise, a garbage response might be received at a later time. </p> <p> The return value <code class="code">Reply</code> is generated when a <code><a href="#state%20callback"><strong>state callback</strong></a></code> returns with <code class="code">{reply,From,Reply}</code> as one <code><a href="#type-action"><span class="code">action()</span></a></code>, and that <code class="code">Reply</code> becomes the return value of this function. </p> <p> The function returns an error if the <code class="code">gen_statem</code> dies before or during this function call. </p> <p> The difference between <code><a href="#wait_response-2"><span class="code">wait_response()</span></a></code> and <code class="code">receive_response()</code> is that <code class="code">receive_response()</code> abandons the request at timeout so that a potential future response is ignored, while <code class="code">wait_response()</code> does not. </p> </div> <table class="func-table" id="reply-1"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-reply-1-idp579').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-reply-1-idp579').style.visibility = 'hidden';"> reply(Replies :: [<code><a href="#type-reply_action">reply_action()</a></code>] | <code><a href="#type-reply_action">reply_action()</a></code>) -&gt; ok</div></td> <td class="func-since-td"><span class="since">OTP 19.0</span></td> </tr></table> <table class="func-table" id="reply-2"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-reply-2-idp580').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-reply-2-idp580').style.visibility = 'hidden';"> reply(From :: <code><a href="#type-from">from()</a></code>, Reply :: term()) -&gt; ok</div></td> <td class="func-since-td"><span class="since">OTP 19.0</span></td> </tr></table> <div class="exports-tube">

<p> This function can be used by a <code class="code">gen_statem</code> to explicitly send a reply to a process that waits in <code><a href="#call-2"><span class="code">call/2</span></a></code> when the reply cannot be defined in the return value of a <code><a href="#state%20callback"><strong>state callback</strong></a></code>. </p> <p> <code class="code">From</code> must be the term from argument <code><a href="#type-event_type"><span class="code">{call,From}</span></a></code> to the <code><a href="#state%20callback"><strong>state callback</strong></a></code>. A reply or multiple replies canalso be sent using one or several <code><a href="#type-reply_action"><span class="code">reply_action()</span></a></code>s from a <code><a href="#state%20callback"><strong>state callback</strong></a></code>. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> A reply sent with this function is not visible in <code><a href="sys"><span class="code">sys</span></a></code> debug output. </p> </div> </div> </div> <table class="func-table" id="send_request-2"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-send_request-2-idp581').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-send_request-2-idp581').style.visibility = 'hidden';"> send_request(ServerRef :: <code><a href="#type-server_ref">server_ref()</a></code>, Request :: term()) -&gt;<br> RequestId :: <code><a href="#type-request_id">request_id()</a></code> </div></td> <td class="func-since-td"><span class="since">OTP-23</span></td> </tr></table> <div class="exports-tube">

<p> Sends a request to the <code class="code">gen_statem</code> <code><a href="#type-server_ref"><span class="code">ServerRef</span></a></code> and returns a handle <code class="code">RequestId</code>. </p> <p> The return value <code class="code">RequestId</code> shall later be used with <code><a href="#receive_response-2"> <span class="code">receive_response/1,2</span></a></code>, <code><a href="#wait_response-2"> <span class="code">wait_response/1,2</span></a></code>, or <code><a href="#check_response-2"> <span class="code">check_response/2</span></a></code> to fetch the actual result of the request. </p> <p> The call <code class="code">gen_statem:wait_response(gen_statem:send_request(ServerRef,Request), Timeout)</code> can be seen as equivalent to <code><a href="#call-3"><span class="code">gen_statem:call(Server,Request,Timeout)</span></a></code>, ignoring the error handling. </p> <p> The <code class="code">gen_statem</code> calls the <code><a href="#state%20callback"><strong>state callback</strong></a></code> with <code><a href="#type-event_type"><span class="code">event_type()</span></a></code> <code class="code">{call,From}</code> and event content <code class="code">Request</code>. </p> <p> A <code class="code">Reply</code> is generated when a <code><a href="#state%20callback"><strong>state callback</strong></a></code> returns with <code class="code">{reply,From,Reply}</code> as one <code><a href="#type-action"><span class="code">action()</span></a></code>, and that <code class="code">Reply</code> becomes the return value of <code><a href="#receive_response-2"> <span class="code">receive_response/1,2</span></a></code>, <code><a href="#wait_response-2"> <span class="code">wait_response/1,2</span></a></code>, or <code><a href="#check_response-2"> <span class="code">check_response/2</span></a></code> function. </p> </div> <table class="func-table" id="start-3"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-start-3-idp582').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-start-3-idp582').style.visibility = 'hidden';"> start(Module :: module(), Args :: term(), Opts :: [<code><a href="#type-start_opt">start_opt()</a></code>]) -&gt;<br> <code><a href="#type-start_ret">start_ret()</a></code> </div></td> <td class="func-since-td"><span class="since">OTP 19.0</span></td> </tr></table> <table class="func-table" id="start-4"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-start-4-idp583').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-start-4-idp583').style.visibility = 'hidden';"> start(ServerName :: <code><a href="#type-server_name">server_name()</a></code>,<br> Module :: module(),<br> Args :: term(),<br> Opts :: [<code><a href="#type-start_opt">start_opt()</a></code>]) -&gt;<br> <code><a href="#type-start_ret">start_ret()</a></code> </div></td> <td class="func-since-td"><span class="since">OTP 19.0</span></td> </tr></table> <div class="exports-tube">

<p> Creates a standalone <code class="code">gen_statem</code> process according to OTP design principles (using <code><a href="proc_lib"><span class="code">proc_lib</span></a></code> primitives). As it does not get linked to the calling process, this start function cannot be used by a supervisor to start a child. </p> <p> For a description of arguments and return values, see <code><a href="#start_link-3"><span class="code">start_link/3,4</span></a></code>. </p> </div> <table class="func-table" id="start_link-3"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-start_link-3-idp584').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-start_link-3-idp584').style.visibility = 'hidden';"> start_link(Module :: module(),<br> Args :: term(),<br> Opts :: [<code><a href="#type-start_opt">start_opt()</a></code>]) -&gt;<br> <code><a href="#type-start_ret">start_ret()</a></code> </div></td> <td class="func-since-td"><span class="since">OTP 19.0</span></td> </tr></table> <table class="func-table" id="start_link-4"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-start_link-4-idp585').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-start_link-4-idp585').style.visibility = 'hidden';"> start_link(ServerName :: <code><a href="#type-server_name">server_name()</a></code>,<br> Module :: module(),<br> Args :: term(),<br> Opts :: [<code><a href="#type-start_opt">start_opt()</a></code>]) -&gt;<br> <code><a href="#type-start_ret">start_ret()</a></code> </div></td> <td class="func-since-td"><span class="since">OTP 19.0</span></td> </tr></table> <div class="exports-tube">

<p> Creates a <code class="code">gen_statem</code> process according to OTP design principles (using <code><a href="proc_lib"><span class="code">proc_lib</span></a></code> primitives) that is linked to the calling process. This is essential when the <code class="code">gen_statem</code> must be part of a supervision tree so it gets linked to its supervisor. </p> <p> The <code class="code">gen_statem</code> process calls <code><a href="#Module:init-1"><span class="code">Module:init/1</span></a></code> to initialize the server. To ensure a synchronized startup procedure, <code class="code">start_link/3,4</code> does not return until <code><a href="#Module:init-1"><span class="code">Module:init/1</span></a></code> has returned. </p> <p> <code class="code">ServerName</code> specifies the <code><a href="#type-server_name"><span class="code">server_name()</span></a></code> to register for the <code class="code">gen_statem</code>. If the <code class="code">gen_statem</code> is started with <code class="code">start_link/3</code>, no <code class="code">ServerName</code> is provided and the <code class="code">gen_statem</code> is not registered. </p> <p><code class="code">Module</code> is the name of the callback module.</p> <p> <code class="code">Args</code> is an arbitrary term that is passed as the argument to <code><a href="#Module:init-1"><span class="code">Module:init/1</span></a></code>. </p> <ul> <li> <p> If option <code><a href="#type-start_opt"> <span class="code">{timeout,Time}</span> </a></code> is present in <code class="code">Opts</code>, the <code class="code">gen_statem</code> is allowed to spend <code class="code">Time</code> milliseconds initializing or it terminates and the start function returns <code><a href="#type-start_ret"><span class="code">{error,timeout}</span></a></code>. </p> </li> <li> <p>If option <code><a href="#type-enter_loop_opt"> <span class="code">{hibernate_after,HibernateAfterTimeout}</span> </a></code> is present, the <code class="code">gen_statem</code> process awaits any message for <code class="code">HibernateAfterTimeout</code> milliseconds and if no message is received, the process goes into hibernation automatically (by calling <code><a href="proc_lib#hibernate-3"><span class="code">proc_lib:hibernate/3</span></a></code>). </p> </li> <li> <p> If option <code><a href="#type-enter_loop_opt"> <span class="code">{debug,Dbgs}</span> </a></code> is present in <code class="code">Opts</code>, debugging through <code><a href="sys"><span class="code">sys</span></a></code> is activated. </p> </li> <li> <p> If option <code><a href="#type-start_opt"> <span class="code">{spawn_opt,SpawnOpts}</span> </a></code> is present in <code class="code">Opts</code>, <code class="code">SpawnOpts</code> is passed as option list to <code><span class="code">erlang:spawn_opt/2</span></code>, which is used to spawn the <code class="code">gen_statem</code> process. </p> </li> </ul> <div class="note"> <div class="label">Note</div> <div class="content">

<p> Using spawn option <code class="code">monitor</code> is not allowed, it causes this function to fail with reason <code class="code">badarg</code>. </p> </div> </div> <p> If the <code class="code">gen_statem</code> is successfully created and initialized, this function returns <code><a href="#type-start_ret"><span class="code">{ok,Pid}</span></a></code>, where <code class="code">Pid</code> is the <code class="code">pid()</code> of the <code class="code">gen_statem</code>. If a process with the specified <code class="code">ServerName</code> exists already, this function returns <code><a href="#type-start_ret"><span class="code">{error,{already_started,Pid}}</span></a></code>, where <code class="code">Pid</code> is the <code class="code">pid()</code> of that process. </p> <p> If <code class="code">Module:init/1</code> fails with <code class="code">Reason</code>, this function returns <code><a href="#type-start_ret"><span class="code">{error,Reason}</span></a></code>. If <code class="code">Module:init/1</code> returns <code><a href="#type-start_ret"><span class="code">{stop,Reason}</span></a></code> or <code><a href="#type-start_ret"><span class="code">ignore</span></a></code>, the process is terminated and this function returns <code><a href="#type-start_ret"><span class="code">{error,Reason}</span></a></code> or <code><a href="#type-start_ret"><span class="code">ignore</span></a></code>, respectively. An exit signal with the same <code class="code">Reason</code> (or <code class="code">normal</code> if <code class="code">Module:init/1</code> returns <code class="code">ignore</code>) is set to linked processes and ports, including the process calling <code class="code">start_link/3,4</code>. </p> </div> <table class="func-table" id="start_monitor-3"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-start_monitor-3-idp586').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-start_monitor-3-idp586').style.visibility = 'hidden';"> start_monitor(Module :: module(),<br> Args :: term(),<br> Opts :: [<code><a href="#type-start_opt">start_opt()</a></code>]) -&gt;<br> <code><a href="#type-start_mon_ret">start_mon_ret()</a></code> </div></td> <td class="func-since-td"><span class="since">OTP 23.0</span></td> </tr></table> <table class="func-table" id="start_monitor-4"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-start_monitor-4-idp587').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-start_monitor-4-idp587').style.visibility = 'hidden';"> start_monitor(ServerName :: <code><a href="#type-server_name">server_name()</a></code>,<br> Module :: module(),<br> Args :: term(),<br> Opts :: [<code><a href="#type-start_opt">start_opt()</a></code>]) -&gt;<br> <code><a href="#type-start_mon_ret">start_mon_ret()</a></code> </div></td> <td class="func-since-td"><span class="since">OTP 23.0</span></td> </tr></table> <div class="exports-tube">

<p> Creates a standalone <code class="code">gen_statem</code> process according to OTP design principles (using <code><a href="proc_lib"><span class="code">proc_lib</span></a></code> primitives) and atomically sets up a monitor to the newly created process. As it does not get linked to the calling process, this start function cannot be used by a supervisor to start a child. </p> <p> For a description of arguments and return values, see <code><a href="#start_link-3"><span class="code">start_link/3,4</span></a></code>. Note that the return value on successful start differs from <code class="code">start_link/3,4</code>. <code class="code">start_monitor/3,4</code> will return <code class="code">{ok,{Pid,Mon}}</code> where <code class="code">Pid</code> is the process identifier of the process, and <code class="code">Mon</code> is a reference to the monitor set up to monitor the process. If the start is not successful, the caller will be blocked until the <code class="code">DOWN</code> message has been received and removed from the message queue. </p> </div> <table class="func-table" id="stop-1"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-stop-1-idp588').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-stop-1-idp588').style.visibility = 'hidden';"> stop(ServerRef :: <code><a href="#type-server_ref">server_ref()</a></code>) -&gt; ok</div></td> <td class="func-since-td"><span class="since">OTP 19.0</span></td> </tr></table> <div class="exports-tube">

<p> The same as <code><a href="#stop-3"><span class="code">stop(ServerRef, normal, infinity)</span></a></code>. </p> </div> <table class="func-table" id="stop-3"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-stop-3-idp589').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-stop-3-idp589').style.visibility = 'hidden';"> stop(ServerRef :: <code><a href="#type-server_ref">server_ref()</a></code>,<br> Reason :: term(),<br> Timeout :: timeout()) -&gt;<br> ok</div></td> <td class="func-since-td"><span class="since">OTP 19.0</span></td> </tr></table> <div class="exports-tube">

<p> Orders the <code class="code">gen_statem</code> <code><a href="#type-server_ref"><span class="code">ServerRef</span></a></code> to exit with the specified <code class="code">Reason</code> and waits for it to terminate. The <code class="code">gen_statem</code> calls <code><a href="#Module:terminate-3"><span class="code">Module:terminate/3</span></a></code> before exiting. </p> <p> This function returns <code class="code">ok</code> if the server terminates with the expected reason. Any other reason than <code class="code">normal</code>, <code class="code">shutdown</code>, or <code class="code">{shutdown,Term}</code> causes an error report to be issued through <code><span class="code">logger(3)</span></code>. An exit signal with the same reason is sent to linked processes and ports. The default <code class="code">Reason</code> is <code class="code">normal</code>. </p> <p> <code class="code">Timeout</code> is an integer &gt; 0, which specifies how many milliseconds to wait for the server to terminate, or the atom <code class="code">infinity</code> to wait indefinitely. Defaults to <code class="code">infinity</code>. If the server does not terminate within the specified time, a <code class="code">timeout</code> exception is raised. </p> <p> If the process does not exist, a <code class="code">noproc</code> exception is raised. </p> </div> <table class="func-table" id="wait_response-1"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-wait_response-1-idp590').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-wait_response-1-idp590').style.visibility = 'hidden';"> wait_response(RequestId :: <code><a href="#type-request_id">request_id()</a></code>) -&gt;<br> {reply, Reply :: term()} |<br> {error, {term(), <code><a href="#type-server_ref">server_ref()</a></code>}}</div></td> <td class="func-since-td"><span class="since">OTP 23.0</span></td> </tr></table> <table class="func-table" id="wait_response-2"><tr class="func-tr"> <td class="func-td"><div onmouseover="document.getElementById('ghlink-wait_response-2-idp591').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-wait_response-2-idp591').style.visibility = 'hidden';"> wait_response(RequestId :: <code><a href="#type-request_id">request_id()</a></code>, Timeout :: timeout()) -&gt;<br> {reply, Reply :: term()} |<br> timeout |<br> {error, {term(), <code><a href="#type-server_ref">server_ref()</a></code>}}</div></td> <td class="func-since-td"><span class="since">OTP 23.0</span></td> </tr></table> <div class="exports-tube">

<p> This function is used to wait for a reply of a request made with <code><a href="#send_request-2"><span class="code">send_request/2</span></a></code> to the <code class="code">gen_statem</code> process. This function must be called from the same process from which <code><a href="#send_request-2"><span class="code">send_request/2</span></a></code> was made. </p> <p> <code class="code">Timeout</code> is an integer greater then or equal to zero that specifies how many milliseconds to wait for an reply, or the atom <code class="code">infinity</code> to wait indefinitely. Defaults to <code class="code">infinity</code>. If no reply is received within the specified time, the function returns <code class="code">timeout</code> and no cleanup is done, and thus the function can be invoked repeatedly until a reply is returned. </p> <p> The return value <code class="code">Reply</code> is generated when a <code><a href="#state%20callback"><strong>state callback</strong></a></code> returns with <code class="code">{reply,From,Reply}</code> as one <code><a href="#type-action"><span class="code">action()</span></a></code>, and that <code class="code">Reply</code> becomes the return value of this function. </p> <p> The function returns an error if the <code class="code">gen_statem</code> dies before or during this function call. </p> <p> The difference between <code><a href="#receive_response-2"><span class="code">receive_response()</span></a></code> and <code class="code">wait_response()</code> is that <code class="code">receive_response()</code> abandons the request at timeout so that a potential future response is ignored, while <code class="code">wait_response()</code> does not. </p> </div> </div> <div class="innertube"> <h2><span onmouseover="document.getElementById('ghlink-callback-functions-idm15546').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-callback-functions-idm15546').style.visibility = 'hidden';">Callback Functions</span></h2>  <p> The following functions are to be exported from a <code class="code">gen_statem</code> callback module. </p>  </div> <div class="innertube"><h2><span onmouseover="document.getElementById('ghlink-exports-idm15545').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-exports-idm15545').style.visibility = 'hidden';">Exports</span></h2></div> <div class="exports-body"> <table class="func-table"><tr class="func-tr"> <td class="func-td"><div><span onmouseover="document.getElementById('ghlink-Module:callback_mode-0-idm15551').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-Module:callback_mode-0-idm15551').style.visibility = 'hidden';" id="Module:callback_mode-0">Module:callback_mode() -&gt; CallbackMode</span></div></td> <td class="func-since-td"><span class="since">OTP 19.1</span></td> </tr></table> <div class="exports-tube">  <h2 class="func-types-title">Types</h2>   
<p> This function is called by a <code class="code">gen_statem</code> when it needs to find out the <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> of the callback module. The value is cached by <code class="code">gen_statem</code> for efficiency reasons, so this function is only called once after server start, after code change, and after changing the callback module, but before the first <code><a href="#state%20callback"><strong>state callback</strong></a></code> in the current callback module's code version is called. More occasions may be added in future versions of <code class="code">gen_statem</code>. </p> <p> Server start happens either when <code><a href="#Module:init-1"><span class="code">Module:init/1</span></a></code> returns or when <code><a href="#enter_loop-4"><span class="code">enter_loop/4-6</span></a></code> is called. Code change happens when <code><a href="#Module:code_change-4"><span class="code">Module:code_change/4</span></a></code> returns. A change of the callback module happens when a <code><a href="#state%20callback"><strong>state callback</strong></a></code> returns any of the actions <code><a href="#type-action"><span class="code">change_callback_module</span></a></code>, <code><a href="#type-action"><span class="code">push_callback_module</span></a></code> or <code><a href="#type-action"><span class="code">pop_callback_module</span></a></code>. </p> <p> The <code class="code">CallbackMode</code> is either just <code><a href="#type-callback_mode"><span class="code">callback_mode()</span></a></code> or a list containing <code><a href="#type-callback_mode"><span class="code">callback_mode()</span></a></code> and possibly the atom <code><a href="#type-state_enter"><span class="code">state_enter</span></a></code>. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> If this function's body does not return an inline constant value the callback module is doing something strange. </p> </div> </div>  </div> <table class="func-table"><tr class="func-tr"> <td class="func-td"><div><span onmouseover="document.getElementById('ghlink-Module:code_change-4-idm15593').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-Module:code_change-4-idm15593').style.visibility = 'hidden';" id="Module:code_change-4">Module:code_change(OldVsn, OldState, OldData, Extra) -&gt; Result </span></div></td> <td class="func-since-td"><span class="since">OTP 19.0</span></td> </tr></table> <div class="exports-tube">  <h2 class="func-types-title">Types</h2>          
<div class="note"> <div class="label">Note</div> <div class="content">

<p> This callback is optional, so callback modules need not export it. If a release upgrade/downgrade with <code class="code">Change = {advanced,Extra}</code> specified in the <code class="code">.appup</code> file is made when <code class="code">code_change/4</code> is not implemented the process will crash with exit reason <code class="code">undef</code>. </p> </div> </div> <p> This function is called by a <code class="code">gen_statem</code> when it is to update its internal state during a release upgrade/downgrade, that is, when the instruction <code class="code">{update,Module,Change,...}</code>, where <code class="code">Change = {advanced,Extra}</code>, is specified in the <code><span class="code">appup</span></code> file. For more information, see <code>OTP Design Principles</code>. </p> <p> For an upgrade, <code class="code">OldVsn</code> is <code class="code">Vsn</code>, and for a downgrade, <code class="code">OldVsn</code> is <code class="code">{down,Vsn}</code>. <code class="code">Vsn</code> is defined by the <code class="code">vsn</code> attribute(s) of the old version of the callback module <code class="code">Module</code>. If no such attribute is defined, the version is the checksum of the Beam file. </p> <p> <code class="code">OldState</code> and <code class="code">OldData</code> is the internal state of the <code class="code">gen_statem</code>. </p> <p> <code class="code">Extra</code> is passed "as is" from the <code class="code">{advanced,Extra}</code> part of the update instruction. </p> <p> If successful, the function must return the updated internal state in an <code class="code">{ok,NewState,NewData}</code> tuple. </p> <p> If the function returns a failure <code class="code">Reason</code>, the ongoing upgrade fails and rolls back to the old release. Note that <code class="code">Reason</code> cannot be an <code class="code">{ok,_,_}</code> tuple since that will be regarded as a <code class="code">{ok,NewState,NewData}</code> tuple, and that a tuple matching <code class="code">{ok,_}</code> is an also invalid failure <code class="code">Reason</code>. It is recommended to use an atom as <code class="code">Reason</code> since it will be wrapped in an <code class="code">{error,Reason}</code> tuple. </p> <p> Also note when upgrading a <code class="code">gen_statem</code>, this function and hence the <code class="code">Change = {advanced,Extra}</code> parameter in the <code><span class="code">appup</span></code> file is not only needed to update the internal state or to act on the <code class="code">Extra</code> argument. It is also needed if an upgrade or downgrade should change <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code>, or else the <strong>callback mode</strong> after the code change will not be honoured, most probably causing a server crash. </p> <p> If the server changes callback module using any of the actions <code><a href="#type-action"><span class="code">change_callback_module</span></a></code>, <code><a href="#type-action"><span class="code">push_callback_module</span></a></code> or <code><a href="#type-action"><span class="code">pop_callback_module</span></a></code>, be aware that it is always the current callback module that will get this callback call. That the current callback module handles the current state and data update should be no surprise, but it must be able to handle even parts of the state and data that it is not familiar with, somehow. </p> <p> In the supervisor <code>child specification</code> there is a list of modules which is recommended to contain only the callback module. For a <code class="code">gen_statem</code> with multiple callback modules there is no real need to list all of them, it may not even be possible since the list could change after code upgrade. If this list would contain only the start callback module, as recommended, what is important is to upgrade <strong>that</strong> module whenever a <strong>synchronized code replacement</strong> is done. Then the release handler concludes that an upgrade that upgrades <strong>that</strong> module needs to suspend, code change, and resume any server whose child specification declares that it is using <strong>that</strong> module. And again; the <strong>current</strong> callback module will get the <code class="code">Module:code_change/4</code> call. </p>  </div> <table class="func-table"><tr class="func-tr"> <td class="func-td"><div><span onmouseover="document.getElementById('ghlink-Module:init-1-idm15672').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-Module:init-1-idm15672').style.visibility = 'hidden';" id="Module:init-1">Module:init(Args) -&gt; Result(StateType)</span></div></td> <td class="func-since-td"><span class="since">OTP 19.0</span></td> </tr></table> <div class="exports-tube">  <h2 class="func-types-title">Types</h2>    
<p> Whenever a <code class="code">gen_statem</code> is started using <code><a href="#start_link-3"><span class="code">start_link/3,4</span></a></code>, <code><a href="#start_monitor-3"><span class="code">start_monitor/3,4</span></a></code>, or <code><a href="#start-3"><span class="code">start/3,4</span></a></code>, this function is called by the new process to initialize the implementation state and server data. </p> <p> <code class="code">Args</code> is the <code class="code">Args</code> argument provided to that start function. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> Note that if the <code class="code">gen_statem</code> is started through <code><a href="proc_lib"><span class="code">proc_lib</span></a></code> and <code><a href="#enter_loop-4"><span class="code">enter_loop/4-6</span></a></code>, this callback will never be called. Since this callback is not optional it can in that case be implemented as: </p> <pre data-language="erlang">
init(Args) -&gt; erlang:error(not_implemented, [Args]).</pre> </div> </div>  </div> <table class="func-table"><tr class="func-tr"> <td class="func-td"><div><span onmouseover="document.getElementById('ghlink-Module:format_status-2-idm15700').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-Module:format_status-2-idm15700').style.visibility = 'hidden';" id="Module:format_status-2">Module:format_status(Opt, [PDict,State,Data]) -&gt; Status </span></div></td> <td class="func-since-td"><span class="since">OTP 19.0</span></td> </tr></table> <div class="exports-tube">  <h2 class="func-types-title">Types</h2>         
<div class="note"> <div class="label">Note</div> <div class="content">

<p> This callback is optional, so a callback module does not need to export it. The <code class="code">gen_statem</code> module provides a default implementation of this function that returns <code class="code">{State,Data}</code>. </p> <p> If this callback is exported but fails, to hide possibly sensitive data, the default function will instead return <code class="code">{State,Info}</code>, where <code class="code">Info</code> says nothing but the fact that <code class="code">format_status/2</code> has crashed. </p> </div> </div> <p>This function is called by a <code class="code">gen_statem</code> process when any of the following apply:</p> <ul> <li> One of <code><a href="sys#get_status-1"><span class="code">sys:get_status/1,2</span></a></code> is invoked to get the <code class="code">gen_statem</code> status. <code class="code">Opt</code> is set to the atom <code class="code">normal</code> for this case. </li> <li> The <code class="code">gen_statem</code> terminates abnormally and logs an error. <code class="code">Opt</code> is set to the atom <code class="code">terminate</code> for this case. </li> </ul> <p> This function is useful for changing the form and appearance of the <code class="code">gen_statem</code> status for these cases. A callback module wishing to change the <code><a href="sys#get_status-1"><span class="code">sys:get_status/1,2</span></a></code> return value and how its status appears in termination error logs exports an instance of <code class="code">format_status/2</code>, which returns a term describing the current status of the <code class="code">gen_statem</code>. </p> <p> <code class="code">PDict</code> is the current value of the process dictionary of the <code class="code">gen_statem</code>. </p> <p> <code><a href="#type-state"><span class="code">State</span></a></code> is the internal state of the <code class="code">gen_statem</code>. </p> <p> <code><a href="#type-data"><span class="code">Data</span></a></code> is the internal server data of the <code class="code">gen_statem</code>. </p> <p> The function is to return <code class="code">Status</code>, a term that contains the appropriate details of the current state and status of the <code class="code">gen_statem</code>. There are no restrictions on the form <code class="code">Status</code> can take, but for the <code><a href="sys#get_status-1"><span class="code">sys:get_status/1,2</span></a></code> case (when <code class="code">Opt</code> is <code class="code">normal</code>), the recommended form for the <code class="code">Status</code> value is <code class="code">[{data, [{"State", Term}]}]</code>, where <code class="code">Term</code> provides relevant details of the <code class="code">gen_statem</code> state. Following this recommendation is not required, but it makes the callback module status consistent with the rest of the <code><a href="sys#get_status-1"><span class="code">sys:get_status/1,2</span></a></code> return value. </p> <p> One use for this function is to return compact alternative state representations to avoid having large state terms printed in log files. Another use is to hide sensitive data from being written to the error log. </p>  </div> <table class="func-table"><tr class="func-tr"> <td class="func-td"><div><span onmouseover="document.getElementById('ghlink-Module:StateName-3-idm15768').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-Module:StateName-3-idm15768').style.visibility = 'hidden';" id="Module:StateName-3">Module:StateName(enter, OldState, Data) -&gt; StateEnterResult(StateName) </span></div></td> <td class="func-since-td"><span class="since">OTP 19.0</span></td> </tr></table> <table class="func-table"><tr class="func-tr"> <td class="func-td"><div><span onmouseover="document.getElementById('ghlink-Module:StateName-3-idm15769').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-Module:StateName-3-idm15769').style.visibility = 'hidden';" id="Module:StateName-3">Module:StateName(EventType, EventContent, Data) -&gt; StateFunctionResult </span></div></td> <td class="func-since-td"><span class="since">OTP 19.0</span></td> </tr></table> <table class="func-table"><tr class="func-tr"> <td class="func-td"><div><span onmouseover="document.getElementById('ghlink-Module:handle_event-4-idm15770').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-Module:handle_event-4-idm15770').style.visibility = 'hidden';" id="Module:handle_event-4">Module:handle_event(enter, OldState, State, Data) -&gt; StateEnterResult(State) </span></div></td> <td class="func-since-td"><span class="since">OTP 19.0</span></td> </tr></table> <table class="func-table"><tr class="func-tr"> <td class="func-td"><div><span onmouseover="document.getElementById('ghlink-Module:handle_event-4-idm15771').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-Module:handle_event-4-idm15771').style.visibility = 'hidden';" id="Module:handle_event-4">Module:handle_event(EventType, EventContent, State, Data) -&gt; HandleEventResult </span></div></td> <td class="func-since-td"><span class="since">OTP 19.0</span></td> </tr></table> <div class="exports-tube">  <h2 class="func-types-title">Types</h2>          
<p> Whenever a <code class="code">gen_statem</code> receives an event from <code><a href="#call-2"><span class="code">call/2</span></a></code>, <code><a href="#cast-2"><span class="code">cast/2</span></a></code>, or as a normal process message, one of these functions is called. If <code><a href="#type-callback_mode"><strong>callback mode</strong></a></code> is <code class="code">state_functions</code>, <code class="code">Module:StateName/3</code> is called, and if it is <code class="code">handle_event_function</code>, <code class="code">Module:handle_event/4</code> is called. </p> <p> If <code class="code">EventType</code> is <code><a href="#type-event_type"><span class="code">{call,From}</span></a></code>, the caller waits for a reply. The reply can be sent from this or from any other <code><a href="#state%20callback"><strong>state callback</strong></a></code> by returning with <code class="code">{reply,From,Reply}</code> in <code><a href="#type-action"><span class="code">Actions</span></a></code>, in <code><a href="#type-reply_action"><span class="code">Replies</span></a></code>, or by calling <code><a href="#reply-2"><span class="code">reply(From, Reply)</span></a></code>. </p> <p> If this function returns with a next state that does not match equal (<code class="code">=/=</code>) to the current state, all postponed events are retried in the next state. </p> <p> The only difference between <code class="code">StateFunctionResult</code> and <code class="code">HandleEventResult</code> is that for <code class="code">StateFunctionResult</code> the next state must be an atom, but for <code class="code">HandleEventResult</code> there is no restriction on the next state. </p> <p> For options that can be set and actions that can be done by <code class="code">gen_statem</code> after returning from this function, see <code><a href="#type-action"><span class="code">action()</span></a></code>. </p> <p> When the <code class="code">gen_statem</code> runs with <code><a href="#type-state_enter"><strong>state enter calls</strong></a></code>, these functions are also called with arguments <code class="code">(enter, OldState, ...)</code> during every <strong>state change</strong>. In this case there are some restrictions on the <code><a href="#type-enter_action">actions</a></code> that may be returned: <code><a href="#type-postpone"><span class="code">postpone()</span></a></code> is not allowed since a <strong>state enter call</strong> is not an event so there is no event to postpone, and <code><a href="#type-action"><span class="code">{next_event,_,_}</span></a></code> is not allowed since using <strong>state enter calls</strong> should not affect how events are consumed and produced. You may also not change states from this call. Should you return <code class="code">{next_state,NextState, ...}</code> with <code class="code">NextState =/= State</code> the <code class="code">gen_statem</code> crashes. Note that it is actually allowed to use <code class="code">{repeat_state, NewData, ...}</code> although it makes little sense since you immediately will be called again with a new <strong>state enter call</strong> making this just a weird way of looping, and there are better ways to loop in Erlang. If you do not update <code class="code">NewData</code> and have some loop termination condition, or if you use <code class="code">{repeat_state_and_data, _}</code> or <code class="code">repeat_state_and_data</code> you have an infinite loop! You are advised to use <code class="code">{keep_state,...}</code>, <code class="code">{keep_state_and_data,_}</code> or <code class="code">keep_state_and_data</code> since changing states from a <strong>state enter call</strong> is not possible anyway. </p> <p> Note the fact that you can use <code><span class="code">throw</span></code> to return the result, which can be useful. For example to bail out with <code class="code">throw(keep_state_and_data)</code> from deep within complex code that cannot return <code class="code">{next_state,State,Data}</code> because <code class="code">State</code> or <code class="code">Data</code> is no longer in scope. </p>  </div> <table class="func-table"><tr class="func-tr"> <td class="func-td"><div><span onmouseover="document.getElementById('ghlink-Module:terminate-3-idm15861').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-Module:terminate-3-idm15861').style.visibility = 'hidden';" id="Module:terminate-3">Module:terminate(Reason, State, Data) -&gt; Ignored</span></div></td> <td class="func-since-td"><span class="since">OTP 19.0</span></td> </tr></table> <div class="exports-tube">  <h2 class="func-types-title">Types</h2>      
<div class="note"> <div class="label">Note</div> <div class="content">

<p>This callback is optional, so callback modules need not export it. The <code class="code">gen_statem</code> module provides a default implementation without cleanup.</p> </div> </div> <p> This function is called by a <code class="code">gen_statem</code> when it is about to terminate. It is to be the opposite of <code><a href="#Module:init-1"><span class="code">Module:init/1</span></a></code> and do any necessary cleaning up. When it returns, the <code class="code">gen_statem</code> terminates with <code class="code">Reason</code>. The return value is ignored.</p> <p> <code class="code">Reason</code> is a term denoting the stop reason and <code><a href="#type-state"><span class="code">State</span></a></code> is the internal state of the <code class="code">gen_statem</code>. </p> <p> <code class="code">Reason</code> depends on why the <code class="code">gen_statem</code> is terminating. If it is because another callback function has returned, a stop tuple <code class="code">{stop,Reason}</code> in <code><a href="#type-action"><span class="code">Actions</span></a></code>, <code class="code">Reason</code> has the value specified in that tuple. If it is because of a failure, <code class="code">Reason</code> is the error reason. </p> <p> If the <code class="code">gen_statem</code> is part of a supervision tree and is ordered by its supervisor to terminate, this function is called with <code class="code">Reason = shutdown</code> if both the following conditions apply:</p> <ul> <li> <p> The <code class="code">gen_statem</code> has been set to trap exit signals. </p> </li> <li> <p> The shutdown strategy as defined in the supervisor's child specification is an integer time-out value, not <code class="code">brutal_kill</code>. </p> </li> </ul> <p> Even if the <code class="code">gen_statem</code> is <strong>not</strong> part of a supervision tree, this function is called if it receives an <code class="code">'EXIT'</code> message from its parent. <code class="code">Reason</code> is the same as in the <code class="code">'EXIT'</code> message. </p> <p> Otherwise, the <code class="code">gen_statem</code> is immediately terminated. </p> <p> Notice that for any other reason than <code class="code">normal</code>, <code class="code">shutdown</code>, or <code class="code">{shutdown,Term}</code>, the <code class="code">gen_statem</code> is assumed to terminate because of an error and an error report is issued using <code><span class="code">logger(3)</span></code>. </p> <p> When the <code class="code">gen_statem</code> process exits, an exit signal with the same reason is sent to linked processes and ports. </p>  </div> </div> <div class="innertube"> <h2><span onmouseover="document.getElementById('ghlink-see-also-idm15920').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-see-also-idm15920').style.visibility = 'hidden';">See Also</span></h2>  <p> <code><a href="gen_event"><span class="code">gen_event(3)</span></a></code>, <code><a href="gen_fsm"><span class="code">gen_fsm(3)</span></a></code>, <code><a href="gen_server"><span class="code">gen_server(3)</span></a></code>, <code><a href="proc_lib"><span class="code">proc_lib(3)</span></a></code>, <code><a href="supervisor"><span class="code">supervisor(3)</span></a></code>, <code><a href="sys"><span class="code">sys(3)</span></a></code>. </p>  </div> <div class="footer"> <hr> <p>Copyright © 1997-2021 Ericsson AB. All Rights Reserved.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2021 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
