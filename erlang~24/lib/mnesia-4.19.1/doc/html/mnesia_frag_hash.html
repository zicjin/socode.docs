  <div class="innertube"> <h2><span onmouseover="document.getElementById('ghlink-module-idm5166').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-module-idm5166').style.visibility = 'hidden';">Module</span></h2> <p class="REFBODY module-body">mnesia_frag_hash</p> </div> <div class="innertube"> <h2><span onmouseover="document.getElementById('ghlink-module-summary-idm5167').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-module-summary-idm5167').style.visibility = 'hidden';">Module Summary</span></h2> <p class="REFBODY module-summary-body">Defines mnesia_frag_hash callback behavior</p> </div> <div class="innertube"> <h2><span onmouseover="document.getElementById('ghlink-description-idm5168').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-description-idm5168').style.visibility = 'hidden';">Description</span></h2> 
<p>This module defines a callback behavior for user-defined hash functions of fragmented tables.</p> <p>Which module that is selected to implement the <code class="code">mnesia_frag_hash</code> behavior for a particular fragmented table is specified together with the other <code class="code">frag_properties</code>. The <code class="code">hash_module</code> defines the module name. The <code class="code">hash_state</code> defines the initial hash state.</p> <p>This module implements dynamic hashing, which is a kind of hashing that grows nicely when new fragments are added. It is well suited for scalable hash tables.</p>  </div> <div class="innertube"><h2><span onmouseover="document.getElementById('ghlink-exports-idm5176').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-exports-idm5176').style.visibility = 'hidden';">Exports</span></h2></div> <div class="exports-body"> <table class="func-table"><tr class="func-tr"> <td class="func-td"><div><span onmouseover="document.getElementById('ghlink-init_state-2-idm5178').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-init_state-2-idm5178').style.visibility = 'hidden';" id="init_state-2">init_state(Tab, State) -&gt; NewState | abort(Reason)</span></div></td> <td class="func-since-td"></td> </tr></table> <div class="exports-tube">  <h2 class="func-types-title">Types</h2>      
<p>Starts when a fragmented table is created with the function <code class="code">mnesia:create_table/2</code> or when a normal (unfragmented) table is converted to be a fragmented table with <code class="code">mnesia:change_table_frag/2</code>.</p> <p>Notice that the function <code class="code">add_frag/2</code> is started one time for each of the other fragments (except number 1) as a part of the table creation procedure.</p> <p><code class="code">State</code> is the initial value of the <code class="code">hash_state</code> <code class="code">frag_property</code>. <code class="code">NewState</code> is stored as <code class="code">hash_state</code> among the other <code class="code">frag_properties</code>.</p>  </div> <table class="func-table"><tr class="func-tr"> <td class="func-td"><div><span onmouseover="document.getElementById('ghlink-add_frag-1-idm5199').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-add_frag-1-idm5199').style.visibility = 'hidden';" id="add_frag-1">add_frag(State) -&gt; {NewState, IterFrags, AdditionalLockFrags} | abort(Reason)</span></div></td> <td class="func-since-td"></td> </tr></table> <div class="exports-tube">  <h2 class="func-types-title">Types</h2>       
<p>To scale well, it is a good idea to ensure that the records are evenly distributed over all fragments, including the new one.</p> <p><code class="code">NewState</code> is stored as <code class="code">hash_state</code> among the other <code class="code">frag_properties</code>.</p> <p>As a part of the <code class="code">add_frag</code> procedure, Mnesia iterates over all fragments corresponding to the <code class="code">IterFrags</code> numbers and starts <code class="code">key_to_frag_number(NewState,RecordKey)</code> for each record. If the new fragment differs from the old fragment, the record is moved to the new fragment.</p> <p>As the <code class="code">add_frag</code> procedure is a part of a schema transaction, Mnesia acquires write locks on the affected tables. That is, both the fragments corresponding to <code class="code">IterFrags</code> and those corresponding to <code class="code">AdditionalLockFrags</code>.</p>  </div> <table class="func-table"><tr class="func-tr"> <td class="func-td"><div><span onmouseover="document.getElementById('ghlink-del_frag-1-idm5222').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-del_frag-1-idm5222').style.visibility = 'hidden';" id="del_frag-1">del_frag(State) -&gt; {NewState, IterFrags, AdditionalLockFrags} | abort(Reason)</span></div></td> <td class="func-since-td"></td> </tr></table> <div class="exports-tube">  <h2 class="func-types-title">Types</h2>       
<p><code class="code">NewState</code> is stored as <code class="code">hash_state</code> among the other <code class="code">frag_properties</code>.</p> <p>As a part of the <code class="code">del_frag</code> procedure, Mnesia iterates over all fragments corresponding to the <code class="code">IterFrags</code> numbers and starts <code class="code">key_to_frag_number(NewState,RecordKey)</code> for each record. If the new fragment differs from the old fragment, the record is moved to the new fragment.</p> <p>Notice that all records in the last fragment must be moved to another fragment, as the entire fragment is deleted.</p> <p>As the <code class="code">del_frag</code> procedure is a part of a schema transaction, Mnesia acquires write locks on the affected tables. That is, both the fragments corresponding to <code class="code">IterFrags</code> and those corresponding to <code class="code">AdditionalLockFrags</code>.</p>  </div> <table class="func-table"><tr class="func-tr"> <td class="func-td"><div><span onmouseover="document.getElementById('ghlink-key_to_frag_number-2-idm5245').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-key_to_frag_number-2-idm5245').style.visibility = 'hidden';" id="key_to_frag_number-2">key_to_frag_number(State, Key) -&gt; FragNum | abort(Reason)</span></div></td> <td class="func-since-td"></td> </tr></table> <div class="exports-tube">  <h2 class="func-types-title">Types</h2>    
<p>Starts whenever Mnesia needs to determine which fragment a certain record belongs to. It is typically started at <code class="code">read</code>, <code class="code">write</code>, and <code class="code">delete</code>.</p>  </div> <table class="func-table"><tr class="func-tr"> <td class="func-td"><div><span onmouseover="document.getElementById('ghlink-match_spec_to_frag_numbers-2-idm5256').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-match_spec_to_frag_numbers-2-idm5256').style.visibility = 'hidden';" id="match_spec_to_frag_numbers-2">match_spec_to_frag_numbers(State, MatchSpec) -&gt; FragNums | abort(Reason)</span></div></td> <td class="func-since-td"></td> </tr></table> <div class="exports-tube">  <h2 class="func-types-title">Types</h2>      
<p>This function is called whenever Mnesia needs to determine which fragments that need to be searched for a <code class="code">MatchSpec</code>. It is typically called by <code class="code">select</code> and <code class="code">match_object</code>.</p>  </div> </div> <div class="innertube"> <h2><span onmouseover="document.getElementById('ghlink-see-also-idm5269').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-see-also-idm5269').style.visibility = 'hidden';">See Also</span></h2>  <p><code>mnesia(3)</code></p>  </div> <div class="footer"> <hr> <p>Copyright Â© 1997-2021 Ericsson AB. All Rights Reserved.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2021 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
