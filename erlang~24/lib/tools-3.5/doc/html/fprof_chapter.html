<div class="innertube"> <h1>4 fprof - The File Trace Profiler</h1> <p><code class="code">fprof</code> is a profiling tool that can be used to get a picture of how much processing time different functions consumes and in which processes. </p> <p><code class="code">fprof</code> uses tracing with timestamps to collect profiling data. Therfore there is no need for special compilation of any module to be profiled. </p> <p><code class="code">fprof</code> presents wall clock times from the host machine OS, with the assumption that OS scheduling will randomly load the profiled functions in a fair way. Both <strong>own time</strong> i.e the time used by a function for its own execution, and <strong>accumulated time</strong> i.e execution time including called functions. </p> <p>Profiling is essentially done in 3 steps:</p> <dl> <dt><strong><code class="code">1</code></strong></dt> <dd>Tracing; to file, as mentioned in the previous paragraph.</dd> <dt><strong><code class="code">2</code></strong></dt> <dd>Profiling; the trace file is read and raw profile data is collected into an internal RAM storage on the node. During this step the trace data may be dumped in text format to file or console.</dd> <dt><strong><code class="code">3</code></strong></dt> <dd>Analysing; the raw profile data is sorted and dumped in text format either to file or console.</dd> </dl> <p>Since <code class="code">fprof</code> uses trace to file, the runtime performance degradation is minimized, but still far from negligible, especially not for programs that use the filesystem heavily by themselves. Where you place the trace file is also important, e.g on Solaris <code class="code">/tmp</code> is usually a good choice, while any NFS mounted disk is a lousy choice. </p> <p>Fprof can also skip the file step and trace to a tracer process of its own that does the profiling in runtime. </p> <p>The following sections show some examples of how to profile with Fprof. See also the reference manual <code><a href="fprof">fprof(3)</a></code>. </p> <h2><span onmouseover="document.getElementById('ghlink-profiling-from-the-source-code-idm514').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-profiling-from-the-source-code-idm514').style.visibility = 'hidden';">4.1 Profiling from the source code</span></h2> <p>If you can edit and recompile the source code, it is convenient to insert <code class="code">fprof:trace(start)</code> and <code class="code">fprof:trace(stop)</code> before and after the code to be profiled. All spawned processes are also traced. If you want some other filename than the default try <code class="code">fprof:trace(start, "my_fprof.trace")</code>. </p> <p>Then read the trace file and create the raw profile data with <code class="code">fprof:profile()</code>, or perhaps <code class="code">fprof:profile(file, "my_fprof.trace")</code> for non-default filename. </p> <p>Finally create an informative table dumped on the console with <code class="code">fprof:analyse()</code>, or on file with <code class="code">fprof:analyse(dest, [])</code>, or perhaps even <code class="code">fprof:analyse([{dest, "my_fprof.analysis"}, {cols, 120}])</code> for a wider listing on non-default filename. </p> <p>See the <code><a href="fprof">fprof(3)</a></code> manual page for more options and arguments to the functions <code><a href="fprof#trace-2">trace</a></code>, <code><a href="fprof#profile-0">profile</a></code> and <code><a href="fprof#analyse-0">analyse</a></code>. </p> <h2><span onmouseover="document.getElementById('ghlink-profiling-a-function-idm532').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-profiling-a-function-idm532').style.visibility = 'hidden';">4.2 Profiling a function</span></h2> <p>If you have one function that does the task that you want to profile, and the function returns when the profiling should stop, it is convenient to use <code class="code">fprof:apply(Module, Function, Args)</code> and related for the tracing step. </p> <p>If the tracing should continue after the function returns, for example if it is a start function that spawns processes to be profiled, you can use <code class="code">fprof:apply(M, F, Args, [continue | OtherOpts])</code>. The tracing has to be stopped at a suitable later time using <code class="code">fprof:trace(stop)</code>. </p> <h2><span onmouseover="document.getElementById('ghlink-immediate-profiling-idm539').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-immediate-profiling-idm539').style.visibility = 'hidden';">4.3 Immediate profiling</span></h2> <p>It is also possible to trace immediately into the profiling process that creates the raw profile data, that is to short circuit the tracing and profiling steps so that the filesystem is not used. </p> <p>Do something like this:</p> <pre data-language="erlang">
{ok, Tracer} = fprof:profile(start),
fprof:trace([start, {tracer, Tracer}]),
%% Code to profile
fprof:trace(stop);</pre> <p>This puts less load on the filesystem, but much more on the Erlang runtime system. </p> </div> <div class="footer"> <hr> <p>Copyright Â© 1997-2021 Ericsson AB. All Rights Reserved.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2021 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
