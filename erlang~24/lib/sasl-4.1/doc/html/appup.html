  <div class="innertube"> <h2><span onmouseover="document.getElementById('ghlink-file-idm1855').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-file-idm1855').style.visibility = 'hidden';">File</span></h2> <p class="REFBODY file-body">appup</p> </div> <div class="innertube"> <h2><span onmouseover="document.getElementById('ghlink-file-summary-idm1856').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-file-summary-idm1856').style.visibility = 'hidden';">File Summary</span></h2> <p class="REFBODY file-summary-body">Application upgrade file</p> </div> <div class="innertube"> <h2><span onmouseover="document.getElementById('ghlink-description-idm1857').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-description-idm1857').style.visibility = 'hidden';">Description</span></h2> 
<p>The <strong>application upgrade file</strong> defines how an application is upgraded or downgraded in a running system.</p> <p>This file is used by the functions in <code><a href="systools"><span class="code">systools</span></a></code> when generating a release upgrade file <code class="code">relup</code>.</p>  </div> <div class="innertube"> <h2><span onmouseover="document.getElementById('ghlink-file-syntax-idm1864').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-file-syntax-idm1864').style.visibility = 'hidden';">File Syntax</span></h2>  <p>The application upgrade file is to be called <code class="code">Application.appup</code>, where <code class="code">Application</code> is the application name. The file is to be located in the <code class="code">ebin</code> directory for the application.</p> <p>The <code class="code">.appup</code> file contains one single Erlang term, which defines the instructions used to upgrade or downgrade the application. The file has the following syntax:</p> <pre data-language="erlang">{Vsn,
  [{UpFromVsn, Instructions}, ...],
  [{DownToVsn, Instructions}, ...]}.</pre> <dl> <dt><strong><code class="code">Vsn = string()</code></strong></dt> <dd><p>Current application version.</p></dd> <dt><strong><code class="code">UpFromVsn = string() | binary()</code></strong></dt> <dd><p>An earlier application version to upgrade from. If it is a string, it is interpreted as a specific version number. If it is a binary, it is interpreted as a regular expression that can match multiple version numbers.</p></dd> <dt><strong><code class="code">DownToVsn = string() | binary()</code></strong></dt> <dd><p>An earlier application version to downgrade to. If it is a string, it is interpreted as a specific version number. If it is a binary, it is interpreted as a regular expression that can match multiple version numbers.</p></dd> <dt><strong><code class="code">Instructions</code></strong></dt> <dd><p>A list of <strong>release upgrade instructions</strong>, see <code><a href="#Release%20Upgrade%20Instructions">Release Upgrade Instructions</a></code>. It is recommended to use high-level instructions only. These are automatically translated to low-level instructions by <code class="code">systools</code> when creating the <code class="code">relup</code> file.</p></dd> </dl> <p>To avoid duplication of upgrade instructions, it is allowed to use regular expressions to specify <code class="code">UpFromVsn</code> and <code class="code">DownToVsn</code>. To be considered a regular expression, the version identifier must be specified as a binary. For example, the following match all versions <code class="code">2.1.x</code>, where <code class="code">x</code> is any number:</p> <pre data-language="erlang">&lt;&lt;"2\\.1\\.[0-9]+"&gt;&gt;</pre> <p>Notice that the regular expression must match the complete version string, so this example works for, for example, <code class="code">2.1.1</code>, but not for <code class="code">2.1.1.1</code>.</p>  </div> <div class="innertube"> <h2> <span onmouseover="document.getElementById('ghlink-release-upgrade-instructions-idm1903').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-release-upgrade-instructions-idm1903').style.visibility = 'hidden';" id="Release%20Upgrade%20Instructions">Release Upgrade Instructions</span> </h2>  <p>Release upgrade instructions are interpreted by the release handler when an upgrade or downgrade is made. For more information about release handling, see <code>OTP Design Principles</code> in <strong>System Documentation</strong>.</p> <p>A process is said to <strong>use</strong> a module <code class="code">Mod</code> if <code class="code">Mod</code> is listed in the <code class="code">Modules</code> part of the child specification used to start the process, see <code><span class="code">supervisor(3)</span></code>. In the case of <code><span class="code">gen_event</span></code>, an event manager process is said to use <code class="code">Mod</code> if <code class="code">Mod</code> is an installed event handler.</p> <h4>High-Level Instructions</h4>  <pre data-language="erlang">
{update, Mod}
{update, Mod, supervisor}
{update, Mod, Change}
{update, Mod, DepMods}
{update, Mod, Change, DepMods}
{update, Mod, Change, PrePurge, PostPurge, DepMods}
{update, Mod, Timeout, Change, PrePurge, PostPurge, DepMods}
{update, Mod, ModType, Timeout, Change, PrePurge, PostPurge, DepMods}
  Mod = atom()
  ModType = static | dynamic
  Timeout = int()&gt;0 | default | infinity
  Change = soft | {advanced,Extra}
    Extra = term()
  PrePurge = PostPurge = soft_purge | brutal_purge
  DepMods = [Mod]</pre> <p>Synchronized code replacement of processes using module <code class="code">Mod</code>.</p> <p>All those processes are suspended using <code><span class="code">sys:suspend</span></code>, the new module version is loaded, and then the processes are resumed using <code><span class="code">sys:resume</span></code>.</p> <dl> <dt><strong><code class="code">Change</code></strong></dt> <dd><p>Defaults to <code class="code">soft</code> and defines the type of code change. If it is set to <code class="code">{advanced,Extra}</code>, implemented processes using <code><span class="code">gen_server</span></code>, <code><span class="code">gen_fsm</span></code>, <code><span class="code">gen_statem</span></code>, or <code><span class="code">gen_event</span></code> transform their internal state by calling the callback function <code class="code">code_change</code>. Special processes call the callback function <code class="code">system_code_change/4</code>. In both cases, the term <code class="code">Extra</code> is passed as an argument to the callback function.</p></dd> <dt><strong><code class="code">PrePurge</code></strong></dt> <dd><p>Defaults to <code class="code">brutal_purge</code>. It controls what action to take with processes executing old code before loading the new module version. If the value is <code class="code">brutal_purge</code>, the processes are killed. If the value is <code class="code">soft_purge</code>, <code><a href="release_handler#install_release-1"><span class="code">release_handler:install_release/1</span></a></code> returns <code class="code">{error,{old_processes,Mod}}</code>.</p></dd> <dt><strong><code class="code">PostPurge</code></strong></dt> <dd><p>Defaults to <code class="code">brutal_purge</code>. It controls what action to take with processes that are executing old code when the new module version has been loaded. If the value is <code class="code">brutal_purge</code>, the code is purged when the release is made permanent and the processes are killed. If the value is <code class="code">soft_purge</code>, the release handler purges the old code when no remaining processes execute the code.</p></dd> <dt><strong><code class="code">DepMods</code></strong></dt> <dd><p>Defaults to <code class="code">[]</code> and defines other modules that <code class="code">Mod</code> is dependent on. In the <code class="code">relup</code> file, instructions for suspending processes using <code class="code">Mod</code> come before instructions for suspending processes using modules in <code class="code">DepMods</code> when upgrading, and conversely when downgrading. In case of circular dependencies, the order of the instructions in the <code class="code">appup</code> file is kept.</p></dd> <dt><strong><code class="code">Timeout</code></strong></dt> <dd><p>Defines the time-out when suspending processes. If no value or <code class="code">default</code> is specified, the default value for <code><span class="code">sys:suspend</span></code> is used.</p></dd> <dt><strong><code class="code">ModType</code></strong></dt> <dd><p>Defaults to <code class="code">dynamic</code>. It specifies if the code is "dynamic", that is, if a process using the module spontaneously switches to new code, or if it is "static". When doing an advanced update and upgrade, the new version of a dynamic module is loaded before the process is asked to change code. When downgrading, the process is asked to change code before loading the new version. For static modules, the new version is loaded before the process is asked to change code, both in the case of upgrading and downgrading. Callback modules are dynamic.</p></dd> </dl> <p><code class="code">update</code> with argument <code class="code">supervisor</code> is used when changing the start specification of a supervisor.</p> <pre data-language="erlang">
{load_module, Mod}
{load_module, Mod, DepMods}
{load_module, Mod, PrePurge, PostPurge, DepMods}
  Mod = atom()
  PrePurge = PostPurge = soft_purge | brutal_purge
  DepMods = [Mod]</pre> <p>Simple code replacement of the module <code class="code">Mod</code>.</p> <p>For a description of <code class="code">PrePurge</code> and <code class="code">PostPurge</code>, see <code class="code">update</code> above.</p> <p><code class="code">DepMods</code> defaults to <code class="code">[]</code> and defines which other modules <code class="code">Mod</code> is dependent on. In the <code class="code">relup</code> file, instructions for loading these modules come before the instruction for loading <code class="code">Mod</code> when upgrading, and conversely when downgrading.</p> <pre data-language="erlang">
{add_module, Mod}
{add_module, Mod, DepMods}
  Mod = atom()
  DepMods = [Mod]</pre> <p>Loads a new module <code class="code">Mod</code>.</p> <p><code class="code">DepMods</code> defaults to <code class="code">[]</code> and defines which other modules <code class="code">Mod</code> is dependent on. In the <code class="code">relup</code> file, instructions related to these modules come before the instruction for loading <code class="code">Mod</code> when upgrading, and conversely when downgrading.</p> <pre data-language="erlang">
{delete_module, Mod}
{delete_module, Mod, DepMods}
  Mod = atom()</pre> <p>Deletes a module <code class="code">Mod</code> using the low-level instructions <code class="code">remove</code> and <code class="code">purge</code>.</p> <p><code class="code">DepMods</code> defaults to <code class="code">[]</code> and defines which other modules <code class="code">Mod</code> is dependent on. In the <code class="code">relup</code> file, instructions related to these modules come before the instruction for removing <code class="code">Mod</code> when upgrading, and conversely when downgrading.</p> <pre data-language="erlang">
{add_application, Application}
{add_application, Application, Type}
  Application = atom()
  Type = permanent | transient | temporary | load | none</pre> <p>Adding an application means that the modules defined by the <code class="code">modules</code> key in the <code class="code">.app</code> file are loaded using <code class="code">add_module</code>.</p> <p><code class="code">Type</code> defaults to <code class="code">permanent</code> and specifies the start type of the application. If <code class="code">Type = permanent | transient | temporary</code>, the application is loaded and started in the corresponding way, see <code><span class="code">application(3)</span></code>. If <code class="code">Type = load</code>, the application is only loaded. If <code class="code">Type = none</code>, the application is not loaded and not started, although the code for its modules is loaded.</p> <pre data-language="erlang">
{remove_application, Application}
  Application = atom()</pre> <p>Removing an application means that the application is stopped, the modules are unloaded using <code class="code">delete_module</code>, and then the application specification is unloaded from the application controller.</p> <pre data-language="erlang">
{restart_application, Application}
  Application = atom()</pre> <p>Restarting an application means that the application is stopped and then started again, similar to using the instructions <code class="code">remove_application</code> and <code class="code">add_application</code> in sequence. Note that, even if the application has been started before the release upgrade is performed, <code class="code">restart_application</code> may only <code class="code">load</code> it rather than <code class="code">start</code> it, depending on the application's <code class="code">start type</code>: If <code class="code">Type = load</code>, the application is only loaded. If <code class="code">Type = none</code>, the application is not loaded and not started, although the code for its modules is loaded. </p>  <h4>Low-Level Instructions</h4>  <pre data-language="erlang">
{load_object_code, {App, Vsn, [Mod]}}
  App = Mod = atom()
  Vsn = string()</pre> <p>Reads each <code class="code">Mod</code> from directory <code class="code">App-Vsn/ebin</code> as a binary. It does not load the modules. The instruction is to be placed first in the script to read all new code from the file to make the suspend-load-resume cycle less time-consuming.</p> <pre data-language="erlang">
point_of_no_return</pre> <p>If a crash occurs after this instruction, the system cannot recover and is restarted from the old release version. The instruction must only occur once in a script. It is to be placed after all <code class="code">load_object_code</code> instructions.</p> <pre data-language="erlang">
{load, {Mod, PrePurge, PostPurge}}
  Mod = atom()
  PrePurge = PostPurge = soft_purge | brutal_purge</pre> <p>Before this instruction occurs, <code class="code">Mod</code> must have been loaded using <code class="code">load_object_code</code>. This instruction loads the module. <code class="code">PrePurge</code> is ignored. For a description of <code class="code">PostPurge</code>, see the high-level instruction <code class="code">update</code> earlier.</p> <pre data-language="erlang">
{remove, {Mod, PrePurge, PostPurge}}
  Mod = atom()
  PrePurge = PostPurge = soft_purge | brutal_purge</pre> <p>Makes the current version of <code class="code">Mod</code> old. <code class="code">PrePurge</code> is ignored. For a description of <code class="code">PostPurge</code>, see the high-level instruction <code class="code">update</code> earlier.</p> <pre data-language="erlang">
{purge, [Mod]}
  Mod = atom()</pre> <p>Purges each module <code class="code">Mod</code>, that is, removes the old code. Notice that any process executing purged code is killed.</p> <pre data-language="erlang">
{suspend, [Mod | {Mod, Timeout}]}
  Mod = atom()
  Timeout = int()&gt;0 | default | infinity</pre> <p>Tries to suspend all processes using a module <code class="code">Mod</code>. If a process does not respond, it is ignored. This can cause the process to die, either because it crashes when it spontaneously switches to new code, or as a result of a purge operation. If no <code class="code">Timeout</code> is specified or <code class="code">default</code> is specified, the default value for <code><span class="code">sys:suspend</span></code> is used.</p> <pre data-language="erlang">
{resume, [Mod]}
  Mod = atom()</pre> <p>Resumes all suspended processes using a module <code class="code">Mod</code>.</p> <pre data-language="erlang">
{code_change, [{Mod, Extra}]}
{code_change, Mode, [{Mod, Extra}]}
  Mod = atom()
  Mode = up | down
  Extra = term()</pre> <p><code class="code">Mode</code> defaults to <code class="code">up</code> and specifies if it is an upgrade or downgrade. This instruction sends a <code class="code">code_change</code> system message to all processes using a module <code class="code">Mod</code> by calling function <code><span class="code">sys:change_code</span></code>, passing term <code class="code">Extra</code> as argument.</p> <pre data-language="erlang">
{stop, [Mod]}
  Mod = atom()</pre> <p>Stops all processes using a module <code class="code">Mod</code> by calling <code><span class="code">supervisor:terminate_child/2</span></code>. This instruction is useful when the simplest way to change code is to stop and restart the processes that run the code.</p> <pre data-language="erlang">
{start, [Mod]}
  Mod = atom()</pre> <p>Starts all stopped processes using a module <code class="code">Mod</code> by calling <code><span class="code">supervisor:restart_child/2</span></code>.</p> <pre data-language="erlang">
{sync_nodes, Id, [Node]}
{sync_nodes, Id, {M, F, A}}
  Id = term()
  Node = node()
  M = F = atom()
  A = [term()]</pre> <p><code class="code">apply(M, F, A)</code> must return a list of nodes.</p> <p>This instruction synchronizes the release installation with other nodes. Each <code class="code">Node</code> must evaluate this command with the same <code class="code">Id</code>. The local node waits for all other nodes to evaluate the instruction before execution continues. If a node goes down, it is considered to be an unrecoverable error, and the local node is restarted from the old release. There is no time-out for this instruction, which means that it can hang forever.</p> <pre data-language="erlang">
{apply, {M, F, A}}
  M = F = atom()
  A = [term()]</pre> <p>Evaluates <code class="code">apply(M, F, A)</code>.</p> <p>If the instruction appears before instruction <code class="code">point_of_no_return</code>, a failure is caught. <code><a href="release_handler#install_release-1"><span class="code">release_handler:install_release/1</span></a></code> then returns <code class="code">{error,{'EXIT',Reason}}</code>, unless <code class="code">{error,Error}</code> is thrown or returned. Then it returns <code class="code">{error,Error}</code>.</p> <p>If the instruction appears after instruction <code class="code">point_of_no_return</code> and the function call fails, the system is restarted.</p> <pre data-language="erlang">
restart_new_emulator</pre> <p>This instruction is used when the application ERTS, Kernel, STDLIB, or SASL is upgraded. It shuts down the current emulator and starts a new one. All processes are terminated gracefully, and the new version of ERTS, Kernel, STDLIB, and SASL are used when the emulator restarts. Only one <code class="code">restart_new_emulator</code> instruction is allowed in the <code class="code">relup</code> file, and it must be placed first. <code><a href="systools#make_relup-3"><span class="code">systools:make_relup/3,4</span></a></code> ensures this when the <code class="code">relup</code> file is generated. The rest of the instructions in the <code class="code">relup</code> file is executed after the restart as a part of the boot script.</p> <p>An info report is written when the upgrade is completed. To programmatically determine if the upgrade is complete, call <code><a href="release_handler#which_releases-0"> <span class="code">release_handler:which_releases/0,1</span></a></code> and check if the expected release has status <code class="code">current</code>.</p> <p>The new release must still be made permanent after the upgrade is completed, otherwise the old emulator is started if there is an emulator restart.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>As stated earlier, instruction <code class="code">restart_new_emulator</code> causes the emulator to be restarted with new versions of ERTS&gt;, Kernel, STDLIB, and SASL. However, all other applications do at startup run their old versions in this new emulator. This is usually no problem, but every now and then incompatible changes occur to the core applications, which can cause trouble in this setting. Such incompatible changes (when functions are removed) are normally preceded by a deprecation over two major releases. To ensure that your application is not crashed by an incompatible change, always remove any call to deprecated functions as soon as possible.</p> </div> </div> <pre data-language="erlang">
restart_emulator</pre> <p>This instruction is similar to <code class="code">restart_new_emulator</code>, except it must be placed at the end of the <code class="code">relup</code> file. It is not related to an upgrade of the emulator or the core applications, but can be used by any application when a complete reboot of the system is required.</p> <p>When generating the <code class="code">relup</code> file, <code><a href="systools#make_relup-3"><span class="code">systools:make_relup/3,4</span></a></code> ensures that there is only one <code class="code">restart_emulator</code> instruction and that it is the last instruction in the <code class="code">relup</code> file.</p>   </div> <div class="innertube"> <h2><span onmouseover="document.getElementById('ghlink-see-also-idm2147').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-see-also-idm2147').style.visibility = 'hidden';">See Also</span></h2>  <p><code><a href="release_handler"><span class="code">release_handler(3)</span></a></code>, <code><a href="relup"><span class="code">relup(4)</span></a></code>, <code><span class="code">supervisor(3)</span></code>, <code><a href="systools"><span class="code">systools(3)</span></a></code></p>  </div> <div class="footer"> <hr> <p>Copyright © 1997-2021 Ericsson AB. All Rights Reserved.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2021 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
