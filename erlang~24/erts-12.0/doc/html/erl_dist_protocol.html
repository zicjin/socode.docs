<div class="innertube"> <h1>13 Distribution Protocol</h1> <p>This description is far from complete. It will be updated if the protocol is updated. However, the protocols, both from Erlang nodes to the Erlang Port Mapper Daemon (EPMD) and between Erlang nodes are stable since many years.</p> <p>The distribution protocol can be divided into four parts:</p> <ul> <li> <p>Low-level socket connection (1)</p> </li> <li> <p>Handshake, interchange node name, and authenticate (2)</p> </li> <li> <p>Authentication (done by <code> <span class="code">net_kernel(3)</span></code>) (3)</p> </li> <li> <p>Connected (4)</p> </li> </ul> <p>A node fetches the port number of another node through the EPMD (at the other host) to initiate a connection request.</p> <p>For each host, where a distributed Erlang node is running, also an EPMD is to be running. The EPMD can be started explicitly or automatically as a result of the Erlang node startup.</p> <p>By default the EPMD listens on port 4369.</p> <p>(3) and (4) above are performed at the same level but the <code class="code">net_kernel</code> disconnects the other node if it communicates using an invalid cookie (after 1 second).</p> <p>The integers in all multibyte fields are in big-endian order.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p> The Erlang Distribution protocol is not by itself secure and does not aim to be so. In order to get secure distribution the distributed nodes should be configured to use distribution over tls. See the <code> Using SSL for Erlang Distribution</code> User's Guide for details on how to setup a secure distributed node. </p> </div> </div> <h2><span onmouseover="document.getElementById('ghlink-epmd-protocol-idm5680').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-epmd-protocol-idm5680').style.visibility = 'hidden';">13.1 EPMD Protocol</span></h2> <p>The requests served by the EPMD are summarized in the following figure.</p> <div class="doc-image-wrapper">  <p class="doc-image-caption">Figure 13.1: Summary of EPMD Requests</p> </div> <p>Each request <code class="code">*_REQ</code> is preceded by a 2 byte length field. Thus, the overall request format is as follows:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>2</td> <td>n</td> </tr> <tr> <td><code class="code">Length</code></td> <td><code class="code">Request</code></td> </tr> </table> <p class="doc-table-caption">Table 13.1: Request Format</p> </div> <h4><span onmouseover="document.getElementById('ghlink-register-a-node-in-epmd-idm5697').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-register-a-node-in-epmd-idm5697').style.visibility = 'hidden';">Register a Node in EPMD</span></h4> <p>When a distributed node is started it registers itself in the EPMD. The message <code class="code">ALIVE2_REQ</code> described below is sent from the node to the EPMD. The response from the EPMD is <code class="code">ALIVE2_X_RESP</code> (or <code class="code">ALIVE2_RESP</code>).</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>2</td> <td>1</td> <td>1</td> <td>2</td> <td>2</td> <td>2</td> <td>Nlen</td> <td>2</td> <td>Elen</td> </tr> <tr> <td><code class="code">120</code></td> <td><code class="code">PortNo</code></td> <td><code class="code">NodeType</code></td> <td><code class="code">Protocol</code></td> <td><code class="code">HighestVersion</code></td> <td><code class="code">LowestVersion</code></td> <td><code class="code">Nlen</code></td> <td><code class="code">NodeName</code></td> <td><code class="code">Elen</code></td> <td><code class="code">Extra</code></td> </tr> </table> <p class="doc-table-caption">Table 13.2: ALIVE2_REQ (120)</p> </div> <dl> <dt><strong><code class="code">PortNo</code></strong></dt> <dd> <p>The port number on which the node accept connection requests.</p> </dd> <dt><strong><code class="code">NodeType</code></strong></dt> <dd> <p>77 = normal Erlang node, 72 = hidden node (C-node), ...</p> </dd> <dt><strong><code class="code">Protocol</code></strong></dt> <dd> <p>0 = TCP/IPv4, ...</p> </dd> <dt><strong><code class="code">HighestVersion</code></strong></dt> <dd> <p>The highest distribution protocol version this node can handle. The value in OTP 23 and later is 6. Older nodes only support version 5.</p> </dd> <dt><strong><code class="code">LowestVersion</code></strong></dt> <dd> <p>The lowest distribution version that this node can handle. Should be 5 to support connections to nodes older than OTP 23.</p> </dd> <dt><strong><code class="code">Nlen</code></strong></dt> <dd> <p>The length (in bytes) of field <code class="code">NodeName</code>.</p> </dd> <dt><strong><code class="code">NodeName</code></strong></dt> <dd> <p>The node name as an UTF-8 encoded string of <code class="code">Nlen</code> bytes.</p> </dd> <dt><strong><code class="code">Elen</code></strong></dt> <dd> <p>The length of field <code class="code">Extra</code>.</p> </dd> <dt><strong><code class="code">Extra</code></strong></dt> <dd> <p>Extra field of <code class="code">Elen</code> bytes.</p> </dd> </dl> <p>The connection created to the EPMD must be kept as long as the node is a distributed node. When the connection is closed, the node is automatically unregistered from the EPMD.</p> <p>The response message is either <code class="code">ALIVE2_X_RESP</code> or <code class="code">ALIVE2_RESP</code> depending on distribution version. If both the node and EPMD support distribution version 6 then the response is <code class="code">ALIVE2_X_RESP</code> otherwise it is the older <code class="code">ALIVE2_RESP</code>:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>1</td> <td>4</td> </tr> <tr> <td><code class="code">118</code></td> <td><code class="code">Result</code></td> <td><code class="code">Creation</code></td> </tr> </table> <p class="doc-table-caption">Table 13.3: ALIVE2_X_RESP (118) with 32 bit creation</p> </div> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>1</td> <td>2</td> </tr> <tr> <td><code class="code">121</code></td> <td><code class="code">Result</code></td> <td><code class="code">Creation</code></td> </tr> </table> <p class="doc-table-caption">Table 13.4: ALIVE2_RESP (121) with 16-bit creation</p> </div> <p>Result = 0 -&gt; ok, result &gt; 0 -&gt; error.</p> <h4><span onmouseover="document.getElementById('ghlink-unregister-a-node-from-epmd-idm5811').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-unregister-a-node-from-epmd-idm5811').style.visibility = 'hidden';">Unregister a Node from EPMD</span></h4> <p>A node unregisters itself from the EPMD by closing the TCP connection to EPMD established when the node was registered.</p> <h4><span onmouseover="document.getElementById('ghlink-get-the-distribution-port-of-another-node-idm5814').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-get-the-distribution-port-of-another-node-idm5814').style.visibility = 'hidden';">Get the Distribution Port of Another Node</span></h4> <p>When one node wants to connect to another node it starts with a <code class="code">PORT_PLEASE2_REQ</code> request to the EPMD on the host where the node resides to get the distribution port that the node listens to.</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>N</td> </tr> <tr> <td><code class="code">122</code></td> <td><code class="code">NodeName</code></td> </tr> </table> <p class="doc-table-caption">Table 13.5: PORT_PLEASE2_REQ (122)</p> </div> <p>where N = <code class="code">Length</code> - 1.</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>1</td> </tr> <tr> <td><code class="code">119</code></td> <td><code class="code">Result</code></td> </tr> </table> <p class="doc-table-caption">Table 13.6: PORT2_RESP (119) Response Indicating Error, Result &gt; 0 </p> </div> <p>or</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>1</td> <td>2</td> <td>1</td> <td>1</td> <td>2</td> <td>2</td> <td>2</td> <td>Nlen</td> <td>2</td> <td>Elen</td> </tr> <tr> <td><code class="code">119</code></td> <td><code class="code">Result</code></td> <td><code class="code">PortNo</code></td> <td><code class="code">NodeType</code></td> <td><code class="code">Protocol</code></td> <td><code class="code">HighestVersion</code></td> <td><code class="code">LowestVersion</code></td> <td><code class="code">Nlen</code></td> <td><code class="code">NodeName</code></td> <td><code class="code">Elen</code></td> <td>&gt;<code class="code">Extra</code> </td> </tr> </table> <p class="doc-table-caption">Table 13.7: PORT2_RESP, Result = 0</p> </div> <p>If <code class="code">Result</code> &gt; 0, the packet only consists of <code class="code">[119, Result]</code>.</p> <p>The EPMD closes the socket when it has sent the information.</p> <h4><span onmouseover="document.getElementById('ghlink-get-all-registered-names-from-epmd-idm5882').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-get-all-registered-names-from-epmd-idm5882').style.visibility = 'hidden';">Get All Registered Names from EPMD</span></h4> <p>This request is used through the Erlang function <code> <span class="code">net_adm:names/1,2</span></code>. A TCP connection is opened to the EPMD and this request is sent.</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> </tr> <tr> <td><code class="code">110</code></td> </tr> </table> <p class="doc-table-caption">Table 13.8: NAMES_REQ (110)</p> </div> <p>The response for a <code class="code">NAMES_REQ</code> is as follows:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>4</td> <td> </td> </tr> <tr> <td><code class="code">EPMDPortNo</code></td> <td><code class="code">NodeInfo*</code></td> </tr> </table> <p class="doc-table-caption">Table 13.9: NAMES_RESP</p> </div> <p><code class="code">NodeInfo</code> is a string written for each active node. When all <code class="code">NodeInfo</code> has been written the connection is closed by the EPMD.</p> <p><code class="code">NodeInfo</code> is, as expressed in Erlang:</p> <pre data-language="erlang">io:format("name ~ts at port ~p~n", [NodeName, Port]).</pre> <h4><span onmouseover="document.getElementById('ghlink-dump-all-data-from-epmd-idm5912').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-dump-all-data-from-epmd-idm5912').style.visibility = 'hidden';">Dump All Data from EPMD</span></h4> <p>This request is not really used, it is to be regarded as a debug feature.</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> </tr> <tr> <td><code class="code">100</code></td> </tr> </table> <p class="doc-table-caption">Table 13.10: DUMP_REQ</p> </div> <p>The response for a <code class="code">DUMP_REQ</code> is as follows:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>4</td> <td> </td> </tr> <tr> <td><code class="code">EPMDPortNo</code></td> <td><code class="code">NodeInfo*</code></td> </tr> </table> <p class="doc-table-caption">Table 13.11: DUMP_RESP</p> </div> <p><code class="code">NodeInfo</code> is a string written for each node kept in the EPMD. When all <code class="code">NodeInfo</code> has been written the connection is closed by the EPMD.</p> <p><code class="code">NodeInfo</code> is, as expressed in Erlang:</p> <pre data-language="erlang">io:format("active name     ~ts at port ~p, fd = ~p~n",
          [NodeName, Port, Fd]).</pre> <p>or</p> <pre data-language="erlang">io:format("old/unused name ~ts at port ~p, fd = ~p ~n",
          [NodeName, Port, Fd]).</pre> <h4><span onmouseover="document.getElementById('ghlink-kill-epmd-idm5942').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-kill-epmd-idm5942').style.visibility = 'hidden';">Kill EPMD</span></h4> <p>This request kills the running EPMD. It is almost never used.</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> </tr> <tr> <td><code class="code">107</code></td> </tr> </table> <p class="doc-table-caption">Table 13.12: KILL_REQ</p> </div> <p>The response for a <code class="code">KILL_REQ</code> is as follows:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>2</td> </tr> <tr> <td><code class="code">OKString</code></td> </tr> </table> <p class="doc-table-caption">Table 13.13: KILL_RESP</p> </div> <p>where <code class="code">OKString</code> is "OK".</p> <h4><span onmouseover="document.getElementById('ghlink-stop_req---not-used--idm5963').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-stop_req---not-used--idm5963').style.visibility = 'hidden';">STOP_REQ (Not Used)</span></h4> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>n</td> </tr> <tr> <td><code class="code">115</code></td> <td><code class="code">NodeName</code></td> </tr> </table> <p class="doc-table-caption">Table 13.14: STOP_REQ</p> </div> <p>where n = <code class="code">Length</code> - 1.</p> <p>The response for a <code class="code">STOP_REQ</code> is as follows:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>7</td> </tr> <tr> <td><code class="code">OKString</code></td> </tr> </table> <p class="doc-table-caption">Table 13.15: STOP_RESP</p> </div> <p>where <code class="code">OKString</code> is "STOPPED".</p> <p>A negative response can look as follows:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>7</td> </tr> <tr> <td><code class="code">NOKString</code></td> </tr> </table> <p class="doc-table-caption">Table 13.16: STOP_NOTOK_RESP</p> </div> <p>where <code class="code">NOKString</code> is "NOEXIST".</p> <h2> <span onmouseover="document.getElementById('ghlink-distribution-handshake-idm5998').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-distribution-handshake-idm5998').style.visibility = 'hidden';" id="distribution_handshake">13.2 Distribution Handshake</span> </h2> <p> This section describes the distribution handshake protocol used between nodes to establishing a connection. The protocol was introduced in Erlang/OTP R6 and has remained unchanged until OTP 23. The changes made in OTP 23 were designed to be compatible with the older protocol version. That is an old node can still connect toward a new node and vice versa. </p> <h4><span onmouseover="document.getElementById('ghlink-general-idm6002').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-general-idm6002').style.visibility = 'hidden';">General</span></h4> <p>The TCP/IP distribution uses a handshake that expects a connection-based protocol, that is, the protocol does not include any authentication after the handshake procedure.</p> <p>This is not entirely safe, as it is vulnerable against takeover attacks, but it is a tradeoff between fair safety and performance.</p> <p>The cookies are never sent in cleartext and the handshake procedure expects the client (called <code class="code">A</code>) to be the first one to prove that it can generate a sufficient digest. The digest is generated with the MD5 message digest algorithm and the challenges are expected to be random numbers.</p> <h4><span onmouseover="document.getElementById('ghlink-definitions-idm6008').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-definitions-idm6008').style.visibility = 'hidden';">Definitions</span></h4> <p>A challenge is a 32-bit integer in big-endian order. Below the function <code class="code">gen_challenge()</code> returns a random 32-bit integer used as a challenge.</p> <p>A digest is a (16 bytes) MD5 hash of the challenge (as text) concatenated with the cookie (as text). Below, the function <code class="code">gen_digest(Challenge, Cookie)</code> generates a digest as described above.</p> <p>An <code class="code">out_cookie</code> is the cookie used in outgoing communication to a certain node, so that <code class="code">A</code>'s <code class="code">out_cookie</code> for <code class="code">B</code> is to correspond with <code class="code">B</code>'s <code class="code">in_cookie</code> for <code class="code">A</code> and conversely. <code class="code">A</code>'s <code class="code">out_cookie</code> for <code class="code">B</code> and <code class="code">A</code>'s <code class="code">in_cookie</code> for <code class="code">B</code> need <strong>not</strong> be the same. Below the function <code class="code">out_cookie(Node)</code> returns the current node's <code class="code">out_cookie</code> for <code class="code">Node</code>.</p> <p>An <code class="code">in_cookie</code> is the cookie expected to be used by another node when communicating with us, so that <code class="code">A</code>'s <code class="code">in_cookie</code> for <code class="code">B</code> corresponds with <code class="code">B</code>'s <code class="code">out_cookie</code> for <code class="code">A</code>. Below the function <code class="code">in_cookie(Node)</code> returns the current node's <code class="code">in_cookie</code> for <code class="code">Node</code>.</p> <p>The cookies are text strings that can be viewed as passwords.</p> <p>Every message in the handshake starts with a 16-bit big-endian integer, which contains the message length (not counting the two initial bytes). In Erlang this corresponds to option <code class="code">{packet, 2}</code> in <code><span class="code">gen_tcp(3)</span></code>. Notice that after the handshake, the distribution switches to 4 byte packet headers.</p> <h4><span onmouseover="document.getElementById('ghlink-the-handshake-in-detail-idm6048').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-the-handshake-in-detail-idm6048').style.visibility = 'hidden';">The Handshake in Detail</span></h4> <p>Imagine two nodes, <code class="code">A</code> that initiates the handshake and <code class="code">B</code> that accepts the connection.</p> <dl> <dt><strong>1) connect/accept</strong></dt> <dd> <p><code class="code">A</code> connects to <code class="code">B</code> through TCP/IP and <code class="code">B</code> accepts the connection.</p> </dd> <dt><strong>2) <code class="code">send_name</code>/<code class="code">receive_name</code></strong></dt> <dd> <p><code class="code">A</code> sends an initial identification to <code class="code">B</code>, which receives the message. The message can have two different formats which looks as follows (the packet headers are removed): </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>2</td> <td>4</td> <td>Nlen</td> </tr> <tr> <td><code class="code">'n'</code></td> <td><code class="code">Version=5</code></td> <td><code class="code">Flags</code></td> <td><code class="code">Name</code></td> </tr> </table> <p class="doc-table-caption">Table 13.17: Old send_name ('n') for protocol version 5</p> </div> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>8</td> <td>4</td> <td>2</td> <td>Nlen</td> </tr> <tr> <td><code class="code">'N'</code></td> <td><code class="code">Flags</code></td> <td><code class="code">Creation</code></td> <td><code class="code">Nlen</code></td> <td><code class="code">Name</code></td> </tr> </table> <p class="doc-table-caption">Table 13.18: New send_name ('N') for protocol version 6</p> </div> <p> The old <code class="code">send_name</code> format is sent from nodes only supporting version 5 or to nodes that might only support version 5. The <code class="code">Version</code> is a 16-bit big endian integer and <strong>must</strong> always have the value 5, even if node <code class="code">A</code> supports version 6. <code class="code">Flags</code> are the <code><a href="#dflags">capability flags</a></code> of node <code class="code">A</code> in 32-bit big endian. The flag bit <code><a href="#DFLAG_HANDSHAKE_23"><span class="code">DFLAG_HANDSHAKE_23</span></a></code> should be set if node <code class="code">A</code> supports version 6. <code class="code">Name</code> is the full node name of <code class="code">A</code>, as a string of bytes (the packet length denotes how long it is). </p> <p> The new <code class="code">send_name</code> is only sent from nodes supporting version 6 to nodes known to support version 6. <code class="code">Flags</code> are the <code><a href="#dflags">capability flags</a></code> of node <code class="code">A</code> in 64-bit big endian. The flag bit <code><a href="#DFLAG_HANDSHAKE_23"><span class="code">DFLAG_HANDSHAKE_23</span></a></code> must always be set. <code class="code">Creation</code> is the node incarnation identifier used by node <code class="code">A</code> to create its pids, ports and references. <code class="code">Name</code> is the full node name of <code class="code">A</code>, as a string of bytes. <code class="code">Nlen</code> is the byte length of the node name in 16-bit big endian. Any extra data after the node <code class="code">Name</code> must be accepted and ignored. </p> </dd> <dt><strong>3) <code class="code">recv_status</code>/<code class="code">send_status</code></strong></dt> <dd> <p> <code class="code">B</code> sends a status message to <code class="code">A</code>, which indicates if the connection is allowed. </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>Slen</td> </tr> <tr> <td><code class="code">'s'</code></td> <td><code class="code">Status</code></td> </tr> </table> <p class="doc-table-caption">Table 13.19: The format of the status message</p> </div> <p> 's' is the message tag. <code class="code">Status</code> is the status code as a string (not null terminated). The following status codes are defined: </p> <dl> <dt><strong><code class="code">ok</code></strong></dt> <dd> <p>The handshake will continue.</p> </dd> <dt><strong><code class="code">ok_simultaneous</code></strong></dt> <dd> <p>The handshake will continue, but <code class="code">A</code> is informed that <code class="code">B</code> has another ongoing connection attempt that will be shut down (simultaneous connect where <code class="code">A</code>'s name is greater than <code class="code">B</code>'s name, compared literally).</p> </dd> <dt><strong><code class="code">nok</code></strong></dt> <dd> <p>The handshake will not continue, as <code class="code">B</code> already has an ongoing handshake, which it itself has initiated (simultaneous connect where <code class="code">B</code>'s name is greater than <code class="code">A</code>'s).</p> </dd> <dt><strong><code class="code">not_allowed</code></strong></dt> <dd> <p>The connection is disallowed for some (unspecified) security reason.</p> </dd> <dt><strong><code class="code">alive</code></strong></dt> <dd> <p>A connection to the node is already active, which either means that node <code class="code">A</code> is confused or that the TCP connection breakdown of a previous node with this name has not yet reached node <code class="code">B</code>. See step 3B below.</p> </dd> <dt><strong><code class="code">named:</code></strong></dt> <dd> <p> The handshake willl continue, but <code class="code">A</code> requested a dynamic node name by setting flag <code><a href="#DFLAG_NAME_ME"> <span class="code">DFLAG_NAME_ME</span></a></code>. The dynamic node name of <code class="code">A</code> is supplied at the end of the status message from <code class="code">B</code>.</p> </dd> </dl> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>Slen=6</td> <td>2</td> <td>Nlen</td> </tr> <tr> <td><code class="code">'s'</code></td> <td><code class="code">Status='named:'</code></td> <td><code class="code">Nlen</code></td> <td><code class="code">Name</code></td> </tr> </table> <p class="doc-table-caption">Table 13.20: The format of the 'named:' status message</p> </div> <p> <code class="code">Name</code> is the full dynamic node name of <code class="code">A</code>, as a string of bytes. <code class="code">Nlen</code> is the byte length of the node name in 16-bit big endian. Any extra data after the node <code class="code">Name</code> must be accepted and ignored. </p> </dd> <dt><strong>3B) <code class="code">send_status</code>/<code class="code">recv_status</code></strong></dt> <dd> <p>If status was <code class="code">alive</code>, node <code class="code">A</code> answers with another status message containing either <code class="code">true</code>, which means that the connection is to continue (the old connection from this node is broken), or <code class="code">false</code>, which means that the connection is to be closed (the connection attempt was a mistake.</p> </dd> <dt><strong>4) <code class="code">recv_challenge</code>/<code class="code">send_challenge</code></strong></dt> <dd> <p>If the status was <code class="code">ok</code> or <code class="code">ok_simultaneous</code>, the handshake continues with <code class="code">B</code> sending <code class="code">A</code> another message, the challenge. The challenge contains the same type of information as the "name" message initially sent from <code class="code">A</code> to <code class="code">B</code>, plus a 32-bit challenge. The challenge message can have two different formats: </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>2</td> <td>4</td> <td>4</td> <td>Nlen</td> </tr> <tr> <td><code class="code">'n'</code></td> <td><code class="code">Version=5</code></td> <td><code class="code">Flags</code></td> <td><code class="code">Challenge</code></td> <td><code class="code">Name</code></td> </tr> </table> <p class="doc-table-caption">Table 13.21: The old challenge message format (version 5)</p> </div> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>8</td> <td>4</td> <td>4</td> <td>2</td> <td>Nlen</td> </tr> <tr> <td><code class="code">'N'</code></td> <td><code class="code">Flags</code></td> <td><code class="code">Challenge</code></td> <td><code class="code">Creation</code></td> <td><code class="code">Nlen</code></td> <td><code class="code">Name</code></td> </tr> </table> <p class="doc-table-caption">Table 13.22: The new challenge message format (version 6)</p> </div> <p> The old challenge message is sent from old <code class="code">B</code> nodes (supporting only version 5) or if node <code class="code">A</code> had not capability flag <code><a href="#DFLAG_HANDSHAKE_23"><span class="code">DFLAG_HANDSHAKE_23</span></a></code> set. The <code class="code">Version</code> is a 16-bit big endian integer and <code class="code">must</code> always have the value 5. </p> <p> The new challenge message is sent from new <code class="code">B</code> nodes if node <code class="code">A</code> had capability flag <code><a href="#DFLAG_HANDSHAKE_23"> <span class="code">DFLAG_HANDSHAKE_23</span></a></code> set. Any extra data after the node <code class="code">Name</code> must be accepted and ignored. </p> <p> <code class="code">Challenge</code> is a 32-bit big-endian integer. The other fields are node <code class="code">B</code>'s flags, creation and full node name, similar to the <code class="code">send_name</code> message. </p> </dd> <dt><strong>4B) <code class="code">send_complement</code>/<code class="code">recv_complement</code></strong></dt> <dd> <p> The complement message, from <code class="code">A</code> to <code class="code">B</code>, is only sent if node <code class="code">A</code> initially sent an old name message and received back a new challenge message from node <code class="code">B</code>. It contains complementary information missing in the initial old name message from node <code class="code">A</code>. </p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>4</td> <td>4</td> </tr> <tr> <td><code class="code">'c'</code></td> <td><code class="code">FlagsHigh</code></td> <td><code class="code">Creation</code></td> </tr> </table> <p class="doc-table-caption">Table 13.23: The complement message</p> </div> <p> <code class="code">FlagsHigh</code> are the high capability flags (bit 33-64) of node <code class="code">A</code> as a 32-bit big endian integer. <code class="code">Creation</code> is the incarnation identifier of node <code class="code">A</code>. </p> </dd> <dt><strong>5) <code class="code">send_challenge_reply</code>/<code class="code">recv_challenge_reply</code></strong></dt> <dd> <p>Now <code class="code">A</code> has generated a digest and its own challenge. Those are sent together in a package to <code class="code">B</code>:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>4</td> <td>16</td> </tr> <tr> <td><code class="code">'r'</code></td> <td><code class="code">Challenge</code></td> <td><code class="code">Digest</code></td> </tr> </table> <p class="doc-table-caption">Table 13.24: The challenge_reply message</p> </div> <p> <code class="code">Challenge</code> is <code class="code">A</code>'s challenge for <code class="code">B</code> to handle. <code class="code">Digest</code> is the MD5 digest that <code class="code">A</code> constructed from the challenge <code class="code">B</code> sent in the previous step. </p> </dd> <dt><strong>6) <code class="code">recv_challenge_ack</code>/<code class="code">send_challenge_ack</code></strong></dt> <dd> <p><code class="code">B</code> checks that the digest received from <code class="code">A</code> is correct and generates a digest from the challenge received from <code class="code">A</code>. The digest is then sent to <code class="code">A</code>. The message is as follows:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>16</td> </tr> <tr> <td><code class="code">'a'</code></td> <td><code class="code">Digest</code></td> </tr> </table> <p class="doc-table-caption">Table 13.25: The challenge_ack message</p> </div> <p> <code class="code">Digest</code> is the digest calculated by <code class="code">B</code> for <code class="code">A</code>'s challenge. </p> </dd> <dt><strong>7) check</strong></dt> <dd> <p><code class="code">A</code> checks the digest from <code class="code">B</code> and the connection is up.</p> </dd> </dl> <h4><span onmouseover="document.getElementById('ghlink-semigraphic-view-idm6368').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-semigraphic-view-idm6368').style.visibility = 'hidden';">Semigraphic View</span></h4> <pre data-language="erlang">
A (initiator)                                      B (acceptor)

TCP connect ------------------------------------&gt;
                                                   TCP accept

send_name --------------------------------------&gt;
                                                   recv_name

  &lt;---------------------------------------------- send_status
recv_status
(if status was 'alive'
 send_status - - - - - - - - - - - - - - - - - -&gt;
                                                   recv_status)

                          (ChB)                      ChB = gen_challenge()
  &lt;---------------------------------------------- send_challenge
recv_challenge

(if old send_name and new recv_challenge
 send_complement - - - - - - - - - - - - - - - -&gt;
                                                   recv_complement)

ChA = gen_challenge(),
OCA = out_cookie(B),
DiA = gen_digest(ChB, OCA)
                          (ChA, DiA)
send_challenge_reply ---------------------------&gt;
                                                   recv_challenge_reply
                                                   ICB = in_cookie(A),
                                                   check:
                                                   DiA == gen_digest (ChB, ICB)?
                                                   - if OK:
                                                    OCB = out_cookie(A),
                                                    DiB = gen_digest (ChA, OCB)
                          (DiB)
  &lt;----------------------------------------------- send_challenge_ack
recv_challenge_ack                                  DONE
ICA = in_cookie(B),                                - else:
check:                                              CLOSE
DiB == gen_digest(ChA, ICA)?
- if OK:
 DONE
- else:
 CLOSE</pre> <h4> <span onmouseover="document.getElementById('ghlink-distribution-flags-idm6371').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-distribution-flags-idm6371').style.visibility = 'hidden';" id="dflags">Distribution Flags</span> </h4> <p>Early in the distribution handshake the two participating nodes exchange capability flags. This is done in order to determine how the communication between the two nodes should be performed. The intersection of the capabilities presented by the two nodes defines the capabilities that will be used. The following capability flags are defined:</p> <dl> <dt><strong><code class="code">-define(DFLAG_PUBLISHED,16#1).</code></strong></dt> <dd> <p>The node is to be published and part of the global namespace.</p> </dd> <dt><strong><code class="code">-define(DFLAG_ATOM_CACHE,16#2).</code></strong></dt> <dd> <p>The node implements an atom cache (obsolete).</p> </dd> <dt><strong><code class="code">-define(DFLAG_EXTENDED_REFERENCES,16#4).</code></strong></dt> <dd> <p>The node implements extended (3 Ã— 32 bits) references. This is required today. If not present, the connection is refused.</p> </dd> <dt><strong><code class="code">-define(DFLAG_DIST_MONITOR,16#8).</code></strong></dt> <dd> <p>The node implements distributed process monitoring.</p> </dd> <dt><strong><code class="code">-define(DFLAG_FUN_TAGS,16#10).</code></strong></dt> <dd> <p>The node uses separate tag for funs (lambdas) in the distribution protocol.</p> </dd> <dt><strong><code class="code">-define(DFLAG_DIST_MONITOR_NAME,16#20).</code></strong></dt> <dd> <p>The node implements distributed named process monitoring.</p> </dd> <dt><strong><code class="code">-define(DFLAG_HIDDEN_ATOM_CACHE,16#40).</code></strong></dt> <dd> <p>The (hidden) node implements atom cache (obsolete).</p> </dd> <dt><strong><code class="code">-define(DFLAG_NEW_FUN_TAGS,16#80).</code></strong></dt> <dd> <p>The node understands the <code><a href="erl_ext_dist#NEW_FUN_EXT"> <span class="code">NEW_FUN_EXT</span></a></code> tag.</p> </dd> <dt><strong><code class="code">-define(DFLAG_EXTENDED_PIDS_PORTS,16#100).</code></strong></dt> <dd> <p>The node can handle extended pids and ports. This is required today. If not present, the connection is refused.</p> </dd> <dt><strong><code class="code">-define(DFLAG_EXPORT_PTR_TAG,16#200).</code></strong></dt> <dd> <p>The node understands the <code><a href="erl_ext_dist#EXPORT_EXT"> <span class="code">EXPORT_EXT</span></a></code> tag.</p> </dd> <dt><strong><code class="code">-define(DFLAG_BIT_BINARIES,16#400).</code></strong></dt> <dd> <p>The node understands the <code><a href="erl_ext_dist#BIT_BINARY_EXT"> <span class="code">BIT_BINARY_EXT</span></a></code> tag.</p> </dd> <dt><strong><code class="code">-define(DFLAG_NEW_FLOATS,16#800).</code></strong></dt> <dd> <p>The node understands the <code><a href="erl_ext_dist#NEW_FLOAT_EXT"> <span class="code">NEW_FLOAT_EXT</span></a></code> tag.</p> </dd> <dt><strong><code class="code">-define(DFLAG_UNICODE_IO,16#1000).</code></strong></dt>  <dt><strong><code class="code">-define(DFLAG_DIST_HDR_ATOM_CACHE,16#2000).</code></strong></dt> <dd> <p>The node implements atom cache in distribution header.</p> </dd> <dt><strong><code class="code" id="DFLAG_SMALL_ATOM_TAGS">-define(DFLAG_SMALL_ATOM_TAGS, 16#4000).</code></strong></dt> <dd> <p>The node understands the <code><a href="erl_ext_dist#SMALL_ATOM_EXT"> <span class="code">SMALL_ATOM_EXT</span></a></code> tag.</p> </dd> <dt><strong><code class="code" id="DFLAG_UTF8_ATOMS">-define(DFLAG_UTF8_ATOMS, 16#10000).</code></strong></dt> <dd> <p>The node understands UTF-8 atoms encoded with <code><a href="erl_ext_dist#ATOM_UTF8_EXT"> <span class="code">ATOM_UTF8_EXT</span></a></code> and <code><a href="erl_ext_dist#SMALL_ATOM_UTF8_EXT"> <span class="code">SMALL ATOM_UTF8_EXT</span></a></code>.</p> </dd> <dt><strong><code class="code">-define(DFLAG_MAP_TAG, 16#20000).</code></strong></dt> <dd> <p>The node understands the map tag <code><a href="erl_ext_dist#MAP_EXT"><span class="code">MAP_EXT</span></a></code>.</p> </dd> <dt><strong><code class="code" id="DFLAG_BIG_CREATION">-define(DFLAG_BIG_CREATION, 16#40000).</code></strong></dt> <dd> <p>The node understands big node creation tags <code><a href="erl_ext_dist#NEW_PID_EXT"><span class="code">NEW_PID_EXT</span></a></code>, <code><a href="erl_ext_dist#NEW_PORT_EXT"><span class="code">NEW_PORT_EXT</span></a></code> and <code><a href="erl_ext_dist#NEWER_REFERENCE_EXT"><span class="code">NEWER_REFERENCE_EXT</span></a></code>. </p> </dd> <dt><strong><code class="code">-define(DFLAG_SEND_SENDER, 16#80000).</code></strong></dt> <dd> <p> Use the <code class="code">SEND_SENDER</code> <code><a href="#control_message">control message</a></code> instead of the <code class="code">SEND</code> control message and use the <code class="code">SEND_SENDER_TT</code> control message instead of the <code class="code">SEND_TT</code> control message. </p> </dd> <dt><strong><code class="code">-define(DFLAG_BIG_SEQTRACE_LABELS, 16#100000).</code></strong></dt> <dd> <p>The node understands any term as the seqtrace label.</p> </dd> <dt><strong><code class="code">-define(DFLAG_EXIT_PAYLOAD, 16#400000).</code></strong></dt> <dd> <p>Use the <code class="code">PAYLOAD_EXIT</code>, <code class="code">PAYLOAD_EXIT_TT</code>, <code class="code">PAYLOAD_EXIT2</code>, <code class="code">PAYLOAD_EXIT2_TT</code> and <code class="code">PAYLOAD_MONITOR_P_EXIT</code> <code><a href="#control_message">control message</a></code>s instead of the non-PAYLOAD variants.</p> </dd> <dt><strong><code class="code" id="DFLAG_FRAGMENTS">-define(DFLAG_FRAGMENTS, 16#800000).</code></strong></dt> <dd> <p>Use <code><a href="erl_ext_dist#fragments">fragmented</a></code> distribution messages to send large messages.</p> </dd> <dt><strong><code class="code" id="DFLAG_HANDSHAKE_23">-define(DFLAG_HANDSHAKE_23, 16#1000000).</code></strong></dt> <dd> <p>The node supports the new connection setup handshake (version 6) introduced in OTP 23.</p> </dd> <dt><strong><code class="code" id="DFLAG_UNLINK_ID">-define(DFLAG_UNLINK_ID, 16#2000000).</code></strong></dt> <dd> <p>Use the <code><a href="#new_link_protocol">new link protocol</a></code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This flag will become mandatory in OTP 26.</p>
</div> </div> <p>Unless both nodes have set the <code class="code">DFLAG_UNLINK_ID</code> flag, the <code><a href="#old_link_protocol">old link protocol</a></code> will be used as a fallback.</p> </dd> <dt><strong><code class="code" id="DFLAG_SPAWN">-define(DFLAG_SPAWN, (1 bsl 32)).</code></strong></dt> <dd> <p>Set if the <code><a href="#SPAWN_REQUEST"><span class="code">SPAWN_REQUEST</span></a></code>, <code><a href="#SPAWN_REQUEST_TT"><span class="code">SPAWN_REQUEST_TT</span></a></code>, <code><a href="#SPAWN_REPLY"><span class="code">SPAWN_REPLY</span></a></code>, <code><a href="#SPAWN_REPLY_TT"><span class="code">SPAWN_REPLY_TT</span></a></code> control messages are supported.</p> </dd> <dt><strong><code class="code" id="DFLAG_NAME_ME">-define(DFLAG_NAME_ME, (1 bsl 33)).</code></strong></dt> <dd> <p> Dynamic node name. This is not a capability but rather used as a request from the connecting node to receive its node name from the accepting node as part of the handshake.</p> </dd> <dt><strong><code class="code" id="DFLAG_V4_NC">-define(DFLAG_V4_NC, (1 bsl 34)).</code></strong></dt> <dd> <p>The node accepts a larger amount of data in pids, ports and references (node container types version 4). In the pid case full 32-bit <code class="code">ID</code> and <code class="code">Serial</code> fields in <code><a href="erl_ext_dist#NEW_PID_EXT"><span class="code">NEW_PID_EXT</span></a></code>, in the port case a 64-bit integer in <code><a href="erl_ext_dist#V4_PORT_EXT"><span class="code">V4_PORT_EXT</span></a></code>, and in the reference case up to 5 32-bit ID words are now accepted in <code><a href="erl_ext_dist#NEWER_REFERENCE_EXT"><span class="code">NEWER_REFERENCE_EXT</span></a></code>. Introduced in OTP 24.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This flag will become mandatory in OTP 26.</p>
</div> </div> </dd> <dt><strong><code class="code" id="DFLAG_ALIAS">-define(DFLAG_ALIAS, (1 bsl 35)).</code></strong></dt> <dd> <p>The node supports process alias and can by this handle the <code><a href="#ALIAS_SEND"><span class="code">ALIAS_SEND</span></a></code> and <code><a href="#ALIAS_SEND_TT"><span class="code">ALIAS_SEND_TT</span></a></code> control messages. Introduced in OTP 24.</p> </dd> </dl> <p> There is also function <code class="code">dist_util:strict_order_flags/0</code> returning all flags (bitwise or:ed together) corresponding to features that require strict ordering of data over distribution channels. </p> <h2> <span onmouseover="document.getElementById('ghlink-protocol-between-connected-nodes-idm6561').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-protocol-between-connected-nodes-idm6561').style.visibility = 'hidden';" id="connected_nodes">13.3 Protocol between Connected Nodes</span> </h2> <p>Since ERTS 5.7.2 (OTP R13B) the runtime system passes a distribution flag in the handshake stage that enables the use of a <code><a href="erl_ext_dist#distribution_header">distribution header </a></code> on all messages passed. Messages passed between nodes have in this case the following format:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>4</td> <td>d</td> <td>n</td> <td>m</td> </tr> <tr> <td><code class="code">Length</code></td> <td><code class="code">DistributionHeader</code></td> <td><code class="code">ControlMessage</code></td> <td><code class="code">Message</code></td> </tr> </table> <p class="doc-table-caption">Table 13.26: Format of Messages Passed between Nodes (as from ERTS 5.7.2 (OTP R13B)) </p> </div> <dl> <dt><strong><code class="code">Length</code></strong></dt> <dd> <p>Equal to d + n + m.</p> </dd> <dt><strong><code class="code">DistributionHeader</code></strong></dt> <dd> <p> <code><a href="erl_ext_dist#distribution_header">Distribution header describing the atom cache and fragmented distribution messages. </a></code> </p> </dd> <dt><strong><code class="code">ControlMessage</code></strong></dt> <dd> <p>A tuple passed using the external format of Erlang.</p> </dd> <dt><strong><code class="code">Message</code></strong></dt> <dd> <p>The message sent to another node using the '!' or the reason for a EXIT, EXIT2 or DOWN signal using the external term format.</p> </dd> </dl> <p>Notice that <code><a href="erl_ext_dist#overall_format">the version number is omitted from the terms that follow a distribution header </a></code>.</p> <p>Nodes with an ERTS version earlier than 5.7.2 (OTP R13B) does not pass the distribution flag that enables the distribution header. Messages passed between nodes have in this case the following format:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>4</td> <td>1</td> <td>n</td> <td>m</td> </tr> <tr> <td><code class="code">Length</code></td> <td><code class="code">Type</code></td> <td><code class="code">ControlMessage</code></td> <td><code class="code">Message</code></td> </tr> </table> <p class="doc-table-caption">Table 13.27: Format of Messages Passed between Nodes (before ERTS 5.7.2 (OTP R13B)) </p> </div> <dl> <dt><strong><code class="code">Length</code></strong></dt> <dd> <p>Equal to 1 + n + m.</p> </dd> <dt><strong><code class="code">Type</code></strong></dt> <dd> <p>Equal to <code class="code">112</code> (pass through).</p> </dd> <dt><strong><code class="code">ControlMessage</code></strong></dt> <dd> <p>A tuple passed using the external format of Erlang.</p> </dd> <dt><strong><code class="code">Message</code></strong></dt> <dd> <p>The message sent to another node using the '!' (in external format). Notice that <code class="code">Message</code> is only passed in combination with a <code class="code">ControlMessage</code> encoding a send ('!').</p> </dd> </dl>  <p id="control_message">The <code class="code">ControlMessage</code> is a tuple, where the first element indicates which distributed operation it encodes:</p> <dl> <dt><strong><code class="code" id="LINK">LINK</code></strong></dt> <dd> <p><code class="code">{1, FromPid, ToPid}</code></p> <p>This signal is sent by <code class="code">FromPid</code> in order to create a link between <code class="code">FromPid</code> and <code class="code">ToPid</code>.</p> </dd> <dt><strong><code class="code">SEND</code></strong></dt> <dd> <p><code class="code">{2, Unused, ToPid}</code></p> <p>Followed by <code class="code">Message</code>.</p> <p><code class="code">Unused</code> is kept for backward compatibility.</p> </dd> <dt><strong><code class="code">EXIT</code></strong></dt> <dd> <p><code class="code">{3, FromPid, ToPid, Reason}</code></p> <p>This signal is sent when a link has been broken</p> </dd> <dt><strong><code class="code" id="UNLINK">UNLINK</code> (deprecated)</strong></dt> <dd> <p><code class="code">{4, FromPid, ToPid}</code></p> <p>This signal is sent by <code class="code">FromPid</code> in order to remove a link between <code class="code">FromPid</code> and <code class="code">ToPid</code>, when using the <code><a href="#old_link_protocol">old link protocol</a></code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This signal has been deprecated and will not be supported in OTP 26. For more information see the documentation of the <code><a href="#new_link_protocol">new link protocol</a></code>. </p>
</div> </div> </dd> <dt><strong><code class="code">NODE_LINK</code></strong></dt> <dd> <p><code class="code">{5}</code></p> </dd> <dt><strong><code class="code">REG_SEND</code></strong></dt> <dd> <p><code class="code">{6, FromPid, Unused, ToName}</code></p> <p>Followed by <code class="code">Message</code>.</p> <p><code class="code">Unused</code> is kept for backward compatibility.</p> </dd> <dt><strong><code class="code">GROUP_LEADER</code></strong></dt> <dd> <p><code class="code">{7, FromPid, ToPid}</code></p> </dd> <dt><strong><code class="code">EXIT2</code></strong></dt> <dd> <p><code class="code">{8, FromPid, ToPid, Reason}</code></p> <p>This signal is sent by a call to the erlang:exit/2 bif</p> </dd> <dt><strong><code class="code">SEND_TT</code></strong></dt> <dd> <p><code class="code">{12, Unused, ToPid, TraceToken}</code></p> <p>Followed by <code class="code">Message</code>.</p> <p><code class="code">Unused</code> is kept for backward compatibility.</p> </dd> <dt><strong><code class="code">EXIT_TT</code></strong></dt> <dd> <p><code class="code">{13, FromPid, ToPid, TraceToken, Reason}</code></p> </dd> <dt><strong><code class="code">REG_SEND_TT</code></strong></dt> <dd> <p><code class="code">{16, FromPid, Unused, ToName, TraceToken}</code></p> <p>Followed by <code class="code">Message</code>.</p> <p><code class="code">Unused</code> is kept for backward compatibility.</p> </dd> <dt><strong><code class="code">EXIT2_TT</code></strong></dt> <dd> <p><code class="code">{18, FromPid, ToPid, TraceToken, Reason}</code></p> </dd> <dt><strong><code class="code">MONITOR_P</code></strong></dt> <dd> <p><code class="code">{19, FromPid, ToProc, Ref}</code>, where <code class="code">FromPid</code> = monitoring process and <code class="code">ToProc</code> = monitored process pid or name (atom)</p> </dd> <dt><strong><code class="code">DEMONITOR_P</code></strong></dt> <dd> <p><code class="code">{20, FromPid, ToProc, Ref}</code>, where <code class="code">FromPid</code> = monitoring process and <code class="code">ToProc</code> = monitored process pid or name (atom)</p> <p>We include <code class="code">FromPid</code> just in case we want to trace this.</p> </dd> <dt><strong><code class="code">MONITOR_P_EXIT</code></strong></dt> <dd> <p><code class="code">{21, FromProc, ToPid, Ref, Reason}</code>, where <code class="code">FromProc</code> = monitored process pid or name (atom), <code class="code">ToPid</code> = monitoring process, and <code class="code">Reason</code> = exit reason for the monitored process</p> </dd> </dl> <h4><span onmouseover="document.getElementById('ghlink-new-ctrlmessages-for-erlang-otp-21-idm6759').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-new-ctrlmessages-for-erlang-otp-21-idm6759').style.visibility = 'hidden';">New Ctrlmessages for Erlang/OTP 21</span></h4> <dl> <dt><strong><code class="code">SEND_SENDER</code></strong></dt> <dd> <p><code class="code">{22, FromPid, ToPid}</code></p> <p>Followed by <code class="code">Message</code>.</p> <p> This control message replaces the <code class="code">SEND</code> control message and will be sent when the distribution flag <code><a href="erl_dist_protocol#dflags"><span class="code">DFLAG_SEND_SENDER</span></a></code> has been negotiated in the connection setup handshake. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> Messages encoded before the connection has been set up may still use the <code class="code">SEND</code> control message. However, once a <code class="code">SEND_SENDER</code> or <code class="code">SEND_SENDER_TT</code> control message has been sent, no more <code class="code">SEND</code> control messages will be sent in the same direction on the connection. </p>
</div> </div> </dd> <dt><strong><code class="code">SEND_SENDER_TT</code></strong></dt> <dd> <p><code class="code">{23, FromPid, ToPid, TraceToken}</code></p> <p>Followed by <code class="code">Message</code>.</p> <p> This control message replaces the <code class="code">SEND_TT</code> control message and will be sent when the distribution flag <code><a href="erl_dist_protocol#dflags"><span class="code">DFLAG_SEND_SENDER</span></a></code> has been negotiated in the connection setup handshake. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> Messages encoded before the connection has been set up may still use the <code class="code">SEND_TT</code> control message. However, once a <code class="code">SEND_SENDER</code> or <code class="code">SEND_SENDER_TT</code> control message has been sent, no more <code class="code">SEND_TT</code> control messages will be sent in the same direction on the connection. </p>
</div> </div> </dd> </dl> <h4><span onmouseover="document.getElementById('ghlink-new-ctrlmessages-for-erlang-otp-22-idm6796').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-new-ctrlmessages-for-erlang-otp-22-idm6796').style.visibility = 'hidden';">New Ctrlmessages for Erlang/OTP 22</span></h4> <div class="note"> <div class="label">Note</div> <div class="content">

<p> Messages encoded before the connection has been set up may still use the non-PAYLOAD variant. However, once a PAYLOAD control message has been sent, no more non-PAYLOAD control messages will be sent in the same direction on the connection. </p>
</div> </div> <dl> <dt><strong><code class="code">PAYLOAD_EXIT</code></strong></dt> <dd> <p><code class="code">{24, FromPid, ToPid}</code></p> <p>Followed by <code class="code">Reason</code>.</p> <p> This control message replaces the <code class="code">EXIT</code> control message and will be sent when the distribution flag <code><a href="erl_dist_protocol#dflags"><span class="code">DFLAG_EXIT_PAYLOAD</span></a></code> has been negotiated in the connection setup handshake. </p> </dd> <dt><strong><code class="code">PAYLOAD_EXIT_TT</code></strong></dt> <dd> <p><code class="code">{25, FromPid, ToPid}</code></p> <p>Followed by <code class="code">Reason</code>.</p> <p> This control message replaces the <code class="code">EXIT_TT</code> control message and will be sent when the distribution flag <code><a href="erl_dist_protocol#dflags"><span class="code">DFLAG_EXIT_PAYLOAD</span></a></code> has been negotiated in the connection setup handshake. </p> </dd> <dt><strong><code class="code">PAYLOAD_EXIT2</code></strong></dt> <dd> <p><code class="code">{26, FromPid, ToPid}</code></p> <p>Followed by <code class="code">Reason</code>.</p> <p> This control message replaces the <code class="code">EXIT2</code> control message and will be sent when the distribution flag <code><a href="erl_dist_protocol#dflags"><span class="code">DFLAG_EXIT_PAYLOAD</span></a></code> has been negotiated in the connection setup handshake. </p> </dd> <dt><strong><code class="code">PAYLOAD_EXIT2_TT</code></strong></dt> <dd> <p><code class="code">{27, FromPid, ToPid}</code></p> <p>Followed by <code class="code">Reason</code>.</p> <p> This control message replaces the <code class="code">EXIT2_TT</code> control message and will be sent when the distribution flag <code><a href="erl_dist_protocol#dflags"><span class="code">DFLAG_EXIT_PAYLOAD</span></a></code> has been negotiated in the connection setup handshake. </p> </dd> <dt><strong><code class="code">PAYLOAD_MONITOR_P_EXIT</code></strong></dt> <dd> <p><code class="code">{28, FromPid, ToPid, Ref}</code></p> <p>Followed by <code class="code">Reason</code>.</p> <p> This control message replaces the <code class="code">MONITOR_P_EXIT</code> control message and will be sent when the distribution flag <code><a href="erl_dist_protocol#dflags"><span class="code">DFLAG_EXIT_PAYLOAD</span></a></code> has been negotiated in the connection setup handshake. </p> </dd> </dl> <h4><span onmouseover="document.getElementById('ghlink-new-ctrlmessages-for-erlang-otp-23-idm6856').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-new-ctrlmessages-for-erlang-otp-23-idm6856').style.visibility = 'hidden';">New Ctrlmessages for Erlang/OTP 23</span></h4> <dl> <dt><strong><code class="code" id="SPAWN_REQUEST">SPAWN_REQUEST</code></strong></dt> <dd> <p><code class="code">{29, ReqId, From, GroupLeader, {Module, Function, Arity}, OptList}</code></p> <p>Followed by <code class="code">ArgList</code>.</p> <p>This signal is sent by the <code><a href="erlang#spawn_request-5"><span class="code">spawn_request()</span></a></code> BIF.</p> <dl> <dt><strong><code class="code">ReqId :: reference()</code></strong></dt> <dd><p>Request identifier. Also used as monitor reference in case the <code class="code">monitor</code> option has been passed.</p></dd> <dt><strong><code class="code">From :: pid()</code></strong></dt> <dd><p>Process identifier of the process making the request. That is, the parent process to be.</p></dd> <dt><strong><code class="code">GroupLeader :: pid()</code></strong></dt> <dd><p>Process identifier of the group leader of the newly created process.</p></dd> <dt><strong><code class="code">{Module :: atom(), Function :: atom(), Arity :: integer() &gt;= 0}</code></strong></dt> <dd><p>Entry point for the the new process.</p></dd> <dt><strong><code class="code">OptList :: [term()]</code></strong></dt> <dd><p>A proper list of spawn options to use when spawning.</p></dd> <dt><strong><code class="code">ArgList :: [term()]</code></strong></dt> <dd><p>A proper list of arguments to use in the call to the entry point.</p></dd> </dl> <p> Only supported when the <code><a href="erl_dist_protocol#DFLAG_SPAWN"><span class="code">DFLAG_SPAWN</span></a></code> <code><a href="erl_dist_protocol#dflags">distribution flag</a></code> has been passed. </p> </dd> <dt><strong><code class="code" id="SPAWN_REQUEST_TT">SPAWN_REQUEST_TT</code></strong></dt> <dd> <p><code class="code">{30, ReqId, From, GroupLeader, {Module, Function, Arity}, OptList, Token}</code></p> <p>Followed by <code class="code">ArgList</code>.</p> <p>Same as <code><a href="#SPAWN_REQUEST"><span class="code">SPAWN_REQUEST</span></a></code>, but also with a sequential trace <code class="code">Token</code>. </p> <p> Only supported when the <code><a href="erl_dist_protocol#DFLAG_SPAWN"><span class="code">DFLAG_SPAWN</span></a></code> <code><a href="erl_dist_protocol#dflags">distribution flag</a></code> has been passed. </p> </dd> <dt><strong><code class="code" id="SPAWN_REPLY">SPAWN_REPLY</code></strong></dt> <dd> <p><code class="code">{31, ReqId, To, Flags, Result}</code></p> <p>This signal is sent as a reply to a process previously sending a <code><a href="#SPAWN_REQUEST"><span class="code">SPAWN_REQUEST</span></a></code> signal.</p> <dl> <dt><strong><code class="code">ReqId :: reference()</code></strong></dt> <dd><p>Request identifier. Also used as monitor reference in case the <code class="code">monitor</code> option has been passed.</p></dd> <dt><strong><code class="code">To :: pid()</code></strong></dt> <dd><p>Process identifier of the process making the spawn request.</p></dd> <dt><strong><code class="code">Flags :: integer() &gt;= 0</code></strong></dt> <dd> <p>A bit flag field of bit flags bitwise or:ed together. Currently the following flags are defined:</p> <dl> <dt><strong><code class="code">1</code></strong></dt> <dd><p>A link between <code class="code">To</code> and <code class="code">Result</code> was set up on the node where <code class="code">Result</code> resides.</p></dd> <dt><strong><code class="code">2</code></strong></dt> <dd><p>A monitor from <code class="code">To</code> to <code class="code">Result</code> was set up on the node where <code class="code">Result</code> resides.</p></dd> </dl> </dd> <dt><strong><code class="code">Result :: pid() | atom()</code></strong></dt> <dd><p>Result of the operation. If <code class="code">Result</code> is a process identifier, the operation succeeded and the process identifier is the identifier of the newly created process. If <code class="code">Result</code> is an atom, the operation failed and the atom identifies failure reason.</p></dd> </dl> <p> Only supported when the <code><a href="erl_dist_protocol#DFLAG_SPAWN"><span class="code">DFLAG_SPAWN</span></a></code> <code><a href="erl_dist_protocol#dflags">distribution flag</a></code> has been passed. </p> </dd> <dt><strong><code class="code" id="SPAWN_REPLY_TT">SPAWN_REPLY_TT</code></strong></dt> <dd> <p><code class="code">{32, ReqId, To, Flags, Result, Token}</code></p> <p>Same as <code><a href="#SPAWN_REPLY"><span class="code">SPAWN_REPLY</span></a></code>, but also with a sequential trace <code class="code">Token</code>.</p> <p> Only supported when the <code><a href="erl_dist_protocol#DFLAG_SPAWN"><span class="code">DFLAG_SPAWN</span></a></code> <code><a href="erl_dist_protocol#dflags">distribution flag</a></code> has been passed. </p> </dd> <dt><strong><code class="code" id="UNLINK_ID">UNLINK_ID</code></strong></dt> <dd> <p><code class="code">{35, Id, FromPid, ToPid}</code></p> <p>This signal is sent by <code class="code">FromPid</code> in order to remove a link between <code class="code">FromPid</code> and <code class="code">ToPid</code>. This unlink signal replaces the <code><a href="#UNLINK"><span class="code">UNLINK</span></a></code> signal. Besides process identifiers of the sender and receiver the <code class="code">UNLINK_ID</code> signal also contains an integer identifier <code class="code">Id</code>. Valid range of <code class="code">Id</code> is <code class="code">[1, (1 bsl 64) - 1]</code>. <code class="code">Id</code> is to be passed back to the sender by the receiver in an <code><a href="#UNLINK_ID_ACK"><span class="code">UNLINK_ID_ACK</span></a></code> signal. <code class="code">Id</code> must uniquely identify the <code class="code">UNLINK_ID</code> signal among all not yet acknowledged <code class="code">UNLINK_ID</code> signals from <code class="code">FromPid</code> to <code class="code">ToPid</code>.</p> <p> This signal is only passed when the <code><a href="#new_link_protocol">new link protocol</a></code> has been negotiated using the <code><a href="erl_dist_protocol#DFLAG_UNLINK_ID"><span class="code">DFLAG_UNLINK_ID</span></a></code> <code><a href="erl_dist_protocol#dflags">distribution flag</a></code>. </p> </dd> <dt><strong><code class="code" id="UNLINK_ID_ACK">UNLINK_ID_ACK</code></strong></dt> <dd> <p><code class="code">{36, Id, FromPid, ToPid}</code></p> <p>An unlink acknowledgement signal. This signal is sent as an acknowledgement of the reception of an <code><a href="#UNLINK_ID"><span class="code">UNLINK_ID</span></a></code> signal. The <code class="code">Id</code> element should be the same <code class="code">Id</code> as present in the <code class="code">UNLINK_ID</code> signal. <code class="code">FromPid</code> identifies the sender of the <code class="code">UNLINK_ID_ACK</code> signal and <code class="code">ToPid</code> identifies the sender of the <code class="code">UNLINK_ID</code> signal.</p> <p> This signal is only passed when the <code><a href="#new_link_protocol">new link protocol</a></code> has been negotiated using the <code><a href="erl_dist_protocol#DFLAG_UNLINK_ID"><span class="code">DFLAG_UNLINK_ID</span></a></code> <code><a href="erl_dist_protocol#dflags">distribution flag</a></code>. </p> </dd> </dl> <h4><span onmouseover="document.getElementById('ghlink-new-ctrlmessages-for-erlang-otp-24-idm7028').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-new-ctrlmessages-for-erlang-otp-24-idm7028').style.visibility = 'hidden';">New Ctrlmessages for Erlang/OTP 24</span></h4> <dl> <dt><strong><code class="code" id="ALIAS_SEND">ALIAS_SEND</code></strong></dt> <dd> <p><code class="code">{33, FromPid, Alias}</code></p> <p>Followed by <code class="code">Message</code>.</p> <p> This control message is used when sending the message <code class="code">Message</code> to the process identified by the process alias <code class="code">Alias</code>. Nodes that can handle this control message sets the distribution flag <code><a href="erl_dist_protocol#dflags"><span class="code">DFLAG_ALIAS</span></a></code> in the connection setup handshake. </p> </dd> <dt><strong><code class="code" id="ALIAS_SEND_TT">ALIAS_SEND_TT</code></strong></dt> <dd> <p><code class="code">{34, FromPid, Alias, Token}</code></p> <p>Followed by <code class="code">Message</code>.</p> <p>Same as <code><a href="#ALIAS_SEND"><span class="code">ALIAS_SEND</span></a></code>, but also with a sequential trace <code class="code">Token</code>.</p> </dd> </dl> <h4> <span onmouseover="document.getElementById('ghlink-link-protocol-idm7056').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-link-protocol-idm7056').style.visibility = 'hidden';" id="link_protocol">Link Protocol</span> </h4> <h5 id="new_link_protocol"> New Link Protocol</h5> <p> The new link protocol will be used when both nodes flag that they understand it using the <code><a href="#DFLAG_UNLINK_ID"><span class="code">DFLAG_UNLINK_ID</span></a></code> <code><a href="#dflags">distribution flag</a></code>. If one of the nodes does not understand the new link protocol, the <code><a href="#old_link_protocol">old link protocol</a></code> will be used as a fallback. </p> <p> The new link protocol introduces two new signals, <code><a href="#UNLINK_ID"><span class="code">UNLINK_ID</span></a></code> and <code><a href="#UNLINK_ID"><span class="code">UNLINK_ID_ACK</span></a></code>, which replace the old <code><a href="#UNLINK"><span class="code">UNLINK</span></a></code> signal. The old <code><a href="#LINK"><span class="code">LINK</span></a></code> signal is still sent in order to set up a link, but handled differently upon reception. </p> <p> In order to set up a link, a <code class="code">LINK</code> signal is sent, from the process initiating the operation, to the process that it wants to link to. In order to remove a link, an <code class="code">UNLINK_ID</code> signal is sent, from the process initiating the operation, to the linked process. The receiver of an <code class="code">UNLINK_ID</code> signal responds with an <code class="code">UNLINK_ID_ACK</code> signal. Upon reception of an <code class="code">UNLINK_ID</code> signal, the corresponding <code class="code">UNLINK_ID_ACK</code> signal <strong>must</strong> be sent before any other signals are sent to the sender of the <code class="code">UNLINK_ID</code> signal. Together with <code>the signal ordering guarantee</code> of Erlang this makes it possible for the sender of the <code class="code">UNLINK_ID</code> signal to know the order of other signals which is essential for the protocol. The <code class="code">UNLINK_ID_ACK</code> signal should contain the same <code class="code">Id</code> as the <code class="code">Id</code> contained in the <code class="code">UNLINK_ID</code> signal being acknowledged. </p> <p> Processes also need to maintain process local information about links. The state of this process local information is changed when the signals above are sent and received. This process local information also determines if a signal should be sent when a process calls <code><a href="erlang#link-1"><span class="code">link/1</span></a></code> or <code><a href="erlang#unlink-1"><span class="code">unlink/1</span></a></code>. A <code class="code">LINK</code> signal is only sent if there does not currently exist an active link between the processes according to the process local information and an <code class="code">UNLINK_ID</code> signal is only sent if there currently exists an active link between the processes according to the process local information. </p> <p> The process local information about a link contains: </p> <dl> <dt><strong>Pid</strong></dt> <dd> Process identifier of the linked process. </dd> <dt><strong>Active Flag</strong></dt> <dd> If set, the link is active and the process will react on <code>incoming exit signals</code> issued due to the link. If not set, the link is inactive and incoming exit signals, issued due to the link, will be ignored. That is, the processes are considered as <strong>not</strong> linked. </dd> <dt><strong>Unlink Id</strong></dt> <dd> Identifier of an outstanding unlink operation. That is, an unlink operation that has not yet been acknowledged. This information is only used when the active flag is not set. </dd> </dl> <p> A process is only considered linked to another process if it has process local information about the link containing the process identifier of the other process and with the active flag set. </p> <p> The process local information about a link is updated as follows: </p> <dl> <dt><strong>A <code class="code">LINK</code> signal is sent</strong></dt> <dd> Link information is created if not already existing. The active flag is set, and unlink id is cleared. That is, if we had an outstanding unlink operation we will ignore the result of that operation and enable the link. </dd> <dt><strong>A <code class="code">LINK</code> signal is received</strong></dt> <dd> If no link information already exists, it is created, the active flag is set and unlink id is cleared. If the link information already exists, the signal is silently ignored, regardless of whether the active flag is set or not. That is, if we have an outstanding unlink operation we will <strong>not</strong> activate the link. In this scenario, the sender of the <code class="code">LINK</code> signal has not yet sent an <code class="code">UNLINK_ID_ACK</code> signal corresponding to our <code class="code">UNLINK_ID</code> signal which means that it will receive our <code class="code">UNLINK_ID</code> signal after it sent its <code class="code">LINK</code> signal. This in turn means that both processes in the end will agree that there is no link between them. </dd> <dt><strong>An <code class="code">UNLINK_ID</code> signal is sent</strong></dt> <dd> Link information already exists and the active flag is set (otherwise the signal would not be sent). The active flag is unset, and the unlink id of the signal is saved in the link information. </dd> <dt><strong>An <code class="code">UNLINK_ID</code> signal is received</strong></dt> <dd> If the active flag is set, information about the link is removed. If the active flag is not set (that is, we have an outstanding unlink operation), the information about the link is left unchanged. </dd> <dt><strong>An <code class="code">UNLINK_ID_ACK</code> signal is sent</strong></dt> <dd> This is done when an <code class="code">UNLINK_ID</code> signal is received and causes no further changes of the link information. </dd> <dt><strong>An <code class="code">UNLINK_ID_ACK</code> signal is received</strong></dt> <dd> If information about the link exists, the active flag is not set, and the unlink id in the link information equals the <code class="code">Id</code> in the signal, the link information is removed; otherwise, the signal is ignored. </dd> </dl> <p> When a process receives an exit signal due to a link, the process will first react to the exit signal if the link is active and then remove the process local information about the link. </p> <p> In case the connection is lost between two nodes, exit signals with exit reason <code class="code">noconnection</code> are sent to all processes with links over the connection. This will cause all process local information about links over the connection to be removed. </p> <p> Exactly the same link protocol is also used internally on an Erlang node. The signals however have different formats since they do not have to be sent over the wire. </p> <h5 id="old_link_protocol"> Old Link Protocol</h5> <p> The old link protocol utilize two signals <code><a href="#LINK"><span class="code">LINK</span></a></code>, and <code><a href="#UNLINK"><span class="code">UNLINK</span></a></code>. The <code class="code">LINK</code> signal informs the other process that a link should be set up, and the <code class="code">UNLINK</code> signal informs the other process that a link should be removed. This protocol is however a bit too naive. If both processes operate on the link simultaneously, the link may end up in an inconsistent state where one process thinks it is linked while the other thinks it is not linked. </p> <p> This protocol is deprecated and support for it will be removed in OTP 26. Until then, it will be used as fallback when communicating with old nodes that do not understand the <code><a href="#new_link_protocol">new link protocol</a></code>. </p> </div> <div class="footer"> <hr> <p>Copyright Â© 1997-2021 Ericsson AB. All Rights Reserved.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2021 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
