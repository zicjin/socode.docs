<div class="innertube"> <h1>4 Match Specifications in Erlang</h1> <p>A "match specification" (<code class="code">match_spec</code>) is an Erlang term describing a small "program" that tries to match something. It can be used to either control tracing with <code><a href="erlang#trace_pattern-3">erlang:trace_pattern/3</a></code> or to search for objects in an ETS table with for example <code>ets:select/2</code>. The match specification in many ways works like a small function in Erlang, but is interpreted/compiled by the Erlang runtime system to something much more efficient than calling an Erlang function. The match specification is also very limited compared to the expressiveness of real Erlang functions.</p> <p>The most notable difference between a match specification and an Erlang fun is the syntax. Match specifications are Erlang terms, not Erlang code. Also, a match specification has a strange concept of exceptions:</p> <ul> <li> <p>An exception (such as <code class="code">badarg</code>) in the <code class="code">MatchCondition</code> part, which resembles an Erlang guard, generates immediate failure.</p> </li> <li> <p>An exception in the <code class="code">MatchBody</code> part, which resembles the body of an Erlang function, is implicitly caught and results in the single atom <code class="code">'EXIT'</code>.</p> </li> </ul> <h2><span onmouseover="document.getElementById('ghlink-grammar-idm623').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-grammar-idm623').style.visibility = 'hidden';">4.1 Grammar</span></h2> <p>A match specification used in tracing can be described in the following <strong>informal</strong> grammar:</p> <ul> <li>MatchExpression ::= [ MatchFunction, ... ] </li> <li>MatchFunction ::= { MatchHead, MatchConditions, MatchBody } </li> <li>MatchHead ::= MatchVariable | <code class="code">'_'</code> | [ MatchHeadPart, ... ] </li> <li>MatchHeadPart ::= term() | MatchVariable | <code class="code">'_'</code> </li> <li>MatchVariable ::= '$&lt;number&gt;' </li> <li>MatchConditions ::= [ MatchCondition, ...] | <code class="code">[]</code> </li> <li>MatchCondition ::= { GuardFunction } | { GuardFunction, ConditionExpression, ... } </li> <li>BoolFunction ::= <code class="code">is_atom</code> | <code class="code">is_float</code> | <code class="code">is_integer</code> | <code class="code">is_list</code> | <code class="code">is_number</code> | <code class="code">is_pid</code> | <code class="code">is_port</code> | <code class="code">is_reference</code> | <code class="code">is_tuple</code> | <code class="code">is_map</code> | <code class="code">is_map_key</code> | <code class="code">is_binary</code> | <code class="code">is_function</code> | <code class="code">is_record</code> | <code class="code">is_seq_trace</code> | <code class="code">'and'</code> | <code class="code">'or'</code> | <code class="code">'not'</code> | <code class="code">'xor'</code> | <code class="code">'andalso'</code> | <code class="code">'orelse'</code> </li> <li>ConditionExpression ::= ExprMatchVariable | { GuardFunction } | { GuardFunction, ConditionExpression, ... } | TermConstruct </li> <li>ExprMatchVariable ::= MatchVariable (bound in the MatchHead) | <code class="code">'$_'</code> | <code class="code">'$$'</code> </li> <li>TermConstruct = {{}} | {{ ConditionExpression, ... }} | <code class="code">[]</code> | [ConditionExpression, ...] | <code class="code">#{}</code> | #{term() =&gt; ConditionExpression, ...} | NonCompositeTerm | Constant </li> <li>NonCompositeTerm ::= term() (not list or tuple or map) </li> <li>Constant ::= {<code class="code">const</code>, term()} </li> <li>GuardFunction ::= BoolFunction | <code class="code">abs</code> | <code class="code">element</code> | <code class="code">hd</code> | <code class="code">length</code> | <code class="code">map_get</code> | <code class="code">map_size</code> | <code class="code">node</code> | <code class="code">round</code> | <code class="code">size</code> | <code class="code">bit_size</code> | <code class="code">tl</code> | <code class="code">trunc</code> | <code class="code">'+'</code> | <code class="code">'-'</code> | <code class="code">'*'</code> | <code class="code">'div'</code> | <code class="code">'rem'</code> | <code class="code">'band'</code> | <code class="code">'bor'</code> | <code class="code">'bxor'</code> | <code class="code">'bnot'</code> | <code class="code">'bsl'</code> | <code class="code">'bsr'</code> | <code class="code">'&gt;'</code> | <code class="code">'&gt;='</code> | <code class="code">'&lt;'</code> | <code class="code">'=&lt;'</code> | <code class="code">'=:='</code> | <code class="code">'=='</code> | <code class="code">'=/='</code> | <code class="code">'/='</code> | <code class="code">self</code> | <code class="code">get_tcw</code> </li> <li>MatchBody ::= [ ActionTerm ] </li> <li>ActionTerm ::= ConditionExpression | ActionCall </li> <li>ActionCall ::= {ActionFunction} | {ActionFunction, ActionTerm, ...} </li> <li>ActionFunction ::= <code class="code">set_seq_token</code> | <code class="code">get_seq_token</code> | <code class="code">message</code> | <code class="code">return_trace</code> | <code class="code">exception_trace</code> | <code class="code">process_dump</code> | <code class="code">enable_trace</code> | <code class="code">disable_trace</code> | <code class="code">trace</code> | <code class="code">display</code> | <code class="code">caller</code> | <code class="code">set_tcw</code> | <code class="code">silent</code> </li> </ul> <p>A match specification used in <code><span class="code">ets(3)</span></code> can be described in the following <strong>informal</strong> grammar:</p> <ul> <li>MatchExpression ::= [ MatchFunction, ... ] </li> <li>MatchFunction ::= { MatchHead, MatchConditions, MatchBody } </li> <li>MatchHead ::= MatchVariable | <code class="code">'_'</code> | { MatchHeadPart, ... } </li> <li>MatchHeadPart ::= term() | MatchVariable | <code class="code">'_'</code> </li> <li>MatchVariable ::= '$&lt;number&gt;' </li> <li>MatchConditions ::= [ MatchCondition, ...] | <code class="code">[]</code> </li> <li>MatchCondition ::= { GuardFunction } | { GuardFunction, ConditionExpression, ... } </li> <li>BoolFunction ::= <code class="code">is_atom</code> | <code class="code">is_float</code> | <code class="code">is_integer</code> | <code class="code">is_list</code> | <code class="code">is_number</code> | <code class="code">is_pid</code> | <code class="code">is_port</code> | <code class="code">is_reference</code> | <code class="code">is_tuple</code> | <code class="code">is_map</code> | <code class="code">map_is_key</code> | <code class="code">is_binary</code> | <code class="code">is_function</code> | <code class="code">is_record</code> | <code class="code">'and'</code> | <code class="code">'or'</code> | <code class="code">'not'</code> | <code class="code">'xor'</code> | <code class="code">'andalso'</code> | <code class="code">'orelse'</code> </li> <li>ConditionExpression ::= ExprMatchVariable | { GuardFunction } | { GuardFunction, ConditionExpression, ... } | TermConstruct </li> <li>ExprMatchVariable ::= MatchVariable (bound in the MatchHead) | <code class="code">'$_'</code> | <code class="code">'$$'</code> </li> <li>TermConstruct = {{}} | {{ ConditionExpression, ... }} | <code class="code">[]</code> | [ConditionExpression, ...] | #{} | #{term() =&gt; ConditionExpression, ...} | NonCompositeTerm | Constant </li> <li>NonCompositeTerm ::= term() (not list or tuple or map) </li> <li>Constant ::= {<code class="code">const</code>, term()} </li> <li>GuardFunction ::= BoolFunction | <code class="code">abs</code> | <code class="code">element</code> | <code class="code">hd</code> | <code class="code">length</code> | <code class="code">map_get</code> | <code class="code">map_size</code> | <code class="code">node</code> | <code class="code">round</code> | <code class="code">size</code> | <code class="code">bit_size</code> | <code class="code">tl</code> | <code class="code">trunc</code> | <code class="code">'+'</code> | <code class="code">'-'</code> | <code class="code">'*'</code> | <code class="code">'div'</code> | <code class="code">'rem'</code> | <code class="code">'band'</code> | <code class="code">'bor'</code> | <code class="code">'bxor'</code> | <code class="code">'bnot'</code> | <code class="code">'bsl'</code> | <code class="code">'bsr'</code> | <code class="code">'&gt;'</code> | <code class="code">'&gt;='</code> | <code class="code">'&lt;'</code> | <code class="code">'=&lt;'</code> | <code class="code">'=:='</code> | <code class="code">'=='</code> | <code class="code">'=/='</code> | <code class="code">'/='</code> | <code class="code">self</code> </li> <li>MatchBody ::= [ ConditionExpression, ... ] </li> </ul> <h2><span onmouseover="document.getElementById('ghlink-function-descriptions-idm800').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-function-descriptions-idm800').style.visibility = 'hidden';">4.2 Function Descriptions</span></h2> <h4><span onmouseover="document.getElementById('ghlink-functions-allowed-in-all-types-of-match-specifications-idm802').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-functions-allowed-in-all-types-of-match-specifications-idm802').style.visibility = 'hidden';">Functions Allowed in All Types of Match Specifications</span></h4> <p>The functions allowed in <code class="code">match_spec</code> work as follows:</p> <dl> <dt><strong><code class="code">is_atom</code>, <code class="code">is_float</code>, <code class="code">is_integer</code>, <code class="code">is_list</code>, <code class="code">is_number</code>, <code class="code">is_pid</code>, <code class="code">is_port</code>, <code class="code">is_reference</code>, <code class="code">is_tuple</code>, <code class="code">is_map</code>, <code class="code">is_binary</code>, <code class="code">is_function</code> </strong></dt> <dd> <p>Same as the corresponding guard tests in Erlang, return <code class="code">true</code> or <code class="code">false</code>.</p> </dd> <dt><strong><code class="code">is_record</code></strong></dt> <dd> <p>Takes an additional parameter, which <strong>must</strong> be the result of <code class="code">record_info(size, &lt;record_type&gt;)</code>, like in <code class="code">{is_record, '$1', rectype, record_info(size, rectype)}</code>.</p> </dd> <dt><strong><code class="code">'not'</code></strong></dt> <dd> <p>Negates its single argument (anything other than <code class="code">false</code> gives <code class="code">false</code>).</p> </dd> <dt><strong><code class="code">'and'</code></strong></dt> <dd> <p>Returns <code class="code">true</code> if all its arguments (variable length argument list) evaluate to <code class="code">true</code>, otherwise <code class="code">false</code>. Evaluation order is undefined.</p> </dd> <dt><strong><code class="code">'or'</code></strong></dt> <dd> <p>Returns <code class="code">true</code> if any of its arguments evaluates to <code class="code">true</code>. Variable length argument list. Evaluation order is undefined.</p> </dd> <dt><strong><code class="code">'andalso'</code></strong></dt> <dd> <p>Works as <code class="code">'and'</code>, but quits evaluating its arguments when one argument evaluates to something else than <code class="code">true</code>. Arguments are evaluated left to right.</p> </dd> <dt><strong><code class="code">'orelse'</code></strong></dt> <dd> <p>Works as <code class="code">'or'</code>, but quits evaluating as soon as one of its arguments evaluates to <code class="code">true</code>. Arguments are evaluated left to right.</p> </dd> <dt><strong><code class="code">'xor'</code></strong></dt> <dd> <p>Only two arguments, of which one must be <code class="code">true</code> and the other <code class="code">false</code> to return <code class="code">true</code>; otherwise <code class="code">'xor'</code> returns false.</p> </dd> <dt><strong><code class="code">abs</code>, <code class="code">element</code>, <code class="code">hd</code>, <code class="code">length</code>, <code class="code">map_get</code>, <code class="code">map_size</code>, <code class="code">node</code>, <code class="code">round</code>, <code class="code">size</code>, <code class="code">bit_size</code>, <code class="code">tl</code>, <code class="code">trunc</code>, <code class="code">'+'</code>, <code class="code">'-'</code>, <code class="code">'*'</code>, <code class="code">'div'</code>, <code class="code">'rem'</code>, <code class="code">'band'</code>, <code class="code">'bor'</code>, <code class="code">'bxor'</code>, <code class="code">'bnot'</code>, <code class="code">'bsl'</code>, <code class="code">'bsr'</code>, <code class="code">'&gt;'</code>, <code class="code">'&gt;='</code>, <code class="code">'&lt;'</code>, <code class="code">'=&lt;'</code>, <code class="code">'=:='</code>, <code class="code">'=='</code>, <code class="code">'=/='</code>, <code class="code">'/='</code>, <code class="code">self</code></strong></dt> <dd> <p>Same as the corresponding Erlang BIFs (or operators). In case of bad arguments, the result depends on the context. In the <code class="code">MatchConditions</code> part of the expression, the test fails immediately (like in an Erlang guard). In the <code class="code">MatchBody</code> part, exceptions are implicitly caught and the call results in the atom <code class="code">'EXIT'</code>.</p> </dd> </dl> <h4><span onmouseover="document.getElementById('ghlink-functions-allowed-only-for-tracing-idm908').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-functions-allowed-only-for-tracing-idm908').style.visibility = 'hidden';">Functions Allowed Only for Tracing</span></h4> <p>The functions allowed only for tracing work as follows:</p> <dl> <dt><strong><code class="code">is_seq_trace</code></strong></dt> <dd> <p>Returns <code class="code">true</code> if a sequential trace token is set for the current process, otherwise <code class="code">false</code>.</p> </dd> <dt><strong><code class="code">set_seq_token</code></strong></dt> <dd> <p>Works as <code class="code">seq_trace:set_token/2</code>, but returns <code class="code">true</code> on success, and <code class="code">'EXIT'</code> on error or bad argument. Only allowed in the <code class="code">MatchBody</code> part and only allowed when tracing.</p> </dd> <dt><strong><code class="code">get_seq_token</code></strong></dt> <dd> <p>Same as <code class="code">seq_trace:get_token/0</code> and only allowed in the <code class="code">MatchBody</code> part when tracing.</p> </dd> <dt><strong><code class="code">message</code></strong></dt> <dd> <p>Sets an additional message appended to the trace message sent. One can only set one additional message in the body. Later calls replace the appended message.</p> <p>As a special case, <code class="code">{message, false}</code> disables sending of trace messages ('call' and 'return_to') for this function call, just like if the match specification had not matched. This can be useful if only the side effects of the <code class="code">MatchBody</code> part are desired.</p> <p>Another special case is <code class="code">{message, true}</code>, which sets the default behavior, as if the function had no match specification; trace message is sent with no extra information (if no other calls to <code class="code">message</code> are placed before <code class="code">{message, true}</code>, it is in fact a "noop").</p> <p>Takes one argument: the message. Returns <code class="code">true</code> and can only be used in the <code class="code">MatchBody</code> part and when tracing.</p> </dd> <dt><strong><code class="code">return_trace</code></strong></dt> <dd> <p>Causes a <code class="code">return_from</code> trace message to be sent upon return from the current function. Takes no arguments, returns <code class="code">true</code> and can only be used in the <code class="code">MatchBody</code> part when tracing. If the process trace flag <code class="code">silent</code> is active, the <code class="code">return_from</code> trace message is inhibited.</p> <p><strong>Warning:</strong> If the traced function is tail-recursive, this match specification function destroys that property. Hence, if a match specification executing this function is used on a perpetual server process, it can only be active for a limited period of time, or the emulator will eventually use all memory in the host machine and crash. If this match specification function is inhibited using process trace flag <code class="code">silent</code>, tail-recursiveness still remains.</p> </dd> <dt><strong><code class="code">exception_trace</code></strong></dt> <dd> <p>Works as <code class="code">return_trace</code> plus; if the traced function exits because of an exception, an <code class="code">exception_from</code> trace message is generated, regardless of the exception is caught or not.</p> </dd> <dt><strong><code class="code">process_dump</code></strong></dt> <dd> <p>Returns some textual information about the current process as a binary. Takes no arguments and is only allowed in the <code class="code">MatchBody</code> part when tracing.</p> </dd> <dt><strong><code class="code">enable_trace</code></strong></dt> <dd> <p>With one parameter this function turns on tracing like the Erlang call <code class="code">erlang:trace(self(), true, [P2])</code>, where <code class="code">P2</code> is the parameter to <code class="code">enable_trace</code>.</p> <p>With two parameters, the first parameter is to be either a process identifier or the registered name of a process. In this case tracing is turned on for the designated process in the same way as in the Erlang call <code class="code">erlang:trace(P1, true, [P2])</code>, where <code class="code">P1</code> is the first and <code class="code">P2</code> is the second argument. The process <code class="code">P1</code> gets its trace messages sent to the same tracer as the process executing the statement uses. <code class="code">P1</code> <strong>cannot</strong> be one of the atoms <code class="code">all</code>, <code class="code">new</code> or <code class="code">existing</code> (unless they are registered names). <code class="code">P2</code> <strong>cannot</strong> be <code class="code">cpu_timestamp</code> or <code class="code">tracer</code>.</p> <p>Returns <code class="code">true</code> and can only be used in the <code class="code">MatchBody</code> part when tracing.</p> </dd> <dt><strong><code class="code">disable_trace</code></strong></dt> <dd> <p>With one parameter this function disables tracing like the Erlang call <code class="code">erlang:trace(self(), false, [P2])</code>, where <code class="code">P2</code> is the parameter to <code class="code">disable_trace</code>.</p> <p>With two parameters this function works as the Erlang call <code class="code">erlang:trace(P1, false, [P2])</code>, where <code class="code">P1</code> can be either a process identifier or a registered name and is specified as the first argument to the match specification function. <code class="code">P2</code> <strong>cannot</strong> be <code class="code">cpu_timestamp</code> or <code class="code">tracer</code>.</p> <p>Returns <code class="code">true</code> and can only be used in the <code class="code">MatchBody</code> part when tracing.</p> </dd> <dt><strong><code class="code">trace</code></strong></dt> <dd> <p>With two parameters this function takes a list of trace flags to disable as first parameter and a list of trace flags to enable as second parameter. Logically, the disable list is applied first, but effectively all changes are applied atomically. The trace flags are the same as for <code class="code">erlang:trace/3</code>, not including <code class="code">cpu_timestamp</code>, but including <code class="code">tracer</code>.</p> <p>If a tracer is specified in both lists, the tracer in the enable list takes precedence. If no tracer is specified, the same tracer as the process executing the match specification is used (not the meta tracer). If that process doesn't have tracer either, then trace flags are ignored.</p> <p>When using a <code><a href="erl_tracer">tracer module</a></code>, the module must be loaded before the match specification is executed. If it is not loaded, the match fails.</p> <p>With three parameters to this function, the first is either a process identifier or the registered name of a process to set trace flags on, the second is the disable list, and the third is the enable list.</p> <p>Returns <code class="code">true</code> if any trace property was changed for the trace target process, otherwise <code class="code">false</code>. Can only be used in the <code class="code">MatchBody</code> part when tracing.</p> </dd> <dt><strong><code class="code">caller</code></strong></dt> <dd> <p>Returns the calling function as a tuple <code class="code">{Module, Function, Arity}</code> or the atom <code class="code">undefined</code> if the calling function cannot be determined. Can only be used in the <code class="code">MatchBody</code> part when tracing.</p> <p>Notice that if a "technically built in function" (that is, a function not written in Erlang) is traced, the <code class="code">caller</code> function sometimes returns the atom <code class="code">undefined</code>. The calling Erlang function is not available during such calls.</p> </dd> <dt><strong><code class="code">display</code></strong></dt> <dd> <p>For debugging purposes only. Displays the single argument as an Erlang term on <code class="code">stdout</code>, which is seldom what is wanted. Returns <code class="code">true</code> and can only be used in the <code class="code">MatchBody</code> part when tracing.</p> </dd> <dt><strong><code class="code" id="get_tcw">get_tcw</code></strong></dt> <dd> <p>Takes no argument and returns the value of the node's trace control word. The same is done by <code class="code">erlang:system_info(trace_control_word)</code>.</p> <p>The trace control word is a 32-bit unsigned integer intended for generic trace control. The trace control word can be tested and set both from within trace match specifications and with BIFs. This call is only allowed when tracing.</p> </dd> <dt><strong><code class="code" id="set_tcw">set_tcw</code></strong></dt> <dd> <p>Takes one unsigned integer argument, sets the value of the node's trace control word to the value of the argument, and returns the previous value. The same is done by <code class="code">erlang:system_flag(trace_control_word, Value)</code>. It is only allowed to use <code class="code">set_tcw</code> in the <code class="code">MatchBody</code> part when tracing.</p> </dd> <dt><strong><code class="code">silent</code></strong></dt> <dd> <p>Takes one argument. If the argument is <code class="code">true</code>, the call trace message mode for the current process is set to silent for this call and all later calls, that is, call trace messages are inhibited even if <code class="code">{message, true}</code> is called in the <code class="code">MatchBody</code> part for a traced function.</p> <p>This mode can also be activated with flag <code class="code">silent</code> to <code class="code">erlang:trace/3</code>.</p> <p>If the argument is <code class="code">false</code>, the call trace message mode for the current process is set to normal (non-silent) for this call and all later calls.</p> <p>If the argument is not <code class="code">true</code> or <code class="code">false</code>, the call trace message mode is unaffected.</p> </dd> </dl> <div class="note"> <div class="label">Note</div> <div class="content">

<p>All "function calls" must be tuples, even if they take no arguments. The value of <code class="code">self</code> is the atom() <code class="code">self</code>, but the value of <code class="code">{self}</code> is the pid() of the current process.</p> </div> </div> <h2> <span onmouseover="document.getElementById('ghlink-match-target-idm1077').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-match-target-idm1077').style.visibility = 'hidden';" id="match_target">4.3 Match target</span> </h2> <p>Each execution of a match specification is done against a match target term. The format and content of the target term depends on the context in which the match is done. The match target for ETS is always a full table tuple. The match target for call trace is always a list of all function arguments. The match target for event trace depends on the event type, see table below.</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>Context</td> <td>Type</td> <td>Match target</td> <td>Description</td> </tr> <tr> <td>ETS</td> <td></td> <td>{Key, Value1, Value2, ...}</td> <td>A table object</td> </tr> <tr> <td>Trace</td> <td>call</td> <td>[Arg1, Arg2, ...]</td> <td>Function arguments</td> </tr> <tr> <td>Trace</td> <td>send</td> <td>[Receiver, Message]</td> <td>Receiving process/port and message term</td> </tr> <tr> <td>Trace</td> <td>'receive'</td> <td>[Node, Sender, Message]</td> <td>Sending node, process/port and message term</td> </tr> </table> <p class="doc-table-caption">Table 4.1: Match target depending on context</p> </div> <h2><span onmouseover="document.getElementById('ghlink-variables-and-literals-idm1108').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-variables-and-literals-idm1108').style.visibility = 'hidden';">4.4 Variables and Literals</span></h2> <p>Variables take the form <code class="code">'$&lt;number&gt;'</code>, where <code class="code">&lt;number&gt;</code> is an integer between 0 and 100,000,000 (1e+8). The behavior if the number is outside these limits is <strong>undefined</strong>. In the <code class="code">MatchHead</code> part, the special variable <code class="code">'_'</code> matches anything, and never gets bound (like <code class="code">_</code> in Erlang).</p> <ul> <li> <p>In the <code class="code">MatchCondition/MatchBody</code> parts, no unbound variables are allowed, so <code class="code">'_'</code> is interpreted as itself (an atom). Variables can only be bound in the <code class="code">MatchHead</code> part.</p> </li> <li> <p>In the <code class="code">MatchBody</code> and <code class="code">MatchCondition</code> parts, only variables bound previously can be used.</p> </li> <li> <p>As a special case, the following apply in the <code class="code">MatchCondition/MatchBody</code> parts:</p> <ul> <li> <p>The variable <code class="code">'$_'</code> expands to the whole <code><a href="#match_target">match target</a></code> term. </p> </li> <li> <p>The variable <code class="code">'$$'</code> expands to a list of the values of all bound variables in order (that is, <code class="code">['$1','$2', ...]</code>).</p> </li> </ul> </li> </ul> <p>In the <code class="code">MatchHead</code> part, all literals (except the variables above) are interpreted "as is".</p> <p>In the <code class="code">MatchCondition/MatchBody</code> parts, the interpretation is in some ways different. Literals in these parts can either be written "as is", which works for all literals except tuples, or by using the special form <code class="code">{const, T}</code>, where <code class="code">T</code> is any Erlang term.</p> <p>For tuple literals in the match specification, double tuple parentheses can also be used, that is, construct them as a tuple of arity one containing a single tuple, which is the one to be constructed. The "double tuple parenthesis" syntax is useful to construct tuples from already bound variables, like in <code class="code">{{'$1', [a,b,'$2']}}</code>. Examples:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Expression</strong></td> <td><strong>Variable Bindings</strong></td> <td><strong>Result</strong></td> </tr> <tr> <td>{{'$1','$2'}}</td> <td>'$1' = a, '$2' = b</td> <td>{a,b}</td> </tr> <tr> <td>{const, {'$1', '$2'}}</td> <td>Irrelevant</td> <td>{'$1', '$2'}</td> </tr> <tr> <td>a</td> <td>Irrelevant</td> <td>a</td> </tr> <tr> <td>'$1'</td> <td>'$1' = []</td> <td>[]</td> </tr> <tr> <td>['$1']</td> <td>'$1' = []</td> <td>[[]]</td> </tr> <tr> <td>[{{a}}]</td> <td>Irrelevant</td> <td>[{a}]</td> </tr> <tr> <td>42</td> <td>Irrelevant</td> <td>42</td> </tr> <tr> <td>"hello"</td> <td>Irrelevant</td> <td>"hello"</td> </tr> <tr> <td>$1</td> <td>Irrelevant</td> <td>49 (the ASCII value for character '1')</td> </tr> </table> <p class="doc-table-caption">Table 4.2: Literals in MatchCondition/MatchBody Parts of a Match Specification</p> </div> <h2><span onmouseover="document.getElementById('ghlink-execution-of-the-match-idm1192').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-execution-of-the-match-idm1192').style.visibility = 'hidden';">4.5 Execution of the Match</span></h2> <p>The execution of the match expression, when the runtime system decides whether a trace message is to be sent, is as follows:</p> <p>For each tuple in the <code class="code">MatchExpression</code> list and while no match has succeeded:</p> <ol> <li> <p>Match the <code class="code">MatchHead</code> part against the match target term, binding the <code class="code">'$&lt;number&gt;'</code> variables (much like in <code class="code">ets:match/2</code>). If the <code class="code">MatchHead</code> part cannot match the arguments, the match fails.</p> </li> <li> <p>Evaluate each <code class="code">MatchCondition</code> (where only <code class="code">'$&lt;number&gt;'</code> variables previously bound in the <code class="code">MatchHead</code> part can occur) and expect it to return the atom <code class="code">true</code>. When a condition does not evaluate to <code class="code">true</code>, the match fails. If any BIF call generates an exception, the match also fails.</p> </li> <li> <p>Two cases can occur:</p> <ul> <li> <p>If the match specification is executing when tracing:</p> <p>Evaluate each <code class="code">ActionTerm</code> in the same way as the <code class="code">MatchConditions</code>, but ignore the return values. Regardless of what happens in this part, the match has succeeded.</p> </li> <li> <p>If the match specification is executed when selecting objects from an ETS table:</p> <p>Evaluate the expressions in order and return the value of the last expression (typically there is only one expression in this context).</p> </li> </ul> </li> </ol> <h2> <span onmouseover="document.getElementById('ghlink-differences-between-match-specifications-in-ets-and-tracing-idm1222').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-differences-between-match-specifications-in-ets-and-tracing-idm1222').style.visibility = 'hidden';" id="differences_ets_tracing">4.6 Differences between Match Specifications in ETS and Tracing</span> </h2> <p>ETS match specifications produce a return value. Usually the <code class="code">MatchBody</code> contains one single <code class="code">ConditionExpression</code> that defines the return value without any side effects. Calls with side effects are not allowed in the ETS context.</p> <p>When tracing there is no return value to produce, the match specification either matches or does not. The effect when the expression matches is a trace message rather than a returned term. The <code class="code">ActionTerm</code>s are executed as in an imperative language, that is, for their side effects. Functions with side effects are also allowed when tracing.</p> <h2><span onmouseover="document.getElementById('ghlink-tracing-examples-idm1230').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-tracing-examples-idm1230').style.visibility = 'hidden';">4.7 Tracing Examples</span></h2> <p>Match an argument list of three, where the first and third arguments are equal:</p> <pre data-language="erlang">[{['$1', '_', '$1'],
  [],
  []}]</pre> <p>Match an argument list of three, where the second argument is a number &gt; 3:</p> <pre data-language="erlang">[{['_', '$1', '_'],
  [{ '&gt;', '$1', 3}],
  []}]</pre> <p>Match an argument list of three, where the third argument is either a tuple containing argument one and two, <strong>or</strong> a list beginning with argument one and two (that is, <code class="code">[a,b,[a,b,c]]</code> or <code class="code">[a,b,{a,b}]</code>):</p> <pre data-language="erlang">[{['$1', '$2', '$3'],
  [{'orelse', 
      {'=:=', '$3', {{'$1','$2'}}},
      {'and', 
        {'=:=', '$1', {hd, '$3'}},
        {'=:=', '$2', {hd, {tl, '$3'}}}}}],
  []}]</pre> <p>The above problem can also be solved as follows:</p> <pre data-language="erlang">[{['$1', '$2', {'$1', '$2}], [], []},
 {['$1', '$2', ['$1', '$2' | '_']], [], []}]</pre> <p>Match two arguments, where the first is a tuple beginning with a list that in turn begins with the second argument times two (that is, <code class="code">[{[4,x],y},2]</code> or <code class="code">[{[8], y, z},4])</code>:</p> <pre data-language="erlang">[{['$1', '$2'],[{'=:=', {'*', 2, '$2'}, {hd, {element, 1, '$1'}}}],
  []}]</pre> <p>Match three arguments. When all three are equal and are numbers, append the process dump to the trace message, otherwise let the trace message be "as is", but set the sequential trace token label to 4711:</p> <pre data-language="erlang">[{['$1', '$1', '$1'],
  [{is_number, '$1'}],
  [{message, {process_dump}}]},
 {'_', [], [{set_seq_token, label, 4711}]}]</pre> <p>As can be noted above, the parameter list can be matched against a single <code class="code">MatchVariable</code> or an <code class="code">'_'</code>. To replace the whole parameter list with a single variable is a special case. In all other cases the <code class="code">MatchHead</code> must be a <strong>proper</strong> list.</p> <p>Generate a trace message only if the trace control word is set to 1:</p> <pre data-language="erlang">[{'_',
  [{'==',{get_tcw},{const, 1}}],
  []}]</pre> <p>Generate a trace message only if there is a <code class="code">seq_trace</code> token:</p> <pre data-language="erlang">[{'_',
  [{'==',{is_seq_trace},{const, 1}}],
  []}]</pre> <p>Remove the <code class="code">'silent'</code> trace flag when the first argument is <code class="code">'verbose'</code>, and add it when it is <code class="code">'silent':</code></p> <pre data-language="erlang">[{'$1',
  [{'==',{hd, '$1'},verbose}],
  [{trace, [silent],[]}]},
 {'$1',
  [{'==',{hd, '$1'},silent}],
  [{trace, [],[silent]}]}]</pre> <p>Add a <code class="code">return_trace</code> message if the function is of arity 3:</p> <pre data-language="erlang">[{'$1',
  [{'==',{length, '$1'},3}],
  [{return_trace}]},
 {'_',[],[]}]</pre> <p>Generate a trace message only if the function is of arity 3 and the first argument is <code class="code">'trace'</code>:</p> <pre data-language="erlang">[{['trace','$2','$3'],
  [],
  []},
 {'_',[],[]}]</pre> <h2><span onmouseover="document.getElementById('ghlink-ets-examples-idm1270').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-ets-examples-idm1270').style.visibility = 'hidden';">4.8 ETS Examples</span></h2> <p>Match all objects in an ETS table, where the first element is the atom <code class="code">'strider'</code> and the tuple arity is 3, and return the whole object:</p> <pre data-language="erlang">[{{strider,'_','_'},
  [],
  ['$_']}]</pre> <p>Match all objects in an ETS table with arity &gt; 1 and the first element is 'gandalf', and return element 2:</p> <pre data-language="erlang">[{'$1',
  [{'==', gandalf, {element, 1, '$1'}},{'&gt;=',{size, '$1'},2}],
  [{element,2,'$1'}]}]</pre> <p>In this example, if the first element had been the key, it is much more efficient to match that key in the <code class="code">MatchHead</code> part than in the <code class="code">MatchConditions</code> part. The search space of the tables is restricted with regards to the <code class="code">MatchHead</code> so that only objects with the matching key are searched.</p> <p>Match tuples of three elements, where the second element is either <code class="code">'merry'</code> or <code class="code">'pippin'</code>, and return the whole objects:</p> <pre data-language="erlang">[{{'_',merry,'_'},
  [],
  ['$_']},
 {{'_',pippin,'_'},
  [],
  ['$_']}]</pre> <p>Function <code><span class="code">ets:test_ms/2&gt;</span></code> can be useful for testing complicated ETS matches.</p> </div> <div class="footer"> <hr> <p>Copyright © 1997-2021 Ericsson AB. All Rights Reserved.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2021 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
