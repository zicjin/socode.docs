<div class="innertube"> <h1>12 Processes</h1> <h2><span onmouseover="document.getElementById('ghlink-processes-idm3086').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-processes-idm3086').style.visibility = 'hidden';">12.1 Processes</span></h2> <p>Erlang is designed for massive concurrency. Erlang processes are lightweight (grow and shrink dynamically) with small memory footprint, fast to create and terminate, and the scheduling overhead is low.</p> <h2><span onmouseover="document.getElementById('ghlink-process-creation-idm3089').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-process-creation-idm3089').style.visibility = 'hidden';">12.2 Process Creation</span></h2> <p>A process is created by calling <code class="code">spawn()</code>:</p> <pre data-language="erlang">
spawn(Module, Name, Args) -&gt; pid()
  Module = Name = atom()
  Args = [Arg1,...,ArgN]
    ArgI = term()</pre> <p><code class="code">spawn()</code> creates a new process and returns the pid.</p> <p>The new process starts executing in <code class="code">Module:Name(Arg1,...,ArgN)</code> where the arguments are the elements of the (possible empty) <code class="code">Args</code> argument list.</p> <p>There exist a number of different <code class="code">spawn</code> BIFs:</p> <ul> <li><code><span class="code">spawn/1,2,3,4</span></code></li> <li><code><span class="code">spawn_link/1,2,3,4</span></code></li> <li><code><span class="code">spawn_monitor/1,2,3,4</span></code></li> <li><code><span class="code">spawn_opt/2,3,4,5</span></code></li> <li><code><span class="code">spawn_request/1,2,3,4,5</span></code></li> </ul> <h2><span onmouseover="document.getElementById('ghlink-registered-processes-idm3117').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-registered-processes-idm3117').style.visibility = 'hidden';">12.3 Registered Processes</span></h2> <p>Besides addressing a process by using its pid, there are also BIFs for registering a process under a name. The name must be an atom and is automatically unregistered if the process terminates:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>BIF</strong></td> <td><strong>Description</strong></td> </tr> <tr> <td><code class="code">register(Name, Pid)</code></td> <td>Associates the name <code class="code">Name</code>, an atom, with the process <code class="code">Pid</code>.</td> </tr> <tr> <td><code class="code">registered()</code></td> <td>Returns a list of names that have been registered using <code class="code">register/2</code>.</td> </tr> <tr> <td><code class="code">whereis(Name)</code></td> <td>Returns the pid registered under <code class="code">Name</code>, or <code class="code">undefined</code>if the name is not registered.</td> </tr> </table> <p class="doc-table-caption">Table 12.1: Name Registration BIFs</p> </div> <h2><span onmouseover="document.getElementById('ghlink-process-aliases-idm3144').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-process-aliases-idm3144').style.visibility = 'hidden';">12.4 Process Aliases</span></h2> <p> When sending a message to a process, the receiving process can be identified by a <code><a href="data_types#pid">PID</a></code>, a <code><a href="#registered-processes">registered name</a></code>, or a <i>process alias</i> which is a term of the type <code><a href="data_types#reference">reference</a></code>. The typical use case that process aliases were designed for is a request/reply scenario. Using a process alias when sending the reply makes it possible for the receiver of the reply to prevent the reply from reaching its message queue if the operation times out or if the connection between the processes is lost. </p> <p> A process alias can be used as identifier of the receiver when sending a message using the <code><a href="expressions#send">send operator <span class="code">!</span></a></code> or send BIFs such as <code><span class="code">erlang:send/2</span></code>. As long as the process alias is active, messages will be delivered the same way as if the process identifier of the process that created the alias had been used. When the alias has been deactivated, messages sent using the alias will be dropped before entering the message queue of the receiver. Note that messages that at deactivation time already have entered the message queue will <strong>not</strong> be removed. </p> <p> A process alias is created either by calling one of the <code><span class="code">alias/0,1</span></code> BIFs or by creating an alias and a monitor simultaneously. If the alias is created together with a monitor, the same reference will be used both as monitor reference and alias. Creating a monitor and an alias at the same time is done by passing the <code class="code">{alias, _}</code> option to the <code><span class="code">monitor/3</span></code> BIF. The <code class="code">{alias, _}</code> option can also be passed when creating a monitor via <code><span class="code">spawn_opt()</span></code>, or <code><span class="code">spawn_request()</span></code>. </p> <p> A process alias can be deactivated by the process that created it by calling the <code><span class="code">unalias/1</span></code> BIF. It is also possible to automatically deactivate an alias on certain events. See the documentation of the <code><span class="code">alias/1</span></code> BIF, and the <code class="code">{alias, _}</code> option of the <code><span class="code">monitor/3</span></code> BIF for more information about automatic deactivation of aliases. </p> <p> It is <strong>not</strong> possible to: </p> <ul> <li>create an alias identifying another process than the caller.</li> <li>deactivate an alias unless it identifies the caller.</li> <li>look up an alias.</li> <li>look up the process identified by an alias.</li> <li>check if an alias is active or not.</li> <li>check if a reference is an alias.</li> </ul> <p> These are all intentional design decisions relating to performance, scalability, and distribution transparency. </p> <h2> <span onmouseover="document.getElementById('ghlink-process-termination-idm3186').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-process-termination-idm3186').style.visibility = 'hidden';" id="term">12.5 Process Termination</span> </h2> <p>When a process terminates, it always terminates with an <strong>exit reason</strong>. The reason can be any term.</p> <p>A process is said to terminate <strong>normally</strong>, if the exit reason is the atom <code class="code">normal</code>. A process with no more code to execute terminates normally.</p> <p>A process terminates with an exit reason <code class="code">{Reason,Stack}</code> when a run-time error occurs. See <code><a href="errors#exit_reasons">Exit Reasons</a></code>.</p> <p>A process can terminate itself by calling one of the following BIFs:</p> <ul> <li><code class="code">exit(Reason)</code></li> <li><code class="code">erlang:error(Reason)</code></li> <li><code class="code">erlang:error(Reason, Args)</code></li> </ul> <p>The process then terminates with reason <code class="code">Reason</code> for <code class="code">exit/1</code> or <code class="code">{Reason,Stack}</code> for the others.</p> <p>A process can also be terminated if it receives an exit signal with another exit reason than <code class="code">normal</code>, see <code><a href="#errors">Error Handling</a></code>.</p> <h2><span onmouseover="document.getElementById('ghlink-signals-idm3212').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-signals-idm3212').style.visibility = 'hidden';">12.6 Signals</span></h2> <p>  All communication between Erlang processes and Erlang ports is done by sending and receiving asynchronous signals. The most common signals are Erlang message signals. A message signal can be sent using the <code id="message-sending"><a href="expressions#send">send operator <span class="code">!</span></a></code>. A received message can be fetched from the message queue by the receiving process using the <code><a href="expressions#receive"><span class="code">receive</span></a></code> expression. </p>  <p id="sync-comm"> Synchronous communication can be broken down into multiple asynchronous signals. An example of such a synchronous communication is a call to the <code><span class="code">erlang:process_info/2</span></code> BIF when the first argument does not equal the process identifier of the calling process. The caller sends an asynchronous signal requesting information, and then blocks waiting for the reply signal containing the requested information. When the request signal reaches its destination, the destination process replies with the requested information. </p> <h4><span onmouseover="document.getElementById('ghlink-sending-signals-idm3224').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-sending-signals-idm3224').style.visibility = 'hidden';">Sending Signals</span></h4> <p> There are many signals that processes and ports use to communicate. The list below contains the most important signals. In all the cases of request/reply signal pairs, the request signal is sent by the process calling the specific BIF, and the reply signal is sent back to it when the requested operation has been performed. </p> <dl> <dt><strong><code class="code">message</code></strong></dt> <dd> Sent when using the <code><a href="expressions#send">send operator <span class="code">!</span></a></code>, or when calling one of the <code><span class="code">erlang:send/2,3</span></code> or <code><span class="code">erlang:send_nosuspend/2,3</span></code> BIFs. </dd> <dt><strong><code class="code">link</code></strong></dt> <dd> Sent when calling the <code>link/1</code> BIF. </dd> <dt><strong><code class="code">unlink</code></strong></dt> <dd> Sent when calling the <code>unlink/1</code> BIF. </dd> <dt><strong><code class="code">exit</code></strong></dt> <dd> Sent either when explicitly sending an <code class="code">exit</code> signal by calling the <code>exit/2</code> BIF, or when a <code><a href="#sending_exit_signals">linked process terminates</a></code>. If the signal is sent due to a link, the signal is sent after all <code><a href="#visible-resources"> <i>directly visible Erlang resources</i></a></code> used by the process have been released. </dd> <dt><strong><code class="code">monitor</code></strong></dt> <dd> Sent when calling one of the <code>monitor/2,3</code> BIFs. </dd> <dt><strong><code class="code">demonitor</code></strong></dt> <dd> Sent when calling one of the <code>demonitor/1,2</code> BIFs, or when a process monitoring another process terminates. </dd> <dt><strong><code class="code">down</code></strong></dt> <dd> Sent by a <code><a href="#monitors">monitored process or port that terminates</a></code>. The signal is sent after all <code><a href="#visible-resources"><i>directly visible Erlang resources</i></a></code> used by the process or the port have been released. </dd> <dt><strong><code class="code">change</code></strong></dt> <dd> Sent by the <code><a href="#runtime-service">clock service</a></code> on the local runtime system, when the <code>time offset</code> changes, to processes which have <code>monitored the <span class="code">time_offset</span></code>. </dd> <dt><strong><code class="code">group_leader</code></strong></dt> <dd> Sent when calling the <code>group_leader/2</code> BIF. </dd> <dt><strong> <code class="code">spawn_request</code>/<code class="code">spawn_reply</code>, <code class="code">open_port_request</code>/<code class="code">open_port_reply</code> </strong></dt> <dd> Sent due to a call to one of the <code><span class="code">spawn/1,2,3,4</span></code>, <code><span class="code">spawn_link/1,2,3,4</span></code>, <code><span class="code">spawn_monitor/1,2,3,4</span></code>, <code><span class="code">spawn_opt/2,3,4,5</span></code>, <code><span class="code">spawn_request/1,2,3,4,5</span></code>, or <code><span class="code">erlang:open_port/2</span></code> BIFs. The request signal is sent to the <code><a href="#runtime-service">spawn service</a></code> which responds with the reply signal. </dd> <dt><strong><code class="code">alive_request</code>/<code class="code">alive_reply</code></strong></dt> <dd> Sent due to a call to the <code>is_process_alive/1</code> BIF. </dd> <dt><strong> <code class="code">garbage_collect_request</code>/<code class="code">garbage_collect_reply</code>, <code class="code">check_process_code_request</code>/<code class="code">check_process_code_reply</code>, <code class="code">process_info_request</code>/<code class="code">process_info_reply</code> </strong></dt> <dd> Sent due to a call to one of the <code>garbage_collect/1,2</code>, <code>erlang:check_process_code/2,3</code>, or <code>process_info/1,2</code> BIFs. Note that if the request is directed towards the caller itself and it is a synchronous request, no signaling will be performed and the caller will instead synchronously perform the request before returning from the BIF. </dd> <dt><strong><code class="code">port_command</code>, <code class="code">port_connect</code>, <code class="code">port_close</code></strong></dt> <dd> Sent by a process to a port on the local node using the <code><a href="expressions#send">send operator <span class="code">!</span></a></code>, or by calling one of the <code><span class="code">send()</span></code> BIFs. The signal is sent by passing a term on the format <code class="code">{Owner, {command, Data}}</code>, <code class="code">{Owner, {connect, Pid}}</code>, or <code class="code">{Owner, close}</code> as message. </dd> <dt><strong> <code class="code">port_command_request</code>/<code class="code">port_command_reply</code>, <code class="code">port_connect_request</code>/<code class="code">port_connect_reply</code>, <code class="code">port_close_request</code>/<code class="code">port_close_reply</code>, <code class="code">port_control_request</code>/<code class="code">port_control_reply</code>, <code class="code">port_call_request</code>/<code class="code">port_call_reply</code>, <code class="code">port_info_request</code>/<code class="code">port_info_reply</code> </strong></dt> <dd> Sent due to a call to one of the <code><span class="code">erlang:port_command/2,3</span></code>, <code><span class="code">erlang:port_connect/2</span></code>, <code><span class="code">erlang:port_close/1</span></code>, <code><span class="code">erlang:port_control/3</span></code>, <code><span class="code">erlang:port_call/3</span></code>, <code><span class="code">erlang:port_info/1,2</span></code> BIFs. The request signal is sent to a port on the local node which responds with the reply signal. </dd> <dt><strong> <code class="code">timer_start_request</code>/<code class="code">timer_start_reply</code>, <code class="code">timer_cancel_request</code>/<code class="code">timer_cancel_reply</code> </strong></dt> <dd> Sent due to a call to one of the <code><span class="code">erlang:send_after/3,4</span></code>, <code><span class="code">erlang:start_timer/3,4</span></code>, or <code><span class="code">erlang:cancel_timer/1,2</span></code> BIFs. The request signal is sent to the <code><a href="#runtime-service">timer service</a></code> which responds with the reply signal. </dd> </dl> <p> The clock service, the timer service, and the spawn service mentioned above are services provided by the runtime system. Each of these services consists of multiple independently executing entities. Such a service can be viewed as a group of processes, and could actually be implemented like that. Since each service consists of multiple independently executing entities, the order between multiple signals sent from one service to one process is <strong id="runtime-service">not</strong> preserved. Note that this does <strong>not</strong> violate the <code><a href="#signal-delivery">signal ordering guarantee</a></code> of the language. </p> <p> The realization of the signals described above may change both at runtime and due to changes in implementation. You may be able to detect such changes using <code class="code">receive</code> tracing or by inspecting message queues. However, these are internal implementation details of the runtime system that you should <strong>not</strong> rely on. As an example, many of the reply signals above are ordinary message signals. When the operation is synchronous, the reply signals do not have to be message signals. The current implementation takes advantage of this and, depending on the state of the system, use alternative ways of delivering the reply signals. The implementation of these reply signals may also, at any time, be changed to not use message signals where it previously did. </p> <h4><span onmouseover="document.getElementById('ghlink-receiving-signals-idm3372').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-receiving-signals-idm3372').style.visibility = 'hidden';">Receiving Signals</span></h4> <p> When a signal is received by a process, some kind of action is taken. The specific action taken depends on the signal type, contents of the signal, and the state of the receiving process. Actions taken for the most common signals: </p> <dl> <dt><strong><code class="code">message</code></strong></dt> <dd> If the message signal was sent using a <code><a href="#process-aliases">process alias</a></code> that is no longer active, the message signal will be dropped; otherwise, if the alias is still active or the message signal was sent by other means, the message is added to the end of the message queue. When the message has been added to the message queue, the receiving process can fetch the message from the message queue using the <code><a href="expressions#receive"><span class="code">receive</span></a></code> expression. </dd> <dt><strong><code class="code">link</code>, <code class="code">unlink</code></strong></dt> <dd> Very simplified it can be viewed as updating process local information about the link. A detailed description of the <code>link protocol</code> can be found in the <i>Distribution Protocol</i> chapter of the <i>ERTS User's Guide</i>. </dd> <dt><strong><code class="code">exit</code></strong></dt> <dd> Set the receiver in an exiting state, drop the signal, or convert the signal into a message and add it to the end of the message queue. If the receiver is set in an exiting state, no more Erlang code will be executed and the process is scheduled for termination. The section <code><a href="#receiving_exit_signals"><i>Receiving Exit Signals</i></a></code> below gives more details on the action taken when an <code class="code">exit</code> signal is received. </dd> <dt><strong><code class="code">monitor</code>, <code class="code">demonitor</code></strong></dt> <dd> Update process local information about the monitor. </dd> <dt><strong><code class="code">down</code>, <code class="code">change</code></strong></dt> <dd> Convert into a message if the corresponding monitor is still active; otherwise, drop the signal. If the signal is converted into a message, it is also added to the end of the message queue. </dd> <dt><strong><code class="code">group_leader</code></strong></dt> <dd> Change the group leader of the process. </dd> <dt><strong><code class="code">spawn_reply</code></strong></dt> <dd> Convert into a message, or drop the signal depending on the reply and how the <code class="code">spawn_request</code> signal was configured. If the signal is converted into a message it is also added to the end of the message queue. For more information see the <code><span class="code">spawn_request()</span></code> BIF. </dd> <dt><strong><code class="code">alive_request</code></strong></dt> <dd> Schedule execution of the <i>is alive</i> test. If the process is in an exiting state, the <i>is alive</i> test will not be executed until after all <code><a href="#visible-resources"><i>directly visible Erlang resources</i></a></code> used by the process have been released. The <code class="code">alive_reply</code> will be sent after the <i>is alive</i> test has executed. </dd> <dt><strong> <code class="code">process_info_request</code>, <code class="code">garbage_collect_request</code>, <code class="code">check_process_code_request</code> </strong></dt> <dd> Schedule execution of the requested operation. The reply signal will be sent when the operation has been executed. </dd> </dl> <p> Note that some actions taken when a signal is received involves <strong>scheduling</strong> further actions which will result in a reply signal when these scheduled actions have completed. This implies that the reply signals may be sent in a different order than the order of the incoming signals that triggered these operations. This does, however, <strong>not</strong> violate the <code><a href="#signal-delivery">signal ordering guarantee</a></code> of the language. </p>  <p id="message-queue-order"> The order of messages in the message queue of a process reflects the order in which the signals corresponding to the messages has been received since <code><a href="processes#receiving-signals">all signals that add messages to the message queue add them at the end of the message queue</a></code>. Messages corresponding to signals from the same sender are also ordered in the same order as the signals were sent due to the <code><a href="processes#signal-delivery">signal ordering guarantee</a></code> of the language. </p> <h4> <span onmouseover="document.getElementById('ghlink-directly-visible-erlang-resources-idm3434').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-directly-visible-erlang-resources-idm3434').style.visibility = 'hidden';" id="visible-resources">Directly Visible Erlang Resources</span> </h4> <p> As described above, <code class="code">exit</code> signals due to links, <code class="code">down</code> signals, and reply signals from an exiting process due to <code class="code">alive_request</code>s are not sent until all <i>directly visible Erlang resources</i> held by the terminating process have been released. With <i>directly visible Erlang resources</i> we here mean all resources made available by the language excluding resources held by heap data, dirty native code execution and the process identifier of the terminating process. Examples of <i>directly visible Erlang resources</i> are <code><a href="#registered-processes">registered name</a></code> and <code>ETS</code> tables. </p> <h5>The Excluded Resources</h5> <p> The process identifier of the process cannot be released for reuse until everything regarding the process has been released. </p> <p> A process executing dirty native code in a NIF when it receives an exit signal will be set into an exiting state even if it is still executing dirty native code. <i>Directly visible Erlang resources</i> will be released, but the runtime system cannot force the native code to stop executing. The runtime system tries to prevent the execution of the dirty native code from effecting other processes by, for example, disabling functionality such as <code><span class="code">enif_send()</span></code> when used from a terminated process, but if the NIF is not well behaved it can still effect other processes. A well behaved dirty NIF should test if <code>the process it is executing in has exited</code>, and if so stop executing. </p> <p> In the general case, the heap of a process cannot be removed before all signals that it needs to send have been sent. Resources held by heap data are the memory blocks containing the heap, but also include things referred to from the heap such as off heap binaries, and resources held via NIF <code>resource objects</code> on the heap. </p> <h4> <span onmouseover="document.getElementById('ghlink-delivery-of-signals-idm3456').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-delivery-of-signals-idm3456').style.visibility = 'hidden';" id="signal-delivery">Delivery of Signals</span> </h4> <p> The amount of time that passes between the time a signal is sent and the arrival of the signal at the destination is unspecified but positive. If the receiver has terminated, the signal does not arrive, but it can trigger another signal. For example, a <code class="code">link</code> signal sent to a non-existing process triggers an <code class="code">exit</code> signal, which is sent back to where the <code class="code">link</code> signal originated from. When communicating over the distribution, signals can be lost if the distribution channel goes down. </p> <p> The only signal ordering guarantee given is the following: if an entity sends multiple signals to the same destination entity, the order is preserved; that is, if <code class="code">A</code> sends a signal <code class="code">S1</code> to <code class="code">B</code>, and later sends signal <code class="code">S2</code> to <code class="code">B</code>, <code class="code">S1</code> is guaranteed not to arrive after <code class="code">S2</code>. Note that <code class="code">S1</code> may, or may not have been lost. </p> <h4> <span onmouseover="document.getElementById('ghlink-irregularities-idm3472').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-irregularities-idm3472').style.visibility = 'hidden';" id="signal-irregularities">Irregularities</span> </h4> <dl> <dt><strong>Synchronous Error Checking</strong></dt> <dd> <p> Some functionality that send signals have synchronous error checking when sending locally on a node and fail if the receiver is not present at the time when the signal is sent: </p> <ul> <li> The <code><a href="expressions#send">send operator <span class="code">!</span></a></code>, <code><span class="code">erlang:send/2,3</span></code>, BIFs and <code><span class="code">erlang:send_nosuspend/2,3</span></code> BIFs when the receiver is identified by a name that is expected to be registered locally. </li> <li> <code><span class="code">erlang:link/1</span></code> </li> <li> <code><span class="code">erlang:group_leader/2</span></code> </li> </ul>  </dd> <dt><strong>Unexpected Behaviours of Exit Signals</strong></dt> <dd> <p> When a process sends an exit signal with exit reason <code class="code">normal</code> to itself by calling <code><span class="code">erlang:exit(self(), normal)</span></code> it will be terminated <code><a href="#receiving_exit_signals">when the <span class="code">exit</span> signal is received</a></code>. In all other cases when an exit signal with exit reason <code class="code">normal</code> is received, it is dropped. </p> <p> When an <code><a href="#receiving_exit_signals"><span class="code">exit</span> signal with exit reason <span class="code">kill</span> is received</a></code>, the action taken is different depending on whether the signal was sent due to a linked process terminating, or the signal was explicitly sent using the <code><span class="code">exit/2</span></code> BIF. When sent using the <code class="code">exit/2</code> BIF, the signal cannot be <code>trapped</code>, while it can be trapped if the signal was sent due to a link. </p> </dd> <dt><strong>Blocking Signaling Over Distribution</strong></dt> <dd> <p> When sending a signal over a distribution channel, the sending process may be suspended even though the signal is supposed to be sent asynchronously. This is due to the built in flow control over the channel that has been present more or less for ever. When the size of the output buffer for the channel reach the <i>distribution buffer busy limit</i>, processes sending on the channel will be suspended until the size of the buffer shrinks below the limit. The size of the limit can be inspected by calling <code> <span class="code">erlang:system_info(dist_buf_busy_limit)</span></code>. Since this functionality has been present for so long, it is not possible to remove it, but it is possible to increase the limit to a point where it more or less never is reached using the <code class="code">erl</code> command line argument <code><span class="code">+zdbbl</span></code>. Note that if you do raise the limit like this, you need to take care of flow control yourself to ensure that you do not get into a situation with excessive memory usage. </p> </dd> </dl> <p> The irregularities mentioned above cannot be fixed as they have been part of Erlang too long and it would break a lot of existing code. </p> <h2><span onmouseover="document.getElementById('ghlink-links-idm3521').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-links-idm3521').style.visibility = 'hidden';">12.7 Links</span></h2> <p> Two processes can be <strong>linked</strong> to each other. Also a process and a port that reside on the same node can be linked to each other. A link between two processes can be created if one of them calls the <code><span class="code">link/1</span></code> BIF with the process identifier of the other process as argument. Links can also be created using one the following spawn BIFs <code><span class="code">spawn_link()</span></code>, <code><span class="code">spawn_opt()</span></code>, or <code><span class="code">spawn_request()</span></code>. The spawn operation and the link operation will be performed atomically, in these cases. </p> <p> If one of the participants of a link terminates, it will <code>send an exit signal</code> to the other participant. The exit signal will contain the <code>exit reason</code> of the terminated participant. </p> <p> A link can be removed by calling the <code><span class="code">unlink/1</span></code> BIF. </p> <p> Links are bidirectional and there can only be one link between two processes. Repeated calls to <code class="code">link()</code> have no effect. Either one of the involved processes may create or remove a link. </p> <p>Links are used to monitor the behavior of other processes, see <code><a href="#errors">Error Handling</a></code>.</p> <h2> <span onmouseover="document.getElementById('ghlink-error-handling-idm3543').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-error-handling-idm3543').style.visibility = 'hidden';" id="errors">12.8 Error Handling</span> </h2> <p>Erlang has a built-in feature for error handling between processes. Terminating processes emit exit signals to all linked processes, which can terminate as well or handle the exit in some way. This feature can be used to build hierarchical program structures where some processes are supervising other processes, for example, restarting them if they terminate abnormally.</p> <p>See <code> OTP Design Principles</code> for more information about OTP supervision trees, which use this feature.</p> <h4> <span onmouseover="document.getElementById('ghlink-sending-exit-signals-idm3549').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-sending-exit-signals-idm3549').style.visibility = 'hidden';" id="sending_exit_signals">Sending Exit Signals</span> </h4> <p> When a process or port <code><a href="#term">terminates</a></code> it will send exit signals to all processes and ports that it is <code><a href="#links">linked</a></code> to. The exit signal will contain the following information: </p> <dl> <dt><strong>Sender identifier</strong></dt> <dd><p> The process or port identifier of the process or port that terminated. </p></dd> <dt><strong>Receiver identifier</strong></dt> <dd><p> The process or port identifier of the process or port which the exit signal is sent to. </p></dd> <dt><strong>The <code class="code">link</code> flag</strong></dt> <dd><p> This flag will be set indicating that the exit signal was sent due to a link. </p></dd> <dt><strong id="link_exit_signal_reason">Exit reason</strong></dt> <dd> <p> The exit reason of the process or port that terminated or the atom:</p> <ul> <li><p> <code class="code">noproc</code> in case no process or port was found when setting up a link in a preceeding call to the <code><span class="code">link(PidOrPort)</span></code> BIF. The process or port identified as sender of the exit signal will equal the <code class="code">PidOrPort</code> argument passed to <code class="code">link/1</code>. </p></li> <li><p> <code class="code">noconnection</code> in case the linked processes resides on different nodes and the connection between the nodes was lost or could not be established. The process or port identified as sender of the exit signal might in this case still be alive. </p></li> </ul> </dd> </dl> <p> Exit signals can also be sent explicitly by calling the <code><span class="code">exit(PidOrPort, Reason)</span></code> BIF. The exit signal is sent to the process or port identified by the <code class="code">PidOrPort</code> argument. The exit signal sent will contain the following information: </p> <dl> <dt><strong>Sender identifier</strong></dt> <dd><p> The process identifier of the process that called <code class="code">exit/2</code>. </p></dd> <dt><strong>Receiver identifier</strong></dt> <dd><p> The process or port identifier of the process or port which the exit signal is sent to. </p></dd> <dt><strong>The <code class="code">link</code> flag</strong></dt> <dd><p> This flag will not be set, indicating that this exit signal was not sent due to a link. </p></dd> <dt><strong>Exit reason</strong></dt> <dd><p> The term passed as <code class="code">Reason</code> in the call to <code class="code">exit/2</code>. If <code class="code">Reason</code> is the atom <code class="code">kill</code>, the receiver cannot <code>trap the exit</code> signal and will unconditionally terminate when it receives the signal. </p></dd> </dl> <h4> <span onmouseover="document.getElementById('ghlink-receiving-exit-signals-idm3605').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-receiving-exit-signals-idm3605').style.visibility = 'hidden';" id="receiving_exit_signals">Receiving Exit Signals</span> </h4> <p>What happens when a process receives an exit signal depends on:</p> <ul> <li><p> The <code>trap exit</code> state of the receiver at the time when the exit signal is received. </p></li> <li><p> The exit reason of the exit signal. </p></li> <li><p> The sender of the exit signal. </p></li> <li><p> The state of the <code class="code">link</code> flag of the exit signal. If the <code class="code">link</code> flag is set, the exit signal was sent due to a link; otherwise, the exit signal was sent by a call to the <code><span class="code">exit/2</span></code> BIF. </p></li> <li><p> If the <code class="code">link</code> flag is set, what happens also depends on whether the <code>link is still active or not</code> when the exit signal is received. </p></li> </ul> <p> Based on the above states, the following will happen when an exit signal is received by a process: </p> <ul> <li> <p>The exit signal is silently dropped if:</p> <ul> <li><p> the <code class="code">link</code> flag of the exit signal is set and the corresponding link has been deactivated. </p></li> <li><p> the exit reason of the exit signal is the atom <code class="code">normal</code>, the receiver is not trapping exits, and the receiver and sender are not the same process. </p></li> </ul> </li> <li> <p>The receiving process is terminated if:</p> <ul> <li><p> the <code class="code">link</code> flag of the exit signal is not set, and the exit reason of the exit signal is the atom <code class="code">kill</code>. The receiving process will terminate with the atom <code class="code">killed</code> as exit reason. </p></li> <li><p> the receiver is not trapping exits, and the exit reason is something other than the atom <code class="code">normal</code>. Also, if the <code class="code">link</code> flag of the exit signal is set, the link also needs to be active otherwise the exit signal will be dropped. The exit reason of the receiving process will equal the exit reason of the exit signal. Note that if the <code class="code">link</code> flag is set, an exit reason of <code class="code">kill</code> will <strong>not</strong> be converted to <code class="code">killed</code>. </p></li> <li><p> the exit reason of the exit signal is the atom <code class="code">normal</code> and the sender of the exit signal is the same process as the receiver. The <code class="code">link</code> flag cannot be set in this case. The exit reason of the receiving process will be the atom <code class="code">normal</code>. </p></li> </ul> </li> <li> <p> The exit signal is converted to a message signal and added to the end of the message queue of the receiver, if the receiver is trapping exits, the <code class="code">link</code> flag of the exit signal is: </p> <ul> <li><p> not set, and the exit reason of the signal is not the atom <code class="code">kill</code>. </p></li> <li><p> set, and the corresponding link is active. Note that an exit reason of <code class="code">kill</code> will <strong>not</strong> terminate the process in this case and it will not be converted to <code class="code">killed</code>. </p></li> </ul> <p> The converted message will be on the form <code class="code">{'EXIT', SenderID, Reason}</code> where <code class="code">Reason</code> equals the exit reason of the exit signal and <code class="code">SenderID</code> is the identifier of the process or port that sent the exit signal. </p> </li> </ul> <h2><span onmouseover="document.getElementById('ghlink-monitors-idm3675').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-monitors-idm3675').style.visibility = 'hidden';">12.9 Monitors</span></h2> <p>An alternative to links are <strong>monitors</strong>. A process <code class="code">Pid1</code> can create a monitor for <code class="code">Pid2</code> by calling the BIF <code class="code">erlang:monitor(process, Pid2)</code>. The function returns a reference <code class="code">Ref</code>.</p> <p>If <code class="code">Pid2</code> terminates with exit reason <code class="code">Reason</code>, a 'DOWN' message is sent to <code class="code">Pid1</code>:</p> <pre data-language="erlang">{'DOWN', Ref, process, Pid2, Reason}</pre> <p>If <code class="code">Pid2</code> does not exist, the 'DOWN' message is sent immediately with <code class="code">Reason</code> set to <code class="code">noproc</code>.</p> <p>Monitors are unidirectional. Repeated calls to <code class="code">erlang:monitor(process, Pid)</code> creates several independent monitors, and each one sends a 'DOWN' message when <code class="code">Pid</code> terminates.</p> <p>A monitor can be removed by calling <code class="code">erlang:demonitor(Ref)</code>.</p> <p>Monitors can be created for processes with registered names, also at other nodes.</p> <h2><span onmouseover="document.getElementById('ghlink-process-dictionary-idm3698').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-process-dictionary-idm3698').style.visibility = 'hidden';">12.10 Process Dictionary</span></h2> <p>Each process has its own process dictionary, accessed by calling the following BIFs:</p> <pre data-language="erlang">
put(Key, Value)
get(Key)
get()
get_keys(Value)
erase(Key)
erase()</pre> </div> <div class="footer"> <hr> <p>Copyright Â© 2003-2021 Ericsson AB. All Rights Reserved.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2021 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
