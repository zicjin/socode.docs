<div class="innertube"> <h1>8 Expressions</h1> <p>In this section, all valid Erlang expressions are listed. When writing Erlang programs, it is also allowed to use macro- and record expressions. However, these expressions are expanded during compilation and are in that sense not true Erlang expressions. Macro- and record expressions are covered in separate sections: </p> <ul> <li><p><code><a href="macros">Preprocessor</a></code></p></li> <li><p><code><a href="records">Records</a></code></p></li> </ul> <h2><span onmouseover="document.getElementById('ghlink-expression-evaluation-idm1268').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-expression-evaluation-idm1268').style.visibility = 'hidden';">8.1 Expression Evaluation</span></h2> <p>All subexpressions are evaluated before an expression itself is evaluated, unless explicitly stated otherwise. For example, consider the expression:</p> <pre data-language="erlang">Expr1 + Expr2</pre> <p><code class="code">Expr1</code> and <code class="code">Expr2</code>, which are also expressions, are evaluated first - in any order - before the addition is performed.</p> <p>Many of the operators can only be applied to arguments of a certain type. For example, arithmetic operators can only be applied to numbers. An argument of the wrong type causes a <code class="code">badarg</code> runtime error.</p> <h2> <span onmouseover="document.getElementById('ghlink-terms-idm1277').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-terms-idm1277').style.visibility = 'hidden';" id="term">8.2 Terms</span> </h2> <p>The simplest form of expression is a term, that is an integer, float, atom, string, list, map, or tuple. The return value is the term itself.</p> <h2><span onmouseover="document.getElementById('ghlink-variables-idm1281').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-variables-idm1281').style.visibility = 'hidden';">8.3 Variables</span></h2> <p>A variable is an expression. If a variable is bound to a value, the return value is this value. Unbound variables are only allowed in patterns.</p> <p>Variables start with an uppercase letter or underscore (_). Variables can contain alphanumeric characters, underscore and <code class="code">@</code>. </p> <p><strong>Examples:</strong></p> <pre data-language="erlang">
X
Name1
PhoneNumber
Phone_number
_
_Height</pre> <p>Variables are bound to values using <code><a href="patterns">pattern matching</a></code>. Erlang uses <strong>single assignment</strong>, that is, a variable can only be bound once.</p> <p>The <strong>anonymous variable</strong> is denoted by underscore (_) and can be used when a variable is required but its value can be ignored.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
[H|_] = [1,2,3]</pre> <p>Variables starting with underscore (_), for example, <code class="code">_Height</code>, are normal variables, not anonymous. However, they are ignored by the compiler in the sense that they do not generate warnings.</p> <p><strong>Example:</strong></p> <p>The following code:</p> <pre data-language="erlang">
member(_, []) -&gt;
    [].</pre> <p>can be rewritten to be more readable:</p> <pre data-language="erlang">
member(Elem, []) -&gt;
    [].</pre> <p>This causes a warning for an unused variable, <code class="code">Elem</code>, if the code is compiled with the flag <code class="code">warn_unused_vars</code> set. Instead, the code can be rewritten to:</p> <pre data-language="erlang">
member(_Elem, []) -&gt;
    [].</pre> <p>Notice that since variables starting with an underscore are not anonymous, this matches:</p> <pre data-language="erlang">
{_,_} = {1,2}</pre> <p>But this fails:</p> <pre data-language="erlang">
{_N,_N} = {1,2}</pre> <p>The scope for a variable is its function clause. Variables bound in a branch of an <code class="code">if</code>, <code class="code">case</code>, or <code class="code">receive</code> expression must be bound in all branches to have a value outside the expression. Otherwise they are regarded as 'unsafe' outside the expression.</p> <p>For the <code class="code">try</code> expression variable scoping is limited so that variables bound in the expression are always 'unsafe' outside the expression.</p> <h2> <span onmouseover="document.getElementById('ghlink-patterns-idm1319').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-patterns-idm1319').style.visibility = 'hidden';" id="pattern">8.4 Patterns</span> </h2> <p>A pattern has the same structure as a term but can contain unbound variables.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
Name1
[H|T]
{error,Reason}</pre> <p>Patterns are allowed in clause heads, <code class="code">case</code> and <code class="code">receive</code> expressions, and match expressions.</p> <h4><span onmouseover="document.getElementById('ghlink-match-operator-=-in-patterns-idm1329').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-match-operator-=-in-patterns-idm1329').style.visibility = 'hidden';">Match Operator = in Patterns</span></h4> <p>If <code class="code">Pattern1</code> and <code class="code">Pattern2</code> are valid patterns, the following is also a valid pattern:</p> <pre data-language="erlang">
Pattern1 = Pattern2</pre> <p>When matched against a term, both <code class="code">Pattern1</code> and <code class="code">Pattern2</code> are matched against the term. The idea behind this feature is to avoid reconstruction of terms.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
f({connect,From,To,Number,Options}, To) -&gt;
    Signal = {connect,From,To,Number,Options},
    ...;
f(Signal, To) -&gt;
    ignore.</pre> <p>can instead be written as</p> <pre data-language="erlang">
f({connect,_,To,_,_} = Signal, To) -&gt;
    ...;
f(Signal, To) -&gt;
    ignore.</pre> <h4><span onmouseover="document.getElementById('ghlink-string-prefix-in-patterns-idm1343').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-string-prefix-in-patterns-idm1343').style.visibility = 'hidden';">String Prefix in Patterns</span></h4> <p>When matching strings, the following is a valid pattern:</p> <pre data-language="erlang">
f("prefix" ++ Str) -&gt; ...</pre> <p>This is syntactic sugar for the equivalent, but harder to read:</p> <pre data-language="erlang">
f([$p,$r,$e,$f,$i,$x | Str]) -&gt; ...</pre> <h4><span onmouseover="document.getElementById('ghlink-expressions-in-patterns-idm1349').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-expressions-in-patterns-idm1349').style.visibility = 'hidden';">Expressions in Patterns</span></h4> <p>An arithmetic expression can be used within a pattern if it meets both of the following two conditions:</p> <ul> <li>It uses only numeric or bitwise operators.</li> <li>Its value can be evaluated to a constant when complied.</li> </ul> <p><strong>Example:</strong></p> <pre data-language="erlang">
case {Value, Result} of
    {?THRESHOLD+1, ok} -&gt; ...</pre> <h2><span onmouseover="document.getElementById('ghlink-match-idm1358').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-match-idm1358').style.visibility = 'hidden';">8.5 Match</span></h2> <p>The following matches <code class="code">Expr1</code>, a pattern, against <code class="code">Expr2</code>:</p> <pre data-language="erlang">
Expr1 = Expr2</pre> <p>If the matching succeeds, any unbound variable in the pattern becomes bound and the value of <code class="code">Expr2</code> is returned.</p> <p>If the matching fails, a <code class="code">badmatch</code> run-time error occurs.</p> <p><strong>Examples:</strong></p> <pre data-language="erlang">
1&gt; {A, B} = {answer, 42}.
{answer,42}
2&gt; A.
answer
3&gt; {C, D} = [1, 2].
** exception error: no match of right-hand side value [1,2]</pre> <h2> <span onmouseover="document.getElementById('ghlink-function-calls-idm1374').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-function-calls-idm1374').style.visibility = 'hidden';" id="calls">8.6 Function Calls</span> </h2> <pre data-language="erlang">
ExprF(Expr1,...,ExprN)
ExprM:ExprF(Expr1,...,ExprN)</pre> <p>In the first form of function calls, <code class="code">ExprM:ExprF(Expr1,...,ExprN)</code>, each of <code class="code">ExprM</code> and <code class="code">ExprF</code> must be an atom or an expression that evaluates to an atom. The function is said to be called by using the <strong>fully qualified function name</strong>. This is often referred to as a <strong>remote</strong> or <strong>external function call</strong>.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">lists:keysearch(Name, 1, List)</pre> <p>In the second form of function calls, <code class="code">ExprF(Expr1,...,ExprN)</code>, <code class="code">ExprF</code> must be an atom or evaluate to a fun.</p> <p>If <code class="code">ExprF</code> is an atom, the function is said to be called by using the <strong>implicitly qualified function name</strong>. If the function <code class="code">ExprF</code> is locally defined, it is called. Alternatively, if <code class="code">ExprF</code> is explicitly imported from the <code class="code">M</code> module, <code class="code">M:ExprF(Expr1,...,ExprN)</code> is called. If <code class="code">ExprF</code> is neither declared locally nor explicitly imported, <code class="code">ExprF</code> must be the name of an automatically imported BIF. </p> <p><strong>Examples:</strong></p> <pre data-language="erlang">handle(Msg, State)
spawn(m, init, [])</pre> <p><strong>Examples</strong> where <code class="code">ExprF</code> is a fun:</p> <pre data-language="erlang">
1&gt; Fun1 = fun(X) -&gt; X+1 end,
Fun1(3).
4
2&gt; fun lists:append/2([1,2], [3,4]).
[1,2,3,4]
3&gt; </pre> <p>Notice that when calling a local function, there is a difference between using the implicitly or fully qualified function name. The latter always refers to the latest version of the module. See <code><a href="code_loading">Compilation and Code Loading </a></code> and <code><a href="functions#eval"> Function Evaluation</a></code>.</p> <h4><span onmouseover="document.getElementById('ghlink-local-function-names-clashing-with--auto-imported-bifs-idm1413').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-local-function-names-clashing-with--auto-imported-bifs-idm1413').style.visibility = 'hidden';">Local Function Names Clashing With Auto-Imported BIFs</span></h4> <p>If a local function has the same name as an auto-imported BIF, the semantics is that implicitly qualified function calls are directed to the locally defined function, not to the BIF. To avoid confusion, there is a compiler directive available, <code class="code">-compile({no_auto_import,[F/A]})</code>, that makes a BIF not being auto-imported. In certain situations, such a compile-directive is mandatory.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Before OTP R14A (ERTS version 5.8), an implicitly qualified function call to a function having the same name as an auto-imported BIF always resulted in the BIF being called. In newer versions of the compiler, the local function is called instead. This is to avoid that future additions to the set of auto-imported BIFs do not silently change the behavior of old code.</p> <p>However, to avoid that old (pre R14) code changed its behavior when compiled with OTP version R14A or later, the following restriction applies: If you override the name of a BIF that was auto-imported in OTP versions prior to R14A (ERTS version 5.8) and have an implicitly qualified call to that function in your code, you either need to explicitly remove the auto-import using a compiler directive, or replace the call with a fully qualified function call. Otherwise you get a compilation error. See the following example:</p> </div> </div> <pre data-language="erlang">-export([length/1,f/1]).

-compile({no_auto_import,[length/1]}). % erlang:length/1 no longer autoimported

length([]) -&gt;
    0;
length([H|T]) -&gt;
    1 + length(T). %% Calls the local function length/1

f(X) when erlang:length(X) &gt; 3 -&gt; %% Calls erlang:length/1,
                                  %% which is allowed in guards
    long.</pre> <p>The same logic applies to explicitly imported functions from other modules, as to locally defined functions. It is not allowed to both import a function from another module and have the function declared in the module at the same time:</p> <pre data-language="erlang">-export([f/1]).

-compile({no_auto_import,[length/1]}). % erlang:length/1 no longer autoimported

-import(mod,[length/1]).

f(X) when erlang:length(X) &gt; 33 -&gt; %% Calls erlang:length/1,
                                   %% which is allowed in guards

    erlang:length(X);              %% Explicit call to erlang:length in body

f(X) -&gt;
    length(X).                     %% mod:length/1 is called</pre> <p>For auto-imported BIFs added in Erlang/OTP R14A and thereafter, overriding the name with a local function or explicit import is always allowed. However, if the <code class="code">-compile({no_auto_import,[F/A])</code> directive is not used, the compiler issues a warning whenever the function is called in the module using the implicitly qualified function name.</p> <h2><span onmouseover="document.getElementById('ghlink-if-idm1425').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-if-idm1425').style.visibility = 'hidden';">8.7 If</span></h2> <pre data-language="erlang">
if
    GuardSeq1 -&gt;
        Body1;
    ...;
    GuardSeqN -&gt;
        BodyN
end</pre> <p>The branches of an <code class="code">if</code>-expression are scanned sequentially until a guard sequence <code class="code">GuardSeq</code> that evaluates to true is found. Then the corresponding <code class="code">Body</code> (sequence of expressions separated by ',') is evaluated.</p> <p>The return value of <code class="code">Body</code> is the return value of the <code class="code">if</code> expression.</p> <p>If no guard sequence is evaluated as true, an <code class="code">if_clause</code> run-time error occurs. If necessary, the guard expression <code class="code">true</code> can be used in the last branch, as that guard sequence is always true.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
is_greater_than(X, Y) -&gt;
    if
        X&gt;Y -&gt;
            true;
        true -&gt; % works as an 'else' branch
            false
    end</pre> <h2> <span onmouseover="document.getElementById('ghlink-case-idm1441').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-case-idm1441').style.visibility = 'hidden';" id="case">8.8 Case</span> </h2> <pre data-language="erlang">
case Expr of
    Pattern1 [when GuardSeq1] -&gt;
        Body1;
    ...;
    PatternN [when GuardSeqN] -&gt;
        BodyN
end</pre> <p>The expression <code class="code">Expr</code> is evaluated and the patterns <code class="code">Pattern</code> are sequentially matched against the result. If a match succeeds and the optional guard sequence <code class="code">GuardSeq</code> is true, the corresponding <code class="code">Body</code> is evaluated.</p> <p>The return value of <code class="code">Body</code> is the return value of the <code class="code">case</code> expression.</p> <p>If there is no matching pattern with a true guard sequence, a <code class="code">case_clause</code> run-time error occurs.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
is_valid_signal(Signal) -&gt;
    case Signal of
        {signal, _What, _From, _To} -&gt;
            true;
        {signal, _What, _To} -&gt;
            true;
        _Else -&gt;
            false
    end.</pre> <h2> <span onmouseover="document.getElementById('ghlink-send-idm1458').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-send-idm1458').style.visibility = 'hidden';" id="send">8.9 Send</span> </h2> <pre data-language="erlang">
Expr1 ! Expr2</pre> <p>Sends the value of <code class="code">Expr2</code> as a message to the process specified by <code class="code">Expr1</code>. The value of <code class="code">Expr2</code> is also the return value of the expression.</p> <p><code class="code">Expr1</code> must evaluate to a pid, an alias (reference), a port, a registered name (atom), or a tuple <code class="code">{Name,Node}</code>. <code class="code">Name</code> is an atom and <code class="code">Node</code> is a node name, also an atom.</p> <ul> <li>If <code class="code">Expr1</code> evaluates to a name, but this name is not registered, a <code class="code">badarg</code> run-time error occurs.</li> <li>Sending a message to a reference never fails, even if the reference is no longer (or never was) an alias.</li> <li>Sending a message to a pid never fails, even if the pid identifies a non-existing process.</li> <li>Distributed message sending, that is, if <code class="code">Expr1</code> evaluates to a tuple <code class="code">{Name,Node}</code> (or a pid located at another node), also never fails.</li> </ul> <h2> <span onmouseover="document.getElementById('ghlink-receive-idm1480').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-receive-idm1480').style.visibility = 'hidden';" id="receive">8.10 Receive</span> </h2> <pre data-language="erlang">
receive
    Pattern1 [when GuardSeq1] -&gt;
        Body1;
    ...;
    PatternN [when GuardSeqN] -&gt;
        BodyN
end</pre> <p> Fetches a received message present in the message queue of the process. The patterns <code class="code">Pattern</code> are sequentially matched against the first message in the message queue, then the second, and so on. Messages in the message queue are <code><a href="processes#message-queue-order">ordered in the order they were received</a></code>. If a match succeeds and the optional guard sequence <code class="code">GuardSeq</code> is true, the corresponding <code class="code">Body</code> is evaluated. The matching message is consumed, that is, removed from the mail queue, while any other messages in the mail queue remain unchanged.</p> <p>The return value of <code class="code">Body</code> is the return value of the <code class="code">receive</code> expression.</p> <p><code class="code">receive</code> never fails. The execution is suspended, possibly indefinitely, until a message arrives that matches one of the patterns and with a true guard sequence. </p> <p><strong>Example:</strong></p> <pre data-language="erlang">
wait_for_onhook() -&gt;
    receive
        onhook -&gt;
            disconnect(),
            idle();
        {connect, B} -&gt;
            B ! {busy, self()},
            wait_for_onhook()
    end.</pre> <p>The <code class="code">receive</code> expression can be augmented with a timeout:</p> <pre data-language="erlang">
receive
    Pattern1 [when GuardSeq1] -&gt;
        Body1;
    ...;
    PatternN [when GuardSeqN] -&gt;
        BodyN
after
    ExprT -&gt;
        BodyT
end</pre> <p><code class="code">ExprT</code> is to evaluate to an integer. The highest allowed value is 16#FFFFFFFF, that is, the value must fit in 32 bits. <code class="code">receive..after</code> works exactly as <code class="code">receive</code>, except that if no matching message has arrived within <code class="code">ExprT</code> milliseconds, then <code class="code">BodyT</code> is evaluated instead. The return value of <code class="code">BodyT</code> then becomes the return value of the <code class="code">receive..after</code> expression.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
wait_for_onhook() -&gt;
    receive
        onhook -&gt;
            disconnect(),
            idle();
        {connect, B} -&gt;
            B ! {busy, self()},
            wait_for_onhook()
    after
        60000 -&gt;
            disconnect(),
            error()
    end.</pre> <p>It is legal to use a <code class="code">receive..after</code> expression with no branches:</p> <pre data-language="erlang">
receive
after
    ExprT -&gt;
        BodyT
end</pre> <p>This construction does not consume any messages, only suspends execution in the process for <code class="code">ExprT</code> milliseconds. This can be used to implement simple timers.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
timer() -&gt;
    spawn(m, timer, [self()]).

timer(Pid) -&gt;
    receive
    after
        5000 -&gt;
            Pid ! timeout
    end.</pre> <p>There are two special cases for the timeout value <code class="code">ExprT</code>:</p> <dl> <dt><strong><code class="code">infinity</code></strong></dt> <dd>The process is to wait indefinitely for a matching message; this is the same as not using a timeout. This can be useful for timeout values that are calculated at runtime.</dd> <dt><strong>0</strong></dt> <dd>If there is no matching message in the mailbox, the timeout occurs immediately.</dd> </dl> <h2><span onmouseover="document.getElementById('ghlink-term-comparisons-idm1527').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-term-comparisons-idm1527').style.visibility = 'hidden';">8.11 Term Comparisons</span></h2> <pre data-language="erlang">
Expr1 op Expr2</pre> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>op</strong></td> <td><strong>Description</strong></td> </tr> <tr> <td>==</td> <td>Equal to</td> </tr> <tr> <td>/=</td> <td>Not equal to</td> </tr> <tr> <td>=&lt;</td> <td>Less than or equal to</td> </tr> <tr> <td>&lt;</td> <td>Less than</td> </tr> <tr> <td>&gt;=</td> <td>Greater than or equal to</td> </tr> <tr> <td>&gt;</td> <td>Greater than</td> </tr> <tr> <td>=:=</td> <td>Exactly equal to</td> </tr> <tr> <td>=/=</td> <td>Exactly not equal to</td> </tr> </table> <p class="doc-table-caption">Table 8.1: Term Comparison Operators.</p> </div> <p>The arguments can be of different data types. The following order is defined:</p> <pre data-language="erlang">
number &lt; atom &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; map &lt; nil &lt; list &lt; bit string</pre> <p><code class="code">nil</code> in the previous expression represents the empty list (<code class="code">[]</code>), which is regarded as a separate type from <code class="code">list/0</code>. That is why <code class="code">nil &lt; list</code>. </p> <p>Lists are compared element by element. Tuples are ordered by size, two tuples with the same size are compared element by element.</p> <p>Bit strings are compared bit by bit. If one bit string is a prefix of the other, the shorter bit string is considered smaller.</p> <p>Maps are ordered by size, two maps with the same size are compared by keys in ascending term order and then by values in key order. In maps key order integers types are considered less than floats types. </p> <p>Atoms are compared using their string value, codepoint by codepoint.</p> <p>When comparing an integer to a float, the term with the lesser precision is converted into the type of the other term, unless the operator is one of <code class="code">=:=</code> or <code class="code">=/=</code>. A float is more precise than an integer until all significant figures of the float are to the left of the decimal point. This happens when the float is larger/smaller than +/-9007199254740992.0. The conversion strategy is changed depending on the size of the float because otherwise comparison of large floats and integers would lose their transitivity.</p> <p>Term comparison operators return the Boolean value of the expression, <code class="code">true</code> or <code class="code">false</code>.</p> <p><strong>Examples:</strong></p> <pre data-language="erlang">
1&gt; 1==1.0.
true
2&gt; 1=:=1.0.
false
3&gt; 1 &gt; a.
false
4&gt; #{c =&gt; 3} &gt; #{a =&gt; 1, b =&gt; 2}.
false
5&gt; #{a =&gt; 1, b =&gt; 2} == #{a =&gt; 1.0, b =&gt; 2.0}.
true
6&gt; &lt;&lt;2:2&gt;&gt; &lt; &lt;&lt;128&gt;&gt;.
true
7&gt; &lt;&lt;3:2&gt;&gt; &lt; &lt;&lt;128&gt;&gt;.
false
</pre> <h2><span onmouseover="document.getElementById('ghlink-arithmetic-expressions-idm1589').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-arithmetic-expressions-idm1589').style.visibility = 'hidden';">8.12 Arithmetic Expressions</span></h2> <pre data-language="erlang">
op Expr
Expr1 op Expr2</pre> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Operator</strong></td> <td><strong>Description</strong></td> <td><strong>Argument Type</strong></td> </tr> <tr> <td>+</td> <td>Unary +</td> <td>Number</td> </tr> <tr> <td>-</td> <td>Unary -</td> <td>Number</td> </tr> <tr> <td>+</td> <td> </td> <td>number</td> </tr> <tr> <td>-</td> <td> </td> <td>Number</td> </tr> <tr> <td>*</td> <td> </td> <td>Number</td> </tr> <tr> <td>/</td> <td>Floating point division</td> <td>Number</td> </tr> <tr> <td>bnot</td> <td>Unary bitwise NOT</td> <td>Integer</td> </tr> <tr> <td>div</td> <td>Integer division</td> <td>Integer</td> </tr> <tr> <td>rem</td> <td>Integer remainder of X/Y</td> <td>Integer</td> </tr> <tr> <td>band</td> <td>Bitwise AND</td> <td>Integer</td> </tr> <tr> <td>bor</td> <td>Bitwise OR</td> <td>Integer</td> </tr> <tr> <td>bxor</td> <td>Arithmetic bitwise XOR</td> <td>Integer</td> </tr> <tr> <td>bsl</td> <td>Arithmetic bitshift left</td> <td>Integer</td> </tr> <tr> <td>bsr</td> <td>Bitshift right</td> <td>Integer</td> </tr> </table> <p class="doc-table-caption">Table 8.2: Arithmetic Operators.</p> </div> <p><strong>Examples:</strong></p> <pre data-language="erlang">
1&gt; +1.
1
2&gt; -1.
-1
3&gt; 1+1.
2
4&gt; 4/2.
2.0
5&gt; 5 div 2.
2
6&gt; 5 rem 2.
1
7&gt; 2#10 band 2#01.
0
8&gt; 2#10 bor 2#01.
3
9&gt; a + 10.
** exception error: an error occurred when evaluating an arithmetic expression
     in operator  +/2
        called as a + 10
10&gt; 1 bsl (1 bsl 64).
** exception error: a system limit has been reached
     in operator  bsl/2
        called as 1 bsl 18446744073709551616</pre> <h2><span onmouseover="document.getElementById('ghlink-boolean-expressions-idm1672').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-boolean-expressions-idm1672').style.visibility = 'hidden';">8.13 Boolean Expressions</span></h2> <pre data-language="erlang">
op Expr
Expr1 op Expr2</pre> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Operator</strong></td> <td><strong>Description</strong></td> </tr> <tr> <td>not</td> <td>Unary logical NOT</td> </tr> <tr> <td>and</td> <td>Logical AND</td> </tr> <tr> <td>or</td> <td>Logical OR</td> </tr> <tr> <td>xor</td> <td>Logical XOR</td> </tr> </table> <p class="doc-table-caption">Table 8.3: Logical Operators.</p> </div> <p><strong>Examples:</strong></p> <pre data-language="erlang">
1&gt; not true.
false
2&gt; true and false.
false
3&gt; true xor false.
true
4&gt; true or garbage.
** exception error: bad argument
     in operator  or/2
        called as true or garbage</pre> <h2><span onmouseover="document.getElementById('ghlink-short-circuit-expressions-idm1703').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-short-circuit-expressions-idm1703').style.visibility = 'hidden';">8.14 Short-Circuit Expressions</span></h2> <pre data-language="erlang">
Expr1 orelse Expr2
Expr1 andalso Expr2</pre> <p><code class="code">Expr2</code> is evaluated only if necessary. That is, <code class="code">Expr2</code> is evaluated only if:</p> <ul> <li> <p><code class="code">Expr1</code> evaluates to <code class="code">false</code> in an <code class="code">orelse</code> expression.</p> </li> </ul> <p>or</p> <ul> <li> <p><code class="code">Expr1</code> evaluates to <code class="code">true</code> in an <code class="code">andalso</code> expression.</p> </li> </ul> <p>Returns either the value of <code class="code">Expr1</code> (that is, <code class="code">true</code> or <code class="code">false</code>) or the value of <code class="code">Expr2</code> (if <code class="code">Expr2</code> is evaluated).</p> <p><strong>Example 1:</strong></p> <pre data-language="erlang">
case A &gt;= -1.0 andalso math:sqrt(A+1) &gt; B of</pre> <p>This works even if <code class="code">A</code> is less than <code class="code">-1.0</code>, since in that case, <code class="code">math:sqrt/1</code> is never evaluated.</p> <p><strong>Example 2:</strong></p> <pre data-language="erlang">
OnlyOne = is_atom(L) orelse
         (is_list(L) andalso length(L) == 1),</pre> <p>From Erlang/OTP R13A, <code class="code">Expr2</code> is no longer required to evaluate to a Boolean value. As a consequence, <code class="code">andalso</code> and <code class="code">orelse</code> are now tail-recursive. For instance, the following function is tail-recursive in Erlang/OTP R13A and later:</p> <pre data-language="erlang">
all(Pred, [Hd|Tail]) -&gt;
    Pred(Hd) andalso all(Pred, Tail);
all(_, []) -&gt;
    true.</pre> <h2><span onmouseover="document.getElementById('ghlink-list-operations-idm1743').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-list-operations-idm1743').style.visibility = 'hidden';">8.15 List Operations</span></h2> <pre data-language="erlang">
Expr1 ++ Expr2
Expr1 -- Expr2</pre> <p>The list concatenation operator <code class="code">++</code> appends its second argument to its first and returns the resulting list.</p> <p>The list subtraction operator <code class="code">--</code> produces a list that is a copy of the first argument. The procedure is a follows: for each element in the second argument, the first occurrence of this element (if any) is removed.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; [1,2,3]++[4,5].
[1,2,3,4,5]
2&gt; [1,2,3,2,1,2]--[2,1,2].
[3,1,2]</pre> <h2> <span onmouseover="document.getElementById('ghlink-map-expressions-idm1755').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-map-expressions-idm1755').style.visibility = 'hidden';" id="map_expressions">8.16 Map Expressions</span> </h2> <h4><span onmouseover="document.getElementById('ghlink-creating-maps-idm1758').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-creating-maps-idm1758').style.visibility = 'hidden';">Creating Maps</span></h4> <p> Constructing a new map is done by letting an expression <code class="code">K</code> be associated with another expression <code class="code">V</code>: </p> <pre data-language="erlang">#{ K =&gt; V }</pre> <p> New maps can include multiple associations at construction by listing every association: </p> <pre data-language="erlang">#{ K1 =&gt; V1, .., Kn =&gt; Vn }</pre> <p> An empty map is constructed by not associating any terms with each other: </p> <pre data-language="erlang">#{}</pre> <p> All keys and values in the map are terms. Any expression is first evaluated and then the resulting terms are used as <strong>key</strong> and <strong>value</strong> respectively. </p> <p> Keys and values are separated by the <code class="code">=&gt;</code> arrow and associations are separated by a comma <code class="code">,</code>. </p> <p> <strong>Examples:</strong> </p> <pre data-language="erlang">M0 = #{},                 % empty map
M1 = #{a =&gt; &lt;&lt;"hello"&gt;&gt;}, % single association with literals
M2 = #{1 =&gt; 2, b =&gt; b},   % multiple associations with literals
M3 = #{k =&gt; {A,B}},       % single association with variables
M4 = #{{"w", 1} =&gt; f()}.  % compound key associated with an evaluated expression</pre> <p> Here, <code class="code">A</code> and <code class="code">B</code> are any expressions and <code class="code">M0</code> through <code class="code">M4</code> are the resulting map terms. </p> <p> If two matching keys are declared, the latter key takes precedence. </p> <p> <strong>Example:</strong> </p> <pre data-language="erlang">
1&gt; #{1 =&gt; a, 1 =&gt; b}.
#{1 =&gt; b }
2&gt; #{1.0 =&gt; a, 1 =&gt; b}.
#{1 =&gt; b, 1.0 =&gt; a}
</pre> <p> The order in which the expressions constructing the keys (and their associated values) are evaluated is not defined. The syntactic order of the key-value pairs in the construction is of no relevance, except in the recently mentioned case of two matching keys. </p> <h4><span onmouseover="document.getElementById('ghlink-updating-maps-idm1789').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-updating-maps-idm1789').style.visibility = 'hidden';">Updating Maps</span></h4> <p> Updating a map has a similar syntax as constructing it. </p> <p> An expression defining the map to be updated, is put in front of the expression defining the keys to be updated and their respective values: </p> <pre data-language="erlang">M#{ K =&gt; V }</pre> <p> Here <code class="code">M</code> is a term of type map and <code class="code">K</code> and <code class="code">V</code> are any expression. </p> <p> If key <code class="code">K</code> does not match any existing key in the map, a new association is created from key <code class="code">K</code> to value <code class="code">V</code>. </p> <p> If key <code class="code">K</code> matches an existing key in map <code class="code">M</code>, its associated value is replaced by the new value <code class="code">V</code>. In both cases, the evaluated map expression returns a new map. </p> <p> If <code class="code">M</code> is not of type map, an exception of type <code class="code">badmap</code> is thrown. </p> <p> To only update an existing value, the following syntax is used: </p> <pre data-language="erlang">M#{ K := V } </pre> <p> Here <code class="code">M</code> is a term of type map, <code class="code">V</code> is an expression and <code class="code">K</code> is an expression that evaluates to an existing key in <code class="code">M</code>. </p> <p> If key <code class="code">K</code> does not match any existing keys in map <code class="code">M</code>, an exception of type <code class="code">badarg</code> is triggered at runtime. If a matching key <code class="code">K</code> is present in map <code class="code">M</code>, its associated value is replaced by the new value <code class="code">V</code>, and the evaluated map expression returns a new map. </p> <p> If <code class="code">M</code> is not of type map, an exception of type <code class="code">badmap</code> is thrown. </p> <p> <strong>Examples:</strong> </p> <pre data-language="erlang">M0 = #{},
M1 = M0#{a =&gt; 0},
M2 = M1#{a =&gt; 1, b =&gt; 2},
M3 = M2#{"function" =&gt; fun() -&gt; f() end},
M4 = M3#{a := 2, b := 3}.  % 'a' and 'b' was added in `M1` and `M2`.</pre> <p> Here <code class="code">M0</code> is any map. It follows that <code class="code">M1 .. M4</code> are maps as well. </p> <p> <strong>More examples:</strong> </p> <pre data-language="erlang">
1&gt; M = #{1 =&gt; a}.
#{1 =&gt; a }
2&gt; M#{1.0 =&gt; b}.
#{1 =&gt; a, 1.0 =&gt; b}.
3&gt; M#{1 := b}.
#{1 =&gt; b}
4&gt; M#{1.0 := b}.
** exception error: bad argument
</pre> <p> As in construction, the order in which the key and value expressions are evaluated is not defined. The syntactic order of the key-value pairs in the update is of no relevance, except in the case where two keys match. In that case, the latter value is used. </p> <h4><span onmouseover="document.getElementById('ghlink-maps-in-patterns-idm1840').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-maps-in-patterns-idm1840').style.visibility = 'hidden';">Maps in Patterns</span></h4> <p> Matching of key-value associations from maps is done as follows: </p> <pre data-language="erlang">#{ K := V } = M</pre> <p> Here <code class="code">M</code> is any map. The key <code class="code">K</code> must be a <code><a href="#guard_expressions">guard expression</a></code>, with all variables already bound. <code class="code">V</code> can be any pattern with either bound or unbound variables. </p> <p> If the variable <code class="code">V</code> is unbound, it becomes bound to the value associated with the key <code class="code">K</code>, which must exist in the map <code class="code">M</code>. If the variable <code class="code">V</code> is bound, it must match the value associated with <code class="code">K</code> in <code class="code">M</code>. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Before OTP 23, the expression defining the key <code class="code">K</code> was restricted to be either a single variable or a literal.</p>
</div> </div> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; M = #{"tuple" =&gt; {1,2}}.
#{"tuple" =&gt; {1,2}}
2&gt; #{"tuple" := {1,B}} = M.
#{"tuple" =&gt; {1,2}}
3&gt; B.
2.</pre> <p> This binds variable <code class="code">B</code> to integer <code class="code">2</code>. </p> <p> Similarly, multiple values from the map can be matched: </p> <pre data-language="erlang">#{ K1 := V1, .., Kn := Vn } = M</pre> <p> Here keys <code class="code">K1 .. Kn</code> are any expressions with literals or bound variables. If all key expressions evalute successfully and all keys exist in map <code class="code">M</code>, all variables in <code class="code">V1 .. Vn</code> is matched to the associated values of their respective keys. </p> <p> If the matching conditions are not met, the match fails, either with: </p> <ul> <li> <p>A <code class="code">badmatch</code> exception.</p> <p>This is if it is used in the context of the match operator as in the example.</p> </li> <li> <p>Or resulting in the next clause being tested in function heads and case expressions.</p> </li> </ul> <p> Matching in maps only allows for <code class="code">:=</code> as delimiters of associations. </p> <p> The order in which keys are declared in matching has no relevance. </p> <p> Duplicate keys are allowed in matching and match each pattern associated to the keys: </p> <pre data-language="erlang">#{ K := V1, K := V2 } = M</pre> <p> Matching an expression against an empty map literal, matches its type but no variables are bound: </p> <pre data-language="erlang">#{} = Expr</pre> <p> This expression matches if the expression <code class="code">Expr</code> is of type map, otherwise it fails with an exception <code class="code">badmatch</code>. </p> <p>Here the key to be retrieved is constructed from an expression:</p> <pre data-language="erlang">#{{tag,length(List)} := V} = Map</pre> <p><code class="code">List</code> must be an already bound variable.</p> <h5>Matching Syntax</h5> <p> Matching of literals as keys are allowed in function heads: </p> <pre data-language="erlang">%% only start if not_started
handle_call(start, From, #{ state := not_started } = S) -&gt;
...
    {reply, ok, S#{ state := start }};

%% only change if started
handle_call(change, From, #{ state := start } = S) -&gt;
...
    {reply, ok, S#{ state := changed }};</pre> <h4><span onmouseover="document.getElementById('ghlink-maps-in-guards-idm1900').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-maps-in-guards-idm1900').style.visibility = 'hidden';">Maps in Guards</span></h4> <p> Maps are allowed in guards as long as all subexpressions are valid guard expressions. </p> <p> The following guard BIFs handle maps: </p> <ul> <li> <code>is_map/1</code> in the <code class="code">erlang</code> module </li> <li> <code>map_get/2</code> in the <code class="code">erlang</code> module </li> <li> <code>map_size/1</code> in the <code class="code">erlang</code> module </li> </ul> <h2> <span onmouseover="document.getElementById('ghlink-bit-syntax-expressions-idm1914').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-bit-syntax-expressions-idm1914').style.visibility = 'hidden';" id="bit_syntax">8.17 Bit Syntax Expressions</span> </h2> <pre data-language="erlang">&lt;&lt;&gt;&gt;
&lt;&lt;E1,...,En&gt;&gt;</pre> <p>Each element <code class="code">Ei</code> specifies a <strong>segment</strong> of the bit string. Each element <code class="code">Ei</code> is a value, followed by an optional <strong>size expression</strong> and an optional <strong>type specifier list</strong>.</p> <pre data-language="erlang">
Ei = Value |
     Value:Size |
     Value/TypeSpecifierList |
     Value:Size/TypeSpecifierList</pre> <p>Used in a bit string construction, <code class="code">Value</code> is an expression that is to evaluate to an integer, float, or bit string. If the expression is not a single literal or variable, it is to be enclosed in parentheses.</p> <p>Used in a bit string matching, <code class="code">Value</code> must be a variable, or an integer, float, or string.</p> <p>Notice that, for example, using a string literal as in <code class="code">&lt;&lt;"abc"&gt;&gt;</code> is syntactic sugar for <code class="code">&lt;&lt;$a,$b,$c&gt;&gt;</code>.</p> <p>Used in a bit string construction, <code class="code">Size</code> is an expression that is to evaluate to an integer.</p> <p>Used in a bit string matching, <code class="code">Size</code> must be a <code><a href="#guard_expressions">guard expression</a></code> that evaluates to an integer. All variables in the guard expression must be already bound.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Before OTP 23, <code class="code">Size</code> was restricted to be an integer or a variable bound to an integer.</p>
</div> </div> <p>The value of <code class="code">Size</code> specifies the size of the segment in units (see below). The default value depends on the type (see below):</p> <ul> <li>For <code class="code">integer</code> it is 8.</li> <li>For <code class="code">float</code> it is 64.</li> <li>For <code class="code">binary</code> and <code class="code">bitstring</code> it is the whole binary or bit string.</li> </ul> <p>In matching, this default value is only valid for the last element. All other bit string or binary elements in the matching must have a size specification.</p> <p>For the <code class="code">utf8</code>, <code class="code">utf16</code>, and <code class="code">utf32</code> types, <code class="code">Size</code> must not be given. The size of the segment is implicitly determined by the type and value itself.</p> <p><code class="code">TypeSpecifierList</code> is a list of type specifiers, in any order, separated by hyphens (-). Default values are used for any omitted type specifiers.</p> <dl> <dt><strong><code class="code">Type</code>= <code class="code">integer</code> | <code class="code">float</code> | <code class="code">binary</code> | <code class="code">bytes</code> | <code class="code">bitstring</code> | <code class="code">bits</code> | <code class="code">utf8</code> | <code class="code">utf16</code> | <code class="code">utf32</code> </strong></dt> <dd>The default is <code class="code">integer</code>. <code class="code">bytes</code> is a shorthand for <code class="code">binary</code> and <code class="code">bits</code> is a shorthand for <code class="code">bitstring</code>. See below for more information about the <code class="code">utf</code> types. </dd> <dt><strong><code class="code">Signedness</code>= <code class="code">signed</code> | <code class="code">unsigned</code></strong></dt> <dd>Only matters for matching and when the type is <code class="code">integer</code>. The default is <code class="code">unsigned</code>.</dd> <dt><strong><code class="code">Endianness</code>= <code class="code">big</code> | <code class="code">little</code> | <code class="code">native</code></strong></dt> <dd>Native-endian means that the endianness is resolved at load time to be either big-endian or little-endian, depending on what is native for the CPU that the Erlang machine is run on. Endianness only matters when the Type is either <code class="code">integer</code>, <code class="code">utf16</code>, <code class="code">utf32</code>, or <code class="code">float</code>. The default is <code class="code">big</code>. </dd> <dt><strong><code class="code">Unit</code>= <code class="code">unit:IntegerLiteral</code></strong></dt> <dd>The allowed range is 1..256. Defaults to 1 for <code class="code">integer</code>, <code class="code">float</code>, and <code class="code">bitstring</code>, and to 8 for <code class="code">binary</code>. No unit specifier must be given for the types <code class="code">utf8</code>, <code class="code">utf16</code>, and <code class="code">utf32</code>. </dd> </dl> <p>The value of <code class="code">Size</code> multiplied with the unit gives the number of bits. A segment of type <code class="code">binary</code> must have a size that is evenly divisible by 8. For a segment of type <code class="code">float</code> the size must be either 64, 32, or 16.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>When constructing binaries, if the size <code class="code">N</code> of an integer segment is too small to contain the given integer, the most significant bits of the integer are silently discarded and only the <code class="code">N</code> least significant bits are put into the binary.</p>
</div> </div> <p>The types <code class="code">utf8</code>, <code class="code">utf16</code>, and <code class="code">utf32</code> specifies encoding/decoding of the <strong>Unicode Transformation Format</strong>s UTF-8, UTF-16, and UTF-32, respectively.</p> <p>When constructing a segment of a <code class="code">utf</code> type, <code class="code">Value</code> must be an integer in the range 0..16#D7FF or 16#E000....16#10FFFF. Construction fails with a <code class="code">badarg</code> exception if <code class="code">Value</code> is outside the allowed ranges. The size of the resulting binary segment depends on the type or <code class="code">Value</code>, or both:</p> <ul> <li>For <code class="code">utf8</code>, <code class="code">Value</code> is encoded in 1-4 bytes.</li> <li>For <code class="code">utf16</code>, <code class="code">Value</code> is encoded in 2 or 4 bytes.</li> <li>For <code class="code">utf32</code>, <code class="code">Value</code> is always be encoded in 4 bytes.</li> </ul> <p>When constructing, a literal string can be given followed by one of the UTF types, for example: <code class="code">&lt;&lt;"abc"/utf8&gt;&gt;</code> which is syntactic sugar for <code class="code">&lt;&lt;$a/utf8,$b/utf8,$c/utf8&gt;&gt;</code>.</p> <p>A successful match of a segment of a <code class="code">utf</code> type, results in an integer in the range 0..16#D7FF or 16#E000..16#10FFFF. The match fails if the returned value falls outside those ranges.</p> <p>A segment of type <code class="code">utf8</code> matches 1-4 bytes in the binary, if the binary at the match position contains a valid UTF-8 sequence. (See RFC-3629 or the Unicode standard.)</p> <p>A segment of type <code class="code">utf16</code> can match 2 or 4 bytes in the binary. The match fails if the binary at the match position does not contain a legal UTF-16 encoding of a Unicode code point. (See RFC-2781 or the Unicode standard.)</p> <p>A segment of type <code class="code">utf32</code> can match 4 bytes in the binary in the same way as an <code class="code">integer</code> segment matches 32 bits. The match fails if the resulting integer is outside the legal ranges mentioned above.</p> <p><strong>Examples:</strong></p> <pre data-language="erlang">
1&gt; Bin1 = &lt;&lt;1,17,42&gt;&gt;.
&lt;&lt;1,17,42&gt;&gt;
2&gt; Bin2 = &lt;&lt;"abc"&gt;&gt;.
&lt;&lt;97,98,99&gt;&gt;
3&gt; Bin3 = &lt;&lt;1,17,42:16&gt;&gt;.
&lt;&lt;1,17,0,42&gt;&gt;
4&gt; &lt;&lt;A,B,C:16&gt;&gt; = &lt;&lt;1,17,42:16&gt;&gt;.
&lt;&lt;1,17,0,42&gt;&gt;
5&gt; C.
42
6&gt; &lt;&lt;D:16,E,F&gt;&gt; = &lt;&lt;1,17,42:16&gt;&gt;.
&lt;&lt;1,17,0,42&gt;&gt;
7&gt; D.
273
8&gt; F.
42
9&gt; &lt;&lt;G,H/binary&gt;&gt; = &lt;&lt;1,17,42:16&gt;&gt;.
&lt;&lt;1,17,0,42&gt;&gt;
10&gt; H.
&lt;&lt;17,0,42&gt;&gt;
11&gt; &lt;&lt;G,J/bitstring&gt;&gt; = &lt;&lt;1,17,42:12&gt;&gt;.
&lt;&lt;1,17,2,10:4&gt;&gt;
12&gt; J.
&lt;&lt;17,2,10:4&gt;&gt;
13&gt; &lt;&lt;1024/utf8&gt;&gt;.
&lt;&lt;208,128&gt;&gt;
</pre> <p>Notice that bit string patterns cannot be nested.</p> <p>Notice also that "<code class="code">B=&lt;&lt;1&gt;&gt;</code>" is interpreted as "<code class="code">B =&lt;&lt;1&gt;&gt;</code>" which is a syntax error. The correct way is to write a space after '=': "<code class="code">B= &lt;&lt;1&gt;&gt;</code>.</p> <p>More examples are provided in <code> Programming Examples</code>.</p> <h2> <span onmouseover="document.getElementById('ghlink-fun-expressions-idm2070').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-fun-expressions-idm2070').style.visibility = 'hidden';" id="funs">8.18 Fun Expressions</span> </h2> <pre data-language="erlang">
fun
    [Name](Pattern11,...,Pattern1N) [when GuardSeq1] -&gt;
              Body1;
    ...;
    [Name](PatternK1,...,PatternKN) [when GuardSeqK] -&gt;
              BodyK
end</pre> <p>A fun expression begins with the keyword <code class="code">fun</code> and ends with the keyword <code class="code">end</code>. Between them is to be a function declaration, similar to a <code><a href="functions#syntax">regular function declaration</a></code>, except that the function name is optional and is to be a variable, if any.</p> <p>Variables in a fun head shadow the function name and both shadow variables in the function clause surrounding the fun expression. Variables bound in a fun body are local to the fun body.</p> <p>The return value of the expression is the resulting fun.</p> <p><strong>Examples:</strong></p> <pre data-language="erlang">
1&gt; Fun1 = fun (X) -&gt; X+1 end.
#Fun&lt;erl_eval.6.39074546&gt;
2&gt; Fun1(2).
3
3&gt; Fun2 = fun (X) when X&gt;=5 -&gt; gt; (X) -&gt; lt end.
#Fun&lt;erl_eval.6.39074546&gt;
4&gt; Fun2(7).
gt
5&gt; Fun3 = fun Fact(1) -&gt; 1; Fact(X) when X &gt; 1 -&gt; X * Fact(X - 1) end.
#Fun&lt;erl_eval.6.39074546&gt;
6&gt; Fun3(4).
24</pre> <p>The following fun expressions are also allowed:</p> <pre data-language="erlang">
fun Name/Arity
fun Module:Name/Arity</pre> <p>In <code class="code">Name/Arity</code>, <code class="code">Name</code> is an atom and <code class="code">Arity</code> is an integer. <code class="code">Name/Arity</code> must specify an existing local function. The expression is syntactic sugar for:</p> <pre data-language="erlang">
fun (Arg1,...,ArgN) -&gt; Name(Arg1,...,ArgN) end</pre> <p>In <code class="code">Module:Name/Arity</code>, <code class="code">Module</code>, and <code class="code">Name</code> are atoms and <code class="code">Arity</code> is an integer. Starting from Erlang/OTP R15, <code class="code">Module</code>, <code class="code">Name</code>, and <code class="code">Arity</code> can also be variables. A fun defined in this way refers to the function <code class="code">Name</code> with arity <code class="code">Arity</code> in the <strong>latest</strong> version of module <code class="code">Module</code>. A fun defined in this way is not dependent on the code for the module in which it is defined. </p> <p>More examples are provided in <code> Programming Examples</code>.</p> <h2> <span onmouseover="document.getElementById('ghlink-catch-and-throw-idm2111').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-catch-and-throw-idm2111').style.visibility = 'hidden';" id="catch">8.19 Catch and Throw</span> </h2> <pre data-language="erlang">catch Expr</pre> <p>Returns the value of <code class="code">Expr</code> unless an exception occurs during the evaluation. In that case, the exception is caught.</p> <p>For exceptions of class <code class="code">error</code>, that is, run-time errors, <code class="code">{'EXIT',{Reason,Stack}}</code> is returned.</p> <p>For exceptions of class <code class="code">exit</code>, that is, the code called <code class="code">exit(Term)</code>, <code class="code">{'EXIT',Term}</code> is returned.</p> <p>For exceptions of class <code class="code">throw</code>, that is the code called <code class="code">throw(Term)</code>, <code class="code">Term</code> is returned.</p> <p><code class="code">Reason</code> depends on the type of error that occurred, and <code class="code">Stack</code> is the stack of recent function calls, see <code><a href="errors#exit_reasons">Exit Reasons</a></code>.</p> <p><strong>Examples:</strong></p> <pre data-language="erlang">
1&gt; catch 1+2.
3
2&gt; catch 1+a.
{'EXIT',{badarith,[...]}}</pre> <p>The BIF <code class="code">throw(Any)</code> can be used for non-local return from a function. It must be evaluated within a <code class="code">catch</code>, which returns the value <code class="code">Any</code>.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
5&gt; catch throw(hello).
hello</pre> <p>If <code class="code">throw/1</code> is not evaluated within a catch, a <code class="code">nocatch</code> run-time error occurs.</p> <h2> <span onmouseover="document.getElementById('ghlink-try-idm2148').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-try-idm2148').style.visibility = 'hidden';" id="try">8.20 Try</span> </h2> <pre data-language="erlang">try Exprs
catch
    Class1:ExceptionPattern1[:Stacktrace] [when ExceptionGuardSeq1] -&gt;
        ExceptionBody1;
    ClassN:ExceptionPatternN[:Stacktrace] [when ExceptionGuardSeqN] -&gt;
        ExceptionBodyN
end</pre> <p>This is an enhancement of <code><a href="#catch">catch</a></code>. It gives the possibility to:</p> <ul> <li>Distinguish between different exception classes.</li> <li>Choose to handle only the desired ones.</li> <li>Passing the others on to an enclosing <code class="code">try</code> or <code class="code">catch</code>, or to default error handling.</li> </ul> <p>Notice that although the keyword <code class="code">catch</code> is used in the <code class="code">try</code> expression, there is not a <code class="code">catch</code> expression within the <code class="code">try</code> expression.</p> <p>It returns the value of <code class="code">Exprs</code> (a sequence of expressions <code class="code">Expr1, ..., ExprN</code>) unless an exception occurs during the evaluation. In that case the exception is caught and the patterns <code class="code">ExceptionPattern</code> with the right exception class <code class="code">Class</code> are sequentially matched against the caught exception. If a match succeeds and the optional guard sequence <code class="code">ExceptionGuardSeq</code> is true, the corresponding <code class="code">ExceptionBody</code> is evaluated to become the return value.</p> <p><code class="code">Stacktrace</code>, if specified, must be the name of a variable (not a pattern). The stack trace is bound to the variable when the corresponding <code class="code">ExceptionPattern</code> matches.</p> <p>If an exception occurs during evaluation of <code class="code">Exprs</code> but there is no matching <code class="code">ExceptionPattern</code> of the right <code class="code">Class</code> with a true guard sequence, the exception is passed on as if <code class="code">Exprs</code> had not been enclosed in a <code class="code">try</code> expression.</p> <p>If an exception occurs during evaluation of <code class="code">ExceptionBody</code>, it is not caught.</p> <p>It is allowed to omit <code class="code">Class</code> and <code class="code">Stacktrace</code>. An omitted <code class="code">Class</code> is shorthand for <code class="code">throw</code>:</p> <pre data-language="erlang">try Exprs
catch
    ExceptionPattern1 [when ExceptionGuardSeq1] -&gt;
        ExceptionBody1;
    ExceptionPatternN [when ExceptionGuardSeqN] -&gt;
        ExceptionBodyN
end</pre> <p>The <code class="code">try</code> expression can have an <code class="code">of</code> section: </p> <pre data-language="erlang">try Exprs of
    Pattern1 [when GuardSeq1] -&gt;
        Body1;
    ...;
    PatternN [when GuardSeqN] -&gt;
        BodyN
catch
    Class1:ExceptionPattern1[:Stacktrace] [when ExceptionGuardSeq1] -&gt;
        ExceptionBody1;
    ...;
    ClassN:ExceptionPatternN[:Stacktrace] [when ExceptionGuardSeqN] -&gt;
        ExceptionBodyN
end</pre> <p>If the evaluation of <code class="code">Exprs</code> succeeds without an exception, the patterns <code class="code">Pattern</code> are sequentially matched against the result in the same way as for a <code><a href="#case">case</a></code> expression, except that if the matching fails, a <code class="code">try_clause</code> run-time error occurs instead of a <code class="code">case_clause</code>.</p> <p>Only exceptions occurring during the evaluation of <code class="code">Exprs</code> can be caught by the <code class="code">catch</code> section. Exceptions occurring in a <code class="code">Body</code> or due to a failed match are not caught.</p> <p>The <code class="code">try</code> expression can also be augmented with an <code class="code">after</code> section, intended to be used for cleanup with side effects:</p> <pre data-language="erlang">try Exprs of
    Pattern1 [when GuardSeq1] -&gt;
        Body1;
    ...;
    PatternN [when GuardSeqN] -&gt;
        BodyN
catch
    Class1:ExceptionPattern1[:Stacktrace] [when ExceptionGuardSeq1] -&gt;
        ExceptionBody1;
    ...;
    ClassN:ExceptionPatternN[:Stacktrace] [when ExceptionGuardSeqN] -&gt;
        ExceptionBodyN
after
    AfterBody
end</pre> <p><code class="code">AfterBody</code> is evaluated after either <code class="code">Body</code> or <code class="code">ExceptionBody</code>, no matter which one. The evaluated value of <code class="code">AfterBody</code> is lost; the return value of the <code class="code">try</code> expression is the same with an <code class="code">after</code> section as without.</p> <p>Even if an exception occurs during evaluation of <code class="code">Body</code> or <code class="code">ExceptionBody</code>, <code class="code">AfterBody</code> is evaluated. In this case the exception is passed on after <code class="code">AfterBody</code> has been evaluated, so the exception from the <code class="code">try</code> expression is the same with an <code class="code">after</code> section as without.</p> <p>If an exception occurs during evaluation of <code class="code">AfterBody</code> itself, it is not caught. So if <code class="code">AfterBody</code> is evaluated after an exception in <code class="code">Exprs</code>, <code class="code">Body</code>, or <code class="code">ExceptionBody</code>, that exception is lost and masked by the exception in <code class="code">AfterBody</code>.</p> <p>The <code class="code">of</code>, <code class="code">catch</code>, and <code class="code">after</code> sections are all optional, as long as there is at least a <code class="code">catch</code> or an <code class="code">after</code> section. So the following are valid <code class="code">try</code> expressions:</p> <pre data-language="erlang">try Exprs of 
    Pattern when GuardSeq -&gt; 
        Body 
after 
    AfterBody 
end

try Exprs
catch 
    ExpressionPattern -&gt; 
        ExpressionBody
after
    AfterBody
end

try Exprs after AfterBody end</pre> <p>Next is an example of using <code class="code">after</code>. This closes the file, even in the event of exceptions in <code class="code">file:read/2</code> or in <code class="code">binary_to_term/1</code>. The exceptions are the same as without the <code class="code">try</code>...<code class="code">after</code>...<code class="code">end</code> expression:</p> <pre data-language="erlang">termize_file(Name) -&gt;
    {ok,F} = file:open(Name, [read,binary]),
    try
        {ok,Bin} = file:read(F, 1024*1024),
        binary_to_term(Bin)
    after
        file:close(F)
    end.</pre> <p>Next is an example of using <code class="code">try</code> to emulate <code class="code">catch Expr</code>:</p> <pre data-language="erlang">try Expr
catch
    throw:Term -&gt; Term;
    exit:Reason -&gt; {'EXIT',Reason}
    error:Reason:Stk -&gt; {'EXIT',{Reason,Stk}}
end</pre> <h2><span onmouseover="document.getElementById('ghlink-parenthesized-expressions-idm2248').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-parenthesized-expressions-idm2248').style.visibility = 'hidden';">8.21 Parenthesized Expressions</span></h2> <pre data-language="erlang">
(Expr)</pre> <p>Parenthesized expressions are useful to override <code><a href="#prec">operator precedences</a></code>, for example, in arithmetic expressions:</p> <pre data-language="erlang">
1&gt; 1 + 2 * 3.
7
2&gt; (1 + 2) * 3.
9</pre> <h2><span onmouseover="document.getElementById('ghlink-block-expressions-idm2256').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-block-expressions-idm2256').style.visibility = 'hidden';">8.22 Block Expressions</span></h2> <pre data-language="erlang">
begin
   Expr1,
   ...,
   ExprN
end</pre> <p>Block expressions provide a way to group a sequence of expressions, similar to a clause body. The return value is the value of the last expression <code class="code">ExprN</code>.</p> <h2> <span onmouseover="document.getElementById('ghlink-list-comprehensions-idm2261').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-list-comprehensions-idm2261').style.visibility = 'hidden';" id="lcs">8.23 List Comprehensions</span> </h2> <p>List comprehensions is a feature of many modern functional programming languages. Subject to certain rules, they provide a succinct notation for generating elements in a list.</p> <p>List comprehensions are analogous to set comprehensions in Zermelo-Frankel set theory and are called ZF expressions in Miranda. They are analogous to the <code class="code">setof</code> and <code class="code">findall</code> predicates in Prolog.</p> <p>List comprehensions are written with the following syntax:</p> <pre data-language="erlang">
[Expr || Qualifier1,...,QualifierN]</pre> <p>Here, <code class="code">Expr</code> is an arbitrary expression, and each <code class="code">Qualifier</code> is either a generator or a filter.</p> <ul> <li>A <strong>generator</strong> is written as: <br> <code class="code">Pattern &lt;- ListExpr</code>. <br> <code class="code">ListExpr</code> must be an expression, which evaluates to a list of terms.</li> <li>A <strong>bit string generator</strong> is written as: <br> <code class="code">BitstringPattern &lt;= BitStringExpr</code>. <br> <code class="code">BitStringExpr</code> must be an expression, which evaluates to a bitstring.</li> <li>A <strong>filter</strong> is an expression, which evaluates to <code class="code">true</code> or <code class="code">false</code>.</li> </ul> <p>The variables in the generator patterns, shadow variables in the function clause, surrounding the list comprehensions.</p> <p>A list comprehension returns a list, where the elements are the result of evaluating <code class="code">Expr</code> for each combination of generator list elements and bit string generator elements, for which all filters are true.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; [X*2 || X &lt;- [1,2,3]].
[2,4,6]</pre> <p>When there are no generators or bit string generators, a list comprehension returns either a list with one element (the result of evaluating <code class="code">Expr</code>) if all filters are true or an empty list otherwise.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; [2 || is_integer(2)].
[2]
2&gt; [x || is_integer(x)].
[]</pre> <p>More examples are provided in <code> Programming Examples.</code></p> <h2><span onmouseover="document.getElementById('ghlink-bit-string-comprehensions-idm2306').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-bit-string-comprehensions-idm2306').style.visibility = 'hidden';">8.24 Bit String Comprehensions</span></h2> <p>Bit string comprehensions are analogous to List Comprehensions. They are used to generate bit strings efficiently and succinctly.</p> <p>Bit string comprehensions are written with the following syntax:</p> <pre data-language="erlang">
&lt;&lt; BitStringExpr || Qualifier1,...,QualifierN &gt;&gt;</pre> <p><code class="code">BitStringExpr</code> is an expression that evalutes to a bit string. If <code class="code">BitStringExpr</code> is a function call, it must be enclosed in parentheses. Each <code class="code">Qualifier</code> is either a generator, a bit string generator or a filter.</p> <ul> <li>A <strong>generator</strong> is written as: <br> <code class="code">Pattern &lt;- ListExpr</code>. <br> <code class="code">ListExpr</code> must be an expression that evaluates to a list of terms.</li> <li>A <strong>bit string generator</strong> is written as: <br> <code class="code">BitstringPattern &lt;= BitStringExpr</code>. <br> <code class="code">BitStringExpr</code> must be an expression that evaluates to a bitstring.</li> <li>A <strong>filter</strong> is an expression that evaluates to <code class="code">true</code> or <code class="code">false</code>.</li> </ul> <p>The variables in the generator patterns, shadow variables in the function clause, surrounding the bit string comprehensions.</p> <p>A bit string comprehension returns a bit string, which is created by concatenating the results of evaluating <code class="code">BitString</code> for each combination of bit string generator elements, for which all filters are true.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">
1&gt; &lt;&lt; &lt;&lt; (X*2) &gt;&gt; || &lt;&lt;X&gt;&gt; &lt;= &lt;&lt; 1,2,3 &gt;&gt; &gt;&gt;.
&lt;&lt;2,4,6&gt;&gt;</pre> <p>More examples are provided in <code> Programming Examples.</code></p> <h2> <span onmouseover="document.getElementById('ghlink-guard-sequences-idm2341').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-guard-sequences-idm2341').style.visibility = 'hidden';" id="guards">8.25 Guard Sequences</span> </h2> <p>A <strong>guard sequence</strong> is a sequence of guards, separated by semicolon (;). The guard sequence is true if at least one of the guards is true. (The remaining guards, if any, are not evaluated.)</p> <p><code class="code">Guard1;...;GuardK</code></p> <p>A <strong>guard</strong> is a sequence of guard expressions, separated by comma (,). The guard is true if all guard expressions evaluate to <code class="code">true</code>.</p> <p><code class="code">GuardExpr1,...,GuardExprN</code></p> <h2> <span onmouseover="document.getElementById('ghlink-guard-expressions-idm2353').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-guard-expressions-idm2353').style.visibility = 'hidden';" id="guard_expressions">8.26 Guard Expressions</span> </h2> <p>The set of valid <strong>guard expressions</strong> is a subset of the set of valid Erlang expressions. The reason for restricting the set of valid expressions is that evaluation of a guard expression must be guaranteed to be free of side effects. Valid guard expressions are the following:</p> <ul> <li>Variables</li> <li>Constants (atoms, integer, floats, lists, tuples, records, binaries, and maps)</li> <li>Expressions that construct atoms, integer, floats, lists, tuples, records, binaries, and maps</li> <li>Expressions that update a map</li> <li>The record epxressions <code class="code">Expr#Name.Field</code> and <code class="code">#Name.Field</code> </li> <li>Calls to the BIFs specified in tables <strong>Type Test BIFs</strong> and <strong>Other BIFs Allowed in Guard Expressions</strong> </li> <li>Term comparisons</li> <li>Arithmetic expressions</li> <li>Boolean expressions</li> <li>Short-circuit expressions (<code class="code">andalso</code>/<code class="code">orelse</code>)</li> </ul> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><code class="code">is_atom/1</code></td> </tr> <tr> <td><code class="code">is_binary/1</code></td> </tr> <tr> <td><code class="code">is_bitstring/1</code></td> </tr> <tr> <td><code class="code">is_boolean/1</code></td> </tr> <tr> <td><code class="code">is_float/1</code></td> </tr> <tr> <td><code class="code">is_function/1</code></td> </tr> <tr> <td><code class="code">is_function/2</code></td> </tr> <tr> <td><code class="code">is_integer/1</code></td> </tr> <tr> <td><code class="code">is_list/1</code></td> </tr> <tr> <td><code class="code">is_map/1</code></td> </tr> <tr> <td><code class="code">is_number/1</code></td> </tr> <tr> <td><code class="code">is_pid/1</code></td> </tr> <tr> <td><code class="code">is_port/1</code></td> </tr> <tr> <td><code class="code">is_record/2</code></td> </tr> <tr> <td><code class="code">is_record/3</code></td> </tr> <tr> <td><code class="code">is_reference/1</code></td> </tr> <tr> <td><code class="code">is_tuple/1</code></td> </tr> </table> <p class="doc-table-caption">Table 8.4: Type Test BIFs</p> </div> <p>Notice that most type test BIFs have older equivalents, without the <code class="code">is_</code> prefix. These old BIFs are retained for backwards compatibility only and are not to be used in new code. They are also only allowed at top level. For example, they are not allowed in Boolean expressions in guards.</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><code class="code">abs(Number)</code></td> </tr> <tr> <td><code class="code">bit_size(Bitstring)</code></td> </tr> <tr> <td><code class="code">byte_size(Bitstring)</code></td> </tr> <tr> <td><code class="code">element(N, Tuple)</code></td> </tr> <tr> <td><code class="code">float(Term)</code></td> </tr> <tr> <td><code class="code">hd(List)</code></td> </tr> <tr> <td><code class="code">length(List)</code></td> </tr> <tr> <td><code class="code">map_get(Key, Map)</code></td> </tr> <tr> <td><code class="code">map_size(Map)</code></td> </tr> <tr> <td><code class="code">node()</code></td> </tr> <tr> <td><code class="code">node(Pid|Ref|Port)</code></td> </tr> <tr> <td><code class="code">round(Number)</code></td> </tr> <tr> <td><code class="code">self()</code></td> </tr> <tr> <td><code class="code">size(Tuple|Bitstring)</code></td> </tr> <tr> <td><code class="code">tl(List)</code></td> </tr> <tr> <td><code class="code">trunc(Number)</code></td> </tr> <tr> <td><code class="code">tuple_size(Tuple)</code></td> </tr> </table> <p class="doc-table-caption">Table 8.5: Other BIFs Allowed in Guard Expressions</p> </div> <p>If an arithmetic expression, a Boolean expression, a short-circuit expression, or a call to a guard BIF fails (because of invalid arguments), the entire guard fails. If the guard was part of a guard sequence, the next guard in the sequence (that is, the guard following the next semicolon) is evaluated.</p> <h2> <span onmouseover="document.getElementById('ghlink-operator-precedence-idm2484').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-operator-precedence-idm2484').style.visibility = 'hidden';" id="prec">8.27 Operator Precedence</span> </h2> <p>Operator precedence in falling priority:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>:</td> <td> </td> </tr> <tr> <td>#</td> <td> </td> </tr> <tr> <td>Unary + - bnot not</td> <td> </td> </tr> <tr> <td>/ * div rem band and</td> <td>Left associative</td> </tr> <tr> <td>+ - bor bxor bsl bsr or xor</td> <td>Left associative</td> </tr> <tr> <td>++ --</td> <td>Right associative</td> </tr> <tr> <td>== /= =&lt; &lt; &gt;= &gt; =:= =/=</td> <td> </td> </tr> <tr> <td>andalso</td> <td> </td> </tr> <tr> <td>orelse</td> <td> </td> </tr> <tr> <td>= !</td> <td>Right associative</td> </tr> <tr> <td>catch</td> <td> </td> </tr> </table> <p class="doc-table-caption">Table 8.6: Operator Precedence</p> </div> <p>When evaluating an expression, the operator with the highest priority is evaluated first. Operators with the same priority are evaluated according to their associativity.</p> <p><strong>Example:</strong></p> <p>The left associative arithmetic operators are evaluated left to right:</p> <pre data-language="erlang">
6 + 5 * 4 - 3 / 2 evaluates to
6 + 20 - 1.5 evaluates to
26 - 1.5 evaluates to
24.5</pre> </div> <div class="footer"> <hr> <p>Copyright © 2003-2021 Ericsson AB. All Rights Reserved.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2021 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
