<div class="innertube"> <h1>11 Release Handling</h1>  <h2 id="release%20handling"><span onmouseover="document.getElementById('ghlink-release-handling-principles-idm2944').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-release-handling-principles-idm2944').style.visibility = 'hidden';">11.1 Release Handling Principles</span></h2> <p>An important feature of the Erlang programming language is the ability to change module code in runtime, <strong>code replacement</strong>, as described in the Erlang Reference Manual.</p> <p>Based on this feature, the OTP application SASL provides a framework for upgrading and downgrading between different versions of an entire release in runtime. This is called <strong>release handling</strong>.</p> <p>The framework consists of:</p> <ul> <li>Offline support - <code class="code">systools</code> for generating scripts and building release packages</li> <li>Online support - <code class="code">release_handler</code> for unpacking and installing release packages</li> </ul> <p>The minimal system based on Erlang/OTP, enabling release handling, thus consists of the Kernel, STDLIB, and SASL applications.</p> <h4><span onmouseover="document.getElementById('ghlink-release-handling-workflow-idm2957').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-release-handling-workflow-idm2957').style.visibility = 'hidden';">Release Handling Workflow</span></h4> <p><strong>Step 1</strong>) A release is created as described in <code><a href="release_structure">Releases</a></code>.</p> <p><strong>Step 2</strong>) The release is transferred to and installed at target environment. For information of how to install the first target system, see <code>System Principles</code>.</p> <p><strong>Step 3</strong>) Modifications, for example, error corrections, are made to the code in the development environment.</p> <p><strong>Step 4</strong>) At some point, it is time to make a new version of release. The relevant <code class="code">.app</code> files are updated and a new <code class="code">.rel</code> file is written.</p> <p><strong>Step 5</strong>) For each modified application, an <code><a href="#appup">application upgrade file</a></code>, <code class="code">.appup</code>, is created. In this file, it is described how to upgrade and/or downgrade between the old and new version of the application.</p> <p><strong>Step 6</strong>) Based on the <code class="code">.appup</code> files, a <code><a href="#relup">release upgrade file</a></code> called <code class="code">relup</code>, is created. This file describes how to upgrade and/or downgrade between the old and new version of the entire release.</p> <p><strong>Step 7</strong>) A new release package is made and transferred to the target system.</p> <p><strong>Step 8</strong>) The new release package is unpacked using the release handler.</p> <p><strong>Step 9</strong>) The new version of the release is installed, also using the release handler. This is done by evaluating the instructions in <code class="code">relup</code>. Modules can be added, deleted, or reloaded, applications can be started, stopped, or restarted, and so on. In some cases, it is even necessary to restart the entire emulator.</p> <ul> <li>If the installation fails, the system can be rebooted. The old release version is then automatically used.</li> <li>If the installation succeeds, the new version is made the default version, which is to now be used if there is a system reboot.</li> </ul> <h4><span onmouseover="document.getElementById('ghlink-release-handling-aspects-idm2990').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-release-handling-aspects-idm2990').style.visibility = 'hidden';">Release Handling Aspects</span></h4> <p><code><a href="appup_cookbook">Appup Cookbook</a></code>, contains examples of <code class="code">.appup</code> files for typical cases of upgrades/downgrades that are normally easy to handle in runtime. However, many aspects can make release handling complicated, for example:</p> <ul> <li> <p>Complicated or circular dependencies can make it difficult or even impossible to decide in which order things must be done without risking runtime errors during an upgrade or downgrade. Dependencies can be:</p> <ul> <li>Between nodes</li> <li>Between processes</li> <li>Between modules</li> </ul> </li> <li> <p>During release handling, non-affected processes continue normal execution. This can lead to time-outs or other problems. For example, new processes created in the time window between suspending processes using a certain module, and loading a new version of this module, can execute old code.</p> </li> </ul> <p>It is thus recommended that code is changed in as small steps as possible, and always kept backwards compatible.</p> <h2> <span onmouseover="document.getElementById('ghlink-requirements-idm3005').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-requirements-idm3005').style.visibility = 'hidden';" id="req">11.2 Requirements</span> </h2> <p>For release handling to work properly, the runtime system must have knowledge about which release it is running. It must also be able to change (in runtime) which boot script and system configuration file to use if the system is rebooted, for example, by <code class="code">heart</code> after a failure. Thus, Erlang must be started as an embedded system; for information on how to do this, see Embedded System.</p> <p>For system reboots to work properly, it is also required that the system is started with heartbeat monitoring, see the <code class="code">erl(1)</code> manual page in ERTS and the <code class="code">heart(3)</code> manual page in Kernel</p> <p>Other requirements:</p> <ul> <li> <p>The boot script included in a release package must be generated from the same <code class="code">.rel</code> file as the release package itself.</p> <p>Information about applications is fetched from the script when an upgrade or downgrade is performed.</p> </li> <li> <p>The system must be configured using only one system configuration file, called <code class="code">sys.config</code>.</p> <p>If found, this file is automatically included when a release package is created.</p> </li> <li> <p>All versions of a release, except the first one, must contain a <code class="code">relup</code> file.</p> <p>If found, this file is automatically included when a release package is created.</p> </li> </ul> <h2><span onmouseover="document.getElementById('ghlink-distributed-systems-idm3027').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-distributed-systems-idm3027').style.visibility = 'hidden';">11.3 Distributed Systems</span></h2> <p>If the system consists of several Erlang nodes, each node can use its own version of the release. The release handler is a locally registered process and must be called at each node where an upgrade or downgrade is required. A release handling instruction, <code class="code">sync_nodes</code>, can be used to synchronize the release handler processes at a number of nodes, see the <code class="code">appup(4)</code> manual page in SASL.</p> <h2> <span onmouseover="document.getElementById('ghlink-release-handling-instructions-idm3032').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-release-handling-instructions-idm3032').style.visibility = 'hidden';" id="instr">11.4 Release Handling Instructions</span> </h2> <p>OTP supports a set of <strong>release handling instructions</strong> that are used when creating <code class="code">.appup</code> files. The release handler understands a subset of these, the <strong>low-level</strong> instructions. To make it easier for the user, there are also a number of <strong>high-level</strong> instructions, which are translated to low-level instructions by <code class="code">systools:make_relup</code>.</p> <p>Some of the most frequently used instructions are described in this section. The complete list of instructions is included in the <code class="code">appup(4)</code> manual page in SASL.</p> <p>First, some definitions:</p> <ul> <li> <strong>Residence module</strong> - The module where a process has its tail-recursive loop function(s). If these functions are implemented in several modules, all those modules are residence modules for the process.</li> <li> <strong>Functional module</strong> - A module that is not a residence module for any process.</li> </ul> <p>For a process implemented using an OTP behaviour, the behaviour module is the residence module for that process. The callback module is a functional module.</p> <h4><span onmouseover="document.getElementById('ghlink-load_module-idm3050').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-load_module-idm3050').style.visibility = 'hidden';">load_module</span></h4> <p>If a simple extension has been made to a functional module, it is sufficient to load the new version of the module into the system, and remove the old version. This is called <strong>simple code replacement</strong> and for this the following instruction is used:</p> <pre data-language="erlang">{load_module, Module}</pre> <h4><span onmouseover="document.getElementById('ghlink-update-idm3055').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-update-idm3055').style.visibility = 'hidden';">update</span></h4> <p>If a more complex change has been made, for example, a change to the format of the internal state of a <code class="code">gen_server</code>, simple code replacement is not sufficient. Instead, it is necessary to:</p> <ul> <li>Suspend the processes using the module (to avoid that they try to handle any requests before the code replacement is completed).</li> <li>Ask them to transform the internal state format and switch to the new version of the module.</li> <li>Remove the old version.</li> <li>Resume the processes.</li> </ul> <p>This is called <strong>synchronized code replacement</strong> and for this the following instructions are used:</p> <pre data-language="erlang">{update, Module, {advanced, Extra}}
{update, Module, supervisor}</pre> <p><code class="code">update</code> with argument <code class="code">{advanced,Extra}</code> is used when changing the internal state of a behaviour as described above. It causes behaviour processes to call the callback function <code class="code">code_change</code>, passing the term <code class="code">Extra</code> and some other information as arguments. See the manual pages for the respective behaviours and <code><a href="appup_cookbook#int_state">Appup Cookbook</a></code>.</p> <p><code class="code">update</code> with argument <code class="code">supervisor</code> is used when changing the start specification of a supervisor. See <code><a href="appup_cookbook#sup">Appup Cookbook</a></code>.</p> <p>When a module is to be updated, the release handler finds which processes that are <strong>using</strong> the module by traversing the supervision tree of each running application and checking all the child specifications:</p> <pre data-language="erlang">{Id, StartFunc, Restart, Shutdown, Type, Modules}</pre> <p>A process uses a module if the name is listed in <code class="code">Modules</code> in the child specification for the process.</p> <p>If <code class="code">Modules=dynamic</code>, which is the case for event managers, the event manager process informs the release handler about the list of currently installed event handlers (<code class="code">gen_event</code>), and it is checked if the module name is in this list instead.</p> <p>The release handler suspends, asks for code change, and resumes processes by calling the functions <code class="code">sys:suspend/1,2</code>, <code class="code">sys:change_code/4,5</code>, and <code class="code">sys:resume/1,2</code>, respectively.</p> <h4><span onmouseover="document.getElementById('ghlink-add_module-and-delete_module-idm3089').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-add_module-and-delete_module-idm3089').style.visibility = 'hidden';">add_module and delete_module</span></h4> <p>If a new module is introduced, the following instruction is used:</p> <pre data-language="erlang">{add_module, Module}</pre> <p>The instruction loads the module and is necessary when running Erlang in embedded mode. It is not strictly required when running Erlang in interactive (default) mode, since the code server then automatically searches for and loads unloaded modules.</p> <p>The opposite of <code class="code">add_module</code> is <code class="code">delete_module</code>, which unloads a module:</p> <pre data-language="erlang">{delete_module, Module}</pre> <p>Any process, in any application, with <code class="code">Module</code> as residence module, is killed when the instruction is evaluated. The user must therefore ensure that all such processes are terminated before deleting the module, to avoid a situation with failing supervisor restarts.</p> <h4><span onmouseover="document.getElementById('ghlink-application-instructions-idm3100').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-application-instructions-idm3100').style.visibility = 'hidden';">Application Instructions</span></h4> <p>The following is the instruction for adding an application:</p> <pre data-language="erlang">{add_application, Application}</pre> <p>Adding an application means that the modules defined by the <code class="code">modules</code> key in the <code class="code">.app</code> file are loaded using a number of <code class="code">add_module</code> instructions, and then the application is started.</p> <p>The following is the instruction for removing an application:</p> <pre data-language="erlang">{remove_application, Application}</pre> <p>Removing an application means that the application is stopped, the modules are unloaded using a number of <code class="code">delete_module</code> instructions, and then the application specification is unloaded from the application controller.</p> <p>The following is the instruction for restarting an application:</p> <pre data-language="erlang">{restart_application, Application}</pre> <p>Restarting an application means that the application is stopped and then started again similar to using the instructions <code class="code">remove_application</code> and <code class="code">add_application</code> in sequence.</p> <h4><span onmouseover="document.getElementById('ghlink-apply--low-level--idm3117').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-apply--low-level--idm3117').style.visibility = 'hidden';">apply (Low-Level)</span></h4> <p>To call an arbitrary function from the release handler, the following instruction is used:</p> <pre data-language="erlang">{apply, {M, F, A}}</pre> <p>The release handler evalutes <code class="code">apply(M, F, A)</code>.</p> <h4> <span onmouseover="document.getElementById('ghlink-restart_new_emulator--low-level--idm3123').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-restart_new_emulator--low-level--idm3123').style.visibility = 'hidden';" id="restart_new_emulator_instr">restart_new_emulator (Low-Level)</span> </h4> <p>This instruction is used when changing to a new emulator version, or when any of the core applications Kernel, STDLIB, or SASL is upgraded. If a system reboot is needed for another reason, the <code class="code">restart_emulator</code> instruction is to be used instead.</p> <p>This instruction requires that the system is started with heartbeat monitoring, see the <code class="code">erl(1)</code> manual page in ERTS and the <code class="code">heart(3)</code> manual page in Kernel.</p> <p>The <code class="code">restart_new_emulator</code> instruction must always be the first instruction in a relup. If the relup is generated by <code class="code">systools:make_relup/3,4</code>, this is automatically ensured.</p> <p>When the release handler encounters the instruction, it first generates a temporary boot file, which starts the new versions of the emulator and the core applications, and the old version of all other applications. Then it shuts down the current emulator by calling <code class="code">init:reboot()</code>, see the <code class="code">init(3)</code> manual page in Kernel. All processes are terminated gracefully and the system is rebooted by the <code class="code">heart</code> program, using the temporary boot file. After the reboot, the rest of the relup instructions are executed. This is done as a part of the temporary boot script.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This mechanism causes the new versions of the emulator and core applications to run with the old version of other applications during startup. Thus, take extra care to avoid incompatibility. Incompatible changes in the core applications can in some situations be necessary. If possible, such changes are preceded by deprecation over two major releases before the actual change. To ensure the application is not crashed by an incompatible change, always remove any call to deprecated functions as soon as possible.</p> </div> </div> <p>An info report is written when the upgrade is completed. To programmatically find out if the upgrade is complete, call <code class="code">release_handler:which_releases(current)</code> and check if it returns the expected (that is, the new) release.</p> <p>The new release version must be made permanent when the new emulator is operational. Otherwise, the old version will be used if there is a new system reboot.</p> <p>On UNIX, the release handler tells the <code class="code">heart</code> program which command to use to reboot the system. The environment variable <code class="code">HEART_COMMAND</code>, normally used by the <code class="code">heart</code> program, is ignored in this case. The command instead defaults to <code class="code">$ROOT/bin/start</code>. Another command can be set by using the SASL configuration parameter <code class="code">start_prg</code>, see the <code class="code">sasl(6)</code> manual page.</p> <h4> <span onmouseover="document.getElementById('ghlink-restart_emulator--low-level--idm3150').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-restart_emulator--low-level--idm3150').style.visibility = 'hidden';" id="restart_emulator_instr">restart_emulator (Low-Level)</span> </h4> <p>This instruction is not related to upgrades of ERTS or any of the core applications. It can be used by any application to force a restart of the emulator after all upgrade instructions are executed.</p> <p>A relup script can only have one <code class="code">restart_emulator</code> instruction and it must always be placed at the end. If the relup is generated by <code class="code">systools:make_relup/3,4</code>, this is automatically ensured.</p> <p>When the release handler encounters the instruction, it shuts down the emulator by calling <code class="code">init:reboot()</code>, see the <code class="code">init(3)</code> manual page in Kernel. All processes are terminated gracefully and the system can then be rebooted by the <code class="code">heart</code> program using the new release version. No more upgrade instruction is executed after the restart.</p> <h2> <span onmouseover="document.getElementById('ghlink-application-upgrade-file-idm3161').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-application-upgrade-file-idm3161').style.visibility = 'hidden';" id="appup">11.5 Application Upgrade File</span> </h2> <p>To define how to upgrade/downgrade between the current version and previous versions of an application, an <strong>application upgrade file</strong>, or in short an <code class="code">.appup</code> file is created. The file is to be called <code class="code">Application.appup</code>, where <code class="code">Application</code> is the application name:</p> <pre data-language="erlang">{Vsn,
 [{UpFromVsn1, InstructionsU1},
  ...,
  {UpFromVsnK, InstructionsUK}],
 [{DownToVsn1, InstructionsD1},
  ...,
  {DownToVsnK, InstructionsDK}]}.</pre> <ul> <li> <code class="code">Vsn</code>, a string, is the current version of the application, as defined in the <code class="code">.app</code> file.</li> <li>Each <code class="code">UpFromVsn</code> is a previous version of the application to upgrade from.</li> <li>Each <code class="code">DownToVsn</code> is a previous version of the application to downgrade to.</li> <li>Each <code class="code">Instructions</code> is a list of release handling instructions.</li> </ul> <p>For information about the syntax and contents of the <code class="code">.appup</code> file, see the <code class="code">appup(4)</code> manual page in SASL.</p> <p><code><a href="appup_cookbook">Appup Cookbook</a></code> includes examples of <code class="code">.appup</code> files for typical upgrade/downgrade cases.</p> <p><strong>Example:</strong> Consider the release <code class="code">ch_rel-1</code> from <code><a href="release_structure#ch_rel">Releases</a></code>. Assume you want to add a function <code class="code">available/0</code> to server <code class="code">ch3</code>, which returns the number of available channels (when trying out the example, change in a copy of the original directory, so that the first versions are still available):</p> <pre data-language="erlang">-module(ch3).
-behaviour(gen_server).

-export([start_link/0]).
-export([alloc/0, free/1]).
-export([available/0]).
-export([init/1, handle_call/3, handle_cast/2]).

start_link() -&gt;
    gen_server:start_link({local, ch3}, ch3, [], []).

alloc() -&gt;
    gen_server:call(ch3, alloc).

free(Ch) -&gt;
    gen_server:cast(ch3, {free, Ch}).

available() -&gt;
    gen_server:call(ch3, available).

init(_Args) -&gt;
    {ok, channels()}.

handle_call(alloc, _From, Chs) -&gt;
    {Ch, Chs2} = alloc(Chs),
    {reply, Ch, Chs2};
handle_call(available, _From, Chs) -&gt;
    N = available(Chs),
    {reply, N, Chs}.

handle_cast({free, Ch}, Chs) -&gt;
    Chs2 = free(Ch, Chs),
    {noreply, Chs2}.</pre> <p>A new version of the <code class="code">ch_app.app</code> file must now be created, where the version is updated:</p> <pre data-language="erlang">{application, ch_app,
 [{description, "Channel allocator"},
  {vsn, "2"},
  {modules, [ch_app, ch_sup, ch3]},
  {registered, [ch3]},
  {applications, [kernel, stdlib, sasl]},
  {mod, {ch_app,[]}}
 ]}.</pre> <p>To upgrade <code class="code">ch_app</code> from <code class="code">"1"</code> to <code class="code">"2"</code> (and to downgrade from <code class="code">"2"</code> to <code class="code">"1"</code>), you only need to load the new (old) version of the <code class="code">ch3</code> callback module. Create the application upgrade file <code class="code">ch_app.appup</code> in the <code class="code">ebin</code> directory:</p> <pre data-language="erlang">{"2",
 [{"1", [{load_module, ch3}]}],
 [{"1", [{load_module, ch3}]}]
}.</pre> <h2> <span onmouseover="document.getElementById('ghlink-release-upgrade-file-idm3206').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-release-upgrade-file-idm3206').style.visibility = 'hidden';" id="relup">11.6 Release Upgrade File</span> </h2> <p>To define how to upgrade/downgrade between the new version and previous versions of a release, a <strong>release upgrade file</strong>, or in short <code class="code">relup</code> file, is to be created.</p> <p>This file does not need to be created manually, it can be generated by <code class="code">systools:make_relup/3,4</code>. The relevant versions of the <code class="code">.rel</code> file, <code class="code">.app</code> files, and <code class="code">.appup</code> files are used as input. It is deduced which applications are to be added and deleted, and which applications that must be upgraded and/or downgraded. The instructions for this are fetched from the <code class="code">.appup</code> files and transformed into a single list of low-level instructions in the right order.</p> <p>If the <code class="code">relup</code> file is relatively simple, it can be created manually. It is only to contain low-level instructions.</p> <p>For details about the syntax and contents of the release upgrade file, see the <code class="code">relup(4)</code> manual page in SASL.</p> <p><strong>Example, continued from the previous section:</strong> You have a new version "2" of <code class="code">ch_app</code> and an <code class="code">.appup</code> file. A new version of the <code class="code">.rel</code> file is also needed. This time the file is called <code class="code">ch_rel-2.rel</code> and the release version string is changed from "A" to "B":</p> <pre data-language="erlang">{release,
 {"ch_rel", "B"},
 {erts, "5.3"},
 [{kernel, "2.9"},
  {stdlib, "1.12"},
  {sasl, "1.10"},
  {ch_app, "2"}]
}.</pre> <p>Now the <code class="code">relup</code> file can be generated:</p> <pre data-language="erlang">
1&gt; systools:make_relup("ch_rel-2", ["ch_rel-1"], ["ch_rel-1"]).
ok</pre> <p>This generates a <code class="code">relup</code> file with instructions for how to upgrade from version "A" ("ch_rel-1") to version "B" ("ch_rel-2") and how to downgrade from version "B" to version "A".</p> <p>Both the old and new versions of the <code class="code">.app</code> and <code class="code">.rel</code> files must be in the code path, as well as the <code class="code">.appup</code> and (new) <code class="code">.beam</code> files. The code path can be extended by using the option <code class="code">path</code>:</p> <pre data-language="erlang">
1&gt; systools:make_relup("ch_rel-2", ["ch_rel-1"], ["ch_rel-1"],
[{path,["../ch_rel-1",
"../ch_rel-1/lib/ch_app-1/ebin"]}]).
ok</pre> <h2> <span onmouseover="document.getElementById('ghlink-installing-a-release-idm3245').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-installing-a-release-idm3245').style.visibility = 'hidden';" id="rel_handler">11.7 Installing a Release</span> </h2> <p>When you have made a new version of a release, a release package can be created with this new version and transferred to the target environment.</p> <p>To install the new version of the release in runtime, the <strong>release handler</strong> is used. This is a process belonging to the SASL application, which handles unpacking, installation, and removal of release packages. It is communicated through the <code class="code">release_handler</code> module. For details, see the <code class="code">release_handler(3)</code> manual page in SASL.</p> <p>Assuming there is an operational target system with installation root directory <code class="code">$ROOT</code>, the release package with the new version of the release is to be copied to <code class="code">$ROOT/releases</code>.</p> <p>First, <strong>unpack</strong> the release package. The files are then extracted from the package:</p> <pre data-language="erlang">release_handler:unpack_release(ReleaseName) =&gt; {ok, Vsn}</pre> <ul> <li> <code class="code">ReleaseName</code> is the name of the release package except the <code class="code">.tar.gz</code> extension.</li> <li> <code class="code">Vsn</code> is the version of the unpacked release, as defined in its <code class="code">.rel</code> file.</li> </ul> <p>A directory <code class="code">$ROOT/lib/releases/Vsn</code> is created, where the <code class="code">.rel</code> file, the boot script <code class="code">start.boot</code>, the system configuration file <code class="code">sys.config</code>, and <code class="code">relup</code> are placed. For applications with new version numbers, the application directories are placed under <code class="code">$ROOT/lib</code>. Unchanged applications are not affected.</p> <p>An unpacked release can be <strong>installed</strong>. The release handler then evaluates the instructions in <code class="code">relup</code>, step by step:</p> <pre data-language="erlang">release_handler:install_release(Vsn) =&gt; {ok, FromVsn, []}</pre> <p>If an error occurs during the installation, the system is rebooted using the old version of the release. If installation succeeds, the system is afterwards using the new version of the release, but if anything happens and the system is rebooted, it starts using the previous version again.</p> <p>To be made the default version, the newly installed release must be made <strong>permanent</strong>, which means the previous version becomes <strong>old</strong>:</p> <pre data-language="erlang">release_handler:make_permanent(Vsn) =&gt; ok</pre> <p>The system keeps information about which versions are old and permanent in the files <code class="code">$ROOT/releases/RELEASES</code> and <code class="code">$ROOT/releases/start_erl.data</code>.</p> <p>To downgrade from <code class="code">Vsn</code> to <code class="code">FromVsn</code>, <code class="code">install_release</code> must be called again:</p> <pre data-language="erlang">release_handler:install_release(FromVsn) =&gt; {ok, Vsn, []}</pre> <p>An installed, but not permanent, release can be <strong>removed</strong>. Information about the release is then deleted from <code class="code">$ROOT/releases/RELEASES</code> and the release-specific code, that is, the new application directories and the <code class="code">$ROOT/releases/Vsn</code> directory, are removed.</p> <pre data-language="erlang">release_handler:remove_release(Vsn) =&gt; ok</pre> <h4><span onmouseover="document.getElementById('ghlink-example--continued-from-the-previous-sections--idm3295').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-example--continued-from-the-previous-sections--idm3295').style.visibility = 'hidden';">Example (continued from the previous sections)</span></h4> <p><strong>Step 1)</strong> Create a target system as described in System Principles of the first version <code class="code">"A"</code> of <code class="code">ch_rel</code> from <code><a href="release_structure#ch_rel">Releases</a></code>. This time <code class="code">sys.config</code> must be included in the release package. If no configuration is needed, the file is to contain the empty list:</p> <pre data-language="erlang">[].</pre> <p><strong>Step 2)</strong> Start the system as a simple target system. In reality, it is to be started as an embedded system. However, using <code class="code">erl</code> with the correct boot script and config file is enough for illustration purposes:</p> <pre data-language="erlang">
% cd $ROOT
% bin/erl -boot $ROOT/releases/A/start -config $ROOT/releases/A/sys
...</pre> <p><code class="code">$ROOT</code> is the installation directory of the target system.</p> <p><strong>Step 3)</strong> In another Erlang shell, generate start scripts and create a release package for the new version <code class="code">"B"</code>. Remember to include (a possible updated) <code class="code">sys.config</code> and the <code class="code">relup</code> file, see <code><a href="#relup">Release Upgrade File</a></code>.</p> <pre data-language="erlang">
1&gt; systools:make_script("ch_rel-2").
ok
2&gt; systools:make_tar("ch_rel-2").
ok</pre> <p>The new release package now also contains version "2" of <code class="code">ch_app</code> and the <code class="code">relup</code> file:</p> <pre data-language="erlang">% tar tf ch_rel-2.tar
lib/kernel-2.9/ebin/kernel.app
lib/kernel-2.9/ebin/application.beam
...
lib/stdlib-1.12/ebin/stdlib.app
lib/stdlib-1.12/ebin/beam_lib.beam
...
lib/sasl-1.10/ebin/sasl.app
lib/sasl-1.10/ebin/sasl.beam
...
lib/ch_app-2/ebin/ch_app.app
lib/ch_app-2/ebin/ch_app.beam
lib/ch_app-2/ebin/ch_sup.beam
lib/ch_app-2/ebin/ch3.beam
releases/B/start.boot
releases/B/relup
releases/B/sys.config
releases/B/ch_rel-2.rel
releases/ch_rel-2.rel</pre> <p><strong>Step 4)</strong> Copy the release package <code class="code">ch_rel-2.tar.gz</code> to the <code class="code">$ROOT/releases</code> directory.</p> <p><strong>Step 5)</strong> In the running target system, unpack the release package:</p> <pre data-language="erlang">
1&gt; release_handler:unpack_release("ch_rel-2").
{ok,"B"}</pre> <p>The new application version <code class="code">ch_app-2</code> is installed under <code class="code">$ROOT/lib</code> next to <code class="code">ch_app-1</code>. The <code class="code">kernel</code>, <code class="code">stdlib</code>, and <code class="code">sasl</code> directories are not affected, as they have not changed.</p> <p>Under <code class="code">$ROOT/releases</code>, a new directory <code class="code">B</code> is created, containing <code class="code">ch_rel-2.rel</code>, <code class="code">start.boot</code>, <code class="code">sys.config</code>, and <code class="code">relup</code>.</p> <p><strong>Step 6)</strong> Check if the function <code class="code">ch3:available/0</code> is available:</p> <pre data-language="erlang">
2&gt; ch3:available().
** exception error: undefined function ch3:available/0</pre> <p><strong>Step 7)</strong> Install the new release. The instructions in <code class="code">$ROOT/releases/B/relup</code> are executed one by one, resulting in the new version of <code class="code">ch3</code> being loaded. The function <code class="code">ch3:available/0</code> is now available:</p> <pre data-language="erlang">
3&gt; release_handler:install_release("B").
{ok,"A",[]}
4&gt; ch3:available().
3
5&gt; code:which(ch3).
".../lib/ch_app-2/ebin/ch3.beam"
6&gt; code:which(ch_sup).
".../lib/ch_app-1/ebin/ch_sup.beam"</pre> <p>Processes in <code class="code">ch_app</code> for which code have not been updated, for example, the supervisor, are still evaluating code from <code class="code">ch_app-1</code>.</p> <p><strong>Step 8)</strong> If the target system is now rebooted, it uses version "A" again. The "B" version must be made permanent, to be used when the system is rebooted.</p> <pre data-language="erlang">
7&gt; release_handler:make_permanent("B").
ok</pre> <h2> <span onmouseover="document.getElementById('ghlink-updating-application-specifications-idm3369').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-updating-application-specifications-idm3369').style.visibility = 'hidden';" id="sys">11.8 Updating Application Specifications</span> </h2> <p>When a new version of a release is installed, the application specifications are automatically updated for all loaded applications.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The information about the new application specifications is fetched from the boot script included in the release package. Thus, it is important that the boot script is generated from the same <code class="code">.rel</code> file as is used to build the release package itself.</p> </div> </div> <p>Specifically, the application configuration parameters are automatically updated according to (in increasing priority order):</p> <ul> <li>The data in the boot script, fetched from the new application resource file <code class="code">App.app</code> </li> <li>The new <code class="code">sys.config</code> </li> <li>Command-line arguments <code class="code">-App Par Val</code> </li> </ul> <p>This means that parameter values set in the other system configuration files and values set using <code class="code">application:set_env/3</code> are disregarded.</p> <p>When an installed release is made permanent, the system process <code class="code">init</code> is set to point out the new <code class="code">sys.config</code>.</p> <p>After the installation, the application controller compares the old and new configuration parameters for all running applications and call the callback function:</p> <pre data-language="erlang">Module:config_change(Changed, New, Removed)</pre> <ul> <li> <code class="code">Module</code> is the application callback module as defined by the <code class="code">mod</code> key in the <code class="code">.app</code> file.</li> <li> <code class="code">Changed</code> and <code class="code">New</code> are lists of <code class="code">{Par,Val}</code> for all changed and added configuration parameters, respectively.</li> <li> <code class="code">Removed</code> is a list of all parameters <code class="code">Par</code> that have been removed.</li> </ul> <p>The function is optional and can be omitted when implementing an application callback module.</p> </div> <div class="footer"> <hr> <p>Copyright © 1997-2021 Ericsson AB. All Rights Reserved.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2021 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
