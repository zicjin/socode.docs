<div class="innertube"> <h1>12 Retired Myths</h1> <p>We belive that the truth finally has caught with the following, retired myths.</p> <h2> <span onmouseover="document.getElementById('ghlink-myth--funs-are-slow-idm1402').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-myth--funs-are-slow-idm1402').style.visibility = 'hidden';" id="retired_myths">12.1 Myth: Funs are Slow</span> </h2> <p>Funs used to be very slow, slower than <code class="code">apply/3</code>. Originally, funs were implemented using nothing more than compiler trickery, ordinary tuples, <code class="code">apply/3</code>, and a great deal of ingenuity.</p> <p>But that is history. Funs was given its own data type in R6B and was further optimized in R7B. Now the cost for a fun call falls roughly between the cost for a call to a local function and <code class="code">apply/3</code>.</p> <h2><span onmouseover="document.getElementById('ghlink-myth--list-comprehensions-are-slow-idm1410').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-myth--list-comprehensions-are-slow-idm1410').style.visibility = 'hidden';">12.2 Myth: List Comprehensions are Slow</span></h2> <p>List comprehensions used to be implemented using funs, and in the old days funs were indeed slow.</p> <p>Nowadays, the compiler rewrites list comprehensions into an ordinary recursive function. Using a tail-recursive function with a reverse at the end would be still faster. Or would it? That leads us to the myth that tail-recursive functions are faster than body-recursive functions.</p> <h2><span onmouseover="document.getElementById('ghlink-myth--list-subtraction-------operator--is-slow-idm1414').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-myth--list-subtraction-------operator--is-slow-idm1414').style.visibility = 'hidden';">12.3 Myth: List subtraction ("--" operator) is slow</span></h2> <p>List subtraction used to have a run-time complexity proportional to the product of the length of its operands, so it was extremely slow when both lists were long.</p> <p>As of OTP 22 the run-time complexity is "n log n" and the operation will complete quickly even when both lists are very long. In fact, it is faster and uses less memory than the commonly used workaround to convert both lists to ordered sets before subtracting them with <code class="code">ordsets:subtract/2</code>.</p> </div> <div class="footer"> <hr> <p>Copyright Â© 2001-2021 Ericsson AB. All Rights Reserved.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2021 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
