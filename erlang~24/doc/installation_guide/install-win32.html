<div class="innertube"> <h1>4 How to Build Erlang/OTP on Windows</h1> <p><strong>Table of Contents</strong></p> <ol> <li> <code><a href="#Introduction">Introduction</a></code> </li> <li> <code><a href="#Short-Version">Short Version</a></code> </li> <li> <code><a href="#Tools-you-Need-and-Their-Environment">Tools you Need and Their Environment</a></code> </li> <li> <code><a href="#The-Shell-Environment">The Shell Environment</a></code> </li> <li> <code><a href="#Building-and-Installing">Building and Installing</a></code> </li> <li> <code><a href="#Development">Development</a></code> </li> <li> <code><a href="#Frequently-Asked-Questions">Frequently Asked Questions</a></code> </li> </ol> <h2> <span onmouseover="document.getElementById('ghlink-introduction-idm1428').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-introduction-idm1428').style.visibility = 'hidden';" id="Introduction">4.1 Introduction</span> </h2> <p> This section describes how to build the Erlang emulator and the OTP libraries on Windows. Note that the Windows binary releases are still a preferred alternative if one does not have Microsoft’s development tools and/or don’t want to install WSL. </p> <p> The instructions apply to Windows 10 (v.1809 and later) supporting the WSL.1 (Windows Subsystem for Linux v.1) and using Ubuntu 18.04 release. </p> <p> The procedure described uses WSL as a build environment. You run the bash shell in WSL and use the gnu make/configure/autoconf etc to do the build. The emulator C-source code is, however, mostly compiled with Microsoft Visual C++™, producing a native Windows binary. This is the same procedure as we use to build the pre-built binaries. Why we use VC++ and not gcc is explained further in the FAQ section. </p> <p> These instructions apply for both 32-bit and 64-bit Windows. Note that even if you build a 64-bit version of Erlang, most of the directories and files involved are still named win32. Some occurrences of the name win64 are however present. The installation file for a 64-bit Windows version of Erlang, for example, is <code class="code">otp_win64_24.exe</code>. </p> <p> If you feel comfortable with the environment and build system, and have all the necessary tools, you have a great opportunity to make the Erlang/OTP distribution for Windows better. Please submit any suggestions or patches to our <code><a href="https://github.com/erlang/otp">git project</a></code> to let them find their way into the next version of Erlang. If making changes to the build system (like makefiles etc) please bear in mind that the same makefiles are used on Unix/VxWorks, so that your changes don't break other platforms. That of course goes for C-code too; system specific code resides in the <code class="code">$ERL_TOP/erts/emulator/sys/win32</code> and <code class="code">$ERL_TOP/erts/etc/win32</code> directories mostly. The <code class="code">$ERL_TOP/erts/emulator/beam</code> directory is for common code. </p> <h2> <span onmouseover="document.getElementById('ghlink-short-version-idm1441').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-short-version-idm1441').style.visibility = 'hidden';" id="Short-Version">4.2 Short Version</span> </h2> <p> In the following sections, we've described as much as we could about the installation of the tools needed. Once the tools are installed, building is quite easy. We have also tried to make these instructions understandable for people with limited Unix experience. WSL is a whole new environment to some Windows users, why careful explanation of environment variables etc seemed to be in place. </p> <p> This is the short story though, for the experienced and impatient: </p> <ul><li> <p>Get and install complete WSL environment </p> <ul> <li> <p>Install Visual Studio 2019 </p> </li> <li> <p>Get and install windows JDK-8 </p> </li> <li> <p>Get and install windows NSIS 3.05 or later (3.05 tried and working) </p> </li> <li> <p>Get, build and install OpenSSL v1.1.1d or later (up to 1.1.1d tried &amp; working) with static libs. </p> </li> <li> <p>Get, build and install wxWidgets-3.1.3 or later (up to 3.1.3 tried &amp; working) with static libs. </p> </li> <li> <p>Get the Erlang source distribution (from <code><a href="http://www.erlang.org/download.html">http://www.erlang.org/download.html</a></code>) and unpack with <code class="code">tar</code> to the windows disk for example to: /mnt/c/src/ </p> </li> <li> <p>Install mingw-gcc, make and autoconf: <code class="code">sudo apt install g++-mingw-w64 gcc-mingw-w64 make autoconf</code> </p> </li> <li> <p><code class="code">$ cd UNPACK_DIR</code> </p> </li> <li> <p>Modify PATH and other environment variables so that all these tools are runnable from a bash shell. Still standing in <code class="code">$ERL_TOP</code>, issue the following commands (for 32-bit Windows, remove the x64 from the first row and change <code class="code">otp_win64_24</code> to <code class="code">otp_win32_24</code> on the last row): </p> <pre data-language="erlang">$ eval `./otp_build env_win32 x64`
$ ./otp_build autoconf
$ ./otp_build configure
$ ./otp_build boot -a
$ ./otp_build release -a
$ ./otp_build installer_win32
$ release/win32/otp_win64_24 /S</pre> </li> </ul> <p>Voila! <code class="code">Start-&gt;Programs-&gt;Erlang OTP 24-&gt;Erlang</code> starts the Erlang Windows shell. </p> </li></ul> <h2> <span onmouseover="document.getElementById('ghlink-tools-you-need-and-their-environment-idm1478').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-tools-you-need-and-their-environment-idm1478').style.visibility = 'hidden';" id="Tools-you-Need-and-Their-Environment">4.3 Tools you Need and Their Environment</span> </h2> <p> You need some tools to be able to build Erlang/OTP on Windows. Most notably you'll need WSL (with ubuntu), Visual Studio and Microsofts Windows SDK, but you might also want a Java compiler, the NSIS install system, OpenSSL and wxWidgets. Well, here's some information about the different tools: </p> <ul> <li> <p>WSL: Install WSL and Ubuntu in Windows 10 <code><a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">https://docs.microsoft.com/en-us/windows/wsl/install-win10</a></code> </p> <p>We have used and tested with WSL-1, WSL-2 was not available and may not be preferred when building Erlang/OTP since access to the windows disk is (currently) slower WSL-2. </p> </li> <li> <p>Visual Studio 2019 Download and run the installer from: <code><a href="http://visualstudio.microsoft.com/downloads">http://visualstudio.microsoft.com/downloads</a></code> Install C++ and SDK packages to the default installation directory. </p> </li> <li> <p>Java JDK 8 or later (optional) If you don't care about Java, you can skip this step. The result will be that jinterface is not built. </p> <p>Our Java code (jinterface, ic) is tested on windows with JDK 8. Get it for Windows and install it, the JRE is not enough. </p> <p>URL: <code><a href="http://www.oracle.com/java/technologies/javase-downloads.html">http://www.oracle.com/java/technologies/javase-downloads.html</a></code> </p> <p>Add javac to your path environment, in my case this means: </p> <pre data-language="erlang">`PATH="/mnt/c/Program\ Files/Java/jdk1.8.0_241/bin:$PATH`</pre> <p>No <code class="code">CLASSPATH</code> or anything is needed. Type <code class="code">javac.exe</code> in the bash prompt and you should get a list of available Java options. </p> </li> <li> <p>Nullsoft NSIS installer system (optional) You need this to build the self installing package. </p> <p>Download and run the installer from: URL: <code><a href="http://nsis.sourceforge.net/download">http://nsis.sourceforge.net/download</a></code> </p> <p>Add 'makensis.exe' to your path environment: </p> <pre data-language="erlang">`PATH="/mnt/c/Program\ Files/NSIS/Bin:$PATH`</pre> <p>Type <code class="code">which makensis.exe</code> in the bash prompt and you should get the path to the program. </p> </li> <li> <p>OpenSSL (optional) You need this to build crypto, ssh and ssl libs. </p> <p>We recommend v1.1.1d or later. There are prebuilt avaiable binaries, which you can just download and install, available here: URL: <code><a href="http://wiki.openssl.org/index.php/Binaries">http://wiki.openssl.org/index.php/Binaries</a></code> </p> <p>Install into <code class="code">C:/OpenSSL-Win64</code> (or <code class="code">C:/OpenSSL-Win32</code>) </p> </li> <li> <p>wxWidgets (optional) You need this to build wx and use gui's in debugger and observer. </p> <p>We recommend v3.1.4 or later. Unpack into <code class="code">c:/opt/local64/pgm/wxWidgets-3.1.4</code> </p> <p>If the <code class="code">wxUSE_POSTSCRIPT</code> isn't enabled in <code class="code">c:/opt/local64/pgm/wxWidgets-3.1.4/include/wx/msw/setup.h</code>, enable it. </p> <p>We recommend to enable for wxWebView wxUSE<strong>WEBVIEW</strong>EDGE. </p> <ul> <li> Download the nuget package 'Microsoft.Web.WebView2' (Version 0.9.488 or newer) </li> <li> Extract the package (it's a zip archive) to wxWidgets/3rdparty/webview2 (you should have 3rdparty/webview2/build/native/include/WebView2.h file after unpacking it) </li> <li> Enable wxUSE<strong>WEBVIEW</strong>EDGE in <code class="code">c:/opt/local64/pgm/wxWidgets-3.1.4/include/wx/msw/setup.h</code> </li> <li> After <code class="code">otp_build release -a</code> copy WebView2Loader.dll from the subdirectory corresponding to the architecture used (x86 or x64) of wxWidgets/3rdparty/webview2/build/ to your $ERL<strong>TOP/release/win32/erts-</strong>/bin/ directory <code class="code">cp /mnt/c/opt/local64/pgm/wxWidgets-3.1.4/3rdparty/webview2/runtimes/win-x64/native/WebView2Loader.dll $ERL_TOP/release/win32/erts-11.1.7/bin/</code> </li> </ul> <p>Build with: </p> <pre data-language="erlang">C:\...\&gt; cd c:\opt\local64\pgm\wxWidgets-3.1.4\build\msw
C:\...\&gt; nmake TARGET_CPU=amd64 BUILD=release SHARED=0 DIR_SUFFIX_CPU= -f makefile.vc</pre> <p>Remove the <code class="code">TARGET_CPU=amd64</code> for 32bit build. </p> </li> <li> <p>Get the Erlang source distribution (from <code><a href="http://www.erlang.org/download.html">http://www.erlang.org/download.html</a></code>). The same as for Unix platforms. Preferably use tar to unpack the source tar.gz (<code class="code">tar zxf otp_src_24.tar.gz</code>) to somewhere on the windows disk, <code class="code">/mnt/c/path/to/otp_src</code> </p> <p>NOTE: It is important that source on the windows disk. </p> <p>Set the environment <code class="code">ERL_TOP</code> to point to the root directory of the source distribution. Let's say I stood in <code class="code">/mnt/c/src</code> and unpacked <code class="code">otp_src_24.tar.gz</code>, I then add the following to <code class="code">.profile</code>: </p> <pre data-language="erlang">ERL_TOP=/mnt/c/src/otp_src_24
export ERL_TOP</pre> </li> </ul> <h2> <span onmouseover="document.getElementById('ghlink-the-shell-environment-idm1550').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-the-shell-environment-idm1550').style.visibility = 'hidden';" id="The-Shell-Environment">4.4 The Shell Environment</span> </h2> <p> The path variable should now contain the windows paths to javac.exe and makensis.exe. </p> <p> Setup the environment with: </p> <pre data-language="erlang">$ export PATH
$ cd /mnt/c/path/to/otp_src/
$ eval `./otp_build env_win32 x64`</pre> <p> This should setup the additional environment variables. </p> <p> This should do the final touch to the environment and building should be easy after this. You could run <code class="code">./otp_build env_win32</code> without <code class="code">eval</code> just to see what it does, and to see that the environment it sets seems OK. The path is cleaned of spaces if possible (using DOS style short names instead), the variables <code class="code">OVERRIDE_TARGET</code>, <code class="code">CC</code>, <code class="code">CXX</code>, <code class="code">AR</code> and <code class="code">RANLIB</code> are set to their respective wrappers and the directories <code class="code">$ERL_TOP/erts/etc/win32/wsl_tools/vc</code> and <code class="code">$ERL_TOP/erts/etc/win32/wsl_tools</code> are added first in the PATH. </p> <p> Now you can check which erlc you have by writing <code class="code">type erlc</code> in your shell. It should reside in <code class="code">$ERL_TOP/erts/etc/win32/wsl_tools</code>. </p> <p> And running <code class="code">cl.exe</code> should print the Microsoft compiler usage message. </p> <p> The needed compiler environment variables are setup inside <code class="code">otp_build</code> via <code class="code">erts/etc/win32/wsl_tools/SetupWSLcross.bat</code>. It contains some hardcoded paths, if your installation path is different it can be added to that file. </p> <h2> <span onmouseover="document.getElementById('ghlink-building-and-installing-idm1575').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-building-and-installing-idm1575').style.visibility = 'hidden';" id="Building-and-Installing">4.5 Building and Installing</span> </h2> <p> Building is easiest using the <code class="code">otp_build</code> script: </p> <pre data-language="erlang">$ ./otp_build autoconf # Ignore the warning blob about versions of autoconf
$ ./otp_build configure &lt;optional configure options&gt;
$ ./otp_build boot -a
$ ./otp_build release -a &lt;installation directory&gt;
$ ./otp_build installer_win32 &lt;installation directory&gt; # optional</pre> <p> Now you will have a file called <code class="code">otp_win32_24.exe</code> or <code class="code">otp_win64_24.exe</code> in the <code class="code">&lt;installation directory&gt;</code>, i.e. <code class="code">$ERL_TOP/release/win32</code>. </p> <p> Lets get into more detail: </p> <ol> <li> <p><code class="code">$ ./otp_build autoconf</code> - This step rebuilds the configure scripts to work correctly in your environment. In an ideal world, this would not be needed, but alas, we have encountered several incompatibilities between our distributed configure scripts (generated on a Linux platform) and the Cygwin/MSYS/MSYS2/WSL environment over the years. Running autoconf in WSL ensures that the configure scripts are generated in a compatible way and that they will work well in the next step. </p> </li> <li> <p><code class="code">$ ./otp_build configure</code> - This runs the newly generated configure scripts with options making configure behave nicely. The target machine type is plainly <code class="code">win32</code>, so a lot of the configure-scripts recognize this awkward target name and behave accordingly. The CC variable also makes the compiler be <code class="code">cc.sh</code>, which wraps MSVC++, so all configure tests regarding the C compiler gets to run the right compiler. A lot of the tests are not needed on Windows, but we thought it best to run the whole configure anyway. </p> </li> <li> <p><code class="code">$ ./otp_build boot -a</code> - This uses the bootstrap directory (shipped with the source, <code class="code">$ERL_TOP/bootstrap</code>) to build a complete OTP system. When this is done you can run erl from within the source tree; just type <code class="code">$ERL_TOP/bin/erl</code> and you should have the prompt. </p> </li> <li> <p><code class="code">$ ./otp_build release -a</code> - Builds a commercial release tree from the source tree. The default is to put it in <code class="code">$ERL_TOP/release/win32</code>. You can give any directory as parameter, but it doesn't really matter if you're going to build a self extracting installer too. </p> </li> <li> <p><code class="code">$ ./otp_build installer_win32</code> - Creates the self extracting installer executable. The executable <code class="code">otp_win32_24.exe</code> or <code class="code">otp_win64_24.exe</code> will be placed in the top directory of the release created in the previous step. If no release directory is specified, the release is expected to have been built to <code class="code">$ERL_TOP/release/win32</code>, which also will be the place where the installer executable will be placed. If you specified some other directory for the release (i.e. <code class="code">./otp_build release -a /tmp/erl_release</code>), you're expected to give the same parameter here, (i.e. <code class="code">./otp_build installer_win32 /tmp/erl_release</code>). You need to have a full NSIS installation and <code class="code">makensis.exe</code> in your path for this to work. Once you have created the installer, you can run it to install Erlang/OTP in the regular way, just run the executable and follow the steps in the installation wizard. To get all default settings in the installation without any questions asked, you run the executable with the parameter <code class="code">/S</code> (capital S) like in: </p> <pre data-language="erlang">$ cd $ERL_TOP
$ release/win32/otp_win32_24 /S
...</pre> <p>or </p> <pre data-language="erlang">$ cd $ERL_TOP
$ release/win32/otp_win64_24 /S
...</pre> <p>and after a while Erlang/OTP-24 will have been installed in <code class="code">C:\Program Files\erl12.0\</code>, with shortcuts in the menu etc. </p> </li> </ol> <h2> <span onmouseover="document.getElementById('ghlink-development-idm1620').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-development-idm1620').style.visibility = 'hidden';" id="Development">4.6 Development</span> </h2> <p> Once the system is built, you might want to change it. Having a test release in some nice directory might be useful, but you can also run Erlang from within the source tree. The target <code class="code">local_setup</code>, makes the program <code class="code">$ERL_TOP/bin/erl.exe</code> usable and it also uses all the OTP libraries in the source tree. </p> <p> If you hack the emulator, you can build the emulator executable by standing in <code class="code">$ERL_TOP/erts/emulator</code> and do a simple </p> <pre data-language="erlang">$ make opt</pre> <p> Note that you need to have run <code class="code">(cd $ERL_TOP &amp;&amp; eval `./otp_build env_win32`)</code> in the particular shell before building anything on Windows. After doing a make opt you can test your result by running <code class="code">$ERL_TOP/bin/erl</code>. If you want to copy the result to a release directory (say <code class="code">/tmp/erl_release</code>), you do this (still in <code class="code">$ERL_TOP/erts/emulator</code>) </p> <pre data-language="erlang">$ make TESTROOT=/tmp/erl_release release</pre> <p> That will copy the emulator executables. </p> <p> To make a debug build of the emulator, you need to recompile both <code class="code">beam.dll</code> (the actual runtime system) and <code class="code">erlexec.dll</code>. Do like this </p> <pre data-language="erlang">$ cd $ERL_TOP
$ rm bin/win32/erlexec.dll
$ cd erts/emulator
$ make debug
$ cd ../etc
$ make debug</pre> <p> and sometimes </p> <pre data-language="erlang">$ cd $ERL_TOP
$ make local_setup</pre> <p> So now when you run <code class="code">$ERL_TOP/erl.exe</code>, you should have a debug compiled emulator, which you will see if you do a: </p> <pre data-language="erlang">1&gt; erlang:system_info(system_version).</pre> <p> in the erlang shell. If the returned string contains <code class="code">[debug]</code>, you got a debug compiled emulator. </p> <p> To hack the erlang libraries, you simply do a <code class="code">make opt</code> in the specific "applications" directory, like: </p> <pre data-language="erlang">$ cd $ERL_TOP/lib/stdlib
$ make opt</pre> <p> or even in the source directory... </p> <pre data-language="erlang">$ cd $ERL_TOP/lib/stdlib/src
$ make opt</pre> <p> Note that you're expected to have a fresh Erlang in your path when doing this, preferably the plain 24 you have built in the previous steps. You could also add <code class="code">$ERL_TOP/bootstrap/bin</code> to your <code class="code">PATH</code> before rebuilding specific libraries. That would give you a good enough Erlang system to compile any OTP erlang code. Setting up the path correctly is a little bit tricky. You still need to have <code class="code">$ERL_TOP/erts/etc/win32/wsl_tools/vc</code> and <code class="code">$ERL_TOP/erts/etc/win32/wsl_tools</code> <strong>before</strong> the actual emulator in the path. A typical setting of the path for using the bootstrap compiler would be: </p> <pre data-language="erlang">$ export PATH=$ERL_TOP/erts/etc/win32/wsl_tools/vc\
:$ERL_TOP/erts/etc/win32/wsl_tools:$ERL_TOP/bootstrap/bin:$PATH</pre> <p> That should make it possible to rebuild any library without hassle... </p> <p> If you want to copy a library (an application) newly built, to a release area, you do like with the emulator: </p> <pre data-language="erlang">$ cd $ERL_TOP/lib/stdlib
$ make TESTROOT=/tmp/erlang_release release</pre> <p> Remember that: </p> <ul> <li> <p>Windows specific C-code goes in the <code class="code">$ERL_TOP/erts/emulator/sys/win32</code>, <code class="code">$ERL_TOP/erts/emulator/drivers/win32</code> or <code class="code">$ERL_TOP/erts/etc/win32</code>. </p> </li> <li> <p>Windows specific erlang code should be used conditionally and the host OS tested in <strong>runtime</strong>, the exactly same beam files should be distributed for every platform! So write code like: </p> <pre data-language="erlang">case os:type() of
    {win32,_} -&gt;
        do_windows_specific();
    Other -&gt;
        do_fallback_or_exit()
end,</pre> </li> </ul> <p> That's basically all you need to get going. </p> <h2> <span onmouseover="document.getElementById('ghlink-frequently-asked-questions-idm1674').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-frequently-asked-questions-idm1674').style.visibility = 'hidden';" id="Frequently-Asked-Questions">4.7 Frequently Asked Questions</span> </h2> <ul> <li> <p>Q: So, now I can build Erlang using GCC on Windows? </p> <p>A: No, unfortunately not. You'll need Microsoft's Visual C++ still. A Bourne-shell script (cc.sh) wraps the Visual C++ compiler and runs it from within the WSL environment. All other tools needed to build Erlang are free-ware/open source, but not the C compiler. </p> </li> <li> <p>Q: Why haven't you got rid of VC++ then, you ******? </p> <p>A: Well, partly because it's a good compiler - really! Actually it's been possible in late R11-releases to build using mingw instead of visual C++ (you might see the remnants of that in some scripts and directories). Unfortunately the development of the SMP version for Windows broke the mingw build and we chose to focus on the VC++ build as the performance has been much better in the VC++ versions. The mingw build will possibly be back, but as long as VC++ gives better performance, the commercial build will be a VC++ one. </p> </li> <li> <p>Q: Hah, I saw you, you used GCC even though you said you didn't! </p> <p>A: OK, I admit, one of the files is compiled using MinGW's GCC and the resulting object code is then converted to MS VC++ compatible coff using a small C hack. It's because that particular file, <code class="code">beam_emu.c</code> benefits immensely from being able to use the GCC labels-as-values extension, which boosts emulator performance by up to 50%. That does unfortunately not (yet) mean that all of OTP could be compiled using GCC. That particular source code does not do anything system specific and actually is adopted to the fact that GCC is used to compile it on Windows. </p> </li> <li> <p>Q: So now there's a MS VC++ project file somewhere and I can build OTP using the nifty VC++ GUI? </p> <p>A: No, never. The hassle of keeping the project files up to date and do all the steps that constitute an OTP build from within the VC++ GUI is simply not worth it, maybe even impossible. A VC++ project file for Erlang/OTP will never happen. </p> </li> <li> <p>Q: So how does it all work then? </p> <p>A: WSL/Ubuntu is the environment, it's almost like you had a virtual Unix machine inside Windows. Configure, given certain parameters, then creates makefiles that are used by the environment's gnu-make to built the system. Most of the actual compilers etc are not, however, WSL tools, so we've written a couple of wrappers (Bourne-shell scripts), which reside in <code class="code">$ERL_TOP/etc/win32/wsl_tools</code>. They all do conversion of parameters and switches common in the Unix environment to fit the native Windows tools. Most notable is of course the paths, which in WSL are Unix-like paths with "forward slashes" (/) and no drive letters. The WSL specific command <code class="code">wslpath</code> is used for most of the path conversions in a WSL environment. Luckily most compilers accept forward slashes instead of backslashes as path separators, but one still have to get the drive letters etc right, though. The wrapper scripts are not general in the sense that, for example, cc.sh would understand and translate every possible gcc option and pass correct options to cl.exe. The principle is that the scripts are powerful enough to allow building of Erlang/OTP, no more, no less. They might need extensions to cope with changes during the development of Erlang, and that's one of the reasons we made them into shell-scripts and not Perl-scripts. We believe they are easier to understand and change that way. </p> <p>In <code class="code">$ERL_TOP</code>, there is a script called <code class="code">otp_build</code>. That script handles the hassle of giving all the right parameters to <code class="code">configure</code>/<code class="code">make</code> and also helps you set up the correct environment variables to work with the Erlang source under WSL. </p> </li> <li> <p>Q: Can I build something that looks exactly as the commercial release? </p> <p>A: Yes, we use the exact same build procedure. </p> </li> <li> <p>Q: Which version of WSL and other tools do you use then? </p> <p>A: We use WSL 1 with Ubuntu 18.04. The GCC we used for 24 was version 7.3-win32. We used Visual studio 2019, Sun's JDK 1.8.0_241, NSIS 3.05, Win32 OpenSSL 1.1.1d and wxWidgets-3.1.3. </p> </li> </ul> </div> <div class="footer"> <hr> <p>Copyright © 1997-2021 Ericsson AB. All Rights Reserved.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2021 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
