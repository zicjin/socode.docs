<h1>Migrating to Mongoose 6</h1>
<a class="edit-docs-link" href="https://github.com/Automattic/mongoose/blob/master/docs/migrating_to_6.md" target="_blank"> <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHZpZXdCb3g9IjAgMCAxMDAwIDEwMDAiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDEwMDAgMTAwMCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8Zz48ZyB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAtMSAwIDQ4MCkiPjxwYXRoIHN0cm9rZT0iIzA5NzFCMiIgZmlsbD0iIzA5NzFCMiIgZD0iTTkzMC45LDQyMC41Yy0zMy4xLDMxLjgtNjkuMyw0Ny43LTEwOC43LDQ3LjdjLTQ0LjUsMC04My45LTE3LjItMTE4LjItNTEuNUw5OS40LTE4NS45Yy0zLjgtMy44LTYuNC04LjktNy42LTE1LjNjLTIuNS04LjktMjkuMi05Ny45LTgwLjEtMjY3Yy0zLjgtMTIuNy0xLjMtMjMuNSw3LjYtMzIuNGM2LjQtNS4xLDE0LTcuNiwyMi45LTcuNmg5LjVjMTMyLjIsNDQuNSwyMTkuOSw3My4xLDI2My4yLDg1LjhjMy44LDEuMyw3LjYsMy44LDExLjQsNy42YzM3NSwzNzAsNTc3LjIsNTcwLjIsNjA2LjQsNjAwLjdjMzguMSwzOS40LDU3LjIsNzkuNSw1Ny4yLDEyMC4xQzk4OC43LDM0Ni44LDk2OSwzODQuOSw5MzAuOSw0MjAuNXogTTY5NC40LDMxOS40YzMxLjgtNy42LDYxLjctMjUuNCw4OS42LTUzLjRjMjYuNy0yNi43LDQzLjItNTcuMiw0OS42LTkxLjVDNzQ3LjIsODguMSw1NzguNy03OS4xLDMyOC4zLTMyN2MtMTIuNywzMC41LTI5LjksNTYuNi01MS41LDc4LjJjLTI2LjcsMjYuNy01Ni42LDQ3LTg5LjYsNjFMMzMyLjEtNDIuOWwyMTAuNywyMTAuN0w2OTQuNCwzMTkuNHogTTE0NS4yLTIzOS4zYzMxLjgtNy42LDYxLTI1LjQsODcuNy01My40YzIxLjYtMjEuNiwzNi45LTQ3LDQ1LjgtNzYuM2MtMTIuNy0zLjgtNDIuOS0xNC05MC42LTMwLjVjLTQ3LjctMTYuNS04Mi4zLTI4LTEwMy45LTM0LjNjNi40LDE5LjEsMTYuOCw1Mi4xLDMxLjUsOTkuMkMxMzAuMy0yODcuNiwxNDAuMS0yNTUuOCwxNDUuMi0yMzkuM3ogTTg4OC45LDIyOS44bC01LjctNS43Yy0xMi43LDMzLjEtMzEuMSw2MS43LTU1LjMsODUuOEM4MDIuNSwzMzUuMyw3NzQuNSwzNTUsNzQ0LDM2OWwxLjksMS45bDEuOSwxLjljMjIuOSwyMi45LDQ3LjcsMzQuMyw3NC40LDM0LjNjMjIuOSwwLDQ1LjEtMTAuOCw2Ni43LTMyLjRjMjUuNC0yNC4yLDM4LjEtNDcuNywzOC4xLTcwLjZTOTE0LjQsMjU2LjUsODg4LjksMjI5Ljh6Ii8+PC9nPjwvZz4NCjwvc3ZnPg=="> </a><h2 id="migrating-from-5x-to-6x">  Migrating from 5.x to 6.x  </h2>   <p>There are several <a href="https://github.com/Automattic/mongoose/blob/master/CHANGELOG.md">backwards-breaking changes</a> you should be aware of when migrating from Mongoose 5.x to Mongoose 6.x.</p> <p>If you're still on Mongoose 4.x, please read the <a href="migrating_to_5">Mongoose 4.x to 5.x migration guide</a> and upgrade to Mongoose 5.x first.</p> <ul> <li><a href="#version-requirements">Version Requirements</a></li> <li><a href="#mongodb-driver-40">MongoDB Driver 4.0</a></li> <li><a href="#no-more-deprecation-warning-options">No More Deprecation Warning Options</a></li> <li><a href="#the-aspromise-method-for-connections">The <code>asPromise()</code> Method for Connections</a></li> <li><a href="#mongoose-connect-returns-a-promise"><code>mongoose.connect()</code> Returns a Promise</a></li> <li><a href="#duplicate-query-execution">Duplicate Query Execution</a></li> <li><a href="#strictquery-is-removed-and-replaced-by-strict"><code>strictQuery</code> is now equal to <code>strict</code> by default</a></li> <li><a href="#mongoerror-is-now-mongoservererror">MongoError is now MongoServerError</a></li> <li><a href="#clone-discriminator-schemas-by-default">Clone Discriminator Schemas By Default</a></li> <li><a href="#schema-defined-document-key-order">Schema Defined Document Key Order</a></li> <li><a href="#sanitizefilter-and-trusted"><code>sanitizeFilter</code> and <code>trusted()</code></a></li> <li><a href="#removed-omitundefined">Removed <code>omitUndefined</code></a></li> <li><a href="#document-parameter-to-default-functions">Document Parameter to Default Functions</a></li> <li><a href="#arrays-are-proxies">Arrays are Proxies</a></li> <li><a href="#typepojotomixed"><code>typePojoToMixed</code></a></li> <li><a href="#strictpopulate"><code>strictPopulate()</code></a></li> <li><a href="#subdocument-ref-function-context">Subdocument <code>ref</code> Function Context</a></li> <li><a href="#schema-reserved-names-warning">Schema Reserved Names Warning</a></li> <li><a href="#subdocument-paths">Subdocument Paths</a></li> <li><a href="#creating-aggregation-cursors">Creating Aggregation Cursors</a></li> <li><a href="#autocreate-defaults-to-true"><code>autoCreate</code> Defaults to <code>true</code></a></li> <li><a href="#no-more-context-query">No More <code>context: 'query'</code></a></li> <li><a href="#custom-validators-with-populated-paths">Custom Validators with Populated Paths</a></li> <li><a href="#disconnected-event-with-replica-sets">Disconnected Event with Replica Sets</a></li> <li><a href="#removed-execpopulate">Removed <code>execPopulate()</code></a></li> <li><a href="#create-with-empty-array"><code>create()</code> with Empty Array</a></li> <li><a href="#removed-nested-path-merging">Removed Nested Path Merging</a></li> <li><a href="#objectid-valueof">ObjectId <code>valueOf()</code></a></li> <li><a href="#immutable-createdat">Immutable <code>createdAt</code></a></li> <li><a href="#removed-validator-isasync">Removed Validator <code>isAsync</code></a></li> <li><a href="#removed-safe">Removed <code>safe</code></a></li> <li><a href="#schematype-set-parameters">SchemaType <code>set</code> parameters now use <code>priorValue</code> as the second parameter instead of <code>self</code></a></li> <li><a href="#toobject-and-tojson-use-nested-schema-minimize"><code>toObject()</code> and <code>toJSON()</code> Use Nested Schema <code>minimize</code></a></li> <li><a href="#typescript-changes">TypeScript changes</a></li> </ul> <h3 id="version-requirements">Version Requirements</h3> <p>Mongoose now requires Node.js &gt;= 12.0.0. Mongoose still supports MongoDB server versions back to 3.0.0.</p> <h3 id="mongodb-driver-40">MongoDB Driver 4.0</h3> <p>Mongoose now uses v4.x of the <a href="https://www.npmjs.com/package/mongodb">MongoDB Node driver</a>. See <a href="https://github.com/mongodb/node-mongodb-native/blob/4.0/docs/CHANGES_4.0.0.md">the MongoDB Node drivers' migration guide</a> for detailed info. Below are some of the most noteworthy changes:</p> <ul> <li>MongoDB Driver 4.x is written in TypeScript and has its own TypeScript type definitions. These may conflict with <code>@types/mongodb</code>, so if you have TypeScript compiler errors please make sure you upgrade to the <a href="https://www.npmjs.com/package/@types/mongodb">latest version of <code>@types/mongodb</code></a>, which is an empty stub.</li> <li>The <code>poolSize</code> option for connections has been <a href="https://github.com/mongodb/node-mongodb-native/blob/4.1/docs/CHANGES_4.0.0.md#connection-pool-options">replaced with <code>minPoolSize</code> and <code>maxPoolSize</code></a>. The Mongoose 5.x <code>poolSize</code> option is equivalent to the Mongoose 6 <code>maxPoolSize</code> option. The default value of <code>maxPoolSize</code> has been increased to 100.</li> <li>The result of <code>updateOne()</code> and <code>updateMany()</code> is now different.</li> <li>The result of <code>deleteOne()</code> and <code>deleteMany()</code> no longer has an <code>n</code> property.</li> </ul> <pre data-language="javascript"><span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> TestModel.updateMany({}, { <span class="hljs-attr">someProperty</span>: <span class="hljs-string">'someValue'</span> });

res.matchedCount; <span class="hljs-comment">// Number of documents that were found that match the filter. Replaces `res.n`</span>
res.modifiedCount; <span class="hljs-comment">// Number of documents modified. Replaces `res.nModified`</span>
res.upsertedCount; <span class="hljs-comment">// Number of documents upserted. Replaces `res.upserted`</span>
</pre> <pre data-language="javascript"><span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> TestModel.deleteMany({});

<span class="hljs-comment">// In Mongoose 6: `{ acknowledged: true, deletedCount: 2 }`</span>
<span class="hljs-comment">// In Mongoose 5: `{ n: 2, ok: 1, deletedCount: 2 }`</span>
res;

res.deletedCount; <span class="hljs-comment">// Number of documents that were deleted. Replaces `res.n`</span>
</pre> <h3 id="no-more-deprecation-warning-options">No More Deprecation Warning Options</h3> <p><code>useNewUrlParser</code>, <code>useUnifiedTopology</code>, <code>useFindAndModify</code>, and <code>useCreateIndex</code> are no longer supported options. Mongoose 6 always behaves as if <code>useNewUrlParser</code>, <code>useUnifiedTopology</code>, and <code>useCreateIndex</code> are <code>true</code>, and <code>useFindAndModify</code> is <code>false</code>. Please remove these options from your code.</p> <pre data-language="javascript"><span class="hljs-comment">// No longer necessary:</span>
mongoose.set(<span class="hljs-string">'useFindAndModify'</span>, <span class="hljs-literal">false</span>);

<span class="hljs-keyword">await</span> mongoose.connect(<span class="hljs-string">'mongodb://localhost:27017/test'</span>, {
  <span class="hljs-attr">useNewUrlParser</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// &lt;-- no longer necessary</span>
  <span class="hljs-attr">useUnifiedTopology</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// &lt;-- no longer necessary</span>
});
</pre> <h3 id="the-aspromise-method-for-connections">The `asPromise()` Method for Connections</h3> <p>Mongoose connections are no longer <a href="https://masteringjs.io/tutorials/fundamentals/thenable">thenable</a>. This means that <code>await mongoose.createConnection(uri)</code> <strong>no longer waits for Mongoose to connect</strong>. Use <code>mongoose.createConnection(uri).asPromise()</code> instead. See <a href="https://github.com/Automattic/mongoose/issues/8810">#8810</a>.</p> <pre data-language="javascript"><span class="hljs-comment">// The below no longer works in Mongoose 6</span>
<span class="hljs-keyword">await</span> mongoose.createConnection(uri);

<span class="hljs-comment">// Do this instead</span>
<span class="hljs-keyword">await</span> mongoose.createConnection(uri).asPromise();
</pre> <h3 id="mongoose-connect-returns-a-promise">`mongoose.connect()` Returns a Promise</h3> <p>The <code>mongoose.connect()</code> function now always returns a promise, <strong>not</strong> a Mongoose instance.</p> <h3 id="duplicate-query-execution">Duplicate Query Execution</h3> <p>Mongoose no longer allows executing the same query object twice. If you do, you'll get a <code>Query was already executed</code> error. Executing the same query instance twice is typically indicative of mixing callbacks and promises, but if you need to execute the same query twice, you can call <code>Query#clone()</code> to clone the query and re-execute it. See <a href="https://github.com/Automattic/mongoose/issues/7398">gh-7398</a></p> <pre data-language="javascript"><span class="hljs-comment">// Results in 'Query was already executed' error, because technically this `find()` query executes twice.</span>
<span class="hljs-keyword">await</span> Model.find({}, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>) </span>{});

<span class="hljs-keyword">const</span> q = Model.find();
<span class="hljs-keyword">await</span> q;
<span class="hljs-keyword">await</span> q.clone(); <span class="hljs-comment">// Can `clone()` the query to allow executing the query again</span>
</pre> <h3 id="strictquery-is-removed-and-replaced-by-strict">`strictQuery` is now equal to `strict` by default</h3> <p><del>Mongoose no longer supports a <code>strictQuery</code> option. You must now use <code>strict</code>.</del> As of Mongoose 6.0.10, we brought back the <code>strictQuery</code> option. However, <code>strictQuery</code> is tied to <code>strict</code> by default. This means that, by default, Mongoose will filter out query filter properties that are not in the schema.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: <span class="hljs-built_in">String</span> });
<span class="hljs-keyword">const</span> User = mongoose.model(<span class="hljs-string">'User'</span>, userSchema);

<span class="hljs-comment">// By default, this is equivalent to `User.find()` because Mongoose filters out `notInSchema`</span>
<span class="hljs-keyword">await</span> User.find({ <span class="hljs-attr">notInSchema</span>: <span class="hljs-number">1</span> });

<span class="hljs-comment">// Set `strictQuery: false` to opt in to filtering by properties that aren't in the schema</span>
<span class="hljs-keyword">await</span> User.find({ <span class="hljs-attr">notInSchema</span>: <span class="hljs-number">1</span> }, <span class="hljs-literal">null</span>, { <span class="hljs-attr">strictQuery</span>: <span class="hljs-literal">false</span> });
<span class="hljs-comment">// equivalent:</span>
<span class="hljs-keyword">await</span> User.find({ <span class="hljs-attr">notInSchema</span>: <span class="hljs-number">1</span> }).setOptions({ <span class="hljs-attr">strictQuery</span>: <span class="hljs-literal">false</span> });
</pre> <p>You can also disable <code>strictQuery</code> globally to override:</p> <pre data-language="javascript">mongoose.set(<span class="hljs-string">'strictQuery'</span>, <span class="hljs-literal">false</span>);
</pre> <h3 id="mongoerror-is-now-mongoservererror">MongoError is now MongoServerError</h3> <p>In MongoDB Node.js Driver v4.x, 'MongoError' is now 'MongoServerError'. Please change any code that depends on the hardcoded string 'MongoError'.</p> <h3 id="clone-discriminator-schemas-by-default">Clone Discriminator Schemas By Default</h3> <p>Mongoose now clones discriminator schemas by default. This means you need to pass <code>{ clone: false }</code> to <code>discriminator()</code> if you're using recursive embedded discriminators.</p> <pre data-language="javascript"><span class="hljs-comment">// In Mongoose 6, these two are equivalent:</span>
User.discriminator(<span class="hljs-string">'author'</span>, authorSchema);
User.discriminator(<span class="hljs-string">'author'</span>, authorSchema.clone());

<span class="hljs-comment">// To opt out if `clone()` is causing issues, pass `clone: false`</span>
User.discriminator(<span class="hljs-string">'author'</span>, authorSchema, { <span class="hljs-attr">clone</span>: <span class="hljs-literal">false</span> });
</pre> <h3 id="schema-defined-document-key-order">Schema Defined Document Key Order</h3> <p>Mongoose now saves objects with keys in the order the keys are specified in the schema, not in the user-defined object. So whether <code>Object.keys(new User({ name: String, email: String }).toObject()</code> is <code>['name', 'email']</code> or <code>['email', 'name']</code> depends on the order <code>name</code> and <code>email</code> are defined in your schema.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({
  <span class="hljs-attr">profile</span>: {
    <span class="hljs-attr">name</span>: {
      <span class="hljs-attr">first</span>: <span class="hljs-built_in">String</span>,
      <span class="hljs-attr">last</span>: <span class="hljs-built_in">String</span>
    }
  }
});
<span class="hljs-keyword">const</span> Test = db.model(<span class="hljs-string">'Test'</span>, schema);

<span class="hljs-keyword">const</span> doc = <span class="hljs-keyword">new</span> Test({
  <span class="hljs-attr">profile</span>: { <span class="hljs-attr">name</span>: { <span class="hljs-attr">last</span>: <span class="hljs-string">'Musashi'</span>, <span class="hljs-attr">first</span>: <span class="hljs-string">'Miyamoto'</span> } }
});

<span class="hljs-comment">// Note that 'first' comes before 'last', even though the argument to `new Test()` flips the key order.</span>
<span class="hljs-comment">// Mongoose uses the schema's key order, not the provided objects' key order.</span>
assert.deepEqual(<span class="hljs-built_in">Object</span>.keys(doc.toObject().profile.name), [<span class="hljs-string">'first'</span>, <span class="hljs-string">'last'</span>]);
</pre> <h3 id="sanitizefilter-and-trusted">`sanitizeFilter` and `trusted()`</h3> <p>Mongoose 6 introduces a new <code>sanitizeFilter</code> option to globals and queries that defends against <a href="https://thecodebarbarian.com/2014/09/04/defending-against-query-selector-injection-attacks.html">query selector injection attacks</a>. If you enable <code>sanitizeFilter</code>, Mongoose will wrap any object in the query filter in a <code>$eq</code>:</p> <pre data-language="javascript"><span class="hljs-comment">// Mongoose will convert this filter into `{ username: 'val', pwd: { $eq: { $ne: null } } }`, preventing</span>
<span class="hljs-comment">// a query selector injection.</span>
<span class="hljs-keyword">await</span> Test.find({ <span class="hljs-attr">username</span>: <span class="hljs-string">'val'</span>, <span class="hljs-attr">pwd</span>: { <span class="hljs-attr">$ne</span>: <span class="hljs-literal">null</span> } }).setOptions({ <span class="hljs-attr">sanitizeFilter</span>: <span class="hljs-literal">true</span> });
</pre> <p>To explicitly allow a query selector, use <code>mongoose.trusted()</code>:</p> <pre data-language="javascript"><span class="hljs-comment">// `mongoose.trusted()` allows query selectors through</span>
<span class="hljs-keyword">await</span> Test.find({ <span class="hljs-attr">username</span>: <span class="hljs-string">'val'</span>, <span class="hljs-attr">pwd</span>: mongoose.trusted({ <span class="hljs-attr">$ne</span>: <span class="hljs-literal">null</span> }) }).setOptions({ <span class="hljs-attr">sanitizeFilter</span>: <span class="hljs-literal">true</span> });
</pre> <h3 id="removed-omitundefined">Removed `omitUndefined`</h3> <p>In Mongoose 5.x, setting a key to <code>undefined</code> in an update operation was equivalent to setting it to <code>null</code>.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> Test.findOneAndUpdate({}, { <span class="hljs-attr">$set</span>: { <span class="hljs-attr">name</span>: <span class="hljs-literal">undefined</span> } }, { <span class="hljs-attr">new</span>: <span class="hljs-literal">true</span> });

res.name; <span class="hljs-comment">// null</span>
</pre> <p>Mongoose 5.x supported an <code>omitUndefined</code> option to strip out <code>undefined</code> keys. In Mongoose 6.x, the <code>omitUndefined</code> option has been removed, and Mongoose will always strip out undefined keys.</p> <pre data-language="javascript"><span class="hljs-comment">// In Mongoose 6, equivalent to `findOneAndUpdate({}, {}, { new: true })` because Mongoose will</span>
<span class="hljs-comment">// remove `name: undefined`</span>
<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> Test.findOneAndUpdate({}, { <span class="hljs-attr">$set</span>: { <span class="hljs-attr">name</span>: <span class="hljs-literal">undefined</span> } }, { <span class="hljs-attr">new</span>: <span class="hljs-literal">true</span> });
</pre> <h3 id="document-parameter-to-default-functions">Document Parameter to Default Functions</h3> <p>Mongoose now passes the document as the first parameter to <code>default</code> functions, which is helpful for using <a href="https://masteringjs.io/tutorials/fundamentals/arrow">arrow functions</a> with defaults.</p> <p>This may affect you if you pass a function that expects different parameters to <code>default</code>, like <code>default: mongoose.Types.ObjectId</code>. See <a href="https://github.com/Automattic/mongoose/issues/9633">gh-9633</a>. If you're passing a default function that does <strong>not</strong> utilize the document, change <code>default: myFunction</code> to <code>default: () =&gt; myFunction()</code> to avoid accidentally passing parameters that potentially change the behavior.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">String</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">Number</span>,
  <span class="hljs-attr">canVote</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-built_in">Boolean</span>,
    <span class="hljs-comment">// Default functions now receive a `doc` parameter, helpful for arrow functions</span>
    <span class="hljs-attr">default</span>: <span class="hljs-function"><span class="hljs-params">doc</span> =&gt;</span> doc.age &gt;= <span class="hljs-number">18</span>
  }
});
</pre> <h3 id="arrays-are-proxies">Arrays are Proxies</h3> <p>Mongoose arrays are now ES6 proxies. You no longer need to <code>markModified()</code> after setting an array index directly.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> post = <span class="hljs-keyword">await</span> BlogPost.findOne();

post.tags[<span class="hljs-number">0</span>] = <span class="hljs-string">'javascript'</span>;
<span class="hljs-keyword">await</span> post.save(); <span class="hljs-comment">// Works, no need for `markModified()`!</span>
</pre> <h3 id="typepojotomixed">`typePojoToMixed`</h3> <p>Schema paths declared with <code>type: { name: String }</code> become single nested subdocs in Mongoose 6, as opposed to Mixed in Mongoose 5. This removes the need for the <code>typePojoToMixed</code> option. See <a href="https://github.com/Automattic/mongoose/issues/7181">gh-7181</a>.</p> <pre data-language="javascript"><span class="hljs-comment">// In Mongoose 6, the below makes `foo` into a subdocument with a `name` property.</span>
<span class="hljs-comment">// In Mongoose 5, the below would make `foo` a `Mixed` type, _unless_ you set `typePojoToMixed: true`.</span>
<span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({
  <span class="hljs-attr">foo</span>: { <span class="hljs-attr">type</span>: { <span class="hljs-attr">name</span>: <span class="hljs-built_in">String</span> } }
});
</pre> <h3 id="strictpopulate">`strictPopulate()`</h3> <p>Mongoose now throws an error if you <code>populate()</code> a path that isn't defined in your schema. This is only for cases when we can infer the local schema, like when you use <code>Query#populate()</code>, <strong>not</strong> when you call <code>Model.populate()</code> on a POJO. See <a href="https://github.com/Automattic/mongoose/issues/5124">gh-5124</a>.</p> <h3 id="subdocument-ref-function-context">Subdocument `ref` Function Context</h3> <p>When populating a subdocument with a function <code>ref</code> or <code>refPath</code>, <code>this</code> is now the subdocument being populated, not the top-level document. See <a href="https://github.com/Automattic/mongoose/issues/8469">#8469</a>.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({
  <span class="hljs-attr">works</span>: [{
    <span class="hljs-attr">modelId</span>: <span class="hljs-built_in">String</span>,
    <span class="hljs-attr">data</span>: {
      <span class="hljs-attr">type</span>: mongoose.ObjectId,
      <span class="hljs-attr">ref</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{
        <span class="hljs-comment">// In Mongoose 6, `doc` is the array element, so you can access `modelId`.</span>
        <span class="hljs-comment">// In Mongoose 5, `doc` was the top-level document.</span>
        <span class="hljs-keyword">return</span> doc.modelId;
      }
    }
  }]
});
</pre> <h3 id="schema-reserved-names-warning">Schema Reserved Names Warning</h3> <p>Using <code>save</code>, <code>isNew</code>, and other Mongoose reserved names as schema path names now triggers a warning, not an error. You can suppress the warning by setting the <code>supressReservedKeysWarning</code> in your schema options: <code>new Schema({ save: String }, { supressReservedKeysWarning: true })</code>. Keep in mind that this may break plugins that rely on these reserved names.</p> <h3 id="subdocument-paths">Subdocument Paths</h3> <p>Single nested subdocs have been renamed to "subdocument paths". So <code>SchemaSingleNestedOptions</code> is now <code>SchemaSubdocumentOptions</code> and <code>mongoose.Schema.Types.Embedded</code> is now <code>mongoose.Schema.Types.Subdocument</code>. See <a href="https://github.com/Automattic/mongoose/issues/10419">gh-10419</a></p> <h3 id="creating-aggregation-cursors">Creating Aggregation Cursors</h3> <p><code>Aggregate#cursor()</code> now returns an AggregationCursor instance to be consistent with <code>Query#cursor()</code>. You no longer need to do <code>Model.aggregate(pipeline).cursor().exec()</code> to get an aggregation cursor, just <code>Model.aggregate(pipeline).cursor()</code>.</p> <h3 id="autocreate-defaults-to-true">`autoCreate` Defaults to `true`</h3> <p><code>autoCreate</code> is <code>true</code> by default <strong>unless</strong> readPreference is secondary or secondaryPreferred, which means Mongoose will attempt to create every model's underlying collection before creating indexes. If readPreference is secondary or secondaryPreferred, Mongoose will default to <code>false</code> for both <code>autoCreate</code> and <code>autoIndex</code> because both <code>createCollection()</code> and <code>createIndex()</code> will fail when connected to a secondary.</p> <h3 id="no-more-context-query">No More `context: 'query'`</h3> <p>The <code>context</code> option for queries has been removed. Now Mongoose always uses <code>context = 'query'</code>.</p> <h3 id="custom-validators-with-populated-paths">Custom Validators with Populated Paths</h3> <p>Mongoose 6 always calls validators with depopulated paths (that is, with the id rather than the document itself). In Mongoose 5, Mongoose would call validators with the populated doc if the path was populated. See <a href="https://github.com/Automattic/mongoose/issues/8042">#8042</a></p> <h3 id="disconnected-event-with-replica-sets">Disconnected Event with Replica Sets</h3> <p>When connected to a replica set, connections now emit 'disconnected' when connection to the primary is lost. In Mongoose 5, connections only emitted 'disconnected' when losing connection to all members of the replica set.</p> <p>However, Mongoose 6 does <strong>not</strong> buffer commands while a connection is disconnected. So you can still successfully execute commands like queries with <code>readPreference = 'secondary'</code>, even if the Mongoose connection is in the disconnected state.</p> <h3 id="removed-execpopulate">Removed `execPopulate()`</h3> <p><code>Document#populate()</code> now returns a promise and is now no longer chainable.</p> <ul> <li>Replace <code>await doc.populate('path1').populate('path2').execPopulate();</code> with <code>await doc.populate(['path1', 'path2']);</code>
</li> <li>Replace <code>await doc.populate('path1', 'select1').populate('path2', 'select2').execPopulate();</code> with<pre data-language="javascript"><span class="hljs-keyword">await</span> doc.populate([{<span class="hljs-attr">path</span>: <span class="hljs-string">'path1'</span>, <span class="hljs-attr">select</span>: <span class="hljs-string">'select1'</span>}, {<span class="hljs-attr">path</span>: <span class="hljs-string">'path2'</span>, <span class="hljs-attr">select</span>: <span class="hljs-string">'select2'</span>}]);
</pre> </li> </ul> <h3 id="create-with-empty-array">`create()` with Empty Array</h3> <p><code>await Model.create([])</code> in v6.0 returns an empty array when provided an empty array, in v5.0 it used to return <code>undefined</code>. If any of your code is checking whether the output is <code>undefined</code> or not, you need to modify it with the assumption that <code>await Model.create(...)</code> will always return an array if provided an array.</p> <h3 id="removed-nested-path-merging">Removed Nested Path Merging</h3> <p><code>doc.set({ child: { age: 21 } })</code> now works the same whether <code>child</code> is a nested path or a subdocument: Mongoose will overwrite the value of <code>child</code>. In Mongoose 5, this operation would merge <code>child</code> if <code>child</code> was a nested path.</p> <h3 id="objectid-valueof">ObjectId `valueOf()`</h3> <p>Mongoose now adds a <code>valueOf()</code> function to ObjectIds. This means you can now use <code>==</code> to compare an ObjectId against a string.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> a = ObjectId(<span class="hljs-string">'6143b55ac9a762738b15d4f0'</span>);

a == <span class="hljs-string">'6143b55ac9a762738b15d4f0'</span>; <span class="hljs-comment">// true</span>
</pre> <h3 id="immutable-createdat">Immutable `createdAt`</h3> <p>If you set <code>timestamps: true</code>, Mongoose will now make the <code>createdAt</code> property <code>immutable</code>. See <a href="https://github.com/Automattic/mongoose/issues/10139">gh-10139</a></p> <h3 id="removed-validator-isasync">Removed Validator `isAsync`</h3> <p><code>isAsync</code> is no longer an option for <code>validate</code>. Use an <code>async function</code> instead.</p> <h3 id="removed-safe">Removed `safe`</h3> <p><code>safe</code> is no longer an option for schemas, queries, or <code>save()</code>. Use <code>writeConcern</code> instead.</p> <h3 id="schematype-set-parameters">SchemaType `set` parameters</h3> <p>Mongoose now calls setter functions with <code>priorValue</code> as the 2nd parameter, rather than <code>schemaType</code> in Mongoose 5.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> Schema({
  <span class="hljs-attr">name</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,
    <span class="hljs-attr">trimStart</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">set</span>: trimStartSetter
  }
});

<span class="hljs-comment">// in v5.x the parameters were (value, schemaType), in v6.x the parameters are (value, priorValue, schemaType).</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trimStartSetter</span>(<span class="hljs-params">val, priorValue, schemaType</span>) </span>{
  <span class="hljs-keyword">if</span> (schemaType.options.trimStart &amp;&amp; <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">return</span> val.trimStart();
  }
  <span class="hljs-keyword">return</span> val;
}

<span class="hljs-keyword">const</span> User = mongoose.model(<span class="hljs-string">'User'</span>, userSchema);

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> User({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Robert Martin'</span> });
<span class="hljs-built_in">console</span>.log(user.name); <span class="hljs-comment">// 'robert martin'</span>
</pre> <h3 id="toobject-and-tojson-use-nested-schema-minimize">`toObject()` and `toJSON()` Use Nested Schema `minimize`</h3> <p>This change was technically released with 5.10.5, but <a href="https://github.com/Automattic/mongoose/issues/10827">caused issues for users migrating from 5.9.x to 6.x</a>. In Mongoose <code>&lt; 5.10.5</code>, <code>toObject()</code> and <code>toJSON()</code> would use the top-level schema's <code>minimize</code> option by default.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">thing</span>: Schema.Types.Mixed });
<span class="hljs-keyword">const</span> parent = <span class="hljs-keyword">new</span> Schema({ child }, { <span class="hljs-attr">minimize</span>: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">const</span> Parent = model(<span class="hljs-string">'Parent'</span>, parent);
<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> Parent({ <span class="hljs-attr">child</span>: { <span class="hljs-attr">thing</span>: {} } });

<span class="hljs-comment">// In v5.10.4, would contain `child.thing` because `toObject()` uses `parent` schema's `minimize` option</span>
<span class="hljs-comment">// In `&gt;= 5.10.5`, `child.thing` is omitted because `child` schema has `minimize: true`</span>
<span class="hljs-built_in">console</span>.log(p.toObject());
</pre> <p>As a workaround, you can either explicitly pass <code>minimize</code> to <code>toObject()</code> or <code>toJSON()</code>:</p> <pre data-language="javascript"><span class="hljs-built_in">console</span>.log(p.toObject({ <span class="hljs-attr">minimize</span>: <span class="hljs-literal">false</span> }));
</pre> <p>Or define the <code>child</code> schema inline (Mongoose 6 only) to inherit the parent's <code>minimize</code> option.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> parent = <span class="hljs-keyword">new</span> Schema({
  <span class="hljs-comment">// Implicitly creates a new schema with the top-level schema's `minimize` option.</span>
  <span class="hljs-attr">child</span>: { <span class="hljs-attr">type</span>: { <span class="hljs-attr">thing</span>: Schema.Types.Mixed } }
}, { <span class="hljs-attr">minimize</span>: <span class="hljs-literal">false</span> });
</pre> <h2 id="typescript-changes">  TypeScript changes  </h2> <p>The <code>Schema</code> class now takes 3 generic params instead of 4. The 3rd generic param, <code>SchemaDefinitionType</code>, is now the same as the 1st generic param <code>DocType</code>. Replace <code>new Schema&lt;UserDocument, UserModel, User&gt;(schemaDefinition)</code> with <code>new Schema&lt;UserDocument, UserModel&gt;(schemaDefinition)</code></p> <p><code>Types.ObjectId</code> is now a class, which means you can no longer omit <code>new</code> when creating a new ObjectId using <code>new mongoose.Types.ObjectId()</code>. Currently, you can still omit <code>new</code> in JavaScript, but you <strong>must</strong> put <code>new</code> in TypeScript.</p> <p>The following legacy types have been removed:</p> <ul> <li><code>ModelUpdateOptions</code></li> <li><code>DocumentQuery</code></li> <li><code>HookSyncCallback</code></li> <li><code>HookAsyncCallback</code></li> <li><code>HookErrorCallback</code></li> <li><code>HookNextFunction</code></li> <li><code>HookDoneFunction</code></li> <li><code>SchemaTypeOpts</code></li> <li><code>ConnectionOptions</code></li> </ul><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://mongoosejs.com/docs/migrating_to_6.html" class="_attribution-link" target="_blank">https://mongoosejs.com/docs/migrating_to_6.html</a>
  </p>
</div>
