<a class="edit-docs-link" href="https://github.com/Automattic/mongoose/blob/master/lib/query.js" target="_blank"> <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHZpZXdCb3g9IjAgMCAxMDAwIDEwMDAiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDEwMDAgMTAwMCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8Zz48ZyB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAtMSAwIDQ4MCkiPjxwYXRoIHN0cm9rZT0iIzA5NzFCMiIgZmlsbD0iIzA5NzFCMiIgZD0iTTkzMC45LDQyMC41Yy0zMy4xLDMxLjgtNjkuMyw0Ny43LTEwOC43LDQ3LjdjLTQ0LjUsMC04My45LTE3LjItMTE4LjItNTEuNUw5OS40LTE4NS45Yy0zLjgtMy44LTYuNC04LjktNy42LTE1LjNjLTIuNS04LjktMjkuMi05Ny45LTgwLjEtMjY3Yy0zLjgtMTIuNy0xLjMtMjMuNSw3LjYtMzIuNGM2LjQtNS4xLDE0LTcuNiwyMi45LTcuNmg5LjVjMTMyLjIsNDQuNSwyMTkuOSw3My4xLDI2My4yLDg1LjhjMy44LDEuMyw3LjYsMy44LDExLjQsNy42YzM3NSwzNzAsNTc3LjIsNTcwLjIsNjA2LjQsNjAwLjdjMzguMSwzOS40LDU3LjIsNzkuNSw1Ny4yLDEyMC4xQzk4OC43LDM0Ni44LDk2OSwzODQuOSw5MzAuOSw0MjAuNXogTTY5NC40LDMxOS40YzMxLjgtNy42LDYxLjctMjUuNCw4OS42LTUzLjRjMjYuNy0yNi43LDQzLjItNTcuMiw0OS42LTkxLjVDNzQ3LjIsODguMSw1NzguNy03OS4xLDMyOC4zLTMyN2MtMTIuNywzMC41LTI5LjksNTYuNi01MS41LDc4LjJjLTI2LjcsMjYuNy01Ni42LDQ3LTg5LjYsNjFMMzMyLjEtNDIuOWwyMTAuNywyMTAuN0w2OTQuNCwzMTkuNHogTTE0NS4yLTIzOS4zYzMxLjgtNy42LDYxLTI1LjQsODcuNy01My40YzIxLjYtMjEuNiwzNi45LTQ3LDQ1LjgtNzYuM2MtMTIuNy0zLjgtNDIuOS0xNC05MC42LTMwLjVjLTQ3LjctMTYuNS04Mi4zLTI4LTEwMy45LTM0LjNjNi40LDE5LjEsMTYuOCw1Mi4xLDMxLjUsOTkuMkMxMzAuMy0yODcuNiwxNDAuMS0yNTUuOCwxNDUuMi0yMzkuM3ogTTg4OC45LDIyOS44bC01LjctNS43Yy0xMi43LDMzLjEtMzEuMSw2MS43LTU1LjMsODUuOEM4MDIuNSwzMzUuMyw3NzQuNSwzNTUsNzQ0LDM2OWwxLjksMS45bDEuOSwxLjljMjIuOSwyMi45LDQ3LjcsMzQuMyw3NC40LDM0LjNjMjIuOSwwLDQ1LjEtMTAuOCw2Ni43LTMyLjRjMjUuNC0yNC4yLDM4LjEtNDcuNywzOC4xLTcwLjZTOTE0LjQsMjU2LjUsODg4LjksMjI5Ljh6Ii8+PC9nPjwvZz4NCjwvc3ZnPg=="> </a><h1>Query</h1>

<div class="api-content">
<h3 id="query_Query">Query()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[options] <span class="method-type">«Object»</span> </li>
<li class="param">[model] <span class="method-type">«Object»</span> </li>
<li class="param">[conditions] <span class="method-type">«Object»</span> </li>
<li class="param">[collection] <span class="method-type">«Object»</span> Mongoose collection </li>
</ul>
<div>
<p>Query constructor used for building queries. You do not need to instantiate a <code>Query</code> directly. Instead use Model functions like <a href="https://mongoosejs.com/docs/api.html#find_find"><code>Model.find()</code></a>.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> query = MyModel.find(); <span class="hljs-comment">// `query` is an instance of `Query`</span>
query.setOptions({ <span class="hljs-attr">lean</span> : <span class="hljs-literal">true</span> });
query.collection(MyModel.collection);
query.where(<span class="hljs-string">'age'</span>).gte(<span class="hljs-number">21</span>).exec(callback);

<span class="hljs-comment">// You can instantiate a query directly. There is no need to do</span>
<span class="hljs-comment">// this unless you're an advanced user with a very good reason to.</span>
<span class="hljs-keyword">const</span> query = <span class="hljs-keyword">new</span> mongoose.Query();</pre> </div>
<h3 id="query_Query-$where">Query.prototype.$where()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">js <span class="method-type">«String|Function»</span> javascript string or function </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Specifies a javascript function or expression to pass to MongoDBs query system.</p> <h4>Example</h4> <pre data-language="javascript">query.$where(<span class="hljs-string">'this.comments.length === 10 || this.name.length === 5'</span>)

<span class="hljs-comment">// or</span>

query.$where(<span class="hljs-function"><span class="hljs-keyword">function</span> () </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.comments.length === <span class="hljs-number">10</span> || <span class="hljs-keyword">this</span>.name.length === <span class="hljs-number">5</span>;
})</pre> <h4>NOTE:</h4> <p>Only use <code>$where</code> when you have a condition that cannot be met using other MongoDB operators like <code>$lt</code>. <strong>Be sure to read about all of <a href="http://docs.mongodb.org/manual/reference/operator/where/">its caveats</a> before using.</strong></p> </div>
<h3 id="query_Query-Symbol.asyncIterator">Query.prototype.Symbol.asyncIterator()</h3>
<div>
<p>Returns an asyncIterator for use with <a href="https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js"><code>for/await/of</code> loops</a> This function <em>only</em> works for <code>find()</code> queries. You do not need to call this function explicitly, the JavaScript runtime will call it for you.</p> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> doc <span class="hljs-keyword">of</span> Model.aggregate([{ <span class="hljs-attr">$sort</span>: { <span class="hljs-attr">name</span>: <span class="hljs-number">1</span> } }])) {
  <span class="hljs-built_in">console</span>.log(doc.name);
}</pre> <p>Node.js 10.x supports async iterators natively without any flags. You can enable async iterators in Node.js 8.x using the <a href="https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187"><code>--harmony_async_iteration</code> flag</a>.</p> <p><strong>Note:</strong> This function is not if <code>Symbol.asyncIterator</code> is undefined. If <code>Symbol.asyncIterator</code> is undefined, that means your Node.js version does not support async iterators.</p> </div>
<h3 id="query_Query-all">Query.prototype.all()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[path] <span class="method-type">«String»</span> </li>
<li class="param">val <span class="method-type">«Array»</span> </li>
</ul>
<div>
<p>Specifies an <code>$all</code> query condition.</p> <p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p> <h4>Example:</h4> <pre data-language="javascript">MyModel.find().where(<span class="hljs-string">'pets'</span>).all([<span class="hljs-string">'dog'</span>, <span class="hljs-string">'cat'</span>, <span class="hljs-string">'ferret'</span>]);
<span class="hljs-comment">// Equivalent:</span>
MyModel.find().all(<span class="hljs-string">'pets'</span>, [<span class="hljs-string">'dog'</span>, <span class="hljs-string">'cat'</span>, <span class="hljs-string">'ferret'</span>]);</pre> </div>
<h3 id="query_Query-allowDiskUse">Query.prototype.allowDiskUse()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">[v] <span class="method-type">«Boolean»</span> Enable/disable <code>allowDiskUse</code>. If called with 0 arguments, sets <code>allowDiskUse: true</code> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Sets the <a href="https://docs.mongodb.com/manual/reference/method/cursor.allowDiskUse/"><code>allowDiskUse</code> option</a>, which allows the MongoDB server to use more than 100 MB for this query's <code>sort()</code>. This option can let you work around <code>QueryExceededMemoryLimitNoDiskUseAllowed</code> errors from the MongoDB server.</p> <p>Note that this option requires MongoDB server &gt;= 4.4. Setting this option is a no-op for MongoDB 4.2 and earlier.</p> <p>Calling <code>query.allowDiskUse(v)</code> is equivalent to <code>query.setOptions({ allowDiskUse: v })</code></p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">await</span> query.find().sort({ <span class="hljs-attr">name</span>: <span class="hljs-number">1</span> }).allowDiskUse(<span class="hljs-literal">true</span>);
<span class="hljs-comment">// Equivalent:</span>
<span class="hljs-keyword">await</span> query.find().sort({ <span class="hljs-attr">name</span>: <span class="hljs-number">1</span> }).allowDiskUse();</pre> </div>
<h3 id="query_Query-and">Query.prototype.and()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">array <span class="method-type">«Array»</span> array of conditions </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Specifies arguments for a <code>$and</code> condition.</p> <h4>Example</h4> <pre data-language="javascript">query.and([{ <span class="hljs-attr">color</span>: <span class="hljs-string">'green'</span> }, { <span class="hljs-attr">status</span>: <span class="hljs-string">'ok'</span> }])</pre> </div>
<h3 id="query_Query-batchSize">Query.prototype.batchSize()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">val <span class="method-type">«Number»</span> </li></ul>
<div>
<p>Specifies the batchSize option.</p> <h4>Example</h4> <pre data-language="javascript">query.batchSize(<span class="hljs-number">100</span>)</pre> <h4>Note</h4> <p>Cannot be used with <code>distinct()</code></p> </div>
<h3 id="query_Query-box">Query.prototype.box()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">val <span class="method-type">«Object»</span> </li>
<li class="param">Upper <span class="method-type">«[Array]»</span> Right Coords </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Specifies a <code>$box</code> condition</p> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> lowerLeft = [<span class="hljs-number">40.73083</span>, <span class="hljs-number">-73.99756</span>]
<span class="hljs-keyword">const</span> upperRight= [<span class="hljs-number">40.741404</span>,  <span class="hljs-number">-73.988135</span>]

query.where(<span class="hljs-string">'loc'</span>).within().box(lowerLeft, upperRight)
query.box({ <span class="hljs-attr">ll</span> : lowerLeft, <span class="hljs-attr">ur</span> : upperRight })</pre> </div>
<h3 id="query_Query-cast">Query.prototype.cast()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[model] <span class="method-type">«Model»</span> the model to cast to. If not set, defaults to <code>this.model</code> </li>
<li class="param">[obj] <span class="method-type">«Object»</span> </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Object»</span> </li></ul>
<div>
<p>Casts this query to the schema of <code>model</code></p> <h4>Note</h4> <p>If <code>obj</code> is present, it is cast instead of this query.</p> </div>
<h3 id="query_Query-catch">Query.prototype.catch()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">[reject] <span class="method-type">«Function»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Promise»</span> </li></ul>
<div>
<p>Executes the query returning a <code>Promise</code> which will be resolved with either the doc(s) or rejected with the error. Like <code>.then()</code>, but only takes a rejection handler.</p> <p>More about <a href="https://masteringjs.io/tutorials/fundamentals/catch">Promise <code>catch()</code> in JavaScript</a>.</p> </div>
<h3 id="query_Query-center">Query.prototype.center()</h3>
<div>
<p><em>DEPRECATED</em> Alias for <a href="#query_Query-circle">circle</a></p> <p><strong>Deprecated.</strong> Use <a href="#query_Query-circle">circle</a> instead.</p> </div>
<h3 id="query_Query-centerSphere">Query.prototype.centerSphere()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[path] <span class="method-type">«String»</span> </li>
<li class="param">val <span class="method-type">«Object»</span> </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p><em>DEPRECATED</em> Specifies a <code>$centerSphere</code> condition</p> <p><strong>Deprecated.</strong> Use <a href="#query_Query-circle">circle</a> instead.</p> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> area = { <span class="hljs-attr">center</span>: [<span class="hljs-number">50</span>, <span class="hljs-number">50</span>], <span class="hljs-attr">radius</span>: <span class="hljs-number">10</span> };
query.where(<span class="hljs-string">'loc'</span>).within().centerSphere(area);</pre> </div>
<h3 id="query_Query-circle">Query.prototype.circle()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[path] <span class="method-type">«String»</span> </li>
<li class="param">area <span class="method-type">«Object»</span> </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Specifies a <code>$center</code> or <code>$centerSphere</code> condition.</p> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> area = { <span class="hljs-attr">center</span>: [<span class="hljs-number">50</span>, <span class="hljs-number">50</span>], <span class="hljs-attr">radius</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span> }
query.where(<span class="hljs-string">'loc'</span>).within().circle(area)
<span class="hljs-comment">// alternatively</span>
query.circle(<span class="hljs-string">'loc'</span>, area);

<span class="hljs-comment">// spherical calculations</span>
<span class="hljs-keyword">const</span> area = { <span class="hljs-attr">center</span>: [<span class="hljs-number">50</span>, <span class="hljs-number">50</span>], <span class="hljs-attr">radius</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">spherical</span>: <span class="hljs-literal">true</span> }
query.where(<span class="hljs-string">'loc'</span>).within().circle(area)
<span class="hljs-comment">// alternatively</span>
query.circle(<span class="hljs-string">'loc'</span>, area);</pre> </div>
<h3 id="query_Query-clone">Query.prototype.clone()</h3>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> copy </li></ul>
<div>
<p>Make a copy of this query so you can re-execute it.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> q = Book.findOne({ <span class="hljs-attr">title</span>: <span class="hljs-string">'Casino Royale'</span> });
<span class="hljs-keyword">await</span> q.exec();
<span class="hljs-keyword">await</span> q.exec(); <span class="hljs-comment">// Throws an error because you can't execute a query twice</span>

<span class="hljs-keyword">await</span> q.clone().exec(); <span class="hljs-comment">// Works</span></pre> </div>
<h3 id="query_Query-collation">Query.prototype.collation()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">value <span class="method-type">«Object»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Adds a collation to this op (MongoDB 3.4 and up)</p> </div>
<h3 id="query_Query-comment">Query.prototype.comment()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">val <span class="method-type">«String»</span> </li></ul>
<div>
<p>Specifies the <code>comment</code> option.</p> <h4>Example</h4> <pre data-language="javascript">query.comment(<span class="hljs-string">'login query'</span>)</pre> <h4>Note</h4> <p>Cannot be used with <code>distinct()</code></p> </div>
<h3 id="query_Query-count">Query.prototype.count()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[filter] <span class="method-type">«Object»</span> count documents that match this object </li>
<li class="param">[callback] <span class="method-type">«Function»</span> optional params are (error, count) </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Specifies this query as a <code>count</code> query.</p> <p>This method is deprecated. If you want to count the number of documents in a collection, e.g. <code>count({})</code>, use the <a href="https://mongoosejs.com/docs/api.html#query_Query-estimatedDocumentCount"><code>estimatedDocumentCount()</code> function</a> instead. Otherwise, use the <a href="https://mongoosejs.com/docs/api.html#query_Query-countDocuments"><code>countDocuments()</code></a> function instead.</p> <p>Passing a <code>callback</code> executes the query.</p> <p>This function triggers the following middleware.</p> <ul> <li><code>count()</code></li> </ul> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> countQuery = model.where({ <span class="hljs-string">'color'</span>: <span class="hljs-string">'black'</span> }).count();

query.count({ <span class="hljs-attr">color</span>: <span class="hljs-string">'black'</span> }).count(callback)

query.count({ <span class="hljs-attr">color</span>: <span class="hljs-string">'black'</span> }, callback)

query.where(<span class="hljs-string">'color'</span>, <span class="hljs-string">'black'</span>).count(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, count</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'there are %d kittens'</span>, count);
})</pre> </div>
<h3 id="query_Query-countDocuments">Query.prototype.countDocuments()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[filter] <span class="method-type">«Object»</span> mongodb selector </li>
<li class="param">[options] <span class="method-type">«Object»</span> </li>
<li class="param">[callback] <span class="method-type">«Function»</span> optional params are (error, count) </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Specifies this query as a <code>countDocuments()</code> query. Behaves like <code>count()</code>, except it always does a full collection scan when passed an empty filter <code>{}</code>.</p> <p>There are also minor differences in how <code>countDocuments()</code> handles <a href="http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#countDocuments"><code>$where</code> and a couple geospatial operators</a>. versus <code>count()</code>.</p> <p>Passing a <code>callback</code> executes the query.</p> <p>This function triggers the following middleware.</p> <ul> <li><code>countDocuments()</code></li> </ul> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> countQuery = model.where({ <span class="hljs-string">'color'</span>: <span class="hljs-string">'black'</span> }).countDocuments();

query.countDocuments({ <span class="hljs-attr">color</span>: <span class="hljs-string">'black'</span> }).count(callback);

query.countDocuments({ <span class="hljs-attr">color</span>: <span class="hljs-string">'black'</span> }, callback);

query.where(<span class="hljs-string">'color'</span>, <span class="hljs-string">'black'</span>).countDocuments(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, count</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'there are %d kittens'</span>, count);
});</pre> <p>The <code>countDocuments()</code> function is similar to <code>count()</code>, but there are a <a href="https://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#countDocuments">few operators that <code>countDocuments()</code> does not support</a>. Below are the operators that <code>count()</code> supports but <code>countDocuments()</code> does not, and the suggested replacement:</p> <ul> <li>
<code>$where</code>: <a href="https://docs.mongodb.com/manual/reference/operator/query/expr/"><code>$expr</code></a>
</li> <li>
<code>$near</code>: <a href="https://docs.mongodb.com/manual/reference/operator/query/geoWithin/"><code>$geoWithin</code></a> with <a href="https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center"><code>$center</code></a>
</li> <li>
<code>$nearSphere</code>: <a href="https://docs.mongodb.com/manual/reference/operator/query/geoWithin/"><code>$geoWithin</code></a> with <a href="https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere"><code>$centerSphere</code></a>
</li> </ul> </div>
<h3 id="query_Query-cursor">Query.prototype.cursor()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">[options] <span class="method-type">«Object»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«QueryCursor»</span> </li></ul>
<div>
<p>Returns a wrapper around a <a href="http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html">mongodb driver cursor</a>. A QueryCursor exposes a Streams3 interface, as well as a <code>.next()</code> function.</p> <p>The <code>.cursor()</code> function triggers pre find hooks, but <strong>not</strong> post find hooks.</p> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-comment">// There are 2 ways to use a cursor. First, as a stream:</span>
Thing.
  find({ <span class="hljs-attr">name</span>: <span class="hljs-regexp">/^hello/</span> }).
  cursor().
  on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{ <span class="hljs-built_in">console</span>.log(doc); }).
  on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Done!'</span>); });

<span class="hljs-comment">// Or you can use `.next()` to manually get the next doc in the stream.</span>
<span class="hljs-comment">// `.next()` returns a promise, so you can use promises or callbacks.</span>
<span class="hljs-keyword">const</span> cursor = Thing.find({ <span class="hljs-attr">name</span>: <span class="hljs-regexp">/^hello/</span> }).cursor();
cursor.next(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, doc</span>) </span>{
  <span class="hljs-built_in">console</span>.log(doc);
});

<span class="hljs-comment">// Because `.next()` returns a promise, you can use co</span>
<span class="hljs-comment">// to easily iterate through all documents without loading them</span>
<span class="hljs-comment">// all into memory.</span>
<span class="hljs-keyword">const</span> cursor = Thing.find({ <span class="hljs-attr">name</span>: <span class="hljs-regexp">/^hello/</span> }).cursor();
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> doc = <span class="hljs-keyword">await</span> cursor.next(); doc != <span class="hljs-literal">null</span>; doc = <span class="hljs-keyword">await</span> cursor.next()) {
  <span class="hljs-built_in">console</span>.log(doc);
}</pre> <h4>Valid options</h4> <ul> <li>
<code>transform</code>: optional function which accepts a mongoose document. The return value of the function will be emitted on <code>data</code> and returned by <code>.next()</code>.</li> </ul> </div>
<h3 id="query_Query-deleteMany">Query.prototype.deleteMany()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[filter] <span class="method-type">«Object|Query»</span> mongodb selector </li>
<li class="param">[options] <span class="method-type">«Object»</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a> </li>
<li class="param">[callback] <span class="method-type">«Function»</span> optional params are (error, mongooseDeleteResult) </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Declare and/or execute this query as a <code>deleteMany()</code> operation. Works like remove, except it deletes <em>every</em> document that matches <code>filter</code> in the collection, regardless of the value of <code>single</code>.</p> <p>This function triggers <code>deleteMany</code> middleware.</p> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-keyword">await</span> Character.deleteMany({ <span class="hljs-attr">name</span>: <span class="hljs-regexp">/Stark/</span>, <span class="hljs-attr">age</span>: { <span class="hljs-attr">$gte</span>: <span class="hljs-number">18</span> } });

<span class="hljs-comment">// Using callbacks:</span>
Character.deleteMany({ <span class="hljs-attr">name</span>: <span class="hljs-regexp">/Stark/</span>, <span class="hljs-attr">age</span>: { <span class="hljs-attr">$gte</span>: <span class="hljs-number">18</span> } }, callback);</pre> <p>This function calls the MongoDB driver's <a href="http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#deleteMany"><code>Collection#deleteMany()</code> function</a>. The returned <a href="../queries">promise</a> resolves to an object that contains 3 properties:</p> <ul> <li>
<code>ok</code>: <code>1</code> if no errors occurred</li> <li>
<code>deletedCount</code>: the number of documents deleted</li> <li>
<code>n</code>: the number of documents deleted. Equal to <code>deletedCount</code>.</li> </ul> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> Character.deleteMany({ <span class="hljs-attr">name</span>: <span class="hljs-regexp">/Stark/</span>, <span class="hljs-attr">age</span>: { <span class="hljs-attr">$gte</span>: <span class="hljs-number">18</span> } });
<span class="hljs-comment">// `0` if no docs matched the filter, number of docs deleted otherwise</span>
res.deletedCount;</pre> </div>
<h3 id="query_Query-deleteOne">Query.prototype.deleteOne()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[filter] <span class="method-type">«Object|Query»</span> mongodb selector </li>
<li class="param">[options] <span class="method-type">«Object»</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a> </li>
<li class="param">[callback] <span class="method-type">«Function»</span> optional params are (error, mongooseDeleteResult) </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Declare and/or execute this query as a <code>deleteOne()</code> operation. Works like remove, except it deletes at most one document regardless of the <code>single</code> option.</p> <p>This function triggers <code>deleteOne</code> middleware.</p> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-keyword">await</span> Character.deleteOne({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Eddard Stark'</span> });

<span class="hljs-comment">// Using callbacks:</span>
Character.deleteOne({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Eddard Stark'</span> }, callback);</pre> <p>This function calls the MongoDB driver's <a href="http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#deleteOne"><code>Collection#deleteOne()</code> function</a>. The returned <a href="../queries">promise</a> resolves to an object that contains 3 properties:</p> <ul> <li>
<code>ok</code>: <code>1</code> if no errors occurred</li> <li>
<code>deletedCount</code>: the number of documents deleted</li> <li>
<code>n</code>: the number of documents deleted. Equal to <code>deletedCount</code>.</li> </ul> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> Character.deleteOne({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Eddard Stark'</span> });
<span class="hljs-comment">// `1` if MongoDB deleted a doc, `0` if no docs matched the filter `{ name: ... }`</span>
res.deletedCount;</pre> </div>
<h3 id="query_Query-distinct">Query.prototype.distinct()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[field] <span class="method-type">«String»</span> </li>
<li class="param">[filter] <span class="method-type">«Object|Query»</span> </li>
<li class="param">[callback] <span class="method-type">«Function»</span> optional params are (error, arr) </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Declares or executes a distinct() operation.</p> <p>Passing a <code>callback</code> executes the query.</p> <p>This function does not trigger any middleware.</p> <h4>Example</h4> <pre data-language="javascript">distinct(field, conditions, callback)
distinct(field, conditions)
distinct(field, callback)
distinct(field)
distinct(callback)
distinct()</pre> </div>
<h3 id="query_Query-elemMatch">Query.prototype.elemMatch()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">path <span class="method-type">«String|Object|Function»</span> </li>
<li class="param">filter <span class="method-type">«Object|Function»</span> </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Specifies an <code>$elemMatch</code> condition</p> <h4>Example</h4> <pre data-language="javascript">query.elemMatch(<span class="hljs-string">'comment'</span>, { <span class="hljs-attr">author</span>: <span class="hljs-string">'autobot'</span>, <span class="hljs-attr">votes</span>: {<span class="hljs-attr">$gte</span>: <span class="hljs-number">5</span>}})

query.where(<span class="hljs-string">'comment'</span>).elemMatch({ <span class="hljs-attr">author</span>: <span class="hljs-string">'autobot'</span>, <span class="hljs-attr">votes</span>: {<span class="hljs-attr">$gte</span>: <span class="hljs-number">5</span>}})

query.elemMatch(<span class="hljs-string">'comment'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
  elem.where(<span class="hljs-string">'author'</span>).equals(<span class="hljs-string">'autobot'</span>);
  elem.where(<span class="hljs-string">'votes'</span>).gte(<span class="hljs-number">5</span>);
})

query.where(<span class="hljs-string">'comment'</span>).elemMatch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
  elem.where({ <span class="hljs-attr">author</span>: <span class="hljs-string">'autobot'</span> });
  elem.where(<span class="hljs-string">'votes'</span>).gte(<span class="hljs-number">5</span>);
})</pre> </div>
<h3 id="query_Query-equals">Query.prototype.equals()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">val <span class="method-type">«Object»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Specifies the complementary comparison value for paths specified with <code>where()</code></p> <h4>Example</h4> <pre data-language="javascript">User.where(<span class="hljs-string">'age'</span>).equals(<span class="hljs-number">49</span>);

<span class="hljs-comment">// is the same as</span>

User.where(<span class="hljs-string">'age'</span>, <span class="hljs-number">49</span>);</pre> </div>
<h3 id="query_Query-error">Query.prototype.error()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">err <span class="method-type">«Error|null»</span> if set, <code>exec()</code> will fail fast before sending the query to MongoDB </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Gets/sets the error flag on this query. If this flag is not null or undefined, the <code>exec()</code> promise will reject without executing.</p> <h4>Example:</h4> <pre data-language="javascript">Query().error(); <span class="hljs-comment">// Get current error value</span>
Query().error(<span class="hljs-literal">null</span>); <span class="hljs-comment">// Unset the current error</span>
Query().error(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'test'</span>)); <span class="hljs-comment">// `exec()` will resolve with test</span>
Schema.pre(<span class="hljs-string">'find'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.getQuery().userId) {
    <span class="hljs-keyword">this</span>.error(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Not allowed to query without setting userId'</span>));
  }
});</pre> <p>Note that query casting runs <strong>after</strong> hooks, so cast errors will override custom errors.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> TestSchema = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">num</span>: <span class="hljs-built_in">Number</span> });
<span class="hljs-keyword">const</span> TestModel = db.model(<span class="hljs-string">'Test'</span>, TestSchema);
TestModel.find({ <span class="hljs-attr">num</span>: <span class="hljs-string">'not a number'</span> }).error(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'woops'</span>)).exec(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
  <span class="hljs-comment">// `error` will be a cast error because `num` failed to cast</span>
});</pre> </div>
<h3 id="query_Query-estimatedDocumentCount">Query.prototype.estimatedDocumentCount()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[options] <span class="method-type">«Object»</span> passed transparently to the <a href="http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#estimatedDocumentCount">MongoDB driver</a> </li>
<li class="param">[callback] <span class="method-type">«Function»</span> optional params are (error, count) </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Specifies this query as a <code>estimatedDocumentCount()</code> query. Faster than using <code>countDocuments()</code> for large collections because <code>estimatedDocumentCount()</code> uses collection metadata rather than scanning the entire collection.</p> <p><code>estimatedDocumentCount()</code> does <strong>not</strong> accept a filter. <code>Model.find({ foo: bar }).estimatedDocumentCount()</code> is equivalent to <code>Model.find().estimatedDocumentCount()</code></p> <p>This function triggers the following middleware.</p> <ul> <li><code>estimatedDocumentCount()</code></li> </ul> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">await</span> Model.find().estimatedDocumentCount();</pre> </div>
<h3 id="query_Query-exec">Query.prototype.exec()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[operation] <span class="method-type">«String|Function»</span> </li>
<li class="param">[callback] <span class="method-type">«Function»</span> optional params depend on the function being called </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Promise»</span> </li></ul>
<div>
<p>Executes the query</p> <h4>Examples:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> promise = query.exec();
<span class="hljs-keyword">const</span> promise = query.exec(<span class="hljs-string">'update'</span>);

query.exec(callback);
query.exec(<span class="hljs-string">'find'</span>, callback);</pre> </div>
<h3 id="query_Query-exists">Query.prototype.exists()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[path] <span class="method-type">«String»</span> </li>
<li class="param">val <span class="method-type">«Boolean»</span> </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Specifies an <code>$exists</code> condition</p> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-comment">// { name: { $exists: true }}</span>
Thing.where(<span class="hljs-string">'name'</span>).exists()
Thing.where(<span class="hljs-string">'name'</span>).exists(<span class="hljs-literal">true</span>)
Thing.find().exists(<span class="hljs-string">'name'</span>)

<span class="hljs-comment">// { name: { $exists: false }}</span>
Thing.where(<span class="hljs-string">'name'</span>).exists(<span class="hljs-literal">false</span>);
Thing.find().exists(<span class="hljs-string">'name'</span>, <span class="hljs-literal">false</span>);</pre> </div>
<h3 id="query_Query-explain">Query.prototype.explain()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">[verbose] <span class="method-type">«String»</span> The verbosity mode. Either 'queryPlanner', 'executionStats', or 'allPlansExecution'. The default is 'queryPlanner' </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Sets the <a href="https://docs.mongodb.com/manual/reference/method/cursor.explain/"><code>explain</code> option</a>, which makes this query return detailed execution stats instead of the actual query result. This method is useful for determining what index your queries use.</p> <p>Calling <code>query.explain(v)</code> is equivalent to <code>query.setOptions({ explain: v })</code></p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> query = <span class="hljs-keyword">new</span> Query();
<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> query.find({ <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> }).explain(<span class="hljs-string">'queryPlanner'</span>);
<span class="hljs-built_in">console</span>.log(res);</pre> </div>
<h3 id="query_Query-find">Query.prototype.find()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[filter] <span class="method-type">«Object|ObjectId»</span> mongodb selector. If not specified, returns all documents. </li>
<li class="param">[callback] <span class="method-type">«Function»</span> </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Find all documents that match <code>selector</code>. The result will be an array of documents.</p> <p>If there are too many documents in the result to fit in memory, use <a href="api#query_Query-cursor"><code>Query.prototype.cursor()</code></a></p> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-comment">// Using async/await</span>
<span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">await</span> Movie.find({ <span class="hljs-attr">year</span>: { <span class="hljs-attr">$gte</span>: <span class="hljs-number">1980</span>, <span class="hljs-attr">$lte</span>: <span class="hljs-number">1989</span> } });

<span class="hljs-comment">// Using callbacks</span>
Movie.find({ <span class="hljs-attr">year</span>: { <span class="hljs-attr">$gte</span>: <span class="hljs-number">1980</span>, <span class="hljs-attr">$lte</span>: <span class="hljs-number">1989</span> } }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, arr</span>) </span>{});</pre> </div>
<h3 id="query_Query-findOne">Query.prototype.findOne()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[filter] <span class="method-type">«Object»</span> mongodb selector </li>
<li class="param">[projection] <span class="method-type">«Object»</span> optional fields to return </li>
<li class="param">[options] <span class="method-type">«Object»</span> see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>setOptions()</code></a> </li>
<li class="param">[callback] <span class="method-type">«Function»</span> optional params are (error, document) </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Declares the query a findOne operation. When executed, the first found document is passed to the callback.</p> <p>Passing a <code>callback</code> executes the query. The result of the query is a single document.</p> <ul> <li>
<em>Note:</em> <code>conditions</code> is optional, and if <code>conditions</code> is null or undefined, mongoose will send an empty <code>findOne</code> command to MongoDB, which will return an arbitrary document. If you're querying by <code>_id</code>, use <code>Model.findById()</code> instead.</li> </ul> <p>This function triggers the following middleware.</p> <ul> <li><code>findOne()</code></li> </ul> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> query  = Kitten.where({ <span class="hljs-attr">color</span>: <span class="hljs-string">'white'</span> });
query.findOne(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, kitten</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
  <span class="hljs-keyword">if</span> (kitten) {
    <span class="hljs-comment">// doc may be null if no document matched</span>
  }
});</pre> </div>
<h3 id="query_Query-findOneAndDelete">Query.prototype.findOneAndDelete()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[conditions] <span class="method-type">«Object»</span> </li>
<li class="param">[options] <span class="method-type">«Object»</span> </li>
<ul style="margin-top: 0.5em"><li>[options.rawResult] <span class="method-type">«Boolean»</span> if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a> </li></ul>
<ul style="margin-top: 0.5em"><li>[options.session=null] <span class="method-type">«ClientSession»</span> The session associated with this query. See <a href="../transactions">transactions docs</a>. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.strict] <span class="method-type">«Boolean|String»</span> overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> </li></ul>
<li class="param">[callback] <span class="method-type">«Function»</span> optional params are (error, document) </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Issues a MongoDB <a href="https://docs.mongodb.com/manual/reference/method/db.collection.findOneAndDelete/">findOneAndDelete</a> command.</p> <p>Finds a matching document, removes it, and passes the found document (if any) to the callback. Executes if <code>callback</code> is passed.</p> <p>This function triggers the following middleware.</p> <ul> <li><code>findOneAndDelete()</code></li> </ul> <p>This function differs slightly from <code>Model.findOneAndRemove()</code> in that <code>findOneAndRemove()</code> becomes a <a href="https://docs.mongodb.com/manual/reference/method/db.collection.findAndModify/">MongoDB <code>findAndModify()</code> command</a>, as opposed to a <code>findOneAndDelete()</code> command. For most mongoose use cases, this distinction is purely pedantic. You should use <code>findOneAndDelete()</code> unless you have a good reason not to.</p> <h4>Available options</h4> <ul> <li>
<code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li> <li>
<code>maxTimeMS</code>: puts a time limit on the query - requires mongodb &gt;= 2.6.0</li> <li>
<code>rawResult</code>: if true, resolves to the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a>
</li> </ul> <h4>Callback Signature</h4> <pre data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, doc</span>) </span>{
  <span class="hljs-comment">// error: any errors that occurred</span>
  <span class="hljs-comment">// doc: the document before updates are applied if `new: false`, or after updates if `new = true`</span>
}</pre> <h4>Examples</h4> <pre data-language="javascript">A.where().findOneAndDelete(conditions, options, callback) <span class="hljs-comment">// executes</span>
A.where().findOneAndDelete(conditions, options)  <span class="hljs-comment">// return Query</span>
A.where().findOneAndDelete(conditions, callback) <span class="hljs-comment">// executes</span>
A.where().findOneAndDelete(conditions) <span class="hljs-comment">// returns Query</span>
A.where().findOneAndDelete(callback)   <span class="hljs-comment">// executes</span>
A.where().findOneAndDelete()           <span class="hljs-comment">// returns Query</span></pre> </div>
<h3 id="query_Query-findOneAndRemove">Query.prototype.findOneAndRemove()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[conditions] <span class="method-type">«Object»</span> </li>
<li class="param">[options] <span class="method-type">«Object»</span> </li>
<ul style="margin-top: 0.5em"><li>[options.rawResult] <span class="method-type">«Boolean»</span> if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a> </li></ul>
<ul style="margin-top: 0.5em"><li>[options.session=null] <span class="method-type">«ClientSession»</span> The session associated with this query. See <a href="../transactions">transactions docs</a>. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.strict] <span class="method-type">«Boolean|String»</span> overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> </li></ul>
<li class="param">[callback] <span class="method-type">«Function»</span> optional params are (error, document) </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Issues a mongodb <a href="http://www.mongodb.org/display/DOCS/findAndModify+Command">findAndModify</a> remove command.</p> <p>Finds a matching document, removes it, passing the found document (if any) to the callback. Executes if <code>callback</code> is passed.</p> <p>This function triggers the following middleware.</p> <ul> <li><code>findOneAndRemove()</code></li> </ul> <h4>Available options</h4> <ul> <li>
<code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li> <li>
<code>maxTimeMS</code>: puts a time limit on the query - requires mongodb &gt;= 2.6.0</li> <li>
<code>rawResult</code>: if true, resolves to the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a>
</li> </ul> <h4>Callback Signature</h4> <pre data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, doc</span>) </span>{
  <span class="hljs-comment">// error: any errors that occurred</span>
  <span class="hljs-comment">// doc: the document before updates are applied if `new: false`, or after updates if `new = true`</span>
}</pre> <h4>Examples</h4> <pre data-language="javascript">A.where().findOneAndRemove(conditions, options, callback) <span class="hljs-comment">// executes</span>
A.where().findOneAndRemove(conditions, options)  <span class="hljs-comment">// return Query</span>
A.where().findOneAndRemove(conditions, callback) <span class="hljs-comment">// executes</span>
A.where().findOneAndRemove(conditions) <span class="hljs-comment">// returns Query</span>
A.where().findOneAndRemove(callback)   <span class="hljs-comment">// executes</span>
A.where().findOneAndRemove()           <span class="hljs-comment">// returns Query</span></pre> </div>
<h3 id="query_Query-findOneAndReplace">Query.prototype.findOneAndReplace()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[filter] <span class="method-type">«Object»</span> </li>
<li class="param">[replacement] <span class="method-type">«Object»</span> </li>
<li class="param">[options] <span class="method-type">«Object»</span> </li>
<ul style="margin-top: 0.5em"><li>[options.rawResult] <span class="method-type">«Boolean»</span> if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a> </li></ul>
<ul style="margin-top: 0.5em"><li>[options.session=null] <span class="method-type">«ClientSession»</span> The session associated with this query. See <a href="../transactions">transactions docs</a>. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.strict] <span class="method-type">«Boolean|String»</span> overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> </li></ul>
<ul style="margin-top: 0.5em"><li>[options.new=false] <span class="method-type">«Boolean»</span> By default, <code>findOneAndUpdate()</code> returns the document as it was <strong>before</strong> <code>update</code> was applied. If you set <code>new: true</code>, <code>findOneAndUpdate()</code> will instead give you the object after <code>update</code> was applied. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.lean] <span class="method-type">«Object»</span> if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See <a href="https://mongoosejs.com/docs/api.html#query_Query-lean"><code>Query.lean()</code></a> and <a href="../tutorials/lean">the Mongoose lean tutorial</a>. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.session=null] <span class="method-type">«ClientSession»</span> The session associated with this query. See <a href="../transactions">transactions docs</a>. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.strict] <span class="method-type">«Boolean|String»</span> overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> </li></ul>
<ul style="margin-top: 0.5em"><li>[options.timestamps=null] <span class="method-type">«Boolean»</span> If set to <code>false</code> and <a href="../guide#timestamps">schema-level timestamps</a> are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.returnOriginal=null] <span class="method-type">«Boolean»</span> An alias for the <code>new</code> option. <code>returnOriginal: false</code> is equivalent to <code>new: true</code>. </li></ul>
<li class="param">[callback] <span class="method-type">«Function»</span> optional params are (error, document) </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Issues a MongoDB <a href="https://docs.mongodb.com/manual/reference/method/db.collection.findOneAndReplace/">findOneAndReplace</a> command.</p> <p>Finds a matching document, removes it, and passes the found document (if any) to the callback. Executes if <code>callback</code> is passed.</p> <p>This function triggers the following middleware.</p> <ul> <li><code>findOneAndReplace()</code></li> </ul> <h4>Available options</h4> <ul> <li>
<code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li> <li>
<code>maxTimeMS</code>: puts a time limit on the query - requires mongodb &gt;= 2.6.0</li> <li>
<code>rawResult</code>: if true, resolves to the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a>
</li> </ul> <h4>Callback Signature</h4> <pre data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, doc</span>) </span>{
  <span class="hljs-comment">// error: any errors that occurred</span>
  <span class="hljs-comment">// doc: the document before updates are applied if `new: false`, or after updates if `new = true`</span>
}</pre> <h4>Examples</h4> <pre data-language="javascript">A.where().findOneAndReplace(filter, replacement, options, callback); <span class="hljs-comment">// executes</span>
A.where().findOneAndReplace(filter, replacement, options); <span class="hljs-comment">// return Query</span>
A.where().findOneAndReplace(filter, replacement, callback); <span class="hljs-comment">// executes</span>
A.where().findOneAndReplace(filter); <span class="hljs-comment">// returns Query</span>
A.where().findOneAndReplace(callback); <span class="hljs-comment">// executes</span>
A.where().findOneAndReplace(); <span class="hljs-comment">// returns Query</span></pre> </div>
<h3 id="query_Query-findOneAndUpdate">Query.prototype.findOneAndUpdate()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[filter] <span class="method-type">«Object|Query»</span> </li>
<li class="param">[doc] <span class="method-type">«Object»</span> </li>
<li class="param">[options] <span class="method-type">«Object»</span> </li>
<ul style="margin-top: 0.5em"><li>[options.rawResult] <span class="method-type">«Boolean»</span> if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a> </li></ul>
<ul style="margin-top: 0.5em"><li>[options.strict] <span class="method-type">«Boolean|String»</span> overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> </li></ul>
<ul style="margin-top: 0.5em"><li>[options.session=null] <span class="method-type">«ClientSession»</span> The session associated with this query. See <a href="../transactions">transactions docs</a>. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.multipleCastError] <span class="method-type">«Boolean»</span> by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.new=false] <span class="method-type">«Boolean»</span> By default, <code>findOneAndUpdate()</code> returns the document as it was <strong>before</strong> <code>update</code> was applied. If you set <code>new: true</code>, <code>findOneAndUpdate()</code> will instead give you the object after <code>update</code> was applied. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.lean] <span class="method-type">«Object»</span> if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See <a href="https://mongoosejs.com/docs/api.html#query_Query-lean"><code>Query.lean()</code></a> and <a href="../tutorials/lean">the Mongoose lean tutorial</a>. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.session=null] <span class="method-type">«ClientSession»</span> The session associated with this query. See <a href="../transactions">transactions docs</a>. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.strict] <span class="method-type">«Boolean|String»</span> overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> </li></ul>
<ul style="margin-top: 0.5em"><li>[options.timestamps=null] <span class="method-type">«Boolean»</span> If set to <code>false</code> and <a href="../guide#timestamps">schema-level timestamps</a> are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.returnOriginal=null] <span class="method-type">«Boolean»</span> An alias for the <code>new</code> option. <code>returnOriginal: false</code> is equivalent to <code>new: true</code>. </li></ul>
<li class="param">[callback] <span class="method-type">«Function»</span> optional params are (error, doc), <em>unless</em> <code>rawResult</code> is used, in which case params are (error, writeOpResult) </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Issues a mongodb <a href="http://www.mongodb.org/display/DOCS/findAndModify+Command">findAndModify</a> update command.</p> <p>Finds a matching document, updates it according to the <code>update</code> arg, passing any <code>options</code>, and returns the found document (if any) to the callback. The query executes if <code>callback</code> is passed.</p> <p>This function triggers the following middleware.</p> <ul> <li><code>findOneAndUpdate()</code></li> </ul> <h4>Available options</h4> <ul> <li>
<code>new</code>: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)</li> <li>
<code>upsert</code>: bool - creates the object if it doesn't exist. defaults to false.</li> <li>
<code>fields</code>: {Object|String} - Field selection. Equivalent to <code>.select(fields).findOneAndUpdate()</code>
</li> <li>
<code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li> <li>
<code>maxTimeMS</code>: puts a time limit on the query - requires mongodb &gt;= 2.6.0</li> <li>
<code>runValidators</code>: if true, runs <a href="../validation#update-validators">update validators</a> on this command. Update validators validate the update operation against the model's schema.</li> <li>
<code>setDefaultsOnInsert</code>: <code>true</code> by default. If <code>setDefaultsOnInsert</code> and <code>upsert</code> are true, mongoose will apply the <a href="http://mongoosejs.com/docs/defaults.html">defaults</a> specified in the model's schema if a new document is created.</li> <li>
<code>rawResult</code>: if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a>
</li> </ul> <h4>Callback Signature</h4> <pre data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, doc</span>) </span>{
  <span class="hljs-comment">// error: any errors that occurred</span>
  <span class="hljs-comment">// doc: the document before updates are applied if `new: false`, or after updates if `new = true`</span>
}</pre> <h4>Examples</h4> <pre data-language="javascript">query.findOneAndUpdate(conditions, update, options, callback) <span class="hljs-comment">// executes</span>
query.findOneAndUpdate(conditions, update, options)  <span class="hljs-comment">// returns Query</span>
query.findOneAndUpdate(conditions, update, callback) <span class="hljs-comment">// executes</span>
query.findOneAndUpdate(conditions, update)           <span class="hljs-comment">// returns Query</span>
query.findOneAndUpdate(update, callback)             <span class="hljs-comment">// returns Query</span>
query.findOneAndUpdate(update)                       <span class="hljs-comment">// returns Query</span>
query.findOneAndUpdate(callback)                     <span class="hljs-comment">// executes</span>
query.findOneAndUpdate()                             <span class="hljs-comment">// returns Query</span></pre> </div>
<h3 id="query_Query-geometry">Query.prototype.geometry()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">object <span class="method-type">«Object»</span> Must contain a <code>type</code> property which is a String and a <code>coordinates</code> property which is an Array. See the examples. </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Specifies a <code>$geometry</code> condition</p> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> polyA = [[[ <span class="hljs-number">10</span>, <span class="hljs-number">20</span> ], [ <span class="hljs-number">10</span>, <span class="hljs-number">40</span> ], [ <span class="hljs-number">30</span>, <span class="hljs-number">40</span> ], [ <span class="hljs-number">30</span>, <span class="hljs-number">20</span> ]]]
query.where(<span class="hljs-string">'loc'</span>).within().geometry({ <span class="hljs-attr">type</span>: <span class="hljs-string">'Polygon'</span>, <span class="hljs-attr">coordinates</span>: polyA })

<span class="hljs-comment">// or</span>
<span class="hljs-keyword">const</span> polyB = [[ <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ], [ <span class="hljs-number">1</span>, <span class="hljs-number">1</span> ]]
query.where(<span class="hljs-string">'loc'</span>).within().geometry({ <span class="hljs-attr">type</span>: <span class="hljs-string">'LineString'</span>, <span class="hljs-attr">coordinates</span>: polyB })

<span class="hljs-comment">// or</span>
<span class="hljs-keyword">const</span> polyC = [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ]
query.where(<span class="hljs-string">'loc'</span>).within().geometry({ <span class="hljs-attr">type</span>: <span class="hljs-string">'Point'</span>, <span class="hljs-attr">coordinates</span>: polyC })

<span class="hljs-comment">// or</span>
query.where(<span class="hljs-string">'loc'</span>).intersects().geometry({ <span class="hljs-attr">type</span>: <span class="hljs-string">'Point'</span>, <span class="hljs-attr">coordinates</span>: polyC })</pre> <p>The argument is assigned to the most recent path passed to <code>where()</code>.</p> <h4>NOTE:</h4> <p><code>geometry()</code> <strong>must</strong> come after either <code>intersects()</code> or <code>within()</code>.</p> <p>The <code>object</code> argument must contain <code>type</code> and <code>coordinates</code> properties. - type {String} - coordinates {Array}</p> </div>
<h3 id="query_Query-get">Query.prototype.get()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">path <span class="method-type">«String|Object»</span> path or object of key/value pairs to get </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>For update operations, returns the value of a path in the update's <code>$set</code>. Useful for writing getters/setters that can work with both update operations and <code>save()</code>.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> query = Model.updateOne({}, { <span class="hljs-attr">$set</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">'Jean-Luc Picard'</span> } });
query.get(<span class="hljs-string">'name'</span>); <span class="hljs-comment">// 'Jean-Luc Picard'</span></pre> </div>
<h3 id="query_Query-getFilter">Query.prototype.getFilter()</h3>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Object»</span> current query filter </li></ul>
<div>
<p>Returns the current query filter (also known as conditions) as a <a href="https://masteringjs.io/tutorials/fundamentals/pojo">POJO</a>.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> query = <span class="hljs-keyword">new</span> Query();
query.find({ <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> }).where(<span class="hljs-string">'b'</span>).gt(<span class="hljs-number">2</span>);
query.getFilter(); <span class="hljs-comment">// { a: 1, b: { $gt: 2 } }</span></pre> </div>
<h3 id="query_Query-getOptions">Query.prototype.getOptions()</h3>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Object»</span> the options </li></ul>
<div>
<p>Gets query options.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> query = <span class="hljs-keyword">new</span> Query();
query.limit(<span class="hljs-number">10</span>);
query.setOptions({ <span class="hljs-attr">maxTimeMS</span>: <span class="hljs-number">1000</span> })
query.getOptions(); <span class="hljs-comment">// { limit: 10, maxTimeMS: 1000 }</span></pre> </div>
<h3 id="query_Query-getPopulatedPaths">Query.prototype.getPopulatedPaths()</h3>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Array»</span> an array of strings representing populated paths </li></ul>
<div>
<p>Gets a list of paths to be populated by this query</p> <h4>Example:</h4> <pre data-language="javascript">bookSchema.pre(<span class="hljs-string">'findOne'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
   <span class="hljs-keyword">let</span> keys = <span class="hljs-keyword">this</span>.getPopulatedPaths(); <span class="hljs-comment">// ['author']</span>
 });
 ...
 Book.findOne({}).populate(<span class="hljs-string">'author'</span>);</pre> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-comment">// Deep populate</span>
 <span class="hljs-keyword">const</span> q = L1.find().populate({
   <span class="hljs-attr">path</span>: <span class="hljs-string">'level2'</span>,
   <span class="hljs-attr">populate</span>: { <span class="hljs-attr">path</span>: <span class="hljs-string">'level3'</span> }
 });
 q.getPopulatedPaths(); <span class="hljs-comment">// ['level2', 'level2.level3']</span></pre> </div>
<h3 id="query_Query-getQuery">Query.prototype.getQuery()</h3>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Object»</span> current query filter </li></ul>
<div>
<p>Returns the current query filter. Equivalent to <code>getFilter()</code>.</p> <p>You should use <code>getFilter()</code> instead of <code>getQuery()</code> where possible. <code>getQuery()</code> will likely be deprecated in a future release.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> query = <span class="hljs-keyword">new</span> Query();
query.find({ <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> }).where(<span class="hljs-string">'b'</span>).gt(<span class="hljs-number">2</span>);
query.getQuery(); <span class="hljs-comment">// { a: 1, b: { $gt: 2 } }</span></pre> </div>
<h3 id="query_Query-getUpdate">Query.prototype.getUpdate()</h3>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Object»</span> current update operations </li></ul>
<div>
<p>Returns the current update operations as a JSON object.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> query = <span class="hljs-keyword">new</span> Query();
query.update({}, { <span class="hljs-attr">$set</span>: { <span class="hljs-attr">a</span>: <span class="hljs-number">5</span> } });
query.getUpdate(); <span class="hljs-comment">// { $set: { a: 5 } }</span></pre> </div>
<h3 id="query_Query-gt">Query.prototype.gt()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[path] <span class="method-type">«String»</span> </li>
<li class="param">val <span class="method-type">«Number»</span> </li>
</ul>
<div>
<p>Specifies a <code>$gt</code> query condition.</p> <p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p> <h4>Example</h4> <pre data-language="javascript">Thing.find().where(<span class="hljs-string">'age'</span>).gt(<span class="hljs-number">21</span>)

<span class="hljs-comment">// or</span>
Thing.find().gt(<span class="hljs-string">'age'</span>, <span class="hljs-number">21</span>)</pre> </div>
<h3 id="query_Query-gte">Query.prototype.gte()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[path] <span class="method-type">«String»</span> </li>
<li class="param">val <span class="method-type">«Number»</span> </li>
</ul>
<div>
<p>Specifies a <code>$gte</code> query condition.</p> <p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p> </div>
<h3 id="query_Query-hint">Query.prototype.hint()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">val <span class="method-type">«Object»</span> a hint object </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Sets query hints.</p> <h4>Example</h4> <pre data-language="javascript">query.hint({ <span class="hljs-attr">indexA</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">indexB</span>: <span class="hljs-number">-1</span>})</pre> <h4>Note</h4> <p>Cannot be used with <code>distinct()</code></p> </div>
<h3 id="query_Query-in">Query.prototype.in()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[path] <span class="method-type">«String»</span> </li>
<li class="param">val <span class="method-type">«Array»</span> </li>
</ul>
<div>
<p>Specifies an <code>$in</code> query condition.</p> <p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p> </div>
<h3 id="query_Query-intersects">Query.prototype.intersects()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">[arg] <span class="method-type">«Object»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Declares an intersects query for <code>geometry()</code>.</p> <h4>Example</h4> <pre data-language="javascript">query.where(<span class="hljs-string">'path'</span>).intersects().geometry({
    <span class="hljs-attr">type</span>: <span class="hljs-string">'LineString'</span>
  , <span class="hljs-attr">coordinates</span>: [[<span class="hljs-number">180.0</span>, <span class="hljs-number">11.0</span>], [<span class="hljs-number">180</span>, <span class="hljs-number">9.0</span>]]
})

query.where(<span class="hljs-string">'path'</span>).intersects({
    <span class="hljs-attr">type</span>: <span class="hljs-string">'LineString'</span>
  , <span class="hljs-attr">coordinates</span>: [[<span class="hljs-number">180.0</span>, <span class="hljs-number">11.0</span>], [<span class="hljs-number">180</span>, <span class="hljs-number">9.0</span>]]
})</pre> <h4>NOTE:</h4> <p><strong>MUST</strong> be used after <code>where()</code>.</p> <h4>NOTE:</h4> <p>In Mongoose 3.7, <code>intersects</code> changed from a getter to a function. If you need the old syntax, use <a href="https://github.com/ebensing/mongoose-within">this</a>.</p> </div>
<h3 id="query_Query-j">Query.prototype.j()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">val <span class="method-type">«boolean»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Requests acknowledgement that this operation has been persisted to MongoDB's on-disk journal.</p> <h2>This option is only valid for operations that write to the database</h2> <ul> <li><code>deleteOne()</code></li> <li><code>deleteMany()</code></li> <li><code>findOneAndDelete()</code></li> <li><code>findOneAndReplace()</code></li> <li><code>findOneAndUpdate()</code></li> <li><code>remove()</code></li> <li><code>update()</code></li> <li><code>updateOne()</code></li> <li><code>updateMany()</code></li> </ul> <p>Defaults to the schema's <a href="../guide#writeConcern"><code>writeConcern.j</code> option</a></p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">await</span> mongoose.model(<span class="hljs-string">'Person'</span>).deleteOne({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Ned Stark'</span> }).j(<span class="hljs-literal">true</span>);</pre> </div>
<h3 id="query_Query-lean">Query.prototype.lean()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">bool <span class="method-type">«Boolean|Object»</span> defaults to true </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Sets the lean option.</p> <p>Documents returned from queries with the <code>lean</code> option enabled are plain javascript objects, not <a href="https://mongoosejs.com/api/document.html">Mongoose Documents</a>. They have no <code>save</code> method, getters/setters, virtuals, or other Mongoose features.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">new</span> Query().lean() <span class="hljs-comment">// true</span>
<span class="hljs-keyword">new</span> Query().lean(<span class="hljs-literal">true</span>)
<span class="hljs-keyword">new</span> Query().lean(<span class="hljs-literal">false</span>)

<span class="hljs-keyword">const</span> docs = <span class="hljs-keyword">await</span> Model.find().lean();
docs[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> mongoose.Document; <span class="hljs-comment">// false</span></pre> <p><a href="../tutorials/lean">Lean is great for high-performance, read-only cases</a>, especially when combined with <a href="../queries#streaming">cursors</a>.</p> <p>If you need virtuals, getters/setters, or defaults with <code>lean()</code>, you need to use a plugin. See:</p> <ul> <li><a href="https://plugins.mongoosejs.io/plugins/lean-virtuals">mongoose-lean-virtuals</a></li> <li><a href="https://plugins.mongoosejs.io/plugins/lean-getters">mongoose-lean-getters</a></li> <li><a href="https://www.npmjs.com/package/mongoose-lean-defaults">mongoose-lean-defaults</a></li> </ul> </div>
<h3 id="query_Query-limit">Query.prototype.limit()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">val <span class="method-type">«Number»</span> </li></ul>
<div>
<p>Specifies the maximum number of documents the query will return.</p> <h4>Example</h4> <pre data-language="javascript">query.limit(<span class="hljs-number">20</span>)</pre> <h4>Note</h4> <p>Cannot be used with <code>distinct()</code></p> </div>
<h3 id="query_Query-lt">Query.prototype.lt()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[path] <span class="method-type">«String»</span> </li>
<li class="param">val <span class="method-type">«Number»</span> </li>
</ul>
<div>
<p>Specifies a <code>$lt</code> query condition.</p> <p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p> </div>
<h3 id="query_Query-lte">Query.prototype.lte()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[path] <span class="method-type">«String»</span> </li>
<li class="param">val <span class="method-type">«Number»</span> </li>
</ul>
<div>
<p>Specifies a <code>$lte</code> query condition.</p> <p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p> </div>
<h3 id="query_Query-maxDistance">Query.prototype.maxDistance()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[path] <span class="method-type">«String»</span> </li>
<li class="param">val <span class="method-type">«Number»</span> </li>
</ul>
<div>
<p>Specifies a <code>maxDistance</code> query condition.</p> <p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p> </div>
<h3 id="query_Query-maxScan">Query.prototype.maxScan()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">val <span class="method-type">«Number»</span> </li></ul>
<div>
<p>Specifies the maxScan option.</p> <h4>Example</h4> <pre data-language="javascript">query.maxScan(<span class="hljs-number">100</span>)</pre> <h4>Note</h4> <p>Cannot be used with <code>distinct()</code></p> </div>
<h3 id="query_Query-maxTimeMS">Query.prototype.maxTimeMS()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">[ms] <span class="method-type">«Number»</span> The number of milliseconds </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Sets the <a href="https://docs.mongodb.com/manual/reference/method/cursor.maxTimeMS/">maxTimeMS</a> option. This will tell the MongoDB server to abort if the query or write op has been running for more than <code>ms</code> milliseconds.</p> <p>Calling <code>query.maxTimeMS(v)</code> is equivalent to <code>query.setOptions({ maxTimeMS: v })</code></p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> query = <span class="hljs-keyword">new</span> Query();
<span class="hljs-comment">// Throws an error 'operation exceeded time limit' as long as there's</span>
<span class="hljs-comment">// &gt;= 1 doc in the queried collection</span>
<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> query.find({ <span class="hljs-attr">$where</span>: <span class="hljs-string">'sleep(1000) || true'</span> }).maxTimeMS(<span class="hljs-number">100</span>);</pre> </div>
<h3 id="query_Query-maxscan">Query.prototype.maxscan()</h3>
<div>
<p><em>DEPRECATED</em> Alias of <code>maxScan</code></p> </div>
<h3 id="query_Query-merge">Query.prototype.merge()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">source <span class="method-type">«Query|Object»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Merges another Query or conditions object into this one.</p> <p>When a Query is passed, conditions, field selection and options are merged.</p> </div>
<h3 id="query_Query-mod">Query.prototype.mod()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[path] <span class="method-type">«String»</span> </li>
<li class="param">val <span class="method-type">«Array»</span> must be of length 2, first element is <code>divisor</code>, 2nd element is <code>remainder</code>. </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Specifies a <code>$mod</code> condition, filters documents for documents whose <code>path</code> property is a number that is equal to <code>remainder</code> modulo <code>divisor</code>.</p> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-comment">// All find products whose inventory is odd</span>
Product.find().mod(<span class="hljs-string">'inventory'</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]);
Product.find().where(<span class="hljs-string">'inventory'</span>).mod([<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]);
<span class="hljs-comment">// This syntax is a little strange, but supported.</span>
Product.find().where(<span class="hljs-string">'inventory'</span>).mod(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);</pre> </div>
<h3 id="query_Query-model">Query.prototype.model</h3>
<h5>Type:</h5>
<ul><li><span class="method-type">«property»</span></li></ul>
<div>
<p>The model this query is associated with.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> q = MyModel.find();
q.model === MyModel; <span class="hljs-comment">// true</span></pre> </div>
<h3 id="query_Query-mongooseOptions">Query.prototype.mongooseOptions()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">options <span class="method-type">«Object»</span> if specified, overwrites the current options </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Object»</span> the options </li></ul>
<div>
<p>Getter/setter around the current mongoose-specific options for this query Below are the current Mongoose-specific options.</p> <ul> <li>
<code>populate</code>: an array representing what paths will be populated. Should have one entry for each call to <a href="https://mongoosejs.com/docs/api.html#query_Query-populate"><code>Query.prototype.populate()</code></a>
</li> <li>
<code>lean</code>: if truthy, Mongoose will not <a href="https://mongoosejs.com/docs/api.html#model_Model.hydrate">hydrate</a> any documents that are returned from this query. See <a href="https://mongoosejs.com/docs/api.html#query_Query-lean"><code>Query.prototype.lean()</code></a> for more information.</li> <li>
<code>strict</code>: controls how Mongoose handles keys that aren't in the schema for updates. This option is <code>true</code> by default, which means Mongoose will silently strip any paths in the update that aren't in the schema. See the <a href="../guide#strict"><code>strict</code> mode docs</a> for more information.</li> <li>
<code>strictQuery</code>: controls how Mongoose handles keys that aren't in the schema for the query <code>filter</code>. This option is <code>false</code> by default for backwards compatibility, which means Mongoose will allow <code>Model.find({ foo: 'bar' })</code> even if <code>foo</code> is not in the schema. See the <a href="../guide#strictQuery"><code>strictQuery</code> docs</a> for more information.</li> <li>
<code>nearSphere</code>: use <code>$nearSphere</code> instead of <code>near()</code>. See the <a href="https://mongoosejs.com/docs/api.html#query_Query-nearSphere"><code>Query.prototype.nearSphere()</code> docs</a>
</li> </ul> <p>Mongoose maintains a separate object for internal options because Mongoose sends <code>Query.prototype.options</code> to the MongoDB server, and the above options are not relevant for the MongoDB server.</p> </div>
<h3 id="query_Query-ne">Query.prototype.ne()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[path] <span class="method-type">«String»</span> </li>
<li class="param">val <span class="method-type">«any»</span> </li>
</ul>
<div>
<p>Specifies a <code>$ne</code> query condition.</p> <p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p> </div>
<h3 id="query_Query-near">Query.prototype.near()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[path] <span class="method-type">«String»</span> </li>
<li class="param">val <span class="method-type">«Object»</span> </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Specifies a <code>$near</code> or <code>$nearSphere</code> condition</p> <p>These operators return documents sorted by distance.</p> <h4>Example</h4> <pre data-language="javascript">query.where(<span class="hljs-string">'loc'</span>).near({ <span class="hljs-attr">center</span>: [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>] });
query.where(<span class="hljs-string">'loc'</span>).near({ <span class="hljs-attr">center</span>: [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>], <span class="hljs-attr">maxDistance</span>: <span class="hljs-number">5</span> });
query.where(<span class="hljs-string">'loc'</span>).near({ <span class="hljs-attr">center</span>: [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>], <span class="hljs-attr">maxDistance</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">spherical</span>: <span class="hljs-literal">true</span> });
query.near(<span class="hljs-string">'loc'</span>, { <span class="hljs-attr">center</span>: [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>], <span class="hljs-attr">maxDistance</span>: <span class="hljs-number">5</span> });</pre> </div>
<h3 id="query_Query-nearSphere">Query.prototype.nearSphere()</h3>
<div>
<p><em>DEPRECATED</em> Specifies a <code>$nearSphere</code> condition</p> <h4>Example</h4> <pre data-language="javascript">query.where(<span class="hljs-string">'loc'</span>).nearSphere({ <span class="hljs-attr">center</span>: [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>], <span class="hljs-attr">maxDistance</span>: <span class="hljs-number">5</span> });</pre> <p><strong>Deprecated.</strong> Use <code>query.near()</code> instead with the <code>spherical</code> option set to <code>true</code>.</p> <h4>Example</h4> <pre data-language="javascript">query.where(<span class="hljs-string">'loc'</span>).near({ <span class="hljs-attr">center</span>: [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>], <span class="hljs-attr">spherical</span>: <span class="hljs-literal">true</span> });</pre> </div>
<h3 id="query_Query-nin">Query.prototype.nin()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[path] <span class="method-type">«String»</span> </li>
<li class="param">val <span class="method-type">«Array»</span> </li>
</ul>
<div>
<p>Specifies an <code>$nin</code> query condition.</p> <p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p> </div>
<h3 id="query_Query-nor">Query.prototype.nor()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">array <span class="method-type">«Array»</span> array of conditions </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Specifies arguments for a <code>$nor</code> condition.</p> <h4>Example</h4> <pre data-language="javascript">query.nor([{ <span class="hljs-attr">color</span>: <span class="hljs-string">'green'</span> }, { <span class="hljs-attr">status</span>: <span class="hljs-string">'ok'</span> }])</pre> </div>
<h3 id="query_Query-or">Query.prototype.or()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">array <span class="method-type">«Array»</span> array of conditions </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Specifies arguments for an <code>$or</code> condition.</p> <h4>Example</h4> <pre data-language="javascript">query.or([{ <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span> }, { <span class="hljs-attr">status</span>: <span class="hljs-string">'emergency'</span> }])</pre> </div>
<h3 id="query_Query-orFail">Query.prototype.orFail()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">[err] <span class="method-type">«Function|Error»</span> optional error to throw if no docs match <code>filter</code>. If not specified, <code>orFail()</code> will throw a <code>DocumentNotFoundError</code> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Make this query throw an error if no documents match the given <code>filter</code>. This is handy for integrating with async/await, because <code>orFail()</code> saves you an extra <code>if</code> statement to check if no document was found.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-comment">// Throws if no doc returned</span>
<span class="hljs-keyword">await</span> Model.findOne({ <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> }).orFail();

<span class="hljs-comment">// Throws if no document was updated</span>
<span class="hljs-keyword">await</span> Model.updateOne({ <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">'test'</span> }).orFail();

<span class="hljs-comment">// Throws "No docs found!" error if no docs match `{ foo: 'bar' }`</span>
<span class="hljs-keyword">await</span> Model.find({ <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> }).orFail(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'No docs found!'</span>));

<span class="hljs-comment">// Throws "Not found" error if no document was found</span>
<span class="hljs-keyword">await</span> Model.findOneAndUpdate({ <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">'test'</span> }).
  orFail(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Not found'</span>));</pre> </div>
<h3 id="query_Query-polygon">Query.prototype.polygon()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[path] <span class="method-type">«String|Array»</span> </li>
<ul style="margin-top: 0.5em"><li>[coordinatePairs...] <span class="method-type">«Array|Object»</span> </li></ul>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Specifies a <code>$polygon</code> condition</p> <h4>Example</h4> <pre data-language="javascript">query.where(<span class="hljs-string">'loc'</span>).within().polygon([<span class="hljs-number">10</span>,<span class="hljs-number">20</span>], [<span class="hljs-number">13</span>, <span class="hljs-number">25</span>], [<span class="hljs-number">7</span>,<span class="hljs-number">15</span>])
query.polygon(<span class="hljs-string">'loc'</span>, [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>], [<span class="hljs-number">13</span>, <span class="hljs-number">25</span>], [<span class="hljs-number">7</span>,<span class="hljs-number">15</span>])</pre> </div>
<h3 id="query_Query-populate">Query.prototype.populate()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">path <span class="method-type">«Object|String»</span> either the path to populate or an object specifying all parameters </li>
<li class="param">[select] <span class="method-type">«Object|String»</span> Field selection for the population query </li>
<li class="param">[model] <span class="method-type">«Model»</span> The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's <code>ref</code> field. </li>
<li class="param">[match] <span class="method-type">«Object»</span> Conditions for the population query </li>
<li class="param">[options] <span class="method-type">«Object»</span> Options for the population query (sort, etc) </li>
<ul style="margin-top: 0.5em"><li>[options.path=null] <span class="method-type">«String»</span> The path to populate. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.retainNullValues=false] <span class="method-type">«boolean»</span> by default, Mongoose removes null and undefined values from populated arrays. Use this option to make <code>populate()</code> retain <code>null</code> and <code>undefined</code> array entries. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.getters=false] <span class="method-type">«boolean»</span> if true, Mongoose will call any getters defined on the <code>localField</code>. By default, Mongoose gets the raw value of <code>localField</code>. For example, you would need to set this option to <code>true</code> if you wanted to <a href="../schematypes#schematype-options">add a <code>lowercase</code> getter to your <code>localField</code></a>. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.clone=false] <span class="method-type">«boolean»</span> When you do <code>BlogPost.find().populate('author')</code>, blog posts with the same author will share 1 copy of an <code>author</code> doc. Enable this option to make Mongoose clone populated docs before assigning them. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.match=null] <span class="method-type">«Object|Function»</span> Add an additional filter to the populate query. Can be a filter object containing <a href="https://docs.mongodb.com/manual/tutorial/query-documents/">MongoDB query syntax</a>, or a function that returns a filter object. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.transform=null] <span class="method-type">«Function»</span> Function that Mongoose will call on every populated document that allows you to transform the populated document. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.options=null] <span class="method-type">«Object»</span> Additional options like <code>limit</code> and <code>lean</code>. </li></ul>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Specifies paths which should be populated with other documents.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">let</span> book = <span class="hljs-keyword">await</span> Book.findOne().populate(<span class="hljs-string">'authors'</span>);
book.title; <span class="hljs-comment">// 'Node.js in Action'</span>
book.authors[<span class="hljs-number">0</span>].name; <span class="hljs-comment">// 'TJ Holowaychuk'</span>
book.authors[<span class="hljs-number">1</span>].name; <span class="hljs-comment">// 'Nathan Rajlich'</span>

<span class="hljs-keyword">let</span> books = <span class="hljs-keyword">await</span> Book.find().populate({
  <span class="hljs-attr">path</span>: <span class="hljs-string">'authors'</span>,
  <span class="hljs-comment">// `match` and `sort` apply to the Author model,</span>
  <span class="hljs-comment">// not the Book model. These options do not affect</span>
  <span class="hljs-comment">// which documents are in `books`, just the order and</span>
  <span class="hljs-comment">// contents of each book document's `authors`.</span>
  <span class="hljs-attr">match</span>: { <span class="hljs-attr">name</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'.*h.*'</span>, <span class="hljs-string">'i'</span>) },
  <span class="hljs-attr">sort</span>: { <span class="hljs-attr">name</span>: <span class="hljs-number">-1</span> }
});
books[<span class="hljs-number">0</span>].title; <span class="hljs-comment">// 'Node.js in Action'</span>
<span class="hljs-comment">// Each book's `authors` are sorted by name, descending.</span>
books[<span class="hljs-number">0</span>].authors[<span class="hljs-number">0</span>].name; <span class="hljs-comment">// 'TJ Holowaychuk'</span>
books[<span class="hljs-number">0</span>].authors[<span class="hljs-number">1</span>].name; <span class="hljs-comment">// 'Marc Harter'</span>

books[<span class="hljs-number">1</span>].title; <span class="hljs-comment">// 'Professional AngularJS'</span>
<span class="hljs-comment">// Empty array, no authors' name has the letter 'h'</span>
books[<span class="hljs-number">1</span>].authors; <span class="hljs-comment">// []</span></pre> <p>Paths are populated after the query executes and a response is received. A separate query is then executed for each path specified for population. After a response for each query has also been returned, the results are passed to the callback.</p> </div>
<h3 id="query_Query-post">Query.prototype.post()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">fn <span class="method-type">«Function»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Promise»</span> </li></ul>
<div>
<p>Add post <a href="../middleware">middleware</a> to this query instance. Doesn't affect other queries.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> q1 = Question.find({ <span class="hljs-attr">answer</span>: <span class="hljs-number">42</span> });
q1.post(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">middleware</span>() </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.getFilter());
});
<span class="hljs-keyword">await</span> q1.exec(); <span class="hljs-comment">// Prints "{ answer: 42 }"</span>

<span class="hljs-comment">// Doesn't print anything, because `middleware()` is only</span>
<span class="hljs-comment">// registered on `q1`.</span>
<span class="hljs-keyword">await</span> Question.find({ <span class="hljs-attr">answer</span>: <span class="hljs-number">42</span> });</pre> </div>
<h3 id="query_Query-pre">Query.prototype.pre()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">fn <span class="method-type">«Function»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Promise»</span> </li></ul>
<div>
<p>Add pre <a href="../middleware">middleware</a> to this query instance. Doesn't affect other queries.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> q1 = Question.find({ <span class="hljs-attr">answer</span>: <span class="hljs-number">42</span> });
q1.pre(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">middleware</span>() </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.getFilter());
});
<span class="hljs-keyword">await</span> q1.exec(); <span class="hljs-comment">// Prints "{ answer: 42 }"</span>

<span class="hljs-comment">// Doesn't print anything, because `middleware()` is only</span>
<span class="hljs-comment">// registered on `q1`.</span>
<span class="hljs-keyword">await</span> Question.find({ <span class="hljs-attr">answer</span>: <span class="hljs-number">42</span> });</pre> </div>
<h3 id="query_Query-projection">Query.prototype.projection()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">arg <span class="method-type">«Object|null»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Object»</span> the current projection </li></ul>
<div>
<p>Get/set the current projection (AKA fields). Pass <code>null</code> to remove the current projection.</p> <p>Unlike <code>projection()</code>, the <code>select()</code> function modifies the current projection in place. This function overwrites the existing projection.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> q = Model.find();
q.projection(); <span class="hljs-comment">// null</span>

q.select(<span class="hljs-string">'a b'</span>);
q.projection(); <span class="hljs-comment">// { a: 1, b: 1 }</span>

q.projection({ <span class="hljs-attr">c</span>: <span class="hljs-number">1</span> });
q.projection(); <span class="hljs-comment">// { c: 1 }</span>

q.projection(<span class="hljs-literal">null</span>);
q.projection(); <span class="hljs-comment">// null</span></pre> </div>
<h3 id="query_Query-read">Query.prototype.read()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">pref <span class="method-type">«String»</span> one of the listed preference options or aliases </li>
<li class="param">[tags] <span class="method-type">«Array»</span> optional tags for this query </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Determines the MongoDB nodes from which to read.</p> <h4>Preferences:</h4> <pre data-language="javascript">primary - (<span class="hljs-keyword">default</span>) Read <span class="hljs-keyword">from</span> primary only. Operations will produce an error <span class="hljs-keyword">if</span> primary is unavailable. Cannot be combined <span class="hljs-keyword">with</span> tags.
secondary            Read <span class="hljs-keyword">from</span> secondary <span class="hljs-keyword">if</span> available, otherwise error.
primaryPreferred     Read <span class="hljs-keyword">from</span> primary <span class="hljs-keyword">if</span> available, otherwise a secondary.
secondaryPreferred   Read <span class="hljs-keyword">from</span> a secondary <span class="hljs-keyword">if</span> available, otherwise read <span class="hljs-keyword">from</span> the primary.
nearest              All operations read <span class="hljs-keyword">from</span> among the nearest candidates, but unlike other modes, <span class="hljs-keyword">this</span> option will include both the primary and all secondaries <span class="hljs-keyword">in</span> the random selection.</pre> <p>Aliases</p> <pre data-language="javascript">p   primary
pp  primaryPreferred
s   secondary
sp  secondaryPreferred
n   nearest</pre> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'primary'</span>)
<span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'p'</span>)  <span class="hljs-comment">// same as primary</span>

<span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'primaryPreferred'</span>)
<span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'pp'</span>) <span class="hljs-comment">// same as primaryPreferred</span>

<span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'secondary'</span>)
<span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'s'</span>)  <span class="hljs-comment">// same as secondary</span>

<span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'secondaryPreferred'</span>)
<span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'sp'</span>) <span class="hljs-comment">// same as secondaryPreferred</span>

<span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'nearest'</span>)
<span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'n'</span>)  <span class="hljs-comment">// same as nearest</span>

<span class="hljs-comment">// read from secondaries with matching tags</span>
<span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'s'</span>, [{ <span class="hljs-attr">dc</span>:<span class="hljs-string">'sf'</span>, <span class="hljs-attr">s</span>: <span class="hljs-number">1</span> },{ <span class="hljs-attr">dc</span>:<span class="hljs-string">'ma'</span>, <span class="hljs-attr">s</span>: <span class="hljs-number">2</span> }])</pre> <p>Read more about how to use read preferences <a href="http://docs.mongodb.org/manual/applications/replication/#read-preference">here</a> and <a href="http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences">here</a>.</p> </div>
<h3 id="query_Query-readConcern">Query.prototype.readConcern()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">level <span class="method-type">«String»</span> one of the listed read concern level or their aliases </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Sets the readConcern option for the query.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">new</span> Query().readConcern(<span class="hljs-string">'local'</span>)
<span class="hljs-keyword">new</span> Query().readConcern(<span class="hljs-string">'l'</span>)  <span class="hljs-comment">// same as local</span>

<span class="hljs-keyword">new</span> Query().readConcern(<span class="hljs-string">'available'</span>)
<span class="hljs-keyword">new</span> Query().readConcern(<span class="hljs-string">'a'</span>)  <span class="hljs-comment">// same as available</span>

<span class="hljs-keyword">new</span> Query().readConcern(<span class="hljs-string">'majority'</span>)
<span class="hljs-keyword">new</span> Query().readConcern(<span class="hljs-string">'m'</span>)  <span class="hljs-comment">// same as majority</span>

<span class="hljs-keyword">new</span> Query().readConcern(<span class="hljs-string">'linearizable'</span>)
<span class="hljs-keyword">new</span> Query().readConcern(<span class="hljs-string">'lz'</span>) <span class="hljs-comment">// same as linearizable</span>

<span class="hljs-keyword">new</span> Query().readConcern(<span class="hljs-string">'snapshot'</span>)
<span class="hljs-keyword">new</span> Query().readConcern(<span class="hljs-string">'s'</span>)  <span class="hljs-comment">// same as snapshot</span></pre> <h4>Read Concern Level:</h4> <pre data-language="javascript">local         MongoDB <span class="hljs-number">3.2</span>+ The query returns <span class="hljs-keyword">from</span> the instance <span class="hljs-keyword">with</span> no guarantee guarantee that the data has been written to a majority <span class="hljs-keyword">of</span> the replica <span class="hljs-keyword">set</span> members (i.e. may be rolled back).
available     MongoDB 3.6+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica <span class="hljs-keyword">set</span> members (i.e. may be rolled back).
majority      MongoDB 3.2+ The query returns the data that has been acknowledged by a majority of the replica <span class="hljs-keyword">set</span> members. The documents returned by the read operation are durable, even in the event of failure.
linearizable  MongoDB 3.4+ The query returns data that reflects all successful majority-acknowledged writes that completed prior to the start of the read operation. The query may wait for concurrently executing writes to propagate to a majority of replica <span class="hljs-keyword">set</span> members before returning results.
snapshot      MongoDB 4.0+ Only available for operations within multi-document transactions. Upon transaction commit with write concern "majority", the transaction operations are guaranteed to have read from a snapshot of majority-committed data.</pre> <p>Aliases</p> <pre data-language="javascript">l   local
a   available
m   majority
lz  linearizable
s   snapshot</pre> <p>Read more about how to use read concern <a href="https://docs.mongodb.com/manual/reference/read-concern/">here</a>.</p> </div>
<h3 id="query_Query-regex">Query.prototype.regex()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[path] <span class="method-type">«String»</span> </li>
<li class="param">val <span class="method-type">«String|RegExp»</span> </li>
</ul>
<div>
<p>Specifies a <code>$regex</code> query condition.</p> <p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p> </div>
<h3 id="query_Query-remove">Query.prototype.remove()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[filter] <span class="method-type">«Object|Query»</span> mongodb selector </li>
<li class="param">[callback] <span class="method-type">«Function»</span> optional params are (error, mongooseDeleteResult) </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Declare and/or execute this query as a remove() operation. <code>remove()</code> is deprecated, you should use <a href="#query_Query-deleteOne"><code>deleteOne()</code></a> or <a href="#query_Query-deleteMany"><code>deleteMany()</code></a> instead.</p> <p>This function does not trigger any middleware</p> <h4>Example</h4> <pre data-language="javascript">Character.remove({ <span class="hljs-attr">name</span>: <span class="hljs-regexp">/Stark/</span> }, callback);</pre> <p>This function calls the MongoDB driver's <a href="http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#remove"><code>Collection#remove()</code> function</a>. The returned <a href="../queries">promise</a> resolves to an object that contains 3 properties:</p> <ul> <li>
<code>ok</code>: <code>1</code> if no errors occurred</li> <li>
<code>deletedCount</code>: the number of documents deleted</li> <li>
<code>n</code>: the number of documents deleted. Equal to <code>deletedCount</code>.</li> </ul> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> Character.remove({ <span class="hljs-attr">name</span>: <span class="hljs-regexp">/Stark/</span> });
<span class="hljs-comment">// Number of docs deleted</span>
res.deletedCount;</pre> <h4>Note</h4> <p>Calling <code>remove()</code> creates a <a href="queries">Mongoose query</a>, and a query does not execute until you either pass a callback, call <a href="#query_Query-then"><code>Query#then()</code></a>, or call <a href="#query_Query-exec"><code>Query#exec()</code></a>.</p> <pre data-language="javascript"><span class="hljs-comment">// not executed</span>
<span class="hljs-keyword">const</span> query = Character.remove({ <span class="hljs-attr">name</span>: <span class="hljs-regexp">/Stark/</span> });

<span class="hljs-comment">// executed</span>
Character.remove({ <span class="hljs-attr">name</span>: <span class="hljs-regexp">/Stark/</span> }, callback);
Character.remove({ <span class="hljs-attr">name</span>: <span class="hljs-regexp">/Stark/</span> }).remove(callback);

<span class="hljs-comment">// executed without a callback</span>
Character.exec();</pre> </div>
<h3 id="query_Query-replaceOne">Query.prototype.replaceOne()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[filter] <span class="method-type">«Object»</span> </li>
<li class="param">[doc] <span class="method-type">«Object»</span> the update command </li>
<li class="param">[options] <span class="method-type">«Object»</span> </li>
<ul style="margin-top: 0.5em"><li>[options.multipleCastError] <span class="method-type">«Boolean»</span> by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.strict] <span class="method-type">«Boolean|String»</span> overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> </li></ul>
<ul style="margin-top: 0.5em"><li>[options.upsert=false] <span class="method-type">«Boolean»</span> if true, and no documents found, insert a new document </li></ul>
<ul style="margin-top: 0.5em"><li>[options.writeConcern=null] <span class="method-type">«Object»</span> sets the <a href="https://docs.mongodb.com/manual/reference/write-concern/">write concern</a> for replica sets. Overrides the <a href="../guide#writeConcern">schema-level write concern</a> </li></ul>
<ul style="margin-top: 0.5em"><li>[options.timestamps=null] <span class="method-type">«Boolean»</span> If set to <code>false</code> and <a href="../guide#timestamps">schema-level timestamps</a> are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set. </li></ul>
<li class="param">[callback] <span class="method-type">«Function»</span> params are (error, writeOpResult) </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Declare and/or execute this query as a replaceOne() operation. Same as <code>update()</code>, except MongoDB will replace the existing document and will not accept any <a href="https://docs.mongodb.com/manual/tutorial/model-data-for-atomic-operations/#pattern">atomic</a> operators (<code>$set</code>, etc.)</p> <p><strong>Note</strong> replaceOne will <em>not</em> fire update middleware. Use <code>pre('replaceOne')</code> and <code>post('replaceOne')</code> instead.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> Person.replaceOne({ <span class="hljs-attr">_id</span>: <span class="hljs-number">24601</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">'Jean Valjean'</span> });
res.n; <span class="hljs-comment">// Number of documents matched</span>
res.nModified; <span class="hljs-comment">// Number of documents modified</span></pre> <p>This function triggers the following middleware.</p> <ul> <li><code>replaceOne()</code></li> </ul> </div>
<h3 id="query_Query-select">Query.prototype.select()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">arg <span class="method-type">«Object|String|Array&lt;String&gt;»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Specifies which document fields to include or exclude (also known as the query "projection")</p> <p>When using string syntax, prefixing a path with <code>-</code> will flag that path as excluded. When a path does not have the <code>-</code> prefix, it is included. Lastly, if a path is prefixed with <code>+</code>, it forces inclusion of the path, which is useful for paths excluded at the <a href="https://mongoosejs.com/docs/api.html#schematype_SchemaType-select">schema level</a>.</p> <p>A projection <em>must</em> be either inclusive or exclusive. In other words, you must either list the fields to include (which excludes all others), or list the fields to exclude (which implies all other fields are included). The <a href="https://docs.mongodb.com/manual/tutorial/project-fields-from-query-results/#suppress-id-field"><code>_id</code> field is the only exception because MongoDB includes it by default</a>.</p> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-comment">// include a and b, exclude other fields</span>
query.select(<span class="hljs-string">'a b'</span>);
<span class="hljs-comment">// Equivalent syntaxes:</span>
query.select([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>]);
query.select({ <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> });

<span class="hljs-comment">// exclude c and d, include other fields</span>
query.select(<span class="hljs-string">'-c -d'</span>);

<span class="hljs-comment">// Use `+` to override schema-level `select: false` without making the</span>
<span class="hljs-comment">// projection inclusive.</span>
<span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({
  <span class="hljs-attr">foo</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">select</span>: <span class="hljs-literal">false</span> },
  <span class="hljs-attr">bar</span>: <span class="hljs-built_in">String</span>
});
<span class="hljs-comment">// ...</span>
query.select(<span class="hljs-string">'+foo'</span>); <span class="hljs-comment">// Override foo's `select: false` without excluding `bar`</span>

<span class="hljs-comment">// or you may use object notation, useful when</span>
<span class="hljs-comment">// you have keys already prefixed with a "-"</span>
query.select({ <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> });
query.select({ <span class="hljs-attr">c</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">d</span>: <span class="hljs-number">0</span> });

Additional calls to select can override the previous selection:
query.select({ <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> }).select({ <span class="hljs-attr">b</span>: <span class="hljs-number">0</span> }); <span class="hljs-comment">// selection is now { a: 1 }</span>
query.select({ <span class="hljs-attr">a</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">0</span> }).select({ <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> }); <span class="hljs-comment">// selection is now { a: 0 }</span></pre> </div>
<h3 id="query_Query-selected">Query.prototype.selected()</h3>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Boolean»</span> </li></ul>
<div>
<p>Determines if field selection has been made.</p> </div>
<h3 id="query_Query-selectedExclusively">Query.prototype.selectedExclusively()</h3>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Boolean»</span> </li></ul>
<div>
<p>Determines if exclusive field selection has been made.</p> <pre data-language="javascript">query.selectedExclusively() <span class="hljs-comment">// false</span>
query.select(<span class="hljs-string">'-name'</span>)
query.selectedExclusively() <span class="hljs-comment">// true</span>
query.selectedInclusively() <span class="hljs-comment">// false</span></pre> </div>
<h3 id="query_Query-selectedInclusively">Query.prototype.selectedInclusively()</h3>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Boolean»</span> </li></ul>
<div>
<p>Determines if inclusive field selection has been made.</p> <pre data-language="javascript">query.selectedInclusively() <span class="hljs-comment">// false</span>
query.select(<span class="hljs-string">'name'</span>)
query.selectedInclusively() <span class="hljs-comment">// true</span></pre> </div>
<h3 id="query_Query-session">Query.prototype.session()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">[session] <span class="method-type">«ClientSession»</span> from <code>await conn.startSession()</code> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Sets the <a href="https://docs.mongodb.com/manual/reference/server-sessions/">MongoDB session</a> associated with this query. Sessions are how you mark a query as part of a <a href="../transactions">transaction</a>.</p> <p>Calling <code>session(null)</code> removes the session from this query.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">await</span> mongoose.startSession();
<span class="hljs-keyword">await</span> mongoose.model(<span class="hljs-string">'Person'</span>).findOne({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Axl Rose'</span> }).session(s);</pre> </div>
<h3 id="query_Query-set">Query.prototype.set()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">path <span class="method-type">«String|Object»</span> path or object of key/value pairs to set </li>
<li class="param">[val] <span class="method-type">«Any»</span> the value to set </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Adds a <code>$set</code> to this query's update without changing the operation. This is useful for query middleware so you can add an update regardless of whether you use <code>updateOne()</code>, <code>updateMany()</code>, <code>findOneAndUpdate()</code>, etc.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-comment">// Updates `{ $set: { updatedAt: new Date() } }`</span>
<span class="hljs-keyword">new</span> Query().updateOne({}, {}).set(<span class="hljs-string">'updatedAt'</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());
<span class="hljs-keyword">new</span> Query().updateMany({}, {}).set({ <span class="hljs-attr">updatedAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() });</pre> </div>
<h3 id="query_Query-setOptions">Query.prototype.setOptions()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">options <span class="method-type">«Object»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Sets query options. Some options only make sense for certain operations.</p> <h4>Options:</h4> <p>The following options are only for <code>find()</code>:</p> <ul> <li><a href="http://www.mongodb.org/display/DOCS/Tailable+Cursors">tailable</a></li> <li><a href="http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort()%7D%7D">sort</a></li> <li><a href="http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D">limit</a></li> <li><a href="http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D">skip</a></li> <li><a href="https://docs.mongodb.com/manual/reference/method/cursor.allowDiskUse/">allowDiskUse</a></li> <li><a href="http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D">batchSize</a></li> <li><a href="http://docs.mongodb.org/manual/applications/replication/#read-preference">readPreference</a></li> <li><a href="http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint">hint</a></li> <li><a href="http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment">comment</a></li> <li><a href="http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D">snapshot</a></li> <li><a href="https://docs.mongodb.org/v3.2/reference/operator/meta/maxScan/#metaOp._S_maxScan">maxscan</a></li> </ul> <p>The following options are only for write operations: <code>update()</code>, <code>updateOne()</code>, <code>updateMany()</code>, <code>replaceOne()</code>, <code>findOneAndUpdate()</code>, and <code>findByIdAndUpdate()</code>:</p> <ul> <li><a href="https://docs.mongodb.com/manual/reference/method/db.collection.update/">upsert</a></li> <li><a href="https://docs.mongodb.com/manual/reference/method/db.collection.update/">writeConcern</a></li> <li>
<a href="../guide#timestamps">timestamps</a>: If <code>timestamps</code> is set in the schema, set this option to <code>false</code> to skip timestamps for that particular update. Has no effect if <code>timestamps</code> is not enabled in the schema options.</li> <li>overwriteDiscriminatorKey: allow setting the discriminator key in the update. Will use the correct discriminator schema if the update changes the discriminator key.</li> </ul> <p>The following options are only for <code>find()</code>, <code>findOne()</code>, <code>findById()</code>, <code>findOneAndUpdate()</code>, and <code>findByIdAndUpdate()</code>:</p> <ul> <li><a href="api#query_Query-lean">lean</a></li> <li><a href="../populate">populate</a></li> <li><a href="query#query_Query-projection">projection</a></li> <li>sanitizeProjection</li> </ul> <p>The following options are only for all operations <strong>except</strong> <code>update()</code>, <code>updateOne()</code>, <code>updateMany()</code>, <code>remove()</code>, <code>deleteOne()</code>, and <code>deleteMany()</code>:</p> <ul> <li><a href="https://docs.mongodb.com/manual/reference/operator/meta/maxTimeMS/">maxTimeMS</a></li> </ul> <p>The following options are for <code>findOneAndUpdate()</code> and <code>findOneAndRemove()</code></p> <ul> <li>rawResult</li> </ul> <h2>The following options are for all operations</h2> <ul> <li><a href="../guide#strict">strict</a></li> <li><a href="https://docs.mongodb.com/manual/reference/collation/">collation</a></li> <li><a href="https://docs.mongodb.com/manual/reference/server-sessions/">session</a></li> <li><a href="https://docs.mongodb.com/manual/reference/method/cursor.explain/">explain</a></li> </ul> </div>
<h3 id="query_Query-setQuery">Query.prototype.setQuery()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">new <span class="method-type">«Object»</span> query conditions </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«undefined»</span> </li></ul>
<div>
<p>Sets the query conditions to the provided JSON object.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> query = <span class="hljs-keyword">new</span> Query();
query.find({ <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> })
query.setQuery({ <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> });
query.getQuery(); <span class="hljs-comment">// { a: 2 }</span></pre> </div>
<h3 id="query_Query-setUpdate">Query.prototype.setUpdate()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">new <span class="method-type">«Object»</span> update operation </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«undefined»</span> </li></ul>
<div>
<p>Sets the current update operation to new value.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> query = <span class="hljs-keyword">new</span> Query();
query.update({}, { <span class="hljs-attr">$set</span>: { <span class="hljs-attr">a</span>: <span class="hljs-number">5</span> } });
query.setUpdate({ <span class="hljs-attr">$set</span>: { <span class="hljs-attr">b</span>: <span class="hljs-number">6</span> } });
query.getUpdate(); <span class="hljs-comment">// { $set: { b: 6 } }</span></pre> </div>
<h3 id="query_Query-size">Query.prototype.size()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[path] <span class="method-type">«String»</span> </li>
<li class="param">val <span class="method-type">«Number»</span> </li>
</ul>
<div>
<p>Specifies a <code>$size</code> query condition.</p> <p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> docs = <span class="hljs-keyword">await</span> MyModel.where(<span class="hljs-string">'tags'</span>).size(<span class="hljs-number">0</span>).exec();
assert(<span class="hljs-built_in">Array</span>.isArray(docs));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'documents with 0 tags'</span>, docs);</pre> </div>
<h3 id="query_Query-skip">Query.prototype.skip()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">val <span class="method-type">«Number»</span> </li></ul>
<div>
<p>Specifies the number of documents to skip.</p> <h4>Example</h4> <pre data-language="javascript">query.skip(<span class="hljs-number">100</span>).limit(<span class="hljs-number">20</span>)</pre> <h4>Note</h4> <p>Cannot be used with <code>distinct()</code></p> </div>
<h3 id="query_Query-slaveOk">Query.prototype.slaveOk()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">v <span class="method-type">«Boolean»</span> defaults to true </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p><em>DEPRECATED</em> Sets the slaveOk option.</p> <p><strong>Deprecated</strong> in MongoDB 2.2 in favor of <a href="#query_Query-read">read preferences</a>.</p> <h4>Example:</h4> <pre data-language="javascript">query.slaveOk() <span class="hljs-comment">// true</span>
query.slaveOk(<span class="hljs-literal">true</span>)
query.slaveOk(<span class="hljs-literal">false</span>)</pre> </div>
<h3 id="query_Query-slice">Query.prototype.slice()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[path] <span class="method-type">«String»</span> </li>
<li class="param">val <span class="method-type">«Number»</span> number/range of elements to slice </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Specifies a <code>$slice</code> projection for an array.</p> <h4>Example</h4> <pre data-language="javascript">query.slice(<span class="hljs-string">'comments'</span>, <span class="hljs-number">5</span>)
query.slice(<span class="hljs-string">'comments'</span>, <span class="hljs-number">-5</span>)
query.slice(<span class="hljs-string">'comments'</span>, [<span class="hljs-number">10</span>, <span class="hljs-number">5</span>])
query.where(<span class="hljs-string">'comments'</span>).slice(<span class="hljs-number">5</span>)
query.where(<span class="hljs-string">'comments'</span>).slice([<span class="hljs-number">-10</span>, <span class="hljs-number">5</span>])</pre> </div>
<h3 id="query_Query-snapshot">Query.prototype.snapshot()</h3>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Specifies this query as a <code>snapshot</code> query.</p> <h4>Example</h4> <pre data-language="javascript">query.snapshot() <span class="hljs-comment">// true</span>
query.snapshot(<span class="hljs-literal">true</span>)
query.snapshot(<span class="hljs-literal">false</span>)</pre> <h4>Note</h4> <p>Cannot be used with <code>distinct()</code></p> </div>
<h3 id="query_Query-sort">Query.prototype.sort()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">arg <span class="method-type">«Object|String»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Sets the sort order</p> <p>If an object is passed, values allowed are <code>asc</code>, <code>desc</code>, <code>ascending</code>, <code>descending</code>, <code>1</code>, and <code>-1</code>.</p> <p>If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with <code>-</code> which will be treated as descending.</p> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-comment">// sort by "field" ascending and "test" descending</span>
query.sort({ <span class="hljs-attr">field</span>: <span class="hljs-string">'asc'</span>, <span class="hljs-attr">test</span>: <span class="hljs-number">-1</span> });

<span class="hljs-comment">// equivalent</span>
query.sort(<span class="hljs-string">'field -test'</span>);</pre> <h4>Note</h4> <p>Cannot be used with <code>distinct()</code></p> </div>
<h3 id="query_Query-tailable">Query.prototype.tailable()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">bool <span class="method-type">«Boolean»</span> defaults to true </li>
<li class="param">[opts] <span class="method-type">«Object»</span> options to set </li>
<ul style="margin-top: 0.5em"><li>[opts.awaitData] <span class="method-type">«Boolean»</span> false by default. Set to true to keep the cursor open even if there's no data. </li></ul>
<ul style="margin-top: 0.5em"><li>[opts.maxAwaitTimeMS] <span class="method-type">«Number»</span> the maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query. Requires <code>tailable</code> and <code>awaitData</code> to be true </li></ul>
</ul>
<div>
<p>Sets the tailable option (for use with capped collections).</p> <h4>Example</h4> <pre data-language="javascript">query.tailable(); <span class="hljs-comment">// true</span>
query.tailable(<span class="hljs-literal">true</span>);
query.tailable(<span class="hljs-literal">false</span>);

<span class="hljs-comment">// Set both `tailable` and `awaitData` options</span>
query.tailable({ <span class="hljs-attr">awaitData</span>: <span class="hljs-literal">true</span> });</pre> <h4>Note</h4> <p>Cannot be used with <code>distinct()</code></p> </div>
<h3 id="query_Query-then">Query.prototype.then()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[resolve] <span class="method-type">«Function»</span> </li>
<li class="param">[reject] <span class="method-type">«Function»</span> </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Promise»</span> </li></ul>
<div>
<p>Executes the query returning a <code>Promise</code> which will be resolved with either the doc(s) or rejected with the error.</p> <p>More about <a href="https://masteringjs.io/tutorials/fundamentals/then"><code>then()</code> in JavaScript</a>.</p> </div>
<h3 id="query_Query-toConstructor">Query.prototype.toConstructor()</h3>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> subclass-of-Query </li></ul>
<div>
<p>Converts this query to a customized, reusable query constructor with all arguments and options retained.</p> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-comment">// Create a query for adventure movies and read from the primary</span>
<span class="hljs-comment">// node in the replica-set unless it is down, in which case we'll</span>
<span class="hljs-comment">// read from a secondary node.</span>
<span class="hljs-keyword">const</span> query = Movie.find({ <span class="hljs-attr">tags</span>: <span class="hljs-string">'adventure'</span> }).read(<span class="hljs-string">'primaryPreferred'</span>);

<span class="hljs-comment">// create a custom Query constructor based off these settings</span>
<span class="hljs-keyword">const</span> Adventure = query.toConstructor();

<span class="hljs-comment">// Adventure is now a subclass of mongoose.Query and works the same way but with the</span>
<span class="hljs-comment">// default query parameters and options set.</span>
Adventure().exec(callback)

<span class="hljs-comment">// further narrow down our query results while still using the previous settings</span>
Adventure().where({ <span class="hljs-attr">name</span>: <span class="hljs-regexp">/^Life/</span> }).exec(callback);

<span class="hljs-comment">// since Adventure is a stand-alone constructor we can also add our own</span>
<span class="hljs-comment">// helper methods and getters without impacting global queries</span>
Adventure.prototype.startsWith = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prefix</span>) </span>{
  <span class="hljs-keyword">this</span>.where({ <span class="hljs-attr">name</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'^'</span> + prefix) })
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}
<span class="hljs-built_in">Object</span>.defineProperty(Adventure.prototype, <span class="hljs-string">'highlyRated'</span>, {
  <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> () </span>{
    <span class="hljs-keyword">this</span>.where({ <span class="hljs-attr">rating</span>: { <span class="hljs-attr">$gt</span>: <span class="hljs-number">4.5</span> }});
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }
})
Adventure().highlyRated.startsWith(<span class="hljs-string">'Life'</span>).exec(callback)</pre> </div>
<h3 id="query_Query-transform">Query.prototype.transform()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">fn <span class="method-type">«Function»</span> function to run to transform the query result </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Runs a function <code>fn</code> and treats the return value of <code>fn</code> as the new value for the query to resolve to.</p> <p>Any functions you pass to <code>transform()</code> will run <strong>after</strong> any post hooks.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> MyModel.findOne().transform(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
  <span class="hljs-comment">// Sets a `loadedAt` property on the doc that tells you the time the</span>
  <span class="hljs-comment">// document was loaded.</span>
  <span class="hljs-keyword">return</span> res == <span class="hljs-literal">null</span> ?
    res :
    <span class="hljs-built_in">Object</span>.assign(res, { <span class="hljs-attr">loadedAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() });
});</pre> </div>
<h3 id="query_Query-update">Query.prototype.update()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[filter] <span class="method-type">«Object»</span> </li>
<li class="param">[doc] <span class="method-type">«Object»</span> the update command </li>
<li class="param">[options] <span class="method-type">«Object»</span> </li>
<ul style="margin-top: 0.5em"><li>[options.multipleCastError] <span class="method-type">«Boolean»</span> by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.strict] <span class="method-type">«Boolean|String»</span> overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> </li></ul>
<ul style="margin-top: 0.5em"><li>[options.upsert=false] <span class="method-type">«Boolean»</span> if true, and no documents found, insert a new document </li></ul>
<ul style="margin-top: 0.5em"><li>[options.writeConcern=null] <span class="method-type">«Object»</span> sets the <a href="https://docs.mongodb.com/manual/reference/write-concern/">write concern</a> for replica sets. Overrides the <a href="../guide#writeConcern">schema-level write concern</a> </li></ul>
<ul style="margin-top: 0.5em"><li>[options.timestamps=null] <span class="method-type">«Boolean»</span> If set to <code>false</code> and <a href="../guide#timestamps">schema-level timestamps</a> are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set. </li></ul>
<li class="param">[callback] <span class="method-type">«Function»</span> params are (error, writeOpResult) </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Declare and/or execute this query as an update() operation.</p> <p><em>All paths passed that are not <a href="https://docs.mongodb.com/manual/tutorial/model-data-for-atomic-operations/#pattern">atomic</a> operations will become <code>$set</code> ops.</em></p> <p>This function triggers the following middleware.</p> <ul> <li><code>update()</code></li> </ul> <h4>Example</h4> <pre data-language="javascript">Model.where({ <span class="hljs-attr">_id</span>: id }).update({ <span class="hljs-attr">title</span>: <span class="hljs-string">'words'</span> })

<span class="hljs-comment">// becomes</span>

Model.where({ <span class="hljs-attr">_id</span>: id }).update({ <span class="hljs-attr">$set</span>: { <span class="hljs-attr">title</span>: <span class="hljs-string">'words'</span> }})</pre> <h4>Valid options:</h4> <ul> <li>
<code>upsert</code> (boolean) whether to create the doc if it doesn't match (false)</li> <li>
<code>multi</code> (boolean) whether multiple documents should be updated (false)</li> <li>
<code>runValidators</code> (boolean) if true, runs <a href="../validation#update-validators">update validators</a> on this command. Update validators validate the update operation against the model's schema.</li> <li>
<code>setDefaultsOnInsert</code> (boolean) <code>true</code> by default. If <code>setDefaultsOnInsert</code> and <code>upsert</code> are true, mongoose will apply the <a href="http://mongoosejs.com/docs/defaults.html">defaults</a> specified in the model's schema if a new document is created.</li> <li>
<code>strict</code> (boolean) overrides the <code>strict</code> option for this update</li> <li><code>read</code></li> <li><code>writeConcern</code></li> </ul> <h4>Note</h4> <p>Passing an empty object <code>{}</code> as the doc will result in a no-op. The update operation will be ignored and the callback executed without sending the command to MongoDB.</p> <h4>Note</h4> <p>The operation is only executed when a callback is passed. To force execution without a callback, we must first call update() and then execute it by using the <code>exec()</code> method.</p> <pre data-language="javascript">const q = Model.where({ _id: id });
q.update({ $set: { name: 'bob' }}).update(); // not executed

q.update({ $set: { name: 'bob' }}).exec(); // executed

// keys that are not [atomic](<a href="https://docs.mongodb.com/manual/tutorial/model-data-for-atomic-operations/#pattern">https://docs.mongodb.com/manual/tutorial/model-data-for-atomic-operations/#pattern</a>) ops become `$set`.
// this executes the same command as the previous example.
q.update({ name: 'bob' }).exec();

// multi updates
Model.where()
     .update({ name: /^match/ }, { $set: { arr: [] }}, { multi: true }, callback)

// more multi updates
Model.where()
     .setOptions({ multi: true })
     .update({ $set: { arr: [] }}, callback)

// single update by default
Model.where({ email: '<a href="mailto:address@example.com">address@example.com</a>' })
     .update({ $inc: { counter: 1 }}, callback)
</pre> <p>API summary</p> <pre data-language="javascript">update(filter, doc, options, cb) <span class="hljs-comment">// executes</span>
update(filter, doc, options)
update(filter, doc, cb) <span class="hljs-comment">// executes</span>
update(filter, doc)
update(doc, cb) <span class="hljs-comment">// executes</span>
update(doc)
update(cb) <span class="hljs-comment">// executes</span>
update(<span class="hljs-literal">true</span>) <span class="hljs-comment">// executes</span>
update()</pre> </div>
<h3 id="query_Query-updateMany">Query.prototype.updateMany()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[filter] <span class="method-type">«Object»</span> </li>
<li class="param">[update] <span class="method-type">«Object|Array»</span> the update command </li>
<li class="param">[options] <span class="method-type">«Object»</span> </li>
<ul style="margin-top: 0.5em"><li>[options.multipleCastError] <span class="method-type">«Boolean»</span> by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.strict] <span class="method-type">«Boolean|String»</span> overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> </li></ul>
<ul style="margin-top: 0.5em"><li>[options.upsert=false] <span class="method-type">«Boolean»</span> if true, and no documents found, insert a new document </li></ul>
<ul style="margin-top: 0.5em"><li>[options.writeConcern=null] <span class="method-type">«Object»</span> sets the <a href="https://docs.mongodb.com/manual/reference/write-concern/">write concern</a> for replica sets. Overrides the <a href="../guide#writeConcern">schema-level write concern</a> </li></ul>
<ul style="margin-top: 0.5em"><li>[options.timestamps=null] <span class="method-type">«Boolean»</span> If set to <code>false</code> and <a href="../guide#timestamps">schema-level timestamps</a> are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set. </li></ul>
<li class="param">[callback] <span class="method-type">«Function»</span> params are (error, writeOpResult) </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Declare and/or execute this query as an updateMany() operation. Same as <code>update()</code>, except MongoDB will update <em>all</em> documents that match <code>filter</code> (as opposed to just the first one) regardless of the value of the <code>multi</code> option.</p> <p><strong>Note</strong> updateMany will <em>not</em> fire update middleware. Use <code>pre('updateMany')</code> and <code>post('updateMany')</code> instead.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> Person.updateMany({ <span class="hljs-attr">name</span>: <span class="hljs-regexp">/Stark$/</span> }, { <span class="hljs-attr">isDeleted</span>: <span class="hljs-literal">true</span> });
res.n; <span class="hljs-comment">// Number of documents matched</span>
res.nModified; <span class="hljs-comment">// Number of documents modified</span></pre> <p>This function triggers the following middleware.</p> <ul> <li><code>updateMany()</code></li> </ul> </div>
<h3 id="query_Query-updateOne">Query.prototype.updateOne()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[filter] <span class="method-type">«Object»</span> </li>
<li class="param">[update] <span class="method-type">«Object|Array»</span> the update command </li>
<li class="param">[options] <span class="method-type">«Object»</span> </li>
<ul style="margin-top: 0.5em"><li>[options.multipleCastError] <span class="method-type">«Boolean»</span> by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.strict] <span class="method-type">«Boolean|String»</span> overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> </li></ul>
<ul style="margin-top: 0.5em"><li>[options.upsert=false] <span class="method-type">«Boolean»</span> if true, and no documents found, insert a new document </li></ul>
<ul style="margin-top: 0.5em"><li>[options.writeConcern=null] <span class="method-type">«Object»</span> sets the <a href="https://docs.mongodb.com/manual/reference/write-concern/">write concern</a> for replica sets. Overrides the <a href="../guide#writeConcern">schema-level write concern</a> </li></ul>
<ul style="margin-top: 0.5em"><li>[options.timestamps=null] <span class="method-type">«Boolean»</span> If set to <code>false</code> and <a href="../guide#timestamps">schema-level timestamps</a> are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set. </li></ul>
<li class="param">[callback] <span class="method-type">«Function»</span> params are (error, writeOpResult) </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Declare and/or execute this query as an updateOne() operation. Same as <code>update()</code>, except it does not support the <code>multi</code> option.</p> <ul> <li>MongoDB will update <em>only</em> the first document that matches <code>filter</code> regardless of the value of the <code>multi</code> option.</li> <li>Use <code>replaceOne()</code> if you want to overwrite an entire document rather than using <a href="https://docs.mongodb.com/manual/tutorial/model-data-for-atomic-operations/#pattern">atomic</a> operators like <code>$set</code>.</li> </ul> <p><strong>Note</strong> updateOne will <em>not</em> fire update middleware. Use <code>pre('updateOne')</code> and <code>post('updateOne')</code> instead.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> Person.updateOne({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Jean-Luc Picard'</span> }, { <span class="hljs-attr">ship</span>: <span class="hljs-string">'USS Enterprise'</span> });
res.n; <span class="hljs-comment">// Number of documents matched</span>
res.nModified; <span class="hljs-comment">// Number of documents modified</span></pre> <p>This function triggers the following middleware.</p> <ul> <li><code>updateOne()</code></li> </ul> </div>
<h3 id="query_Query-use$geoWithin">Query.prototype.use$geoWithin</h3>
<h5>Type:</h5>
<ul><li><span class="method-type">«property»</span></li></ul>
<div>
<p>Flag to opt out of using <code>$geoWithin</code>.</p> <pre data-language="javascript">mongoose.Query.use$geoWithin = <span class="hljs-literal">false</span>;</pre> <p>MongoDB 2.4 deprecated the use of <code>$within</code>, replacing it with <code>$geoWithin</code>. Mongoose uses <code>$geoWithin</code> by default (which is 100% backward compatible with <code>$within</code>). If you are running an older version of MongoDB, set this flag to <code>false</code> so your <code>within()</code> queries continue to work.</p> </div>
<h3 id="query_Query-w">Query.prototype.w()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">val <span class="method-type">«String|number»</span> 0 for fire-and-forget, 1 for acknowledged by one server, 'majority' for majority of the replica set, or <a href="https://docs.mongodb.com/manual/reference/write-concern/#w-option">any of the more advanced options</a>. </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Sets the specified number of <code>mongod</code> servers, or tag set of <code>mongod</code> servers, that must acknowledge this write before this write is considered successful.</p> <h2>This option is only valid for operations that write to the database</h2> <ul> <li><code>deleteOne()</code></li> <li><code>deleteMany()</code></li> <li><code>findOneAndDelete()</code></li> <li><code>findOneAndReplace()</code></li> <li><code>findOneAndUpdate()</code></li> <li><code>remove()</code></li> <li><code>update()</code></li> <li><code>updateOne()</code></li> <li><code>updateMany()</code></li> </ul> <p>Defaults to the schema's <a href="../guide#writeConcern"><code>writeConcern.w</code> option</a></p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-comment">// The 'majority' option means the `deleteOne()` promise won't resolve</span>
<span class="hljs-comment">// until the `deleteOne()` has propagated to the majority of the replica set</span>
<span class="hljs-keyword">await</span> mongoose.model(<span class="hljs-string">'Person'</span>).
  deleteOne({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Ned Stark'</span> }).
  w(<span class="hljs-string">'majority'</span>);</pre> </div>
<h3 id="query_Query-where">Query.prototype.where()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[path] <span class="method-type">«String|Object»</span> </li>
<li class="param">[val] <span class="method-type">«any»</span> </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Specifies a <code>path</code> for use with chaining.</p> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-comment">// instead of writing:</span>
User.find({<span class="hljs-attr">age</span>: {<span class="hljs-attr">$gte</span>: <span class="hljs-number">21</span>, <span class="hljs-attr">$lte</span>: <span class="hljs-number">65</span>}}, callback);

<span class="hljs-comment">// we can instead write:</span>
User.where(<span class="hljs-string">'age'</span>).gte(<span class="hljs-number">21</span>).lte(<span class="hljs-number">65</span>);

<span class="hljs-comment">// passing query conditions is permitted</span>
User.find().where({ <span class="hljs-attr">name</span>: <span class="hljs-string">'vonderful'</span> })

<span class="hljs-comment">// chaining</span>
User
.where(<span class="hljs-string">'age'</span>).gte(<span class="hljs-number">21</span>).lte(<span class="hljs-number">65</span>)
.where(<span class="hljs-string">'name'</span>, /^vonderful/i)
.where(<span class="hljs-string">'friends'</span>).slice(<span class="hljs-number">10</span>)
.exec(callback)</pre> </div>
<h3 id="query_Query-within">Query.prototype.within()</h3>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>Defines a <code>$within</code> or <code>$geoWithin</code> argument for geo-spatial queries.</p> <h4>Example</h4> <pre data-language="javascript">query.where(path).within().box()
query.where(path).within().circle()
query.where(path).within().geometry()

query.where(<span class="hljs-string">'loc'</span>).within({ <span class="hljs-attr">center</span>: [<span class="hljs-number">50</span>,<span class="hljs-number">50</span>], <span class="hljs-attr">radius</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">spherical</span>: <span class="hljs-literal">true</span> });
query.where(<span class="hljs-string">'loc'</span>).within({ <span class="hljs-attr">box</span>: [[<span class="hljs-number">40.73</span>, <span class="hljs-number">-73.9</span>], [<span class="hljs-number">40.7</span>, <span class="hljs-number">-73.988</span>]] });
query.where(<span class="hljs-string">'loc'</span>).within({ <span class="hljs-attr">polygon</span>: [[],[],[],[]] });

query.where(<span class="hljs-string">'loc'</span>).within([], [], []) <span class="hljs-comment">// polygon</span>
query.where(<span class="hljs-string">'loc'</span>).within([], []) <span class="hljs-comment">// box</span>
query.where(<span class="hljs-string">'loc'</span>).within({ <span class="hljs-attr">type</span>: <span class="hljs-string">'LineString'</span>, <span class="hljs-attr">coordinates</span>: [...] }); <span class="hljs-comment">// geometry</span></pre> <p><strong>MUST</strong> be used after <code>where()</code>.</p> <h4>NOTE:</h4> <p>As of Mongoose 3.7, <code>$geoWithin</code> is always used for queries. To change this behavior, see <a href="#query_Query-use%2524geoWithin">Query.use$geoWithin</a>.</p> <h4>NOTE:</h4> <p>In Mongoose 3.7, <code>within</code> changed from a getter to a function. If you need the old syntax, use <a href="https://github.com/ebensing/mongoose-within">this</a>.</p> </div>
<h3 id="query_Query-writeConcern">Query.prototype.writeConcern()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">writeConcern <span class="method-type">«Object»</span> the write concern value to set </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<h2>Sets the 3 write concern parameters for this query</h2> <ul> <li>
<code>w</code>: Sets the specified number of <code>mongod</code> servers, or tag set of <code>mongod</code> servers, that must acknowledge this write before this write is considered successful.</li> <li>
<code>j</code>: Boolean, set to <code>true</code> to request acknowledgement that this operation has been persisted to MongoDB's on-disk journal.</li> <li>
<code>wtimeout</code>: If <a href="https://mongoosejs.com/docs/api.html#query_Query-w"><code>w &gt; 1</code></a>, the maximum amount of time to wait for this write to propagate through the replica set before this operation fails. The default is <code>0</code>, which means no timeout.</li> </ul> <h2>This option is only valid for operations that write to the database</h2> <ul> <li><code>deleteOne()</code></li> <li><code>deleteMany()</code></li> <li><code>findOneAndDelete()</code></li> <li><code>findOneAndReplace()</code></li> <li><code>findOneAndUpdate()</code></li> <li><code>remove()</code></li> <li><code>update()</code></li> <li><code>updateOne()</code></li> <li><code>updateMany()</code></li> </ul> <p>Defaults to the schema's <a href="../guide#writeConcern"><code>writeConcern</code> option</a></p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-comment">// The 'majority' option means the `deleteOne()` promise won't resolve</span>
<span class="hljs-comment">// until the `deleteOne()` has propagated to the majority of the replica set</span>
<span class="hljs-keyword">await</span> mongoose.model(<span class="hljs-string">'Person'</span>).
  deleteOne({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Ned Stark'</span> }).
  writeConcern({ <span class="hljs-attr">w</span>: <span class="hljs-string">'majority'</span> });</pre> </div>
<h3 id="query_Query-wtimeout">Query.prototype.wtimeout()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">ms <span class="method-type">«number»</span> number of milliseconds to wait </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Query»</span> this </li></ul>
<div>
<p>If <a href="https://mongoosejs.com/docs/api.html#query_Query-w"><code>w &gt; 1</code></a>, the maximum amount of time to wait for this write to propagate through the replica set before this operation fails. The default is <code>0</code>, which means no timeout.</p> <h2>This option is only valid for operations that write to the database</h2> <ul> <li><code>deleteOne()</code></li> <li><code>deleteMany()</code></li> <li><code>findOneAndDelete()</code></li> <li><code>findOneAndReplace()</code></li> <li><code>findOneAndUpdate()</code></li> <li><code>remove()</code></li> <li><code>update()</code></li> <li><code>updateOne()</code></li> <li><code>updateMany()</code></li> </ul> <p>Defaults to the schema's <a href="../guide#writeConcern"><code>writeConcern.wtimeout</code> option</a></p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-comment">// The `deleteOne()` promise won't resolve until this `deleteOne()` has</span>
<span class="hljs-comment">// propagated to at least `w = 2` members of the replica set. If it takes</span>
<span class="hljs-comment">// longer than 1 second, this `deleteOne()` will fail.</span>
<span class="hljs-keyword">await</span> mongoose.model(<span class="hljs-string">'Person'</span>).
  deleteOne({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Ned Stark'</span> }).
  w(<span class="hljs-number">2</span>).
  wtimeout(<span class="hljs-number">1000</span>);</pre> </div>
</div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://mongoosejs.com/docs/api/query.html" class="_attribution-link" target="_blank">https://mongoosejs.com/docs/api/query.html</a>
  </p>
</div>
