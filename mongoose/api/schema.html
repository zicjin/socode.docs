<a class="edit-docs-link" href="https://github.com/Automattic/mongoose/blob/master/lib/schema.js" target="_blank"> <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHZpZXdCb3g9IjAgMCAxMDAwIDEwMDAiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDEwMDAgMTAwMCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8Zz48ZyB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAtMSAwIDQ4MCkiPjxwYXRoIHN0cm9rZT0iIzA5NzFCMiIgZmlsbD0iIzA5NzFCMiIgZD0iTTkzMC45LDQyMC41Yy0zMy4xLDMxLjgtNjkuMyw0Ny43LTEwOC43LDQ3LjdjLTQ0LjUsMC04My45LTE3LjItMTE4LjItNTEuNUw5OS40LTE4NS45Yy0zLjgtMy44LTYuNC04LjktNy42LTE1LjNjLTIuNS04LjktMjkuMi05Ny45LTgwLjEtMjY3Yy0zLjgtMTIuNy0xLjMtMjMuNSw3LjYtMzIuNGM2LjQtNS4xLDE0LTcuNiwyMi45LTcuNmg5LjVjMTMyLjIsNDQuNSwyMTkuOSw3My4xLDI2My4yLDg1LjhjMy44LDEuMyw3LjYsMy44LDExLjQsNy42YzM3NSwzNzAsNTc3LjIsNTcwLjIsNjA2LjQsNjAwLjdjMzguMSwzOS40LDU3LjIsNzkuNSw1Ny4yLDEyMC4xQzk4OC43LDM0Ni44LDk2OSwzODQuOSw5MzAuOSw0MjAuNXogTTY5NC40LDMxOS40YzMxLjgtNy42LDYxLjctMjUuNCw4OS42LTUzLjRjMjYuNy0yNi43LDQzLjItNTcuMiw0OS42LTkxLjVDNzQ3LjIsODguMSw1NzguNy03OS4xLDMyOC4zLTMyN2MtMTIuNywzMC41LTI5LjksNTYuNi01MS41LDc4LjJjLTI2LjcsMjYuNy01Ni42LDQ3LTg5LjYsNjFMMzMyLjEtNDIuOWwyMTAuNywyMTAuN0w2OTQuNCwzMTkuNHogTTE0NS4yLTIzOS4zYzMxLjgtNy42LDYxLTI1LjQsODcuNy01My40YzIxLjYtMjEuNiwzNi45LTQ3LDQ1LjgtNzYuM2MtMTIuNy0zLjgtNDIuOS0xNC05MC42LTMwLjVjLTQ3LjctMTYuNS04Mi4zLTI4LTEwMy45LTM0LjNjNi40LDE5LjEsMTYuOCw1Mi4xLDMxLjUsOTkuMkMxMzAuMy0yODcuNiwxNDAuMS0yNTUuOCwxNDUuMi0yMzkuM3ogTTg4OC45LDIyOS44bC01LjctNS43Yy0xMi43LDMzLjEtMzEuMSw2MS43LTU1LjMsODUuOEM4MDIuNSwzMzUuMyw3NzQuNSwzNTUsNzQ0LDM2OWwxLjksMS45bDEuOSwxLjljMjIuOSwyMi45LDQ3LjcsMzQuMyw3NC40LDM0LjNjMjIuOSwwLDQ1LjEtMTAuOCw2Ni43LTMyLjRjMjUuNC0yNC4yLDM4LjEtNDcuNywzOC4xLTcwLjZTOTE0LjQsMjU2LjUsODg4LjksMjI5Ljh6Ii8+PC9nPjwvZz4NCjwvc3ZnPg=="> </a><h1>Schema</h1>

<div class="api-content">
<h3 id="schema_Schema">Schema()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">[definition] <span class="method-type">«Object|Schema|Array»</span> Can be one of: object describing schema paths, or schema to copy, or array of objects and schemas </li>
<li class="param">[options] <span class="method-type">«Object»</span> </li>
</ul>
<h5>Inherits:</h5>
<ul><li><span class="method-type">«NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter»</span></li></ul>
<div>
<p>Schema constructor.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: <span class="hljs-built_in">String</span> });
<span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">Number</span>, <span class="hljs-attr">children</span>: [child] });
<span class="hljs-keyword">const</span> Tree = mongoose.model(<span class="hljs-string">'Tree'</span>, schema);

<span class="hljs-comment">// setting schema options</span>
<span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: <span class="hljs-built_in">String</span> }, { <span class="hljs-attr">_id</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">autoIndex</span>: <span class="hljs-literal">false</span> })</pre> <h4>Options:</h4> <ul> <li>
<a href="../guide#autoIndex">autoIndex</a>: bool - defaults to null (which means use the connection's autoIndex option)</li> <li>
<a href="../guide#autoCreate">autoCreate</a>: bool - defaults to null (which means use the connection's autoCreate option)</li> <li>
<a href="../guide#bufferCommands">bufferCommands</a>: bool - defaults to true</li> <li>
<a href="../guide#bufferTimeoutMS">bufferTimeoutMS</a>: number - defaults to 10000 (10 seconds). If <code>bufferCommands</code> is enabled, the amount of time Mongoose will wait for connectivity to be restablished before erroring out.</li> <li>
<a href="../guide#capped">capped</a>: bool - defaults to false</li> <li>
<a href="../guide#collection">collection</a>: string - no default</li> <li>
<a href="../guide#discriminatorKey">discriminatorKey</a>: string - defaults to <code>__t</code>
</li> <li>
<a href="../guide#id">id</a>: bool - defaults to true</li> <li>
<a href="../guide#_id">_id</a>: bool - defaults to true</li> <li>
<a href="../guide#minimize">minimize</a>: bool - controls <a href="#document_Document-toObject">document#toObject</a> behavior when called manually - defaults to true</li> <li>
<a href="../guide#read">read</a>: string</li> <li>
<a href="../guide#writeConcern">writeConcern</a>: object - defaults to null, use to override <a href="https://docs.mongodb.com/manual/reference/write-concern/">the MongoDB server's default write concern settings</a>
</li> <li>
<a href="../guide#shardKey">shardKey</a>: object - defaults to <code>null</code>
</li> <li>
<a href="../guide#strict">strict</a>: bool - defaults to true</li> <li>
<a href="../guide#strictQuery">strictQuery</a>: bool - defaults to false</li> <li>
<a href="../guide#toJSON">toJSON</a> - object - no default</li> <li>
<a href="../guide#toObject">toObject</a> - object - no default</li> <li>
<a href="../guide#typeKey">typeKey</a> - string - defaults to 'type'</li> <li>
<a href="../guide#validateBeforeSave">validateBeforeSave</a> - bool - defaults to <code>true</code>
</li> <li>
<a href="../guide#versionKey">versionKey</a>: string or object - defaults to "__v"</li> <li>
<a href="../guide#optimisticConcurrency">optimisticConcurrency</a>: bool - defaults to false. Set to true to enable <a href="https://thecodebarbarian.com/whats-new-in-mongoose-5-10-optimistic-concurrency.html">optimistic concurrency</a>.</li> <li>
<a href="../guide#collation">collation</a>: object - defaults to null (which means use no collation)</li> <li>
<a href="../guide#timeseries">timeseries</a>: object - defaults to null (which means this schema's collection won't be a timeseries collection)</li> <li>
<a href="../guide#selectPopulatedPaths">selectPopulatedPaths</a>: boolean - defaults to <code>true</code>
</li> <li>
<a href="../guide#skipVersioning">skipVersioning</a>: object - paths to exclude from versioning</li> <li>
<a href="../guide#timestamps">timestamps</a>: object or boolean - defaults to <code>false</code>. If true, Mongoose adds <code>createdAt</code> and <code>updatedAt</code> properties to your schema and manages those properties for you.</li> </ul> <h4>Options for Nested Schemas:</h4> <ul> <li>
<code>excludeIndexes</code>: bool - defaults to <code>false</code>. If <code>true</code>, skip building indexes on this schema's paths.</li> </ul> <h4>Note:</h4> <p><em>When nesting schemas, (<code>children</code> in the example above), always declare the child schema first before passing it into its parent.</em></p> </div>
<h3 id="schema_Schema.Types">Schema.Types</h3>
<h5>Type:</h5>
<ul><li><span class="method-type">«property»</span></li></ul>
<div>
<p>The various built-in Mongoose Schema Types.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);
<span class="hljs-keyword">const</span> ObjectId = mongoose.Schema.Types.ObjectId;</pre> <h4>Types:</h4> <ul> <li><a href="../schematypes#strings">String</a></li> <li><a href="../schematypes#numbers">Number</a></li> <li>
<a href="../schematypes#booleans">Boolean</a> | Bool</li> <li><a href="../schematypes#arrays">Array</a></li> <li><a href="../schematypes#buffers">Buffer</a></li> <li><a href="../schematypes#dates">Date</a></li> <li>
<a href="../schematypes#objectids">ObjectId</a> | Oid</li> <li><a href="../schematypes#mixed">Mixed</a></li> </ul> <p>Using this exposed access to the <code>Mixed</code> SchemaType, we can use them in our schema.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> Mixed = mongoose.Schema.Types.Mixed;
<span class="hljs-keyword">new</span> mongoose.Schema({ <span class="hljs-attr">_user</span>: Mixed })</pre> </div>
<h3 id="schema_Schema-indexTypes">Schema.indexTypes</h3>
<h5>Type:</h5>
<ul><li><span class="method-type">«property»</span></li></ul>
<div>
<p>The allowed index types</p> </div>
<h3 id="schema_Schema-add">Schema.prototype.add()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">obj <span class="method-type">«Object|Schema»</span> plain object with paths to add, or another schema </li>
<li class="param">[prefix] <span class="method-type">«String»</span> path to prefix the newly added paths with </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Schema»</span> the Schema instance </li></ul>
<div>
<p>Adds key path / schema type pairs to this schema.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> ToySchema = <span class="hljs-keyword">new</span> Schema();
ToySchema.add({ <span class="hljs-attr">name</span>: <span class="hljs-string">'string'</span>, <span class="hljs-attr">color</span>: <span class="hljs-string">'string'</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">'number'</span> });

<span class="hljs-keyword">const</span> TurboManSchema = <span class="hljs-keyword">new</span> Schema();
<span class="hljs-comment">// You can also `add()` another schema and copy over all paths, virtuals,</span>
<span class="hljs-comment">// getters, setters, indexes, methods, and statics.</span>
TurboManSchema.add(ToySchema).add({ <span class="hljs-attr">year</span>: <span class="hljs-built_in">Number</span> });</pre> </div>
<h3 id="schema_Schema-childSchemas">Schema.prototype.childSchemas</h3>
<h5>Type:</h5>
<ul><li><span class="method-type">«property»</span></li></ul>
<div>
<p>Array of child schemas (from document arrays and single nested subdocs) and their corresponding compiled models. Each element of the array is an object with 2 properties: <code>schema</code> and <code>model</code>.</p> <p>This property is typically only useful for plugin authors and advanced users. You do not need to interact with this property at all to use mongoose.</p> </div>
<h3 id="schema_Schema-clone">Schema.prototype.clone()</h3>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Schema»</span> the cloned schema </li></ul>
<div>
<p>Returns a deep copy of the schema</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: <span class="hljs-built_in">String</span> });
<span class="hljs-keyword">const</span> clone = schema.clone();
clone === schema; <span class="hljs-comment">// false</span>
clone.path(<span class="hljs-string">'name'</span>); <span class="hljs-comment">// SchemaString { ... }</span></pre> </div>
<h3 id="schema_Schema-eachPath">Schema.prototype.eachPath()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">fn <span class="method-type">«Function»</span> callback function </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Schema»</span> this </li></ul>
<div>
<p>Iterates the schemas paths similar to Array#forEach.</p> <p>The callback is passed the pathname and the schemaType instance.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">registeredAt</span>: <span class="hljs-built_in">Date</span> });
userSchema.eachPath(<span class="hljs-function">(<span class="hljs-params">pathname, schematype</span>) =&gt;</span> {
  <span class="hljs-comment">// Prints twice:</span>
  <span class="hljs-comment">// name SchemaString { ... }</span>
  <span class="hljs-comment">// registeredAt SchemaDate { ... }</span>
  <span class="hljs-built_in">console</span>.log(pathname, schematype);
});</pre> </div>
<h3 id="schema_Schema-get">Schema.prototype.get()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">key <span class="method-type">«String»</span> option name </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Any»</span> the option's value </li></ul>
<div>
<p>Gets a schema option.</p> <h4>Example:</h4> <pre data-language="javascript">schema.get(<span class="hljs-string">'strict'</span>); <span class="hljs-comment">// true</span>
schema.set(<span class="hljs-string">'strict'</span>, <span class="hljs-literal">false</span>);
schema.get(<span class="hljs-string">'strict'</span>); <span class="hljs-comment">// false</span></pre> </div>
<h3 id="schema_Schema-index">Schema.prototype.index()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">fields <span class="method-type">«Object»</span> </li>
<li class="param">[options] <span class="method-type">«Object»</span> Options to pass to <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#createIndex">MongoDB driver's <code>createIndex()</code> function</a> </li>
<li class="param">| <span class="method-type">«String»</span> number} [options.expires=null] Mongoose-specific syntactic sugar, uses <a href="https://www.npmjs.com/package/ms">ms</a> to convert <code>expires</code> option into seconds for the <code>expireAfterSeconds</code> in the above link. </li>
</ul>
<div>
<p>Defines an index (most likely compound) for this schema.</p> <h4>Example</h4> <pre data-language="javascript">schema.index({ <span class="hljs-attr">first</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">last</span>: <span class="hljs-number">-1</span> })</pre> </div>
<h3 id="schema_Schema-indexes">Schema.prototype.indexes()</h3>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Array»</span> list of indexes defined in the schema </li></ul>
<div>
<p>Returns a list of indexes that this schema declares, via <code>schema.index()</code> or by <code>index: true</code> in a path's options. Indexes are expressed as an array <code>[spec, options]</code>.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> Schema({
  <span class="hljs-attr">email</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span> },
  <span class="hljs-attr">registeredAt</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">Date</span>, <span class="hljs-attr">index</span>: <span class="hljs-literal">true</span> }
});

<span class="hljs-comment">// [ [ { email: 1 }, { unique: true, background: true } ],</span>
<span class="hljs-comment">//   [ { registeredAt: 1 }, { background: true } ] ]</span>
userSchema.indexes();</pre> <p><a href="../plugins">Plugins</a> can use the return value of this function to modify a schema's indexes. For example, the below plugin makes every index unique by default.</p> <pre data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myPlugin</span>(<span class="hljs-params">schema</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> index <span class="hljs-keyword">of</span> schema.indexes()) {
    <span class="hljs-keyword">if</span> (index[<span class="hljs-number">1</span>].unique === <span class="hljs-literal">undefined</span>) {
      index[<span class="hljs-number">1</span>].unique = <span class="hljs-literal">true</span>;
    }
  }
}</pre> </div>
<h3 id="schema_Schema-loadClass">Schema.prototype.loadClass()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">model <span class="method-type">«Function»</span> </li>
<li class="param">[virtualsOnly] <span class="method-type">«Boolean»</span> if truthy, only pulls virtuals from the class, not methods or statics </li>
</ul>
<div>
<p>Loads an ES6 class into a schema. Maps <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set">setters</a> + <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get">getters</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static">static methods</a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions">instance methods</a> to schema <a href="../guide#virtuals">virtuals</a>, <a href="../guide#statics">statics</a>, and <a href="../guide#methods">methods</a>.</p> <h4>Example:</h4> <div class="highlight"><pre lang="javascript" data-language="javascript">const md5 = require('md5');
const userSchema = new Schema({ email: String });
class UserClass {
  // `gravatarImage` becomes a virtual
  get gravatarImage() {
    const hash = md5(this.email.toLowerCase());
    return `<a href="#">https://www.gravatar.com/avatar/${hash}`</a>;
  }

  // `getProfileUrl()` becomes a document method
  getProfileUrl() {
    return `<a href="#">https://mysite.com/${this.email}`</a>;
  }

  // `findByEmail()` becomes a static
  static findByEmail(email) {
    return this.findOne({ email });
  }
}

// `schema` will now have a `gravatarImage` virtual, a `getProfileUrl()` method,
// and a `findByEmail()` static
userSchema.loadClass(UserClass);
</pre></div> </div>
<h3 id="schema_Schema-method">Schema.prototype.method()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">method <span class="method-type">«String|Object»</span> name </li>
<li class="param">[fn] <span class="method-type">«Function»</span> </li>
</ul>
<div>
<p>Adds an instance method to documents constructed from Models compiled from this schema.</p> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> schema = kittySchema = <span class="hljs-keyword">new</span> Schema(..);

schema.method(<span class="hljs-string">'meow'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> () </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'meeeeeoooooooooooow'</span>);
})

<span class="hljs-keyword">const</span> Kitty = mongoose.model(<span class="hljs-string">'Kitty'</span>, schema);

<span class="hljs-keyword">const</span> fizz = <span class="hljs-keyword">new</span> Kitty;
fizz.meow(); <span class="hljs-comment">// meeeeeooooooooooooow</span></pre> <p>If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.</p> <pre data-language="javascript">schema.method({
    <span class="hljs-attr">purr</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> () </span>{}
  , <span class="hljs-attr">scratch</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> () </span>{}
});

<span class="hljs-comment">// later</span>
fizz.purr();
fizz.scratch();</pre> <p>NOTE: <code>Schema.method()</code> adds instance methods to the <code>Schema.methods</code> object. You can also add instance methods directly to the <code>Schema.methods</code> object as seen in the <a href="../guide#methods">guide</a></p> </div>
<h3 id="schema_Schema-obj">Schema.prototype.obj</h3>
<h5>Type:</h5>
<ul><li><span class="method-type">«property»</span></li></ul>
<div>
<p>The original object passed to the schema constructor</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">a</span>: <span class="hljs-built_in">String</span> }).add({ <span class="hljs-attr">b</span>: <span class="hljs-built_in">String</span> });
schema.obj; <span class="hljs-comment">// { a: String }</span></pre> </div>
<h3 id="schema_Schema-path">Schema.prototype.path()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">path <span class="method-type">«String»</span> </li>
<li class="param">constructor <span class="method-type">«Object»</span> </li>
</ul>
<div>
<p>Gets/sets schema paths.</p> <p>Sets a path (if arity 2) Gets a path (if arity 1)</p> <h4>Example</h4> <pre data-language="javascript">schema.path(<span class="hljs-string">'name'</span>) <span class="hljs-comment">// returns a SchemaType</span>
schema.path(<span class="hljs-string">'name'</span>, <span class="hljs-built_in">Number</span>) <span class="hljs-comment">// changes the schemaType of `name` to Number</span></pre> </div>
<h3 id="schema_Schema-pathType">Schema.prototype.pathType()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">path <span class="method-type">«String»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«String»</span> </li></ul>
<div>
<p>Returns the pathType of <code>path</code> for this schema.</p> <p>Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">nested</span>: { <span class="hljs-attr">foo</span>: <span class="hljs-built_in">String</span> } });
s.virtual(<span class="hljs-string">'foo'</span>).get(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">42</span>);
s.pathType(<span class="hljs-string">'name'</span>); <span class="hljs-comment">// "real"</span>
s.pathType(<span class="hljs-string">'nested'</span>); <span class="hljs-comment">// "nested"</span>
s.pathType(<span class="hljs-string">'foo'</span>); <span class="hljs-comment">// "virtual"</span>
s.pathType(<span class="hljs-string">'fail'</span>); <span class="hljs-comment">// "adhocOrUndefined"</span></pre> </div>
<h3 id="schema_Schema-paths">Schema.prototype.paths</h3>
<h5>Type:</h5>
<ul><li><span class="method-type">«property»</span></li></ul>
<div>
<p>The paths defined on this schema. The keys are the top-level paths in this schema, and the values are instances of the SchemaType class.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: <span class="hljs-built_in">String</span> }, { <span class="hljs-attr">_id</span>: <span class="hljs-literal">false</span> });
schema.paths; <span class="hljs-comment">// { name: SchemaString { ... } }</span>

schema.add({ <span class="hljs-attr">age</span>: <span class="hljs-built_in">Number</span> });
schema.paths; <span class="hljs-comment">// { name: SchemaString { ... }, age: SchemaNumber { ... } }</span></pre> </div>
<h3 id="schema_Schema-pick">Schema.prototype.pick()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">paths <span class="method-type">«Array»</span> list of paths to pick </li>
<li class="param">[options] <span class="method-type">«Object»</span> options to pass to the schema constructor. Defaults to <code>this.options</code> if not set. </li>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Schema»</span> </li></ul>
<div>
<p>Returns a new schema that has the picked <code>paths</code> from this schema.</p> <p>This method is analagous to <a href="https://lodash.com/docs/4.17.15#pick">Lodash's <code>pick()</code> function</a> for Mongoose schemas.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> schema = Schema({ <span class="hljs-attr">name</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">Number</span> });
<span class="hljs-comment">// Creates a new schema with the same `name` path as `schema`,</span>
<span class="hljs-comment">// but no `age` path.</span>
<span class="hljs-keyword">const</span> newSchema = schema.pick([<span class="hljs-string">'name'</span>]);

newSchema.path(<span class="hljs-string">'name'</span>); <span class="hljs-comment">// SchemaString { ... }</span>
newSchema.path(<span class="hljs-string">'age'</span>); <span class="hljs-comment">// undefined</span></pre> </div>
<h3 id="schema_Schema-plugin">Schema.prototype.plugin()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">plugin <span class="method-type">«Function»</span> callback </li>
<li class="param">[opts] <span class="method-type">«Object»</span> </li>
</ul>
<div>
<p>Registers a plugin for this schema.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: <span class="hljs-built_in">String</span> });
s.plugin(<span class="hljs-function"><span class="hljs-params">schema</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(schema.path(<span class="hljs-string">'name'</span>).path));
mongoose.model(<span class="hljs-string">'Test'</span>, s); <span class="hljs-comment">// Prints 'name'</span></pre> </div>
<h3 id="schema_Schema-post">Schema.prototype.post()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">The <span class="method-type">«String|RegExp»</span> method name or regular expression to match method name </li>
<li class="param">[options] <span class="method-type">«Object»</span> </li>
<ul style="margin-top: 0.5em"><li>[options.document] <span class="method-type">«Boolean»</span> If <code>name</code> is a hook for both document and query middleware, set to <code>true</code> to run on document middleware. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.query] <span class="method-type">«Boolean»</span> If <code>name</code> is a hook for both document and query middleware, set to <code>true</code> to run on query middleware. </li></ul>
<li class="param">fn <span class="method-type">«Function»</span> callback </li>
</ul>
<div>
<p>Defines a post hook for the document</p> <pre data-language="javascript">const schema = new Schema(..);
schema.post('save', function (doc) {
  console.log('this fired after a document was saved');
});

schema.post('find', function(docs) {
  console.log('this fired after you ran a find query');
});

schema.post(/Many$/, function(res) {
  console.log('this fired after you ran `updateMany()` or `deleteMany()`);
});

const Model = mongoose.model('Model', schema);

const m = new Model(..);
m.save(function(err) {
  console.log('this fires after the `post` hook');
});

m.find(function(err, docs) {
  console.log('this fires after the post find hook');
});</pre> </div>
<h3 id="schema_Schema-pre">Schema.prototype.pre()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">The <span class="method-type">«String|RegExp»</span> method name or regular expression to match method name </li>
<li class="param">[options] <span class="method-type">«Object»</span> </li>
<ul style="margin-top: 0.5em"><li>[options.document] <span class="method-type">«Boolean»</span> If <code>name</code> is a hook for both document and query middleware, set to <code>true</code> to run on document middleware. For example, set <code>options.document</code> to <code>true</code> to apply this hook to <code>Document#deleteOne()</code> rather than <code>Query#deleteOne()</code>. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.query] <span class="method-type">«Boolean»</span> If <code>name</code> is a hook for both document and query middleware, set to <code>true</code> to run on query middleware. </li></ul>
<li class="param">callback <span class="method-type">«Function»</span> </li>
</ul>
<div>
<p>Defines a pre hook for the model.</p> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> toySchema = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">created</span>: <span class="hljs-built_in">Date</span> });

toySchema.pre(<span class="hljs-string">'save'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.created) <span class="hljs-keyword">this</span>.created = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>;
  next();
});

toySchema.pre(<span class="hljs-string">'validate'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.name !== <span class="hljs-string">'Woody'</span>) <span class="hljs-keyword">this</span>.name = <span class="hljs-string">'Woody'</span>;
  next();
});

<span class="hljs-comment">// Equivalent to calling `pre()` on `find`, `findOne`, `findOneAndUpdate`.</span>
toySchema.pre(<span class="hljs-regexp">/^find/</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.getFilter());
});

<span class="hljs-comment">// Equivalent to calling `pre()` on `updateOne`, `findOneAndUpdate`.</span>
toySchema.pre([<span class="hljs-string">'updateOne'</span>, <span class="hljs-string">'findOneAndUpdate'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.getFilter());
});

toySchema.pre(<span class="hljs-string">'deleteOne'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
  <span class="hljs-comment">// Runs when you call `Toy.deleteOne()`</span>
});

toySchema.pre(<span class="hljs-string">'deleteOne'</span>, { <span class="hljs-attr">document</span>: <span class="hljs-literal">true</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
  <span class="hljs-comment">// Runs when you call `doc.deleteOne()`</span>
});</pre> </div>
<h3 id="schema_Schema-queue">Schema.prototype.queue()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">name <span class="method-type">«String»</span> name of the document method to call later </li>
<li class="param">args <span class="method-type">«Array»</span> arguments to pass to the method </li>
</ul>
<div>
<p>Adds a method call to the queue.</p> <h4>Example:</h4> <pre data-language="javascript">schema.methods.print = <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>); };
schema.queue(<span class="hljs-string">'print'</span>, []); <span class="hljs-comment">// Print the doc every one is instantiated</span>

<span class="hljs-keyword">const</span> Model = mongoose.model(<span class="hljs-string">'Test'</span>, schema);
<span class="hljs-keyword">new</span> Model({ <span class="hljs-attr">name</span>: <span class="hljs-string">'test'</span> }); <span class="hljs-comment">// Prints '{"_id": ..., "name": "test" }'</span></pre> </div>
<h3 id="schema_Schema-remove">Schema.prototype.remove()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">path <span class="method-type">«String|Array»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Schema»</span> the Schema instance </li></ul>
<div>
<p>Removes the given <code>path</code> (or [<code>paths</code>]).</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({ <span class="hljs-attr">name</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">Number</span> });
schema.remove(<span class="hljs-string">'name'</span>);
schema.path(<span class="hljs-string">'name'</span>); <span class="hljs-comment">// Undefined</span>
schema.path(<span class="hljs-string">'age'</span>); <span class="hljs-comment">// SchemaNumber { ... }</span></pre> </div>
<h3 id="schema_Schema-requiredPaths">Schema.prototype.requiredPaths()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">invalidate <span class="method-type">«Boolean»</span> refresh the cache </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«Array»</span> </li></ul>
<div>
<p>Returns an Array of path strings that are required by this schema.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> Schema({
  <span class="hljs-attr">name</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> },
  <span class="hljs-attr">age</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> },
  <span class="hljs-attr">notes</span>: <span class="hljs-built_in">String</span>
});
s.requiredPaths(); <span class="hljs-comment">// [ 'age', 'name' ]</span></pre> </div>
<h3 id="schema_Schema-set">Schema.prototype.set()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">key <span class="method-type">«String»</span> option name </li>
<li class="param">[value] <span class="method-type">«Object»</span> if not passed, the current option value is returned </li>
</ul>
<div>
<p>Sets a schema option.</p> <h4>Example</h4> <pre data-language="javascript">schema.set(<span class="hljs-string">'strict'</span>); <span class="hljs-comment">// 'true' by default</span>
schema.set(<span class="hljs-string">'strict'</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// Sets 'strict' to false</span>
schema.set(<span class="hljs-string">'strict'</span>); <span class="hljs-comment">// 'false'</span></pre> </div>
<h3 id="schema_Schema-static">Schema.prototype.static()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">name <span class="method-type">«String|Object»</span> </li>
<li class="param">[fn] <span class="method-type">«Function»</span> </li>
</ul>
<div>
<p>Adds static "class" methods to Models compiled from this schema.</p> <h4>Example</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema(..);
<span class="hljs-comment">// Equivalent to `schema.statics.findByName = function(name) {}`;</span>
schema.static(<span class="hljs-string">'findByName'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.find({ <span class="hljs-attr">name</span>: name });
});

<span class="hljs-keyword">const</span> Drink = mongoose.model(<span class="hljs-string">'Drink'</span>, schema);
<span class="hljs-keyword">await</span> Drink.findByName(<span class="hljs-string">'LaCroix'</span>);</pre> <p>If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.</p> </div>
<h3 id="schema_Schema-virtual">Schema.prototype.virtual()</h3>
<h5>Parameters</h5>
<ul class="params">
<li class="param">name <span class="method-type">«String»</span> </li>
<li class="param">[options] <span class="method-type">«Object»</span> </li>
<ul style="margin-top: 0.5em"><li>[options.ref] <span class="method-type">«String|Model»</span> model name or model instance. Marks this as a <a href="../populate#populate-virtuals">populate virtual</a>. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.localField] <span class="method-type">«String|Function»</span> Required for populate virtuals. See <a href="../populate#populate-virtuals">populate virtual docs</a> for more information. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.foreignField] <span class="method-type">«String|Function»</span> Required for populate virtuals. See <a href="../populate#populate-virtuals">populate virtual docs</a> for more information. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.justOne=false] <span class="method-type">«Boolean|Function»</span> Only works with populate virtuals. If <a href="https://masteringjs.io/tutorials/fundamentals/truthy">truthy</a>, will be a single doc or <code>null</code>. Otherwise, the populate virtual will be an array. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.count=false] <span class="method-type">«Boolean»</span> Only works with populate virtuals. If <a href="https://masteringjs.io/tutorials/fundamentals/truthy">truthy</a>, this populate virtual will contain the number of documents rather than the documents themselves when you <code>populate()</code>. </li></ul>
<ul style="margin-top: 0.5em"><li>[options.get=null] <span class="method-type">«Function|null»</span> Adds a <a href="../tutorials/getters-setters">getter</a> to this virtual to transform the populated doc. </li></ul>
</ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«VirtualType»</span> </li></ul>
<div>
<p>Creates a virtual type with the given name.</p> </div>
<h3 id="schema_Schema-virtualpath">Schema.prototype.virtualpath()</h3>
<h5>Parameters</h5>
<ul class="params"><li class="param">name <span class="method-type">«String»</span> </li></ul>
<h5>Returns:</h5>
<ul><li>
<span class="method-type">«VirtualType»</span> </li></ul>
<div>
<p>Returns the virtual type with the given <code>name</code>.</p> </div>
<h3 id="schema_Schema-virtuals">Schema.prototype.virtuals</h3>
<h5>Type:</h5>
<ul><li><span class="method-type">«property»</span></li></ul>
<div>
<p>Object containing all virtuals defined on this schema. The objects' keys are the virtual paths and values are instances of <code>VirtualType</code>.</p> <p>This property is typically only useful for plugin authors and advanced users. You do not need to interact with this property at all to use mongoose.</p> <h4>Example:</h4> <pre data-language="javascript"><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({});
schema.virtual(<span class="hljs-string">'answer'</span>).get(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">42</span>);

<span class="hljs-built_in">console</span>.log(schema.virtuals); <span class="hljs-comment">// { answer: VirtualType { path: 'answer', ... } }</span>
<span class="hljs-built_in">console</span>.log(schema.virtuals[<span class="hljs-string">'answer'</span>].getters[<span class="hljs-number">0</span>].call()); <span class="hljs-comment">// 42</span></pre> </div>
<h3 id="schema_Schema.reserved">Schema.reserved</h3>
<h5>Type:</h5>
<ul><li><span class="method-type">«property»</span></li></ul>
<div>
<p>Reserved document keys.</p> <p>Keys in this object are names that are warned in schema declarations because they have the potential to break Mongoose/ Mongoose plugins functionality. If you create a schema using <code>new Schema()</code> with one of these property names, Mongoose will log a warning.</p> <ul> <li>_posts</li> <li>_pres</li> <li>collection</li> <li>emit</li> <li>errors</li> <li>get</li> <li>init</li> <li>isModified</li> <li>isNew</li> <li>listeners</li> <li>modelName</li> <li>on</li> <li>once</li> <li>populated</li> <li>prototype</li> <li>remove</li> <li>removeListener</li> <li>save</li> <li>schema</li> <li>toObject</li> <li>validate</li> </ul> <p><em>NOTE:</em> Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema(..);
 schema.methods.init = <span class="hljs-function"><span class="hljs-keyword">function</span> () </span>{} <span class="hljs-comment">// potentially breaking</span></pre> </div>
</div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://mongoosejs.com/docs/api/schema.html" class="_attribution-link" target="_blank">https://mongoosejs.com/docs/api/schema.html</a>
  </p>
</div>
