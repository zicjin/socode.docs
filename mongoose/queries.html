<a class="edit-docs-link" href="https://github.com/Automattic/mongoose/blob/master/docs/queries.md" target="_blank"> <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHZpZXdCb3g9IjAgMCAxMDAwIDEwMDAiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDEwMDAgMTAwMCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8Zz48ZyB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAtMSAwIDQ4MCkiPjxwYXRoIHN0cm9rZT0iIzA5NzFCMiIgZmlsbD0iIzA5NzFCMiIgZD0iTTkzMC45LDQyMC41Yy0zMy4xLDMxLjgtNjkuMyw0Ny43LTEwOC43LDQ3LjdjLTQ0LjUsMC04My45LTE3LjItMTE4LjItNTEuNUw5OS40LTE4NS45Yy0zLjgtMy44LTYuNC04LjktNy42LTE1LjNjLTIuNS04LjktMjkuMi05Ny45LTgwLjEtMjY3Yy0zLjgtMTIuNy0xLjMtMjMuNSw3LjYtMzIuNGM2LjQtNS4xLDE0LTcuNiwyMi45LTcuNmg5LjVjMTMyLjIsNDQuNSwyMTkuOSw3My4xLDI2My4yLDg1LjhjMy44LDEuMyw3LjYsMy44LDExLjQsNy42YzM3NSwzNzAsNTc3LjIsNTcwLjIsNjA2LjQsNjAwLjdjMzguMSwzOS40LDU3LjIsNzkuNSw1Ny4yLDEyMC4xQzk4OC43LDM0Ni44LDk2OSwzODQuOSw5MzAuOSw0MjAuNXogTTY5NC40LDMxOS40YzMxLjgtNy42LDYxLjctMjUuNCw4OS42LTUzLjRjMjYuNy0yNi43LDQzLjItNTcuMiw0OS42LTkxLjVDNzQ3LjIsODguMSw1NzguNy03OS4xLDMyOC4zLTMyN2MtMTIuNywzMC41LTI5LjksNTYuNi01MS41LDc4LjJjLTI2LjcsMjYuNy01Ni42LDQ3LTg5LjYsNjFMMzMyLjEtNDIuOWwyMTAuNywyMTAuN0w2OTQuNCwzMTkuNHogTTE0NS4yLTIzOS4zYzMxLjgtNy42LDYxLTI1LjQsODcuNy01My40YzIxLjYtMjEuNiwzNi45LTQ3LDQ1LjgtNzYuM2MtMTIuNy0zLjgtNDIuOS0xNC05MC42LTMwLjVjLTQ3LjctMTYuNS04Mi4zLTI4LTEwMy45LTM0LjNjNi40LDE5LjEsMTYuOCw1Mi4xLDMxLjUsOTkuMkMxMzAuMy0yODcuNiwxNDAuMS0yNTUuOCwxNDUuMi0yMzkuM3ogTTg4OC45LDIyOS44bC01LjctNS43Yy0xMi43LDMzLjEtMzEuMSw2MS43LTU1LjMsODUuOEM4MDIuNSwzMzUuMyw3NzQuNSwzNTUsNzQ0LDM2OWwxLjksMS45bDEuOSwxLjljMjIuOSwyMi45LDQ3LjcsMzQuMyw3NC40LDM0LjNjMjIuOSwwLDQ1LjEtMTAuOCw2Ni43LTMyLjRjMjUuNC0yNC4yLDM4LjEtNDcuNywzOC4xLTcwLjZTOTE0LjQsMjU2LjUsODg4LjksMjI5Ljh6Ii8+PC9nPjwvZz4NCjwvc3ZnPg=="> </a><h1 id="queries">Queries</h1>   <p>Mongoose <a href="models">models</a> provide several static helper functions for <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD operations</a>. Each of these functions returns a <a href="http://mongoosejs.com/docs/api.html#Query">mongoose <code>Query</code> object</a>.</p> <ul> <li><a href="https://mongoosejs.com/docs/api.html#model_Model.deleteMany"><code>Model.deleteMany()</code></a></li> <li><a href="https://mongoosejs.com/docs/api.html#model_Model.deleteOne"><code>Model.deleteOne()</code></a></li> <li><a href="https://mongoosejs.com/docs/api.html#model_Model.find"><code>Model.find()</code></a></li> <li><a href="https://mongoosejs.com/docs/api.html#model_Model.findById"><code>Model.findById()</code></a></li> <li><a href="https://mongoosejs.com/docs/api.html#model_Model.findByIdAndDelete"><code>Model.findByIdAndDelete()</code></a></li> <li><a href="https://mongoosejs.com/docs/api.html#model_Model.findByIdAndRemove"><code>Model.findByIdAndRemove()</code></a></li> <li><a href="https://mongoosejs.com/docs/api.html#model_Model.findByIdAndUpdate"><code>Model.findByIdAndUpdate()</code></a></li> <li><a href="https://mongoosejs.com/docs/api.html#model_Model.findOne"><code>Model.findOne()</code></a></li> <li><a href="https://mongoosejs.com/docs/api.html#model_Model.findOneAndDelete"><code>Model.findOneAndDelete()</code></a></li> <li><a href="https://mongoosejs.com/docs/api.html#model_Model.findOneAndRemove"><code>Model.findOneAndRemove()</code></a></li> <li><a href="https://mongoosejs.com/docs/api.html#model_Model.findOneAndReplace"><code>Model.findOneAndReplace()</code></a></li> <li><a href="https://mongoosejs.com/docs/api.html#model_Model.findOneAndUpdate"><code>Model.findOneAndUpdate()</code></a></li> <li><a href="https://mongoosejs.com/docs/api.html#model_Model.replaceOne"><code>Model.replaceOne()</code></a></li> <li><a href="https://mongoosejs.com/docs/api.html#model_Model.updateMany"><code>Model.updateMany()</code></a></li> <li><a href="https://mongoosejs.com/docs/api.html#model_Model.updateOne"><code>Model.updateOne()</code></a></li> </ul> <p>A mongoose query can be executed in one of two ways. First, if you pass in a <code>callback</code> function, Mongoose will execute the query asynchronously and pass the results to the <code>callback</code>.</p> <p>A query also has a <code>.then()</code> function, and thus can be used as a promise.</p>  <h2 id="executing">Executing</h2> <p>When executing a query with a <code>callback</code> function, you specify your query as a JSON document. The JSON document's syntax is the same as the <a href="http://docs.mongodb.org/manual/tutorial/query-documents/">MongoDB shell</a>.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> Person = mongoose.model(<span class="hljs-string">'Person'</span>, yourSchema);

<span class="hljs-comment">// find each person with a last name matching 'Ghost', selecting the `name` and `occupation` fields</span>
Person.findOne({ <span class="hljs-string">'name.last'</span>: <span class="hljs-string">'Ghost'</span> }, <span class="hljs-string">'name occupation'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, person</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
  <span class="hljs-comment">// Prints "Space Ghost is a talk show host".</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'%s %s is a %s.'</span>, person.name.first, person.name.last,
    person.occupation);
});</pre> <p>Mongoose executed the query and passed the results to <code>callback</code>. All callbacks in Mongoose use the pattern: <code>callback(error, result)</code>. If an error occurs executing the query, the <code>error</code> parameter will contain an error document, and <code>result</code> will be null. If the query is successful, the <code>error</code> parameter will be null, and the <code>result</code> will be populated with the results of the query.</p> <p>Anywhere a callback is passed to a query in Mongoose, the callback follows the pattern <code>callback(error, results)</code>. What <code>results</code> is depends on the operation: For <code>findOne()</code> it is a <a href="https://mongoosejs.com/docs/api.html#model_Model.findOne">potentially-null single document</a>, <code>find()</code> a <a href="https://mongoosejs.com/docs/api.html#model_Model.find">list of documents</a>, <code>count()</code> <a href="https://mongoosejs.com/docs/api.html#model_Model.count">the number of documents</a>, <code>update()</code> the <a href="https://mongoosejs.com/docs/api.html#model_Model.update">number of documents affected</a>, etc. The <a href="https://mongoosejs.com/docs/api.html#model-js">API docs for Models</a> provide more detail on what is passed to the callbacks.</p> <p>Now let's look at what happens when no <code>callback</code> is passed:</p> <pre data-language="javascript"><span class="hljs-comment">// find each person with a last name matching 'Ghost'</span>
<span class="hljs-keyword">const</span> query = Person.findOne({ <span class="hljs-string">'name.last'</span>: <span class="hljs-string">'Ghost'</span> });

<span class="hljs-comment">// selecting the `name` and `occupation` fields</span>
query.select(<span class="hljs-string">'name occupation'</span>);

<span class="hljs-comment">// execute the query at a later time</span>
query.exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, person</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
  <span class="hljs-comment">// Prints "Space Ghost is a talk show host."</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'%s %s is a %s.'</span>, person.name.first, person.name.last,
    person.occupation);
});</pre> <p>In the above code, the <code>query</code> variable is of type <a href="https://mongoosejs.com/docs/api.html#query-js">Query</a>. A <code>Query</code> enables you to build up a query using chaining syntax, rather than specifying a JSON object. The below 2 examples are equivalent.</p> <pre data-language="javascript"><span class="hljs-comment">// With a JSON doc</span>
Person.
  find({
    <span class="hljs-attr">occupation</span>: <span class="hljs-regexp">/host/</span>,
    <span class="hljs-string">'name.last'</span>: <span class="hljs-string">'Ghost'</span>,
    <span class="hljs-attr">age</span>: { <span class="hljs-attr">$gt</span>: <span class="hljs-number">17</span>, <span class="hljs-attr">$lt</span>: <span class="hljs-number">66</span> },
    <span class="hljs-attr">likes</span>: { <span class="hljs-attr">$in</span>: [<span class="hljs-string">'vaporizing'</span>, <span class="hljs-string">'talking'</span>] }
  }).
  limit(<span class="hljs-number">10</span>).
  sort({ <span class="hljs-attr">occupation</span>: <span class="hljs-number">-1</span> }).
  select({ <span class="hljs-attr">name</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">occupation</span>: <span class="hljs-number">1</span> }).
  exec(callback);

<span class="hljs-comment">// Using query builder</span>
Person.
  find({ <span class="hljs-attr">occupation</span>: <span class="hljs-regexp">/host/</span> }).
  where(<span class="hljs-string">'name.last'</span>).equals(<span class="hljs-string">'Ghost'</span>).
  where(<span class="hljs-string">'age'</span>).gt(<span class="hljs-number">17</span>).lt(<span class="hljs-number">66</span>).
  where(<span class="hljs-string">'likes'</span>).in([<span class="hljs-string">'vaporizing'</span>, <span class="hljs-string">'talking'</span>]).
  limit(<span class="hljs-number">10</span>).
  sort(<span class="hljs-string">'-occupation'</span>).
  select(<span class="hljs-string">'name occupation'</span>).
  exec(callback);</pre> <p>A full list of <a href="https://mongoosejs.com/docs/api.html#query-js">Query helper functions can be found in the API docs</a>.</p> <h2 id="queries-are-not-promises">  Queries are Not Promises  </h2> <p>Mongoose queries are <strong>not</strong> promises. They have a <code>.then()</code> function for <a href="https://www.npmjs.com/package/co">co</a> and <a href="http://thecodebarbarian.com/common-async-await-design-patterns-in-node.js.html">async/await</a> as a convenience. However, unlike promises, calling a query's <code>.then()</code> can execute the query multiple times.</p> <p>For example, the below code will execute 3 <code>updateMany()</code> calls, one because of the callback, and two because <code>.then()</code> is called twice.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> q = MyModel.updateMany({}, { <span class="hljs-attr">isDeleted</span>: <span class="hljs-literal">true</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Update 1'</span>);
});

q.then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Update 2'</span>));
q.then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Update 3'</span>));</pre> <p>Don't mix using callbacks and promises with queries, or you may end up with duplicate operations. That's because passing a callback to a query function immediately executes the query, and calling <a href="https://masteringjs.io/tutorials/fundamentals/then"><code>then()</code></a> executes the query again.</p> <p>Mixing promises and callbacks can lead to duplicate entries in arrays. For example, the below code inserts 2 entries into the <code>tags</code> array, *<em>not</em> just 1.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> BlogPost = mongoose.model(<span class="hljs-string">'BlogPost'</span>, <span class="hljs-keyword">new</span> Schema({
  <span class="hljs-attr">title</span>: <span class="hljs-built_in">String</span>,
  <span class="hljs-attr">tags</span>: [<span class="hljs-built_in">String</span>]
}));

<span class="hljs-comment">// Because there's both `await` **and** a callback, this `updateOne()` executes twice</span>
<span class="hljs-comment">// and thus pushes the same string into `tags` twice.</span>
<span class="hljs-keyword">const</span> update = { <span class="hljs-attr">$push</span>: { <span class="hljs-attr">tags</span>: [<span class="hljs-string">'javascript'</span>] } };
<span class="hljs-keyword">await</span> BlogPost.updateOne({ <span class="hljs-attr">title</span>: <span class="hljs-string">'Introduction to Promises'</span> }, update, (err, res) =&gt; {
  <span class="hljs-built_in">console</span>.log(res);
});</pre> <h2 id="refs">References to other documents</h2> <p>There are no joins in MongoDB but sometimes we still want references to documents in other collections. This is where <a href="populate">population</a> comes in. Read more about how to include documents from other collections in your query results <a href="https://mongoosejs.com/docs/api.html#query_Query-populate">here</a>.</p> <h2 id="streaming">Streaming</h2> <p>You can <a href="http://nodejs.org/api/stream.html">stream</a> query results from MongoDB. You need to call the <a href="https://mongoosejs.com/docs/api.html#query_Query-cursor">Query#cursor()</a> function to return an instance of <a href="https://mongoosejs.com/docs/api.html#query_Query-cursor">QueryCursor</a>.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> cursor = Person.find({ <span class="hljs-attr">occupation</span>: <span class="hljs-regexp">/host/</span> }).cursor();

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> doc = <span class="hljs-keyword">await</span> cursor.next(); doc != <span class="hljs-literal">null</span>; doc = <span class="hljs-keyword">await</span> cursor.next()) {
  <span class="hljs-built_in">console</span>.log(doc); <span class="hljs-comment">// Prints documents one at a time</span>
}</pre> <p>Iterating through a Mongoose query using <a href="https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js.html">async iterators</a> also creates a cursor.</p> <pre data-language="javascript"><span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> doc <span class="hljs-keyword">of</span> Person.find()) {
  <span class="hljs-built_in">console</span>.log(doc); <span class="hljs-comment">// Prints documents one at a time</span>
}</pre> <p>Cursors are subject to <a href="https://stackoverflow.com/questions/21853178/when-a-mongodb-cursor-will-expire">cursor timeouts</a>. By default, MongoDB will close your cursor after 10 minutes and subsequent <code>next()</code> calls will result in a <code>MongoError: cursor id 123 not found</code> error. To override this, set the <code>noCursorTimeout</code> option on your cursor.</p> <pre data-language="javascript"><span class="hljs-comment">// MongoDB won't automatically close this cursor after 10 minutes.</span>
<span class="hljs-keyword">const</span> cursor = Person.find().cursor().addCursorFlag(<span class="hljs-string">'noCursorTimeout'</span>, <span class="hljs-literal">true</span>);</pre> <p>However, cursors can still time out because of <a href="https://docs.mongodb.com/manual/reference/method/cursor.noCursorTimeout/#session-idle-timeout-overrides-nocursortimeout">session idle timeouts</a>. So even a cursor with <code>noCursorTimeout</code> set will still time out after 30 minutes of inactivity. You can read more about working around session idle timeouts in the <a href="https://docs.mongodb.com/manual/reference/method/cursor.noCursorTimeout/#session-idle-timeout-overrides-nocursortimeout">MongoDB documentation</a>.</p> <h2 id="versus-aggregation">Versus Aggregation</h2> <p><a href="https://mongoosejs.com/docs/api.html#aggregate_Aggregate">Aggregation</a> can do many of the same things that queries can. For example, below is how you can use <code>aggregate()</code> to find docs where <code>name.last = 'Ghost'</code>:</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> docs = <span class="hljs-keyword">await</span> Person.aggregate([{ <span class="hljs-attr">$match</span>: { <span class="hljs-string">'name.last'</span>: <span class="hljs-string">'Ghost'</span> } }]);</pre> <p>However, just because you can use <code>aggregate()</code> doesn't mean you should. In general, you should use queries where possible, and only use <code>aggregate()</code> when you absolutely need to.</p> <p>Unlike query results, Mongoose does <strong>not</strong> <a href="api/model#model_Model.hydrate"><code>hydrate()</code></a> aggregation results. Aggregation results are always POJOs, not Mongoose documents.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> docs = <span class="hljs-keyword">await</span> Person.aggregate([{ <span class="hljs-attr">$match</span>: { <span class="hljs-string">'name.last'</span>: <span class="hljs-string">'Ghost'</span> } }]);

docs[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> mongoose.Document; <span class="hljs-comment">// false</span></pre> <p>Also, unlike query filters, Mongoose also doesn't <a href="tutorials/query_casting">cast</a> aggregation pipelines. That means you're responsible for ensuring the values you pass in to an aggregation pipeline have the correct type.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> doc = <span class="hljs-keyword">await</span> Person.findOne();

<span class="hljs-keyword">const</span> idString = doc._id.toString();

<span class="hljs-comment">// Finds the `Person`, because Mongoose casts `idString` to an ObjectId</span>
<span class="hljs-keyword">const</span> queryRes = <span class="hljs-keyword">await</span> Person.findOne({ <span class="hljs-attr">_id</span>: idString });

<span class="hljs-comment">// Does **not** find the `Person`, because Mongoose doesn't cast aggregation</span>
<span class="hljs-comment">// pipelines.</span>
<span class="hljs-keyword">const</span> aggRes = <span class="hljs-keyword">await</span> Person.aggregate([{ <span class="hljs-attr">$match</span>: { <span class="hljs-attr">_id</span>: idString } }])</pre> <h2 id="next">Next Up</h2> <p>Now that we've covered <code>Queries</code>, let's take a look at <a href="validation">Validation</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://mongoosejs.com/docs/queries.html" class="_attribution-link" target="_blank">https://mongoosejs.com/docs/queries.html</a>
  </p>
</div>
