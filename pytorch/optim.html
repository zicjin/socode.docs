<h1 id="torch-optim">torch.optim</h1> <p id="module-torch.optim"><a class="reference internal" href="#module-torch.optim" title="torch.optim"><code>torch.optim</code></a> is a package implementing various optimization algorithms. Most commonly used methods are already supported, and the interface is general enough, so that more sophisticated ones can be also easily integrated in the future.</p>  <h2 id="how-to-use-an-optimizer">How to use an optimizer</h2> <p>To use <a class="reference internal" href="#module-torch.optim" title="torch.optim"><code>torch.optim</code></a> you have to construct an optimizer object, that will hold the current state and will update the parameters based on the computed gradients.</p>  <h3 id="constructing-it">Constructing it</h3> <p>To construct an <a class="reference internal" href="#torch.optim.Optimizer" title="torch.optim.Optimizer"><code>Optimizer</code></a> you have to give it an iterable containing the parameters (all should be <code>Variable</code> s) to optimize. Then, you can specify optimizer-specific options such as the learning rate, weight decay, etc.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you need to move a model to GPU via <code>.cuda()</code>, please do so before constructing optimizers for it. Parameters of a model after <code>.cuda()</code> will be different objects with those before the call.</p> <p>In general, you should make sure that optimized parameters live in consistent locations when optimizers are constructed and used.</p> </div> <p>Example:</p> <pre data-language="python">optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.9)
optimizer = optim.Adam([var1, var2], lr=0.0001)
</pre>   <h3 id="per-parameter-options">Per-parameter options</h3> <p><a class="reference internal" href="#torch.optim.Optimizer" title="torch.optim.Optimizer"><code>Optimizer</code></a> s also support specifying per-parameter options. To do this, instead of passing an iterable of <code>Variable</code> s, pass in an iterable of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><code>dict</code></a> s. Each of them will define a separate parameter group, and should contain a <code>params</code> key, containing a list of parameters belonging to it. Other keys should match the keyword arguments accepted by the optimizers, and will be used as optimization options for this group.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>You can still pass options as keyword arguments. They will be used as defaults, in the groups that didn’t override them. This is useful when you only want to vary a single option, while keeping all others consistent between parameter groups.</p> </div> <p>For example, this is very useful when one wants to specify per-layer learning rates:</p> <pre data-language="python">optim.SGD([
                {'params': model.base.parameters()},
                {'params': model.classifier.parameters(), 'lr': 1e-3}
            ], lr=1e-2, momentum=0.9)
</pre> <p>This means that <code>model.base</code>’s parameters will use the default learning rate of <code>1e-2</code>, <code>model.classifier</code>’s parameters will use a learning rate of <code>1e-3</code>, and a momentum of <code>0.9</code> will be used for all parameters.</p>   <h3 id="taking-an-optimization-step">Taking an optimization step</h3> <p>All optimizers implement a <a class="reference internal" href="#torch.optim.Optimizer.step" title="torch.optim.Optimizer.step"><code>step()</code></a> method, that updates the parameters. It can be used in two ways:</p>  <h4 id="optimizer-step"><code>optimizer.step()</code></h4> <p>This is a simplified version supported by most optimizers. The function can be called once the gradients are computed using e.g. <code>backward()</code>.</p> <p>Example:</p> <pre data-language="python">for input, target in dataset:
    optimizer.zero_grad()
    output = model(input)
    loss = loss_fn(output, target)
    loss.backward()
    optimizer.step()
</pre>   <h4 id="optimizer-step-closure"><code>optimizer.step(closure)</code></h4> <p>Some optimization algorithms such as Conjugate Gradient and LBFGS need to reevaluate the function multiple times, so you have to pass in a closure that allows them to recompute your model. The closure should clear the gradients, compute the loss, and return it.</p> <p>Example:</p> <pre data-language="python">for input, target in dataset:
    def closure():
        optimizer.zero_grad()
        output = model(input)
        loss = loss_fn(output, target)
        loss.backward()
        return loss
    optimizer.step(closure)
</pre>     <h2 id="optimizer-algorithms">Algorithms</h2> <dl class="class" id="algorithms"> <dt id="torch.optim.Optimizer">
<code>class torch.optim.Optimizer(params, defaults)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/optimizer.html#Optimizer"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Base class for all optimizers.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Parameters need to be specified as collections that have a deterministic ordering that is consistent between runs. Examples of objects that don’t satisfy those properties are sets and iterators over values of dictionaries.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>params</strong> (<em>iterable</em>) – an iterable of <a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor"><code>torch.Tensor</code></a> s or <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><code>dict</code></a> s. Specifies what Tensors should be optimized.</li> <li>
<strong>defaults</strong> – (dict): a dict containing default values of optimization options (used when a parameter group doesn’t specify them).</li> </ul> </dd> </dl> <dl class="method"> <dt id="torch.optim.Optimizer.add_param_group">
<code>add_param_group(param_group)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/optimizer.html#Optimizer.add_param_group"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add a param group to the <a class="reference internal" href="#torch.optim.Optimizer" title="torch.optim.Optimizer"><code>Optimizer</code></a> s <code>param_groups</code>.</p> <p>This can be useful when fine tuning a pre-trained network as frozen layers can be made trainable and added to the <a class="reference internal" href="#torch.optim.Optimizer" title="torch.optim.Optimizer"><code>Optimizer</code></a> as training progresses.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>param_group</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)">dict</a>) – Specifies what Tensors should be optimized along with group</li> <li>
<strong>optimization options.</strong> (<em>specific</em>) – </li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.optim.Optimizer.load_state_dict">
<code>load_state_dict(state_dict)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/optimizer.html#Optimizer.load_state_dict"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Loads the optimizer state.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>state_dict</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)">dict</a>) – optimizer state. Should be an object returned from a call to <a class="reference internal" href="#torch.optim.Optimizer.state_dict" title="torch.optim.Optimizer.state_dict"><code>state_dict()</code></a>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.optim.Optimizer.state_dict">
<code>state_dict()</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/optimizer.html#Optimizer.state_dict"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns the state of the optimizer as a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><code>dict</code></a>.</p> <p>It contains two entries:</p> <ul class="simple"> <li>
<dl class="simple"> <dt>state - a dict holding current optimization state. Its content</dt>
<dd>
<p>differs between optimizer classes.</p> </dd> </dl> </li> <li>param_groups - a dict containing all parameter groups</li> </ul> </dd>
</dl> <dl class="method"> <dt id="torch.optim.Optimizer.step">
<code>step(closure)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/optimizer.html#Optimizer.step"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs a single optimization step (parameter update).</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>closure</strong> (<em>callable</em>) – A closure that reevaluates the model and returns the loss. Optional for most optimizers.</p> </dd> </dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Unless otherwise specified, this function should not modify the <code>.grad</code> field of the parameters.</p> </div> </dd>
</dl> <dl class="method"> <dt id="torch.optim.Optimizer.zero_grad">
<code>zero_grad(set_to_none=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/optimizer.html#Optimizer.zero_grad"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Sets the gradients of all optimized <a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor"><code>torch.Tensor</code></a> s to zero.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>set_to_none</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – instead of setting to zero, set the grads to None. This will in general have lower memory footprint, and can modestly improve performance. However, it changes certain behaviors. For example: 1. When the user tries to access a gradient and perform manual ops on it, a None attribute or a Tensor full of 0s will behave differently. 2. If the user requests <code>zero_grad(set_to_none=True)</code> followed by a backward pass, <code>.grad</code>s are guaranteed to be None for params that did not receive a gradient. 3. <code>torch.optim</code> optimizers have a different behavior if the gradient is 0 or None (in one case it does the step with a gradient of 0 and in the other it skips the step altogether).</p> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="torch.optim.Adadelta">
<code>class torch.optim.Adadelta(params, lr=1.0, rho=0.9, eps=1e-06, weight_decay=0)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/adadelta.html#Adadelta"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Implements Adadelta algorithm.</p> <p>It has been proposed in <a class="reference external" href="https://arxiv.org/abs/1212.5701">ADADELTA: An Adaptive Learning Rate Method</a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>params</strong> (<em>iterable</em>) – iterable of parameters to optimize or dicts defining parameter groups</li> <li>
<strong>rho</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – coefficient used for computing a running average of squared gradients (default: 0.9)</li> <li>
<strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – term added to the denominator to improve numerical stability (default: 1e-6)</li> <li>
<strong>lr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – coefficient that scale delta before it is applied to the parameters (default: 1.0)</li> <li>
<strong>weight_decay</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – weight decay (L2 penalty) (default: 0)</li> </ul> </dd> </dl> <dl class="method"> <dt id="torch.optim.Adadelta.step">
<code>step(closure=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/adadelta.html#Adadelta.step"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs a single optimization step.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>closure</strong> (<em>callable</em><em>, </em><em>optional</em>) – A closure that reevaluates the model and returns the loss.</p> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="torch.optim.Adagrad">
<code>class torch.optim.Adagrad(params, lr=0.01, lr_decay=0, weight_decay=0, initial_accumulator_value=0, eps=1e-10)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/adagrad.html#Adagrad"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Implements Adagrad algorithm.</p> <p>It has been proposed in <a class="reference external" href="http://jmlr.org/papers/v12/duchi11a.html">Adaptive Subgradient Methods for Online Learning and Stochastic Optimization</a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>params</strong> (<em>iterable</em>) – iterable of parameters to optimize or dicts defining parameter groups</li> <li>
<strong>lr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – learning rate (default: 1e-2)</li> <li>
<strong>lr_decay</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – learning rate decay (default: 0)</li> <li>
<strong>weight_decay</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – weight decay (L2 penalty) (default: 0)</li> <li>
<strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – term added to the denominator to improve numerical stability (default: 1e-10)</li> </ul> </dd> </dl> <dl class="method"> <dt id="torch.optim.Adagrad.step">
<code>step(closure=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/adagrad.html#Adagrad.step"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs a single optimization step.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>closure</strong> (<em>callable</em><em>, </em><em>optional</em>) – A closure that reevaluates the model and returns the loss.</p> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="torch.optim.Adam">
<code>class torch.optim.Adam(params, lr=0.001, betas=(0.9, 0.999), eps=1e-08, weight_decay=0, amsgrad=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/adam.html#Adam"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Implements Adam algorithm.</p> <p>It has been proposed in <a class="reference external" href="https://arxiv.org/abs/1412.6980">Adam: A Method for Stochastic Optimization</a>. The implementation of the L2 penalty follows changes proposed in <a class="reference external" href="https://arxiv.org/abs/1711.05101">Decoupled Weight Decay Regularization</a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>params</strong> (<em>iterable</em>) – iterable of parameters to optimize or dicts defining parameter groups</li> <li>
<strong>lr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – learning rate (default: 1e-3)</li> <li>
<strong>betas</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>]</em><em>, </em><em>optional</em>) – coefficients used for computing running averages of gradient and its square (default: (0.9, 0.999))</li> <li>
<strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – term added to the denominator to improve numerical stability (default: 1e-8)</li> <li>
<strong>weight_decay</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – weight decay (L2 penalty) (default: 0)</li> <li>
<strong>amsgrad</strong> (<em>boolean</em><em>, </em><em>optional</em>) – whether to use the AMSGrad variant of this algorithm from the paper <a class="reference external" href="https://openreview.net/forum?id=ryQu7f-RZ">On the Convergence of Adam and Beyond</a> (default: False)</li> </ul> </dd> </dl> <dl class="method"> <dt id="torch.optim.Adam.step">
<code>step(closure=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/adam.html#Adam.step"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs a single optimization step.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>closure</strong> (<em>callable</em><em>, </em><em>optional</em>) – A closure that reevaluates the model and returns the loss.</p> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="torch.optim.AdamW">
<code>class torch.optim.AdamW(params, lr=0.001, betas=(0.9, 0.999), eps=1e-08, weight_decay=0.01, amsgrad=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/adamw.html#AdamW"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Implements AdamW algorithm.</p> <p>The original Adam algorithm was proposed in <a class="reference external" href="https://arxiv.org/abs/1412.6980">Adam: A Method for Stochastic Optimization</a>. The AdamW variant was proposed in <a class="reference external" href="https://arxiv.org/abs/1711.05101">Decoupled Weight Decay Regularization</a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>params</strong> (<em>iterable</em>) – iterable of parameters to optimize or dicts defining parameter groups</li> <li>
<strong>lr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – learning rate (default: 1e-3)</li> <li>
<strong>betas</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>]</em><em>, </em><em>optional</em>) – coefficients used for computing running averages of gradient and its square (default: (0.9, 0.999))</li> <li>
<strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – term added to the denominator to improve numerical stability (default: 1e-8)</li> <li>
<strong>weight_decay</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – weight decay coefficient (default: 1e-2)</li> <li>
<strong>amsgrad</strong> (<em>boolean</em><em>, </em><em>optional</em>) – whether to use the AMSGrad variant of this algorithm from the paper <a class="reference external" href="https://openreview.net/forum?id=ryQu7f-RZ">On the Convergence of Adam and Beyond</a> (default: False)</li> </ul> </dd> </dl> <dl class="method"> <dt id="torch.optim.AdamW.step">
<code>step(closure=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/adamw.html#AdamW.step"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs a single optimization step.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>closure</strong> (<em>callable</em><em>, </em><em>optional</em>) – A closure that reevaluates the model and returns the loss.</p> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="torch.optim.SparseAdam">
<code>class torch.optim.SparseAdam(params, lr=0.001, betas=(0.9, 0.999), eps=1e-08)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/sparse_adam.html#SparseAdam"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Implements lazy version of Adam algorithm suitable for sparse tensors.</p> <p>In this variant, only moments that show up in the gradient get updated, and only those portions of the gradient get applied to the parameters.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>params</strong> (<em>iterable</em>) – iterable of parameters to optimize or dicts defining parameter groups</li> <li>
<strong>lr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – learning rate (default: 1e-3)</li> <li>
<strong>betas</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>]</em><em>, </em><em>optional</em>) – coefficients used for computing running averages of gradient and its square (default: (0.9, 0.999))</li> <li>
<strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – term added to the denominator to improve numerical stability (default: 1e-8)</li> </ul> </dd> </dl> <dl class="method"> <dt id="torch.optim.SparseAdam.step">
<code>step(closure=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/sparse_adam.html#SparseAdam.step"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs a single optimization step.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>closure</strong> (<em>callable</em><em>, </em><em>optional</em>) – A closure that reevaluates the model and returns the loss.</p> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="torch.optim.Adamax">
<code>class torch.optim.Adamax(params, lr=0.002, betas=(0.9, 0.999), eps=1e-08, weight_decay=0)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/adamax.html#Adamax"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Implements Adamax algorithm (a variant of Adam based on infinity norm).</p> <p>It has been proposed in <a class="reference external" href="https://arxiv.org/abs/1412.6980">Adam: A Method for Stochastic Optimization</a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>params</strong> (<em>iterable</em>) – iterable of parameters to optimize or dicts defining parameter groups</li> <li>
<strong>lr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – learning rate (default: 2e-3)</li> <li>
<strong>betas</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>]</em><em>, </em><em>optional</em>) – coefficients used for computing running averages of gradient and its square</li> <li>
<strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – term added to the denominator to improve numerical stability (default: 1e-8)</li> <li>
<strong>weight_decay</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – weight decay (L2 penalty) (default: 0)</li> </ul> </dd> </dl> <dl class="method"> <dt id="torch.optim.Adamax.step">
<code>step(closure=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/adamax.html#Adamax.step"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs a single optimization step.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>closure</strong> (<em>callable</em><em>, </em><em>optional</em>) – A closure that reevaluates the model and returns the loss.</p> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="torch.optim.ASGD">
<code>class torch.optim.ASGD(params, lr=0.01, lambd=0.0001, alpha=0.75, t0=1000000.0, weight_decay=0)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/asgd.html#ASGD"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Implements Averaged Stochastic Gradient Descent.</p> <p>It has been proposed in <a class="reference external" href="https://dl.acm.org/citation.cfm?id=131098">Acceleration of stochastic approximation by averaging</a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>params</strong> (<em>iterable</em>) – iterable of parameters to optimize or dicts defining parameter groups</li> <li>
<strong>lr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – learning rate (default: 1e-2)</li> <li>
<strong>lambd</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – decay term (default: 1e-4)</li> <li>
<strong>alpha</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – power for eta update (default: 0.75)</li> <li>
<strong>t0</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – point at which to start averaging (default: 1e6)</li> <li>
<strong>weight_decay</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – weight decay (L2 penalty) (default: 0)</li> </ul> </dd> </dl> <dl class="method"> <dt id="torch.optim.ASGD.step">
<code>step(closure=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/asgd.html#ASGD.step"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs a single optimization step.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>closure</strong> (<em>callable</em><em>, </em><em>optional</em>) – A closure that reevaluates the model and returns the loss.</p> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="torch.optim.LBFGS">
<code>class torch.optim.LBFGS(params, lr=1, max_iter=20, max_eval=None, tolerance_grad=1e-07, tolerance_change=1e-09, history_size=100, line_search_fn=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/lbfgs.html#LBFGS"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Implements L-BFGS algorithm, heavily inspired by <code>minFunc &lt;https://www.cs.ubc.ca/~schmidtm/Software/minFunc.html&gt;</code>.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This optimizer doesn’t support per-parameter options and parameter groups (there can be only one).</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Right now all parameters have to be on a single device. This will be improved in the future.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This is a very memory intensive optimizer (it requires additional <code>param_bytes * (history_size + 1)</code> bytes). If it doesn’t fit in memory try reducing the history size, or use a different algorithm.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>lr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a>) – learning rate (default: 1)</li> <li>
<strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – maximal number of iterations per optimization step (default: 20)</li> <li>
<strong>max_eval</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – maximal number of function evaluations per optimization step (default: max_iter * 1.25).</li> <li>
<strong>tolerance_grad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a>) – termination tolerance on first order optimality (default: 1e-5).</li> <li>
<strong>tolerance_change</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a>) – termination tolerance on function value/parameter changes (default: 1e-9).</li> <li>
<strong>history_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – update history size (default: 100).</li> <li>
<strong>line_search_fn</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>) – either ‘strong_wolfe’ or None (default: None).</li> </ul> </dd> </dl> <dl class="method"> <dt id="torch.optim.LBFGS.step">
<code>step(closure)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/lbfgs.html#LBFGS.step"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs a single optimization step.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>closure</strong> (<em>callable</em>) – A closure that reevaluates the model and returns the loss.</p> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="torch.optim.RMSprop">
<code>class torch.optim.RMSprop(params, lr=0.01, alpha=0.99, eps=1e-08, weight_decay=0, momentum=0, centered=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/rmsprop.html#RMSprop"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Implements RMSprop algorithm.</p> <p>Proposed by G. Hinton in his <a class="reference external" href="https://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf">course</a>.</p> <p>The centered version first appears in <a class="reference external" href="https://arxiv.org/pdf/1308.0850v5.pdf">Generating Sequences With Recurrent Neural Networks</a>.</p> <p>The implementation here takes the square root of the gradient average before adding epsilon (note that TensorFlow interchanges these two operations). The effective learning rate is thus <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><msqrt><mi>v</mi></msqrt><mo>+</mo><mi>ϵ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha/(\sqrt{v} + \epsilon)</annotation></semantics></math></span></span> </span> where <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span></span> </span> is the scheduled learning rate and <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span></span> </span> is the weighted moving average of the squared gradient.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>params</strong> (<em>iterable</em>) – iterable of parameters to optimize or dicts defining parameter groups</li> <li>
<strong>lr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – learning rate (default: 1e-2)</li> <li>
<strong>momentum</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – momentum factor (default: 0)</li> <li>
<strong>alpha</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – smoothing constant (default: 0.99)</li> <li>
<strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – term added to the denominator to improve numerical stability (default: 1e-8)</li> <li>
<strong>centered</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – if <code>True</code>, compute the centered RMSProp, the gradient is normalized by an estimation of its variance</li> <li>
<strong>weight_decay</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – weight decay (L2 penalty) (default: 0)</li> </ul> </dd> </dl> <dl class="method"> <dt id="torch.optim.RMSprop.step">
<code>step(closure=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/rmsprop.html#RMSprop.step"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs a single optimization step.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>closure</strong> (<em>callable</em><em>, </em><em>optional</em>) – A closure that reevaluates the model and returns the loss.</p> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="torch.optim.Rprop">
<code>class torch.optim.Rprop(params, lr=0.01, etas=(0.5, 1.2), step_sizes=(1e-06, 50))</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/rprop.html#Rprop"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Implements the resilient backpropagation algorithm.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>params</strong> (<em>iterable</em>) – iterable of parameters to optimize or dicts defining parameter groups</li> <li>
<strong>lr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – learning rate (default: 1e-2)</li> <li>
<strong>etas</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>]</em><em>, </em><em>optional</em>) – pair of (etaminus, etaplis), that are multiplicative increase and decrease factors (default: (0.5, 1.2))</li> <li>
<strong>step_sizes</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>]</em><em>, </em><em>optional</em>) – a pair of minimal and maximal allowed step sizes (default: (1e-6, 50))</li> </ul> </dd> </dl> <dl class="method"> <dt id="torch.optim.Rprop.step">
<code>step(closure=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/rprop.html#Rprop.step"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs a single optimization step.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>closure</strong> (<em>callable</em><em>, </em><em>optional</em>) – A closure that reevaluates the model and returns the loss.</p> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="torch.optim.SGD">
<code>class torch.optim.SGD(params, lr=&lt;required parameter&gt;, momentum=0, dampening=0, weight_decay=0, nesterov=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/sgd.html#SGD"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Implements stochastic gradient descent (optionally with momentum).</p> <p>Nesterov momentum is based on the formula from <a class="reference external" href="http://www.cs.toronto.edu/%7Ehinton/absps/momentum.pdf">On the importance of initialization and momentum in deep learning</a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>params</strong> (<em>iterable</em>) – iterable of parameters to optimize or dicts defining parameter groups</li> <li>
<strong>lr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a>) – learning rate</li> <li>
<strong>momentum</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – momentum factor (default: 0)</li> <li>
<strong>weight_decay</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – weight decay (L2 penalty) (default: 0)</li> <li>
<strong>dampening</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – dampening for momentum (default: 0)</li> <li>
<strong>nesterov</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – enables Nesterov momentum (default: False)</li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; optimizer = torch.optim.SGD(model.parameters(), lr=0.1, momentum=0.9)
&gt;&gt;&gt; optimizer.zero_grad()
&gt;&gt;&gt; loss_fn(model(input), target).backward()
&gt;&gt;&gt; optimizer.step()
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The implementation of SGD with Momentum/Nesterov subtly differs from Sutskever et. al. and implementations in some other frameworks.</p> <p>Considering the specific case of Momentum, the update can be written as</p> <div class="math"> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>v</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mi>μ</mi><mo>∗</mo><msub><mi>v</mi><mi>t</mi></msub><mo>+</mo><msub><mi>g</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>p</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><msub><mi>p</mi><mi>t</mi></msub><mo>−</mo><mtext>lr</mtext><mo>∗</mo><msub><mi>v</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} v_{t+1} &amp; = \mu * v_{t} + g_{t+1}, \\ p_{t+1} &amp; = p_{t} - \text{lr} * v_{t+1}, \end{aligned} </annotation></semantics></math></span></span></span> </div>
<p>where <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span></span> </span>, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span></span> </span>, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span></span> </span> and <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span></span> </span> denote the parameters, gradient, velocity, and momentum respectively.</p> <p>This is in contrast to Sutskever et. al. and other frameworks which employ an update of the form</p> <div class="math"> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>v</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mi>μ</mi><mo>∗</mo><msub><mi>v</mi><mi>t</mi></msub><mo>+</mo><mtext>lr</mtext><mo>∗</mo><msub><mi>g</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>p</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><msub><mi>p</mi><mi>t</mi></msub><mo>−</mo><msub><mi>v</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} v_{t+1} &amp; = \mu * v_{t} + \text{lr} * g_{t+1}, \\ p_{t+1} &amp; = p_{t} - v_{t+1}. \end{aligned} </annotation></semantics></math></span></span></span> </div>
<p>The Nesterov version is analogously modified.</p> </div> <dl class="method"> <dt id="torch.optim.SGD.step">
<code>step(closure=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/sgd.html#SGD.step"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs a single optimization step.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>closure</strong> (<em>callable</em><em>, </em><em>optional</em>) – A closure that reevaluates the model and returns the loss.</p> </dd> </dl> </dd>
</dl> </dd>
</dl>   <h2 id="how-to-adjust-learning-rate">How to adjust learning rate</h2> <p><code>torch.optim.lr_scheduler</code> provides several methods to adjust the learning rate based on the number of epochs. <a class="reference internal" href="#torch.optim.lr_scheduler.ReduceLROnPlateau" title="torch.optim.lr_scheduler.ReduceLROnPlateau"><code>torch.optim.lr_scheduler.ReduceLROnPlateau</code></a> allows dynamic learning rate reducing based on some validation measurements.</p> <p>Learning rate scheduling should be applied after optimizer’s update; e.g., you should write your code this way:</p> <pre data-language="python">&gt;&gt;&gt; scheduler = ...
&gt;&gt;&gt; for epoch in range(100):
&gt;&gt;&gt;     train(...)
&gt;&gt;&gt;     validate(...)
&gt;&gt;&gt;     scheduler.step()
</pre> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Prior to PyTorch 1.1.0, the learning rate scheduler was expected to be called before the optimizer’s update; 1.1.0 changed this behavior in a BC-breaking way. If you use the learning rate scheduler (calling <code>scheduler.step()</code>) before the optimizer’s update (calling <code>optimizer.step()</code>), this will skip the first value of the learning rate schedule. If you are unable to reproduce results after upgrading to PyTorch 1.1.0, please check if you are calling <code>scheduler.step()</code> at the wrong time.</p> </div> <dl class="class"> <dt id="torch.optim.lr_scheduler.LambdaLR">
<code>class torch.optim.lr_scheduler.LambdaLR(optimizer, lr_lambda, last_epoch=-1, verbose=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/lr_scheduler.html#LambdaLR"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Sets the learning rate of each parameter group to the initial lr times a given function. When last_epoch=-1, sets initial lr as lr.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>optimizer</strong> (<a class="reference internal" href="#torch.optim.Optimizer" title="torch.optim.Optimizer">Optimizer</a>) – Wrapped optimizer.</li> <li>
<strong>lr_lambda</strong> (<em>function</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)">list</a>) – A function which computes a multiplicative factor given an integer parameter epoch, or a list of such functions, one for each group in optimizer.param_groups.</li> <li>
<strong>last_epoch</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – The index of last epoch. Default: -1.</li> <li>
<strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – If <code>True</code>, prints a message to stdout for each update. Default: <code>False</code>.</li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; # Assuming optimizer has two groups.
&gt;&gt;&gt; lambda1 = lambda epoch: epoch // 30
&gt;&gt;&gt; lambda2 = lambda epoch: 0.95 ** epoch
&gt;&gt;&gt; scheduler = LambdaLR(optimizer, lr_lambda=[lambda1, lambda2])
&gt;&gt;&gt; for epoch in range(100):
&gt;&gt;&gt;     train(...)
&gt;&gt;&gt;     validate(...)
&gt;&gt;&gt;     scheduler.step()
</pre> <dl class="method"> <dt id="torch.optim.lr_scheduler.LambdaLR.load_state_dict">
<code>load_state_dict(state_dict)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/lr_scheduler.html#LambdaLR.load_state_dict"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Loads the schedulers state.</p> <p>When saving or loading the scheduler, please make sure to also save or load the state of the optimizer.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>state_dict</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)">dict</a>) – scheduler state. Should be an object returned from a call to <a class="reference internal" href="#torch.optim.lr_scheduler.LambdaLR.state_dict" title="torch.optim.lr_scheduler.LambdaLR.state_dict"><code>state_dict()</code></a>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.optim.lr_scheduler.LambdaLR.state_dict">
<code>state_dict()</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/lr_scheduler.html#LambdaLR.state_dict"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns the state of the scheduler as a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><code>dict</code></a>.</p> <p>It contains an entry for every variable in self.__dict__ which is not the optimizer. The learning rate lambda functions will only be saved if they are callable objects and not if they are functions or lambdas.</p> <p>When saving or loading the scheduler, please make sure to also save or load the state of the optimizer.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="torch.optim.lr_scheduler.MultiplicativeLR">
<code>class torch.optim.lr_scheduler.MultiplicativeLR(optimizer, lr_lambda, last_epoch=-1, verbose=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/lr_scheduler.html#MultiplicativeLR"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Multiply the learning rate of each parameter group by the factor given in the specified function. When last_epoch=-1, sets initial lr as lr.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>optimizer</strong> (<a class="reference internal" href="#torch.optim.Optimizer" title="torch.optim.Optimizer">Optimizer</a>) – Wrapped optimizer.</li> <li>
<strong>lr_lambda</strong> (<em>function</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)">list</a>) – A function which computes a multiplicative factor given an integer parameter epoch, or a list of such functions, one for each group in optimizer.param_groups.</li> <li>
<strong>last_epoch</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – The index of last epoch. Default: -1.</li> <li>
<strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – If <code>True</code>, prints a message to stdout for each update. Default: <code>False</code>.</li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; lmbda = lambda epoch: 0.95
&gt;&gt;&gt; scheduler = MultiplicativeLR(optimizer, lr_lambda=lmbda)
&gt;&gt;&gt; for epoch in range(100):
&gt;&gt;&gt;     train(...)
&gt;&gt;&gt;     validate(...)
&gt;&gt;&gt;     scheduler.step()
</pre> <dl class="method"> <dt id="torch.optim.lr_scheduler.MultiplicativeLR.load_state_dict">
<code>load_state_dict(state_dict)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/lr_scheduler.html#MultiplicativeLR.load_state_dict"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Loads the schedulers state.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>state_dict</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)">dict</a>) – scheduler state. Should be an object returned from a call to <a class="reference internal" href="#torch.optim.lr_scheduler.MultiplicativeLR.state_dict" title="torch.optim.lr_scheduler.MultiplicativeLR.state_dict"><code>state_dict()</code></a>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.optim.lr_scheduler.MultiplicativeLR.state_dict">
<code>state_dict()</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/lr_scheduler.html#MultiplicativeLR.state_dict"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns the state of the scheduler as a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><code>dict</code></a>.</p> <p>It contains an entry for every variable in self.__dict__ which is not the optimizer. The learning rate lambda functions will only be saved if they are callable objects and not if they are functions or lambdas.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="torch.optim.lr_scheduler.StepLR">
<code>class torch.optim.lr_scheduler.StepLR(optimizer, step_size, gamma=0.1, last_epoch=-1, verbose=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/lr_scheduler.html#StepLR"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Decays the learning rate of each parameter group by gamma every step_size epochs. Notice that such decay can happen simultaneously with other changes to the learning rate from outside this scheduler. When last_epoch=-1, sets initial lr as lr.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>optimizer</strong> (<a class="reference internal" href="#torch.optim.Optimizer" title="torch.optim.Optimizer">Optimizer</a>) – Wrapped optimizer.</li> <li>
<strong>step_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – Period of learning rate decay.</li> <li>
<strong>gamma</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a>) – Multiplicative factor of learning rate decay. Default: 0.1.</li> <li>
<strong>last_epoch</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – The index of last epoch. Default: -1.</li> <li>
<strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – If <code>True</code>, prints a message to stdout for each update. Default: <code>False</code>.</li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; # Assuming optimizer uses lr = 0.05 for all groups
&gt;&gt;&gt; # lr = 0.05     if epoch &lt; 30
&gt;&gt;&gt; # lr = 0.005    if 30 &lt;= epoch &lt; 60
&gt;&gt;&gt; # lr = 0.0005   if 60 &lt;= epoch &lt; 90
&gt;&gt;&gt; # ...
&gt;&gt;&gt; scheduler = StepLR(optimizer, step_size=30, gamma=0.1)
&gt;&gt;&gt; for epoch in range(100):
&gt;&gt;&gt;     train(...)
&gt;&gt;&gt;     validate(...)
&gt;&gt;&gt;     scheduler.step()
</pre> </dd>
</dl> <dl class="class"> <dt id="torch.optim.lr_scheduler.MultiStepLR">
<code>class torch.optim.lr_scheduler.MultiStepLR(optimizer, milestones, gamma=0.1, last_epoch=-1, verbose=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/lr_scheduler.html#MultiStepLR"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Decays the learning rate of each parameter group by gamma once the number of epoch reaches one of the milestones. Notice that such decay can happen simultaneously with other changes to the learning rate from outside this scheduler. When last_epoch=-1, sets initial lr as lr.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>optimizer</strong> (<a class="reference internal" href="#torch.optim.Optimizer" title="torch.optim.Optimizer">Optimizer</a>) – Wrapped optimizer.</li> <li>
<strong>milestones</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)">list</a>) – List of epoch indices. Must be increasing.</li> <li>
<strong>gamma</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a>) – Multiplicative factor of learning rate decay. Default: 0.1.</li> <li>
<strong>last_epoch</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – The index of last epoch. Default: -1.</li> <li>
<strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – If <code>True</code>, prints a message to stdout for each update. Default: <code>False</code>.</li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; # Assuming optimizer uses lr = 0.05 for all groups
&gt;&gt;&gt; # lr = 0.05     if epoch &lt; 30
&gt;&gt;&gt; # lr = 0.005    if 30 &lt;= epoch &lt; 80
&gt;&gt;&gt; # lr = 0.0005   if epoch &gt;= 80
&gt;&gt;&gt; scheduler = MultiStepLR(optimizer, milestones=[30,80], gamma=0.1)
&gt;&gt;&gt; for epoch in range(100):
&gt;&gt;&gt;     train(...)
&gt;&gt;&gt;     validate(...)
&gt;&gt;&gt;     scheduler.step()
</pre> </dd>
</dl> <dl class="class"> <dt id="torch.optim.lr_scheduler.ExponentialLR">
<code>class torch.optim.lr_scheduler.ExponentialLR(optimizer, gamma, last_epoch=-1, verbose=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/lr_scheduler.html#ExponentialLR"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Decays the learning rate of each parameter group by gamma every epoch. When last_epoch=-1, sets initial lr as lr.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>optimizer</strong> (<a class="reference internal" href="#torch.optim.Optimizer" title="torch.optim.Optimizer">Optimizer</a>) – Wrapped optimizer.</li> <li>
<strong>gamma</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a>) – Multiplicative factor of learning rate decay.</li> <li>
<strong>last_epoch</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – The index of last epoch. Default: -1.</li> <li>
<strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – If <code>True</code>, prints a message to stdout for each update. Default: <code>False</code>.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="torch.optim.lr_scheduler.CosineAnnealingLR">
<code>class torch.optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max, eta_min=0, last_epoch=-1, verbose=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/lr_scheduler.html#CosineAnnealingLR"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the learning rate of each parameter group using a cosine annealing schedule, where <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\eta_{max}</annotation></semantics></math></span></span> </span> is set to the initial lr and <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mrow><mi>c</mi><mi>u</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{cur}</annotation></semantics></math></span></span> </span> is the number of epochs since the last restart in SGDR:</p> <div class="math"> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>η</mi><mi>t</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><msub><mi>η</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><msub><mi>η</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><msub><mi>η</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy="false">)</mo><mrow><mo fence="true">(</mo><mn>1</mn><mo>+</mo><mi>cos</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mfrac><msub><mi>T</mi><mrow><mi>c</mi><mi>u</mi><mi>r</mi></mrow></msub><msub><mi>T</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mfrac><mi>π</mi><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>T</mi><mrow><mi>c</mi><mi>u</mi><mi>r</mi></mrow></msub><mo mathvariant="normal">≠</mo><mo stretchy="false">(</mo><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><msub><mi>T</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo separator="true">;</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>η</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><msub><mi>η</mi><mi>t</mi></msub><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><msub><mi>η</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><msub><mi>η</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy="false">)</mo><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><mi>cos</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mfrac><mn>1</mn><msub><mi>T</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mfrac><mi>π</mi><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>T</mi><mrow><mi>c</mi><mi>u</mi><mi>r</mi></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><msub><mi>T</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} \eta_t &amp; = \eta_{min} + \frac{1}{2}(\eta_{max} - \eta_{min})\left(1 + \cos\left(\frac{T_{cur}}{T_{max}}\pi\right)\right), &amp; T_{cur} \neq (2k+1)T_{max}; \\ \eta_{t+1} &amp; = \eta_{t} + \frac{1}{2}(\eta_{max} - \eta_{min}) \left(1 - \cos\left(\frac{1}{T_{max}}\pi\right)\right), &amp; T_{cur} = (2k+1)T_{max}. \end{aligned} </annotation></semantics></math></span></span></span> </div>
<p>When last_epoch=-1, sets initial lr as lr. Notice that because the schedule is defined recursively, the learning rate can be simultaneously modified outside this scheduler by other operators. If the learning rate is set solely by this scheduler, the learning rate at each step becomes:</p> <div class="math"> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>η</mi><mi>t</mi></msub><mo>=</mo><msub><mi>η</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><msub><mi>η</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><msub><mi>η</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy="false">)</mo><mrow><mo fence="true">(</mo><mn>1</mn><mo>+</mo><mi>cos</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mfrac><msub><mi>T</mi><mrow><mi>c</mi><mi>u</mi><mi>r</mi></mrow></msub><msub><mi>T</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mfrac><mi>π</mi><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\eta_t = \eta_{min} + \frac{1}{2}(\eta_{max} - \eta_{min})\left(1 + \cos\left(\frac{T_{cur}}{T_{max}}\pi\right)\right) </annotation></semantics></math></span></span></span> </div>
<p>It has been proposed in <a class="reference external" href="https://arxiv.org/abs/1608.03983">SGDR: Stochastic Gradient Descent with Warm Restarts</a>. Note that this only implements the cosine annealing part of SGDR, and not the restarts.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>optimizer</strong> (<a class="reference internal" href="#torch.optim.Optimizer" title="torch.optim.Optimizer">Optimizer</a>) – Wrapped optimizer.</li> <li>
<strong>T_max</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – Maximum number of iterations.</li> <li>
<strong>eta_min</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a>) – Minimum learning rate. Default: 0.</li> <li>
<strong>last_epoch</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – The index of last epoch. Default: -1.</li> <li>
<strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – If <code>True</code>, prints a message to stdout for each update. Default: <code>False</code>.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="class"> <dt id="torch.optim.lr_scheduler.ReduceLROnPlateau">
<code>class torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode='min', factor=0.1, patience=10, threshold=0.0001, threshold_mode='rel', cooldown=0, min_lr=0, eps=1e-08, verbose=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/lr_scheduler.html#ReduceLROnPlateau"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Reduce learning rate when a metric has stopped improving. Models often benefit from reducing the learning rate by a factor of 2-10 once learning stagnates. This scheduler reads a metrics quantity and if no improvement is seen for a ‘patience’ number of epochs, the learning rate is reduced.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>optimizer</strong> (<a class="reference internal" href="#torch.optim.Optimizer" title="torch.optim.Optimizer">Optimizer</a>) – Wrapped optimizer.</li> <li>
<strong>mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>) – One of <code>min</code>, <code>max</code>. In <code>min</code> mode, lr will be reduced when the quantity monitored has stopped decreasing; in <code>max</code> mode it will be reduced when the quantity monitored has stopped increasing. Default: ‘min’.</li> <li>
<strong>factor</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a>) – Factor by which the learning rate will be reduced. new_lr = lr * factor. Default: 0.1.</li> <li>
<strong>patience</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – Number of epochs with no improvement after which learning rate will be reduced. For example, if <code>patience = 2</code>, then we will ignore the first 2 epochs with no improvement, and will only decrease the LR after the 3rd epoch if the loss still hasn’t improved then. Default: 10.</li> <li>
<strong>threshold</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a>) – Threshold for measuring the new optimum, to only focus on significant changes. Default: 1e-4.</li> <li>
<strong>threshold_mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>) – One of <code>rel</code>, <code>abs</code>. In <code>rel</code> mode, dynamic_threshold = best * ( 1 + threshold ) in ‘max’ mode or best * ( 1 - threshold ) in <code>min</code> mode. In <code>abs</code> mode, dynamic_threshold = best + threshold in <code>max</code> mode or best - threshold in <code>min</code> mode. Default: ‘rel’.</li> <li>
<strong>cooldown</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – Number of epochs to wait before resuming normal operation after lr has been reduced. Default: 0.</li> <li>
<strong>min_lr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)">list</a>) – A scalar or a list of scalars. A lower bound on the learning rate of all param groups or each group respectively. Default: 0.</li> <li>
<strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a>) – Minimal decay applied to lr. If the difference between new and old lr is smaller than eps, the update is ignored. Default: 1e-8.</li> <li>
<strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – If <code>True</code>, prints a message to stdout for each update. Default: <code>False</code>.</li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; optimizer = torch.optim.SGD(model.parameters(), lr=0.1, momentum=0.9)
&gt;&gt;&gt; scheduler = ReduceLROnPlateau(optimizer, 'min')
&gt;&gt;&gt; for epoch in range(10):
&gt;&gt;&gt;     train(...)
&gt;&gt;&gt;     val_loss = validate(...)
&gt;&gt;&gt;     # Note that step should be called after validate()
&gt;&gt;&gt;     scheduler.step(val_loss)
</pre> </dd>
</dl> <dl class="class"> <dt id="torch.optim.lr_scheduler.CyclicLR">
<code>class torch.optim.lr_scheduler.CyclicLR(optimizer, base_lr, max_lr, step_size_up=2000, step_size_down=None, mode='triangular', gamma=1.0, scale_fn=None, scale_mode='cycle', cycle_momentum=True, base_momentum=0.8, max_momentum=0.9, last_epoch=-1, verbose=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/lr_scheduler.html#CyclicLR"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Sets the learning rate of each parameter group according to cyclical learning rate policy (CLR). The policy cycles the learning rate between two boundaries with a constant frequency, as detailed in the paper <a class="reference external" href="https://arxiv.org/abs/1506.01186">Cyclical Learning Rates for Training Neural Networks</a>. The distance between the two boundaries can be scaled on a per-iteration or per-cycle basis.</p> <p>Cyclical learning rate policy changes the learning rate after every batch. <code>step</code> should be called after a batch has been used for training.</p> <p>This class has three built-in policies, as put forth in the paper:</p> <ul class="simple"> <li>“triangular”: A basic triangular cycle without amplitude scaling.</li> <li>“triangular2”: A basic triangular cycle that scales initial amplitude by half each cycle.</li> <li>“exp_range”: A cycle that scales initial amplitude by <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext>gamma</mtext><mtext>cycle iterations</mtext></msup></mrow><annotation encoding="application/x-tex">\text{gamma}^{\text{cycle iterations}}</annotation></semantics></math></span></span> </span> at each cycle iteration.</li> </ul> <p>This implementation was adapted from the github repo: <a class="reference external" href="https://github.com/bckenstler/CLR">bckenstler/CLR</a></p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>optimizer</strong> (<a class="reference internal" href="#torch.optim.Optimizer" title="torch.optim.Optimizer">Optimizer</a>) – Wrapped optimizer.</li> <li>
<strong>base_lr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)">list</a>) – Initial learning rate which is the lower boundary in the cycle for each parameter group.</li> <li>
<strong>max_lr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)">list</a>) – Upper learning rate boundaries in the cycle for each parameter group. Functionally, it defines the cycle amplitude (max_lr - base_lr). The lr at any cycle is the sum of base_lr and some scaling of the amplitude; therefore max_lr may not actually be reached depending on scaling function.</li> <li>
<strong>step_size_up</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – Number of training iterations in the increasing half of a cycle. Default: 2000</li> <li>
<strong>step_size_down</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – Number of training iterations in the decreasing half of a cycle. If step_size_down is None, it is set to step_size_up. Default: None</li> <li>
<strong>mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>) – One of {triangular, triangular2, exp_range}. Values correspond to policies detailed above. If scale_fn is not None, this argument is ignored. Default: ‘triangular’</li> <li>
<strong>gamma</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a>) – Constant in ‘exp_range’ scaling function: gamma**(cycle iterations) Default: 1.0</li> <li>
<strong>scale_fn</strong> (<em>function</em>) – Custom scaling policy defined by a single argument lambda function, where 0 &lt;= scale_fn(x) &lt;= 1 for all x &gt;= 0. If specified, then ‘mode’ is ignored. Default: None</li> <li>
<strong>scale_mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>) – {‘cycle’, ‘iterations’}. Defines whether scale_fn is evaluated on cycle number or cycle iterations (training iterations since start of cycle). Default: ‘cycle’</li> <li>
<strong>cycle_momentum</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – If <code>True</code>, momentum is cycled inversely to learning rate between ‘base_momentum’ and ‘max_momentum’. Default: True</li> <li>
<strong>base_momentum</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)">list</a>) – Lower momentum boundaries in the cycle for each parameter group. Note that momentum is cycled inversely to learning rate; at the peak of a cycle, momentum is ‘base_momentum’ and learning rate is ‘max_lr’. Default: 0.8</li> <li>
<strong>max_momentum</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)">list</a>) – Upper momentum boundaries in the cycle for each parameter group. Functionally, it defines the cycle amplitude (max_momentum - base_momentum). The momentum at any cycle is the difference of max_momentum and some scaling of the amplitude; therefore base_momentum may not actually be reached depending on scaling function. Note that momentum is cycled inversely to learning rate; at the start of a cycle, momentum is ‘max_momentum’ and learning rate is ‘base_lr’ Default: 0.9</li> <li>
<strong>last_epoch</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – The index of the last batch. This parameter is used when resuming a training job. Since <code>step()</code> should be invoked after each batch instead of after each epoch, this number represents the total number of <em>batches</em> computed, not the total number of epochs computed. When last_epoch=-1, the schedule is started from the beginning. Default: -1</li> <li>
<strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – If <code>True</code>, prints a message to stdout for each update. Default: <code>False</code>.</li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; optimizer = torch.optim.SGD(model.parameters(), lr=0.1, momentum=0.9)
&gt;&gt;&gt; scheduler = torch.optim.lr_scheduler.CyclicLR(optimizer, base_lr=0.01, max_lr=0.1)
&gt;&gt;&gt; data_loader = torch.utils.data.DataLoader(...)
&gt;&gt;&gt; for epoch in range(10):
&gt;&gt;&gt;     for batch in data_loader:
&gt;&gt;&gt;         train_batch(...)
&gt;&gt;&gt;         scheduler.step()
</pre> <dl class="method"> <dt id="torch.optim.lr_scheduler.CyclicLR.get_lr">
<code>get_lr()</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/lr_scheduler.html#CyclicLR.get_lr"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculates the learning rate at batch index. This function treats <code>self.last_epoch</code> as the last batch index.</p> <p>If <code>self.cycle_momentum</code> is <code>True</code>, this function has a side effect of updating the optimizer’s momentum.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="torch.optim.lr_scheduler.OneCycleLR">
<code>class torch.optim.lr_scheduler.OneCycleLR(optimizer, max_lr, total_steps=None, epochs=None, steps_per_epoch=None, pct_start=0.3, anneal_strategy='cos', cycle_momentum=True, base_momentum=0.85, max_momentum=0.95, div_factor=25.0, final_div_factor=10000.0, three_phase=False, last_epoch=-1, verbose=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/lr_scheduler.html#OneCycleLR"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Sets the learning rate of each parameter group according to the 1cycle learning rate policy. The 1cycle policy anneals the learning rate from an initial learning rate to some maximum learning rate and then from that maximum learning rate to some minimum learning rate much lower than the initial learning rate. This policy was initially described in the paper <a class="reference external" href="https://arxiv.org/abs/1708.07120">Super-Convergence: Very Fast Training of Neural Networks Using Large Learning Rates</a>.</p> <p>The 1cycle learning rate policy changes the learning rate after every batch. <code>step</code> should be called after a batch has been used for training.</p> <p>This scheduler is not chainable.</p> <p>Note also that the total number of steps in the cycle can be determined in one of two ways (listed in order of precedence):</p> <ol class="arabic simple"> <li>A value for total_steps is explicitly provided.</li> <li>A number of epochs (epochs) and a number of steps per epoch (steps_per_epoch) are provided. In this case, the number of total steps is inferred by total_steps = epochs * steps_per_epoch</li> </ol> <p>You must either provide a value for total_steps or provide a value for both epochs and steps_per_epoch.</p> <p>The default behaviour of this scheduler follows the fastai implementation of 1cycle, which claims that “unpublished work has shown even better results by using only two phases”. To mimic the behaviour of the original paper instead, set <code>three_phase=True</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>optimizer</strong> (<a class="reference internal" href="#torch.optim.Optimizer" title="torch.optim.Optimizer">Optimizer</a>) – Wrapped optimizer.</li> <li>
<strong>max_lr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)">list</a>) – Upper learning rate boundaries in the cycle for each parameter group.</li> <li>
<strong>total_steps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – The total number of steps in the cycle. Note that if a value is not provided here, then it must be inferred by providing a value for epochs and steps_per_epoch. Default: None</li> <li>
<strong>epochs</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – The number of epochs to train for. This is used along with steps_per_epoch in order to infer the total number of steps in the cycle if a value for total_steps is not provided. Default: None</li> <li>
<strong>steps_per_epoch</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – The number of steps per epoch to train for. This is used along with epochs in order to infer the total number of steps in the cycle if a value for total_steps is not provided. Default: None</li> <li>
<strong>pct_start</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a>) – The percentage of the cycle (in number of steps) spent increasing the learning rate. Default: 0.3</li> <li>
<strong>anneal_strategy</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>) – {‘cos’, ‘linear’} Specifies the annealing strategy: “cos” for cosine annealing, “linear” for linear annealing. Default: ‘cos’</li> <li>
<strong>cycle_momentum</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – If <code>True</code>, momentum is cycled inversely to learning rate between ‘base_momentum’ and ‘max_momentum’. Default: True</li> <li>
<strong>base_momentum</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)">list</a>) – Lower momentum boundaries in the cycle for each parameter group. Note that momentum is cycled inversely to learning rate; at the peak of a cycle, momentum is ‘base_momentum’ and learning rate is ‘max_lr’. Default: 0.85</li> <li>
<strong>max_momentum</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)">list</a>) – Upper momentum boundaries in the cycle for each parameter group. Functionally, it defines the cycle amplitude (max_momentum - base_momentum). Note that momentum is cycled inversely to learning rate; at the start of a cycle, momentum is ‘max_momentum’ and learning rate is ‘base_lr’ Default: 0.95</li> <li>
<strong>div_factor</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a>) – Determines the initial learning rate via initial_lr = max_lr/div_factor Default: 25</li> <li>
<strong>final_div_factor</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a>) – Determines the minimum learning rate via min_lr = initial_lr/final_div_factor Default: 1e4</li> <li>
<strong>three_phase</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – If <code>True</code>, use a third phase of the schedule to annihilate the learning rate according to ‘final_div_factor’ instead of modifying the second phase (the first two phases will be symmetrical about the step indicated by ‘pct_start’).</li> <li>
<strong>last_epoch</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – The index of the last batch. This parameter is used when resuming a training job. Since <code>step()</code> should be invoked after each batch instead of after each epoch, this number represents the total number of <em>batches</em> computed, not the total number of epochs computed. When last_epoch=-1, the schedule is started from the beginning. Default: -1</li> <li>
<strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – If <code>True</code>, prints a message to stdout for each update. Default: <code>False</code>.</li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; data_loader = torch.utils.data.DataLoader(...)
&gt;&gt;&gt; optimizer = torch.optim.SGD(model.parameters(), lr=0.1, momentum=0.9)
&gt;&gt;&gt; scheduler = torch.optim.lr_scheduler.OneCycleLR(optimizer, max_lr=0.01, steps_per_epoch=len(data_loader), epochs=10)
&gt;&gt;&gt; for epoch in range(10):
&gt;&gt;&gt;     for batch in data_loader:
&gt;&gt;&gt;         train_batch(...)
&gt;&gt;&gt;         scheduler.step()
</pre> </dd>
</dl> <dl class="class"> <dt id="torch.optim.lr_scheduler.CosineAnnealingWarmRestarts">
<code>class torch.optim.lr_scheduler.CosineAnnealingWarmRestarts(optimizer, T_0, T_mult=1, eta_min=0, last_epoch=-1, verbose=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/lr_scheduler.html#CosineAnnealingWarmRestarts"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the learning rate of each parameter group using a cosine annealing schedule, where <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\eta_{max}</annotation></semantics></math></span></span> </span> is set to the initial lr, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mrow><mi>c</mi><mi>u</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{cur}</annotation></semantics></math></span></span> </span> is the number of epochs since the last restart and <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_{i}</annotation></semantics></math></span></span> </span> is the number of epochs between two warm restarts in SGDR:</p> <div class="math"> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>η</mi><mi>t</mi></msub><mo>=</mo><msub><mi>η</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><msub><mi>η</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><msub><mi>η</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy="false">)</mo><mrow><mo fence="true">(</mo><mn>1</mn><mo>+</mo><mi>cos</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mfrac><msub><mi>T</mi><mrow><mi>c</mi><mi>u</mi><mi>r</mi></mrow></msub><msub><mi>T</mi><mi>i</mi></msub></mfrac><mi>π</mi><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\eta_t = \eta_{min} + \frac{1}{2}(\eta_{max} - \eta_{min})\left(1 + \cos\left(\frac{T_{cur}}{T_{i}}\pi\right)\right) </annotation></semantics></math></span></span></span> </div>
<p>When <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mrow><mi>c</mi><mi>u</mi><mi>r</mi></mrow></msub><mo>=</mo><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_{cur}=T_{i}</annotation></semantics></math></span></span> </span>, set <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mi>t</mi></msub><mo>=</mo><msub><mi>η</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\eta_t = \eta_{min}</annotation></semantics></math></span></span> </span>. When <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mrow><mi>c</mi><mi>u</mi><mi>r</mi></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">T_{cur}=0</annotation></semantics></math></span></span> </span> after restart, set <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mi>t</mi></msub><mo>=</mo><msub><mi>η</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\eta_t=\eta_{max}</annotation></semantics></math></span></span> </span>.</p> <p>It has been proposed in <a class="reference external" href="https://arxiv.org/abs/1608.03983">SGDR: Stochastic Gradient Descent with Warm Restarts</a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>optimizer</strong> (<a class="reference internal" href="#torch.optim.Optimizer" title="torch.optim.Optimizer">Optimizer</a>) – Wrapped optimizer.</li> <li>
<strong>T_0</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – Number of iterations for the first restart.</li> <li>
<strong>T_mult</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><em>optional</em>) – A factor increases <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_{i}</annotation></semantics></math></span></span> </span> after a restart. Default: 1.</li> <li>
<strong>eta_min</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – Minimum learning rate. Default: 0.</li> <li>
<strong>last_epoch</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><em>optional</em>) – The index of last epoch. Default: -1.</li> <li>
<strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – If <code>True</code>, prints a message to stdout for each update. Default: <code>False</code>.</li> </ul> </dd> </dl> <dl class="method"> <dt id="torch.optim.lr_scheduler.CosineAnnealingWarmRestarts.step">
<code>step(epoch=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/lr_scheduler.html#CosineAnnealingWarmRestarts.step"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Step could be called after every batch update</p> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; scheduler = CosineAnnealingWarmRestarts(optimizer, T_0, T_mult)
&gt;&gt;&gt; iters = len(dataloader)
&gt;&gt;&gt; for epoch in range(20):
&gt;&gt;&gt;     for i, sample in enumerate(dataloader):
&gt;&gt;&gt;         inputs, labels = sample['inputs'], sample['labels']
&gt;&gt;&gt;         optimizer.zero_grad()
&gt;&gt;&gt;         outputs = net(inputs)
&gt;&gt;&gt;         loss = criterion(outputs, labels)
&gt;&gt;&gt;         loss.backward()
&gt;&gt;&gt;         optimizer.step()
&gt;&gt;&gt;         scheduler.step(epoch + i / iters)
</pre> <p>This function can be called in an interleaved way.</p> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; scheduler = CosineAnnealingWarmRestarts(optimizer, T_0, T_mult)
&gt;&gt;&gt; for epoch in range(20):
&gt;&gt;&gt;     scheduler.step()
&gt;&gt;&gt; scheduler.step(26)
&gt;&gt;&gt; scheduler.step() # scheduler.step(27), instead of scheduler(20)
</pre> </dd>
</dl> </dd>
</dl>   <h2 id="stochastic-weight-averaging">Stochastic Weight Averaging</h2> <p><code>torch.optim.swa_utils</code> implements Stochastic Weight Averaging (SWA). In particular, <code>torch.optim.swa_utils.AveragedModel</code> class implements SWA models, <code>torch.optim.swa_utils.SWALR</code> implements the SWA learning rate scheduler and <code>torch.optim.swa_utils.update_bn()</code> is a utility function used to update SWA batch normalization statistics at the end of training.</p> <p>SWA has been proposed in <a class="reference external" href="https://arxiv.org/abs/1803.05407">Averaging Weights Leads to Wider Optima and Better Generalization</a>.</p>  <h3 id="constructing-averaged-models">Constructing averaged models</h3> <p><code>AveragedModel</code> class serves to compute the weights of the SWA model. You can create an averaged model by running:</p> <pre data-language="python">&gt;&gt;&gt; swa_model = AveragedModel(model)
</pre> <p>Here the model <code>model</code> can be an arbitrary <a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module"><code>torch.nn.Module</code></a> object. <code>swa_model</code> will keep track of the running averages of the parameters of the <code>model</code>. To update these averages, you can use the <code>update_parameters()</code> function:</p> <pre data-language="python">&gt;&gt;&gt; swa_model.update_parameters(model)
</pre>   <h3 id="swa-learning-rate-schedules">SWA learning rate schedules</h3> <p>Typically, in SWA the learning rate is set to a high constant value. <code>SWALR</code> is a learning rate scheduler that anneals the learning rate to a fixed value, and then keeps it constant. For example, the following code creates a scheduler that linearly anneals the learning rate from its initial value to 0.05 in 5 epochs within each parameter group:</p> <pre data-language="python">&gt;&gt;&gt; swa_scheduler = torch.optim.swa_utils.SWALR(optimizer, \
&gt;&gt;&gt;         anneal_strategy="linear", anneal_epochs=5, swa_lr=0.05)
</pre> <p>You can also use cosine annealing to a fixed value instead of linear annealing by setting <code>anneal_strategy="cos"</code>.</p>   <h3 id="taking-care-of-batch-normalization">Taking care of batch normalization</h3> <p><code>update_bn()</code> is a utility function that allows to compute the batchnorm statistics for the SWA model on a given dataloader <code>loader</code> at the end of training:</p> <pre data-language="python">&gt;&gt;&gt; torch.optim.swa_utils.update_bn(loader, swa_model)
</pre> <p><code>update_bn()</code> applies the <code>swa_model</code> to every element in the dataloader and computes the activation statistics for each batch normalization layer in the model.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><code>update_bn()</code> assumes that each batch in the dataloader <code>loader</code> is either a tensors or a list of tensors where the first element is the tensor that the network <code>swa_model</code> should be applied to. If your dataloader has a different structure, you can update the batch normalization statistics of the <code>swa_model</code> by doing a forward pass with the <code>swa_model</code> on each element of the dataset.</p> </div>   <h3 id="custom-averaging-strategies">Custom averaging strategies</h3> <p>By default, <code>torch.optim.swa_utils.AveragedModel</code> computes a running equal average of the parameters that you provide, but you can also use custom averaging functions with the <code>avg_fn</code> parameter. In the following example <code>ema_model</code> computes an exponential moving average.</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; ema_avg = lambda averaged_model_parameter, model_parameter, num_averaged:\
&gt;&gt;&gt;         0.1 * averaged_model_parameter + 0.9 * model_parameter
&gt;&gt;&gt; ema_model = torch.optim.swa_utils.AveragedModel(model, avg_fn=ema_avg)
</pre>   <h3 id="putting-it-all-together">Putting it all together</h3> <p>In the example below, <code>swa_model</code> is the SWA model that accumulates the averages of the weights. We train the model for a total of 300 epochs and we switch to the SWA learning rate schedule and start to collect SWA averages of the parameters at epoch 160:</p> <pre data-language="python">&gt;&gt;&gt; loader, optimizer, model, loss_fn = ...
&gt;&gt;&gt; swa_model = torch.optim.swa_utils.AveragedModel(model)
&gt;&gt;&gt; scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max=300)
&gt;&gt;&gt; swa_start = 160
&gt;&gt;&gt; swa_scheduler = SWALR(optimizer, swa_lr=0.05)
&gt;&gt;&gt;
&gt;&gt;&gt; for epoch in range(300):
&gt;&gt;&gt;       for input, target in loader:
&gt;&gt;&gt;           optimizer.zero_grad()
&gt;&gt;&gt;           loss_fn(model(input), target).backward()
&gt;&gt;&gt;           optimizer.step()
&gt;&gt;&gt;       if epoch &gt; swa_start:
&gt;&gt;&gt;           swa_model.update_parameters(model)
&gt;&gt;&gt;           swa_scheduler.step()
&gt;&gt;&gt;       else:
&gt;&gt;&gt;           scheduler.step()
&gt;&gt;&gt;
&gt;&gt;&gt; # Update bn statistics for the swa_model at the end
&gt;&gt;&gt; torch.optim.swa_utils.update_bn(loader, swa_model)
&gt;&gt;&gt; # Use swa_model to make predictions on test data
&gt;&gt;&gt; preds = swa_model(test_input)
</pre><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://pytorch.org/docs/1.8.0/optim.html" class="_attribution-link" target="_blank">https://pytorch.org/docs/1.8.0/optim.html</a>
  </p>
</div>
