<h1 id="automatic-differentiation-package-torch-autograd">Automatic differentiation package - torch.autograd</h1> <p id="module-torch.autograd"><code>torch.autograd</code> provides classes and functions implementing automatic differentiation of arbitrary scalar valued functions. It requires minimal changes to the existing code - you only need to declare <code>Tensor</code> s for which gradients should be computed with the <code>requires_grad=True</code> keyword. As of now, we only support autograd for floating point <code>Tensor</code> types ( half, float, double and bfloat16) and complex <code>Tensor</code> types (cfloat, cdouble).</p> <dl class="function"> <dt id="torch.autograd.backward">
<code>torch.autograd.backward(tensors, grad_tensors=None, retain_graph=None, create_graph=False, grad_variables=None, inputs=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd.html#backward"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Computes the sum of gradients of given tensors w.r.t. graph leaves.</p> <p>The graph is differentiated using the chain rule. If any of <code>tensors</code> are non-scalar (i.e. their data has more than one element) and require gradient, then the Jacobian-vector product would be computed, in this case the function additionally requires specifying <code>grad_tensors</code>. It should be a sequence of matching length, that contains the “vector” in the Jacobian-vector product, usually the gradient of the differentiated function w.r.t. corresponding tensors (<code>None</code> is an acceptable value for all tensors that don’t need gradient tensors).</p> <p>This function accumulates gradients in the leaves - you might need to zero <code>.grad</code> attributes or set them to <code>None</code> before calling it. See <a class="reference internal" href="#default-grad-layouts"><span class="std std-ref">Default gradient layouts</span></a> for details on the memory layout of accumulated gradients.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Using this method with <code>create_graph=True</code> will create a reference cycle between the parameter and its gradient which can cause a memory leak. We recommend using <code>autograd.grad</code> when creating the graph to avoid this. If you have to use this function, make sure to reset the <code>.grad</code> fields of your parameters to <code>None</code> after use to break the cycle and avoid the leak.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you run any forward ops, create <code>grad_tensors</code>, and/or call <code>backward</code> in a user-specified CUDA stream context, see <a class="reference internal" href="https://pytorch.org/docs/1.8.0/notes/cuda.html#bwd-cuda-stream-semantics"><span class="std std-ref">Stream semantics of backward passes</span></a>.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>tensors</strong> (<em>sequence of Tensor</em>) – Tensors of which the derivative will be computed.</li> <li>
<strong>grad_tensors</strong> (<em>sequence of</em><em> (</em><a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)">None</a><em>)</em>) – The “vector” in the Jacobian-vector product, usually gradients w.r.t. each element of corresponding tensors. None values can be specified for scalar Tensors or ones that don’t require grad. If a None value would be acceptable for all grad_tensors, then this argument is optional.</li> <li>
<strong>retain_graph</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If <code>False</code>, the graph used to compute the grad will be freed. Note that in nearly all cases setting this option to <code>True</code> is not needed and often can be worked around in a much more efficient way. Defaults to the value of <code>create_graph</code>.</li> <li>
<strong>create_graph</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If <code>True</code>, graph of the derivative will be constructed, allowing to compute higher order derivative products. Defaults to <code>False</code>.</li> <li>
<strong>inputs</strong> (<em>sequence of Tensor</em>) – Inputs w.r.t. which the gradient will be accumulated into <code>.grad</code>. All other Tensors will be ignored. If not provided, the gradient is accumulated into all the leaf Tensors that were used to compute the attr::tensors. All the provided inputs must be leaf Tensors.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="function"> <dt id="torch.autograd.grad">
<code>torch.autograd.grad(outputs, inputs, grad_outputs=None, retain_graph=None, create_graph=False, only_inputs=True, allow_unused=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd.html#grad"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Computes and returns the sum of gradients of outputs w.r.t. the inputs.</p> <p><code>grad_outputs</code> should be a sequence of length matching <code>output</code> containing the “vector” in Jacobian-vector product, usually the pre-computed gradients w.r.t. each of the outputs. If an output doesn’t require_grad, then the gradient can be <code>None</code>).</p> <p>If <code>only_inputs</code> is <code>True</code>, the function will only return a list of gradients w.r.t the specified inputs. If it’s <code>False</code>, then gradient w.r.t. all remaining leaves will still be computed, and will be accumulated into their <code>.grad</code> attribute.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you run any forward ops, create <code>grad_outputs</code>, and/or call <code>grad</code> in a user-specified CUDA stream context, see <a class="reference internal" href="https://pytorch.org/docs/1.8.0/notes/cuda.html#bwd-cuda-stream-semantics"><span class="std std-ref">Stream semantics of backward passes</span></a>.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>outputs</strong> (<em>sequence of Tensor</em>) – outputs of the differentiated function.</li> <li>
<strong>inputs</strong> (<em>sequence of Tensor</em>) – Inputs w.r.t. which the gradient will be returned (and not accumulated into <code>.grad</code>).</li> <li>
<strong>grad_outputs</strong> (<em>sequence of Tensor</em>) – The “vector” in the Jacobian-vector product. Usually gradients w.r.t. each output. None values can be specified for scalar Tensors or ones that don’t require grad. If a None value would be acceptable for all grad_tensors, then this argument is optional. Default: None.</li> <li>
<strong>retain_graph</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If <code>False</code>, the graph used to compute the grad will be freed. Note that in nearly all cases setting this option to <code>True</code> is not needed and often can be worked around in a much more efficient way. Defaults to the value of <code>create_graph</code>.</li> <li>
<strong>create_graph</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If <code>True</code>, graph of the derivative will be constructed, allowing to compute higher order derivative products. Default: <code>False</code>.</li> <li>
<strong>allow_unused</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If <code>False</code>, specifying inputs that were not used when computing outputs (and therefore their grad is always zero) is an error. Defaults to <code>False</code>.</li> </ul> </dd> </dl> </dd>
</dl>  <h2 id="functional-api">Functional higher level API</h2> <div class="admonition warning" id="functional-higher-level-api"> <p class="admonition-title">Warning</p> <p>This API is in beta. Even though the function signatures are very unlikely to change, major improvements to performances are planned before we consider this stable.</p> </div> <p>This section contains the higher level API for the autograd that builds on the basic API above and allows you to compute jacobians, hessians, etc.</p> <p>This API works with user-provided functions that take only Tensors as input and return only Tensors. If your function takes other arguments that are not Tensors or Tensors that don’t have requires_grad set, you can use a lambda to capture them. For example, for a function <code>f</code> that takes three inputs, a Tensor for which we want the jacobian, another tensor that should be considered constant and a boolean flag as <code>f(input, constant, flag=flag)</code> you can use it as <code>functional.jacobian(lambda x: f(x, constant, flag=flag), input)</code>.</p> <dl class="function"> <dt id="torch.autograd.functional.jacobian">
<code>torch.autograd.functional.jacobian(func, inputs, create_graph=False, strict=False, vectorize=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/functional.html#jacobian"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Function that computes the Jacobian of a given function.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>func</strong> (<em>function</em>) – a Python function that takes Tensor inputs and returns a tuple of Tensors or a Tensor.</li> <li>
<strong>inputs</strong> (<em>tuple of Tensors</em><em> or </em><a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – inputs to the function <code>func</code>.</li> <li>
<strong>create_graph</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If <code>True</code>, the Jacobian will be computed in a differentiable manner. Note that when <code>strict</code> is <code>False</code>, the result can not require gradients or be disconnected from the inputs. Defaults to <code>False</code>.</li> <li>
<strong>strict</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If <code>True</code>, an error will be raised when we detect that there exists an input such that all the outputs are independent of it. If <code>False</code>, we return a Tensor of zeros as the jacobian for said inputs, which is the expected mathematical value. Defaults to <code>False</code>.</li> <li>
<strong>vectorize</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – This feature is experimental, please use at your own risk. When computing the jacobian, usually we invoke <code>autograd.grad</code> once per row of the jacobian. If this flag is <code>True</code>, we use the vmap prototype feature as the backend to vectorize calls to <code>autograd.grad</code> so we only invoke it once instead of once per row. This should lead to performance improvements in many use cases, however, due to this feature being incomplete, there may be performance cliffs. Please use <code>torch._C._debug_only_display_vmap_fallback_warnings(True)</code> to show any performance warnings and file us issues if warnings exist for your use case. Defaults to <code>False</code>.</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>if there is a single input and output, this will be a single Tensor containing the Jacobian for the linearized inputs and output. If one of the two is a tuple, then the Jacobian will be a tuple of Tensors. If both of them are tuples, then the Jacobian will be a tuple of tuple of Tensors where <code>Jacobian[i][j]</code> will contain the Jacobian of the <code>i</code>th output and <code>j</code>th input and will have as size the concatenation of the sizes of the corresponding output and the corresponding input and will have same dtype and device as the corresponding input.</p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p>Jacobian (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a> or nested tuple of Tensors)</p> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; def exp_reducer(x):
...   return x.exp().sum(dim=1)
&gt;&gt;&gt; inputs = torch.rand(2, 2)
&gt;&gt;&gt; jacobian(exp_reducer, inputs)
tensor([[[1.4917, 2.4352],
         [0.0000, 0.0000]],
        [[0.0000, 0.0000],
         [2.4369, 2.3799]]])
</pre> <pre data-language="python">&gt;&gt;&gt; jacobian(exp_reducer, inputs, create_graph=True)
tensor([[[1.4917, 2.4352],
         [0.0000, 0.0000]],
        [[0.0000, 0.0000],
         [2.4369, 2.3799]]], grad_fn=&lt;ViewBackward&gt;)
</pre> <pre data-language="python">&gt;&gt;&gt; def exp_adder(x, y):
...   return 2 * x.exp() + 3 * y
&gt;&gt;&gt; inputs = (torch.rand(2), torch.rand(2))
&gt;&gt;&gt; jacobian(exp_adder, inputs)
(tensor([[2.8052, 0.0000],
        [0.0000, 3.3963]]),
 tensor([[3., 0.],
         [0., 3.]]))
</pre> </dd>
</dl> <dl class="function"> <dt id="torch.autograd.functional.hessian">
<code>torch.autograd.functional.hessian(func, inputs, create_graph=False, strict=False, vectorize=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/functional.html#hessian"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Function that computes the Hessian of a given scalar function.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>func</strong> (<em>function</em>) – a Python function that takes Tensor inputs and returns a Tensor with a single element.</li> <li>
<strong>inputs</strong> (<em>tuple of Tensors</em><em> or </em><a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – inputs to the function <code>func</code>.</li> <li>
<strong>create_graph</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If <code>True</code>, the Hessian will be computed in a differentiable manner. Note that when <code>strict</code> is <code>False</code>, the result can not require gradients or be disconnected from the inputs. Defaults to <code>False</code>.</li> <li>
<strong>strict</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If <code>True</code>, an error will be raised when we detect that there exists an input such that all the outputs are independent of it. If <code>False</code>, we return a Tensor of zeros as the hessian for said inputs, which is the expected mathematical value. Defaults to <code>False</code>.</li> <li>
<strong>vectorize</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – This feature is experimental, please use at your own risk. When computing the hessian, usually we invoke <code>autograd.grad</code> once per row of the hessian. If this flag is <code>True</code>, we use the vmap prototype feature as the backend to vectorize calls to <code>autograd.grad</code> so we only invoke it once instead of once per row. This should lead to performance improvements in many use cases, however, due to this feature being incomplete, there may be performance cliffs. Please use <code>torch._C._debug_only_display_vmap_fallback_warnings(True)</code> to show any performance warnings and file us issues if warnings exist for your use case. Defaults to <code>False</code>.</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>if there is a single input, this will be a single Tensor containing the Hessian for the input. If it is a tuple, then the Hessian will be a tuple of tuples where <code>Hessian[i][j]</code> will contain the Hessian of the <code>i</code>th input and <code>j</code>th input with size the sum of the size of the <code>i</code>th input plus the size of the <code>j</code>th input. <code>Hessian[i][j]</code> will have the same dtype and device as the corresponding <code>i</code>th input.</p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p>Hessian (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a> or a tuple of tuple of Tensors)</p> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; def pow_reducer(x):
...   return x.pow(3).sum()
&gt;&gt;&gt; inputs = torch.rand(2, 2)
&gt;&gt;&gt; hessian(pow_reducer, inputs)
tensor([[[[5.2265, 0.0000],
          [0.0000, 0.0000]],
         [[0.0000, 4.8221],
          [0.0000, 0.0000]]],
        [[[0.0000, 0.0000],
          [1.9456, 0.0000]],
         [[0.0000, 0.0000],
          [0.0000, 3.2550]]]])
</pre> <pre data-language="python">&gt;&gt;&gt; hessian(pow_reducer, inputs, create_graph=True)
tensor([[[[5.2265, 0.0000],
          [0.0000, 0.0000]],
         [[0.0000, 4.8221],
          [0.0000, 0.0000]]],
        [[[0.0000, 0.0000],
          [1.9456, 0.0000]],
         [[0.0000, 0.0000],
          [0.0000, 3.2550]]]], grad_fn=&lt;ViewBackward&gt;)
</pre> <pre data-language="python">&gt;&gt;&gt; def pow_adder_reducer(x, y):
...   return (2 * x.pow(2) + 3 * y.pow(2)).sum()
&gt;&gt;&gt; inputs = (torch.rand(2), torch.rand(2))
&gt;&gt;&gt; hessian(pow_adder_reducer, inputs)
((tensor([[4., 0.],
          [0., 4.]]),
  tensor([[0., 0.],
          [0., 0.]])),
 (tensor([[0., 0.],
          [0., 0.]]),
  tensor([[6., 0.],
          [0., 6.]])))
</pre> </dd>
</dl> <dl class="function"> <dt id="torch.autograd.functional.vjp">
<code>torch.autograd.functional.vjp(func, inputs, v=None, create_graph=False, strict=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/functional.html#vjp"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Function that computes the dot product between a vector <code>v</code> and the Jacobian of the given function at the point given by the inputs.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>func</strong> (<em>function</em>) – a Python function that takes Tensor inputs and returns a tuple of Tensors or a Tensor.</li> <li>
<strong>inputs</strong> (<em>tuple of Tensors</em><em> or </em><a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – inputs to the function <code>func</code>.</li> <li>
<strong>v</strong> (<em>tuple of Tensors</em><em> or </em><a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – The vector for which the vector Jacobian product is computed. Must be the same size as the output of <code>func</code>. This argument is optional when the output of <code>func</code> contains a single element and (if it is not provided) will be set as a Tensor containing a single <code>1</code>.</li> <li>
<strong>create_graph</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If <code>True</code>, both the output and result will be computed in a differentiable way. Note that when <code>strict</code> is <code>False</code>, the result can not require gradients or be disconnected from the inputs. Defaults to <code>False</code>.</li> <li>
<strong>strict</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If <code>True</code>, an error will be raised when we detect that there exists an input such that all the outputs are independent of it. If <code>False</code>, we return a Tensor of zeros as the vjp for said inputs, which is the expected mathematical value. Defaults to <code>False</code>.</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">

<dl> <dt>tuple with:</dt>
<dd>
<p>func_output (tuple of Tensors or Tensor): output of <code>func(inputs)</code></p> <p>vjp (tuple of Tensors or Tensor): result of the dot product with the same shape as the inputs.</p> </dd> </dl> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p>output (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.9)">tuple</a>)</p> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; def exp_reducer(x):
...   return x.exp().sum(dim=1)
&gt;&gt;&gt; inputs = torch.rand(4, 4)
&gt;&gt;&gt; v = torch.ones(4)
&gt;&gt;&gt; vjp(exp_reducer, inputs, v)
(tensor([5.7817, 7.2458, 5.7830, 6.7782]),
 tensor([[1.4458, 1.3962, 1.3042, 1.6354],
        [2.1288, 1.0652, 1.5483, 2.5035],
        [2.2046, 1.1292, 1.1432, 1.3059],
        [1.3225, 1.6652, 1.7753, 2.0152]]))
</pre> <pre data-language="python">&gt;&gt;&gt; vjp(exp_reducer, inputs, v, create_graph=True)
(tensor([5.7817, 7.2458, 5.7830, 6.7782], grad_fn=&lt;SumBackward1&gt;),
 tensor([[1.4458, 1.3962, 1.3042, 1.6354],
        [2.1288, 1.0652, 1.5483, 2.5035],
        [2.2046, 1.1292, 1.1432, 1.3059],
        [1.3225, 1.6652, 1.7753, 2.0152]], grad_fn=&lt;MulBackward0&gt;))
</pre> <pre data-language="python">&gt;&gt;&gt; def adder(x, y):
...   return 2 * x + 3 * y
&gt;&gt;&gt; inputs = (torch.rand(2), torch.rand(2))
&gt;&gt;&gt; v = torch.ones(2)
&gt;&gt;&gt; vjp(adder, inputs, v)
(tensor([2.4225, 2.3340]),
 (tensor([2., 2.]), tensor([3., 3.])))
</pre> </dd>
</dl> <dl class="function"> <dt id="torch.autograd.functional.jvp">
<code>torch.autograd.functional.jvp(func, inputs, v=None, create_graph=False, strict=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/functional.html#jvp"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Function that computes the dot product between the Jacobian of the given function at the point given by the inputs and a vector <code>v</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>func</strong> (<em>function</em>) – a Python function that takes Tensor inputs and returns a tuple of Tensors or a Tensor.</li> <li>
<strong>inputs</strong> (<em>tuple of Tensors</em><em> or </em><a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – inputs to the function <code>func</code>.</li> <li>
<strong>v</strong> (<em>tuple of Tensors</em><em> or </em><a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – The vector for which the Jacobian vector product is computed. Must be the same size as the input of <code>func</code>. This argument is optional when the input to <code>func</code> contains a single element and (if it is not provided) will be set as a Tensor containing a single <code>1</code>.</li> <li>
<strong>create_graph</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If <code>True</code>, both the output and result will be computed in a differentiable way. Note that when <code>strict</code> is <code>False</code>, the result can not require gradients or be disconnected from the inputs. Defaults to <code>False</code>.</li> <li>
<strong>strict</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If <code>True</code>, an error will be raised when we detect that there exists an input such that all the outputs are independent of it. If <code>False</code>, we return a Tensor of zeros as the jvp for said inputs, which is the expected mathematical value. Defaults to <code>False</code>.</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">

<dl> <dt>tuple with:</dt>
<dd>
<p>func_output (tuple of Tensors or Tensor): output of <code>func(inputs)</code></p> <p>jvp (tuple of Tensors or Tensor): result of the dot product with the same shape as the output.</p> </dd> </dl> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p>output (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.9)">tuple</a>)</p> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; def exp_reducer(x):
...   return x.exp().sum(dim=1)
&gt;&gt;&gt; inputs = torch.rand(4, 4)
&gt;&gt;&gt; v = torch.ones(4, 4)
&gt;&gt;&gt; jvp(exp_reducer, inputs, v)
(tensor([6.3090, 4.6742, 7.9114, 8.2106]),
 tensor([6.3090, 4.6742, 7.9114, 8.2106]))
</pre> <pre data-language="python">&gt;&gt;&gt; jvp(exp_reducer, inputs, v, create_graph=True)
(tensor([6.3090, 4.6742, 7.9114, 8.2106], grad_fn=&lt;SumBackward1&gt;),
 tensor([6.3090, 4.6742, 7.9114, 8.2106], grad_fn=&lt;SqueezeBackward1&gt;))
</pre> <pre data-language="python">&gt;&gt;&gt; def adder(x, y):
...   return 2 * x + 3 * y
&gt;&gt;&gt; inputs = (torch.rand(2), torch.rand(2))
&gt;&gt;&gt; v = (torch.ones(2), torch.ones(2))
&gt;&gt;&gt; jvp(adder, inputs, v)
(tensor([2.2399, 2.5005]),
 tensor([5., 5.]))
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The jvp is currently computed by using the backward of the backward (sometimes called the double backwards trick) as we don’t have support for forward mode AD in PyTorch at the moment.</p> </div> </dd>
</dl> <dl class="function"> <dt id="torch.autograd.functional.vhp">
<code>torch.autograd.functional.vhp(func, inputs, v=None, create_graph=False, strict=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/functional.html#vhp"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Function that computes the dot product between a vector <code>v</code> and the Hessian of a given scalar function at the point given by the inputs.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>func</strong> (<em>function</em>) – a Python function that takes Tensor inputs and returns a Tensor with a single element.</li> <li>
<strong>inputs</strong> (<em>tuple of Tensors</em><em> or </em><a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – inputs to the function <code>func</code>.</li> <li>
<strong>v</strong> (<em>tuple of Tensors</em><em> or </em><a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – The vector for which the vector Hessian product is computed. Must be the same size as the input of <code>func</code>. This argument is optional when <code>func</code>’s input contains a single element and (if it is not provided) will be set as a Tensor containing a single <code>1</code>.</li> <li>
<strong>create_graph</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If <code>True</code>, both the output and result will be computed in a differentiable way. Note that when <code>strict</code> is <code>False</code>, the result can not require gradients or be disconnected from the inputs. Defaults to <code>False</code>.</li> <li>
<strong>strict</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If <code>True</code>, an error will be raised when we detect that there exists an input such that all the outputs are independent of it. If <code>False</code>, we return a Tensor of zeros as the vhp for said inputs, which is the expected mathematical value. Defaults to <code>False</code>.</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">

<dl> <dt>tuple with:</dt>
<dd>
<p>func_output (tuple of Tensors or Tensor): output of <code>func(inputs)</code></p> <p>vhp (tuple of Tensors or Tensor): result of the dot product with the same shape as the inputs.</p> </dd> </dl> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p>output (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.9)">tuple</a>)</p> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; def pow_reducer(x):
...   return x.pow(3).sum()
&gt;&gt;&gt; inputs = torch.rand(2, 2)
&gt;&gt;&gt; v = torch.ones(2, 2)
&gt;&gt;&gt; vhp(pow_reducer, inputs, v)
(tensor(0.5591),
 tensor([[1.0689, 1.2431],
         [3.0989, 4.4456]]))
&gt;&gt;&gt; vhp(pow_reducer, inputs, v, create_graph=True)
(tensor(0.5591, grad_fn=&lt;SumBackward0&gt;),
 tensor([[1.0689, 1.2431],
         [3.0989, 4.4456]], grad_fn=&lt;MulBackward0&gt;))
&gt;&gt;&gt; def pow_adder_reducer(x, y):
...   return (2 * x.pow(2) + 3 * y.pow(2)).sum()
&gt;&gt;&gt; inputs = (torch.rand(2), torch.rand(2))
&gt;&gt;&gt; v = (torch.zeros(2), torch.ones(2))
&gt;&gt;&gt; vhp(pow_adder_reducer, inputs, v)
(tensor(4.8053),
 (tensor([0., 0.]),
  tensor([6., 6.])))
</pre> </dd>
</dl> <dl class="function"> <dt id="torch.autograd.functional.hvp">
<code>torch.autograd.functional.hvp(func, inputs, v=None, create_graph=False, strict=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/functional.html#hvp"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Function that computes the dot product between the Hessian of a given scalar function and a vector <code>v</code> at the point given by the inputs.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>func</strong> (<em>function</em>) – a Python function that takes Tensor inputs and returns a Tensor with a single element.</li> <li>
<strong>inputs</strong> (<em>tuple of Tensors</em><em> or </em><a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – inputs to the function <code>func</code>.</li> <li>
<strong>v</strong> (<em>tuple of Tensors</em><em> or </em><a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – The vector for which the Hessian vector product is computed. Must be the same size as the input of <code>func</code>. This argument is optional when <code>func</code>’s input contains a single element and (if it is not provided) will be set as a Tensor containing a single <code>1</code>.</li> <li>
<strong>create_graph</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If <code>True</code>, both the output and result will be computed in a differentiable way. Note that when <code>strict</code> is <code>False</code>, the result can not require gradients or be disconnected from the inputs. Defaults to <code>False</code>.</li> <li>
<strong>strict</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If <code>True</code>, an error will be raised when we detect that there exists an input such that all the outputs are independent of it. If <code>False</code>, we return a Tensor of zeros as the hvp for said inputs, which is the expected mathematical value. Defaults to <code>False</code>.</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">

<dl> <dt>tuple with:</dt>
<dd>
<p>func_output (tuple of Tensors or Tensor): output of <code>func(inputs)</code></p> <p>hvp (tuple of Tensors or Tensor): result of the dot product with the same shape as the inputs.</p> </dd> </dl> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p>output (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.9)">tuple</a>)</p> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; def pow_reducer(x):
...   return x.pow(3).sum()
&gt;&gt;&gt; inputs = torch.rand(2, 2)
&gt;&gt;&gt; v = torch.ones(2, 2)
&gt;&gt;&gt; hvp(pow_reducer, inputs, v)
(tensor(0.1448),
 tensor([[2.0239, 1.6456],
         [2.4988, 1.4310]]))
</pre> <pre data-language="python">&gt;&gt;&gt; hvp(pow_reducer, inputs, v, create_graph=True)
(tensor(0.1448, grad_fn=&lt;SumBackward0&gt;),
 tensor([[2.0239, 1.6456],
         [2.4988, 1.4310]], grad_fn=&lt;MulBackward0&gt;))
</pre> <pre data-language="python">&gt;&gt;&gt; def pow_adder_reducer(x, y):
...   return (2 * x.pow(2) + 3 * y.pow(2)).sum()
&gt;&gt;&gt; inputs = (torch.rand(2), torch.rand(2))
&gt;&gt;&gt; v = (torch.zeros(2), torch.ones(2))
&gt;&gt;&gt; hvp(pow_adder_reducer, inputs, v)
(tensor(2.3030),
 (tensor([0., 0.]),
  tensor([6., 6.])))
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function is significantly slower than <code>vhp</code> due to backward mode AD constraints. If your functions is twice continuously differentiable, then hvp = vhp.t(). So if you know that your function satisfies this condition, you should use vhp instead that is much faster with the current implementation.</p> </div> </dd>
</dl>   <h2 id="locally-disable-grad">Locally disabling gradient computation</h2> <dl class="class" id="locally-disabling-gradient-computation"> <dt id="torch.autograd.no_grad">
<code>class torch.autograd.no_grad</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/grad_mode.html#no_grad"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Context-manager that disabled gradient calculation.</p> <p>Disabling gradient calculation is useful for inference, when you are sure that you will not call <code>Tensor.backward()</code>. It will reduce memory consumption for computations that would otherwise have <code>requires_grad=True</code>.</p> <p>In this mode, the result of every computation will have <code>requires_grad=False</code>, even when the inputs have <code>requires_grad=True</code>.</p> <p>This context manager is thread local; it will not affect computation in other threads.</p> <p>Also functions as a decorator. (Make sure to instantiate with parenthesis.)</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; x = torch.tensor([1], requires_grad=True)
&gt;&gt;&gt; with torch.no_grad():
...   y = x * 2
&gt;&gt;&gt; y.requires_grad
False
&gt;&gt;&gt; @torch.no_grad()
... def doubler(x):
...     return x * 2
&gt;&gt;&gt; z = doubler(x)
&gt;&gt;&gt; z.requires_grad
False
</pre> </dd>
</dl> <dl class="class"> <dt id="torch.autograd.enable_grad">
<code>class torch.autograd.enable_grad</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/grad_mode.html#enable_grad"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Context-manager that enables gradient calculation.</p> <p>Enables gradient calculation, if it has been disabled via <a class="reference internal" href="#torch.autograd.no_grad" title="torch.autograd.no_grad"><code>no_grad</code></a> or <a class="reference internal" href="#torch.autograd.set_grad_enabled" title="torch.autograd.set_grad_enabled"><code>set_grad_enabled</code></a>.</p> <p>This context manager is thread local; it will not affect computation in other threads.</p> <p>Also functions as a decorator. (Make sure to instantiate with parenthesis.)</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; x = torch.tensor([1], requires_grad=True)
&gt;&gt;&gt; with torch.no_grad():
...   with torch.enable_grad():
...     y = x * 2
&gt;&gt;&gt; y.requires_grad
True
&gt;&gt;&gt; y.backward()
&gt;&gt;&gt; x.grad
&gt;&gt;&gt; @torch.enable_grad()
... def doubler(x):
...     return x * 2
&gt;&gt;&gt; with torch.no_grad():
...     z = doubler(x)
&gt;&gt;&gt; z.requires_grad
True
</pre> </dd>
</dl> <dl class="class"> <dt id="torch.autograd.set_grad_enabled">
<code>class torch.autograd.set_grad_enabled(mode)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/grad_mode.html#set_grad_enabled"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Context-manager that sets gradient calculation to on or off.</p> <p><code>set_grad_enabled</code> will enable or disable grads based on its argument <code>mode</code>. It can be used as a context-manager or as a function.</p> <p>This context manager is thread local; it will not affect computation in other threads.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – Flag whether to enable grad (<code>True</code>), or disable (<code>False</code>). This can be used to conditionally enable gradients.</p> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; x = torch.tensor([1], requires_grad=True)
&gt;&gt;&gt; is_train = False
&gt;&gt;&gt; with torch.set_grad_enabled(is_train):
...   y = x * 2
&gt;&gt;&gt; y.requires_grad
False
&gt;&gt;&gt; torch.set_grad_enabled(True)
&gt;&gt;&gt; y = x * 2
&gt;&gt;&gt; y.requires_grad
True
&gt;&gt;&gt; torch.set_grad_enabled(False)
&gt;&gt;&gt; y = x * 2
&gt;&gt;&gt; y.requires_grad
False
</pre> </dd>
</dl>   <h2 id="default-grad-layouts">Default gradient layouts</h2> <p id="default-gradient-layouts">When a non-sparse <code>param</code> receives a non-sparse gradient during <a class="reference internal" href="#torch.autograd.backward" title="torch.autograd.backward"><code>torch.autograd.backward()</code></a> or <a class="reference internal" href="#torch.Tensor.backward" title="torch.Tensor.backward"><code>torch.Tensor.backward()</code></a> <code>param.grad</code> is accumulated as follows.</p> <p>If <code>param.grad</code> is initially <code>None</code>:</p> <ol class="arabic simple"> <li>If <code>param</code>’s memory is non-overlapping and dense, <code>.grad</code> is created with strides matching <code>param</code> (thus matching <code>param</code>’s layout).</li> <li>Otherwise, <code>.grad</code> is created with rowmajor-contiguous strides.</li> </ol> <p>If <code>param</code> already has a non-sparse <code>.grad</code> attribute:</p> <ol class="arabic simple" start="3"> <li>If <code>create_graph=False</code>, <code>backward()</code> accumulates into <code>.grad</code> in-place, which preserves its strides.</li> <li>If <code>create_graph=True</code>, <code>backward()</code> replaces <code>.grad</code> with a new tensor <code>.grad + new grad</code>, which attempts (but does not guarantee) matching the preexisting <code>.grad</code>’s strides.</li> </ol> <p>The default behavior (letting <code>.grad</code>s be <code>None</code> before the first <code>backward()</code>, such that their layout is created according to 1 or 2, and retained over time according to 3 or 4) is recommended for best performance. Calls to <code>model.zero_grad()</code> or <code>optimizer.zero_grad()</code> will not affect <code>.grad</code> layouts.</p> <p>In fact, resetting all <code>.grad</code>s to <code>None</code> before each accumulation phase, e.g.:</p> <pre data-language="python">for iterations...
    ...
    for param in model.parameters():
        param.grad = None
    loss.backward()
</pre> <p>such that they’re recreated according to 1 or 2 every time, is a valid alternative to <code>model.zero_grad()</code> or <code>optimizer.zero_grad()</code> that may improve performance for some networks.</p>  <h3 id="manual-gradient-layouts">Manual gradient layouts</h3> <p>If you need manual control over <code>.grad</code>’s strides, assign <code>param.grad =</code> a zeroed tensor with desired strides before the first <code>backward()</code>, and never reset it to <code>None</code>. 3 guarantees your layout is preserved as long as <code>create_graph=False</code>. 4 indicates your layout is <em>likely</em> preserved even if <code>create_graph=True</code>.</p>    <h2 id="in-place-operations-on-tensors">In-place operations on Tensors</h2> <p>Supporting in-place operations in autograd is a hard matter, and we discourage their use in most cases. Autograd’s aggressive buffer freeing and reuse makes it very efficient and there are very few occasions when in-place operations actually lower memory usage by any significant amount. Unless you’re operating under heavy memory pressure, you might never need to use them.</p>  <h3 id="in-place-correctness-checks">In-place correctness checks</h3> <p>All <code>Tensor</code> s keep track of in-place operations applied to them, and if the implementation detects that a tensor was saved for backward in one of the functions, but it was modified in-place afterwards, an error will be raised once backward pass is started. This ensures that if you’re using in-place functions and not seeing any errors, you can be sure that the computed gradients are correct.</p>    <h2 id="variable-deprecated">Variable (deprecated)</h2> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The Variable API has been deprecated: Variables are no longer necessary to use autograd with tensors. Autograd automatically supports Tensors with <code>requires_grad</code> set to <code>True</code>. Below please find a quick guide on what has changed:</p> <ul class="simple"> <li>
<code>Variable(tensor)</code> and <code>Variable(tensor, requires_grad)</code> still work as expected, but they return Tensors instead of Variables.</li> <li>
<code>var.data</code> is the same thing as <code>tensor.data</code>.</li> <li>Methods such as <code>var.backward(), var.detach(), var.register_hook()</code> now work on tensors with the same method names.</li> </ul> <p>In addition, one can now create tensors with <code>requires_grad=True</code> using factory methods such as <a class="reference internal" href="generated/torch.randn#torch.randn" title="torch.randn"><code>torch.randn()</code></a>, <a class="reference internal" href="generated/torch.zeros#torch.zeros" title="torch.zeros"><code>torch.zeros()</code></a>, <a class="reference internal" href="generated/torch.ones#torch.ones" title="torch.ones"><code>torch.ones()</code></a>, and others like the following:</p> <p><code>autograd_tensor = torch.randn((2, 3, 4), requires_grad=True)</code></p> </div>   <h2 id="tensor-autograd-functions">Tensor autograd functions</h2> <dl class="class"> <dt>
<code>class torch.Tensor</code> </dt> <dd>
<dl class="attribute"> <dt id="torch.Tensor.grad">
<code>grad</code> </dt> <dd>
<p>This attribute is <code>None</code> by default and becomes a Tensor the first time a call to <a class="reference internal" href="#torch.Tensor.backward" title="torch.Tensor.backward"><code>backward()</code></a> computes gradients for <code>self</code>. The attribute will then contain the gradients computed and future calls to <a class="reference internal" href="#torch.Tensor.backward" title="torch.Tensor.backward"><code>backward()</code></a> will accumulate (add) gradients into it.</p> </dd>
</dl> <dl class="attribute"> <dt id="torch.Tensor.requires_grad">
<code>requires_grad</code> </dt> <dd>
<p>Is <code>True</code> if gradients need to be computed for this Tensor, <code>False</code> otherwise.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The fact that gradients need to be computed for a Tensor do not mean that the <a class="reference internal" href="#torch.Tensor.grad" title="torch.Tensor.grad"><code>grad</code></a> attribute will be populated, see <a class="reference internal" href="#torch.Tensor.is_leaf" title="torch.Tensor.is_leaf"><code>is_leaf</code></a> for more details.</p> </div> </dd>
</dl> <dl class="attribute"> <dt id="torch.Tensor.is_leaf">
<code>is_leaf</code> </dt> <dd>
<p>All Tensors that have <a class="reference internal" href="#torch.Tensor.requires_grad" title="torch.Tensor.requires_grad"><code>requires_grad</code></a> which is <code>False</code> will be leaf Tensors by convention.</p> <p>For Tensors that have <a class="reference internal" href="#torch.Tensor.requires_grad" title="torch.Tensor.requires_grad"><code>requires_grad</code></a> which is <code>True</code>, they will be leaf Tensors if they were created by the user. This means that they are not the result of an operation and so <code>grad_fn</code> is None.</p> <p>Only leaf Tensors will have their <a class="reference internal" href="#torch.Tensor.grad" title="torch.Tensor.grad"><code>grad</code></a> populated during a call to <a class="reference internal" href="#torch.Tensor.backward" title="torch.Tensor.backward"><code>backward()</code></a>. To get <a class="reference internal" href="#torch.Tensor.grad" title="torch.Tensor.grad"><code>grad</code></a> populated for non-leaf Tensors, you can use <a class="reference internal" href="#torch.Tensor.retain_grad" title="torch.Tensor.retain_grad"><code>retain_grad()</code></a>.</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; a = torch.rand(10, requires_grad=True)
&gt;&gt;&gt; a.is_leaf
True
&gt;&gt;&gt; b = torch.rand(10, requires_grad=True).cuda()
&gt;&gt;&gt; b.is_leaf
False
# b was created by the operation that cast a cpu Tensor into a cuda Tensor
&gt;&gt;&gt; c = torch.rand(10, requires_grad=True) + 2
&gt;&gt;&gt; c.is_leaf
False
# c was created by the addition operation
&gt;&gt;&gt; d = torch.rand(10).cuda()
&gt;&gt;&gt; d.is_leaf
True
# d does not require gradients and so has no operation creating it (that is tracked by the autograd engine)
&gt;&gt;&gt; e = torch.rand(10).cuda().requires_grad_()
&gt;&gt;&gt; e.is_leaf
True
# e requires gradients and has no operations creating it
&gt;&gt;&gt; f = torch.rand(10, requires_grad=True, device="cuda")
&gt;&gt;&gt; f.is_leaf
True
# f requires grad, has no operation creating it
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.backward">
<code>backward(gradient=None, retain_graph=None, create_graph=False, inputs=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/tensor.html#Tensor.backward"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Computes the gradient of current tensor w.r.t. graph leaves.</p> <p>The graph is differentiated using the chain rule. If the tensor is non-scalar (i.e. its data has more than one element) and requires gradient, the function additionally requires specifying <code>gradient</code>. It should be a tensor of matching type and location, that contains the gradient of the differentiated function w.r.t. <code>self</code>.</p> <p>This function accumulates gradients in the leaves - you might need to zero <code>.grad</code> attributes or set them to <code>None</code> before calling it. See <a class="reference internal" href="#default-grad-layouts"><span class="std std-ref">Default gradient layouts</span></a> for details on the memory layout of accumulated gradients.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you run any forward ops, create <code>gradient</code>, and/or call <code>backward</code> in a user-specified CUDA stream context, see <a class="reference internal" href="https://pytorch.org/docs/1.8.0/notes/cuda.html#bwd-cuda-stream-semantics"><span class="std std-ref">Stream semantics of backward passes</span></a>.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>gradient</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)">None</a>) – Gradient w.r.t. the tensor. If it is a tensor, it will be automatically converted to a Tensor that does not require grad unless <code>create_graph</code> is True. None values can be specified for scalar Tensors or ones that don’t require grad. If a None value would be acceptable then this argument is optional.</li> <li>
<strong>retain_graph</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If <code>False</code>, the graph used to compute the grads will be freed. Note that in nearly all cases setting this option to True is not needed and often can be worked around in a much more efficient way. Defaults to the value of <code>create_graph</code>.</li> <li>
<strong>create_graph</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If <code>True</code>, graph of the derivative will be constructed, allowing to compute higher order derivative products. Defaults to <code>False</code>.</li> <li>
<strong>inputs</strong> (<em>sequence of Tensor</em>) – Inputs w.r.t. which the gradient will be accumulated into <code>.grad</code>. All other Tensors will be ignored. If not provided, the gradient is accumulated into all the leaf Tensors that were used to compute the attr::tensors. All the provided inputs must be leaf Tensors.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.detach">
<code>detach()</code> </dt> <dd>
<p>Returns a new Tensor, detached from the current graph.</p> <p>The result will never require gradient.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Returned Tensor shares the same storage with the original one. In-place modifications on either of them will be seen, and may trigger errors in correctness checks. IMPORTANT NOTE: Previously, in-place size / stride / storage changes (such as <code>resize_</code> / <code>resize_as_</code> / <code>set_</code> / <code>transpose_</code>) to the returned tensor also update the original tensor. Now, these in-place changes will not update the original tensor anymore, and will instead trigger an error. For sparse tensors: In-place indices / values changes (such as <code>zero_</code> / <code>copy_</code> / <code>add_</code>) to the returned tensor will not update the original tensor anymore, and will instead trigger an error.</p> </div> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.detach_">
<code>detach_()</code> </dt> <dd>
<p>Detaches the Tensor from the graph that created it, making it a leaf. Views cannot be detached in-place.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.register_hook">
<code>register_hook(hook)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/tensor.html#Tensor.register_hook"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Registers a backward hook.</p> <p>The hook will be called every time a gradient with respect to the Tensor is computed. The hook should have the following signature:</p> <pre data-language="python">hook(grad) -&gt; Tensor or None
</pre> <p>The hook should not modify its argument, but it can optionally return a new gradient which will be used in place of <a class="reference internal" href="#torch.Tensor.grad" title="torch.Tensor.grad"><code>grad</code></a>.</p> <p>This function returns a handle with a method <code>handle.remove()</code> that removes the hook from the module.</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; v = torch.tensor([0., 0., 0.], requires_grad=True)
&gt;&gt;&gt; h = v.register_hook(lambda grad: grad * 2)  # double the gradient
&gt;&gt;&gt; v.backward(torch.tensor([1., 2., 3.]))
&gt;&gt;&gt; v.grad

 2
 4
 6
[torch.FloatTensor of size (3,)]

&gt;&gt;&gt; h.remove()  # removes the hook
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.retain_grad">
<code>retain_grad()</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/tensor.html#Tensor.retain_grad"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Enables .grad attribute for non-leaf Tensors.</p> </dd>
</dl> </dd>
</dl>   <h2 id="function"><span class="hidden-section">Function</span></h2> <dl class="class"> <dt id="torch.autograd.Function">
<code>class torch.autograd.Function</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/function.html#Function"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Records operation history and defines formulas for differentiating ops.</p> <p>See the Note on extending the autograd engine for more details on how to use this class: <a class="reference external" href="https://pytorch.org/docs/stable/notes/extending.html#extending-torch-autograd">https://pytorch.org/docs/stable/notes/extending.html#extending-torch-autograd</a></p> <p>Every operation performed on <code>Tensor</code> s creates a new function object, that performs the computation, and records that it happened. The history is retained in the form of a DAG of functions, with edges denoting data dependencies (<code>input &lt;- output</code>). Then, when backward is called, the graph is processed in the topological ordering, by calling <a class="reference internal" href="#torch.autograd.backward" title="torch.autograd.backward"><code>backward()</code></a> methods of each <a class="reference internal" href="#torch.autograd.Function" title="torch.autograd.Function"><code>Function</code></a> object, and passing returned gradients on to next <a class="reference internal" href="#torch.autograd.Function" title="torch.autograd.Function"><code>Function</code></a> s.</p> <p>Normally, the only way users interact with functions is by creating subclasses and defining new operations. This is a recommended way of extending torch.autograd.</p> <p>Examples:</p> <pre data-language="python">&gt;&gt;&gt; class Exp(Function):
&gt;&gt;&gt;
&gt;&gt;&gt;     @staticmethod
&gt;&gt;&gt;     def forward(ctx, i):
&gt;&gt;&gt;         result = i.exp()
&gt;&gt;&gt;         ctx.save_for_backward(result)
&gt;&gt;&gt;         return result
&gt;&gt;&gt;
&gt;&gt;&gt;     @staticmethod
&gt;&gt;&gt;     def backward(ctx, grad_output):
&gt;&gt;&gt;         result, = ctx.saved_tensors
&gt;&gt;&gt;         return grad_output * result
&gt;&gt;&gt;
&gt;&gt;&gt; #Use it by calling the apply method:
&gt;&gt;&gt; output = Exp.apply(input)
</pre> <dl class="method"> <dt id="torch.autograd.Function.backward">
<code>static backward(ctx, *grad_outputs)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/function.html#Function.backward"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Defines a formula for differentiating the operation.</p> <p>This function is to be overridden by all subclasses.</p> <p>It must accept a context <code>ctx</code> as the first argument, followed by as many outputs did <a class="reference internal" href="#torch.autograd.Function.forward" title="torch.autograd.Function.forward"><code>forward()</code></a> return, and it should return as many tensors, as there were inputs to <a class="reference internal" href="#torch.autograd.Function.forward" title="torch.autograd.Function.forward"><code>forward()</code></a>. Each argument is the gradient w.r.t the given output, and each returned value should be the gradient w.r.t. the corresponding input.</p> <p>The context can be used to retrieve tensors saved during the forward pass. It also has an attribute <code>ctx.needs_input_grad</code> as a tuple of booleans representing whether each input needs gradient. E.g., <a class="reference internal" href="#torch.autograd.backward" title="torch.autograd.backward"><code>backward()</code></a> will have <code>ctx.needs_input_grad[0] = True</code> if the first input to <a class="reference internal" href="#torch.autograd.Function.forward" title="torch.autograd.Function.forward"><code>forward()</code></a> needs gradient computated w.r.t. the output.</p> </dd>
</dl> <dl class="method"> <dt id="torch.autograd.Function.forward">
<code>static forward(ctx, *args, **kwargs)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/function.html#Function.forward"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs the operation.</p> <p>This function is to be overridden by all subclasses.</p> <p>It must accept a context ctx as the first argument, followed by any number of arguments (tensors or other types).</p> <p>The context can be used to store tensors that can be then retrieved during the backward pass.</p> </dd>
</dl> </dd>
</dl>   <h2 id="context-method-mixins">Context method mixins</h2> <p>When creating a new <a class="reference internal" href="#torch.autograd.Function" title="torch.autograd.Function"><code>Function</code></a>, the following methods are available to <code>ctx</code>.</p> <dl class="class"> <dt id="torch.autograd.function._ContextMethodMixin">
<code>class torch.autograd.function._ContextMethodMixin</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/function.html#_ContextMethodMixin"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<dl class="method"> <dt id="torch.autograd.function._ContextMethodMixin.mark_dirty">
<code>mark_dirty(*args)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/function.html#_ContextMethodMixin.mark_dirty"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Marks given tensors as modified in an in-place operation.</p> <p><strong>This should be called at most once, only from inside the</strong> <code>forward()</code> <strong>method, and all arguments should be inputs.</strong></p> <p>Every tensor that’s been modified in-place in a call to <code>forward()</code> should be given to this function, to ensure correctness of our checks. It doesn’t matter whether the function is called before or after modification.</p> </dd>
</dl> <dl class="method"> <dt id="torch.autograd.function._ContextMethodMixin.mark_non_differentiable">
<code>mark_non_differentiable(*args)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/function.html#_ContextMethodMixin.mark_non_differentiable"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Marks outputs as non-differentiable.</p> <p><strong>This should be called at most once, only from inside the</strong> <code>forward()</code> <strong>method, and all arguments should be outputs.</strong></p> <p>This will mark outputs as not requiring gradients, increasing the efficiency of backward computation. You still need to accept a gradient for each output in <code>backward()</code>, but it’s always going to be a zero tensor with the same shape as the shape of a corresponding output.</p> <p>This is used e.g. for indices returned from a max <code>Function</code>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.autograd.function._ContextMethodMixin.save_for_backward">
<code>save_for_backward(*tensors)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/function.html#_ContextMethodMixin.save_for_backward"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Saves given tensors for a future call to <code>backward()</code>.</p> <p><strong>This should be called at most once, and only from inside the</strong> <code>forward()</code> <strong>method.</strong></p> <p>Later, saved tensors can be accessed through the <code>saved_tensors</code> attribute. Before returning them to the user, a check is made to ensure they weren’t used in any in-place operation that modified their content.</p> <p>Arguments can also be <code>None</code>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.autograd.function._ContextMethodMixin.set_materialize_grads">
<code>set_materialize_grads(value)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/function.html#_ContextMethodMixin.set_materialize_grads"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Sets whether to materialize output grad tensors. Default is true.</p> <p><strong>This should be called only from inside the</strong> <code>forward()</code> <strong>method</strong></p> <p>If true, undefined output grad tensors will be expanded to tensors full of zeros prior to calling the <code>backward()</code> method.</p> </dd>
</dl> </dd>
</dl>   <h2 id="grad-check">Numerical gradient checking</h2> <dl class="function" id="numerical-gradient-checking"> <dt id="torch.autograd.gradcheck">
<code>torch.autograd.gradcheck(func, inputs, eps=1e-06, atol=1e-05, rtol=0.001, raise_exception=True, check_sparse_nnz=False, nondet_tol=0.0, check_undefined_grad=True, check_grad_dtypes=False, check_batched_grad=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/gradcheck.html#gradcheck"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Check gradients computed via small finite differences against analytical gradients w.r.t. tensors in <code>inputs</code> that are of floating point or complex type and with <code>requires_grad=True</code>.</p> <p>The check between numerical and analytical gradients uses <a class="reference internal" href="generated/torch.allclose#torch.allclose" title="torch.allclose"><code>allclose()</code></a>.</p> <p>For complex functions, no notion of Jacobian exists. Gradcheck verifies if the numerical and analytical values of Wirtinger and Conjugate Wirtinger derivative are consistent. The gradient computation is done under the assumption that the overall function has a real valued output. For functions with complex output, gradcheck compares the numerical and analytical gradients for two values of <code>grad_output</code>: 1 and 1j. For more details, check out <a class="reference internal" href="https://pytorch.org/docs/1.8.0/notes/autograd.html#complex-autograd-doc"><span class="std std-ref">Autograd for Complex Numbers</span></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The default values are designed for <code>input</code> of double precision. This check will likely fail if <code>input</code> is of less precision, e.g., <code>FloatTensor</code>.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>If any checked tensor in <code>input</code> has overlapping memory, i.e., different indices pointing to the same memory address (e.g., from <code>torch.expand()</code>), this check will likely fail because the numerical gradients computed by point perturbation at such indices will change values at all other indices that share the same memory address.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>func</strong> (<em>function</em>) – a Python function that takes Tensor inputs and returns a Tensor or a tuple of Tensors</li> <li>
<strong>inputs</strong> (<em>tuple of Tensor</em><em> or </em><a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – inputs to the function</li> <li>
<strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – perturbation for finite differences</li> <li>
<strong>atol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – absolute tolerance</li> <li>
<strong>rtol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – relative tolerance</li> <li>
<strong>raise_exception</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – indicating whether to raise an exception if the check fails. The exception gives more information about the exact nature of the failure. This is helpful when debugging gradchecks.</li> <li>
<strong>check_sparse_nnz</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – if True, gradcheck allows for SparseTensor input, and for any SparseTensor at input, gradcheck will perform check at nnz positions only.</li> <li>
<strong>nondet_tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – tolerance for non-determinism. When running identical inputs through the differentiation, the results must either match exactly (default, 0.0) or be within this tolerance.</li> <li>
<strong>check_undefined_grad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – if True, check if undefined output grads are supported and treated as zeros, for <code>Tensor</code> outputs.</li> <li>
<strong>check_batched_grad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – if True, check if we can compute batched gradients using prototype vmap support. Defaults to False.</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>True if all differences satisfy allclose condition</p> </dd> </dl> </dd>
</dl> <dl class="function"> <dt id="torch.autograd.gradgradcheck">
<code>torch.autograd.gradgradcheck(func, inputs, grad_outputs=None, eps=1e-06, atol=1e-05, rtol=0.001, gen_non_contig_grad_outputs=False, raise_exception=True, nondet_tol=0.0, check_undefined_grad=True, check_grad_dtypes=False, check_batched_grad=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/gradcheck.html#gradgradcheck"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Check gradients of gradients computed via small finite differences against analytical gradients w.r.t. tensors in <code>inputs</code> and <code>grad_outputs</code> that are of floating point or complex type and with <code>requires_grad=True</code>.</p> <p>This function checks that backpropagating through the gradients computed to the given <code>grad_outputs</code> are correct.</p> <p>The check between numerical and analytical gradients uses <a class="reference internal" href="generated/torch.allclose#torch.allclose" title="torch.allclose"><code>allclose()</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The default values are designed for <code>input</code> and <code>grad_outputs</code> of double precision. This check will likely fail if they are of less precision, e.g., <code>FloatTensor</code>.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>If any checked tensor in <code>input</code> and <code>grad_outputs</code> has overlapping memory, i.e., different indices pointing to the same memory address (e.g., from <code>torch.expand()</code>), this check will likely fail because the numerical gradients computed by point perturbation at such indices will change values at all other indices that share the same memory address.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>func</strong> (<em>function</em>) – a Python function that takes Tensor inputs and returns a Tensor or a tuple of Tensors</li> <li>
<strong>inputs</strong> (<em>tuple of Tensor</em><em> or </em><a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – inputs to the function</li> <li>
<strong>grad_outputs</strong> (<em>tuple of Tensor</em><em> or </em><a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a><em>, </em><em>optional</em>) – The gradients with respect to the function’s outputs.</li> <li>
<strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – perturbation for finite differences</li> <li>
<strong>atol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – absolute tolerance</li> <li>
<strong>rtol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – relative tolerance</li> <li>
<strong>gen_non_contig_grad_outputs</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – if <code>grad_outputs</code> is <code>None</code> and <code>gen_non_contig_grad_outputs</code> is <code>True</code>, the randomly generated gradient outputs are made to be noncontiguous</li> <li>
<strong>raise_exception</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – indicating whether to raise an exception if the check fails. The exception gives more information about the exact nature of the failure. This is helpful when debugging gradchecks.</li> <li>
<strong>nondet_tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – tolerance for non-determinism. When running identical inputs through the differentiation, the results must either match exactly (default, 0.0) or be within this tolerance. Note that a small amount of nondeterminism in the gradient will lead to larger inaccuracies in the second derivative.</li> <li>
<strong>check_undefined_grad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – if True, check if undefined output grads are supported and treated as zeros</li> <li>
<strong>check_batched_grad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – if True, check if we can compute batched gradients using prototype vmap support. Defaults to False.</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>True if all differences satisfy allclose condition</p> </dd> </dl> </dd>
</dl>   <h2 id="profiler">Profiler</h2> <p>Autograd includes a profiler that lets you inspect the cost of different operators inside your model - both on the CPU and GPU. There are two modes implemented at the moment - CPU-only using <a class="reference internal" href="#torch.autograd.profiler.profile" title="torch.autograd.profiler.profile"><code>profile</code></a>. and nvprof based (registers both CPU and GPU activity) using <a class="reference internal" href="#torch.autograd.profiler.emit_nvtx" title="torch.autograd.profiler.emit_nvtx"><code>emit_nvtx</code></a>.</p> <dl class="class"> <dt id="torch.autograd.profiler.profile">
<code>class torch.autograd.profiler.profile(enabled=True, *, use_cuda=False, record_shapes=False, with_flops=False, profile_memory=False, with_stack=False, use_kineto=False, use_cpu=True)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/profiler.html#profile"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Context manager that manages autograd profiler state and holds a summary of results. Under the hood it just records events of functions being executed in C++ and exposes those events to Python. You can wrap any code into it and it will only report runtime of PyTorch functions. Note: profiler is thread local and is automatically propagated into the async tasks</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>enabled</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – Setting this to False makes this context manager a no-op.</li> <li>
<strong>use_cuda</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – Enables timing of CUDA events as well using the cudaEvent API. Adds approximately 4us of overhead to each tensor operation.</li> <li>
<strong>record_shapes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If shapes recording is set, information about input dimensions will be collected. This allows one to see which dimensions have been used under the hood and further group by them using prof.key_averages(group_by_input_shape=True). Please note that shape recording might skew your profiling data. It is recommended to use separate runs with and without shape recording to validate the timing. Most likely the skew will be negligible for bottom most events (in a case of nested function calls). But for higher level functions the total self cpu time might be artificially increased because of the shape collection.</li> <li>
<strong>with_flops</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If with_flops is set, the profiler will estimate the FLOPS (floating pointer operations per second) value using the operator’s input shape and total time. This allows one to estimate the hardware performance. Currently, this option only works for the matrix multiplication and 2D convolution operators.</li> <li>
<strong>profile_memory</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – track tensor memory allocation/deallocation.</li> <li>
<strong>with_stack</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – record source information (file and line number) for the ops.</li> <li>
<strong>use_kineto</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – experimental, enable profiling with Kineto profiler.</li> <li>
<strong>use_cpu</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – profile CPU events; setting to <code>False</code> requires <code>use_kineto=True</code> and can be used to lower the overhead for GPU-only profiling.</li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; x = torch.randn((1, 1), requires_grad=True)
&gt;&gt;&gt; with torch.autograd.profiler.profile() as prof:
&gt;&gt;&gt;     for _ in range(100):  # any normal python code, really!
&gt;&gt;&gt;         y = x ** 2
&gt;&gt;          y.backward()
&gt;&gt;&gt; # NOTE: some columns were removed for brevity
&gt;&gt;&gt; print(prof.key_averages().table(sort_by="self_cpu_time_total"))
-----------------------------------  ---------------  ---------------  ---------------
Name                                 Self CPU total   CPU time avg     Number of Calls
-----------------------------------  ---------------  ---------------  ---------------
mul                                  32.048ms         32.048ms         200
pow                                  27.041ms         27.041ms         200
PowBackward0                         9.727ms          55.483ms         100
torch::autograd::AccumulateGrad      9.148ms          9.148ms          100
torch::autograd::GraphRoot           691.816us        691.816us        100
-----------------------------------  ---------------  ---------------  ---------------
</pre> <dl class="method"> <dt id="torch.autograd.profiler.profile.export_chrome_trace">
<code>export_chrome_trace(path)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/profiler.html#profile.export_chrome_trace"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Exports an EventList as a Chrome tracing tools file.</p> <p>The checkpoint can be later loaded and inspected under <code>chrome://tracing</code> URL.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>path</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>) – Path where the trace will be written.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.autograd.profiler.profile.key_averages">
<code>key_averages(group_by_input_shape=False, group_by_stack_n=0)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/profiler.html#profile.key_averages"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Averages all function events over their keys.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>group_by_input_shapes</strong> – group entries by</li> <li>
<strong>name, input shapes) rather than just event name.</strong> (<em>(</em><em>event</em>) – </li> <li>
<strong>is useful to see which input shapes contribute to the runtime</strong> (<em>This</em>) – </li> <li>
<strong>most and may help with size-specific optimizations or</strong> (<em>the</em>) – </li> <li>
<strong>the best candidates for quantization</strong> (<em>choosing</em>) – </li> <li>
<strong>group_by_stack_n</strong> – group by top n stack trace entries</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>An EventList containing FunctionEventAvg objects.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.autograd.profiler.profile.self_cpu_time_total">
<code>property self_cpu_time_total</code> </dt> <dd>
<p>Returns total time spent on CPU obtained as a sum of all self times across all the events.</p> </dd>
</dl> <dl class="method"> <dt id="torch.autograd.profiler.profile.table">
<code>table(sort_by=None, row_limit=100, max_src_column_width=75, header=None, top_level_events_only=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/profiler.html#profile.table"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Prints an EventList as a nicely formatted table.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>sort_by</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><em>optional</em>) – Attribute used to sort entries. By default they are printed in the same order as they were registered. Valid keys include: <code>cpu_time</code>, <code>cuda_time</code>, <code>cpu_time_total</code>, <code>cuda_time_total</code>, <code>cpu_memory_usage</code>, <code>cuda_memory_usage</code>, <code>self_cpu_memory_usage</code>, <code>self_cuda_memory_usage</code>, <code>count</code>.</li> <li>
<strong>top_level_events_only</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – Boolean flag to determine the selection of events to display. If true, the profiler will only display events at top level like top-level invocation of python <code>lstm</code>, python <code>add</code> or other functions, nested events like low-level cpu/cuda ops events are omitted for profiler result readability.</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>A string containing the table.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.autograd.profiler.profile.total_average">
<code>total_average()</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/profiler.html#profile.total_average"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Averages all events.</p> <dl class="field-list simple"> <dt class="field-odd">Returns</dt> <dd class="field-odd">
<p>A FunctionEventAvg object.</p> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="torch.autograd.profiler.emit_nvtx">
<code>class torch.autograd.profiler.emit_nvtx(enabled=True, record_shapes=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/profiler.html#emit_nvtx"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Context manager that makes every autograd operation emit an NVTX range.</p> <p>It is useful when running the program under nvprof:</p> <pre data-language="python">nvprof --profile-from-start off -o trace_name.prof -- &lt;regular command here&gt;
</pre> <p>Unfortunately, there’s no way to force nvprof to flush the data it collected to disk, so for CUDA profiling one has to use this context manager to annotate nvprof traces and wait for the process to exit before inspecting them. Then, either NVIDIA Visual Profiler (nvvp) can be used to visualize the timeline, or <a class="reference internal" href="#torch.autograd.profiler.load_nvprof" title="torch.autograd.profiler.load_nvprof"><code>torch.autograd.profiler.load_nvprof()</code></a> can load the results for inspection e.g. in Python REPL.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>enabled</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em><em>, </em><em>default=True</em>) – Setting <code>enabled=False</code> makes this context manager a no-op. Default: <code>True</code>.</li> <li>
<strong>record_shapes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em><em>, </em><em>default=False</em>) – If <code>record_shapes=True</code>, the nvtx range wrapping each autograd op will append information about the sizes of Tensor arguments received by that op, in the following format: <code>[[arg0.size(0), arg0.size(1), ...], [arg1.size(0), arg1.size(1), ...], ...]</code> Non-tensor arguments will be represented by <code>[]</code>. Arguments will be listed in the order they are received by the backend op. Please note that this order may not match the order in which those arguments were passed on the Python side. Also note that shape recording may increase the overhead of nvtx range creation.</li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; with torch.cuda.profiler.profile():
...     model(x) # Warmup CUDA memory allocator and profiler
...     with torch.autograd.profiler.emit_nvtx():
...         model(x)
</pre> <p><strong>Forward-backward correlation</strong></p> <p>When viewing a profile created using <a class="reference internal" href="#torch.autograd.profiler.emit_nvtx" title="torch.autograd.profiler.emit_nvtx"><code>emit_nvtx</code></a> in the Nvidia Visual Profiler, correlating each backward-pass op with the corresponding forward-pass op can be difficult. To ease this task, <a class="reference internal" href="#torch.autograd.profiler.emit_nvtx" title="torch.autograd.profiler.emit_nvtx"><code>emit_nvtx</code></a> appends sequence number information to the ranges it generates.</p> <p>During the forward pass, each function range is decorated with <code>seq=&lt;N&gt;</code>. <code>seq</code> is a running counter, incremented each time a new backward Function object is created and stashed for backward. Thus, the <code>seq=&lt;N&gt;</code> annotation associated with each forward function range tells you that if a backward Function object is created by this forward function, the backward object will receive sequence number N. During the backward pass, the top-level range wrapping each C++ backward Function’s <code>apply()</code> call is decorated with <code>stashed seq=&lt;M&gt;</code>. <code>M</code> is the sequence number that the backward object was created with. By comparing <code>stashed seq</code> numbers in backward with <code>seq</code> numbers in forward, you can track down which forward op created each backward Function.</p> <p>Any functions executed during the backward pass are also decorated with <code>seq=&lt;N&gt;</code>. During default backward (with <code>create_graph=False</code>) this information is irrelevant, and in fact, <code>N</code> may simply be 0 for all such functions. Only the top-level ranges associated with backward Function objects’ <code>apply()</code> methods are useful, as a way to correlate these Function objects with the earlier forward pass.</p> <p><strong>Double-backward</strong></p> <p>If, on the other hand, a backward pass with <code>create_graph=True</code> is underway (in other words, if you are setting up for a double-backward), each function’s execution during backward is given a nonzero, useful <code>seq=&lt;N&gt;</code>. Those functions may themselves create Function objects to be executed later during double-backward, just as the original functions in the forward pass did. The relationship between backward and double-backward is conceptually the same as the relationship between forward and backward: The functions still emit current-sequence-number-tagged ranges, the Function objects they create still stash those sequence numbers, and during the eventual double-backward, the Function objects’ <code>apply()</code> ranges are still tagged with <code>stashed seq</code> numbers, which can be compared to <code>seq</code> numbers from the backward pass.</p> </dd>
</dl> <dl class="function"> <dt id="torch.autograd.profiler.load_nvprof">
<code>torch.autograd.profiler.load_nvprof(path)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/profiler.html#load_nvprof"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Opens an nvprof trace file and parses autograd annotations.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>path</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>) – path to nvprof trace</p> </dd> </dl> </dd>
</dl>   <h2 id="anomaly-detection">Anomaly detection</h2> <dl class="class"> <dt id="torch.autograd.detect_anomaly">
<code>class torch.autograd.detect_anomaly</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/anomaly_mode.html#detect_anomaly"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Context-manager that enable anomaly detection for the autograd engine.</p> <p>This does two things:</p> <ul class="simple"> <li>Running the forward pass with detection enabled will allow the backward pass to print the traceback of the forward operation that created the failing backward function.</li> <li>Any backward computation that generate “nan” value will raise an error.</li> </ul> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This mode should be enabled only for debugging as the different tests will slow down your program execution.</p> </div> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; import torch
&gt;&gt;&gt; from torch import autograd
&gt;&gt;&gt; class MyFunc(autograd.Function):
...     @staticmethod
...     def forward(ctx, inp):
...         return inp.clone()
...     @staticmethod
...     def backward(ctx, gO):
...         # Error during the backward pass
...         raise RuntimeError("Some error in backward")
...         return gO.clone()
&gt;&gt;&gt; def run_fn(a):
...     out = MyFunc.apply(a)
...     return out.sum()
&gt;&gt;&gt; inp = torch.rand(10, 10, requires_grad=True)
&gt;&gt;&gt; out = run_fn(inp)
&gt;&gt;&gt; out.backward()
    Traceback (most recent call last):
      File "&lt;stdin&gt;", line 1, in &lt;module&gt;
      File "/your/pytorch/install/torch/tensor.py", line 93, in backward
        torch.autograd.backward(self, gradient, retain_graph, create_graph)
      File "/your/pytorch/install/torch/autograd/__init__.py", line 90, in backward
        allow_unreachable=True)  # allow_unreachable flag
      File "/your/pytorch/install/torch/autograd/function.py", line 76, in apply
        return self._forward_cls.backward(self, *args)
      File "&lt;stdin&gt;", line 8, in backward
    RuntimeError: Some error in backward
&gt;&gt;&gt; with autograd.detect_anomaly():
...     inp = torch.rand(10, 10, requires_grad=True)
...     out = run_fn(inp)
...     out.backward()
    Traceback of forward call that caused the error:
      File "tmp.py", line 53, in &lt;module&gt;
        out = run_fn(inp)
      File "tmp.py", line 44, in run_fn
        out = MyFunc.apply(a)
    Traceback (most recent call last):
      File "&lt;stdin&gt;", line 4, in &lt;module&gt;
      File "/your/pytorch/install/torch/tensor.py", line 93, in backward
        torch.autograd.backward(self, gradient, retain_graph, create_graph)
      File "/your/pytorch/install/torch/autograd/__init__.py", line 90, in backward
        allow_unreachable=True)  # allow_unreachable flag
      File "/your/pytorch/install/torch/autograd/function.py", line 76, in apply
        return self._forward_cls.backward(self, *args)
      File "&lt;stdin&gt;", line 8, in backward
    RuntimeError: Some error in backward
</pre> </dd>
</dl> <dl class="class"> <dt id="torch.autograd.set_detect_anomaly">
<code>class torch.autograd.set_detect_anomaly(mode)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/autograd/anomaly_mode.html#set_detect_anomaly"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Context-manager that sets the anomaly detection for the autograd engine on or off.</p> <p><code>set_detect_anomaly</code> will enable or disable the autograd anomaly detection based on its argument <code>mode</code>. It can be used as a context-manager or as a function.</p> <p>See <code>detect_anomaly</code> above for details of the anomaly detection behaviour.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – Flag whether to enable anomaly detection (<code>True</code>), or disable (<code>False</code>).</p> </dd> </dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://pytorch.org/docs/1.8.0/autograd.html" class="_attribution-link" target="_blank">https://pytorch.org/docs/1.8.0/autograd.html</a>
  </p>
</div>
