<h1 id="torch-eig">torch.eig</h1> <dl class="function"> <dt id="torch.eig">
<code>torch.eig(input, eigenvectors=False, *, out=None) -&gt; (Tensor, Tensor)</code> </dt> <dd>
<p>Computes the eigenvalues and eigenvectors of a real square matrix.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Since eigenvalues and eigenvectors might be complex, backward pass is supported only if eigenvalues and eigenvectors are all real valued.</p> <p>When <code>input</code> is on CUDA, <a class="reference internal" href="#torch.eig" title="torch.eig"><code>torch.eig()</code></a> causes host-device synchronization.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="../tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the square matrix of shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n \times n)</annotation></semantics></math></span></span> </span> for which the eigenvalues and eigenvectors will be computed</li> <li>
<strong>eigenvectors</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – <code>True</code> to compute both eigenvalues and eigenvectors; otherwise, only eigenvalues will be computed</li> </ul> </dd> <dt class="field-even">Keyword Arguments</dt> <dd class="field-even">
<p><strong>out</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.9)">tuple</a><em>, </em><em>optional</em>) – the output tensors</p> </dd> <dt class="field-odd">Returns</dt> <dd class="field-odd">

<p>A namedtuple (eigenvalues, eigenvectors) containing</p>  <ul class="simple"> <li>
<strong>eigenvalues</strong> (<em>Tensor</em>): Shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n \times 2)</annotation></semantics></math></span></span> </span>. Each row is an eigenvalue of <code>input</code>, where the first element is the real part and the second element is the imaginary part. The eigenvalues are not necessarily ordered.</li> <li>
<strong>eigenvectors</strong> (<em>Tensor</em>): If <code>eigenvectors=False</code>, it’s an empty tensor. Otherwise, this tensor of shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n \times n)</annotation></semantics></math></span></span> </span> can be used to compute normalized (unit length) eigenvectors of corresponding eigenvalues as follows. If the corresponding <code>eigenvalues[j]</code> is a real number, column <code>eigenvectors[:, j]</code> is the eigenvector corresponding to <code>eigenvalues[j]</code>. If the corresponding <code>eigenvalues[j]</code> and <code>eigenvalues[j + 1]</code> form a complex conjugate pair, then the true eigenvectors can be computed as <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>true eigenvector</mtext><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>e</mi><mi>i</mi><mi>g</mi><mi>e</mi><mi>n</mi><mi>v</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>s</mi><mo stretchy="false">[</mo><mo>:</mo><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>i</mi><mo>×</mo><mi>e</mi><mi>i</mi><mi>g</mi><mi>e</mi><mi>n</mi><mi>v</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>s</mi><mo stretchy="false">[</mo><mo>:</mo><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\text{true eigenvector}[j] = eigenvectors[:, j] + i \times eigenvectors[:, j + 1]</annotation></semantics></math></span></span> </span>, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>true eigenvector</mtext><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>e</mi><mi>i</mi><mi>g</mi><mi>e</mi><mi>n</mi><mi>v</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>s</mi><mo stretchy="false">[</mo><mo>:</mo><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo><mo>−</mo><mi>i</mi><mo>×</mo><mi>e</mi><mi>i</mi><mi>g</mi><mi>e</mi><mi>n</mi><mi>v</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>s</mi><mo stretchy="false">[</mo><mo>:</mo><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\text{true eigenvector}[j + 1] = eigenvectors[:, j] - i \times eigenvectors[:, j + 1]</annotation></semantics></math></span></span> </span>.</li> </ul>  </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p>(<a class="reference internal" href="../tensors#torch.Tensor" title="torch.Tensor">Tensor</a>, <a class="reference internal" href="../tensors#torch.Tensor" title="torch.Tensor">Tensor</a>)</p> </dd> </dl> <p>Example:</p> <pre data-language="python">Trivial example with a diagonal matrix. By default, only eigenvalues are computed:

&gt;&gt;&gt; a = torch.diag(torch.tensor([1, 2, 3], dtype=torch.double))
&gt;&gt;&gt; e, v = torch.eig(a)
&gt;&gt;&gt; e
tensor([[1., 0.],
        [2., 0.],
        [3., 0.]], dtype=torch.float64)
&gt;&gt;&gt; v
tensor([], dtype=torch.float64)

Compute also the eigenvectors:

&gt;&gt;&gt; e, v = torch.eig(a, eigenvectors=True)
&gt;&gt;&gt; e
tensor([[1., 0.],
        [2., 0.],
        [3., 0.]], dtype=torch.float64)
&gt;&gt;&gt; v
tensor([[1., 0., 0.],
        [0., 1., 0.],
        [0., 0., 1.]], dtype=torch.float64)
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://pytorch.org/docs/1.8.0/generated/torch.eig.html" class="_attribution-link" target="_blank">https://pytorch.org/docs/1.8.0/generated/torch.eig.html</a>
  </p>
</div>
