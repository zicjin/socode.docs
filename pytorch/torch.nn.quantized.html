<h1 id="torch-nn-quantized">torch.nn.quantized</h1> <p>This module implements the quantized versions of the nn modules and functionals.</p>  <h2 id="functional-interface">Functional interface</h2> <p id="module-torch.nn.quantized.functional">Functional interface (quantized).</p> <dl class="function"> <dt id="torch.nn.quantized.functional.linear">
<code>torch.nn.quantized.functional.linear(input, weight, bias=None, scale=None, zero_point=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/functional.html#linear"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Applies a linear transformation to the incoming quantized data: <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>x</mi><msup><mi>A</mi><mi>T</mi></msup><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y = xA^T + b</annotation></semantics></math></span></span> </span>. See <a class="reference internal" href="#torch.nn.quantized.Linear" title="torch.nn.quantized.Linear"><code>Linear</code></a></p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Current implementation packs weights on every call, which has penalty on performance. If you want to avoid the overhead, use <a class="reference internal" href="#torch.nn.quantized.Linear" title="torch.nn.quantized.Linear"><code>Linear</code></a>.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – Quantized input of type <code>torch.quint8</code>
</li> <li>
<strong>weight</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – Quantized weight of type <code>torch.qint8</code>
</li> <li>
<strong>bias</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – None or fp32 bias of type <code>torch.float</code>
</li> <li>
<strong>scale</strong> (<em>double</em>) – output scale. If None, derived from the input scale</li> <li>
<strong>zero_point</strong> (<em>long</em>) – output zero point. If None, derived from the input zero_point</li> </ul> </dd> </dl> <dl class="simple"> <dt>Shape:</dt>
<dd>
<ul class="simple"> <li>Input: <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mo>∗</mo><mo separator="true">,</mo><mi>i</mi><mi>n</mi><mi mathvariant="normal">_</mi><mi>f</mi><mi>e</mi><mi>a</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>e</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(N, *, in\_features)</annotation></semantics></math></span></span> </span> where <code>*</code> means any number of additional dimensions</li> <li>Weight: <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>o</mi><mi>u</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>f</mi><mi>e</mi><mi>a</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>e</mi><mi>s</mi><mo separator="true">,</mo><mi>i</mi><mi>n</mi><mi mathvariant="normal">_</mi><mi>f</mi><mi>e</mi><mi>a</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>e</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(out\_features, in\_features)</annotation></semantics></math></span></span> </span>
</li> <li>Bias: <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>o</mi><mi>u</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>f</mi><mi>e</mi><mi>a</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>e</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(out\_features)</annotation></semantics></math></span></span> </span>
</li> <li>Output: <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mo>∗</mo><mo separator="true">,</mo><mi>o</mi><mi>u</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>f</mi><mi>e</mi><mi>a</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>e</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(N, *, out\_features)</annotation></semantics></math></span></span> </span>
</li> </ul> </dd> </dl> </dd>
</dl> <dl class="function"> <dt id="torch.nn.quantized.functional.conv1d">
<code>torch.nn.quantized.functional.conv1d(input, weight, bias, stride=1, padding=0, dilation=1, groups=1, padding_mode='zeros', scale=1.0, zero_point=0, dtype=torch.quint8)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/functional.html#conv1d"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Applies a 1D convolution over a quantized 1D input composed of several input planes.</p> <p>See <a class="reference internal" href="#torch.nn.quantized.Conv1d" title="torch.nn.quantized.Conv1d"><code>Conv1d</code></a> for details and output shape.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> – quantized input tensor of shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>minibatch</mtext><mo separator="true">,</mo><mtext>in_channels</mtext><mo separator="true">,</mo><mi>i</mi><mi>W</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{minibatch} , \text{in\_channels} , iW)</annotation></semantics></math></span></span> </span>
</li> <li>
<strong>weight</strong> – quantized filters of shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>out_channels</mtext><mo separator="true">,</mo><mfrac><mtext>in_channels</mtext><mtext>groups</mtext></mfrac><mo separator="true">,</mo><mi>i</mi><mi>W</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{out\_channels} , \frac{\text{in\_channels}}{\text{groups}} , iW)</annotation></semantics></math></span></span> </span>
</li> <li>
<strong>bias</strong> – <strong>non-quantized</strong> bias tensor of shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>out_channels</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{out\_channels})</annotation></semantics></math></span></span> </span>. The tensor type must be <code>torch.float</code>.</li> <li>
<strong>stride</strong> – the stride of the convolving kernel. Can be a single number or a tuple <code>(sW,)</code>. Default: 1</li> <li>
<strong>padding</strong> – implicit paddings on both sides of the input. Can be a single number or a tuple <code>(padW,)</code>. Default: 0</li> <li>
<strong>dilation</strong> – the spacing between kernel elements. Can be a single number or a tuple <code>(dW,)</code>. Default: 1</li> <li>
<strong>groups</strong> – split input into groups, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>in_channels</mtext></mrow><annotation encoding="application/x-tex">\text{in\_channels}</annotation></semantics></math></span></span> </span> should be divisible by the number of groups. Default: 1</li> <li>
<strong>padding_mode</strong> – the padding mode to use. Only “zeros” is supported for quantized convolution at the moment. Default: “zeros”</li> <li>
<strong>scale</strong> – quantization scale for the output. Default: 1.0</li> <li>
<strong>zero_point</strong> – quantization zero_point for the output. Default: 0</li> <li>
<strong>dtype</strong> – quantization data type to use. Default: <code>torch.quint8</code>
</li> </ul> </dd> </dl> <p>Examples:</p> <pre data-language="python">&gt;&gt;&gt; from torch.nn.quantized import functional as qF
&gt;&gt;&gt; filters = torch.randn(33, 16, 3, dtype=torch.float)
&gt;&gt;&gt; inputs = torch.randn(20, 16, 50, dtype=torch.float)
&gt;&gt;&gt; bias = torch.randn(33, dtype=torch.float)
&gt;&gt;&gt;
&gt;&gt;&gt; scale, zero_point = 1.0, 0
&gt;&gt;&gt; dtype_inputs = torch.quint8
&gt;&gt;&gt; dtype_filters = torch.qint8
&gt;&gt;&gt;
&gt;&gt;&gt; q_filters = torch.quantize_per_tensor(filters, scale, zero_point, dtype_filters)
&gt;&gt;&gt; q_inputs = torch.quantize_per_tensor(inputs, scale, zero_point, dtype_inputs)
&gt;&gt;&gt; qF.conv1d(q_inputs, q_filters, bias, padding=1, scale=scale, zero_point=zero_point)
</pre> </dd>
</dl> <dl class="function"> <dt id="torch.nn.quantized.functional.conv2d">
<code>torch.nn.quantized.functional.conv2d(input, weight, bias, stride=1, padding=0, dilation=1, groups=1, padding_mode='zeros', scale=1.0, zero_point=0, dtype=torch.quint8)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/functional.html#conv2d"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Applies a 2D convolution over a quantized 2D input composed of several input planes.</p> <p>See <a class="reference internal" href="#torch.nn.quantized.Conv2d" title="torch.nn.quantized.Conv2d"><code>Conv2d</code></a> for details and output shape.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> – quantized input tensor of shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>minibatch</mtext><mo separator="true">,</mo><mtext>in_channels</mtext><mo separator="true">,</mo><mi>i</mi><mi>H</mi><mo separator="true">,</mo><mi>i</mi><mi>W</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{minibatch} , \text{in\_channels} , iH , iW)</annotation></semantics></math></span></span> </span>
</li> <li>
<strong>weight</strong> – quantized filters of shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>out_channels</mtext><mo separator="true">,</mo><mfrac><mtext>in_channels</mtext><mtext>groups</mtext></mfrac><mo separator="true">,</mo><mi>k</mi><mi>H</mi><mo separator="true">,</mo><mi>k</mi><mi>W</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{out\_channels} , \frac{\text{in\_channels}}{\text{groups}} , kH , kW)</annotation></semantics></math></span></span> </span>
</li> <li>
<strong>bias</strong> – <strong>non-quantized</strong> bias tensor of shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>out_channels</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{out\_channels})</annotation></semantics></math></span></span> </span>. The tensor type must be <code>torch.float</code>.</li> <li>
<strong>stride</strong> – the stride of the convolving kernel. Can be a single number or a tuple <code>(sH, sW)</code>. Default: 1</li> <li>
<strong>padding</strong> – implicit paddings on both sides of the input. Can be a single number or a tuple <code>(padH, padW)</code>. Default: 0</li> <li>
<strong>dilation</strong> – the spacing between kernel elements. Can be a single number or a tuple <code>(dH, dW)</code>. Default: 1</li> <li>
<strong>groups</strong> – split input into groups, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>in_channels</mtext></mrow><annotation encoding="application/x-tex">\text{in\_channels}</annotation></semantics></math></span></span> </span> should be divisible by the number of groups. Default: 1</li> <li>
<strong>padding_mode</strong> – the padding mode to use. Only “zeros” is supported for quantized convolution at the moment. Default: “zeros”</li> <li>
<strong>scale</strong> – quantization scale for the output. Default: 1.0</li> <li>
<strong>zero_point</strong> – quantization zero_point for the output. Default: 0</li> <li>
<strong>dtype</strong> – quantization data type to use. Default: <code>torch.quint8</code>
</li> </ul> </dd> </dl> <p>Examples:</p> <pre data-language="python">&gt;&gt;&gt; from torch.nn.quantized import functional as qF
&gt;&gt;&gt; filters = torch.randn(8, 4, 3, 3, dtype=torch.float)
&gt;&gt;&gt; inputs = torch.randn(1, 4, 5, 5, dtype=torch.float)
&gt;&gt;&gt; bias = torch.randn(8, dtype=torch.float)
&gt;&gt;&gt;
&gt;&gt;&gt; scale, zero_point = 1.0, 0
&gt;&gt;&gt; dtype_inputs = torch.quint8
&gt;&gt;&gt; dtype_filters = torch.qint8
&gt;&gt;&gt;
&gt;&gt;&gt; q_filters = torch.quantize_per_tensor(filters, scale, zero_point, dtype_filters)
&gt;&gt;&gt; q_inputs = torch.quantize_per_tensor(inputs, scale, zero_point, dtype_inputs)
&gt;&gt;&gt; qF.conv2d(q_inputs, q_filters, bias, padding=1, scale=scale, zero_point=zero_point)
</pre> </dd>
</dl> <dl class="function"> <dt id="torch.nn.quantized.functional.conv3d">
<code>torch.nn.quantized.functional.conv3d(input, weight, bias, stride=1, padding=0, dilation=1, groups=1, padding_mode='zeros', scale=1.0, zero_point=0, dtype=torch.quint8)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/functional.html#conv3d"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Applies a 3D convolution over a quantized 3D input composed of several input planes.</p> <p>See <a class="reference internal" href="#torch.nn.quantized.Conv3d" title="torch.nn.quantized.Conv3d"><code>Conv3d</code></a> for details and output shape.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> – quantized input tensor of shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>minibatch</mtext><mo separator="true">,</mo><mtext>in_channels</mtext><mo separator="true">,</mo><mi>i</mi><mi>D</mi><mo separator="true">,</mo><mi>i</mi><mi>H</mi><mo separator="true">,</mo><mi>i</mi><mi>W</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{minibatch} , \text{in\_channels} , iD , iH , iW)</annotation></semantics></math></span></span> </span>
</li> <li>
<strong>weight</strong> – quantized filters of shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>out_channels</mtext><mo separator="true">,</mo><mfrac><mtext>in_channels</mtext><mtext>groups</mtext></mfrac><mo separator="true">,</mo><mi>k</mi><mi>D</mi><mo separator="true">,</mo><mi>k</mi><mi>H</mi><mo separator="true">,</mo><mi>k</mi><mi>W</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{out\_channels} , \frac{\text{in\_channels}}{\text{groups}} , kD , kH , kW)</annotation></semantics></math></span></span> </span>
</li> <li>
<strong>bias</strong> – <strong>non-quantized</strong> bias tensor of shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>out_channels</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{out\_channels})</annotation></semantics></math></span></span> </span>. The tensor type must be <code>torch.float</code>.</li> <li>
<strong>stride</strong> – the stride of the convolving kernel. Can be a single number or a tuple <code>(sD, sH, sW)</code>. Default: 1</li> <li>
<strong>padding</strong> – implicit paddings on both sides of the input. Can be a single number or a tuple <code>(padD, padH, padW)</code>. Default: 0</li> <li>
<strong>dilation</strong> – the spacing between kernel elements. Can be a single number or a tuple <code>(dD, dH, dW)</code>. Default: 1</li> <li>
<strong>groups</strong> – split input into groups, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>in_channels</mtext></mrow><annotation encoding="application/x-tex">\text{in\_channels}</annotation></semantics></math></span></span> </span> should be divisible by the number of groups. Default: 1</li> <li>
<strong>padding_mode</strong> – the padding mode to use. Only “zeros” is supported for quantized convolution at the moment. Default: “zeros”</li> <li>
<strong>scale</strong> – quantization scale for the output. Default: 1.0</li> <li>
<strong>zero_point</strong> – quantization zero_point for the output. Default: 0</li> <li>
<strong>dtype</strong> – quantization data type to use. Default: <code>torch.quint8</code>
</li> </ul> </dd> </dl> <p>Examples:</p> <pre data-language="python">&gt;&gt;&gt; from torch.nn.quantized import functional as qF
&gt;&gt;&gt; filters = torch.randn(8, 4, 3, 3, 3, dtype=torch.float)
&gt;&gt;&gt; inputs = torch.randn(1, 4, 5, 5, 5, dtype=torch.float)
&gt;&gt;&gt; bias = torch.randn(8, dtype=torch.float)
&gt;&gt;&gt;
&gt;&gt;&gt; scale, zero_point = 1.0, 0
&gt;&gt;&gt; dtype_inputs = torch.quint8
&gt;&gt;&gt; dtype_filters = torch.qint8
&gt;&gt;&gt;
&gt;&gt;&gt; q_filters = torch.quantize_per_tensor(filters, scale, zero_point, dtype_filters)
&gt;&gt;&gt; q_inputs = torch.quantize_per_tensor(inputs, scale, zero_point, dtype_inputs)
&gt;&gt;&gt; qF.conv3d(q_inputs, q_filters, bias, padding=1, scale=scale, zero_point=zero_point)
</pre> </dd>
</dl> <dl class="function"> <dt id="torch.nn.quantized.functional.max_pool2d">
<code>torch.nn.quantized.functional.max_pool2d(input, kernel_size, stride=None, padding=0, dilation=1, ceil_mode=False, return_indices=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/functional.html#max_pool2d"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Applies a 2D max pooling over a quantized input signal composed of several quantized input planes.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The input quantization parameters are propagated to the output.</p> </div> <p>See <code>MaxPool2d</code> for details.</p> </dd>
</dl> <dl class="function"> <dt id="torch.nn.quantized.functional.adaptive_avg_pool2d">
<code>torch.nn.quantized.functional.adaptive_avg_pool2d(input, output_size)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/functional.html#adaptive_avg_pool2d"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Applies a 2D adaptive average pooling over a quantized input signal composed of several quantized input planes.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The input quantization parameters propagate to the output.</p> </div> <p>See <code>AdaptiveAvgPool2d</code> for details and output shape.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>output_size</strong> – the target output size (single integer or double-integer tuple)</p> </dd> </dl> </dd>
</dl> <dl class="function"> <dt id="torch.nn.quantized.functional.avg_pool2d">
<code>torch.nn.quantized.functional.avg_pool2d(input, kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True, divisor_override=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/functional.html#avg_pool2d"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Applies 2D average-pooling operation in <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>H</mi><mo>×</mo><mi>k</mi><mi>W</mi></mrow><annotation encoding="application/x-tex">kH \times kW</annotation></semantics></math></span></span> </span> regions by step size <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>H</mi><mo>×</mo><mi>s</mi><mi>W</mi></mrow><annotation encoding="application/x-tex">sH \times sW</annotation></semantics></math></span></span> </span> steps. The number of output features is equal to the number of input planes.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The input quantization parameters propagate to the output.</p> </div> <p>See <code>AvgPool2d</code> for details and output shape.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> – quantized input tensor <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>minibatch</mtext><mo separator="true">,</mo><mtext>in_channels</mtext><mo separator="true">,</mo><mi>i</mi><mi>H</mi><mo separator="true">,</mo><mi>i</mi><mi>W</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{minibatch} , \text{in\_channels} , iH , iW)</annotation></semantics></math></span></span> </span>
</li> <li>
<strong>kernel_size</strong> – size of the pooling region. Can be a single number or a tuple <code>(kH, kW)</code>
</li> <li>
<strong>stride</strong> – stride of the pooling operation. Can be a single number or a tuple <code>(sH, sW)</code>. Default: <code>kernel_size</code>
</li> <li>
<strong>padding</strong> – implicit zero paddings on both sides of the input. Can be a single number or a tuple <code>(padH, padW)</code>. Default: 0</li> <li>
<strong>ceil_mode</strong> – when True, will use <code>ceil</code> instead of <code>floor</code> in the formula to compute the output shape. Default: <code>False</code>
</li> <li>
<strong>count_include_pad</strong> – when True, will include the zero-padding in the averaging calculation. Default: <code>True</code>
</li> <li>
<strong>divisor_override</strong> – if specified, it will be used as divisor, otherwise size of the pooling region will be used. Default: None</li> </ul> </dd> </dl> </dd>
</dl> <dl class="function"> <dt id="torch.nn.quantized.functional.interpolate">
<code>torch.nn.quantized.functional.interpolate(input, size=None, scale_factor=None, mode='nearest', align_corners=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/functional.html#interpolate"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Down/up samples the input to either the given <code>size</code> or the given <code>scale_factor</code></p> <p>See <a class="reference internal" href="nn.functional#torch.nn.functional.interpolate" title="torch.nn.functional.interpolate"><code>torch.nn.functional.interpolate()</code></a> for implementation details.</p> <p>The input dimensions are interpreted in the form: <code>mini-batch x channels x [optional depth] x [optional height] x width</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The input quantization parameters propagate to the output.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Only 2D/3D input is supported for quantized inputs</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Only the following modes are supported for the quantized inputs:</p> <ul class="simple"> <li><code>bilinear</code></li> <li><code>nearest</code></li> </ul> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the input tensor</li> <li>
<strong>size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em> or </em><em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>] or </em><em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>] or </em><em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em>) – output spatial size.</li> <li>
<strong>scale_factor</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em> or </em><em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>]</em>) – multiplier for spatial size. Has to match input size if it is a tuple.</li> <li>
<strong>mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>) – algorithm used for upsampling: <code>'nearest'</code> | <code>'bilinear'</code>
</li> <li>
<strong>align_corners</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – Geometrically, we consider the pixels of the input and output as squares rather than points. If set to <code>True</code>, the input and output tensors are aligned by the center points of their corner pixels, preserving the values at the corner pixels. If set to <code>False</code>, the input and output tensors are aligned by the corner points of their corner pixels, and the interpolation uses edge value padding for out-of-boundary values, making this operation <em>independent</em> of input size when <code>scale_factor</code> is kept the same. This only has an effect when <code>mode</code> is <code>'bilinear'</code>. Default: <code>False</code>
</li> </ul> </dd> </dl> </dd>
</dl> <dl class="function"> <dt id="torch.nn.quantized.functional.hardswish">
<code>torch.nn.quantized.functional.hardswish(input, scale, zero_point)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/functional.html#hardswish"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This is the quantized version of <a class="reference internal" href="nn.functional#torch.nn.functional.hardswish" title="torch.nn.functional.hardswish"><code>hardswish()</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> – quantized input</li> <li>
<strong>scale</strong> – quantization scale of the output tensor</li> <li>
<strong>zero_point</strong> – quantization zero point of the output tensor</li> </ul> </dd> </dl> </dd>
</dl> <dl class="function"> <dt id="torch.nn.quantized.functional.upsample">
<code>torch.nn.quantized.functional.upsample(input, size=None, scale_factor=None, mode='nearest', align_corners=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/functional.html#upsample"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Upsamples the input to either the given <code>size</code> or the given <code>scale_factor</code></p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This function is deprecated in favor of <a class="reference internal" href="#torch.nn.quantized.functional.interpolate" title="torch.nn.quantized.functional.interpolate"><code>torch.nn.quantized.functional.interpolate()</code></a>. This is equivalent with <code>nn.quantized.functional.interpolate(...)</code>.</p> </div> <p>See <a class="reference internal" href="nn.functional#torch.nn.functional.interpolate" title="torch.nn.functional.interpolate"><code>torch.nn.functional.interpolate()</code></a> for implementation details.</p> <p>The input dimensions are interpreted in the form: <code>mini-batch x channels x [optional depth] x [optional height] x width</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The input quantization parameters propagate to the output.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Only 2D input is supported for quantized inputs</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Only the following modes are supported for the quantized inputs:</p> <ul class="simple"> <li><code>bilinear</code></li> <li><code>nearest</code></li> </ul> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – quantized input tensor</li> <li>
<strong>size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em> or </em><em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>] or </em><em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>] or </em><em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em>) – output spatial size.</li> <li>
<strong>scale_factor</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em> or </em><em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>]</em>) – multiplier for spatial size. Has to be an integer.</li> <li>
<strong>mode</strong> (<em>string</em>) – algorithm used for upsampling: <code>'nearest'</code> | <code>'bilinear'</code>
</li> <li>
<strong>align_corners</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – Geometrically, we consider the pixels of the input and output as squares rather than points. If set to <code>True</code>, the input and output tensors are aligned by the center points of their corner pixels, preserving the values at the corner pixels. If set to <code>False</code>, the input and output tensors are aligned by the corner points of their corner pixels, and the interpolation uses edge value padding for out-of-boundary values, making this operation <em>independent</em> of input size when <code>scale_factor</code> is kept the same. This only has an effect when <code>mode</code> is <code>'bilinear'</code>. Default: <code>False</code>
</li> </ul> </dd> </dl> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>With <code>align_corners = True</code>, the linearly interpolating modes (<code>bilinear</code>) don’t proportionally align the output and input pixels, and thus the output values can depend on the input size. This was the default behavior for these modes up to version 0.3.1. Since then, the default behavior is <code>align_corners = False</code>. See <a class="reference internal" href="generated/torch.nn.upsample#torch.nn.Upsample" title="torch.nn.Upsample"><code>Upsample</code></a> for concrete examples on how this affects the outputs.</p> </div> </dd>
</dl> <dl class="function"> <dt id="torch.nn.quantized.functional.upsample_bilinear">
<code>torch.nn.quantized.functional.upsample_bilinear(input, size=None, scale_factor=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/functional.html#upsample_bilinear"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Upsamples the input, using bilinear upsampling.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This function is deprecated in favor of <a class="reference internal" href="#torch.nn.quantized.functional.interpolate" title="torch.nn.quantized.functional.interpolate"><code>torch.nn.quantized.functional.interpolate()</code></a>. This is equivalent with <code>nn.quantized.functional.interpolate(..., mode='bilinear', align_corners=True)</code>.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The input quantization parameters propagate to the output.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Only 2D inputs are supported</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – quantized input</li> <li>
<strong>size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em> or </em><em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em>) – output spatial size.</li> <li>
<strong>scale_factor</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em> or </em><em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em>) – multiplier for spatial size</li> </ul> </dd> </dl> </dd>
</dl> <dl class="function" id="module-torch.nn.quantized"> <dt id="torch.nn.quantized.functional.upsample_nearest">
<code>torch.nn.quantized.functional.upsample_nearest(input, size=None, scale_factor=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/functional.html#upsample_nearest"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Upsamples the input, using nearest neighbours’ pixel values.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This function is deprecated in favor of <a class="reference internal" href="#torch.nn.quantized.functional.interpolate" title="torch.nn.quantized.functional.interpolate"><code>torch.nn.quantized.functional.interpolate()</code></a>. This is equivalent with <code>nn.quantized.functional.interpolate(..., mode='nearest')</code>.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The input quantization parameters propagate to the output.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Only 2D inputs are supported</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – quantized input</li> <li>
<strong>size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em> or </em><em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>] or </em><em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em>) – output spatial size.</li> <li>
<strong>scale_factor</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – multiplier for spatial size. Has to be an integer.</li> </ul> </dd> </dl> </dd>
</dl>   <h2 id="relu6">ReLU6</h2> <dl class="class"> <dt id="torch.nn.quantized.ReLU6">
<code>class torch.nn.quantized.ReLU6(inplace=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/activation.html#ReLU6"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Applies the element-wise function:</p> <p><span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>ReLU6</mtext><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{ReLU6}(x) = \min(\max(x_0, x), q(6))</annotation></semantics></math></span></span> </span>, where <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span></span> </span> is the zero_point, and <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q(6)</annotation></semantics></math></span></span> </span> is the quantized representation of number 6.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>inplace</strong> – can optionally do the operation in-place. Default: <code>False</code></p> </dd> </dl> <dl class="simple"> <dt>Shape:</dt>
<dd>
<ul class="simple"> <li>Input: <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mo>∗</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(N, *)</annotation></semantics></math></span></span> </span> where <code>*</code> means, any number of additional dimensions</li> <li>Output: <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mo>∗</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(N, *)</annotation></semantics></math></span></span> </span>, same shape as the input</li> </ul> </dd> </dl> <img alt="_images/ReLU61.png" src="data:image/png;base64,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"> <p>Examples:</p> <pre data-language="python">&gt;&gt;&gt; m = nn.quantized.ReLU6()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; input = torch.quantize_per_tensor(input, 1.0, 0, dtype=torch.qint32)
&gt;&gt;&gt; output = m(input)
</pre> </dd>
</dl>   <h2 id="elu">ELU</h2> <dl class="class"> <dt id="torch.nn.quantized.ELU">
<code>class torch.nn.quantized.ELU(scale, zero_point, alpha=1.0)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/activation.html#ELU"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This is the quantized equivalent of <a class="reference internal" href="generated/torch.nn.elu#torch.nn.ELU" title="torch.nn.ELU"><code>ELU</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>scale</strong> – quantization scale of the output tensor</li> <li>
<strong>zero_point</strong> – quantization zero point of the output tensor</li> <li>
<strong>alpha</strong> – the alpha constant</li> </ul> </dd> </dl> </dd>
</dl>   <h2 id="hardswish">Hardswish</h2> <dl class="class"> <dt id="torch.nn.quantized.Hardswish">
<code>class torch.nn.quantized.Hardswish(scale, zero_point)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/activation.html#Hardswish"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This is the quantized version of <a class="reference internal" href="generated/torch.nn.hardswish#torch.nn.Hardswish" title="torch.nn.Hardswish"><code>Hardswish</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>scale</strong> – quantization scale of the output tensor</li> <li>
<strong>zero_point</strong> – quantization zero point of the output tensor</li> </ul> </dd> </dl> </dd>
</dl>   <h2 id="conv1d">Conv1d</h2> <dl class="class"> <dt id="torch.nn.quantized.Conv1d">
<code>class torch.nn.quantized.Conv1d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode='zeros')</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/conv.html#Conv1d"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Applies a 1D convolution over a quantized input signal composed of several quantized input planes.</p> <p>For details on input arguments, parameters, and implementation see <a class="reference internal" href="generated/torch.nn.conv1d#torch.nn.Conv1d" title="torch.nn.Conv1d"><code>Conv1d</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Only <code>zeros</code> is supported for the <code>padding_mode</code> argument.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Only <code>torch.quint8</code> is supported for the input data type.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Variables</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>~Conv1d.weight</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – packed tensor derived from the learnable weight parameter.</li> <li>
<strong>~Conv1d.scale</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – scalar for the output scale</li> <li>
<strong>~Conv1d.zero_point</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – scalar for the output zero point</li> </ul> </dd> </dl> <p>See <a class="reference internal" href="generated/torch.nn.conv1d#torch.nn.Conv1d" title="torch.nn.Conv1d"><code>Conv1d</code></a> for other attributes.</p> <p>Examples:</p> <pre data-language="python">&gt;&gt;&gt; m = nn.quantized.Conv1d(16, 33, 3, stride=2)
&gt;&gt;&gt; input = torch.randn(20, 16, 100)
&gt;&gt;&gt; # quantize input to quint8
&gt;&gt;&gt; q_input = torch.quantize_per_tensor(input, scale=1.0, zero_point=0,
                                        dtype=torch.quint8)
&gt;&gt;&gt; output = m(q_input)
</pre> <dl class="method"> <dt id="torch.nn.quantized.Conv1d.from_float">
<code>classmethod from_float(mod)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/conv.html#Conv1d.from_float"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Creates a quantized module from a float module or qparams_dict.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>mod</strong> (<a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module">Module</a>) – a float module, either produced by torch.quantization utilities or provided by the user</p> </dd> </dl> </dd>
</dl> </dd>
</dl>   <h2 id="conv2d">Conv2d</h2> <dl class="class"> <dt id="torch.nn.quantized.Conv2d">
<code>class torch.nn.quantized.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode='zeros')</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/conv.html#Conv2d"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Applies a 2D convolution over a quantized input signal composed of several quantized input planes.</p> <p>For details on input arguments, parameters, and implementation see <a class="reference internal" href="generated/torch.nn.conv2d#torch.nn.Conv2d" title="torch.nn.Conv2d"><code>Conv2d</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Only <code>zeros</code> is supported for the <code>padding_mode</code> argument.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Only <code>torch.quint8</code> is supported for the input data type.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Variables</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>~Conv2d.weight</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – packed tensor derived from the learnable weight parameter.</li> <li>
<strong>~Conv2d.scale</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – scalar for the output scale</li> <li>
<strong>~Conv2d.zero_point</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – scalar for the output zero point</li> </ul> </dd> </dl> <p>See <a class="reference internal" href="generated/torch.nn.conv2d#torch.nn.Conv2d" title="torch.nn.Conv2d"><code>Conv2d</code></a> for other attributes.</p> <p>Examples:</p> <pre data-language="python">&gt;&gt;&gt; # With square kernels and equal stride
&gt;&gt;&gt; m = nn.quantized.Conv2d(16, 33, 3, stride=2)
&gt;&gt;&gt; # non-square kernels and unequal stride and with padding
&gt;&gt;&gt; m = nn.quantized.Conv2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2))
&gt;&gt;&gt; # non-square kernels and unequal stride and with padding and dilation
&gt;&gt;&gt; m = nn.quantized.Conv2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2), dilation=(3, 1))
&gt;&gt;&gt; input = torch.randn(20, 16, 50, 100)
&gt;&gt;&gt; # quantize input to quint8
&gt;&gt;&gt; q_input = torch.quantize_per_tensor(input, scale=1.0, zero_point=0, dtype=torch.quint8)
&gt;&gt;&gt; output = m(q_input)
</pre> <dl class="method"> <dt id="torch.nn.quantized.Conv2d.from_float">
<code>classmethod from_float(mod)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/conv.html#Conv2d.from_float"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Creates a quantized module from a float module or qparams_dict.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>mod</strong> (<a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module">Module</a>) – a float module, either produced by torch.quantization utilities or provided by the user</p> </dd> </dl> </dd>
</dl> </dd>
</dl>   <h2 id="conv3d">Conv3d</h2> <dl class="class"> <dt id="torch.nn.quantized.Conv3d">
<code>class torch.nn.quantized.Conv3d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode='zeros')</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/conv.html#Conv3d"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Applies a 3D convolution over a quantized input signal composed of several quantized input planes.</p> <p>For details on input arguments, parameters, and implementation see <a class="reference internal" href="generated/torch.nn.conv3d#torch.nn.Conv3d" title="torch.nn.Conv3d"><code>Conv3d</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Only <code>zeros</code> is supported for the <code>padding_mode</code> argument.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Only <code>torch.quint8</code> is supported for the input data type.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Variables</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>~Conv3d.weight</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – packed tensor derived from the learnable weight parameter.</li> <li>
<strong>~Conv3d.scale</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – scalar for the output scale</li> <li>
<strong>~Conv3d.zero_point</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – scalar for the output zero point</li> </ul> </dd> </dl> <p>See <a class="reference internal" href="generated/torch.nn.conv3d#torch.nn.Conv3d" title="torch.nn.Conv3d"><code>Conv3d</code></a> for other attributes.</p> <p>Examples:</p> <pre data-language="python">&gt;&gt;&gt; # With square kernels and equal stride
&gt;&gt;&gt; m = nn.quantized.Conv3d(16, 33, 3, stride=2)
&gt;&gt;&gt; # non-square kernels and unequal stride and with padding
&gt;&gt;&gt; m = nn.quantized.Conv3d(16, 33, (3, 5, 5), stride=(1, 2, 2), padding=(1, 2, 2))
&gt;&gt;&gt; # non-square kernels and unequal stride and with padding and dilation
&gt;&gt;&gt; m = nn.quantized.Conv3d(16, 33, (3, 5, 5), stride=(1, 2, 2), padding=(1, 2, 2), dilation=(1, 2, 2))
&gt;&gt;&gt; input = torch.randn(20, 16, 56, 56, 56)
&gt;&gt;&gt; # quantize input to quint8
&gt;&gt;&gt; q_input = torch.quantize_per_tensor(input, scale=1.0, zero_point=0, dtype=torch.quint8)
&gt;&gt;&gt; output = m(q_input)
</pre> <dl class="method"> <dt id="torch.nn.quantized.Conv3d.from_float">
<code>classmethod from_float(mod)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/conv.html#Conv3d.from_float"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Creates a quantized module from a float module or qparams_dict.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>mod</strong> (<a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module">Module</a>) – a float module, either produced by torch.quantization utilities or provided by the user</p> </dd> </dl> </dd>
</dl> </dd>
</dl>   <h2 id="floatfunctional">FloatFunctional</h2> <dl class="class"> <dt id="torch.nn.quantized.FloatFunctional">
<code>class torch.nn.quantized.FloatFunctional</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/functional_modules.html#FloatFunctional"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>State collector class for float operations.</p> <p>The instance of this class can be used instead of the <code>torch.</code> prefix for some operations. See example usage below.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This class does not provide a <code>forward</code> hook. Instead, you must use one of the underlying functions (e.g. <code>add</code>).</p> </div> <p>Examples:</p> <pre data-language="python">&gt;&gt;&gt; f_add = FloatFunctional()
&gt;&gt;&gt; a = torch.tensor(3.0)
&gt;&gt;&gt; b = torch.tensor(4.0)
&gt;&gt;&gt; f_add.add(a, b)  # Equivalent to ``torch.add(a, b)``
</pre> <dl class="simple"> <dt>Valid operation names:</dt>
<dd>
<ul class="simple"> <li>add</li> <li>cat</li> <li>mul</li> <li>add_relu</li> <li>add_scalar</li> <li>mul_scalar</li> </ul> </dd> </dl> </dd>
</dl>   <h2 id="qfunctional">QFunctional</h2> <dl class="class"> <dt id="torch.nn.quantized.QFunctional">
<code>class torch.nn.quantized.QFunctional</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/functional_modules.html#QFunctional"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Wrapper class for quantized operations.</p> <p>The instance of this class can be used instead of the <code>torch.ops.quantized</code> prefix. See example usage below.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This class does not provide a <code>forward</code> hook. Instead, you must use one of the underlying functions (e.g. <code>add</code>).</p> </div> <p>Examples:</p> <pre data-language="python">&gt;&gt;&gt; q_add = QFunctional()
&gt;&gt;&gt; a = torch.quantize_per_tensor(torch.tensor(3.0), 1.0, 0, torch.qint32)
&gt;&gt;&gt; b = torch.quantize_per_tensor(torch.tensor(4.0), 1.0, 0, torch.qint32)
&gt;&gt;&gt; q_add.add(a, b)  # Equivalent to ``torch.ops.quantized.add(a, b, 1.0, 0)``
</pre> <dl class="simple"> <dt>Valid operation names:</dt>
<dd>
<ul class="simple"> <li>add</li> <li>cat</li> <li>mul</li> <li>add_relu</li> <li>add_scalar</li> <li>mul_scalar</li> </ul> </dd> </dl> </dd>
</dl>   <h2 id="quantize">Quantize</h2> <dl class="class"> <dt id="torch.nn.quantized.Quantize">
<code>class torch.nn.quantized.Quantize(scale, zero_point, dtype)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules.html#Quantize"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Quantizes an incoming tensor</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>scale</strong> – scale of the output Quantized Tensor</li> <li>
<strong>zero_point</strong> – zero_point of output Quantized Tensor</li> <li>
<strong>dtype</strong> – data type of output Quantized Tensor</li> </ul> </dd> <dt class="field-even">Variables</dt> <dd class="field-even">
<p><strong>zero_point, dtype</strong> (<em>`scale`</em><em>,</em>) – </p> </dd> </dl> <dl> <dt>Examples::</dt>
<dd>
<pre data-language="python">&gt;&gt;&gt; t = torch.tensor([[1., -1.], [1., -1.]])
&gt;&gt;&gt; scale, zero_point, dtype = 1.0, 2, torch.qint8
&gt;&gt;&gt; qm = Quantize(scale, zero_point, dtype)
&gt;&gt;&gt; qt = qm(t)
&gt;&gt;&gt; print(qt)
tensor([[ 1., -1.],
        [ 1., -1.]], size=(2, 2), dtype=torch.qint8, scale=1.0, zero_point=2)
</pre> </dd> </dl> </dd>
</dl>   <h2 id="dequantize">DeQuantize</h2> <dl class="class"> <dt id="torch.nn.quantized.DeQuantize">
<code>class torch.nn.quantized.DeQuantize</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules.html#DeQuantize"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Dequantizes an incoming tensor</p> <dl> <dt>Examples::</dt>
<dd>
<pre data-language="python">&gt;&gt;&gt; input = torch.tensor([[1., -1.], [1., -1.]])
&gt;&gt;&gt; scale, zero_point, dtype = 1.0, 2, torch.qint8
&gt;&gt;&gt; qm = Quantize(scale, zero_point, dtype)
&gt;&gt;&gt; quantized_input = qm(input)
&gt;&gt;&gt; dqm = DeQuantize()
&gt;&gt;&gt; dequantized = dqm(quantized_input)
&gt;&gt;&gt; print(dequantized)
tensor([[ 1., -1.],
        [ 1., -1.]], dtype=torch.float32)
</pre> </dd> </dl> </dd>
</dl>   <h2 id="linear">Linear</h2> <dl class="class"> <dt id="torch.nn.quantized.Linear">
<code>class torch.nn.quantized.Linear(in_features, out_features, bias_=True, dtype=torch.qint8)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/linear.html#Linear"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>A quantized linear module with quantized tensor as inputs and outputs. We adopt the same interface as <code>torch.nn.Linear</code>, please see <a class="reference external" href="https://pytorch.org/docs/stable/nn.html#torch.nn.Linear">https://pytorch.org/docs/stable/nn.html#torch.nn.Linear</a> for documentation.</p> <p>Similar to <a class="reference internal" href="generated/torch.nn.linear#torch.nn.Linear" title="torch.nn.Linear"><code>Linear</code></a>, attributes will be randomly initialized at module creation time and will be overwritten later</p> <dl class="field-list simple"> <dt class="field-odd">Variables</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>~Linear.weight</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the non-learnable quantized weights of the module of shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>out_features</mtext><mo separator="true">,</mo><mtext>in_features</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{out\_features}, \text{in\_features})</annotation></semantics></math></span></span> </span>.</li> <li>
<strong>~Linear.bias</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the non-learnable bias of the module of shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>out_features</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{out\_features})</annotation></semantics></math></span></span> </span>. If <code>bias</code> is <code>True</code>, the values are initialized to zero.</li> <li>
<strong>~Linear.scale</strong> – <code>scale</code> parameter of output Quantized Tensor, type: double</li> <li>
<strong>~Linear.zero_point</strong> – <code>zero_point</code> parameter for output Quantized Tensor, type: long</li> </ul> </dd> </dl> <p>Examples:</p> <pre data-language="python">&gt;&gt;&gt; m = nn.quantized.Linear(20, 30)
&gt;&gt;&gt; input = torch.randn(128, 20)
&gt;&gt;&gt; input = torch.quantize_per_tensor(input, 1.0, 0, torch.quint8)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; print(output.size())
torch.Size([128, 30])
</pre> <dl class="method"> <dt id="torch.nn.quantized.Linear.from_float">
<code>classmethod from_float(mod)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/linear.html#Linear.from_float"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a quantized module from a float module or qparams_dict</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>mod</strong> (<a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module">Module</a>) – a float module, either produced by torch.quantization utilities or provided by the user</p> </dd> </dl> </dd>
</dl> </dd>
</dl>   <h2 id="batchnorm2d">BatchNorm2d</h2> <dl class="class"> <dt id="torch.nn.quantized.BatchNorm2d">
<code>class torch.nn.quantized.BatchNorm2d(num_features, eps=1e-05, momentum=0.1)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/batchnorm.html#BatchNorm2d"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This is the quantized version of <a class="reference internal" href="generated/torch.nn.batchnorm2d#torch.nn.BatchNorm2d" title="torch.nn.BatchNorm2d"><code>BatchNorm2d</code></a>.</p> </dd>
</dl>   <h2 id="batchnorm3d">BatchNorm3d</h2> <dl class="class"> <dt id="torch.nn.quantized.BatchNorm3d">
<code>class torch.nn.quantized.BatchNorm3d(num_features, eps=1e-05, momentum=0.1)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/batchnorm.html#BatchNorm3d"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This is the quantized version of <a class="reference internal" href="generated/torch.nn.batchnorm3d#torch.nn.BatchNorm3d" title="torch.nn.BatchNorm3d"><code>BatchNorm3d</code></a>.</p> </dd>
</dl>   <h2 id="layernorm">LayerNorm</h2> <dl class="class"> <dt id="torch.nn.quantized.LayerNorm">
<code>class torch.nn.quantized.LayerNorm(normalized_shape, weight, bias, scale, zero_point, eps=1e-05, elementwise_affine=True)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/normalization.html#LayerNorm"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This is the quantized version of <a class="reference internal" href="generated/torch.nn.layernorm#torch.nn.LayerNorm" title="torch.nn.LayerNorm"><code>LayerNorm</code></a>.</p> <dl class="simple"> <dt>Additional args:</dt>
<dd>
<ul class="simple"> <li>
<strong>scale</strong> - quantization scale of the output, type: double.</li> <li>
<strong>zero_point</strong> - quantization zero point of the output, type: long.</li> </ul> </dd> </dl> </dd>
</dl>   <h2 id="groupnorm">GroupNorm</h2> <dl class="class"> <dt id="torch.nn.quantized.GroupNorm">
<code>class torch.nn.quantized.GroupNorm(num_groups, num_channels, weight, bias, scale, zero_point, eps=1e-05, affine=True)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/normalization.html#GroupNorm"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This is the quantized version of <a class="reference internal" href="generated/torch.nn.groupnorm#torch.nn.GroupNorm" title="torch.nn.GroupNorm"><code>GroupNorm</code></a>.</p> <dl class="simple"> <dt>Additional args:</dt>
<dd>
<ul class="simple"> <li>
<strong>scale</strong> - quantization scale of the output, type: double.</li> <li>
<strong>zero_point</strong> - quantization zero point of the output, type: long.</li> </ul> </dd> </dl> </dd>
</dl>   <h2 id="instancenorm1d">InstanceNorm1d</h2> <dl class="class"> <dt id="torch.nn.quantized.InstanceNorm1d">
<code>class torch.nn.quantized.InstanceNorm1d(num_features, weight, bias, scale, zero_point, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/normalization.html#InstanceNorm1d"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This is the quantized version of <a class="reference internal" href="generated/torch.nn.instancenorm1d#torch.nn.InstanceNorm1d" title="torch.nn.InstanceNorm1d"><code>InstanceNorm1d</code></a>.</p> <dl class="simple"> <dt>Additional args:</dt>
<dd>
<ul class="simple"> <li>
<strong>scale</strong> - quantization scale of the output, type: double.</li> <li>
<strong>zero_point</strong> - quantization zero point of the output, type: long.</li> </ul> </dd> </dl> </dd>
</dl>   <h2 id="instancenorm2d">InstanceNorm2d</h2> <dl class="class"> <dt id="torch.nn.quantized.InstanceNorm2d">
<code>class torch.nn.quantized.InstanceNorm2d(num_features, weight, bias, scale, zero_point, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/normalization.html#InstanceNorm2d"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This is the quantized version of <a class="reference internal" href="generated/torch.nn.instancenorm2d#torch.nn.InstanceNorm2d" title="torch.nn.InstanceNorm2d"><code>InstanceNorm2d</code></a>.</p> <dl class="simple"> <dt>Additional args:</dt>
<dd>
<ul class="simple"> <li>
<strong>scale</strong> - quantization scale of the output, type: double.</li> <li>
<strong>zero_point</strong> - quantization zero point of the output, type: long.</li> </ul> </dd> </dl> </dd>
</dl>   <h2 id="instancenorm3d">InstanceNorm3d</h2> <dl class="class"> <dt id="torch.nn.quantized.InstanceNorm3d">
<code>class torch.nn.quantized.InstanceNorm3d(num_features, weight, bias, scale, zero_point, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/normalization.html#InstanceNorm3d"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This is the quantized version of <a class="reference internal" href="generated/torch.nn.instancenorm3d#torch.nn.InstanceNorm3d" title="torch.nn.InstanceNorm3d"><code>InstanceNorm3d</code></a>.</p> <dl class="simple"> <dt>Additional args:</dt>
<dd>
<ul class="simple"> <li>
<strong>scale</strong> - quantization scale of the output, type: double.</li> <li>
<strong>zero_point</strong> - quantization zero point of the output, type: long.</li> </ul> </dd> </dl> </dd>
</dl>   <h2 id="embedding">Embedding</h2> <dl class="class"> <dt id="torch.nn.quantized.Embedding">
<code>class torch.nn.quantized.Embedding(num_embeddings, embedding_dim, padding_idx=None, max_norm=None, norm_type=2.0, scale_grad_by_freq=False, sparse=False, _weight=None, dtype=torch.quint8)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/embedding_ops.html#Embedding"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>A quantized Embedding module with quantized packed weights as inputs. We adopt the same interface as <code>torch.nn.Embedding</code>, please see <a class="reference external" href="https://pytorch.org/docs/stable/nn.html#torch.nn.Embedding">https://pytorch.org/docs/stable/nn.html#torch.nn.Embedding</a> for documentation.</p> <p>Similar to <a class="reference internal" href="generated/torch.nn.embedding#torch.nn.Embedding" title="torch.nn.Embedding"><code>Embedding</code></a>, attributes will be randomly initialized at module creation time and will be overwritten later</p> <dl class="field-list simple"> <dt class="field-odd">Variables</dt> <dd class="field-odd">
<p><strong>~Embedding.weight</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the non-learnable quantized weights of the module of shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>num_embeddings</mtext><mo separator="true">,</mo><mtext>embedding_dim</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{num\_embeddings}, \text{embedding\_dim})</annotation></semantics></math></span></span> </span>.</p> </dd> </dl> <dl> <dt>Examples::</dt>
<dd>
<pre data-language="python">&gt;&gt;&gt; m = nn.quantized.Embedding(num_embeddings=10, embedding_dim=12)
&gt;&gt;&gt; indices = torch.tensor([9, 6, 5, 7, 8, 8, 9, 2, 8])
&gt;&gt;&gt; output = m(indices)
&gt;&gt;&gt; print(output.size())
torch.Size([9, 12]
</pre> </dd> </dl> <dl class="method"> <dt id="torch.nn.quantized.Embedding.from_float">
<code>classmethod from_float(mod)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/embedding_ops.html#Embedding.from_float"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a quantized embedding module from a float module</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>mod</strong> (<a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module">Module</a>) – a float module, either produced by torch.quantization utilities or provided by user</p> </dd> </dl> </dd>
</dl> </dd>
</dl>   <h2 id="embeddingbag">EmbeddingBag</h2> <dl class="class"> <dt id="torch.nn.quantized.EmbeddingBag">
<code>class torch.nn.quantized.EmbeddingBag(num_embeddings, embedding_dim, max_norm=None, norm_type=2.0, scale_grad_by_freq=False, mode='sum', sparse=False, _weight=None, include_last_offset=False, dtype=torch.quint8)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/embedding_ops.html#EmbeddingBag"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>A quantized EmbeddingBag module with quantized packed weights as inputs. We adopt the same interface as <code>torch.nn.EmbeddingBag</code>, please see <a class="reference external" href="https://pytorch.org/docs/stable/nn.html#torch.nn.EmbeddingBag">https://pytorch.org/docs/stable/nn.html#torch.nn.EmbeddingBag</a> for documentation.</p> <p>Similar to <a class="reference internal" href="generated/torch.nn.embeddingbag#torch.nn.EmbeddingBag" title="torch.nn.EmbeddingBag"><code>EmbeddingBag</code></a>, attributes will be randomly initialized at module creation time and will be overwritten later</p> <dl class="field-list simple"> <dt class="field-odd">Variables</dt> <dd class="field-odd">
<p><strong>~EmbeddingBag.weight</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the non-learnable quantized weights of the module of shape <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext>num_embeddings</mtext><mo separator="true">,</mo><mtext>embedding_dim</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\text{num\_embeddings}, \text{embedding\_dim})</annotation></semantics></math></span></span> </span>.</p> </dd> </dl> <dl> <dt>Examples::</dt>
<dd>
<pre data-language="python">&gt;&gt;&gt; m = nn.quantized.EmbeddingBag(num_embeddings=10, embedding_dim=12, include_last_offset=True, mode='sum')
&gt;&gt;&gt; indices = torch.tensor([9, 6, 5, 7, 8, 8, 9, 2, 8, 6, 6, 9, 1, 6, 8, 8, 3, 2, 3, 6, 3, 6, 5, 7, 0, 8, 4, 6, 5, 8, 2, 3])
&gt;&gt;&gt; offsets = torch.tensor([0, 19, 20, 28, 28, 32])
&gt;&gt;&gt; output = m(indices, offsets)
&gt;&gt;&gt; print(output.size())
torch.Size([5, 12]
</pre> </dd> </dl> <dl class="method"> <dt id="torch.nn.quantized.EmbeddingBag.from_float">
<code>classmethod from_float(mod)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/nn/quantized/modules/embedding_ops.html#EmbeddingBag.from_float"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a quantized embedding_bag module from a float module</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>mod</strong> (<a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module">Module</a>) – a float module, either produced by torch.quantization utilities or provided by user</p> </dd> </dl> </dd>
</dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://pytorch.org/docs/1.8.0/torch.nn.quantized.html" class="_attribution-link" target="_blank">https://pytorch.org/docs/1.8.0/torch.nn.quantized.html</a>
  </p>
</div>
