<h1 id="torch-fft">torch.fft</h1> <p>Discrete Fourier transforms and related functions.</p>  <h2 id="fast-fourier-transforms">Fast Fourier Transforms</h2> <dl class="function"> <dt id="torch.fft.fft">
<code>torch.fft.fft(input, n=None, dim=-1, norm=None) → Tensor</code> </dt> <dd>
<p>Computes the one dimensional discrete Fourier transform of <code>input</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The Fourier domain representation of any real signal satisfies the Hermitian property: <code>X[i] = conj(X[-i])</code>. This function always returns both the positive and negative frequency terms even though, for real inputs, the negative frequencies are redundant. <a class="reference internal" href="#torch.fft.rfft" title="torch.fft.rfft"><code>rfft()</code></a> returns the more compact one-sided representation where only the positive frequencies are returned.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the input tensor</li> <li>
<strong>n</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><em>optional</em>) – Signal length. If given, the input will either be zero-padded or trimmed to this length before computing the FFT.</li> <li>
<strong>dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><em>optional</em>) – The dimension along which to take the one dimensional FFT.</li> <li>
<p><strong>norm</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><em>optional</em>) – </p>
<p>Normalization mode. For the forward transform (<a class="reference internal" href="#torch.fft.fft" title="torch.fft.fft"><code>fft()</code></a>), these correspond to:</p> <ul> <li>
<code>"forward"</code> - normalize by <code>1/n</code>
</li> <li>
<code>"backward"</code> - no normalization</li> <li>
<code>"ortho"</code> - normalize by <code>1/sqrt(n)</code> (making the FFT orthonormal)</li> </ul> <p>Calling the backward transform (<a class="reference internal" href="#torch.fft.ifft" title="torch.fft.ifft"><code>ifft()</code></a>) with the same normalization mode will apply an overall normalization of <code>1/n</code> between the two transforms. This is required to make <a class="reference internal" href="#torch.fft.ifft" title="torch.fft.ifft"><code>ifft()</code></a> the exact inverse.</p> <p>Default is <code>"backward"</code> (no normalization).</p> </li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; t = torch.arange(4)
&gt;&gt;&gt; t
tensor([0, 1, 2, 3])
&gt;&gt;&gt; torch.fft.fft(t)
tensor([ 6.+0.j, -2.+2.j, -2.+0.j, -2.-2.j])
</pre> <pre data-language="python">&gt;&gt;&gt; t = tensor([0.+1.j, 2.+3.j, 4.+5.j, 6.+7.j])
&gt;&gt;&gt; torch.fft.fft(t)
tensor([12.+16.j, -8.+0.j, -4.-4.j,  0.-8.j])
</pre> </dd>
</dl> <dl class="function"> <dt id="torch.fft.ifft">
<code>torch.fft.ifft(input, n=None, dim=-1, norm=None) → Tensor</code> </dt> <dd>
<p>Computes the one dimensional inverse discrete Fourier transform of <code>input</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the input tensor</li> <li>
<strong>n</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><em>optional</em>) – Signal length. If given, the input will either be zero-padded or trimmed to this length before computing the IFFT.</li> <li>
<strong>dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><em>optional</em>) – The dimension along which to take the one dimensional IFFT.</li> <li>
<p><strong>norm</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><em>optional</em>) – </p>
<p>Normalization mode. For the backward transform (<a class="reference internal" href="#torch.fft.ifft" title="torch.fft.ifft"><code>ifft()</code></a>), these correspond to:</p> <ul> <li>
<code>"forward"</code> - no normalization</li> <li>
<code>"backward"</code> - normalize by <code>1/n</code>
</li> <li>
<code>"ortho"</code> - normalize by <code>1/sqrt(n)</code> (making the IFFT orthonormal)</li> </ul> <p>Calling the forward transform (<a class="reference internal" href="#torch.fft.fft" title="torch.fft.fft"><code>fft()</code></a>) with the same normalization mode will apply an overall normalization of <code>1/n</code> between the two transforms. This is required to make <a class="reference internal" href="#torch.fft.ifft" title="torch.fft.ifft"><code>ifft()</code></a> the exact inverse.</p> <p>Default is <code>"backward"</code> (normalize by <code>1/n</code>).</p> </li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; t = torch.tensor([ 6.+0.j, -2.+2.j, -2.+0.j, -2.-2.j])
&gt;&gt;&gt; torch.fft.ifft(t)
tensor([0.+0.j, 1.+0.j, 2.+0.j, 3.+0.j])
</pre> </dd>
</dl> <dl class="function"> <dt id="torch.fft.fft2">
<code>torch.fft.fft2(input, s=None, dim=(-2, -1), norm=None) → Tensor</code> </dt> <dd>
<p>Computes the 2 dimensional discrete Fourier transform of <code>input</code>. Equivalent to <a class="reference internal" href="#torch.fft.fftn" title="torch.fft.fftn"><code>fftn()</code></a> but FFTs only the last two dimensions by default.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The Fourier domain representation of any real signal satisfies the Hermitian property: <code>X[i, j] = conj(X[-i, -j])</code>. This function always returns all positive and negative frequency terms even though, for real inputs, half of these values are redundant. <a class="reference internal" href="#torch.fft.rfft2" title="torch.fft.rfft2"><code>rfft2()</code></a> returns the more compact one-sided representation where only the positive frequencies of the last dimension are returned.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the input tensor</li> <li>
<strong>s</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em><em>, </em><em>optional</em>) – Signal size in the transformed dimensions. If given, each dimension <code>dim[i]</code> will either be zero-padded or trimmed to the length <code>s[i]</code> before computing the FFT. If a length <code>-1</code> is specified, no padding is done in that dimension. Default: <code>s = [input.size(d) for d in dim]</code>
</li> <li>
<strong>dim</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em><em>, </em><em>optional</em>) – Dimensions to be transformed. Default: last two dimensions.</li> <li>
<p><strong>norm</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><em>optional</em>) – </p>
<p>Normalization mode. For the forward transform (<a class="reference internal" href="#torch.fft.fft2" title="torch.fft.fft2"><code>fft2()</code></a>), these correspond to:</p> <ul> <li>
<code>"forward"</code> - normalize by <code>1/n</code>
</li> <li>
<code>"backward"</code> - no normalization</li> <li>
<code>"ortho"</code> - normalize by <code>1/sqrt(n)</code> (making the FFT orthonormal)</li> </ul> <p>Where <code>n = prod(s)</code> is the logical FFT size. Calling the backward transform (<a class="reference internal" href="#torch.fft.ifft2" title="torch.fft.ifft2"><code>ifft2()</code></a>) with the same normalization mode will apply an overall normalization of <code>1/n</code> between the two transforms. This is required to make <a class="reference internal" href="#torch.fft.ifft2" title="torch.fft.ifft2"><code>ifft2()</code></a> the exact inverse.</p> <p>Default is <code>"backward"</code> (no normalization).</p> </li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; x = torch.rand(10, 10, dtype=torch.complex64)
&gt;&gt;&gt; fft2 = torch.fft.fft2(t)
</pre> <p>The discrete Fourier transform is separable, so <a class="reference internal" href="#torch.fft.fft2" title="torch.fft.fft2"><code>fft2()</code></a> here is equivalent to two one-dimensional <a class="reference internal" href="#torch.fft.fft" title="torch.fft.fft"><code>fft()</code></a> calls:</p> <pre data-language="python">&gt;&gt;&gt; two_ffts = torch.fft.fft(torch.fft.fft(x, dim=0), dim=1)
&gt;&gt;&gt; torch.allclose(fft2, two_ffts)
</pre> </dd>
</dl> <dl class="function"> <dt id="torch.fft.ifft2">
<code>torch.fft.ifft2(input, s=None, dim=(-2, -1), norm=None) → Tensor</code> </dt> <dd>
<p>Computes the 2 dimensional inverse discrete Fourier transform of <code>input</code>. Equivalent to <a class="reference internal" href="#torch.fft.ifftn" title="torch.fft.ifftn"><code>ifftn()</code></a> but IFFTs only the last two dimensions by default.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the input tensor</li> <li>
<strong>s</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em><em>, </em><em>optional</em>) – Signal size in the transformed dimensions. If given, each dimension <code>dim[i]</code> will either be zero-padded or trimmed to the length <code>s[i]</code> before computing the IFFT. If a length <code>-1</code> is specified, no padding is done in that dimension. Default: <code>s = [input.size(d) for d in dim]</code>
</li> <li>
<strong>dim</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em><em>, </em><em>optional</em>) – Dimensions to be transformed. Default: last two dimensions.</li> <li>
<p><strong>norm</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><em>optional</em>) – </p>
<p>Normalization mode. For the backward transform (<a class="reference internal" href="#torch.fft.ifft2" title="torch.fft.ifft2"><code>ifft2()</code></a>), these correspond to:</p> <ul> <li>
<code>"forward"</code> - no normalization</li> <li>
<code>"backward"</code> - normalize by <code>1/n</code>
</li> <li>
<code>"ortho"</code> - normalize by <code>1/sqrt(n)</code> (making the IFFT orthonormal)</li> </ul> <p>Where <code>n = prod(s)</code> is the logical IFFT size. Calling the forward transform (<a class="reference internal" href="#torch.fft.fft2" title="torch.fft.fft2"><code>fft2()</code></a>) with the same normalization mode will apply an overall normalization of <code>1/n</code> between the two transforms. This is required to make <a class="reference internal" href="#torch.fft.ifft2" title="torch.fft.ifft2"><code>ifft2()</code></a> the exact inverse.</p> <p>Default is <code>"backward"</code> (normalize by <code>1/n</code>).</p> </li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; x = torch.rand(10, 10, dtype=torch.complex64)
&gt;&gt;&gt; ifft2 = torch.fft.ifft2(t)
</pre> <p>The discrete Fourier transform is separable, so <a class="reference internal" href="#torch.fft.ifft2" title="torch.fft.ifft2"><code>ifft2()</code></a> here is equivalent to two one-dimensional <a class="reference internal" href="#torch.fft.ifft" title="torch.fft.ifft"><code>ifft()</code></a> calls:</p> <pre data-language="python">&gt;&gt;&gt; two_iffts = torch.fft.ifft(torch.fft.ifft(x, dim=0), dim=1)
&gt;&gt;&gt; torch.allclose(ifft2, two_iffts)
</pre> </dd>
</dl> <dl class="function"> <dt id="torch.fft.fftn">
<code>torch.fft.fftn(input, s=None, dim=None, norm=None) → Tensor</code> </dt> <dd>
<p>Computes the N dimensional discrete Fourier transform of <code>input</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The Fourier domain representation of any real signal satisfies the Hermitian property: <code>X[i_1, ..., i_n] = conj(X[-i_1, ..., -i_n])</code>. This function always returns all positive and negative frequency terms even though, for real inputs, half of these values are redundant. <a class="reference internal" href="#torch.fft.rfftn" title="torch.fft.rfftn"><code>rfftn()</code></a> returns the more compact one-sided representation where only the positive frequencies of the last dimension are returned.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the input tensor</li> <li>
<strong>s</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em><em>, </em><em>optional</em>) – Signal size in the transformed dimensions. If given, each dimension <code>dim[i]</code> will either be zero-padded or trimmed to the length <code>s[i]</code> before computing the FFT. If a length <code>-1</code> is specified, no padding is done in that dimension. Default: <code>s = [input.size(d) for d in dim]</code>
</li> <li>
<strong>dim</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em><em>, </em><em>optional</em>) – Dimensions to be transformed. Default: all dimensions, or the last <code>len(s)</code> dimensions if <code>s</code> is given.</li> <li>
<p><strong>norm</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><em>optional</em>) – </p>
<p>Normalization mode. For the forward transform (<a class="reference internal" href="#torch.fft.fftn" title="torch.fft.fftn"><code>fftn()</code></a>), these correspond to:</p> <ul> <li>
<code>"forward"</code> - normalize by <code>1/n</code>
</li> <li>
<code>"backward"</code> - no normalization</li> <li>
<code>"ortho"</code> - normalize by <code>1/sqrt(n)</code> (making the FFT orthonormal)</li> </ul> <p>Where <code>n = prod(s)</code> is the logical FFT size. Calling the backward transform (<a class="reference internal" href="#torch.fft.ifftn" title="torch.fft.ifftn"><code>ifftn()</code></a>) with the same normalization mode will apply an overall normalization of <code>1/n</code> between the two transforms. This is required to make <a class="reference internal" href="#torch.fft.ifftn" title="torch.fft.ifftn"><code>ifftn()</code></a> the exact inverse.</p> <p>Default is <code>"backward"</code> (no normalization).</p> </li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; x = torch.rand(10, 10, dtype=torch.complex64)
&gt;&gt;&gt; fftn = torch.fft.fftn(t)
</pre> <p>The discrete Fourier transform is separable, so <a class="reference internal" href="#torch.fft.fftn" title="torch.fft.fftn"><code>fftn()</code></a> here is equivalent to two one-dimensional <a class="reference internal" href="#torch.fft.fft" title="torch.fft.fft"><code>fft()</code></a> calls:</p> <pre data-language="python">&gt;&gt;&gt; two_ffts = torch.fft.fft(torch.fft.fft(x, dim=0), dim=1)
&gt;&gt;&gt; torch.allclose(fftn, two_ffts)
</pre> </dd>
</dl> <dl class="function"> <dt id="torch.fft.ifftn">
<code>torch.fft.ifftn(input, s=None, dim=None, norm=None) → Tensor</code> </dt> <dd>
<p>Computes the N dimensional inverse discrete Fourier transform of <code>input</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the input tensor</li> <li>
<strong>s</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em><em>, </em><em>optional</em>) – Signal size in the transformed dimensions. If given, each dimension <code>dim[i]</code> will either be zero-padded or trimmed to the length <code>s[i]</code> before computing the IFFT. If a length <code>-1</code> is specified, no padding is done in that dimension. Default: <code>s = [input.size(d) for d in dim]</code>
</li> <li>
<strong>dim</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em><em>, </em><em>optional</em>) – Dimensions to be transformed. Default: all dimensions, or the last <code>len(s)</code> dimensions if <code>s</code> is given.</li> <li>
<p><strong>norm</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><em>optional</em>) – </p>
<p>Normalization mode. For the backward transform (<a class="reference internal" href="#torch.fft.ifftn" title="torch.fft.ifftn"><code>ifftn()</code></a>), these correspond to:</p> <ul> <li>
<code>"forward"</code> - no normalization</li> <li>
<code>"backward"</code> - normalize by <code>1/n</code>
</li> <li>
<code>"ortho"</code> - normalize by <code>1/sqrt(n)</code> (making the IFFT orthonormal)</li> </ul> <p>Where <code>n = prod(s)</code> is the logical IFFT size. Calling the forward transform (<a class="reference internal" href="#torch.fft.fftn" title="torch.fft.fftn"><code>fftn()</code></a>) with the same normalization mode will apply an overall normalization of <code>1/n</code> between the two transforms. This is required to make <a class="reference internal" href="#torch.fft.ifftn" title="torch.fft.ifftn"><code>ifftn()</code></a> the exact inverse.</p> <p>Default is <code>"backward"</code> (normalize by <code>1/n</code>).</p> </li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; x = torch.rand(10, 10, dtype=torch.complex64)
&gt;&gt;&gt; ifftn = torch.fft.ifftn(t)
</pre> <p>The discrete Fourier transform is separable, so <a class="reference internal" href="#torch.fft.ifftn" title="torch.fft.ifftn"><code>ifftn()</code></a> here is equivalent to two one-dimensional <a class="reference internal" href="#torch.fft.ifft" title="torch.fft.ifft"><code>ifft()</code></a> calls:</p> <pre data-language="python">&gt;&gt;&gt; two_iffts = torch.fft.ifft(torch.fft.ifft(x, dim=0), dim=1)
&gt;&gt;&gt; torch.allclose(ifftn, two_iffts)
</pre> </dd>
</dl> <dl class="function"> <dt id="torch.fft.rfft">
<code>torch.fft.rfft(input, n=None, dim=-1, norm=None) → Tensor</code> </dt> <dd>
<p>Computes the one dimensional Fourier transform of real-valued <code>input</code>.</p> <p>The FFT of a real signal is Hermitian-symmetric, <code>X[i] = conj(X[-i])</code> so the output contains only the positive frequencies below the Nyquist frequency. To compute the full output, use <a class="reference internal" href="#torch.fft.fft" title="torch.fft.fft"><code>fft()</code></a></p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the real input tensor</li> <li>
<strong>n</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><em>optional</em>) – Signal length. If given, the input will either be zero-padded or trimmed to this length before computing the real FFT.</li> <li>
<strong>dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><em>optional</em>) – The dimension along which to take the one dimensional real FFT.</li> <li>
<p><strong>norm</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><em>optional</em>) – </p>
<p>Normalization mode. For the forward transform (<a class="reference internal" href="#torch.fft.rfft" title="torch.fft.rfft"><code>rfft()</code></a>), these correspond to:</p> <ul> <li>
<code>"forward"</code> - normalize by <code>1/n</code>
</li> <li>
<code>"backward"</code> - no normalization</li> <li>
<code>"ortho"</code> - normalize by <code>1/sqrt(n)</code> (making the FFT orthonormal)</li> </ul> <p>Calling the backward transform (<a class="reference internal" href="#torch.fft.irfft" title="torch.fft.irfft"><code>irfft()</code></a>) with the same normalization mode will apply an overall normalization of <code>1/n</code> between the two transforms. This is required to make <a class="reference internal" href="#torch.fft.irfft" title="torch.fft.irfft"><code>irfft()</code></a> the exact inverse.</p> <p>Default is <code>"backward"</code> (no normalization).</p> </li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; t = torch.arange(4)
&gt;&gt;&gt; t
tensor([0, 1, 2, 3])
&gt;&gt;&gt; torch.fft.rfft(t)
tensor([ 6.+0.j, -2.+2.j, -2.+0.j])
</pre> <p>Compare against the full output from <a class="reference internal" href="#torch.fft.fft" title="torch.fft.fft"><code>fft()</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; torch.fft.fft(t)
tensor([ 6.+0.j, -2.+2.j, -2.+0.j, -2.-2.j])
</pre> <p>Notice that the symmetric element <code>T[-1] == T[1].conj()</code> is omitted. At the Nyquist frequency <code>T[-2] == T[2]</code> is it’s own symmetric pair, and therefore must always be real-valued.</p> </dd>
</dl> <dl class="function"> <dt id="torch.fft.irfft">
<code>torch.fft.irfft(input, n=None, dim=-1, norm=None) → Tensor</code> </dt> <dd>
<p>Computes the inverse of <a class="reference internal" href="#torch.fft.rfft" title="torch.fft.rfft"><code>rfft()</code></a>.</p> <p><code>input</code> is interpreted as a one-sided Hermitian signal in the Fourier domain, as produced by <a class="reference internal" href="#torch.fft.rfft" title="torch.fft.rfft"><code>rfft()</code></a>. By the Hermitian property, the output will be real-valued.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Some input frequencies must be real-valued to satisfy the Hermitian property. In these cases the imaginary component will be ignored. For example, any imaginary component in the zero-frequency term cannot be represented in a real output and so will always be ignored.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The correct interpretation of the Hermitian input depends on the length of the original data, as given by <code>n</code>. This is because each input shape could correspond to either an odd or even length signal. By default, the signal is assumed to be even length and odd signals will not round-trip properly. So, it is recommended to always pass the signal length <code>n</code>.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the input tensor representing a half-Hermitian signal</li> <li>
<strong>n</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><em>optional</em>) – Output signal length. This determines the length of the output signal. If given, the input will either be zero-padded or trimmed to this length before computing the real IFFT. Defaults to even output: <code>n=2*(input.size(dim) - 1)</code>.</li> <li>
<strong>dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><em>optional</em>) – The dimension along which to take the one dimensional real IFFT.</li> <li>
<p><strong>norm</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><em>optional</em>) – </p>
<p>Normalization mode. For the backward transform (<a class="reference internal" href="#torch.fft.irfft" title="torch.fft.irfft"><code>irfft()</code></a>), these correspond to:</p> <ul> <li>
<code>"forward"</code> - no normalization</li> <li>
<code>"backward"</code> - normalize by <code>1/n</code>
</li> <li>
<code>"ortho"</code> - normalize by <code>1/sqrt(n)</code> (making the real IFFT orthonormal)</li> </ul> <p>Calling the forward transform (<a class="reference internal" href="#torch.fft.rfft" title="torch.fft.rfft"><code>rfft()</code></a>) with the same normalization mode will apply an overall normalization of <code>1/n</code> between the two transforms. This is required to make <a class="reference internal" href="#torch.fft.irfft" title="torch.fft.irfft"><code>irfft()</code></a> the exact inverse.</p> <p>Default is <code>"backward"</code> (normalize by <code>1/n</code>).</p> </li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; t = torch.arange(5)
&gt;&gt;&gt; t
tensor([0, 1, 2, 3, 4])
&gt;&gt;&gt; T = torch.fft.rfft(t)
&gt;&gt;&gt; T
tensor([10.0000+0.0000j, -2.5000+3.4410j, -2.5000+0.8123j])
</pre> <p>Without specifying the output length to <a class="reference internal" href="#torch.fft.irfft" title="torch.fft.irfft"><code>irfft()</code></a>, the output will not round-trip properly because the input is odd-length:</p> <pre data-language="python">&gt;&gt;&gt; torch.fft.irfft(T)
tensor([0.6250, 1.4045, 3.1250, 4.8455])
</pre> <p>So, it is recommended to always pass the signal length <code>n</code>:</p> <pre data-language="python">&gt;&gt;&gt; torch.fft.irfft(T, t.numel())
tensor([0.0000, 1.0000, 2.0000, 3.0000, 4.0000])
</pre> </dd>
</dl> <dl class="function"> <dt id="torch.fft.rfft2">
<code>torch.fft.rfft2(input, s=None, dim=(-2, -1), norm=None) → Tensor</code> </dt> <dd>
<p>Computes the 2-dimensional discrete Fourier transform of real <code>input</code>. Equivalent to <a class="reference internal" href="#torch.fft.rfftn" title="torch.fft.rfftn"><code>rfftn()</code></a> but FFTs only the last two dimensions by default.</p> <p>The FFT of a real signal is Hermitian-symmetric, <code>X[i, j] = conj(X[-i, -j])</code>, so the full <a class="reference internal" href="#torch.fft.fft2" title="torch.fft.fft2"><code>fft2()</code></a> output contains redundant information. <a class="reference internal" href="#torch.fft.rfft2" title="torch.fft.rfft2"><code>rfft2()</code></a> instead omits the negative frequencies in the last dimension.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the input tensor</li> <li>
<strong>s</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em><em>, </em><em>optional</em>) – Signal size in the transformed dimensions. If given, each dimension <code>dim[i]</code> will either be zero-padded or trimmed to the length <code>s[i]</code> before computing the real FFT. If a length <code>-1</code> is specified, no padding is done in that dimension. Default: <code>s = [input.size(d) for d in dim]</code>
</li> <li>
<strong>dim</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em><em>, </em><em>optional</em>) – Dimensions to be transformed. Default: last two dimensions.</li> <li>
<p><strong>norm</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><em>optional</em>) – </p>
<p>Normalization mode. For the forward transform (<a class="reference internal" href="#torch.fft.rfft2" title="torch.fft.rfft2"><code>rfft2()</code></a>), these correspond to:</p> <ul> <li>
<code>"forward"</code> - normalize by <code>1/n</code>
</li> <li>
<code>"backward"</code> - no normalization</li> <li>
<code>"ortho"</code> - normalize by <code>1/sqrt(n)</code> (making the real FFT orthonormal)</li> </ul> <p>Where <code>n = prod(s)</code> is the logical FFT size. Calling the backward transform (<a class="reference internal" href="#torch.fft.irfft2" title="torch.fft.irfft2"><code>irfft2()</code></a>) with the same normalization mode will apply an overall normalization of <code>1/n</code> between the two transforms. This is required to make <a class="reference internal" href="#torch.fft.irfft2" title="torch.fft.irfft2"><code>irfft2()</code></a> the exact inverse.</p> <p>Default is <code>"backward"</code> (no normalization).</p> </li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; t = torch.rand(10, 10)
&gt;&gt;&gt; rfft2 = torch.fft.rfft2(t)
&gt;&gt;&gt; rfft2.size()
torch.Size([10, 6])
</pre> <p>Compared against the full output from <a class="reference internal" href="#torch.fft.fft2" title="torch.fft.fft2"><code>fft2()</code></a>, we have all elements up to the Nyquist frequency.</p> <pre data-language="python">&gt;&gt;&gt; fft2 = torch.fft.fft2(t)
&gt;&gt;&gt; torch.allclose(fft2[..., :6], rfft2)
True
</pre> <p>The discrete Fourier transform is separable, so <a class="reference internal" href="#torch.fft.rfft2" title="torch.fft.rfft2"><code>rfft2()</code></a> here is equivalent to a combination of <a class="reference internal" href="#torch.fft.fft" title="torch.fft.fft"><code>fft()</code></a> and <a class="reference internal" href="#torch.fft.rfft" title="torch.fft.rfft"><code>rfft()</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; two_ffts = torch.fft.fft(torch.fft.rfft(x, dim=1), dim=0)
&gt;&gt;&gt; torch.allclose(rfft2, two_ffts)
</pre> </dd>
</dl> <dl class="function"> <dt id="torch.fft.irfft2">
<code>torch.fft.irfft2(input, s=None, dim=(-2, -1), norm=None) → Tensor</code> </dt> <dd>
<p>Computes the inverse of <a class="reference internal" href="#torch.fft.rfft2" title="torch.fft.rfft2"><code>rfft2()</code></a>. Equivalent to <a class="reference internal" href="#torch.fft.irfftn" title="torch.fft.irfftn"><code>irfftn()</code></a> but IFFTs only the last two dimensions by default.</p> <p><code>input</code> is interpreted as a one-sided Hermitian signal in the Fourier domain, as produced by <a class="reference internal" href="#torch.fft.rfft2" title="torch.fft.rfft2"><code>rfft2()</code></a>. By the Hermitian property, the output will be real-valued.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Some input frequencies must be real-valued to satisfy the Hermitian property. In these cases the imaginary component will be ignored. For example, any imaginary component in the zero-frequency term cannot be represented in a real output and so will always be ignored.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The correct interpretation of the Hermitian input depends on the length of the original data, as given by <code>s</code>. This is because each input shape could correspond to either an odd or even length signal. By default, the signal is assumed to be even length and odd signals will not round-trip properly. So, it is recommended to always pass the signal shape <code>s</code>.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the input tensor</li> <li>
<strong>s</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em><em>, </em><em>optional</em>) – Signal size in the transformed dimensions. If given, each dimension <code>dim[i]</code> will either be zero-padded or trimmed to the length <code>s[i]</code> before computing the real FFT. If a length <code>-1</code> is specified, no padding is done in that dimension. Defaults to even output in the last dimension: <code>s[-1] = 2*(input.size(dim[-1]) - 1)</code>.</li> <li>
<strong>dim</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em><em>, </em><em>optional</em>) – Dimensions to be transformed. The last dimension must be the half-Hermitian compressed dimension. Default: last two dimensions.</li> <li>
<p><strong>norm</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><em>optional</em>) – </p>
<p>Normalization mode. For the backward transform (<a class="reference internal" href="#torch.fft.irfft2" title="torch.fft.irfft2"><code>irfft2()</code></a>), these correspond to:</p> <ul> <li>
<code>"forward"</code> - no normalization</li> <li>
<code>"backward"</code> - normalize by <code>1/n</code>
</li> <li>
<code>"ortho"</code> - normalize by <code>1/sqrt(n)</code> (making the real IFFT orthonormal)</li> </ul> <p>Where <code>n = prod(s)</code> is the logical IFFT size. Calling the forward transform (<a class="reference internal" href="#torch.fft.rfft2" title="torch.fft.rfft2"><code>rfft2()</code></a>) with the same normalization mode will apply an overall normalization of <code>1/n</code> between the two transforms. This is required to make <a class="reference internal" href="#torch.fft.irfft2" title="torch.fft.irfft2"><code>irfft2()</code></a> the exact inverse.</p> <p>Default is <code>"backward"</code> (normalize by <code>1/n</code>).</p> </li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; t = torch.rand(10, 9)
&gt;&gt;&gt; T = torch.fft.rfft2(t)
</pre> <p>Without specifying the output length to <a class="reference internal" href="#torch.fft.irfft2" title="torch.fft.irfft2"><code>irfft2()</code></a>, the output will not round-trip properly because the input is odd-length in the last dimension:</p> <pre data-language="python">&gt;&gt;&gt; torch.fft.irfft2(T).size()
torch.Size([10, 10])
</pre> <p>So, it is recommended to always pass the signal shape <code>s</code>.</p> <pre data-language="python">&gt;&gt;&gt; roundtrip = torch.fft.irfft2(T, t.size())
&gt;&gt;&gt; roundtrip.size()
torch.Size([10, 9])
&gt;&gt;&gt; torch.allclose(roundtrip, t)
True
</pre> </dd>
</dl> <dl class="function"> <dt id="torch.fft.rfftn">
<code>torch.fft.rfftn(input, s=None, dim=None, norm=None) → Tensor</code> </dt> <dd>
<p>Computes the N-dimensional discrete Fourier transform of real <code>input</code>.</p> <p>The FFT of a real signal is Hermitian-symmetric, <code>X[i_1, ..., i_n] = conj(X[-i_1, ..., -i_n])</code> so the full <a class="reference internal" href="#torch.fft.fftn" title="torch.fft.fftn"><code>fftn()</code></a> output contains redundant information. <a class="reference internal" href="#torch.fft.rfftn" title="torch.fft.rfftn"><code>rfftn()</code></a> instead omits the negative frequencies in the last dimension.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the input tensor</li> <li>
<strong>s</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em><em>, </em><em>optional</em>) – Signal size in the transformed dimensions. If given, each dimension <code>dim[i]</code> will either be zero-padded or trimmed to the length <code>s[i]</code> before computing the real FFT. If a length <code>-1</code> is specified, no padding is done in that dimension. Default: <code>s = [input.size(d) for d in dim]</code>
</li> <li>
<strong>dim</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em><em>, </em><em>optional</em>) – Dimensions to be transformed. Default: all dimensions, or the last <code>len(s)</code> dimensions if <code>s</code> is given.</li> <li>
<p><strong>norm</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><em>optional</em>) – </p>
<p>Normalization mode. For the forward transform (<a class="reference internal" href="#torch.fft.rfftn" title="torch.fft.rfftn"><code>rfftn()</code></a>), these correspond to:</p> <ul> <li>
<code>"forward"</code> - normalize by <code>1/n</code>
</li> <li>
<code>"backward"</code> - no normalization</li> <li>
<code>"ortho"</code> - normalize by <code>1/sqrt(n)</code> (making the real FFT orthonormal)</li> </ul> <p>Where <code>n = prod(s)</code> is the logical FFT size. Calling the backward transform (<a class="reference internal" href="#torch.fft.irfftn" title="torch.fft.irfftn"><code>irfftn()</code></a>) with the same normalization mode will apply an overall normalization of <code>1/n</code> between the two transforms. This is required to make <a class="reference internal" href="#torch.fft.irfftn" title="torch.fft.irfftn"><code>irfftn()</code></a> the exact inverse.</p> <p>Default is <code>"backward"</code> (no normalization).</p> </li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; t = torch.rand(10, 10)
&gt;&gt;&gt; rfftn = torch.fft.rfftn(t)
&gt;&gt;&gt; rfftn.size()
torch.Size([10, 6])
</pre> <p>Compared against the full output from <a class="reference internal" href="#torch.fft.fftn" title="torch.fft.fftn"><code>fftn()</code></a>, we have all elements up to the Nyquist frequency.</p> <pre data-language="python">&gt;&gt;&gt; fftn = torch.fft.fftn(t)
&gt;&gt;&gt; torch.allclose(fftn[..., :6], rfftn)
True
</pre> <p>The discrete Fourier transform is separable, so <a class="reference internal" href="#torch.fft.rfftn" title="torch.fft.rfftn"><code>rfftn()</code></a> here is equivalent to a combination of <a class="reference internal" href="#torch.fft.fft" title="torch.fft.fft"><code>fft()</code></a> and <a class="reference internal" href="#torch.fft.rfft" title="torch.fft.rfft"><code>rfft()</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; two_ffts = torch.fft.fft(torch.fft.rfft(x, dim=1), dim=0)
&gt;&gt;&gt; torch.allclose(rfftn, two_ffts)
</pre> </dd>
</dl> <dl class="function"> <dt id="torch.fft.irfftn">
<code>torch.fft.irfftn(input, s=None, dim=None, norm=None) → Tensor</code> </dt> <dd>
<p>Computes the inverse of <a class="reference internal" href="#torch.fft.rfftn" title="torch.fft.rfftn"><code>rfftn()</code></a>.</p> <p><code>input</code> is interpreted as a one-sided Hermitian signal in the Fourier domain, as produced by <a class="reference internal" href="#torch.fft.rfftn" title="torch.fft.rfftn"><code>rfftn()</code></a>. By the Hermitian property, the output will be real-valued.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Some input frequencies must be real-valued to satisfy the Hermitian property. In these cases the imaginary component will be ignored. For example, any imaginary component in the zero-frequency term cannot be represented in a real output and so will always be ignored.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The correct interpretation of the Hermitian input depends on the length of the original data, as given by <code>s</code>. This is because each input shape could correspond to either an odd or even length signal. By default, the signal is assumed to be even length and odd signals will not round-trip properly. So, it is recommended to always pass the signal shape <code>s</code>.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the input tensor</li> <li>
<strong>s</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em><em>, </em><em>optional</em>) – Signal size in the transformed dimensions. If given, each dimension <code>dim[i]</code> will either be zero-padded or trimmed to the length <code>s[i]</code> before computing the real FFT. If a length <code>-1</code> is specified, no padding is done in that dimension. Defaults to even output in the last dimension: <code>s[-1] = 2*(input.size(dim[-1]) - 1)</code>.</li> <li>
<strong>dim</strong> (<em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em><em>, </em><em>optional</em>) – Dimensions to be transformed. The last dimension must be the half-Hermitian compressed dimension. Default: all dimensions, or the last <code>len(s)</code> dimensions if <code>s</code> is given.</li> <li>
<p><strong>norm</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><em>optional</em>) – </p>
<p>Normalization mode. For the backward transform (<a class="reference internal" href="#torch.fft.irfftn" title="torch.fft.irfftn"><code>irfftn()</code></a>), these correspond to:</p> <ul> <li>
<code>"forward"</code> - no normalization</li> <li>
<code>"backward"</code> - normalize by <code>1/n</code>
</li> <li>
<code>"ortho"</code> - normalize by <code>1/sqrt(n)</code> (making the real IFFT orthonormal)</li> </ul> <p>Where <code>n = prod(s)</code> is the logical IFFT size. Calling the forward transform (<a class="reference internal" href="#torch.fft.rfftn" title="torch.fft.rfftn"><code>rfftn()</code></a>) with the same normalization mode will apply an overall normalization of <code>1/n</code> between the two transforms. This is required to make <a class="reference internal" href="#torch.fft.irfftn" title="torch.fft.irfftn"><code>irfftn()</code></a> the exact inverse.</p> <p>Default is <code>"backward"</code> (normalize by <code>1/n</code>).</p> </li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; t = torch.rand(10, 9)
&gt;&gt;&gt; T = torch.fft.rfftn(t)
</pre> <p>Without specifying the output length to <a class="reference internal" href="#torch.fft.irfft" title="torch.fft.irfft"><code>irfft()</code></a>, the output will not round-trip properly because the input is odd-length in the last dimension:</p> <pre data-language="python">&gt;&gt;&gt; torch.fft.irfftn(T).size()
torch.Size([10, 10])
</pre> <p>So, it is recommended to always pass the signal shape <code>s</code>.</p> <pre data-language="python">&gt;&gt;&gt; roundtrip = torch.fft.irfftn(T, t.size())
&gt;&gt;&gt; roundtrip.size()
torch.Size([10, 9])
&gt;&gt;&gt; torch.allclose(roundtrip, t)
True
</pre> </dd>
</dl> <dl class="function"> <dt id="torch.fft.hfft">
<code>torch.fft.hfft(input, n=None, dim=-1, norm=None) → Tensor</code> </dt> <dd>
<p>Computes the one dimensional discrete Fourier transform of a Hermitian symmetric <code>input</code> signal.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><a class="reference internal" href="#torch.fft.hfft" title="torch.fft.hfft"><code>hfft()</code></a>/<a class="reference internal" href="#torch.fft.ihfft" title="torch.fft.ihfft"><code>ihfft()</code></a> are analogous to <a class="reference internal" href="#torch.fft.rfft" title="torch.fft.rfft"><code>rfft()</code></a>/<a class="reference internal" href="#torch.fft.irfft" title="torch.fft.irfft"><code>irfft()</code></a>. The real FFT expects a real signal in the time-domain and gives a Hermitian symmetry in the frequency-domain. The Hermitian FFT is the opposite; Hermitian symmetric in the time-domain and real-valued in the frequency-domain. For this reason, special care needs to be taken with the length argument <code>n</code>, in the same way as with <a class="reference internal" href="#torch.fft.irfft" title="torch.fft.irfft"><code>irfft()</code></a>.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Because the signal is Hermitian in the time-domain, the result will be real in the frequency domain. Note that some input frequencies must be real-valued to satisfy the Hermitian property. In these cases the imaginary component will be ignored. For example, any imaginary component in <code>input[0]</code> would result in one or more complex frequency terms which cannot be represented in a real output and so will always be ignored.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The correct interpretation of the Hermitian input depends on the length of the original data, as given by <code>n</code>. This is because each input shape could correspond to either an odd or even length signal. By default, the signal is assumed to be even length and odd signals will not round-trip properly. So, it is recommended to always pass the signal length <code>n</code>.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the input tensor representing a half-Hermitian signal</li> <li>
<strong>n</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><em>optional</em>) – Output signal length. This determines the length of the real output. If given, the input will either be zero-padded or trimmed to this length before computing the Hermitian FFT. Defaults to even output: <code>n=2*(input.size(dim) - 1)</code>.</li> <li>
<strong>dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><em>optional</em>) – The dimension along which to take the one dimensional Hermitian FFT.</li> <li>
<p><strong>norm</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><em>optional</em>) – </p>
<p>Normalization mode. For the forward transform (<a class="reference internal" href="#torch.fft.hfft" title="torch.fft.hfft"><code>hfft()</code></a>), these correspond to:</p> <ul> <li>
<code>"forward"</code> - normalize by <code>1/n</code>
</li> <li>
<code>"backward"</code> - no normalization</li> <li>
<code>"ortho"</code> - normalize by <code>1/sqrt(n)</code> (making the Hermitian FFT orthonormal)</li> </ul> <p>Calling the backward transform (<a class="reference internal" href="#torch.fft.ihfft" title="torch.fft.ihfft"><code>ihfft()</code></a>) with the same normalization mode will apply an overall normalization of <code>1/n</code> between the two transforms. This is required to make <a class="reference internal" href="#torch.fft.ihfft" title="torch.fft.ihfft"><code>ihfft()</code></a> the exact inverse.</p> <p>Default is <code>"backward"</code> (no normalization).</p> </li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <p>Taking a real-valued frequency signal and bringing it into the time domain gives Hermitian symmetric output:</p> <pre data-language="python">&gt;&gt;&gt; t = torch.arange(5)
&gt;&gt;&gt; t
tensor([0, 1, 2, 3, 4])
&gt;&gt;&gt; T = torch.fft.ifft(t)
&gt;&gt;&gt; T
tensor([ 2.0000+-0.0000j, -0.5000-0.6882j, -0.5000-0.1625j, -0.5000+0.1625j,
        -0.5000+0.6882j])
</pre> <p>Note that <code>T[1] == T[-1].conj()</code> and <code>T[2] == T[-2].conj()</code> is redundant. We can thus compute the forward transform without considering negative frequencies:</p> <pre data-language="python">&gt;&gt;&gt; torch.fft.hfft(T[:3], n=5)
tensor([0., 1., 2., 3., 4.])
</pre> <p>Like with <a class="reference internal" href="#torch.fft.irfft" title="torch.fft.irfft"><code>irfft()</code></a>, the output length must be given in order to recover an even length output:</p> <pre data-language="python">&gt;&gt;&gt; torch.fft.hfft(T[:3])
tensor([0.5000, 1.1236, 2.5000, 3.8764])
</pre> </dd>
</dl> <dl class="function"> <dt id="torch.fft.ihfft">
<code>torch.fft.ihfft(input, n=None, dim=-1, norm=None) → Tensor</code> </dt> <dd>
<p>Computes the inverse of <a class="reference internal" href="#torch.fft.hfft" title="torch.fft.hfft"><code>hfft()</code></a>.</p> <p><code>input</code> must be a real-valued signal, interpreted in the Fourier domain. The IFFT of a real signal is Hermitian-symmetric, <code>X[i] = conj(X[-i])</code>. <a class="reference internal" href="#torch.fft.ihfft" title="torch.fft.ihfft"><code>ihfft()</code></a> represents this in the one-sided form where only the positive frequencies below the Nyquist frequency are included. To compute the full output, use <a class="reference internal" href="#torch.fft.ifft" title="torch.fft.ifft"><code>ifft()</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the real input tensor</li> <li>
<strong>n</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><em>optional</em>) – Signal length. If given, the input will either be zero-padded or trimmed to this length before computing the Hermitian IFFT.</li> <li>
<strong>dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><em>optional</em>) – The dimension along which to take the one dimensional Hermitian IFFT.</li> <li>
<p><strong>norm</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><em>optional</em>) – </p>
<p>Normalization mode. For the backward transform (<a class="reference internal" href="#torch.fft.ihfft" title="torch.fft.ihfft"><code>ihfft()</code></a>), these correspond to:</p> <ul> <li>
<code>"forward"</code> - no normalization</li> <li>
<code>"backward"</code> - normalize by <code>1/n</code>
</li> <li>
<code>"ortho"</code> - normalize by <code>1/sqrt(n)</code> (making the IFFT orthonormal)</li> </ul> <p>Calling the forward transform (<a class="reference internal" href="#torch.fft.hfft" title="torch.fft.hfft"><code>hfft()</code></a>) with the same normalization mode will apply an overall normalization of <code>1/n</code> between the two transforms. This is required to make <a class="reference internal" href="#torch.fft.ihfft" title="torch.fft.ihfft"><code>ihfft()</code></a> the exact inverse.</p> <p>Default is <code>"backward"</code> (normalize by <code>1/n</code>).</p> </li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; t = torch.arange(5)
&gt;&gt;&gt; t
tensor([0, 1, 2, 3, 4])
&gt;&gt;&gt; torch.fft.ihfft(t)
tensor([ 2.0000+-0.0000j, -0.5000-0.6882j, -0.5000-0.1625j])
</pre> <p>Compare against the full output from <a class="reference internal" href="#torch.fft.ifft" title="torch.fft.ifft"><code>ifft()</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; torch.fft.ifft(t)
tensor([ 2.0000+-0.0000j, -0.5000-0.6882j, -0.5000-0.1625j, -0.5000+0.1625j,
    -0.5000+0.6882j])
</pre> </dd>
</dl>   <h2 id="helper-functions">Helper Functions</h2> <dl class="function"> <dt id="torch.fft.fftfreq">
<code>torch.fft.fftfreq(n, d=1.0, *, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor</code> </dt> <dd>
<p>Computes the discrete Fourier Transform sample frequencies for a signal of size <code>n</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>By convention, <a class="reference internal" href="#torch.fft.fft" title="torch.fft.fft"><code>fft()</code></a> returns positive frequency terms first, followed by the negative frequencies in reverse order, so that <code>f[-i]</code> for all <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">0 &lt; i \leq n/2</annotation></semantics></math></span></span> </span> in Python gives the negative frequency terms. For an FFT of length <code>n</code> and with inputs spaced in length unit <code>d</code>, the frequencies are:</p> <pre data-language="python">f = [0, 1, ..., (n - 1) // 2, -(n // 2), ..., -1] / (d * n)
</pre> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For even lengths, the Nyquist frequency at <code>f[n/2]</code> can be thought of as either negative or positive. <a class="reference internal" href="#torch.fft.fftfreq" title="torch.fft.fftfreq"><code>fftfreq()</code></a> follows NumPy’s convention of taking it to be negative.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>n</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – the FFT length</li> <li>
<strong>d</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – The sampling length scale. The spacing between individual samples of the FFT input. The default assumes unit spacing, dividing that result by the actual spacing gives the result in physical frequency units.</li> </ul> </dd> <dt class="field-even">Keyword Arguments</dt> <dd class="field-even">
<ul class="simple"> <li>
<strong>dtype</strong> (<code>torch.dtype</code>, optional) – the desired data type of returned tensor. Default: if <code>None</code>, uses a global default (see <a class="reference internal" href="generated/torch.set_default_tensor_type#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>).</li> <li>
<strong>layout</strong> (<code>torch.layout</code>, optional) – the desired layout of returned Tensor. Default: <code>torch.strided</code>.</li> <li>
<strong>device</strong> (<code>torch.device</code>, optional) – the desired device of returned tensor. Default: if <code>None</code>, uses the current device for the default tensor type (see <a class="reference internal" href="generated/torch.set_default_tensor_type#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li> <li>
<strong>requires_grad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; torch.fft.fftfreq(5)
tensor([ 0.0000,  0.2000,  0.4000, -0.4000, -0.2000])
</pre> <p>For even input, we can see the Nyquist frequency at <code>f[2]</code> is given as negative:</p> <pre data-language="python">&gt;&gt;&gt; torch.fft.fftfreq(4)
tensor([ 0.0000,  0.2500, -0.5000, -0.2500])
</pre> </dd>
</dl> <dl class="function"> <dt id="torch.fft.rfftfreq">
<code>torch.fft.rfftfreq(n, d=1.0, *, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor</code> </dt> <dd>
<p>Computes the sample frequencies for <a class="reference internal" href="#torch.fft.rfft" title="torch.fft.rfft"><code>rfft()</code></a> with a signal of size <code>n</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><a class="reference internal" href="#torch.fft.rfft" title="torch.fft.rfft"><code>rfft()</code></a> returns Hermitian one-sided output, so only the positive frequency terms are returned. For a real FFT of length <code>n</code> and with inputs spaced in length unit <code>d</code>, the frequencies are:</p> <pre data-language="python">f = torch.arange((n + 1) // 2) / (d * n)
</pre> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For even lengths, the Nyquist frequency at <code>f[n/2]</code> can be thought of as either negative or positive. Unlike <a class="reference internal" href="#torch.fft.fftfreq" title="torch.fft.fftfreq"><code>fftfreq()</code></a>, <a class="reference internal" href="#torch.fft.rfftfreq" title="torch.fft.rfftfreq"><code>rfftfreq()</code></a> always returns it as positive.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>n</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – the real FFT length</li> <li>
<strong>d</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>, </em><em>optional</em>) – The sampling length scale. The spacing between individual samples of the FFT input. The default assumes unit spacing, dividing that result by the actual spacing gives the result in physical frequency units.</li> </ul> </dd> <dt class="field-even">Keyword Arguments</dt> <dd class="field-even">
<ul class="simple"> <li>
<strong>dtype</strong> (<code>torch.dtype</code>, optional) – the desired data type of returned tensor. Default: if <code>None</code>, uses a global default (see <a class="reference internal" href="generated/torch.set_default_tensor_type#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>).</li> <li>
<strong>layout</strong> (<code>torch.layout</code>, optional) – the desired layout of returned Tensor. Default: <code>torch.strided</code>.</li> <li>
<strong>device</strong> (<code>torch.device</code>, optional) – the desired device of returned tensor. Default: if <code>None</code>, uses the current device for the default tensor type (see <a class="reference internal" href="generated/torch.set_default_tensor_type#torch.set_default_tensor_type" title="torch.set_default_tensor_type"><code>torch.set_default_tensor_type()</code></a>). <code>device</code> will be the CPU for CPU tensor types and the current CUDA device for CUDA tensor types.</li> <li>
<strong>requires_grad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; torch.fft.rfftfreq(5)
tensor([ 0.0000,  0.2000,  0.4000])
</pre> <pre data-language="python">&gt;&gt;&gt; torch.fft.rfftfreq(4)
tensor([ 0.0000,  0.2500, 0.5000])
</pre> <p>Compared to the output from <a class="reference internal" href="#torch.fft.fftfreq" title="torch.fft.fftfreq"><code>fftfreq()</code></a>, we see that the Nyquist frequency at <code>f[2]</code> has changed sign: &gt;&gt;&gt; torch.fft.fftfreq(4) tensor([ 0.0000, 0.2500, -0.5000, -0.2500])</p> </dd>
</dl> <dl class="function"> <dt id="torch.fft.fftshift">
<code>torch.fft.fftshift(input, dim=None) → Tensor</code> </dt> <dd>
<p>Reorders n-dimensional FFT data, as provided by <a class="reference internal" href="#torch.fft.fftn" title="torch.fft.fftn"><code>fftn()</code></a>, to have negative frequency terms first.</p> <p>This performs a periodic shift of n-dimensional data such that the origin <code>(0, ..., 0)</code> is moved to the center of the tensor. Specifically, to <code>input.shape[dim] // 2</code> in each selected dimension.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>By convention, the FFT returns positive frequency terms first, followed by the negative frequencies in reverse order, so that <code>f[-i]</code> for all <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">0 &lt; i \leq n/2</annotation></semantics></math></span></span> </span> in Python gives the negative frequency terms. <a class="reference internal" href="#torch.fft.fftshift" title="torch.fft.fftshift"><code>fftshift()</code></a> rearranges all frequencies into ascending order from negative to positive with the zero-frequency term in the center.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For even lengths, the Nyquist frequency at <code>f[n/2]</code> can be thought of as either negative or positive. <a class="reference internal" href="#torch.fft.fftshift" title="torch.fft.fftshift"><code>fftshift()</code></a> always puts the Nyquist term at the 0-index. This is the same convention used by <a class="reference internal" href="#torch.fft.fftfreq" title="torch.fft.fftfreq"><code>fftfreq()</code></a>.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the tensor in FFT order</li> <li>
<strong>dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em><em>, </em><em>optional</em>) – The dimensions to rearrange. Only dimensions specified here will be rearranged, any other dimensions will be left in their original order. Default: All dimensions of <code>input</code>.</li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; f = torch.fft.fftfreq(4)
&gt;&gt;&gt; f
tensor([ 0.0000,  0.2500, -0.5000, -0.2500])
</pre> <pre data-language="python">&gt;&gt;&gt; torch.fft.fftshift(f)
tensor([-0.5000, -0.2500,  0.0000,  0.2500])
</pre> <p>Also notice that the Nyquist frequency term at <code>f[2]</code> was moved to the beginning of the tensor.</p> <p>This also works for multi-dimensional transforms:</p> <pre data-language="python">&gt;&gt;&gt; x = torch.fft.fftfreq(5, d=1/5) + 0.1 * torch.fft.fftfreq(5, d=1/5).unsqueeze(1)
&gt;&gt;&gt; x
tensor([[ 0.0000,  1.0000,  2.0000, -2.0000, -1.0000],
        [ 0.1000,  1.1000,  2.1000, -1.9000, -0.9000],
        [ 0.2000,  1.2000,  2.2000, -1.8000, -0.8000],
        [-0.2000,  0.8000,  1.8000, -2.2000, -1.2000],
        [-0.1000,  0.9000,  1.9000, -2.1000, -1.1000]])
</pre> <pre data-language="python">&gt;&gt;&gt; torch.fft.fftshift(x)
tensor([[-2.2000, -1.2000, -0.2000,  0.8000,  1.8000],
        [-2.1000, -1.1000, -0.1000,  0.9000,  1.9000],
        [-2.0000, -1.0000,  0.0000,  1.0000,  2.0000],
        [-1.9000, -0.9000,  0.1000,  1.1000,  2.1000],
        [-1.8000, -0.8000,  0.2000,  1.2000,  2.2000]])
</pre> <p><a class="reference internal" href="#torch.fft.fftshift" title="torch.fft.fftshift"><code>fftshift()</code></a> can also be useful for spatial data. If our data is defined on a centered grid (<code>[-(N//2), (N-1)//2]</code>) then we can use the standard FFT defined on an uncentered grid (<code>[0, N)</code>) by first applying an <a class="reference internal" href="#torch.fft.ifftshift" title="torch.fft.ifftshift"><code>ifftshift()</code></a>.</p> <pre data-language="python">&gt;&gt;&gt; x_centered = torch.arange(-5, 5)
&gt;&gt;&gt; x_uncentered = torch.fft.ifftshift(x_centered)
&gt;&gt;&gt; fft_uncentered = torch.fft.fft(x_uncentered)
</pre> <p>Similarly, we can convert the frequency domain components to centered convention by applying <a class="reference internal" href="#torch.fft.fftshift" title="torch.fft.fftshift"><code>fftshift()</code></a>.</p> <pre data-language="python">&gt;&gt;&gt; fft_centered = torch.fft.fftshift(fft_uncentered)
</pre> <p>The inverse transform, from centered Fourier space back to centered spatial data, can be performed by applying the inverse shifts in reverse order:</p> <pre data-language="python">&gt;&gt;&gt; x_centered_2 = torch.fft.fftshift(torch.fft.ifft(torch.fft.ifftshift(fft_centered)))
&gt;&gt;&gt; torch.allclose(x_centered.to(torch.complex64), x_centered_2)
True
</pre> </dd>
</dl> <dl class="function"> <dt id="torch.fft.ifftshift">
<code>torch.fft.ifftshift(input, dim=None) → Tensor</code> </dt> <dd>
<p>Inverse of <a class="reference internal" href="#torch.fft.fftshift" title="torch.fft.fftshift"><code>fftshift()</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the tensor in FFT order</li> <li>
<strong>dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em><em>, </em><em>optional</em>) – The dimensions to rearrange. Only dimensions specified here will be rearranged, any other dimensions will be left in their original order. Default: All dimensions of <code>input</code>.</li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; f = torch.fft.fftfreq(5)
&gt;&gt;&gt; f
tensor([ 0.0000,  0.2000,  0.4000, -0.4000, -0.2000])
</pre> <p>A round-trip through <a class="reference internal" href="#torch.fft.fftshift" title="torch.fft.fftshift"><code>fftshift()</code></a> and <a class="reference internal" href="#torch.fft.ifftshift" title="torch.fft.ifftshift"><code>ifftshift()</code></a> gives the same result:</p> <pre data-language="python">&gt;&gt;&gt; shifted = torch.fftshift(f)
&gt;&gt;&gt; torch.ifftshift(shifted)
tensor([ 0.0000,  0.2000,  0.4000, -0.4000, -0.2000])
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://pytorch.org/docs/1.8.0/fft.html" class="_attribution-link" target="_blank">https://pytorch.org/docs/1.8.0/fft.html</a>
  </p>
</div>
