<h1 id="tensor-doc">torch.Tensor</h1> <p id="torch-tensor">A <a class="reference internal" href="#torch.Tensor" title="torch.Tensor"><code>torch.Tensor</code></a> is a multi-dimensional matrix containing elements of a single data type.</p> <p>Torch defines 10 tensor types with CPU and GPU variants which are as follows:</p> <table class="docutils colwidths-auto align-default"> <thead> <tr>
<th class="head"><p>Data type</p></th> <th class="head"><p>dtype</p></th> <th class="head"><p>CPU tensor</p></th> <th class="head"><p>GPU tensor</p></th> </tr> </thead>  <tr>
<td><p>32-bit floating point</p></td> <td><p><code>torch.float32</code> or <code>torch.float</code></p></td> <td><p><code>torch.FloatTensor</code></p></td> <td><p><code>torch.cuda.FloatTensor</code></p></td> </tr> <tr>
<td><p>64-bit floating point</p></td> <td><p><code>torch.float64</code> or <code>torch.double</code></p></td> <td><p><code>torch.DoubleTensor</code></p></td> <td><p><code>torch.cuda.DoubleTensor</code></p></td> </tr> <tr>
<td><p>16-bit floating point <a class="footnote-reference brackets" href="#id3" id="id1">1</a></p></td> <td><p><code>torch.float16</code> or <code>torch.half</code></p></td> <td><p><code>torch.HalfTensor</code></p></td> <td><p><code>torch.cuda.HalfTensor</code></p></td> </tr> <tr>
<td><p>16-bit floating point <a class="footnote-reference brackets" href="#id4" id="id2">2</a></p></td> <td><p><code>torch.bfloat16</code></p></td> <td><p><code>torch.BFloat16Tensor</code></p></td> <td><p><code>torch.cuda.BFloat16Tensor</code></p></td> </tr> <tr>
<td><p>32-bit complex</p></td> <td><p><code>torch.complex32</code></p></td> <td></td> <td></td> </tr> <tr>
<td><p>64-bit complex</p></td> <td><p><code>torch.complex64</code></p></td> <td></td> <td></td> </tr> <tr>
<td><p>128-bit complex</p></td> <td><p><code>torch.complex128</code> or <code>torch.cdouble</code></p></td> <td></td> <td></td> </tr> <tr>
<td><p>8-bit integer (unsigned)</p></td> <td><p><code>torch.uint8</code></p></td> <td><p><code>torch.ByteTensor</code></p></td> <td><p><code>torch.cuda.ByteTensor</code></p></td> </tr> <tr>
<td><p>8-bit integer (signed)</p></td> <td><p><code>torch.int8</code></p></td> <td><p><code>torch.CharTensor</code></p></td> <td><p><code>torch.cuda.CharTensor</code></p></td> </tr> <tr>
<td><p>16-bit integer (signed)</p></td> <td><p><code>torch.int16</code> or <code>torch.short</code></p></td> <td><p><code>torch.ShortTensor</code></p></td> <td><p><code>torch.cuda.ShortTensor</code></p></td> </tr> <tr>
<td><p>32-bit integer (signed)</p></td> <td><p><code>torch.int32</code> or <code>torch.int</code></p></td> <td><p><code>torch.IntTensor</code></p></td> <td><p><code>torch.cuda.IntTensor</code></p></td> </tr> <tr>
<td><p>64-bit integer (signed)</p></td> <td><p><code>torch.int64</code> or <code>torch.long</code></p></td> <td><p><code>torch.LongTensor</code></p></td> <td><p><code>torch.cuda.LongTensor</code></p></td> </tr> <tr>
<td><p>Boolean</p></td> <td><p><code>torch.bool</code></p></td> <td><p><code>torch.BoolTensor</code></p></td> <td><p><code>torch.cuda.BoolTensor</code></p></td> </tr>  </table> <dl class="footnote brackets"> <dt class="label" id="id3">
<code>1</code> </dt> <dd>
<p>Sometimes referred to as binary16: uses 1 sign, 5 exponent, and 10 significand bits. Useful when precision is important at the expense of range.</p> </dd> <dt class="label" id="id4">
<code>2</code> </dt> <dd>
<p>Sometimes referred to as Brain Floating Point: uses 1 sign, 8 exponent, and 7 significand bits. Useful when range is important, since it has the same number of exponent bits as <code>float32</code></p> </dd> </dl> <p><a class="reference internal" href="#torch.Tensor" title="torch.Tensor"><code>torch.Tensor</code></a> is an alias for the default tensor type (<code>torch.FloatTensor</code>).</p> <p>A tensor can be constructed from a Python <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)"><code>list</code></a> or sequence using the <a class="reference internal" href="generated/torch.tensor#torch.tensor" title="torch.tensor"><code>torch.tensor()</code></a> constructor:</p> <pre data-language="python">&gt;&gt;&gt; torch.tensor([[1., -1.], [1., -1.]])
tensor([[ 1.0000, -1.0000],
        [ 1.0000, -1.0000]])
&gt;&gt;&gt; torch.tensor(np.array([[1, 2, 3], [4, 5, 6]]))
tensor([[ 1,  2,  3],
        [ 4,  5,  6]])
</pre> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><a class="reference internal" href="generated/torch.tensor#torch.tensor" title="torch.tensor"><code>torch.tensor()</code></a> always copies <code>data</code>. If you have a Tensor <code>data</code> and just want to change its <code>requires_grad</code> flag, use <a class="reference internal" href="#torch.Tensor.requires_grad_" title="torch.Tensor.requires_grad_"><code>requires_grad_()</code></a> or <a class="reference internal" href="autograd#torch.Tensor.detach" title="torch.Tensor.detach"><code>detach()</code></a> to avoid a copy. If you have a numpy array and want to avoid a copy, use <a class="reference internal" href="generated/torch.as_tensor#torch.as_tensor" title="torch.as_tensor"><code>torch.as_tensor()</code></a>.</p> </div> <p>A tensor of specific data type can be constructed by passing a <a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a> and/or a <a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a> to a constructor or tensor creation op:</p> <pre data-language="python">&gt;&gt;&gt; torch.zeros([2, 4], dtype=torch.int32)
tensor([[ 0,  0,  0,  0],
        [ 0,  0,  0,  0]], dtype=torch.int32)
&gt;&gt;&gt; cuda0 = torch.device('cuda:0')
&gt;&gt;&gt; torch.ones([2, 4], dtype=torch.float64, device=cuda0)
tensor([[ 1.0000,  1.0000,  1.0000,  1.0000],
        [ 1.0000,  1.0000,  1.0000,  1.0000]], dtype=torch.float64, device='cuda:0')
</pre> <p>The contents of a tensor can be accessed and modified using Python’s indexing and slicing notation:</p> <pre data-language="python">&gt;&gt;&gt; x = torch.tensor([[1, 2, 3], [4, 5, 6]])
&gt;&gt;&gt; print(x[1][2])
tensor(6)
&gt;&gt;&gt; x[0][1] = 8
&gt;&gt;&gt; print(x)
tensor([[ 1,  8,  3],
        [ 4,  5,  6]])
</pre> <p>Use <a class="reference internal" href="#torch.Tensor.item" title="torch.Tensor.item"><code>torch.Tensor.item()</code></a> to get a Python number from a tensor containing a single value:</p> <pre data-language="python">&gt;&gt;&gt; x = torch.tensor([[1]])
&gt;&gt;&gt; x
tensor([[ 1]])
&gt;&gt;&gt; x.item()
1
&gt;&gt;&gt; x = torch.tensor(2.5)
&gt;&gt;&gt; x
tensor(2.5000)
&gt;&gt;&gt; x.item()
2.5
</pre> <p>A tensor can be created with <code>requires_grad=True</code> so that <a class="reference internal" href="autograd#module-torch.autograd" title="torch.autograd"><code>torch.autograd</code></a> records operations on them for automatic differentiation.</p> <pre data-language="python">&gt;&gt;&gt; x = torch.tensor([[1., -1.], [1., 1.]], requires_grad=True)
&gt;&gt;&gt; out = x.pow(2).sum()
&gt;&gt;&gt; out.backward()
&gt;&gt;&gt; x.grad
tensor([[ 2.0000, -2.0000],
        [ 2.0000,  2.0000]])
</pre> <p>Each tensor has an associated <code>torch.Storage</code>, which holds its data. The tensor class also provides multi-dimensional, <a class="reference external" href="https://en.wikipedia.org/wiki/Stride_of_an_array">strided</a> view of a storage and defines numeric operations on it.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For more information on tensor views, see <a class="reference internal" href="tensor_view#tensor-view-doc"><span class="std std-ref">Tensor Views</span></a>.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For more information on the <a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, <a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, and <a class="reference internal" href="tensor_attributes#torch.torch.layout" title="torch.torch.layout"><code>torch.layout</code></a> attributes of a <a class="reference internal" href="#torch.Tensor" title="torch.Tensor"><code>torch.Tensor</code></a>, see <a class="reference internal" href="tensor_attributes#tensor-attributes-doc"><span class="std std-ref">Tensor Attributes</span></a>.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Methods which mutate a tensor are marked with an underscore suffix. For example, <code>torch.FloatTensor.abs_()</code> computes the absolute value in-place and returns the modified tensor, while <code>torch.FloatTensor.abs()</code> computes the result in a new tensor.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>To change an existing tensor’s <a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a> and/or <a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, consider using <a class="reference internal" href="#torch.Tensor.to" title="torch.Tensor.to"><code>to()</code></a> method on the tensor.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Current implementation of <a class="reference internal" href="#torch.Tensor" title="torch.Tensor"><code>torch.Tensor</code></a> introduces memory overhead, thus it might lead to unexpectedly high memory usage in the applications with many tiny tensors. If this is your case, consider using one large structure.</p> </div> <dl class="class"> <dt id="torch.Tensor">
<code>class torch.Tensor</code> </dt> <dd>
<p>There are a few main ways to create a tensor, depending on your use case.</p> <ul class="simple"> <li>To create a tensor with pre-existing data, use <a class="reference internal" href="generated/torch.tensor#torch.tensor" title="torch.tensor"><code>torch.tensor()</code></a>.</li> <li>To create a tensor with specific size, use <code>torch.*</code> tensor creation ops (see <a class="reference internal" href="torch#tensor-creation-ops"><span class="std std-ref">Creation Ops</span></a>).</li> <li>To create a tensor with the same size (and similar types) as another tensor, use <code>torch.*_like</code> tensor creation ops (see <a class="reference internal" href="torch#tensor-creation-ops"><span class="std std-ref">Creation Ops</span></a>).</li> <li>To create a tensor with similar type but different size as another tensor, use <code>tensor.new_*</code> creation ops.</li> </ul> <dl class="method"> <dt id="torch.Tensor.new_tensor">
<code>new_tensor(data, dtype=None, device=None, requires_grad=False) → Tensor</code> </dt> <dd>
<p>Returns a new Tensor with <code>data</code> as the tensor data. By default, the returned Tensor has the same <a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a> and <a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a> as this tensor.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><a class="reference internal" href="#torch.Tensor.new_tensor" title="torch.Tensor.new_tensor"><code>new_tensor()</code></a> always copies <code>data</code>. If you have a Tensor <code>data</code> and want to avoid a copy, use <a class="reference internal" href="#torch.Tensor.requires_grad_" title="torch.Tensor.requires_grad_"><code>torch.Tensor.requires_grad_()</code></a> or <a class="reference internal" href="autograd#torch.Tensor.detach" title="torch.Tensor.detach"><code>torch.Tensor.detach()</code></a>. If you have a numpy array and want to avoid a copy, use <a class="reference internal" href="generated/torch.from_numpy#torch.from_numpy" title="torch.from_numpy"><code>torch.from_numpy()</code></a>.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>When data is a tensor <code>x</code>, <a class="reference internal" href="#torch.Tensor.new_tensor" title="torch.Tensor.new_tensor"><code>new_tensor()</code></a> reads out ‘the data’ from whatever it is passed, and constructs a leaf variable. Therefore <code>tensor.new_tensor(x)</code> is equivalent to <code>x.clone().detach()</code> and <code>tensor.new_tensor(x, requires_grad=True)</code> is equivalent to <code>x.clone().detach().requires_grad_(True)</code>. The equivalents using <code>clone()</code> and <code>detach()</code> are recommended.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>data</strong> (<em>array_like</em>) – The returned Tensor copies <code>data</code>.</li> <li>
<strong>dtype</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired type of returned tensor. Default: if None, same <a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a> as this tensor.</li> <li>
<strong>device</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if None, same <a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a> as this tensor.</li> <li>
<strong>requires_grad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li> </ul> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; tensor = torch.ones((2,), dtype=torch.int8)
&gt;&gt;&gt; data = [[0, 1], [2, 3]]
&gt;&gt;&gt; tensor.new_tensor(data)
tensor([[ 0,  1],
        [ 2,  3]], dtype=torch.int8)
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.new_full">
<code>new_full(size, fill_value, dtype=None, device=None, requires_grad=False) → Tensor</code> </dt> <dd>
<p>Returns a Tensor of size <a class="reference internal" href="#torch.Tensor.size" title="torch.Tensor.size"><code>size</code></a> filled with <code>fill_value</code>. By default, the returned Tensor has the same <a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a> and <a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a> as this tensor.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>fill_value</strong> (<em>scalar</em>) – the number to fill the output tensor with.</li> <li>
<strong>dtype</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired type of returned tensor. Default: if None, same <a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a> as this tensor.</li> <li>
<strong>device</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if None, same <a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a> as this tensor.</li> <li>
<strong>requires_grad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li> </ul> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; tensor = torch.ones((2,), dtype=torch.float64)
&gt;&gt;&gt; tensor.new_full((3, 4), 3.141592)
tensor([[ 3.1416,  3.1416,  3.1416,  3.1416],
        [ 3.1416,  3.1416,  3.1416,  3.1416],
        [ 3.1416,  3.1416,  3.1416,  3.1416]], dtype=torch.float64)
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.new_empty">
<code>new_empty(size, dtype=None, device=None, requires_grad=False) → Tensor</code> </dt> <dd>
<p>Returns a Tensor of size <a class="reference internal" href="#torch.Tensor.size" title="torch.Tensor.size"><code>size</code></a> filled with uninitialized data. By default, the returned Tensor has the same <a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a> and <a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a> as this tensor.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>dtype</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired type of returned tensor. Default: if None, same <a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a> as this tensor.</li> <li>
<strong>device</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if None, same <a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a> as this tensor.</li> <li>
<strong>requires_grad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li> </ul> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; tensor = torch.ones(())
&gt;&gt;&gt; tensor.new_empty((2, 3))
tensor([[ 5.8182e-18,  4.5765e-41, -1.0545e+30],
        [ 3.0949e-41,  4.4842e-44,  0.0000e+00]])
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.new_ones">
<code>new_ones(size, dtype=None, device=None, requires_grad=False) → Tensor</code> </dt> <dd>
<p>Returns a Tensor of size <a class="reference internal" href="#torch.Tensor.size" title="torch.Tensor.size"><code>size</code></a> filled with <code>1</code>. By default, the returned Tensor has the same <a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a> and <a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a> as this tensor.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>size</strong> (<em>int...</em>) – a list, tuple, or <code>torch.Size</code> of integers defining the shape of the output tensor.</li> <li>
<strong>dtype</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired type of returned tensor. Default: if None, same <a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a> as this tensor.</li> <li>
<strong>device</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if None, same <a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a> as this tensor.</li> <li>
<strong>requires_grad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li> </ul> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; tensor = torch.tensor((), dtype=torch.int32)
&gt;&gt;&gt; tensor.new_ones((2, 3))
tensor([[ 1,  1,  1],
        [ 1,  1,  1]], dtype=torch.int32)
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.new_zeros">
<code>new_zeros(size, dtype=None, device=None, requires_grad=False) → Tensor</code> </dt> <dd>
<p>Returns a Tensor of size <a class="reference internal" href="#torch.Tensor.size" title="torch.Tensor.size"><code>size</code></a> filled with <code>0</code>. By default, the returned Tensor has the same <a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a> and <a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a> as this tensor.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>size</strong> (<em>int...</em>) – a list, tuple, or <code>torch.Size</code> of integers defining the shape of the output tensor.</li> <li>
<strong>dtype</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>, optional) – the desired type of returned tensor. Default: if None, same <a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a> as this tensor.</li> <li>
<strong>device</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, optional) – the desired device of returned tensor. Default: if None, same <a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a> as this tensor.</li> <li>
<strong>requires_grad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If autograd should record operations on the returned tensor. Default: <code>False</code>.</li> </ul> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; tensor = torch.tensor((), dtype=torch.float64)
&gt;&gt;&gt; tensor.new_zeros((2, 3))
tensor([[ 0.,  0.,  0.],
        [ 0.,  0.,  0.]], dtype=torch.float64)
</pre> </dd>
</dl> <dl class="attribute"> <dt id="torch.Tensor.is_cuda">
<code>is_cuda</code> </dt> <dd>
<p>Is <code>True</code> if the Tensor is stored on the GPU, <code>False</code> otherwise.</p> </dd>
</dl> <dl class="attribute"> <dt id="torch.Tensor.is_quantized">
<code>is_quantized</code> </dt> <dd>
<p>Is <code>True</code> if the Tensor is quantized, <code>False</code> otherwise.</p> </dd>
</dl> <dl class="attribute"> <dt id="torch.Tensor.is_meta">
<code>is_meta</code> </dt> <dd>
<p>Is <code>True</code> if the Tensor is a meta tensor, <code>False</code> otherwise. Meta tensors are like normal tensors, but they carry no data.</p> </dd>
</dl> <dl class="attribute"> <dt id="torch.Tensor.device">
<code>device</code> </dt> <dd>
<p>Is the <a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a> where this Tensor is.</p> </dd>
</dl> <dl class="attribute"> <dt>
<code>grad</code> </dt> <dd>
<p>This attribute is <code>None</code> by default and becomes a Tensor the first time a call to <a class="reference internal" href="autograd#torch.Tensor.backward" title="torch.Tensor.backward"><code>backward()</code></a> computes gradients for <code>self</code>. The attribute will then contain the gradients computed and future calls to <a class="reference internal" href="autograd#torch.Tensor.backward" title="torch.Tensor.backward"><code>backward()</code></a> will accumulate (add) gradients into it.</p> </dd>
</dl> <dl class="attribute"> <dt id="torch.Tensor.ndim">
<code>ndim</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#torch.Tensor.dim" title="torch.Tensor.dim"><code>dim()</code></a></p> </dd>
</dl> <dl class="attribute"> <dt id="torch.Tensor.T">
<code>T</code> </dt> <dd>
<p>Is this Tensor with its dimensions reversed.</p> <p>If <code>n</code> is the number of dimensions in <code>x</code>, <code>x.T</code> is equivalent to <code>x.permute(n-1, n-2, ..., 0)</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="torch.Tensor.real">
<code>real</code> </dt> <dd>
<p>Returns a new tensor containing real values of the <code>self</code> tensor. The returned tensor and <code>self</code> share the same underlying storage.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><a class="reference internal" href="generated/torch.real#torch.real" title="torch.real"><code>real()</code></a> is only supported for tensors with complex dtypes.</p> </div> <dl> <dt>Example::</dt>
<dd>
<pre data-language="python">&gt;&gt;&gt; x=torch.randn(4, dtype=torch.cfloat)
&gt;&gt;&gt; x
tensor([(0.3100+0.3553j), (-0.5445-0.7896j), (-1.6492-0.0633j), (-0.0638-0.8119j)])
&gt;&gt;&gt; x.real
tensor([ 0.3100, -0.5445, -1.6492, -0.0638])
</pre> </dd> </dl> </dd>
</dl> <dl class="attribute"> <dt id="torch.Tensor.imag">
<code>imag</code> </dt> <dd>
<p>Returns a new tensor containing imaginary values of the <code>self</code> tensor. The returned tensor and <code>self</code> share the same underlying storage.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><a class="reference internal" href="generated/torch.imag#torch.imag" title="torch.imag"><code>imag()</code></a> is only supported for tensors with complex dtypes.</p> </div> <dl> <dt>Example::</dt>
<dd>
<pre data-language="python">&gt;&gt;&gt; x=torch.randn(4, dtype=torch.cfloat)
&gt;&gt;&gt; x
tensor([(0.3100+0.3553j), (-0.5445-0.7896j), (-1.6492-0.0633j), (-0.0638-0.8119j)])
&gt;&gt;&gt; x.imag
tensor([ 0.3553, -0.7896, -0.0633, -0.8119])
</pre> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.abs">
<code>abs() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.abs#torch.abs" title="torch.abs"><code>torch.abs()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.abs_">
<code>abs_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.abs" title="torch.Tensor.abs"><code>abs()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.absolute">
<code>absolute() → Tensor</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="generated/torch.abs#torch.abs" title="torch.abs"><code>abs()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.absolute_">
<code>absolute_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.absolute" title="torch.Tensor.absolute"><code>absolute()</code></a> Alias for <a class="reference internal" href="#torch.Tensor.abs_" title="torch.Tensor.abs_"><code>abs_()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.acos">
<code>acos() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.acos#torch.acos" title="torch.acos"><code>torch.acos()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.acos_">
<code>acos_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.acos" title="torch.Tensor.acos"><code>acos()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.arccos">
<code>arccos() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.arccos#torch.arccos" title="torch.arccos"><code>torch.arccos()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.arccos_">
<code>arccos_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.arccos" title="torch.Tensor.arccos"><code>arccos()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.add">
<code>add(other, *, alpha=1) → Tensor</code> </dt> <dd>
<p>Add a scalar or tensor to <code>self</code> tensor. If both <code>alpha</code> and <code>other</code> are specified, each element of <code>other</code> is scaled by <code>alpha</code> before being used.</p> <p>When <code>other</code> is a tensor, the shape of <code>other</code> must be <a class="reference internal" href="https://pytorch.org/docs/1.8.0/notes/broadcasting.html#broadcasting-semantics"><span class="std std-ref">broadcastable</span></a> with the shape of the underlying tensor</p> <p>See <a class="reference internal" href="generated/torch.add#torch.add" title="torch.add"><code>torch.add()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.add_">
<code>add_(other, *, alpha=1) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.add" title="torch.Tensor.add"><code>add()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.addbmm">
<code>addbmm(batch1, batch2, *, beta=1, alpha=1) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.addbmm#torch.addbmm" title="torch.addbmm"><code>torch.addbmm()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.addbmm_">
<code>addbmm_(batch1, batch2, *, beta=1, alpha=1) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.addbmm" title="torch.Tensor.addbmm"><code>addbmm()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.addcdiv">
<code>addcdiv(tensor1, tensor2, *, value=1) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.addcdiv#torch.addcdiv" title="torch.addcdiv"><code>torch.addcdiv()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.addcdiv_">
<code>addcdiv_(tensor1, tensor2, *, value=1) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.addcdiv" title="torch.Tensor.addcdiv"><code>addcdiv()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.addcmul">
<code>addcmul(tensor1, tensor2, *, value=1) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.addcmul#torch.addcmul" title="torch.addcmul"><code>torch.addcmul()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.addcmul_">
<code>addcmul_(tensor1, tensor2, *, value=1) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.addcmul" title="torch.Tensor.addcmul"><code>addcmul()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.addmm">
<code>addmm(mat1, mat2, *, beta=1, alpha=1) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.addmm#torch.addmm" title="torch.addmm"><code>torch.addmm()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.addmm_">
<code>addmm_(mat1, mat2, *, beta=1, alpha=1) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.addmm" title="torch.Tensor.addmm"><code>addmm()</code></a></p> </dd>
</dl> <dl class="method"> <dt>
<code>sspaddmm(mat1, mat2, *, beta=1, alpha=1) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="sparse#torch.sspaddmm" title="torch.sspaddmm"><code>torch.sspaddmm()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.addmv">
<code>addmv(mat, vec, *, beta=1, alpha=1) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.addmv#torch.addmv" title="torch.addmv"><code>torch.addmv()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.addmv_">
<code>addmv_(mat, vec, *, beta=1, alpha=1) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.addmv" title="torch.Tensor.addmv"><code>addmv()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.addr">
<code>addr(vec1, vec2, *, beta=1, alpha=1) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.addr#torch.addr" title="torch.addr"><code>torch.addr()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.addr_">
<code>addr_(vec1, vec2, *, beta=1, alpha=1) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.addr" title="torch.Tensor.addr"><code>addr()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.allclose">
<code>allclose(other, rtol=1e-05, atol=1e-08, equal_nan=False) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.allclose#torch.allclose" title="torch.allclose"><code>torch.allclose()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.amax">
<code>amax(dim=None, keepdim=False) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.amax#torch.amax" title="torch.amax"><code>torch.amax()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.amin">
<code>amin(dim=None, keepdim=False) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.amin#torch.amin" title="torch.amin"><code>torch.amin()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.angle">
<code>angle() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.angle#torch.angle" title="torch.angle"><code>torch.angle()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.apply_">
<code>apply_(callable) → Tensor</code> </dt> <dd>
<p>Applies the function <code>callable</code> to each element in the tensor, replacing each element with the value returned by <code>callable</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function only works with CPU tensors and should not be used in code sections that require high performance.</p> </div> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.argmax">
<code>argmax(dim=None, keepdim=False) → LongTensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.argmax#torch.argmax" title="torch.argmax"><code>torch.argmax()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.argmin">
<code>argmin(dim=None, keepdim=False) → LongTensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.argmin#torch.argmin" title="torch.argmin"><code>torch.argmin()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.argsort">
<code>argsort(dim=-1, descending=False) → LongTensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.argsort#torch.argsort" title="torch.argsort"><code>torch.argsort()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.asin">
<code>asin() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.asin#torch.asin" title="torch.asin"><code>torch.asin()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.asin_">
<code>asin_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.asin" title="torch.Tensor.asin"><code>asin()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.arcsin">
<code>arcsin() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.arcsin#torch.arcsin" title="torch.arcsin"><code>torch.arcsin()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.arcsin_">
<code>arcsin_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.arcsin" title="torch.Tensor.arcsin"><code>arcsin()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.as_strided">
<code>as_strided(size, stride, storage_offset=0) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.as_strided#torch.as_strided" title="torch.as_strided"><code>torch.as_strided()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.atan">
<code>atan() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.atan#torch.atan" title="torch.atan"><code>torch.atan()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.atan_">
<code>atan_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.atan" title="torch.Tensor.atan"><code>atan()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.arctan">
<code>arctan() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.arctan#torch.arctan" title="torch.arctan"><code>torch.arctan()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.arctan_">
<code>arctan_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.arctan" title="torch.Tensor.arctan"><code>arctan()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.atan2">
<code>atan2(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.atan2#torch.atan2" title="torch.atan2"><code>torch.atan2()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.atan2_">
<code>atan2_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.atan2" title="torch.Tensor.atan2"><code>atan2()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.all">
<code>all(dim=None, keepdim=False) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.all#torch.all" title="torch.all"><code>torch.all()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.any">
<code>any(dim=None, keepdim=False) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.any#torch.any" title="torch.any"><code>torch.any()</code></a></p> </dd>
</dl> <dl class="method"> <dt>
<code>backward(gradient=None, retain_graph=None, create_graph=False, inputs=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/tensor.html#Tensor.backward"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Computes the gradient of current tensor w.r.t. graph leaves.</p> <p>The graph is differentiated using the chain rule. If the tensor is non-scalar (i.e. its data has more than one element) and requires gradient, the function additionally requires specifying <code>gradient</code>. It should be a tensor of matching type and location, that contains the gradient of the differentiated function w.r.t. <code>self</code>.</p> <p>This function accumulates gradients in the leaves - you might need to zero <code>.grad</code> attributes or set them to <code>None</code> before calling it. See <a class="reference internal" href="autograd#default-grad-layouts"><span class="std std-ref">Default gradient layouts</span></a> for details on the memory layout of accumulated gradients.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you run any forward ops, create <code>gradient</code>, and/or call <code>backward</code> in a user-specified CUDA stream context, see <a class="reference internal" href="https://pytorch.org/docs/1.8.0/notes/cuda.html#bwd-cuda-stream-semantics"><span class="std std-ref">Stream semantics of backward passes</span></a>.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>gradient</strong> (<a class="reference internal" href="#torch.Tensor" title="torch.Tensor">Tensor</a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)">None</a>) – Gradient w.r.t. the tensor. If it is a tensor, it will be automatically converted to a Tensor that does not require grad unless <code>create_graph</code> is True. None values can be specified for scalar Tensors or ones that don’t require grad. If a None value would be acceptable then this argument is optional.</li> <li>
<strong>retain_graph</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If <code>False</code>, the graph used to compute the grads will be freed. Note that in nearly all cases setting this option to True is not needed and often can be worked around in a much more efficient way. Defaults to the value of <code>create_graph</code>.</li> <li>
<strong>create_graph</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><em>optional</em>) – If <code>True</code>, graph of the derivative will be constructed, allowing to compute higher order derivative products. Defaults to <code>False</code>.</li> <li>
<strong>inputs</strong> (<em>sequence of Tensor</em>) – Inputs w.r.t. which the gradient will be accumulated into <code>.grad</code>. All other Tensors will be ignored. If not provided, the gradient is accumulated into all the leaf Tensors that were used to compute the attr::tensors. All the provided inputs must be leaf Tensors.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.baddbmm">
<code>baddbmm(batch1, batch2, *, beta=1, alpha=1) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.baddbmm#torch.baddbmm" title="torch.baddbmm"><code>torch.baddbmm()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.baddbmm_">
<code>baddbmm_(batch1, batch2, *, beta=1, alpha=1) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.baddbmm" title="torch.Tensor.baddbmm"><code>baddbmm()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.bernoulli">
<code>bernoulli(*, generator=None) → Tensor</code> </dt> <dd>
<p>Returns a result tensor where each <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">result[i]</mtext></mrow><annotation encoding="application/x-tex">\texttt{result[i]}</annotation></semantics></math></span></span> </span> is independently sampled from <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Bernoulli</mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">self[i]</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{Bernoulli}(\texttt{self[i]})</annotation></semantics></math></span></span> </span>. <code>self</code> must have floating point <code>dtype</code>, and the result will have the same <code>dtype</code>.</p> <p>See <a class="reference internal" href="generated/torch.bernoulli#torch.bernoulli" title="torch.bernoulli"><code>torch.bernoulli()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.bernoulli_">
<code>bernoulli_()</code> </dt> <dd>
<dl class="function"> <dt>
<code>bernoulli_(p=0.5, *, generator=None) → Tensor</code> </dt> <dd>
<p>Fills each location of <code>self</code> with an independent sample from <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Bernoulli</mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">p</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{Bernoulli}(\texttt{p})</annotation></semantics></math></span></span> </span>. <code>self</code> can have integral <code>dtype</code>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>bernoulli_(p_tensor, *, generator=None) → Tensor</code> </dt> <dd>
<p><code>p_tensor</code> should be a tensor containing probabilities to be used for drawing the binary random number.</p> <p>The <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext>i</mtext><mrow><mi>t</mi><mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\text{i}^{th}</annotation></semantics></math></span></span> </span> element of <code>self</code> tensor will be set to a value sampled from <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Bernoulli</mtext><mo stretchy="false">(</mo><mtext mathvariant="monospace">p_tensor[i]</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{Bernoulli}(\texttt{p\_tensor[i]})</annotation></semantics></math></span></span> </span>.</p> <p><code>self</code> can have integral <code>dtype</code>, but <code>p_tensor</code> must have floating point <code>dtype</code>.</p> </dd>
</dl> <p>See also <a class="reference internal" href="#torch.Tensor.bernoulli" title="torch.Tensor.bernoulli"><code>bernoulli()</code></a> and <a class="reference internal" href="generated/torch.bernoulli#torch.bernoulli" title="torch.bernoulli"><code>torch.bernoulli()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.bfloat16">
<code>bfloat16(memory_format=torch.preserve_format) → Tensor</code> </dt> <dd>
<p><code>self.bfloat16()</code> is equivalent to <code>self.to(torch.bfloat16)</code>. See <a class="reference internal" href="#torch.Tensor.to" title="torch.Tensor.to"><code>to()</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>memory_format</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.memory_format" title="torch.torch.memory_format"><code>torch.memory_format</code></a>, optional) – the desired memory format of returned Tensor. Default: <code>torch.preserve_format</code>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.bincount">
<code>bincount(weights=None, minlength=0) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.bincount#torch.bincount" title="torch.bincount"><code>torch.bincount()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.bitwise_not">
<code>bitwise_not() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.bitwise_not#torch.bitwise_not" title="torch.bitwise_not"><code>torch.bitwise_not()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.bitwise_not_">
<code>bitwise_not_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.bitwise_not" title="torch.Tensor.bitwise_not"><code>bitwise_not()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.bitwise_and">
<code>bitwise_and() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.bitwise_and#torch.bitwise_and" title="torch.bitwise_and"><code>torch.bitwise_and()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.bitwise_and_">
<code>bitwise_and_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.bitwise_and" title="torch.Tensor.bitwise_and"><code>bitwise_and()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.bitwise_or">
<code>bitwise_or() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.bitwise_or#torch.bitwise_or" title="torch.bitwise_or"><code>torch.bitwise_or()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.bitwise_or_">
<code>bitwise_or_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.bitwise_or" title="torch.Tensor.bitwise_or"><code>bitwise_or()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.bitwise_xor">
<code>bitwise_xor() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.bitwise_xor#torch.bitwise_xor" title="torch.bitwise_xor"><code>torch.bitwise_xor()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.bitwise_xor_">
<code>bitwise_xor_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.bitwise_xor" title="torch.Tensor.bitwise_xor"><code>bitwise_xor()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.bmm">
<code>bmm(batch2) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.bmm#torch.bmm" title="torch.bmm"><code>torch.bmm()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.bool">
<code>bool(memory_format=torch.preserve_format) → Tensor</code> </dt> <dd>
<p><code>self.bool()</code> is equivalent to <code>self.to(torch.bool)</code>. See <a class="reference internal" href="#torch.Tensor.to" title="torch.Tensor.to"><code>to()</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>memory_format</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.memory_format" title="torch.torch.memory_format"><code>torch.memory_format</code></a>, optional) – the desired memory format of returned Tensor. Default: <code>torch.preserve_format</code>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.byte">
<code>byte(memory_format=torch.preserve_format) → Tensor</code> </dt> <dd>
<p><code>self.byte()</code> is equivalent to <code>self.to(torch.uint8)</code>. See <a class="reference internal" href="#torch.Tensor.to" title="torch.Tensor.to"><code>to()</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>memory_format</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.memory_format" title="torch.torch.memory_format"><code>torch.memory_format</code></a>, optional) – the desired memory format of returned Tensor. Default: <code>torch.preserve_format</code>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.broadcast_to">
<code>broadcast_to(shape) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.broadcast_to#torch.broadcast_to" title="torch.broadcast_to"><code>torch.broadcast_to()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.cauchy_">
<code>cauchy_(median=0, sigma=1, *, generator=None) → Tensor</code> </dt> <dd>
<p>Fills the tensor with numbers drawn from the Cauchy distribution:</p> <div class="math"> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>π</mi></mfrac><mfrac><mi>σ</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mtext>median</mtext><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">f(x) = \dfrac{1}{\pi} \dfrac{\sigma}{(x - \text{median})^2 + \sigma^2}</annotation></semantics></math></span></span></span> </div>
</dd>
</dl> <dl class="method"> <dt id="torch.Tensor.ceil">
<code>ceil() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.ceil#torch.ceil" title="torch.ceil"><code>torch.ceil()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.ceil_">
<code>ceil_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.ceil" title="torch.Tensor.ceil"><code>ceil()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.char">
<code>char(memory_format=torch.preserve_format) → Tensor</code> </dt> <dd>
<p><code>self.char()</code> is equivalent to <code>self.to(torch.int8)</code>. See <a class="reference internal" href="#torch.Tensor.to" title="torch.Tensor.to"><code>to()</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>memory_format</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.memory_format" title="torch.torch.memory_format"><code>torch.memory_format</code></a>, optional) – the desired memory format of returned Tensor. Default: <code>torch.preserve_format</code>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.cholesky">
<code>cholesky(upper=False) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.cholesky#torch.cholesky" title="torch.cholesky"><code>torch.cholesky()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.cholesky_inverse">
<code>cholesky_inverse(upper=False) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.cholesky_inverse#torch.cholesky_inverse" title="torch.cholesky_inverse"><code>torch.cholesky_inverse()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.cholesky_solve">
<code>cholesky_solve(input2, upper=False) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.cholesky_solve#torch.cholesky_solve" title="torch.cholesky_solve"><code>torch.cholesky_solve()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.chunk">
<code>chunk(chunks, dim=0) → List of Tensors</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.chunk#torch.chunk" title="torch.chunk"><code>torch.chunk()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.clamp">
<code>clamp(min, max) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.clamp#torch.clamp" title="torch.clamp"><code>torch.clamp()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.clamp_">
<code>clamp_(min, max) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.clamp" title="torch.Tensor.clamp"><code>clamp()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.clip">
<code>clip(min, max) → Tensor</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#torch.Tensor.clamp" title="torch.Tensor.clamp"><code>clamp()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.clip_">
<code>clip_(min, max) → Tensor</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#torch.Tensor.clamp_" title="torch.Tensor.clamp_"><code>clamp_()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.clone">
<code>clone(*, memory_format=torch.preserve_format) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.clone#torch.clone" title="torch.clone"><code>torch.clone()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.contiguous">
<code>contiguous(memory_format=torch.contiguous_format) → Tensor</code> </dt> <dd>
<p>Returns a contiguous in memory tensor containing the same data as <code>self</code> tensor. If <code>self</code> tensor is already in the specified memory format, this function returns the <code>self</code> tensor.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>memory_format</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.memory_format" title="torch.torch.memory_format"><code>torch.memory_format</code></a>, optional) – the desired memory format of returned Tensor. Default: <code>torch.contiguous_format</code>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.copy_">
<code>copy_(src, non_blocking=False) → Tensor</code> </dt> <dd>
<p>Copies the elements from <code>src</code> into <code>self</code> tensor and returns <code>self</code>.</p> <p>The <code>src</code> tensor must be <a class="reference internal" href="https://pytorch.org/docs/1.8.0/notes/broadcasting.html#broadcasting-semantics"><span class="std std-ref">broadcastable</span></a> with the <code>self</code> tensor. It may be of a different data type or reside on a different device.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>src</strong> (<a class="reference internal" href="#torch.Tensor" title="torch.Tensor">Tensor</a>) – the source tensor to copy from</li> <li>
<strong>non_blocking</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – if <code>True</code> and this copy is between CPU and GPU, the copy may occur asynchronously with respect to the host. For other cases, this argument has no effect.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.conj">
<code>conj() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.conj#torch.conj" title="torch.conj"><code>torch.conj()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.copysign">
<code>copysign(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.copysign#torch.copysign" title="torch.copysign"><code>torch.copysign()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.copysign_">
<code>copysign_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.copysign" title="torch.Tensor.copysign"><code>copysign()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.cos">
<code>cos() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.cos#torch.cos" title="torch.cos"><code>torch.cos()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.cos_">
<code>cos_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.cos" title="torch.Tensor.cos"><code>cos()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.cosh">
<code>cosh() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.cosh#torch.cosh" title="torch.cosh"><code>torch.cosh()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.cosh_">
<code>cosh_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.cosh" title="torch.Tensor.cosh"><code>cosh()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.count_nonzero">
<code>count_nonzero(dim=None) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.count_nonzero#torch.count_nonzero" title="torch.count_nonzero"><code>torch.count_nonzero()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.acosh">
<code>acosh() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.acosh#torch.acosh" title="torch.acosh"><code>torch.acosh()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.acosh_">
<code>acosh_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.acosh" title="torch.Tensor.acosh"><code>acosh()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.arccosh">
<code>arccosh()</code> </dt> <dd>
<p>acosh() -&gt; Tensor</p> <p>See <a class="reference internal" href="generated/torch.arccosh#torch.arccosh" title="torch.arccosh"><code>torch.arccosh()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.arccosh_">
<code>arccosh_()</code> </dt> <dd>
<p>acosh_() -&gt; Tensor</p> <p>In-place version of <a class="reference internal" href="#torch.Tensor.arccosh" title="torch.Tensor.arccosh"><code>arccosh()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.cpu">
<code>cpu(memory_format=torch.preserve_format) → Tensor</code> </dt> <dd>
<p>Returns a copy of this object in CPU memory.</p> <p>If this object is already in CPU memory and on the correct device, then no copy is performed and the original object is returned.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>memory_format</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.memory_format" title="torch.torch.memory_format"><code>torch.memory_format</code></a>, optional) – the desired memory format of returned Tensor. Default: <code>torch.preserve_format</code>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.cross">
<code>cross(other, dim=-1) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.cross#torch.cross" title="torch.cross"><code>torch.cross()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.cuda">
<code>cuda(device=None, non_blocking=False, memory_format=torch.preserve_format) → Tensor</code> </dt> <dd>
<p>Returns a copy of this object in CUDA memory.</p> <p>If this object is already in CUDA memory and on the correct device, then no copy is performed and the original object is returned.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>device</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>) – The destination GPU device. Defaults to the current CUDA device.</li> <li>
<strong>non_blocking</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – If <code>True</code> and the source is in pinned memory, the copy will be asynchronous with respect to the host. Otherwise, the argument has no effect. Default: <code>False</code>.</li> <li>
<strong>memory_format</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.memory_format" title="torch.torch.memory_format"><code>torch.memory_format</code></a>, optional) – the desired memory format of returned Tensor. Default: <code>torch.preserve_format</code>.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.logcumsumexp">
<code>logcumsumexp(dim) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.logcumsumexp#torch.logcumsumexp" title="torch.logcumsumexp"><code>torch.logcumsumexp()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.cummax">
<code>cummax(dim) -&gt; (Tensor, Tensor)</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.cummax#torch.cummax" title="torch.cummax"><code>torch.cummax()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.cummin">
<code>cummin(dim) -&gt; (Tensor, Tensor)</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.cummin#torch.cummin" title="torch.cummin"><code>torch.cummin()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.cumprod">
<code>cumprod(dim, dtype=None) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.cumprod#torch.cumprod" title="torch.cumprod"><code>torch.cumprod()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.cumprod_">
<code>cumprod_(dim, dtype=None) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.cumprod" title="torch.Tensor.cumprod"><code>cumprod()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.cumsum">
<code>cumsum(dim, dtype=None) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.cumsum#torch.cumsum" title="torch.cumsum"><code>torch.cumsum()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.cumsum_">
<code>cumsum_(dim, dtype=None) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.cumsum" title="torch.Tensor.cumsum"><code>cumsum()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.data_ptr">
<code>data_ptr() → int</code> </dt> <dd>
<p>Returns the address of the first element of <code>self</code> tensor.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.deg2rad">
<code>deg2rad() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.deg2rad#torch.deg2rad" title="torch.deg2rad"><code>torch.deg2rad()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.dequantize">
<code>dequantize() → Tensor</code> </dt> <dd>
<p>Given a quantized Tensor, dequantize it and return the dequantized float Tensor.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.det">
<code>det() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.det#torch.det" title="torch.det"><code>torch.det()</code></a></p> </dd>
</dl> <dl class="method"> <dt>
<code>dense_dim() → int</code> </dt> <dd>
<p>Return the number of dense dimensions in a <a class="reference internal" href="sparse#sparse-docs"><span class="std std-ref">sparse tensor</span></a> <code>self</code>.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Throws an error if <code>self</code> is not a sparse tensor.</p> </div> <p>See also <a class="reference internal" href="sparse#torch.Tensor.sparse_dim" title="torch.Tensor.sparse_dim"><code>Tensor.sparse_dim()</code></a> and <a class="reference internal" href="sparse#sparse-hybrid-coo-docs"><span class="std std-ref">hybrid tensors</span></a>.</p> </dd>
</dl> <dl class="method"> <dt>
<code>detach()</code> </dt> <dd>
<p>Returns a new Tensor, detached from the current graph.</p> <p>The result will never require gradient.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Returned Tensor shares the same storage with the original one. In-place modifications on either of them will be seen, and may trigger errors in correctness checks. IMPORTANT NOTE: Previously, in-place size / stride / storage changes (such as <code>resize_</code> / <code>resize_as_</code> / <code>set_</code> / <code>transpose_</code>) to the returned tensor also update the original tensor. Now, these in-place changes will not update the original tensor anymore, and will instead trigger an error. For sparse tensors: In-place indices / values changes (such as <code>zero_</code> / <code>copy_</code> / <code>add_</code>) to the returned tensor will not update the original tensor anymore, and will instead trigger an error.</p> </div> </dd>
</dl> <dl class="method"> <dt>
<code>detach_()</code> </dt> <dd>
<p>Detaches the Tensor from the graph that created it, making it a leaf. Views cannot be detached in-place.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.diag">
<code>diag(diagonal=0) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.diag#torch.diag" title="torch.diag"><code>torch.diag()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.diag_embed">
<code>diag_embed(offset=0, dim1=-2, dim2=-1) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.diag_embed#torch.diag_embed" title="torch.diag_embed"><code>torch.diag_embed()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.diagflat">
<code>diagflat(offset=0) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.diagflat#torch.diagflat" title="torch.diagflat"><code>torch.diagflat()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.diagonal">
<code>diagonal(offset=0, dim1=0, dim2=1) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.diagonal#torch.diagonal" title="torch.diagonal"><code>torch.diagonal()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.fill_diagonal_">
<code>fill_diagonal_(fill_value, wrap=False) → Tensor</code> </dt> <dd>
<p>Fill the main diagonal of a tensor that has at least 2-dimensions. When dims&gt;2, all dimensions of input must be of equal length. This function modifies the input tensor in-place, and returns the input tensor.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>fill_value</strong> (<em>Scalar</em>) – the fill value</li> <li>
<strong>wrap</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – the diagonal ‘wrapped’ after N columns for tall matrices.</li> </ul> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; a = torch.zeros(3, 3)
&gt;&gt;&gt; a.fill_diagonal_(5)
tensor([[5., 0., 0.],
        [0., 5., 0.],
        [0., 0., 5.]])
&gt;&gt;&gt; b = torch.zeros(7, 3)
&gt;&gt;&gt; b.fill_diagonal_(5)
tensor([[5., 0., 0.],
        [0., 5., 0.],
        [0., 0., 5.],
        [0., 0., 0.],
        [0., 0., 0.],
        [0., 0., 0.],
        [0., 0., 0.]])
&gt;&gt;&gt; c = torch.zeros(7, 3)
&gt;&gt;&gt; c.fill_diagonal_(5, wrap=True)
tensor([[5., 0., 0.],
        [0., 5., 0.],
        [0., 0., 5.],
        [0., 0., 0.],
        [5., 0., 0.],
        [0., 5., 0.],
        [0., 0., 5.]])
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.fmax">
<code>fmax(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.fmax#torch.fmax" title="torch.fmax"><code>torch.fmax()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.fmin">
<code>fmin(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.fmin#torch.fmin" title="torch.fmin"><code>torch.fmin()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.diff">
<code>diff(n=1, dim=-1, prepend=None, append=None) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.diff#torch.diff" title="torch.diff"><code>torch.diff()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.digamma">
<code>digamma() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.digamma#torch.digamma" title="torch.digamma"><code>torch.digamma()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.digamma_">
<code>digamma_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.digamma" title="torch.Tensor.digamma"><code>digamma()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.dim">
<code>dim() → int</code> </dt> <dd>
<p>Returns the number of dimensions of <code>self</code> tensor.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.dist">
<code>dist(other, p=2) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.dist#torch.dist" title="torch.dist"><code>torch.dist()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.div">
<code>div(value, *, rounding_mode=None) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.div#torch.div" title="torch.div"><code>torch.div()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.div_">
<code>div_(value, *, rounding_mode=None) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.div" title="torch.Tensor.div"><code>div()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.divide">
<code>divide(value, *, rounding_mode=None) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.divide#torch.divide" title="torch.divide"><code>torch.divide()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.divide_">
<code>divide_(value, *, rounding_mode=None) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.divide" title="torch.Tensor.divide"><code>divide()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.dot">
<code>dot(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.dot#torch.dot" title="torch.dot"><code>torch.dot()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.double">
<code>double(memory_format=torch.preserve_format) → Tensor</code> </dt> <dd>
<p><code>self.double()</code> is equivalent to <code>self.to(torch.float64)</code>. See <a class="reference internal" href="#torch.Tensor.to" title="torch.Tensor.to"><code>to()</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>memory_format</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.memory_format" title="torch.torch.memory_format"><code>torch.memory_format</code></a>, optional) – the desired memory format of returned Tensor. Default: <code>torch.preserve_format</code>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.eig">
<code>eig(eigenvectors=False) -&gt; (Tensor, Tensor)</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.eig#torch.eig" title="torch.eig"><code>torch.eig()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.element_size">
<code>element_size() → int</code> </dt> <dd>
<p>Returns the size in bytes of an individual element.</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; torch.tensor([]).element_size()
4
&gt;&gt;&gt; torch.tensor([], dtype=torch.uint8).element_size()
1
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.eq">
<code>eq(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.eq#torch.eq" title="torch.eq"><code>torch.eq()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.eq_">
<code>eq_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.eq" title="torch.Tensor.eq"><code>eq()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.equal">
<code>equal(other) → bool</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.equal#torch.equal" title="torch.equal"><code>torch.equal()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.erf">
<code>erf() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.erf#torch.erf" title="torch.erf"><code>torch.erf()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.erf_">
<code>erf_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.erf" title="torch.Tensor.erf"><code>erf()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.erfc">
<code>erfc() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.erfc#torch.erfc" title="torch.erfc"><code>torch.erfc()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.erfc_">
<code>erfc_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.erfc" title="torch.Tensor.erfc"><code>erfc()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.erfinv">
<code>erfinv() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.erfinv#torch.erfinv" title="torch.erfinv"><code>torch.erfinv()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.erfinv_">
<code>erfinv_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.erfinv" title="torch.Tensor.erfinv"><code>erfinv()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.exp">
<code>exp() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.exp#torch.exp" title="torch.exp"><code>torch.exp()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.exp_">
<code>exp_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.exp" title="torch.Tensor.exp"><code>exp()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.expm1">
<code>expm1() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.expm1#torch.expm1" title="torch.expm1"><code>torch.expm1()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.expm1_">
<code>expm1_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.expm1" title="torch.Tensor.expm1"><code>expm1()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.expand">
<code>expand(*sizes) → Tensor</code> </dt> <dd>
<p>Returns a new view of the <code>self</code> tensor with singleton dimensions expanded to a larger size.</p> <p>Passing -1 as the size for a dimension means not changing the size of that dimension.</p> <p>Tensor can be also expanded to a larger number of dimensions, and the new ones will be appended at the front. For the new dimensions, the size cannot be set to -1.</p> <p>Expanding a tensor does not allocate new memory, but only creates a new view on the existing tensor where a dimension of size one is expanded to a larger size by setting the <code>stride</code> to 0. Any dimension of size 1 can be expanded to an arbitrary value without allocating new memory.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>*sizes</strong> (<em>torch.Size</em><em> or </em><em>int...</em>) – the desired expanded size</p> </dd> </dl> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>More than one element of an expanded tensor may refer to a single memory location. As a result, in-place operations (especially ones that are vectorized) may result in incorrect behavior. If you need to write to the tensors, please clone them first.</p> </div> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; x = torch.tensor([[1], [2], [3]])
&gt;&gt;&gt; x.size()
torch.Size([3, 1])
&gt;&gt;&gt; x.expand(3, 4)
tensor([[ 1,  1,  1,  1],
        [ 2,  2,  2,  2],
        [ 3,  3,  3,  3]])
&gt;&gt;&gt; x.expand(-1, 4)   # -1 means not changing the size of that dimension
tensor([[ 1,  1,  1,  1],
        [ 2,  2,  2,  2],
        [ 3,  3,  3,  3]])
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.expand_as">
<code>expand_as(other) → Tensor</code> </dt> <dd>
<p>Expand this tensor to the same size as <code>other</code>. <code>self.expand_as(other)</code> is equivalent to <code>self.expand(other.size())</code>.</p> <p>Please see <a class="reference internal" href="#torch.Tensor.expand" title="torch.Tensor.expand"><code>expand()</code></a> for more information about <code>expand</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>other</strong> (<a class="reference internal" href="#torch.Tensor" title="torch.Tensor"><code>torch.Tensor</code></a>) – The result tensor has the same size as <code>other</code>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.exponential_">
<code>exponential_(lambd=1, *, generator=None) → Tensor</code> </dt> <dd>
<p>Fills <code>self</code> tensor with elements drawn from the exponential distribution:</p> <div class="math"> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>λ</mi><msup><mi>e</mi><mrow><mo>−</mo><mi>λ</mi><mi>x</mi></mrow></msup></mrow><annotation encoding="application/x-tex">f(x) = \lambda e^{-\lambda x}</annotation></semantics></math></span></span></span> </div>
</dd>
</dl> <dl class="method"> <dt id="torch.Tensor.fix">
<code>fix() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.fix#torch.fix" title="torch.fix"><code>torch.fix()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.fix_">
<code>fix_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.fix" title="torch.Tensor.fix"><code>fix()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.fill_">
<code>fill_(value) → Tensor</code> </dt> <dd>
<p>Fills <code>self</code> tensor with the specified value.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.flatten">
<code>flatten(input, start_dim=0, end_dim=-1) → Tensor</code> </dt> <dd>
<p>see <a class="reference internal" href="generated/torch.flatten#torch.flatten" title="torch.flatten"><code>torch.flatten()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.flip">
<code>flip(dims) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.flip#torch.flip" title="torch.flip"><code>torch.flip()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.fliplr">
<code>fliplr() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.fliplr#torch.fliplr" title="torch.fliplr"><code>torch.fliplr()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.flipud">
<code>flipud() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.flipud#torch.flipud" title="torch.flipud"><code>torch.flipud()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.float">
<code>float(memory_format=torch.preserve_format) → Tensor</code> </dt> <dd>
<p><code>self.float()</code> is equivalent to <code>self.to(torch.float32)</code>. See <a class="reference internal" href="#torch.Tensor.to" title="torch.Tensor.to"><code>to()</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>memory_format</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.memory_format" title="torch.torch.memory_format"><code>torch.memory_format</code></a>, optional) – the desired memory format of returned Tensor. Default: <code>torch.preserve_format</code>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.float_power">
<code>float_power(exponent) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.float_power#torch.float_power" title="torch.float_power"><code>torch.float_power()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.float_power_">
<code>float_power_(exponent) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.float_power" title="torch.Tensor.float_power"><code>float_power()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.floor">
<code>floor() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.floor#torch.floor" title="torch.floor"><code>torch.floor()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.floor_">
<code>floor_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.floor" title="torch.Tensor.floor"><code>floor()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.floor_divide">
<code>floor_divide(value) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.floor_divide#torch.floor_divide" title="torch.floor_divide"><code>torch.floor_divide()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.floor_divide_">
<code>floor_divide_(value) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.floor_divide" title="torch.Tensor.floor_divide"><code>floor_divide()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.fmod">
<code>fmod(divisor) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.fmod#torch.fmod" title="torch.fmod"><code>torch.fmod()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.fmod_">
<code>fmod_(divisor) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.fmod" title="torch.Tensor.fmod"><code>fmod()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.frac">
<code>frac() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.frac#torch.frac" title="torch.frac"><code>torch.frac()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.frac_">
<code>frac_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.frac" title="torch.Tensor.frac"><code>frac()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.gather">
<code>gather(dim, index) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.gather#torch.gather" title="torch.gather"><code>torch.gather()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.gcd">
<code>gcd(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.gcd#torch.gcd" title="torch.gcd"><code>torch.gcd()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.gcd_">
<code>gcd_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.gcd" title="torch.Tensor.gcd"><code>gcd()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.ge">
<code>ge(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.ge#torch.ge" title="torch.ge"><code>torch.ge()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.ge_">
<code>ge_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.ge" title="torch.Tensor.ge"><code>ge()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.greater_equal">
<code>greater_equal(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.greater_equal#torch.greater_equal" title="torch.greater_equal"><code>torch.greater_equal()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.greater_equal_">
<code>greater_equal_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.greater_equal" title="torch.Tensor.greater_equal"><code>greater_equal()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.geometric_">
<code>geometric_(p, *, generator=None) → Tensor</code> </dt> <dd>
<p>Fills <code>self</code> tensor with elements drawn from the geometric distribution:</p> <div class="math"> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>p</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(X=k) = p^{k - 1} (1 - p)</annotation></semantics></math></span></span></span> </div>
</dd>
</dl> <dl class="method"> <dt id="torch.Tensor.geqrf">
<code>geqrf() -&gt; (Tensor, Tensor)</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.geqrf#torch.geqrf" title="torch.geqrf"><code>torch.geqrf()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.ger">
<code>ger(vec2) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.ger#torch.ger" title="torch.ger"><code>torch.ger()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.get_device">
<code>get_device() -&gt; Device ordinal (Integer)</code> </dt> <dd>
<p>For CUDA tensors, this function returns the device ordinal of the GPU on which the tensor resides. For CPU tensors, an error is thrown.</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; x = torch.randn(3, 4, 5, device='cuda:0')
&gt;&gt;&gt; x.get_device()
0
&gt;&gt;&gt; x.cpu().get_device()  # RuntimeError: get_device is not implemented for type torch.FloatTensor
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.gt">
<code>gt(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.gt#torch.gt" title="torch.gt"><code>torch.gt()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.gt_">
<code>gt_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.gt" title="torch.Tensor.gt"><code>gt()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.greater">
<code>greater(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.greater#torch.greater" title="torch.greater"><code>torch.greater()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.greater_">
<code>greater_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.greater" title="torch.Tensor.greater"><code>greater()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.half">
<code>half(memory_format=torch.preserve_format) → Tensor</code> </dt> <dd>
<p><code>self.half()</code> is equivalent to <code>self.to(torch.float16)</code>. See <a class="reference internal" href="#torch.Tensor.to" title="torch.Tensor.to"><code>to()</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>memory_format</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.memory_format" title="torch.torch.memory_format"><code>torch.memory_format</code></a>, optional) – the desired memory format of returned Tensor. Default: <code>torch.preserve_format</code>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.hardshrink">
<code>hardshrink(lambd=0.5) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="nn.functional#torch.nn.functional.hardshrink" title="torch.nn.functional.hardshrink"><code>torch.nn.functional.hardshrink()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.heaviside">
<code>heaviside(values) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.heaviside#torch.heaviside" title="torch.heaviside"><code>torch.heaviside()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.histc">
<code>histc(bins=100, min=0, max=0) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.histc#torch.histc" title="torch.histc"><code>torch.histc()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.hypot">
<code>hypot(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.hypot#torch.hypot" title="torch.hypot"><code>torch.hypot()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.hypot_">
<code>hypot_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.hypot" title="torch.Tensor.hypot"><code>hypot()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.i0">
<code>i0() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.i0#torch.i0" title="torch.i0"><code>torch.i0()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.i0_">
<code>i0_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.i0" title="torch.Tensor.i0"><code>i0()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.igamma">
<code>igamma(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.igamma#torch.igamma" title="torch.igamma"><code>torch.igamma()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.igamma_">
<code>igamma_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.igamma" title="torch.Tensor.igamma"><code>igamma()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.igammac">
<code>igammac(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.igammac#torch.igammac" title="torch.igammac"><code>torch.igammac()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.igammac_">
<code>igammac_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.igammac" title="torch.Tensor.igammac"><code>igammac()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.index_add_">
<code>index_add_(dim, index, tensor) → Tensor</code> </dt> <dd>
<p>Accumulate the elements of <a class="reference internal" href="generated/torch.tensor#torch.tensor" title="torch.tensor"><code>tensor</code></a> into the <code>self</code> tensor by adding to the indices in the order given in <code>index</code>. For example, if <code>dim == 0</code> and <code>index[i] == j</code>, then the <code>i</code>th row of <a class="reference internal" href="generated/torch.tensor#torch.tensor" title="torch.tensor"><code>tensor</code></a> is added to the <code>j</code>th row of <code>self</code>.</p> <p>The <a class="reference internal" href="#torch.Tensor.dim" title="torch.Tensor.dim"><code>dim</code></a>th dimension of <a class="reference internal" href="generated/torch.tensor#torch.tensor" title="torch.tensor"><code>tensor</code></a> must have the same size as the length of <code>index</code> (which must be a vector), and all other dimensions must match <code>self</code>, or an error will be raised.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This operation may behave nondeterministically when given tensors on a CUDA device. See <a class="reference internal" href="https://pytorch.org/docs/1.8.0/notes/randomness.html"><span class="doc">Reproducibility</span></a> for more information.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – dimension along which to index</li> <li>
<strong>index</strong> (<em>IntTensor</em><em> or </em><em>LongTensor</em>) – indices of <a class="reference internal" href="generated/torch.tensor#torch.tensor" title="torch.tensor"><code>tensor</code></a> to select from</li> <li>
<strong>tensor</strong> (<a class="reference internal" href="#torch.Tensor" title="torch.Tensor">Tensor</a>) – the tensor containing values to add</li> </ul> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; x = torch.ones(5, 3)
&gt;&gt;&gt; t = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float)
&gt;&gt;&gt; index = torch.tensor([0, 4, 2])
&gt;&gt;&gt; x.index_add_(0, index, t)
tensor([[  2.,   3.,   4.],
        [  1.,   1.,   1.],
        [  8.,   9.,  10.],
        [  1.,   1.,   1.],
        [  5.,   6.,   7.]])
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.index_add">
<code>index_add(tensor1, dim, index, tensor2) → Tensor</code> </dt> <dd>
<p>Out-of-place version of <a class="reference internal" href="#torch.Tensor.index_add_" title="torch.Tensor.index_add_"><code>torch.Tensor.index_add_()</code></a>. <code>tensor1</code> corresponds to <code>self</code> in <a class="reference internal" href="#torch.Tensor.index_add_" title="torch.Tensor.index_add_"><code>torch.Tensor.index_add_()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.index_copy_">
<code>index_copy_(dim, index, tensor) → Tensor</code> </dt> <dd>
<p>Copies the elements of <a class="reference internal" href="generated/torch.tensor#torch.tensor" title="torch.tensor"><code>tensor</code></a> into the <code>self</code> tensor by selecting the indices in the order given in <code>index</code>. For example, if <code>dim == 0</code> and <code>index[i] == j</code>, then the <code>i</code>th row of <a class="reference internal" href="generated/torch.tensor#torch.tensor" title="torch.tensor"><code>tensor</code></a> is copied to the <code>j</code>th row of <code>self</code>.</p> <p>The <a class="reference internal" href="#torch.Tensor.dim" title="torch.Tensor.dim"><code>dim</code></a>th dimension of <a class="reference internal" href="generated/torch.tensor#torch.tensor" title="torch.tensor"><code>tensor</code></a> must have the same size as the length of <code>index</code> (which must be a vector), and all other dimensions must match <code>self</code>, or an error will be raised.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If <code>index</code> contains duplicate entries, multiple elements from <a class="reference internal" href="generated/torch.tensor#torch.tensor" title="torch.tensor"><code>tensor</code></a> will be copied to the same index of <code>self</code>. The result is nondeterministic since it depends on which copy occurs last.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – dimension along which to index</li> <li>
<strong>index</strong> (<em>LongTensor</em>) – indices of <a class="reference internal" href="generated/torch.tensor#torch.tensor" title="torch.tensor"><code>tensor</code></a> to select from</li> <li>
<strong>tensor</strong> (<a class="reference internal" href="#torch.Tensor" title="torch.Tensor">Tensor</a>) – the tensor containing values to copy</li> </ul> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; x = torch.zeros(5, 3)
&gt;&gt;&gt; t = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float)
&gt;&gt;&gt; index = torch.tensor([0, 4, 2])
&gt;&gt;&gt; x.index_copy_(0, index, t)
tensor([[ 1.,  2.,  3.],
        [ 0.,  0.,  0.],
        [ 7.,  8.,  9.],
        [ 0.,  0.,  0.],
        [ 4.,  5.,  6.]])
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.index_copy">
<code>index_copy(tensor1, dim, index, tensor2) → Tensor</code> </dt> <dd>
<p>Out-of-place version of <a class="reference internal" href="#torch.Tensor.index_copy_" title="torch.Tensor.index_copy_"><code>torch.Tensor.index_copy_()</code></a>. <code>tensor1</code> corresponds to <code>self</code> in <a class="reference internal" href="#torch.Tensor.index_copy_" title="torch.Tensor.index_copy_"><code>torch.Tensor.index_copy_()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.index_fill_">
<code>index_fill_(dim, index, val) → Tensor</code> </dt> <dd>
<p>Fills the elements of the <code>self</code> tensor with value <code>val</code> by selecting the indices in the order given in <code>index</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – dimension along which to index</li> <li>
<strong>index</strong> (<em>LongTensor</em>) – indices of <code>self</code> tensor to fill in</li> <li>
<strong>val</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a>) – the value to fill with</li> </ul> </dd> </dl> <dl> <dt>Example::</dt>
<dd>
<pre data-language="python">&gt;&gt;&gt; x = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float)
&gt;&gt;&gt; index = torch.tensor([0, 2])
&gt;&gt;&gt; x.index_fill_(1, index, -1)
tensor([[-1.,  2., -1.],
        [-1.,  5., -1.],
        [-1.,  8., -1.]])
</pre> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.index_fill">
<code>index_fill(tensor1, dim, index, value) → Tensor</code> </dt> <dd>
<p>Out-of-place version of <a class="reference internal" href="#torch.Tensor.index_fill_" title="torch.Tensor.index_fill_"><code>torch.Tensor.index_fill_()</code></a>. <code>tensor1</code> corresponds to <code>self</code> in <a class="reference internal" href="#torch.Tensor.index_fill_" title="torch.Tensor.index_fill_"><code>torch.Tensor.index_fill_()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.index_put_">
<code>index_put_(indices, values, accumulate=False) → Tensor</code> </dt> <dd>
<p>Puts values from the tensor <a class="reference internal" href="sparse#torch.Tensor.values" title="torch.Tensor.values"><code>values</code></a> into the tensor <code>self</code> using the indices specified in <a class="reference internal" href="sparse#torch.Tensor.indices" title="torch.Tensor.indices"><code>indices</code></a> (which is a tuple of Tensors). The expression <code>tensor.index_put_(indices, values)</code> is equivalent to <code>tensor[indices] = values</code>. Returns <code>self</code>.</p> <p>If <code>accumulate</code> is <code>True</code>, the elements in <a class="reference internal" href="sparse#torch.Tensor.values" title="torch.Tensor.values"><code>values</code></a> are added to <code>self</code>. If accumulate is <code>False</code>, the behavior is undefined if indices contain duplicate elements.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>indices</strong> (<em>tuple of LongTensor</em>) – tensors used to index into <code>self</code>.</li> <li>
<strong>values</strong> (<a class="reference internal" href="#torch.Tensor" title="torch.Tensor">Tensor</a>) – tensor of same dtype as <code>self</code>.</li> <li>
<strong>accumulate</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – whether to accumulate into self</li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.index_put">
<code>index_put(tensor1, indices, values, accumulate=False) → Tensor</code> </dt> <dd>
<p>Out-place version of <a class="reference internal" href="#torch.Tensor.index_put_" title="torch.Tensor.index_put_"><code>index_put_()</code></a>. <code>tensor1</code> corresponds to <code>self</code> in <a class="reference internal" href="#torch.Tensor.index_put_" title="torch.Tensor.index_put_"><code>torch.Tensor.index_put_()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.index_select">
<code>index_select(dim, index) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.index_select#torch.index_select" title="torch.index_select"><code>torch.index_select()</code></a></p> </dd>
</dl> <dl class="method"> <dt>
<code>indices() → Tensor</code> </dt> <dd>
<p>Return the indices tensor of a <a class="reference internal" href="sparse#sparse-coo-docs"><span class="std std-ref">sparse COO tensor</span></a>.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Throws an error if <code>self</code> is not a sparse COO tensor.</p> </div> <p>See also <a class="reference internal" href="sparse#torch.Tensor.values" title="torch.Tensor.values"><code>Tensor.values()</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This method can only be called on a coalesced sparse tensor. See <a class="reference internal" href="sparse#torch.Tensor.coalesce" title="torch.Tensor.coalesce"><code>Tensor.coalesce()</code></a> for details.</p> </div> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.inner">
<code>inner(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.inner#torch.inner" title="torch.inner"><code>torch.inner()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.int">
<code>int(memory_format=torch.preserve_format) → Tensor</code> </dt> <dd>
<p><code>self.int()</code> is equivalent to <code>self.to(torch.int32)</code>. See <a class="reference internal" href="#torch.Tensor.to" title="torch.Tensor.to"><code>to()</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>memory_format</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.memory_format" title="torch.torch.memory_format"><code>torch.memory_format</code></a>, optional) – the desired memory format of returned Tensor. Default: <code>torch.preserve_format</code>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.int_repr">
<code>int_repr() → Tensor</code> </dt> <dd>
<p>Given a quantized Tensor, <code>self.int_repr()</code> returns a CPU Tensor with uint8_t as data type that stores the underlying uint8_t values of the given Tensor.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.inverse">
<code>inverse() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.inverse#torch.inverse" title="torch.inverse"><code>torch.inverse()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.isclose">
<code>isclose(other, rtol=1e-05, atol=1e-08, equal_nan=False) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.isclose#torch.isclose" title="torch.isclose"><code>torch.isclose()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.isfinite">
<code>isfinite() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.isfinite#torch.isfinite" title="torch.isfinite"><code>torch.isfinite()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.isinf">
<code>isinf() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.isinf#torch.isinf" title="torch.isinf"><code>torch.isinf()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.isposinf">
<code>isposinf() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.isposinf#torch.isposinf" title="torch.isposinf"><code>torch.isposinf()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.isneginf">
<code>isneginf() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.isneginf#torch.isneginf" title="torch.isneginf"><code>torch.isneginf()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.isnan">
<code>isnan() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.isnan#torch.isnan" title="torch.isnan"><code>torch.isnan()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.is_contiguous">
<code>is_contiguous(memory_format=torch.contiguous_format) → bool</code> </dt> <dd>
<p>Returns True if <code>self</code> tensor is contiguous in memory in the order specified by memory format.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>memory_format</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.memory_format" title="torch.torch.memory_format"><code>torch.memory_format</code></a>, optional) – Specifies memory allocation order. Default: <code>torch.contiguous_format</code>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.is_complex">
<code>is_complex() → bool</code> </dt> <dd>
<p>Returns True if the data type of <code>self</code> is a complex data type.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.is_floating_point">
<code>is_floating_point() → bool</code> </dt> <dd>
<p>Returns True if the data type of <code>self</code> is a floating point data type.</p> </dd>
</dl> <dl class="attribute"> <dt>
<code>is_leaf</code> </dt> <dd>
<p>All Tensors that have <a class="reference internal" href="autograd#torch.Tensor.requires_grad" title="torch.Tensor.requires_grad"><code>requires_grad</code></a> which is <code>False</code> will be leaf Tensors by convention.</p> <p>For Tensors that have <a class="reference internal" href="autograd#torch.Tensor.requires_grad" title="torch.Tensor.requires_grad"><code>requires_grad</code></a> which is <code>True</code>, they will be leaf Tensors if they were created by the user. This means that they are not the result of an operation and so <code>grad_fn</code> is None.</p> <p>Only leaf Tensors will have their <a class="reference internal" href="autograd#torch.Tensor.grad" title="torch.Tensor.grad"><code>grad</code></a> populated during a call to <a class="reference internal" href="autograd#torch.Tensor.backward" title="torch.Tensor.backward"><code>backward()</code></a>. To get <a class="reference internal" href="autograd#torch.Tensor.grad" title="torch.Tensor.grad"><code>grad</code></a> populated for non-leaf Tensors, you can use <a class="reference internal" href="autograd#torch.Tensor.retain_grad" title="torch.Tensor.retain_grad"><code>retain_grad()</code></a>.</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; a = torch.rand(10, requires_grad=True)
&gt;&gt;&gt; a.is_leaf
True
&gt;&gt;&gt; b = torch.rand(10, requires_grad=True).cuda()
&gt;&gt;&gt; b.is_leaf
False
# b was created by the operation that cast a cpu Tensor into a cuda Tensor
&gt;&gt;&gt; c = torch.rand(10, requires_grad=True) + 2
&gt;&gt;&gt; c.is_leaf
False
# c was created by the addition operation
&gt;&gt;&gt; d = torch.rand(10).cuda()
&gt;&gt;&gt; d.is_leaf
True
# d does not require gradients and so has no operation creating it (that is tracked by the autograd engine)
&gt;&gt;&gt; e = torch.rand(10).cuda().requires_grad_()
&gt;&gt;&gt; e.is_leaf
True
# e requires gradients and has no operations creating it
&gt;&gt;&gt; f = torch.rand(10, requires_grad=True, device="cuda")
&gt;&gt;&gt; f.is_leaf
True
# f requires grad, has no operation creating it
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.is_pinned">
<code>is_pinned()</code> </dt> <dd>
<p>Returns true if this tensor resides in pinned memory.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.is_set_to">
<code>is_set_to(tensor) → bool</code> </dt> <dd>
<p>Returns True if both tensors are pointing to the exact same memory (same storage, offset, size and stride).</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.is_shared">
<code>is_shared()</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/tensor.html#Tensor.is_shared"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Checks if tensor is in shared memory.</p> <p>This is always <code>True</code> for CUDA tensors.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.is_signed">
<code>is_signed() → bool</code> </dt> <dd>
<p>Returns True if the data type of <code>self</code> is a signed data type.</p> </dd>
</dl> <dl class="attribute"> <dt>
<code>is_sparse</code> </dt> <dd>
<p>Is <code>True</code> if the Tensor uses sparse storage layout, <code>False</code> otherwise.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.istft">
<code>istft(n_fft, hop_length=None, win_length=None, window=None, center=True, normalized=False, onesided=None, length=None, return_complex=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/tensor.html#Tensor.istft"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>See <a class="reference internal" href="generated/torch.istft#torch.istft" title="torch.istft"><code>torch.istft()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.isreal">
<code>isreal() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.isreal#torch.isreal" title="torch.isreal"><code>torch.isreal()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.item">
<code>item() → number</code> </dt> <dd>
<p>Returns the value of this tensor as a standard Python number. This only works for tensors with one element. For other cases, see <a class="reference internal" href="#torch.Tensor.tolist" title="torch.Tensor.tolist"><code>tolist()</code></a>.</p> <p>This operation is not differentiable.</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; x = torch.tensor([1.0])
&gt;&gt;&gt; x.item()
1.0
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.kthvalue">
<code>kthvalue(k, dim=None, keepdim=False) -&gt; (Tensor, LongTensor)</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.kthvalue#torch.kthvalue" title="torch.kthvalue"><code>torch.kthvalue()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.lcm">
<code>lcm(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.lcm#torch.lcm" title="torch.lcm"><code>torch.lcm()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.lcm_">
<code>lcm_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.lcm" title="torch.Tensor.lcm"><code>lcm()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.ldexp">
<code>ldexp(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.ldexp#torch.ldexp" title="torch.ldexp"><code>torch.ldexp()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.ldexp_">
<code>ldexp_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.ldexp" title="torch.Tensor.ldexp"><code>ldexp()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.le">
<code>le(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.le#torch.le" title="torch.le"><code>torch.le()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.le_">
<code>le_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.le" title="torch.Tensor.le"><code>le()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.less_equal">
<code>less_equal(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.less_equal#torch.less_equal" title="torch.less_equal"><code>torch.less_equal()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.less_equal_">
<code>less_equal_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.less_equal" title="torch.Tensor.less_equal"><code>less_equal()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.lerp">
<code>lerp(end, weight) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.lerp#torch.lerp" title="torch.lerp"><code>torch.lerp()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.lerp_">
<code>lerp_(end, weight) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.lerp" title="torch.Tensor.lerp"><code>lerp()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.lgamma">
<code>lgamma() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.lgamma#torch.lgamma" title="torch.lgamma"><code>torch.lgamma()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.lgamma_">
<code>lgamma_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.lgamma" title="torch.Tensor.lgamma"><code>lgamma()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.log">
<code>log() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.log#torch.log" title="torch.log"><code>torch.log()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.log_">
<code>log_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.log" title="torch.Tensor.log"><code>log()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.logdet">
<code>logdet() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.logdet#torch.logdet" title="torch.logdet"><code>torch.logdet()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.log10">
<code>log10() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.log10#torch.log10" title="torch.log10"><code>torch.log10()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.log10_">
<code>log10_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.log10" title="torch.Tensor.log10"><code>log10()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.log1p">
<code>log1p() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.log1p#torch.log1p" title="torch.log1p"><code>torch.log1p()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.log1p_">
<code>log1p_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.log1p" title="torch.Tensor.log1p"><code>log1p()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.log2">
<code>log2() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.log2#torch.log2" title="torch.log2"><code>torch.log2()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.log2_">
<code>log2_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.log2" title="torch.Tensor.log2"><code>log2()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.log_normal_">
<code>log_normal_(mean=1, std=2, *, generator=None)</code> </dt> <dd>
<p>Fills <code>self</code> tensor with numbers samples from the log-normal distribution parameterized by the given mean <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span></span> </span> and standard deviation <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span></span> </span>. Note that <a class="reference internal" href="generated/torch.mean#torch.mean" title="torch.mean"><code>mean</code></a> and <a class="reference internal" href="generated/torch.std#torch.std" title="torch.std"><code>std</code></a> are the mean and standard deviation of the underlying normal distribution, and not of the returned distribution:</p> <div class="math"> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi>x</mi><mi>σ</mi><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mrow></mfrac><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>ln</mi><mo>⁡</mo><mi>x</mi><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">f(x) = \dfrac{1}{x \sigma \sqrt{2\pi}}\ e^{-\frac{(\ln x - \mu)^2}{2\sigma^2}}</annotation></semantics></math></span></span></span> </div>
</dd>
</dl> <dl class="method"> <dt id="torch.Tensor.logaddexp">
<code>logaddexp(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.logaddexp#torch.logaddexp" title="torch.logaddexp"><code>torch.logaddexp()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.logaddexp2">
<code>logaddexp2(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.logaddexp2#torch.logaddexp2" title="torch.logaddexp2"><code>torch.logaddexp2()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.logsumexp">
<code>logsumexp(dim, keepdim=False) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.logsumexp#torch.logsumexp" title="torch.logsumexp"><code>torch.logsumexp()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.logical_and">
<code>logical_and() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.logical_and#torch.logical_and" title="torch.logical_and"><code>torch.logical_and()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.logical_and_">
<code>logical_and_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.logical_and" title="torch.Tensor.logical_and"><code>logical_and()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.logical_not">
<code>logical_not() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.logical_not#torch.logical_not" title="torch.logical_not"><code>torch.logical_not()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.logical_not_">
<code>logical_not_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.logical_not" title="torch.Tensor.logical_not"><code>logical_not()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.logical_or">
<code>logical_or() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.logical_or#torch.logical_or" title="torch.logical_or"><code>torch.logical_or()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.logical_or_">
<code>logical_or_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.logical_or" title="torch.Tensor.logical_or"><code>logical_or()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.logical_xor">
<code>logical_xor() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.logical_xor#torch.logical_xor" title="torch.logical_xor"><code>torch.logical_xor()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.logical_xor_">
<code>logical_xor_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.logical_xor" title="torch.Tensor.logical_xor"><code>logical_xor()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.logit">
<code>logit() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.logit#torch.logit" title="torch.logit"><code>torch.logit()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.logit_">
<code>logit_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.logit" title="torch.Tensor.logit"><code>logit()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.long">
<code>long(memory_format=torch.preserve_format) → Tensor</code> </dt> <dd>
<p><code>self.long()</code> is equivalent to <code>self.to(torch.int64)</code>. See <a class="reference internal" href="#torch.Tensor.to" title="torch.Tensor.to"><code>to()</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>memory_format</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.memory_format" title="torch.torch.memory_format"><code>torch.memory_format</code></a>, optional) – the desired memory format of returned Tensor. Default: <code>torch.preserve_format</code>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.lstsq">
<code>lstsq(A) -&gt; (Tensor, Tensor)</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.lstsq#torch.lstsq" title="torch.lstsq"><code>torch.lstsq()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.lt">
<code>lt(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.lt#torch.lt" title="torch.lt"><code>torch.lt()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.lt_">
<code>lt_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.lt" title="torch.Tensor.lt"><code>lt()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.less">
<code>less()</code> </dt> <dd>
<p>lt(other) -&gt; Tensor</p> <p>See <a class="reference internal" href="generated/torch.less#torch.less" title="torch.less"><code>torch.less()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.less_">
<code>less_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.less" title="torch.Tensor.less"><code>less()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.lu">
<code>lu(pivot=True, get_infos=False)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/tensor.html#Tensor.lu"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>See <a class="reference internal" href="generated/torch.lu#torch.lu" title="torch.lu"><code>torch.lu()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.lu_solve">
<code>lu_solve(LU_data, LU_pivots) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.lu_solve#torch.lu_solve" title="torch.lu_solve"><code>torch.lu_solve()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.as_subclass">
<code>as_subclass(cls) → Tensor</code> </dt> <dd>
<p>Makes a <code>cls</code> instance with the same data pointer as <code>self</code>. Changes in the output mirror changes in <code>self</code>, and the output stays attached to the autograd graph. <code>cls</code> must be a subclass of <code>Tensor</code>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.map_">
<code>map_(tensor, callable)</code> </dt> <dd>
<p>Applies <code>callable</code> for each element in <code>self</code> tensor and the given <a class="reference internal" href="generated/torch.tensor#torch.tensor" title="torch.tensor"><code>tensor</code></a> and stores the results in <code>self</code> tensor. <code>self</code> tensor and the given <a class="reference internal" href="generated/torch.tensor#torch.tensor" title="torch.tensor"><code>tensor</code></a> must be <a class="reference internal" href="https://pytorch.org/docs/1.8.0/notes/broadcasting.html#broadcasting-semantics"><span class="std std-ref">broadcastable</span></a>.</p> <p>The <code>callable</code> should have the signature:</p> <pre data-language="python">def callable(a, b) -&gt; number
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.masked_scatter_">
<code>masked_scatter_(mask, source)</code> </dt> <dd>
<p>Copies elements from <code>source</code> into <code>self</code> tensor at positions where the <code>mask</code> is True. The shape of <code>mask</code> must be <a class="reference internal" href="https://pytorch.org/docs/1.8.0/notes/broadcasting.html#broadcasting-semantics"><span class="std std-ref">broadcastable</span></a> with the shape of the underlying tensor. The <code>source</code> should have at least as many elements as the number of ones in <code>mask</code></p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>mask</strong> (<em>BoolTensor</em>) – the boolean mask</li> <li>
<strong>source</strong> (<a class="reference internal" href="#torch.Tensor" title="torch.Tensor">Tensor</a>) – the tensor to copy from</li> </ul> </dd> </dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <code>mask</code> operates on the <code>self</code> tensor, not on the given <code>source</code> tensor.</p> </div> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.masked_scatter">
<code>masked_scatter(mask, tensor) → Tensor</code> </dt> <dd>
<p>Out-of-place version of <a class="reference internal" href="#torch.Tensor.masked_scatter_" title="torch.Tensor.masked_scatter_"><code>torch.Tensor.masked_scatter_()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.masked_fill_">
<code>masked_fill_(mask, value)</code> </dt> <dd>
<p>Fills elements of <code>self</code> tensor with <code>value</code> where <code>mask</code> is True. The shape of <code>mask</code> must be <a class="reference internal" href="https://pytorch.org/docs/1.8.0/notes/broadcasting.html#broadcasting-semantics"><span class="std std-ref">broadcastable</span></a> with the shape of the underlying tensor.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>mask</strong> (<em>BoolTensor</em>) – the boolean mask</li> <li>
<strong>value</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a>) – the value to fill in with</li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.masked_fill">
<code>masked_fill(mask, value) → Tensor</code> </dt> <dd>
<p>Out-of-place version of <a class="reference internal" href="#torch.Tensor.masked_fill_" title="torch.Tensor.masked_fill_"><code>torch.Tensor.masked_fill_()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.masked_select">
<code>masked_select(mask) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.masked_select#torch.masked_select" title="torch.masked_select"><code>torch.masked_select()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.matmul">
<code>matmul(tensor2) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.matmul#torch.matmul" title="torch.matmul"><code>torch.matmul()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.matrix_power">
<code>matrix_power(n) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.matrix_power#torch.matrix_power" title="torch.matrix_power"><code>torch.matrix_power()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.matrix_exp">
<code>matrix_exp() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.matrix_exp#torch.matrix_exp" title="torch.matrix_exp"><code>torch.matrix_exp()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.max">
<code>max(dim=None, keepdim=False) -&gt; Tensor or (Tensor, Tensor)</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.max#torch.max" title="torch.max"><code>torch.max()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.maximum">
<code>maximum(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.maximum#torch.maximum" title="torch.maximum"><code>torch.maximum()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.mean">
<code>mean(dim=None, keepdim=False) -&gt; Tensor or (Tensor, Tensor)</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.mean#torch.mean" title="torch.mean"><code>torch.mean()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.median">
<code>median(dim=None, keepdim=False) -&gt; (Tensor, LongTensor)</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.median#torch.median" title="torch.median"><code>torch.median()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.nanmedian">
<code>nanmedian(dim=None, keepdim=False) -&gt; (Tensor, LongTensor)</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.nanmedian#torch.nanmedian" title="torch.nanmedian"><code>torch.nanmedian()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.min">
<code>min(dim=None, keepdim=False) -&gt; Tensor or (Tensor, Tensor)</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.min#torch.min" title="torch.min"><code>torch.min()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.minimum">
<code>minimum(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.minimum#torch.minimum" title="torch.minimum"><code>torch.minimum()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.mm">
<code>mm(mat2) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.mm#torch.mm" title="torch.mm"><code>torch.mm()</code></a></p> </dd>
</dl> <dl class="method"> <dt>
<code>smm(mat) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="sparse#torch.smm" title="torch.smm"><code>torch.smm()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.mode">
<code>mode(dim=None, keepdim=False) -&gt; (Tensor, LongTensor)</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.mode#torch.mode" title="torch.mode"><code>torch.mode()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.movedim">
<code>movedim(source, destination) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.movedim#torch.movedim" title="torch.movedim"><code>torch.movedim()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.moveaxis">
<code>moveaxis(source, destination) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.moveaxis#torch.moveaxis" title="torch.moveaxis"><code>torch.moveaxis()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.msort">
<code>msort() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.msort#torch.msort" title="torch.msort"><code>torch.msort()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.mul">
<code>mul(value) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.mul#torch.mul" title="torch.mul"><code>torch.mul()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.mul_">
<code>mul_(value) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.mul" title="torch.Tensor.mul"><code>mul()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.multiply">
<code>multiply(value) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.multiply#torch.multiply" title="torch.multiply"><code>torch.multiply()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.multiply_">
<code>multiply_(value) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.multiply" title="torch.Tensor.multiply"><code>multiply()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.multinomial">
<code>multinomial(num_samples, replacement=False, *, generator=None) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.multinomial#torch.multinomial" title="torch.multinomial"><code>torch.multinomial()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.mv">
<code>mv(vec) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.mv#torch.mv" title="torch.mv"><code>torch.mv()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.mvlgamma">
<code>mvlgamma(p) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.mvlgamma#torch.mvlgamma" title="torch.mvlgamma"><code>torch.mvlgamma()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.mvlgamma_">
<code>mvlgamma_(p) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.mvlgamma" title="torch.Tensor.mvlgamma"><code>mvlgamma()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.nansum">
<code>nansum(dim=None, keepdim=False, dtype=None) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.nansum#torch.nansum" title="torch.nansum"><code>torch.nansum()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.narrow">
<code>narrow(dimension, start, length) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.narrow#torch.narrow" title="torch.narrow"><code>torch.narrow()</code></a></p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; x = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
&gt;&gt;&gt; x.narrow(0, 0, 2)
tensor([[ 1,  2,  3],
        [ 4,  5,  6]])
&gt;&gt;&gt; x.narrow(1, 1, 2)
tensor([[ 2,  3],
        [ 5,  6],
        [ 8,  9]])
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.narrow_copy">
<code>narrow_copy(dimension, start, length) → Tensor</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#torch.Tensor.narrow" title="torch.Tensor.narrow"><code>Tensor.narrow()</code></a> except returning a copy rather than shared storage. This is primarily for sparse tensors, which do not have a shared-storage narrow method. Calling <code>`narrow_copy</code> with <code>`dimemsion &gt; self.sparse_dim()`</code> will return a copy with the relevant dense dimension narrowed, and <code>`self.shape`</code> updated accordingly.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.ndimension">
<code>ndimension() → int</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#torch.Tensor.dim" title="torch.Tensor.dim"><code>dim()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.nan_to_num">
<code>nan_to_num(nan=0.0, posinf=None, neginf=None) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.nan_to_num#torch.nan_to_num" title="torch.nan_to_num"><code>torch.nan_to_num()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.nan_to_num_">
<code>nan_to_num_(nan=0.0, posinf=None, neginf=None) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.nan_to_num" title="torch.Tensor.nan_to_num"><code>nan_to_num()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.ne">
<code>ne(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.ne#torch.ne" title="torch.ne"><code>torch.ne()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.ne_">
<code>ne_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.ne" title="torch.Tensor.ne"><code>ne()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.not_equal">
<code>not_equal(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.not_equal#torch.not_equal" title="torch.not_equal"><code>torch.not_equal()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.not_equal_">
<code>not_equal_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.not_equal" title="torch.Tensor.not_equal"><code>not_equal()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.neg">
<code>neg() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.neg#torch.neg" title="torch.neg"><code>torch.neg()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.neg_">
<code>neg_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.neg" title="torch.Tensor.neg"><code>neg()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.negative">
<code>negative() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.negative#torch.negative" title="torch.negative"><code>torch.negative()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.negative_">
<code>negative_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.negative" title="torch.Tensor.negative"><code>negative()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.nelement">
<code>nelement() → int</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#torch.Tensor.numel" title="torch.Tensor.numel"><code>numel()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.nextafter">
<code>nextafter(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.nextafter#torch.nextafter" title="torch.nextafter"><code>torch.nextafter()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.nextafter_">
<code>nextafter_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.nextafter" title="torch.Tensor.nextafter"><code>nextafter()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.nonzero">
<code>nonzero() → LongTensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.nonzero#torch.nonzero" title="torch.nonzero"><code>torch.nonzero()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.norm">
<code>norm(p='fro', dim=None, keepdim=False, dtype=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/tensor.html#Tensor.norm"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>See <a class="reference internal" href="generated/torch.norm#torch.norm" title="torch.norm"><code>torch.norm()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.normal_">
<code>normal_(mean=0, std=1, *, generator=None) → Tensor</code> </dt> <dd>
<p>Fills <code>self</code> tensor with elements samples from the normal distribution parameterized by <a class="reference internal" href="generated/torch.mean#torch.mean" title="torch.mean"><code>mean</code></a> and <a class="reference internal" href="generated/torch.std#torch.std" title="torch.std"><code>std</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.numel">
<code>numel() → int</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.numel#torch.numel" title="torch.numel"><code>torch.numel()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.numpy">
<code>numpy() → numpy.ndarray</code> </dt> <dd>
<p>Returns <code>self</code> tensor as a NumPy <code>ndarray</code>. This tensor and the returned <code>ndarray</code> share the same underlying storage. Changes to <code>self</code> tensor will be reflected in the <code>ndarray</code> and vice versa.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.orgqr">
<code>orgqr(input2) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.orgqr#torch.orgqr" title="torch.orgqr"><code>torch.orgqr()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.ormqr">
<code>ormqr(input2, input3, left=True, transpose=False) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.ormqr#torch.ormqr" title="torch.ormqr"><code>torch.ormqr()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.outer">
<code>outer(vec2) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.outer#torch.outer" title="torch.outer"><code>torch.outer()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.permute">
<code>permute(*dims) → Tensor</code> </dt> <dd>
<p>Returns a view of the original tensor with its dimensions permuted.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>*dims</strong> (<em>int...</em>) – The desired ordering of dimensions</p> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; x = torch.randn(2, 3, 5)
&gt;&gt;&gt; x.size()
torch.Size([2, 3, 5])
&gt;&gt;&gt; x.permute(2, 0, 1).size()
torch.Size([5, 2, 3])
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.pin_memory">
<code>pin_memory() → Tensor</code> </dt> <dd>
<p>Copies the tensor to pinned memory, if it’s not already pinned.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.pinverse">
<code>pinverse() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.pinverse#torch.pinverse" title="torch.pinverse"><code>torch.pinverse()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.polygamma">
<code>polygamma(n) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.polygamma#torch.polygamma" title="torch.polygamma"><code>torch.polygamma()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.polygamma_">
<code>polygamma_(n) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.polygamma" title="torch.Tensor.polygamma"><code>polygamma()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.pow">
<code>pow(exponent) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.pow#torch.pow" title="torch.pow"><code>torch.pow()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.pow_">
<code>pow_(exponent) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.pow" title="torch.Tensor.pow"><code>pow()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.prod">
<code>prod(dim=None, keepdim=False, dtype=None) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.prod#torch.prod" title="torch.prod"><code>torch.prod()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.put_">
<code>put_(indices, tensor, accumulate=False) → Tensor</code> </dt> <dd>
<p>Copies the elements from <a class="reference internal" href="generated/torch.tensor#torch.tensor" title="torch.tensor"><code>tensor</code></a> into the positions specified by indices. For the purpose of indexing, the <code>self</code> tensor is treated as if it were a 1-D tensor.</p> <p>If <code>accumulate</code> is <code>True</code>, the elements in <a class="reference internal" href="generated/torch.tensor#torch.tensor" title="torch.tensor"><code>tensor</code></a> are added to <code>self</code>. If accumulate is <code>False</code>, the behavior is undefined if indices contain duplicate elements.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>indices</strong> (<em>LongTensor</em>) – the indices into self</li> <li>
<strong>tensor</strong> (<a class="reference internal" href="#torch.Tensor" title="torch.Tensor">Tensor</a>) – the tensor containing values to copy from</li> <li>
<strong>accumulate</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – whether to accumulate into self</li> </ul> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; src = torch.tensor([[4, 3, 5],
...                     [6, 7, 8]])
&gt;&gt;&gt; src.put_(torch.tensor([1, 3]), torch.tensor([9, 10]))
tensor([[  4,   9,   5],
        [ 10,   7,   8]])
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.qr">
<code>qr(some=True) -&gt; (Tensor, Tensor)</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.qr#torch.qr" title="torch.qr"><code>torch.qr()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.qscheme">
<code>qscheme() → torch.qscheme</code> </dt> <dd>
<p>Returns the quantization scheme of a given QTensor.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.quantile">
<code>quantile(q, dim=None, keepdim=False) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.quantile#torch.quantile" title="torch.quantile"><code>torch.quantile()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.nanquantile">
<code>nanquantile(q, dim=None, keepdim=False) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.nanquantile#torch.nanquantile" title="torch.nanquantile"><code>torch.nanquantile()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.q_scale">
<code>q_scale() → float</code> </dt> <dd>
<p>Given a Tensor quantized by linear(affine) quantization, returns the scale of the underlying quantizer().</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.q_zero_point">
<code>q_zero_point() → int</code> </dt> <dd>
<p>Given a Tensor quantized by linear(affine) quantization, returns the zero_point of the underlying quantizer().</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.q_per_channel_scales">
<code>q_per_channel_scales() → Tensor</code> </dt> <dd>
<p>Given a Tensor quantized by linear (affine) per-channel quantization, returns a Tensor of scales of the underlying quantizer. It has the number of elements that matches the corresponding dimensions (from q_per_channel_axis) of the tensor.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.q_per_channel_zero_points">
<code>q_per_channel_zero_points() → Tensor</code> </dt> <dd>
<p>Given a Tensor quantized by linear (affine) per-channel quantization, returns a tensor of zero_points of the underlying quantizer. It has the number of elements that matches the corresponding dimensions (from q_per_channel_axis) of the tensor.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.q_per_channel_axis">
<code>q_per_channel_axis() → int</code> </dt> <dd>
<p>Given a Tensor quantized by linear (affine) per-channel quantization, returns the index of dimension on which per-channel quantization is applied.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.rad2deg">
<code>rad2deg() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.rad2deg#torch.rad2deg" title="torch.rad2deg"><code>torch.rad2deg()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.random_">
<code>random_(from=0, to=None, *, generator=None) → Tensor</code> </dt> <dd>
<p>Fills <code>self</code> tensor with numbers sampled from the discrete uniform distribution over <code>[from, to - 1]</code>. If not specified, the values are usually only bounded by <code>self</code> tensor’s data type. However, for floating point types, if unspecified, range will be <code>[0, 2^mantissa]</code> to ensure that every value is representable. For example, <code>torch.tensor(1, dtype=torch.double).random_()</code> will be uniform in <code>[0, 2^53]</code>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.ravel">
<code>ravel(input) → Tensor</code> </dt> <dd>
<p>see <a class="reference internal" href="generated/torch.ravel#torch.ravel" title="torch.ravel"><code>torch.ravel()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.reciprocal">
<code>reciprocal() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.reciprocal#torch.reciprocal" title="torch.reciprocal"><code>torch.reciprocal()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.reciprocal_">
<code>reciprocal_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.reciprocal" title="torch.Tensor.reciprocal"><code>reciprocal()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.record_stream">
<code>record_stream(stream)</code> </dt> <dd>
<p>Ensures that the tensor memory is not reused for another tensor until all current work queued on <code>stream</code> are complete.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The caching allocator is aware of only the stream where a tensor was allocated. Due to the awareness, it already correctly manages the life cycle of tensors on only one stream. But if a tensor is used on a stream different from the stream of origin, the allocator might reuse the memory unexpectedly. Calling this method lets the allocator know which streams have used the tensor.</p> </div> </dd>
</dl> <dl class="method"> <dt>
<code>register_hook(hook)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/tensor.html#Tensor.register_hook"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Registers a backward hook.</p> <p>The hook will be called every time a gradient with respect to the Tensor is computed. The hook should have the following signature:</p> <pre data-language="python">hook(grad) -&gt; Tensor or None
</pre> <p>The hook should not modify its argument, but it can optionally return a new gradient which will be used in place of <a class="reference internal" href="autograd#torch.Tensor.grad" title="torch.Tensor.grad"><code>grad</code></a>.</p> <p>This function returns a handle with a method <code>handle.remove()</code> that removes the hook from the module.</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; v = torch.tensor([0., 0., 0.], requires_grad=True)
&gt;&gt;&gt; h = v.register_hook(lambda grad: grad * 2)  # double the gradient
&gt;&gt;&gt; v.backward(torch.tensor([1., 2., 3.]))
&gt;&gt;&gt; v.grad

 2
 4
 6
[torch.FloatTensor of size (3,)]

&gt;&gt;&gt; h.remove()  # removes the hook
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.remainder">
<code>remainder(divisor) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.remainder#torch.remainder" title="torch.remainder"><code>torch.remainder()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.remainder_">
<code>remainder_(divisor) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.remainder" title="torch.Tensor.remainder"><code>remainder()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.renorm">
<code>renorm(p, dim, maxnorm) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.renorm#torch.renorm" title="torch.renorm"><code>torch.renorm()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.renorm_">
<code>renorm_(p, dim, maxnorm) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.renorm" title="torch.Tensor.renorm"><code>renorm()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.repeat">
<code>repeat(*sizes) → Tensor</code> </dt> <dd>
<p>Repeats this tensor along the specified dimensions.</p> <p>Unlike <a class="reference internal" href="#torch.Tensor.expand" title="torch.Tensor.expand"><code>expand()</code></a>, this function copies the tensor’s data.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><a class="reference internal" href="#torch.Tensor.repeat" title="torch.Tensor.repeat"><code>repeat()</code></a> behaves differently from <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.repeat.html">numpy.repeat</a>, but is more similar to <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.tile.html">numpy.tile</a>. For the operator similar to <code>numpy.repeat</code>, see <a class="reference internal" href="generated/torch.repeat_interleave#torch.repeat_interleave" title="torch.repeat_interleave"><code>torch.repeat_interleave()</code></a>.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>sizes</strong> (<em>torch.Size</em><em> or </em><em>int...</em>) – The number of times to repeat this tensor along each dimension</p> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; x = torch.tensor([1, 2, 3])
&gt;&gt;&gt; x.repeat(4, 2)
tensor([[ 1,  2,  3,  1,  2,  3],
        [ 1,  2,  3,  1,  2,  3],
        [ 1,  2,  3,  1,  2,  3],
        [ 1,  2,  3,  1,  2,  3]])
&gt;&gt;&gt; x.repeat(4, 2, 1).size()
torch.Size([4, 2, 3])
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.repeat_interleave">
<code>repeat_interleave(repeats, dim=None) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.repeat_interleave#torch.repeat_interleave" title="torch.repeat_interleave"><code>torch.repeat_interleave()</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt>
<code>requires_grad</code> </dt> <dd>
<p>Is <code>True</code> if gradients need to be computed for this Tensor, <code>False</code> otherwise.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The fact that gradients need to be computed for a Tensor do not mean that the <a class="reference internal" href="autograd#torch.Tensor.grad" title="torch.Tensor.grad"><code>grad</code></a> attribute will be populated, see <a class="reference internal" href="autograd#torch.Tensor.is_leaf" title="torch.Tensor.is_leaf"><code>is_leaf</code></a> for more details.</p> </div> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.requires_grad_">
<code>requires_grad_(requires_grad=True) → Tensor</code> </dt> <dd>
<p>Change if autograd should record operations on this tensor: sets this tensor’s <a class="reference internal" href="autograd#torch.Tensor.requires_grad" title="torch.Tensor.requires_grad"><code>requires_grad</code></a> attribute in-place. Returns this tensor.</p> <p><a class="reference internal" href="#torch.Tensor.requires_grad_" title="torch.Tensor.requires_grad_"><code>requires_grad_()</code></a>’s main use case is to tell autograd to begin recording operations on a Tensor <code>tensor</code>. If <code>tensor</code> has <code>requires_grad=False</code> (because it was obtained through a DataLoader, or required preprocessing or initialization), <code>tensor.requires_grad_()</code> makes it so that autograd will begin to record operations on <code>tensor</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>requires_grad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – If autograd should record operations on this tensor. Default: <code>True</code>.</p> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; # Let's say we want to preprocess some saved weights and use
&gt;&gt;&gt; # the result as new weights.
&gt;&gt;&gt; saved_weights = [0.1, 0.2, 0.3, 0.25]
&gt;&gt;&gt; loaded_weights = torch.tensor(saved_weights)
&gt;&gt;&gt; weights = preprocess(loaded_weights)  # some function
&gt;&gt;&gt; weights
tensor([-0.5503,  0.4926, -2.1158, -0.8303])

&gt;&gt;&gt; # Now, start to record operations done to weights
&gt;&gt;&gt; weights.requires_grad_()
&gt;&gt;&gt; out = weights.pow(2).sum()
&gt;&gt;&gt; out.backward()
&gt;&gt;&gt; weights.grad
tensor([-1.1007,  0.9853, -4.2316, -1.6606])
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.reshape">
<code>reshape(*shape) → Tensor</code> </dt> <dd>
<p>Returns a tensor with the same data and number of elements as <code>self</code> but with the specified shape. This method returns a view if <code>shape</code> is compatible with the current shape. See <a class="reference internal" href="#torch.Tensor.view" title="torch.Tensor.view"><code>torch.Tensor.view()</code></a> on when it is possible to return a view.</p> <p>See <a class="reference internal" href="generated/torch.reshape#torch.reshape" title="torch.reshape"><code>torch.reshape()</code></a></p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>shape</strong> (<em>tuple of python:ints</em><em> or </em><em>int...</em>) – the desired shape</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.reshape_as">
<code>reshape_as(other) → Tensor</code> </dt> <dd>
<p>Returns this tensor as the same shape as <code>other</code>. <code>self.reshape_as(other)</code> is equivalent to <code>self.reshape(other.sizes())</code>. This method returns a view if <code>other.sizes()</code> is compatible with the current shape. See <a class="reference internal" href="#torch.Tensor.view" title="torch.Tensor.view"><code>torch.Tensor.view()</code></a> on when it is possible to return a view.</p> <p>Please see <a class="reference internal" href="generated/torch.reshape#torch.reshape" title="torch.reshape"><code>reshape()</code></a> for more information about <code>reshape</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>other</strong> (<a class="reference internal" href="#torch.Tensor" title="torch.Tensor"><code>torch.Tensor</code></a>) – The result tensor has the same shape as <code>other</code>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.resize_">
<code>resize_(*sizes, memory_format=torch.contiguous_format) → Tensor</code> </dt> <dd>
<p>Resizes <code>self</code> tensor to the specified size. If the number of elements is larger than the current storage size, then the underlying storage is resized to fit the new number of elements. If the number of elements is smaller, the underlying storage is not changed. Existing elements are preserved but any new memory is uninitialized.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This is a low-level method. The storage is reinterpreted as C-contiguous, ignoring the current strides (unless the target size equals the current size, in which case the tensor is left unchanged). For most purposes, you will instead want to use <a class="reference internal" href="#torch.Tensor.view" title="torch.Tensor.view"><code>view()</code></a>, which checks for contiguity, or <a class="reference internal" href="#torch.Tensor.reshape" title="torch.Tensor.reshape"><code>reshape()</code></a>, which copies data if needed. To change the size in-place with custom strides, see <a class="reference internal" href="#torch.Tensor.set_" title="torch.Tensor.set_"><code>set_()</code></a>.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>sizes</strong> (<em>torch.Size</em><em> or </em><em>int...</em>) – the desired size</li> <li>
<strong>memory_format</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.memory_format" title="torch.torch.memory_format"><code>torch.memory_format</code></a>, optional) – the desired memory format of Tensor. Default: <code>torch.contiguous_format</code>. Note that memory format of <code>self</code> is going to be unaffected if <code>self.size()</code> matches <code>sizes</code>.</li> </ul> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; x = torch.tensor([[1, 2], [3, 4], [5, 6]])
&gt;&gt;&gt; x.resize_(2, 2)
tensor([[ 1,  2],
        [ 3,  4]])
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.resize_as_">
<code>resize_as_(tensor, memory_format=torch.contiguous_format) → Tensor</code> </dt> <dd>
<p>Resizes the <code>self</code> tensor to be the same size as the specified <a class="reference internal" href="generated/torch.tensor#torch.tensor" title="torch.tensor"><code>tensor</code></a>. This is equivalent to <code>self.resize_(tensor.size())</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>memory_format</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.memory_format" title="torch.torch.memory_format"><code>torch.memory_format</code></a>, optional) – the desired memory format of Tensor. Default: <code>torch.contiguous_format</code>. Note that memory format of <code>self</code> is going to be unaffected if <code>self.size()</code> matches <code>tensor.size()</code>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt>
<code>retain_grad()</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/tensor.html#Tensor.retain_grad"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Enables .grad attribute for non-leaf Tensors.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.roll">
<code>roll(shifts, dims) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.roll#torch.roll" title="torch.roll"><code>torch.roll()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.rot90">
<code>rot90(k, dims) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.rot90#torch.rot90" title="torch.rot90"><code>torch.rot90()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.round">
<code>round() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.round#torch.round" title="torch.round"><code>torch.round()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.round_">
<code>round_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.round" title="torch.Tensor.round"><code>round()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.rsqrt">
<code>rsqrt() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.rsqrt#torch.rsqrt" title="torch.rsqrt"><code>torch.rsqrt()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.rsqrt_">
<code>rsqrt_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.rsqrt" title="torch.Tensor.rsqrt"><code>rsqrt()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.scatter">
<code>scatter(dim, index, src) → Tensor</code> </dt> <dd>
<p>Out-of-place version of <a class="reference internal" href="#torch.Tensor.scatter_" title="torch.Tensor.scatter_"><code>torch.Tensor.scatter_()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.scatter_">
<code>scatter_(dim, index, src, reduce=None) → Tensor</code> </dt> <dd>
<p>Writes all values from the tensor <code>src</code> into <code>self</code> at the indices specified in the <code>index</code> tensor. For each value in <code>src</code>, its output index is specified by its index in <code>src</code> for <code>dimension != dim</code> and by the corresponding value in <code>index</code> for <code>dimension = dim</code>.</p> <p>For a 3-D tensor, <code>self</code> is updated as:</p> <pre data-language="python">self[index[i][j][k]][j][k] = src[i][j][k]  # if dim == 0
self[i][index[i][j][k]][k] = src[i][j][k]  # if dim == 1
self[i][j][index[i][j][k]] = src[i][j][k]  # if dim == 2
</pre> <p>This is the reverse operation of the manner described in <a class="reference internal" href="#torch.Tensor.gather" title="torch.Tensor.gather"><code>gather()</code></a>.</p> <p><code>self</code>, <code>index</code> and <code>src</code> (if it is a Tensor) should all have the same number of dimensions. It is also required that <code>index.size(d) &lt;= src.size(d)</code> for all dimensions <code>d</code>, and that <code>index.size(d) &lt;= self.size(d)</code> for all dimensions <code>d != dim</code>. Note that <code>index</code> and <code>src</code> do not broadcast.</p> <p>Moreover, as for <a class="reference internal" href="#torch.Tensor.gather" title="torch.Tensor.gather"><code>gather()</code></a>, the values of <code>index</code> must be between <code>0</code> and <code>self.size(dim) - 1</code> inclusive.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>When indices are not unique, the behavior is non-deterministic (one of the values from <code>src</code> will be picked arbitrarily) and the gradient will be incorrect (it will be propagated to all locations in the source that correspond to the same index)!</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The backward pass is implemented only for <code>src.shape == index.shape</code>.</p> </div> <p>Additionally accepts an optional <code>reduce</code> argument that allows specification of an optional reduction operation, which is applied to all values in the tensor <code>src</code> into <code>self</code> at the indicies specified in the <code>index</code>. For each value in <code>src</code>, the reduction operation is applied to an index in <code>self</code> which is specified by its index in <code>src</code> for <code>dimension != dim</code> and by the corresponding value in <code>index</code> for <code>dimension = dim</code>.</p> <p>Given a 3-D tensor and reduction using the multiplication operation, <code>self</code> is updated as:</p> <pre data-language="python">self[index[i][j][k]][j][k] *= src[i][j][k]  # if dim == 0
self[i][index[i][j][k]][k] *= src[i][j][k]  # if dim == 1
self[i][j][index[i][j][k]] *= src[i][j][k]  # if dim == 2
</pre> <p>Reducing with the addition operation is the same as using <a class="reference internal" href="#torch.Tensor.scatter_add_" title="torch.Tensor.scatter_add_"><code>scatter_add_()</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – the axis along which to index</li> <li>
<strong>index</strong> (<em>LongTensor</em>) – the indices of elements to scatter, can be either empty or of the same dimensionality as <code>src</code>. When empty, the operation returns <code>self</code> unchanged.</li> <li>
<strong>src</strong> (<a class="reference internal" href="#torch.Tensor" title="torch.Tensor">Tensor</a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a>) – the source element(s) to scatter.</li> <li>
<strong>reduce</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><em>optional</em>) – reduction operation to apply, can be either <code>'add'</code> or <code>'multiply'</code>.</li> </ul> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; src = torch.arange(1, 11).reshape((2, 5))
&gt;&gt;&gt; src
tensor([[ 1,  2,  3,  4,  5],
        [ 6,  7,  8,  9, 10]])
&gt;&gt;&gt; index = torch.tensor([[0, 1, 2, 0]])
&gt;&gt;&gt; torch.zeros(3, 5, dtype=src.dtype).scatter_(0, index, src)
tensor([[1, 0, 0, 4, 0],
        [0, 2, 0, 0, 0],
        [0, 0, 3, 0, 0]])
&gt;&gt;&gt; index = torch.tensor([[0, 1, 2], [0, 1, 4]])
&gt;&gt;&gt; torch.zeros(3, 5, dtype=src.dtype).scatter_(1, index, src)
tensor([[1, 2, 3, 0, 0],
        [6, 7, 0, 0, 8],
        [0, 0, 0, 0, 0]])

&gt;&gt;&gt; torch.full((2, 4), 2.).scatter_(1, torch.tensor([[2], [3]]),
...            1.23, reduce='multiply')
tensor([[2.0000, 2.0000, 2.4600, 2.0000],
        [2.0000, 2.0000, 2.0000, 2.4600]])
&gt;&gt;&gt; torch.full((2, 4), 2.).scatter_(1, torch.tensor([[2], [3]]),
...            1.23, reduce='add')
tensor([[2.0000, 2.0000, 3.2300, 2.0000],
        [2.0000, 2.0000, 2.0000, 3.2300]])
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.scatter_add_">
<code>scatter_add_(dim, index, src) → Tensor</code> </dt> <dd>
<p>Adds all values from the tensor <code>other</code> into <code>self</code> at the indices specified in the <code>index</code> tensor in a similar fashion as <a class="reference internal" href="#torch.Tensor.scatter_" title="torch.Tensor.scatter_"><code>scatter_()</code></a>. For each value in <code>src</code>, it is added to an index in <code>self</code> which is specified by its index in <code>src</code> for <code>dimension != dim</code> and by the corresponding value in <code>index</code> for <code>dimension = dim</code>.</p> <p>For a 3-D tensor, <code>self</code> is updated as:</p> <pre data-language="python">self[index[i][j][k]][j][k] += src[i][j][k]  # if dim == 0
self[i][index[i][j][k]][k] += src[i][j][k]  # if dim == 1
self[i][j][index[i][j][k]] += src[i][j][k]  # if dim == 2
</pre> <p><code>self</code>, <code>index</code> and <code>src</code> should have same number of dimensions. It is also required that <code>index.size(d) &lt;= src.size(d)</code> for all dimensions <code>d</code>, and that <code>index.size(d) &lt;= self.size(d)</code> for all dimensions <code>d != dim</code>. Note that <code>index</code> and <code>src</code> do not broadcast.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This operation may behave nondeterministically when given tensors on a CUDA device. See <a class="reference internal" href="https://pytorch.org/docs/1.8.0/notes/randomness.html"><span class="doc">Reproducibility</span></a> for more information.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The backward pass is implemented only for <code>src.shape == index.shape</code>.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – the axis along which to index</li> <li>
<strong>index</strong> (<em>LongTensor</em>) – the indices of elements to scatter and add, can be either empty or of the same dimensionality as <code>src</code>. When empty, the operation returns <code>self</code> unchanged.</li> <li>
<strong>src</strong> (<a class="reference internal" href="#torch.Tensor" title="torch.Tensor">Tensor</a>) – the source elements to scatter and add</li> </ul> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; src = torch.ones((2, 5))
&gt;&gt;&gt; index = torch.tensor([[0, 1, 2, 0, 0]])
&gt;&gt;&gt; torch.zeros(3, 5, dtype=src.dtype).scatter_add_(0, index, src)
tensor([[1., 0., 0., 1., 1.],
        [0., 1., 0., 0., 0.],
        [0., 0., 1., 0., 0.]])
&gt;&gt;&gt; index = torch.tensor([[0, 1, 2, 0, 0], [0, 1, 2, 2, 2]])
&gt;&gt;&gt; torch.zeros(3, 5, dtype=src.dtype).scatter_add_(0, index, src)
tensor([[2., 0., 0., 1., 1.],
        [0., 2., 0., 0., 0.],
        [0., 0., 2., 1., 1.]])
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.scatter_add">
<code>scatter_add(dim, index, src) → Tensor</code> </dt> <dd>
<p>Out-of-place version of <a class="reference internal" href="#torch.Tensor.scatter_add_" title="torch.Tensor.scatter_add_"><code>torch.Tensor.scatter_add_()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.select">
<code>select(dim, index) → Tensor</code> </dt> <dd>
<p>Slices the <code>self</code> tensor along the selected dimension at the given index. This function returns a view of the original tensor with the given dimension removed.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – the dimension to slice</li> <li>
<strong>index</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – the index to select with</li> </ul> </dd> </dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p><a class="reference internal" href="#torch.Tensor.select" title="torch.Tensor.select"><code>select()</code></a> is equivalent to slicing. For example, <code>tensor.select(0, index)</code> is equivalent to <code>tensor[index]</code> and <code>tensor.select(2, index)</code> is equivalent to <code>tensor[:,:,index]</code>.</p> </div> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.set_">
<code>set_(source=None, storage_offset=0, size=None, stride=None) → Tensor</code> </dt> <dd>
<p>Sets the underlying storage, size, and strides. If <code>source</code> is a tensor, <code>self</code> tensor will share the same storage and have the same size and strides as <code>source</code>. Changes to elements in one tensor will be reflected in the other.</p> <p>If <code>source</code> is a <code>Storage</code>, the method sets the underlying storage, offset, size, and stride.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>source</strong> (<a class="reference internal" href="#torch.Tensor" title="torch.Tensor">Tensor</a><em> or </em><em>Storage</em>) – the tensor or storage to use</li> <li>
<strong>storage_offset</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><em>optional</em>) – the offset in the storage</li> <li>
<strong>size</strong> (<em>torch.Size</em><em>, </em><em>optional</em>) – the desired size. Defaults to the size of the source.</li> <li>
<strong>stride</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.9)">tuple</a><em>, </em><em>optional</em>) – the desired stride. Defaults to C-contiguous strides.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.share_memory_">
<code>share_memory_()</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/tensor.html#Tensor.share_memory_"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Moves the underlying storage to shared memory.</p> <p>This is a no-op if the underlying storage is already in shared memory and for CUDA tensors. Tensors in shared memory cannot be resized.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.short">
<code>short(memory_format=torch.preserve_format) → Tensor</code> </dt> <dd>
<p><code>self.short()</code> is equivalent to <code>self.to(torch.int16)</code>. See <a class="reference internal" href="#torch.Tensor.to" title="torch.Tensor.to"><code>to()</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>memory_format</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.memory_format" title="torch.torch.memory_format"><code>torch.memory_format</code></a>, optional) – the desired memory format of returned Tensor. Default: <code>torch.preserve_format</code>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.sigmoid">
<code>sigmoid() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.sigmoid#torch.sigmoid" title="torch.sigmoid"><code>torch.sigmoid()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.sigmoid_">
<code>sigmoid_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.sigmoid" title="torch.Tensor.sigmoid"><code>sigmoid()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.sign">
<code>sign() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.sign#torch.sign" title="torch.sign"><code>torch.sign()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.sign_">
<code>sign_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.sign" title="torch.Tensor.sign"><code>sign()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.signbit">
<code>signbit() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.signbit#torch.signbit" title="torch.signbit"><code>torch.signbit()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.sgn">
<code>sgn() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.sgn#torch.sgn" title="torch.sgn"><code>torch.sgn()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.sgn_">
<code>sgn_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.sgn" title="torch.Tensor.sgn"><code>sgn()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.sin">
<code>sin() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.sin#torch.sin" title="torch.sin"><code>torch.sin()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.sin_">
<code>sin_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.sin" title="torch.Tensor.sin"><code>sin()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.sinc">
<code>sinc() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.sinc#torch.sinc" title="torch.sinc"><code>torch.sinc()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.sinc_">
<code>sinc_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.sinc" title="torch.Tensor.sinc"><code>sinc()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.sinh">
<code>sinh() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.sinh#torch.sinh" title="torch.sinh"><code>torch.sinh()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.sinh_">
<code>sinh_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.sinh" title="torch.Tensor.sinh"><code>sinh()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.asinh">
<code>asinh() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.asinh#torch.asinh" title="torch.asinh"><code>torch.asinh()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.asinh_">
<code>asinh_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.asinh" title="torch.Tensor.asinh"><code>asinh()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.arcsinh">
<code>arcsinh() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.arcsinh#torch.arcsinh" title="torch.arcsinh"><code>torch.arcsinh()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.arcsinh_">
<code>arcsinh_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.arcsinh" title="torch.Tensor.arcsinh"><code>arcsinh()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.size">
<code>size() → torch.Size</code> </dt> <dd>
<p>Returns the size of the <code>self</code> tensor. The returned value is a subclass of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.9)"><code>tuple</code></a>.</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; torch.empty(3, 4, 5).size()
torch.Size([3, 4, 5])
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.slogdet">
<code>slogdet() -&gt; (Tensor, Tensor)</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.slogdet#torch.slogdet" title="torch.slogdet"><code>torch.slogdet()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.solve">
<code>solve(A) → Tensor, Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.solve#torch.solve" title="torch.solve"><code>torch.solve()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.sort">
<code>sort(dim=-1, descending=False) -&gt; (Tensor, LongTensor)</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.sort#torch.sort" title="torch.sort"><code>torch.sort()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.split">
<code>split(split_size, dim=0)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/tensor.html#Tensor.split"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>See <a class="reference internal" href="generated/torch.split#torch.split" title="torch.split"><code>torch.split()</code></a></p> </dd>
</dl> <dl class="method"> <dt>
<code>sparse_mask(mask) → Tensor</code> </dt> <dd>
<p>Returns a new <a class="reference internal" href="sparse#sparse-docs"><span class="std std-ref">sparse tensor</span></a> with values from a strided tensor <code>self</code> filtered by the indices of the sparse tensor <code>mask</code>. The values of <code>mask</code> sparse tensor are ignored. <code>self</code> and <code>mask</code> tensors must have the same shape.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The returned sparse tensor has the same indices as the sparse tensor <code>mask</code>, even when the corresponding values in <code>self</code> are zeros.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>mask</strong> (<a class="reference internal" href="#torch.Tensor" title="torch.Tensor">Tensor</a>) – a sparse tensor whose indices are used as a filter</p> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; nse = 5
&gt;&gt;&gt; dims = (5, 5, 2, 2)
&gt;&gt;&gt; I = torch.cat([torch.randint(0, dims[0], size=(nse,)),
...                torch.randint(0, dims[1], size=(nse,))], 0).reshape(2, nse)
&gt;&gt;&gt; V = torch.randn(nse, dims[2], dims[3])
&gt;&gt;&gt; S = torch.sparse_coo_tensor(I, V, dims).coalesce()
&gt;&gt;&gt; D = torch.randn(dims)
&gt;&gt;&gt; D.sparse_mask(S)
tensor(indices=tensor([[0, 0, 0, 2],
                       [0, 1, 4, 3]]),
       values=tensor([[[ 1.6550,  0.2397],
                       [-0.1611, -0.0779]],

                      [[ 0.2326, -1.0558],
                       [ 1.4711,  1.9678]],

                      [[-0.5138, -0.0411],
                       [ 1.9417,  0.5158]],

                      [[ 0.0793,  0.0036],
                       [-0.2569, -0.1055]]]),
       size=(5, 5, 2, 2), nnz=4, layout=torch.sparse_coo)
</pre> </dd>
</dl> <dl class="method"> <dt>
<code>sparse_dim() → int</code> </dt> <dd>
<p>Return the number of sparse dimensions in a <a class="reference internal" href="sparse#sparse-docs"><span class="std std-ref">sparse tensor</span></a> <code>self</code>.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Throws an error if <code>self</code> is not a sparse tensor.</p> </div> <p>See also <a class="reference internal" href="sparse#torch.Tensor.dense_dim" title="torch.Tensor.dense_dim"><code>Tensor.dense_dim()</code></a> and <a class="reference internal" href="sparse#sparse-hybrid-coo-docs"><span class="std std-ref">hybrid tensors</span></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.sqrt">
<code>sqrt() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.sqrt#torch.sqrt" title="torch.sqrt"><code>torch.sqrt()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.sqrt_">
<code>sqrt_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.sqrt" title="torch.Tensor.sqrt"><code>sqrt()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.square">
<code>square() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.square#torch.square" title="torch.square"><code>torch.square()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.square_">
<code>square_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.square" title="torch.Tensor.square"><code>square()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.squeeze">
<code>squeeze(dim=None) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.squeeze#torch.squeeze" title="torch.squeeze"><code>torch.squeeze()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.squeeze_">
<code>squeeze_(dim=None) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.squeeze" title="torch.Tensor.squeeze"><code>squeeze()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.std">
<code>std(dim=None, unbiased=True, keepdim=False) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.std#torch.std" title="torch.std"><code>torch.std()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.stft">
<code>stft(n_fft, hop_length=None, win_length=None, window=None, center=True, pad_mode='reflect', normalized=False, onesided=None, return_complex=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/tensor.html#Tensor.stft"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>See <a class="reference internal" href="generated/torch.stft#torch.stft" title="torch.stft"><code>torch.stft()</code></a></p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This function changed signature at version 0.4.1. Calling with the previous signature may cause error or return incorrect result.</p> </div> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.storage">
<code>storage() → torch.Storage</code> </dt> <dd>
<p>Returns the underlying storage.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.storage_offset">
<code>storage_offset() → int</code> </dt> <dd>
<p>Returns <code>self</code> tensor’s offset in the underlying storage in terms of number of storage elements (not bytes).</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; x = torch.tensor([1, 2, 3, 4, 5])
&gt;&gt;&gt; x.storage_offset()
0
&gt;&gt;&gt; x[3:].storage_offset()
3
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.storage_type">
<code>storage_type() → type</code> </dt> <dd>
<p>Returns the type of the underlying storage.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.stride">
<code>stride(dim) → tuple or int</code> </dt> <dd>
<p>Returns the stride of <code>self</code> tensor.</p> <p>Stride is the jump necessary to go from one element to the next one in the specified dimension <a class="reference internal" href="#torch.Tensor.dim" title="torch.Tensor.dim"><code>dim</code></a>. A tuple of all strides is returned when no argument is passed in. Otherwise, an integer value is returned as the stride in the particular dimension <a class="reference internal" href="#torch.Tensor.dim" title="torch.Tensor.dim"><code>dim</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><em>optional</em>) – the desired dimension in which stride is required</p> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; x = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])
&gt;&gt;&gt; x.stride()
(5, 1)
&gt;&gt;&gt; x.stride(0)
5
&gt;&gt;&gt; x.stride(-1)
1
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.sub">
<code>sub(other, *, alpha=1) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.sub#torch.sub" title="torch.sub"><code>torch.sub()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.sub_">
<code>sub_(other, *, alpha=1) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.sub" title="torch.Tensor.sub"><code>sub()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.subtract">
<code>subtract(other, *, alpha=1) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.subtract#torch.subtract" title="torch.subtract"><code>torch.subtract()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.subtract_">
<code>subtract_(other, *, alpha=1) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.subtract" title="torch.Tensor.subtract"><code>subtract()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.sum">
<code>sum(dim=None, keepdim=False, dtype=None) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.sum#torch.sum" title="torch.sum"><code>torch.sum()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.sum_to_size">
<code>sum_to_size(*size) → Tensor</code> </dt> <dd>
<p>Sum <code>this</code> tensor to <a class="reference internal" href="#torch.Tensor.size" title="torch.Tensor.size"><code>size</code></a>. <a class="reference internal" href="#torch.Tensor.size" title="torch.Tensor.size"><code>size</code></a> must be broadcastable to <code>this</code> tensor size.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>size</strong> (<em>int...</em>) – a sequence of integers defining the shape of the output tensor.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.svd">
<code>svd(some=True, compute_uv=True) -&gt; (Tensor, Tensor, Tensor)</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.svd#torch.svd" title="torch.svd"><code>torch.svd()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.swapaxes">
<code>swapaxes(axis0, axis1) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.swapaxes#torch.swapaxes" title="torch.swapaxes"><code>torch.swapaxes()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.swapdims">
<code>swapdims(dim0, dim1) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.swapdims#torch.swapdims" title="torch.swapdims"><code>torch.swapdims()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.symeig">
<code>symeig(eigenvectors=False, upper=True) -&gt; (Tensor, Tensor)</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.symeig#torch.symeig" title="torch.symeig"><code>torch.symeig()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.t">
<code>t() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.t#torch.t" title="torch.t"><code>torch.t()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.t_">
<code>t_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.t" title="torch.Tensor.t"><code>t()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.tensor_split">
<code>tensor_split(indices_or_sections, dim=0) → List of Tensors</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.tensor_split#torch.tensor_split" title="torch.tensor_split"><code>torch.tensor_split()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.tile">
<code>tile(*reps) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.tile#torch.tile" title="torch.tile"><code>torch.tile()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.to">
<code>to(*args, **kwargs) → Tensor</code> </dt> <dd>
<p>Performs Tensor dtype and/or device conversion. A <a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a> and <a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a> are inferred from the arguments of <code>self.to(*args, **kwargs)</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If the <code>self</code> Tensor already has the correct <a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a> and <a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>, then <code>self</code> is returned. Otherwise, the returned tensor is a copy of <code>self</code> with the desired <a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a> and <a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a>.</p> </div> <p>Here are the ways to call <code>to</code>:</p> <dl class="function"> <dt>
<code>to(dtype, non_blocking=False, copy=False, memory_format=torch.preserve_format) → Tensor</code> </dt> <dd>
<p>Returns a Tensor with the specified <code>dtype</code></p> <dl class="simple"> <dt>Args:</dt>
<dd>
<p>memory_format (<a class="reference internal" href="tensor_attributes#torch.torch.memory_format" title="torch.torch.memory_format"><code>torch.memory_format</code></a>, optional): the desired memory format of returned Tensor. Default: <code>torch.preserve_format</code>.</p> </dd> </dl> </dd>
</dl> <dl class="function"> <dt>
<code>to(device=None, dtype=None, non_blocking=False, copy=False, memory_format=torch.preserve_format) → Tensor</code> </dt> <dd>
<p>Returns a Tensor with the specified <a class="reference internal" href="#torch.Tensor.device" title="torch.Tensor.device"><code>device</code></a> and (optional) <code>dtype</code>. If <code>dtype</code> is <code>None</code> it is inferred to be <code>self.dtype</code>. When <code>non_blocking</code>, tries to convert asynchronously with respect to the host if possible, e.g., converting a CPU Tensor with pinned memory to a CUDA Tensor. When <code>copy</code> is set, a new Tensor is created even when the Tensor already matches the desired conversion.</p> <dl class="simple"> <dt>Args:</dt>
<dd>
<p>memory_format (<a class="reference internal" href="tensor_attributes#torch.torch.memory_format" title="torch.torch.memory_format"><code>torch.memory_format</code></a>, optional): the desired memory format of returned Tensor. Default: <code>torch.preserve_format</code>.</p> </dd> </dl> </dd>
</dl> <dl class="function"> <dt>
<code>to(other, non_blocking=False, copy=False) → Tensor</code> </dt> <dd>
<p>Returns a Tensor with same <a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a> and <a class="reference internal" href="tensor_attributes#torch.torch.device" title="torch.torch.device"><code>torch.device</code></a> as the Tensor <code>other</code>. When <code>non_blocking</code>, tries to convert asynchronously with respect to the host if possible, e.g., converting a CPU Tensor with pinned memory to a CUDA Tensor. When <code>copy</code> is set, a new Tensor is created even when the Tensor already matches the desired conversion.</p> </dd>
</dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu
&gt;&gt;&gt; tensor.to(torch.float64)
tensor([[-0.5044,  0.0005],
        [ 0.3310, -0.0584]], dtype=torch.float64)

&gt;&gt;&gt; cuda0 = torch.device('cuda:0')
&gt;&gt;&gt; tensor.to(cuda0)
tensor([[-0.5044,  0.0005],
        [ 0.3310, -0.0584]], device='cuda:0')

&gt;&gt;&gt; tensor.to(cuda0, dtype=torch.float64)
tensor([[-0.5044,  0.0005],
        [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')

&gt;&gt;&gt; other = torch.randn((), dtype=torch.float64, device=cuda0)
&gt;&gt;&gt; tensor.to(other, non_blocking=True)
tensor([[-0.5044,  0.0005],
        [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.to_mkldnn">
<code>to_mkldnn() → Tensor</code> </dt> <dd>
<p>Returns a copy of the tensor in <code>torch.mkldnn</code> layout.</p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.take">
<code>take(indices) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.take#torch.take" title="torch.take"><code>torch.take()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.tan">
<code>tan() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.tan#torch.tan" title="torch.tan"><code>torch.tan()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.tan_">
<code>tan_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.tan" title="torch.Tensor.tan"><code>tan()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.tanh">
<code>tanh() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.tanh#torch.tanh" title="torch.tanh"><code>torch.tanh()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.tanh_">
<code>tanh_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.tanh" title="torch.Tensor.tanh"><code>tanh()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.atanh">
<code>atanh() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.atanh#torch.atanh" title="torch.atanh"><code>torch.atanh()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.atanh_">
<code>atanh_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.atanh" title="torch.Tensor.atanh"><code>atanh()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.arctanh">
<code>arctanh() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.arctanh#torch.arctanh" title="torch.arctanh"><code>torch.arctanh()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.arctanh_">
<code>arctanh_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.arctanh" title="torch.Tensor.arctanh"><code>arctanh()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.tolist">
<code>tolist() → list or number</code> </dt> <dd>
<p>Returns the tensor as a (nested) list. For scalars, a standard Python number is returned, just like with <a class="reference internal" href="#torch.Tensor.item" title="torch.Tensor.item"><code>item()</code></a>. Tensors are automatically moved to the CPU first if necessary.</p> <p>This operation is not differentiable.</p> <p>Examples:</p> <pre data-language="python">&gt;&gt;&gt; a = torch.randn(2, 2)
&gt;&gt;&gt; a.tolist()
[[0.012766935862600803, 0.5415473580360413],
 [-0.08909505605697632, 0.7729271650314331]]
&gt;&gt;&gt; a[0,0].tolist()
0.012766935862600803
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.topk">
<code>topk(k, dim=None, largest=True, sorted=True) -&gt; (Tensor, LongTensor)</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.topk#torch.topk" title="torch.topk"><code>torch.topk()</code></a></p> </dd>
</dl> <dl class="method"> <dt>
<code>to_sparse(sparseDims) → Tensor</code> </dt> <dd>
<p>Returns a sparse copy of the tensor. PyTorch supports sparse tensors in <a class="reference internal" href="sparse#sparse-coo-docs"><span class="std std-ref">coordinate format</span></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>sparseDims</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><em>optional</em>) – the number of sparse dimensions to include in the new sparse tensor</p> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; d = torch.tensor([[0, 0, 0], [9, 0, 10], [0, 0, 0]])
&gt;&gt;&gt; d
tensor([[ 0,  0,  0],
        [ 9,  0, 10],
        [ 0,  0,  0]])
&gt;&gt;&gt; d.to_sparse()
tensor(indices=tensor([[1, 1],
                       [0, 2]]),
       values=tensor([ 9, 10]),
       size=(3, 3), nnz=2, layout=torch.sparse_coo)
&gt;&gt;&gt; d.to_sparse(1)
tensor(indices=tensor([[1]]),
       values=tensor([[ 9,  0, 10]]),
       size=(3, 3), nnz=1, layout=torch.sparse_coo)
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.trace">
<code>trace() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.trace#torch.trace" title="torch.trace"><code>torch.trace()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.transpose">
<code>transpose(dim0, dim1) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.transpose#torch.transpose" title="torch.transpose"><code>torch.transpose()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.transpose_">
<code>transpose_(dim0, dim1) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.transpose" title="torch.Tensor.transpose"><code>transpose()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.triangular_solve">
<code>triangular_solve(A, upper=True, transpose=False, unitriangular=False) -&gt; (Tensor, Tensor)</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.triangular_solve#torch.triangular_solve" title="torch.triangular_solve"><code>torch.triangular_solve()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.tril">
<code>tril(k=0) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.tril#torch.tril" title="torch.tril"><code>torch.tril()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.tril_">
<code>tril_(k=0) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.tril" title="torch.Tensor.tril"><code>tril()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.triu">
<code>triu(k=0) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.triu#torch.triu" title="torch.triu"><code>torch.triu()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.triu_">
<code>triu_(k=0) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.triu" title="torch.Tensor.triu"><code>triu()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.true_divide">
<code>true_divide(value) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.true_divide#torch.true_divide" title="torch.true_divide"><code>torch.true_divide()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.true_divide_">
<code>true_divide_(value) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.true_divide_" title="torch.Tensor.true_divide_"><code>true_divide_()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.trunc">
<code>trunc() → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.trunc#torch.trunc" title="torch.trunc"><code>torch.trunc()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.trunc_">
<code>trunc_() → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.trunc" title="torch.Tensor.trunc"><code>trunc()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.type">
<code>type(dtype=None, non_blocking=False, **kwargs) → str or Tensor</code> </dt> <dd>
<p>Returns the type if <code>dtype</code> is not provided, else casts this object to the specified type.</p> <p>If this is already of the correct type, no copy is performed and the original object is returned.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.9)">type</a><em> or </em><em>string</em>) – The desired type</li> <li>
<strong>non_blocking</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – If <code>True</code>, and the source is in pinned memory and destination is on the GPU or vice versa, the copy is performed asynchronously with respect to the host. Otherwise, the argument has no effect.</li> <li>
<strong>**kwargs</strong> – For compatibility, may contain the key <code>async</code> in place of the <code>non_blocking</code> argument. The <code>async</code> arg is deprecated.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.type_as">
<code>type_as(tensor) → Tensor</code> </dt> <dd>
<p>Returns this tensor cast to the type of the given tensor.</p> <p>This is a no-op if the tensor is already of the correct type. This is equivalent to <code>self.type(tensor.type())</code></p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>tensor</strong> (<a class="reference internal" href="#torch.Tensor" title="torch.Tensor">Tensor</a>) – the tensor which has the desired type</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.unbind">
<code>unbind(dim=0) → seq</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.unbind#torch.unbind" title="torch.unbind"><code>torch.unbind()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.unfold">
<code>unfold(dimension, size, step) → Tensor</code> </dt> <dd>
<p>Returns a view of the original tensor which contains all slices of size <a class="reference internal" href="#torch.Tensor.size" title="torch.Tensor.size"><code>size</code></a> from <code>self</code> tensor in the dimension <code>dimension</code>.</p> <p>Step between two slices is given by <code>step</code>.</p> <p>If <code>sizedim</code> is the size of dimension <code>dimension</code> for <code>self</code>, the size of dimension <code>dimension</code> in the returned tensor will be <code>(sizedim - size) / step + 1</code>.</p> <p>An additional dimension of size <a class="reference internal" href="#torch.Tensor.size" title="torch.Tensor.size"><code>size</code></a> is appended in the returned tensor.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>dimension</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – dimension in which unfolding happens</li> <li>
<strong>size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – the size of each slice that is unfolded</li> <li>
<strong>step</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – the step between each slice</li> </ul> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; x = torch.arange(1., 8)
&gt;&gt;&gt; x
tensor([ 1.,  2.,  3.,  4.,  5.,  6.,  7.])
&gt;&gt;&gt; x.unfold(0, 2, 1)
tensor([[ 1.,  2.],
        [ 2.,  3.],
        [ 3.,  4.],
        [ 4.,  5.],
        [ 5.,  6.],
        [ 6.,  7.]])
&gt;&gt;&gt; x.unfold(0, 2, 2)
tensor([[ 1.,  2.],
        [ 3.,  4.],
        [ 5.,  6.]])
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.uniform_">
<code>uniform_(from=0, to=1) → Tensor</code> </dt> <dd>
<p>Fills <code>self</code> tensor with numbers sampled from the continuous uniform distribution:</p> <div class="math"> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mtext>to</mtext><mo>−</mo><mtext>from</mtext></mrow></mfrac></mrow><annotation encoding="application/x-tex">P(x) = \dfrac{1}{\text{to} - \text{from}} </annotation></semantics></math></span></span></span> </div>
</dd>
</dl> <dl class="method"> <dt id="torch.Tensor.unique">
<code>unique(sorted=True, return_inverse=False, return_counts=False, dim=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/tensor.html#Tensor.unique"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns the unique elements of the input tensor.</p> <p>See <a class="reference internal" href="generated/torch.unique#torch.unique" title="torch.unique"><code>torch.unique()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.unique_consecutive">
<code>unique_consecutive(return_inverse=False, return_counts=False, dim=None)</code> <a class="reference internal" href="https://pytorch.org/docs/1.8.0/_modules/torch/tensor.html#Tensor.unique_consecutive"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Eliminates all but the first element from every consecutive group of equivalent elements.</p> <p>See <a class="reference internal" href="generated/torch.unique_consecutive#torch.unique_consecutive" title="torch.unique_consecutive"><code>torch.unique_consecutive()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.unsqueeze">
<code>unsqueeze(dim) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.unsqueeze#torch.unsqueeze" title="torch.unsqueeze"><code>torch.unsqueeze()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.unsqueeze_">
<code>unsqueeze_(dim) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.unsqueeze" title="torch.Tensor.unsqueeze"><code>unsqueeze()</code></a></p> </dd>
</dl> <dl class="method"> <dt>
<code>values() → Tensor</code> </dt> <dd>
<p>Return the values tensor of a <a class="reference internal" href="sparse#sparse-coo-docs"><span class="std std-ref">sparse COO tensor</span></a>.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Throws an error if <code>self</code> is not a sparse COO tensor.</p> </div> <p>See also <a class="reference internal" href="sparse#torch.Tensor.indices" title="torch.Tensor.indices"><code>Tensor.indices()</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This method can only be called on a coalesced sparse tensor. See <a class="reference internal" href="sparse#torch.Tensor.coalesce" title="torch.Tensor.coalesce"><code>Tensor.coalesce()</code></a> for details.</p> </div> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.var">
<code>var(dim=None, unbiased=True, keepdim=False) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.var#torch.var" title="torch.var"><code>torch.var()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.vdot">
<code>vdot(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.vdot#torch.vdot" title="torch.vdot"><code>torch.vdot()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.view">
<code>view(*shape) → Tensor</code> </dt> <dd>
<p>Returns a new tensor with the same data as the <code>self</code> tensor but of a different <code>shape</code>.</p> <p>The returned tensor shares the same data and must have the same number of elements, but may have a different size. For a tensor to be viewed, the new view size must be compatible with its original size and stride, i.e., each new view dimension must either be a subspace of an original dimension, or only span across original dimensions <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo separator="true">,</mo><mi>d</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>d</mi><mo>+</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">d, d+1, \dots, d+k</annotation></semantics></math></span></span> </span> that satisfy the following contiguity-like condition that <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>i</mi><mo>=</mo><mi>d</mi><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>d</mi><mo>+</mo><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\forall i = d, \dots, d+k-1</annotation></semantics></math></span></span> </span>,</p> <div class="math"> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>stride</mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mtext>stride</mtext><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo>×</mo><mtext>size</mtext><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\text{stride}[i] = \text{stride}[i+1] \times \text{size}[i+1]</annotation></semantics></math></span></span></span> </div>
<p>Otherwise, it will not be possible to view <code>self</code> tensor as <code>shape</code> without copying it (e.g., via <a class="reference internal" href="#torch.Tensor.contiguous" title="torch.Tensor.contiguous"><code>contiguous()</code></a>). When it is unclear whether a <a class="reference internal" href="#torch.Tensor.view" title="torch.Tensor.view"><code>view()</code></a> can be performed, it is advisable to use <a class="reference internal" href="generated/torch.reshape#torch.reshape" title="torch.reshape"><code>reshape()</code></a>, which returns a view if the shapes are compatible, and copies (equivalent to calling <a class="reference internal" href="#torch.Tensor.contiguous" title="torch.Tensor.contiguous"><code>contiguous()</code></a>) otherwise.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>shape</strong> (<em>torch.Size</em><em> or </em><em>int...</em>) – the desired size</p> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; x = torch.randn(4, 4)
&gt;&gt;&gt; x.size()
torch.Size([4, 4])
&gt;&gt;&gt; y = x.view(16)
&gt;&gt;&gt; y.size()
torch.Size([16])
&gt;&gt;&gt; z = x.view(-1, 8)  # the size -1 is inferred from other dimensions
&gt;&gt;&gt; z.size()
torch.Size([2, 8])

&gt;&gt;&gt; a = torch.randn(1, 2, 3, 4)
&gt;&gt;&gt; a.size()
torch.Size([1, 2, 3, 4])
&gt;&gt;&gt; b = a.transpose(1, 2)  # Swaps 2nd and 3rd dimension
&gt;&gt;&gt; b.size()
torch.Size([1, 3, 2, 4])
&gt;&gt;&gt; c = a.view(1, 3, 2, 4)  # Does not change tensor layout in memory
&gt;&gt;&gt; c.size()
torch.Size([1, 3, 2, 4])
&gt;&gt;&gt; torch.equal(b, c)
False
</pre> <dl class="function"> <dt>
<code>view(dtype) → Tensor</code> </dt> 
</dl> <p>Returns a new tensor with the same data as the <code>self</code> tensor but of a different <code>dtype</code>. <code>dtype</code> must have the same number of bytes per element as <code>self</code>’s dtype.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This overload is not supported by TorchScript, and using it in a Torchscript program will cause undefined behavior.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>dtype</strong> (<a class="reference internal" href="tensor_attributes#torch.torch.dtype" title="torch.torch.dtype"><code>torch.dtype</code></a>) – the desired dtype</p> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; x = torch.randn(4, 4)
&gt;&gt;&gt; x
tensor([[ 0.9482, -0.0310,  1.4999, -0.5316],
        [-0.1520,  0.7472,  0.5617, -0.8649],
        [-2.4724, -0.0334, -0.2976, -0.8499],
        [-0.2109,  1.9913, -0.9607, -0.6123]])
&gt;&gt;&gt; x.dtype
torch.float32

&gt;&gt;&gt; y = x.view(torch.int32)
&gt;&gt;&gt; y
tensor([[ 1064483442, -1124191867,  1069546515, -1089989247],
        [-1105482831,  1061112040,  1057999968, -1084397505],
        [-1071760287, -1123489973, -1097310419, -1084649136],
        [-1101533110,  1073668768, -1082790149, -1088634448]],
    dtype=torch.int32)
&gt;&gt;&gt; y[0, 0] = 1000000000
&gt;&gt;&gt; x
tensor([[ 0.0047, -0.0310,  1.4999, -0.5316],
        [-0.1520,  0.7472,  0.5617, -0.8649],
        [-2.4724, -0.0334, -0.2976, -0.8499],
        [-0.2109,  1.9913, -0.9607, -0.6123]])

&gt;&gt;&gt; x.view(torch.int16)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
RuntimeError: Viewing a tensor as a new dtype with a different number of bytes per element is not supported.
</pre> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.view_as">
<code>view_as(other) → Tensor</code> </dt> <dd>
<p>View this tensor as the same size as <code>other</code>. <code>self.view_as(other)</code> is equivalent to <code>self.view(other.size())</code>.</p> <p>Please see <a class="reference internal" href="#torch.Tensor.view" title="torch.Tensor.view"><code>view()</code></a> for more information about <code>view</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>other</strong> (<a class="reference internal" href="#torch.Tensor" title="torch.Tensor"><code>torch.Tensor</code></a>) – The result tensor has the same size as <code>other</code>.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.where">
<code>where(condition, y) → Tensor</code> </dt> <dd>
<p><code>self.where(condition, y)</code> is equivalent to <code>torch.where(condition, self, y)</code>. See <a class="reference internal" href="generated/torch.where#torch.where" title="torch.where"><code>torch.where()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.xlogy">
<code>xlogy(other) → Tensor</code> </dt> <dd>
<p>See <a class="reference internal" href="generated/torch.xlogy#torch.xlogy" title="torch.xlogy"><code>torch.xlogy()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.xlogy_">
<code>xlogy_(other) → Tensor</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#torch.Tensor.xlogy" title="torch.Tensor.xlogy"><code>xlogy()</code></a></p> </dd>
</dl> <dl class="method"> <dt id="torch.Tensor.zero_">
<code>zero_() → Tensor</code> </dt> <dd>
<p>Fills <code>self</code> tensor with zeros.</p> </dd>
</dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://pytorch.org/docs/1.8.0/tensors.html" class="_attribution-link" target="_blank">https://pytorch.org/docs/1.8.0/tensors.html</a>
  </p>
</div>
