<h1 class="devsite-page-title">tf.train.experimental.enable_mixed_precision_graph_rewrite</h1>     <div itemscope itemtype="http://developers.google.com/ReferenceObject"> <meta itemprop="name" content="tf.train.experimental.enable_mixed_precision_graph_rewrite"> <meta itemprop="path" content="Stable"> </div>  <table class="tfo-notebook-buttons tfo-api" align="left"> <td> <a target="_blank" href="https://www.tensorflow.org/versions/r1.15/api_docs/python/tf/train/experimental/enable_mixed_precision_graph_rewrite">  TensorFlow 1 version</a> </td> <td> <a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.1/tensorflow/python/training/experimental/mixed_precision.py#L78-L201">  View source on GitHub </a> </td>
</table>  <p>Enable mixed precision via a graph rewrite.</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">tf.train.experimental.enable_mixed_precision_graph_rewrite(
    opt,
    loss_scale='dynamic'
)
</pre>  <p>Mixed precision is the use of both float32 and float16 data types when training a model to improve performance. This is achieved via a graph rewrite operation and a loss-scale optimizer.</p> <p>Performing arithmetic operations in float16 takes advantage of specialized processing units, such as NVIDIA Tensor Cores for much higher arithmetic throughput. However, due to the smaller representable range, performing the entire training with float16 can result in gradient underflow, that is, small gradient values becoming zeroes. Instead, performing only select arithmetic operations in float16 results in higher throughput and decreased training time when using compatible hardware accelerators while also reducing memory usage, typically without sacrificing model accuracy.</p> <blockquote class="note">
<strong>Note:</strong><span> While the mixed precision rewrite changes the datatype of various layers throughout the model, the same accuracy reached in float32 is expected. If a <code translate="no" dir="ltr">NaN</code> gradient occurs with dynamic loss scaling, the model update for that batch is skipped. In this case, the global step count is not incremented, and the <code translate="no" dir="ltr">LossScaleOptimizer</code> attempts to decrease the loss scaling value to avoid <code translate="no" dir="ltr">NaN</code> values in subsequent iterations. This approach has been shown to achieve the same accuracy as float32 and, in most cases, better training throughput.</span>
</blockquote> <h4 id="example">Example:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">model = tf.keras.models.Sequential([
  ...
])

opt = tf.keras.optimizers.SGD()
opt = tf.train.experimental.enable_mixed_precision_graph_rewrite(opt)

model.compile(loss="categorical_crossentropy",
            optimizer=opt,
            metrics=["accuracy"])

model.fit(x_train, y_train,
        batch_size=batch_size,
        epochs=epochs)
</pre> <p>For a complete example showing the speed-up on training an image classification task on CIFAR10, check out this <a href="#">Colab notebook</a>.</p> <p>Calling <code translate="no" dir="ltr">enable_mixed_precision_graph_rewrite(opt)</code> enables the graph rewrite operation before computing gradients. The function additionally returns an <code translate="no" dir="ltr">Optimizer</code>(<code translate="no" dir="ltr">opt</code>) wrapped with a <code translate="no" dir="ltr">LossScaleOptimizer</code>. This prevents underflow in the float16 tensors during the backward pass. An optimizer of type <code translate="no" dir="ltr">tf.train.Optimizer</code> or <a href="../../keras/optimizers/optimizer"><code translate="no" dir="ltr">tf.keras.optimizers.Optimizer</code></a> must be passed to this function, which will then be wrapped to use loss scaling.</p> <p><img src="#" width="500px"></p> <p>The graph rewrite operation changes the <code translate="no" dir="ltr">dtype</code> of certain operations in the graph from float32 to float16. There are several categories of operations that are either included or excluded by this rewrite operation. The following categories of Ops are defined inside corresponding functions under the class <code translate="no" dir="ltr">AutoMixedPrecisionLists</code> in <a href="#"> auto_mixed_precision_lists.h</a>:</p> <ul> <li>
<code translate="no" dir="ltr">ClearList</code>: Ops that do not have numerically significant adverse effects. E.g. <code translate="no" dir="ltr">ArgMax</code> and <code translate="no" dir="ltr">Floor</code>.</li> <li>
<code translate="no" dir="ltr">WhiteList</code>: Ops that are considered numerically safe for execution in float16, and thus are always converted. E.g. <code translate="no" dir="ltr">Conv2D</code>.</li> <li>
<code translate="no" dir="ltr">BlackList</code>: Ops that are numerically unsafe to execute in float16 and can negatively affect downstream nodes. E.g. <code translate="no" dir="ltr">Softmax</code>.</li> <li>
<code translate="no" dir="ltr">GrayList</code>: Ops that are considered numerically safe for execution in float16 unless downstream from a BlackList Op. E.g. <code translate="no" dir="ltr">Add</code> and <code translate="no" dir="ltr">AvgPool</code>.</li> </ul> <p>When this function is used, gradients should only be computed and applied with the returned optimizer, either by calling <code translate="no" dir="ltr">opt.minimize()</code> or <code translate="no" dir="ltr">opt.compute_gradients()</code> followed by <code translate="no" dir="ltr">opt.apply_gradients()</code>. Gradients should not be computed with <a href="../../gradients"><code translate="no" dir="ltr">tf.gradients</code></a> or <a href="../../gradienttape"><code translate="no" dir="ltr">tf.GradientTape</code></a>. This is because the returned optimizer will apply loss scaling, and <a href="../../gradients"><code translate="no" dir="ltr">tf.gradients</code></a> or <a href="../../gradienttape"><code translate="no" dir="ltr">tf.GradientTape</code></a> will not. If you do directly use <a href="../../gradients"><code translate="no" dir="ltr">tf.gradients</code></a> or <a href="../../gradienttape"><code translate="no" dir="ltr">tf.GradientTape</code></a>, your model may not converge due to float16 underflow problems.</p> <p>When eager execution is enabled, the mixed precision graph rewrite is only enabled within <a href="../../function"><code translate="no" dir="ltr">tf.function</code></a>, as outside <a href="../../function"><code translate="no" dir="ltr">tf.function</code></a>, there is no graph.</p> <p>For NVIDIA GPUs with Tensor cores, as a general performance guide, dimensions (such as batch size, input size, output size, and channel counts) should be powers of two if under 256, or otherwise divisible by 8 if above 256. For more information, check out the <a href="https://docs.nvidia.com/deeplearning/sdk/dl-performance-guide/index.html">NVIDIA Deep Learning Performance Guide</a>.</p> <p>Currently, mixed precision is only enabled on NVIDIA Tensor Core GPUs with Compute Capability 7.0 and above (Volta, Turing, or newer architectures). The parts of the graph on CPUs and TPUs are untouched by the graph rewrite. TPU support is coming soon. CPUs are not supported, as CPUs do not run float16 operations faster than float32 operations.</p> <h4 id="raises">Raises:</h4> <p><code translate="no" dir="ltr">ValueError</code> when <code translate="no" dir="ltr">mixed_precision_global_state.using_default_mixed_precision_policy</code> is set to <code translate="no" dir="ltr">False</code> before <a href="enable_mixed_precision_graph_rewrite"><code translate="no" dir="ltr">tf.train.experimental.enable_mixed_precision_graph_rewrite()</code></a> is called.</p> <h4 id="args">Args:</h4> <ul> <li>
<b><code translate="no" dir="ltr">opt</code></b>: An instance of a <a href="../../keras/optimizers/optimizer"><code translate="no" dir="ltr">tf.keras.optimizers.Optimizer</code></a>.</li> <li>
<b><code translate="no" dir="ltr">loss_scale</code></b>: Either an int/float, the string <code translate="no" dir="ltr">"dynamic"</code>, or an instance of a <a href="../../mixed_precision/experimental/lossscale"><code translate="no" dir="ltr">tf.mixed_precision.experimental.LossScale</code></a>. The loss scale to use. It is recommended to keep this as its default value of <code translate="no" dir="ltr">"dynamic"</code>, which will adjust the scaling automatically to prevent <code translate="no" dir="ltr">Inf</code> or <code translate="no" dir="ltr">NaN</code> values.</li> </ul> <h4 id="returns">Returns:</h4> <p>A version of <code translate="no" dir="ltr">opt</code> that will use loss scaling to prevent underflow.</p> <h2 id="compat_aliases">Compat aliases</h2> <ul> <li><a href="enable_mixed_precision_graph_rewrite"><code translate="no" dir="ltr">tf.compat.v2.train.experimental.enable_mixed_precision_graph_rewrite</code></a></li> </ul>  <devsite-page-rating position="footer" selected-rating="0" hover-rating-star="0"> </devsite-page-rating><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2019 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/api_docs/python/tf/train/experimental/enable_mixed_precision_graph_rewrite" class="_attribution-link">https://www.tensorflow.org/api_docs/python/tf/train/experimental/enable_mixed_precision_graph_rewrite</a>
  </p>
</div>
