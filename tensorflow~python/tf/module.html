<h1 class="devsite-page-title">tf.Module</h1>     <div itemscope itemtype="http://developers.google.com/ReferenceObject"> <meta itemprop="name" content="tf.Module"> <meta itemprop="path" content="Stable"> <meta itemprop="property" content="name"> <meta itemprop="property" content="name_scope"> <meta itemprop="property" content="submodules"> <meta itemprop="property" content="trainable_variables"> <meta itemprop="property" content="variables"> <meta itemprop="property" content="__init__"> <meta itemprop="property" content="with_name_scope"> </div>   <table class="tfo-notebook-buttons tfo-api" align="left"> <td> <a target="_blank" href="https://www.tensorflow.org/versions/r1.15/api_docs/python/tf/Module">  TensorFlow 1 version</a> </td> <td> <a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.1/tensorflow/python/module/module.py#L33-L294">  View source on GitHub </a> </td>
</table>  <h2 id="class_module_2">Class <code translate="no" dir="ltr">Module</code>
</h2> <p>Base neural network module class.</p> <h3 id="used_in_the_guide_2">Used in the guide:</h3> <ul> <li><a href="https://www.tensorflow.org/guide/concrete_function">Concrete functions</a></li> <li><a href="https://www.tensorflow.org/guide/saved_model">Using the SavedModel format</a></li> </ul> <p>A module is a named container for <a href="variable"><code translate="no" dir="ltr">tf.Variable</code></a>s, other <a href="module"><code translate="no" dir="ltr">tf.Module</code></a>s and functions which apply to user input. For example a dense layer in a neural network might be implemented as a <a href="module"><code translate="no" dir="ltr">tf.Module</code></a>:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">class Dense(tf.Module):
  def __init__(self, in_features, output_features, name=None):
    super(Dense, self).__init__(name=name)
    self.w = tf.Variable(
        tf.random.normal([input_features, output_features]), name='w')
    self.b = tf.Variable(tf.zeros([output_features]), name='b')

  def __call__(self, x):
    y = tf.matmul(x, self.w) + self.b
    return tf.nn.relu(y)
</pre> <p>You can use the Dense layer as you would expect:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">d = Dense(input_features=64, output_features=10)
d(tf.ones([100, 64]))
#==&gt; &lt;tf.Tensor: ...&gt;
</pre> <p>By subclassing <a href="module"><code translate="no" dir="ltr">tf.Module</code></a> instead of <code translate="no" dir="ltr">object</code> any <a href="variable"><code translate="no" dir="ltr">tf.Variable</code></a> or <a href="module"><code translate="no" dir="ltr">tf.Module</code></a> instances assigned to object properties can be collected using the <code translate="no" dir="ltr">variables</code>, <code translate="no" dir="ltr">trainable_variables</code> or <code translate="no" dir="ltr">submodules</code> property:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">d.variables
#==&gt; (&lt;tf.Variable 'b:0' ...&gt;, &lt;tf.Variable 'w:0' ...&gt;)
</pre> <p>Subclasses of <a href="module"><code translate="no" dir="ltr">tf.Module</code></a> can also take advantage of the <code translate="no" dir="ltr">_flatten</code> method which can be used to implement tracking of any other types.</p> <p>All <a href="module"><code translate="no" dir="ltr">tf.Module</code></a> classes have an associated <a href="name_scope"><code translate="no" dir="ltr">tf.name_scope</code></a> which can be used to group operations in TensorBoard and create hierarchies for variable names which can help with debugging. We suggest using the name scope when creating nested submodules/parameters or for forward methods whose graph you might want to inspect in TensorBoard. You can enter the name scope explicitly using <code translate="no" dir="ltr">with self.name_scope:</code> or you can annotate methods (apart from <code translate="no" dir="ltr">__init__</code>) with <code translate="no" dir="ltr">@tf.Module.with_name_scope</code>.</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">class MLP(tf.Module):
  def __init__(self, input_size, sizes, name=None):
    super(MLP, self).__init__(name=name)
    self.layers = []
    with self.name_scope:
      for size in sizes:
        self.layers.append(Dense(input_size=input_size, output_size=size))
        input_size = size

  @tf.Module.with_name_scope
  def __call__(self, x):
    for layer in self.layers:
      x = layer(x)
    return x
</pre> <h2 id="__init__"><code translate="no" dir="ltr">__init__</code></h2> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.1/tensorflow/python/module/module.py#L107-L122">View source</a></p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">__init__(name=None)
</pre> <p>Initialize self. See help(type(self)) for accurate signature.</p> <h2 id="properties_2">Properties</h2> <h3 id="name"><code translate="no" dir="ltr">name</code></h3> <p>Returns the name of this module as passed or determined in the ctor.</p> <p>NOTE: This is not the same as the <code translate="no" dir="ltr">self.name_scope.name</code> which includes parent module names.</p> <h3 id="name_scope"><code translate="no" dir="ltr">name_scope</code></h3> <p>Returns a <a href="name_scope"><code translate="no" dir="ltr">tf.name_scope</code></a> instance for this class.</p> <h3 id="submodules"><code translate="no" dir="ltr">submodules</code></h3> <p>Sequence of all sub-modules.</p> <p>Submodules are modules which are properties of this module, or found as properties of modules which are properties of this module (and so on).</p> <pre class="prettyprint" translate="no" dir="ltr" data-language="python">a = tf.Module()
b = tf.Module()
c = tf.Module()
a.b = b
b.c = c
assert list(a.submodules) == [b, c]
assert list(b.submodules) == [c]
assert list(c.submodules) == []
</pre> <h4 id="returns_5">Returns:</h4> <p>A sequence of all submodules.</p> <h3 id="trainable_variables"><code translate="no" dir="ltr">trainable_variables</code></h3> <p>Sequence of trainable variables owned by this module and its submodules.</p> <blockquote class="note">
<strong>Note:</strong><span> this method uses reflection to find variables on the current instance and submodules. For performance reasons you may wish to cache the result of calling this method if you don't expect the return value to change.</span>
</blockquote> <h4 id="returns_6">Returns:</h4> <p>A sequence of variables for the current module (sorted by attribute name) followed by variables from all submodules recursively (breadth first).</p> <h3 id="variables"><code translate="no" dir="ltr">variables</code></h3> <p>Sequence of variables owned by this module and its submodules.</p> <blockquote class="note">
<strong>Note:</strong><span> this method uses reflection to find variables on the current instance and submodules. For performance reasons you may wish to cache the result of calling this method if you don't expect the return value to change.</span>
</blockquote> <h4 id="returns_7">Returns:</h4> <p>A sequence of variables for the current module (sorted by attribute name) followed by variables from all submodules recursively (breadth first).</p> <h2 id="methods_2">Methods</h2> <h3 id="with_name_scope"><code translate="no" dir="ltr">with_name_scope</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.1/tensorflow/python/module/module.py#L260-L294">View source</a></p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">@classmethod
with_name_scope(
    cls,
    method
)
</pre> <p>Decorator to automatically enter the module name scope.</p> <pre class="prettyprint" translate="no" dir="ltr" data-language="python">class MyModule(tf.Module):
  @tf.Module.with_name_scope
  def __call__(self, x):
    if not hasattr(self, 'w'):
      self.w = tf.Variable(tf.random.normal([x.shape[1], 64]))
    return tf.matmul(x, self.w)
</pre> <p>Using the above module would produce <a href="variable"><code translate="no" dir="ltr">tf.Variable</code></a>s and <a href="tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>s whose names included the module name:</p> <pre class="prettyprint" translate="no" dir="ltr" data-language="python">mod = MyModule()
mod(tf.ones([8, 32]))
# ==&gt; &lt;tf.Tensor: ...&gt;
mod.w
# ==&gt; &lt;tf.Variable ...'my_module/w:0'&gt;
</pre> <h4 id="args_2">Args:</h4> <ul> <li>
<b><code translate="no" dir="ltr">method</code></b>: The method to wrap.</li> </ul> <h4 id="returns_8">Returns:</h4> <p>The original method wrapped such that it enters the module's name scope.</p> <h2 id="compat_aliases_2">Compat aliases</h2> <ul> <li><a href="module"><code translate="no" dir="ltr">tf.compat.v1.Module</code></a></li> <li><a href="module"><code translate="no" dir="ltr">tf.compat.v2.Module</code></a></li> </ul>  <devsite-page-rating position="footer" selected-rating="0" hover-rating-star="0"> </devsite-page-rating><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2019 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/api_docs/python/tf/Module" class="_attribution-link">https://www.tensorflow.org/api_docs/python/tf/Module</a>
  </p>
</div>
