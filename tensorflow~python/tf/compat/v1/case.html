<h1 class="devsite-page-title">tf.compat.v1.case</h1>     <div itemscope itemtype="http://developers.google.com/ReferenceObject"> <meta itemprop="name" content="tf.compat.v1.case"> <meta itemprop="path" content="Stable"> </div>  <table class="tfo-notebook-buttons tfo-api" align="left"> <td> <a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.1/tensorflow/python/ops/control_flow_ops.py#L3385-L3490">  View source on GitHub </a> </td>
</table>  <p>Create a case operation.</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">tf.compat.v1.case(
    pred_fn_pairs,
    default=None,
    exclusive=False,
    strict=False,
    name='case'
)
</pre>  <p>See also <a href="../../switch_case"><code translate="no" dir="ltr">tf.switch_case</code></a>.</p> <p>The <code translate="no" dir="ltr">pred_fn_pairs</code> parameter is a dict or list of pairs of size N. Each pair contains a boolean scalar tensor and a python callable that creates the tensors to be returned if the boolean evaluates to True. <code translate="no" dir="ltr">default</code> is a callable generating a list of tensors. All the callables in <code translate="no" dir="ltr">pred_fn_pairs</code> as well as <code translate="no" dir="ltr">default</code> (if provided) should return the same number and types of tensors.</p> <p>If <code translate="no" dir="ltr">exclusive==True</code>, all predicates are evaluated, and an exception is thrown if more than one of the predicates evaluates to <code translate="no" dir="ltr">True</code>. If <code translate="no" dir="ltr">exclusive==False</code>, execution stops at the first predicate which evaluates to True, and the tensors generated by the corresponding function are returned immediately. If none of the predicates evaluate to True, this operation returns the tensors generated by <code translate="no" dir="ltr">default</code>.</p> <p><a href="../../case"><code translate="no" dir="ltr">tf.case</code></a> supports nested structures as implemented in <code translate="no" dir="ltr">tf.contrib.framework.nest</code>. All of the callables must return the same (possibly nested) value structure of lists, tuples, and/or named tuples. Singleton lists and tuples form the only exceptions to this: when returned by a callable, they are implicitly unpacked to single values. This behavior is disabled by passing <code translate="no" dir="ltr">strict=True</code>.</p> <p>If an unordered dictionary is used for <code translate="no" dir="ltr">pred_fn_pairs</code>, the order of the conditional tests is not guaranteed. However, the order is guaranteed to be deterministic, so that variables created in conditional branches are created in fixed order across runs.</p> <p><strong>Example 1:</strong></p> <h4 id="pseudocode">Pseudocode:</h4> <pre class="prettyprint" translate="no" dir="ltr" data-language="python">if (x &lt; y) return 17;
else return 23;
</pre> <h4 id="expressions">Expressions:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">f1 = lambda: tf.constant(17)
f2 = lambda: tf.constant(23)
r = tf.case([(tf.less(x, y), f1)], default=f2)
</pre> <p><strong>Example 2:</strong></p> <h4 id="pseudocode_2">Pseudocode:</h4> <pre class="prettyprint" translate="no" dir="ltr" data-language="python">if (x &lt; y &amp;&amp; x &gt; z) raise OpError("Only one predicate may evaluate to True");
if (x &lt; y) return 17;
else if (x &gt; z) return 23;
else return -1;
</pre> <h4 id="expressions_2">Expressions:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">def f1(): return tf.constant(17)
def f2(): return tf.constant(23)
def f3(): return tf.constant(-1)
r = tf.case({tf.less(x, y): f1, tf.greater(x, z): f2},
         default=f3, exclusive=True)
</pre> <h4 id="args">Args:</h4> <ul> <li>
<b><code translate="no" dir="ltr">pred_fn_pairs</code></b>: Dict or list of pairs of a boolean scalar tensor and a callable which returns a list of tensors.</li> <li>
<b><code translate="no" dir="ltr">default</code></b>: Optional callable that returns a list of tensors.</li> <li>
<b><code translate="no" dir="ltr">exclusive</code></b>: True iff at most one predicate is allowed to evaluate to <code translate="no" dir="ltr">True</code>.</li> <li>
<b><code translate="no" dir="ltr">strict</code></b>: A boolean that enables/disables 'strict' mode; see above.</li> <li>
<b><code translate="no" dir="ltr">name</code></b>: A name for this operation (optional).</li> </ul> <h4 id="returns">Returns:</h4> <p>The tensors returned by the first pair whose predicate evaluated to True, or those returned by <code translate="no" dir="ltr">default</code> if none does.</p> <h4 id="raises">Raises:</h4> <ul> <li>
<b><code translate="no" dir="ltr">TypeError</code></b>: If <code translate="no" dir="ltr">pred_fn_pairs</code> is not a list/dictionary.</li> <li>
<b><code translate="no" dir="ltr">TypeError</code></b>: If <code translate="no" dir="ltr">pred_fn_pairs</code> is a list but does not contain 2-tuples.</li> <li>
<b><code translate="no" dir="ltr">TypeError</code></b>: If <code translate="no" dir="ltr">fns[i]</code> is not callable for any i, or <code translate="no" dir="ltr">default</code> is not callable.</li> </ul> <h4 id="eager_compatibility">Eager Compatibility</h4> <p>Unordered dictionaries are not supported in eager mode when <code translate="no" dir="ltr">exclusive=False</code>. Use a list of tuples instead.</p>  <devsite-page-rating position="footer" selected-rating="0" hover-rating-star="0"> </devsite-page-rating><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2019 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/api_docs/python/tf/compat/v1/case" class="_attribution-link">https://www.tensorflow.org/api_docs/python/tf/compat/v1/case</a>
  </p>
</div>
