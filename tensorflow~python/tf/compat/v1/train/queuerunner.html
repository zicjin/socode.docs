<h1 class="devsite-page-title">tf.compat.v1.train.QueueRunner</h1>     <div itemscope itemtype="http://developers.google.com/ReferenceObject"> <meta itemprop="name" content="tf.compat.v1.train.QueueRunner"> <meta itemprop="path" content="Stable"> <meta itemprop="property" content="cancel_op"> <meta itemprop="property" content="close_op"> <meta itemprop="property" content="enqueue_ops"> <meta itemprop="property" content="exceptions_raised"> <meta itemprop="property" content="name"> <meta itemprop="property" content="queue"> <meta itemprop="property" content="queue_closed_exception_types"> <meta itemprop="property" content="__init__"> <meta itemprop="property" content="create_threads"> <meta itemprop="property" content="from_proto"> <meta itemprop="property" content="to_proto"> </div>  <table class="tfo-notebook-buttons tfo-api" align="left"> <td> <a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.1/tensorflow/python/training/queue_runner_impl.py#L38-L391">  View source on GitHub </a> </td>
</table>  <h2 id="class_queuerunner">Class <code translate="no" dir="ltr">QueueRunner</code>
</h2> <p>Holds a list of enqueue operations for a queue, each to be run in a thread.</p>  <p>Queues are a convenient TensorFlow mechanism to compute tensors asynchronously using multiple threads. For example in the canonical 'Input Reader' setup one set of threads generates filenames in a queue; a second set of threads read records from the files, processes them, and enqueues tensors on a second queue; a third set of threads dequeues these input records to construct batches and runs them through training operations.</p> <p>There are several delicate issues when running multiple threads that way: closing the queues in sequence as the input is exhausted, correctly catching and reporting exceptions, etc.</p> <p>The <code translate="no" dir="ltr">QueueRunner</code>, combined with the <code translate="no" dir="ltr">Coordinator</code>, helps handle these issues.</p> <h4 id="eager_compatibility">Eager Compatibility</h4> <p>QueueRunners are not compatible with eager execution. Instead, please use <a href="../../../data"><code translate="no" dir="ltr">tf.data</code></a> to get data into your model.</p> <h2 id="__init__"><code translate="no" dir="ltr">__init__</code></h2> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.1/tensorflow/python/training/queue_runner_impl.py#L60-L118">View source</a></p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">__init__(
    queue=None,
    enqueue_ops=None,
    close_op=None,
    cancel_op=None,
    queue_closed_exception_types=None,
    queue_runner_def=None,
    import_scope=None
)
</pre> <p>Create a QueueRunner. (deprecated)</p> <aside class="warning"><strong>Warning:</strong><span> THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: To construct input pipelines, use the <a href="../../../data"><code translate="no" dir="ltr">tf.data</code></a> module.</span></aside> <p>On construction the <code translate="no" dir="ltr">QueueRunner</code> adds an op to close the queue. That op will be run if the enqueue ops raise exceptions.</p> <p>When you later call the <code translate="no" dir="ltr">create_threads()</code> method, the <code translate="no" dir="ltr">QueueRunner</code> will create one thread for each op in <code translate="no" dir="ltr">enqueue_ops</code>. Each thread will run its enqueue op in parallel with the other threads. The enqueue ops do not have to all be the same op, but it is expected that they all enqueue tensors in <code translate="no" dir="ltr">queue</code>.</p> <h4 id="args">Args:</h4> <ul> <li>
<b><code translate="no" dir="ltr">queue</code></b>: A <code translate="no" dir="ltr">Queue</code>.</li> <li>
<b><code translate="no" dir="ltr">enqueue_ops</code></b>: List of enqueue ops to run in threads later.</li> <li>
<b><code translate="no" dir="ltr">close_op</code></b>: Op to close the queue. Pending enqueue ops are preserved.</li> <li>
<b><code translate="no" dir="ltr">cancel_op</code></b>: Op to close the queue and cancel pending enqueue ops.</li> <li>
<b><code translate="no" dir="ltr">queue_closed_exception_types</code></b>: Optional tuple of Exception types that indicate that the queue has been closed when raised during an enqueue operation. Defaults to <code translate="no" dir="ltr">(tf.errors.OutOfRangeError,)</code>. Another common case includes <code translate="no" dir="ltr">(tf.errors.OutOfRangeError, tf.errors.CancelledError)</code>, when some of the enqueue ops may dequeue from other Queues.</li> <li>
<b><code translate="no" dir="ltr">queue_runner_def</code></b>: Optional <code translate="no" dir="ltr">QueueRunnerDef</code> protocol buffer. If specified, recreates the QueueRunner from its contents. <code translate="no" dir="ltr">queue_runner_def</code> and the other arguments are mutually exclusive.</li> <li>
<b><code translate="no" dir="ltr">import_scope</code></b>: Optional <code translate="no" dir="ltr">string</code>. Name scope to add. Only used when initializing from protocol buffer.</li> </ul> <h4 id="raises">Raises:</h4> <ul> <li>
<b><code translate="no" dir="ltr">ValueError</code></b>: If both <code translate="no" dir="ltr">queue_runner_def</code> and <code translate="no" dir="ltr">queue</code> are both specified.</li> <li>
<b><code translate="no" dir="ltr">ValueError</code></b>: If <code translate="no" dir="ltr">queue</code> or <code translate="no" dir="ltr">enqueue_ops</code> are not provided when not restoring from <code translate="no" dir="ltr">queue_runner_def</code>.</li> <li>
<b><code translate="no" dir="ltr">RuntimeError</code></b>: If eager execution is enabled.</li> </ul> <h2 id="properties">Properties</h2> <h3 id="cancel_op"><code translate="no" dir="ltr">cancel_op</code></h3> <h3 id="close_op"><code translate="no" dir="ltr">close_op</code></h3> <h3 id="enqueue_ops"><code translate="no" dir="ltr">enqueue_ops</code></h3> <h3 id="exceptions_raised"><code translate="no" dir="ltr">exceptions_raised</code></h3> <p>Exceptions raised but not handled by the <code translate="no" dir="ltr">QueueRunner</code> threads.</p> <p>Exceptions raised in queue runner threads are handled in one of two ways depending on whether or not a <code translate="no" dir="ltr">Coordinator</code> was passed to <code translate="no" dir="ltr">create_threads()</code>:</p> <ul> <li>With a <code translate="no" dir="ltr">Coordinator</code>, exceptions are reported to the coordinator and forgotten by the <code translate="no" dir="ltr">QueueRunner</code>.</li> <li>Without a <code translate="no" dir="ltr">Coordinator</code>, exceptions are captured by the <code translate="no" dir="ltr">QueueRunner</code> and made available in this <code translate="no" dir="ltr">exceptions_raised</code> property.</li> </ul> <h4 id="returns">Returns:</h4> <p>A list of Python <code translate="no" dir="ltr">Exception</code> objects. The list is empty if no exception was captured. (No exceptions are captured when using a Coordinator.)</p> <h3 id="name"><code translate="no" dir="ltr">name</code></h3> <p>The string name of the underlying Queue.</p> <h3 id="queue"><code translate="no" dir="ltr">queue</code></h3> <h3 id="queue_closed_exception_types"><code translate="no" dir="ltr">queue_closed_exception_types</code></h3> <h2 id="methods">Methods</h2> <h3 id="create_threads"><code translate="no" dir="ltr">create_threads</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.1/tensorflow/python/training/queue_runner_impl.py#L301-L356">View source</a></p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">create_threads(
    sess,
    coord=None,
    daemon=False,
    start=False
)
</pre> <p>Create threads to run the enqueue ops for the given session.</p> <p>This method requires a session in which the graph was launched. It creates a list of threads, optionally starting them. There is one thread for each op passed in <code translate="no" dir="ltr">enqueue_ops</code>.</p> <p>The <code translate="no" dir="ltr">coord</code> argument is an optional coordinator that the threads will use to terminate together and report exceptions. If a coordinator is given, this method starts an additional thread to close the queue when the coordinator requests a stop.</p> <p>If previously created threads for the given session are still running, no new threads will be created.</p> <h4 id="args_2">Args:</h4> <ul> <li>
<b><code translate="no" dir="ltr">sess</code></b>: A <code translate="no" dir="ltr">Session</code>.</li> <li>
<b><code translate="no" dir="ltr">coord</code></b>: Optional <code translate="no" dir="ltr">Coordinator</code> object for reporting errors and checking stop conditions.</li> <li>
<b><code translate="no" dir="ltr">daemon</code></b>: Boolean. If <code translate="no" dir="ltr">True</code> make the threads daemon threads.</li> <li>
<b><code translate="no" dir="ltr">start</code></b>: Boolean. If <code translate="no" dir="ltr">True</code> starts the threads. If <code translate="no" dir="ltr">False</code> the caller must call the <code translate="no" dir="ltr">start()</code> method of the returned threads.</li> </ul> <h4 id="returns_2">Returns:</h4> <p>A list of threads.</p> <h3 id="from_proto"><code translate="no" dir="ltr">from_proto</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.1/tensorflow/python/training/queue_runner_impl.py#L387-L391">View source</a></p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">@staticmethod
from_proto(
    queue_runner_def,
    import_scope=None
)
</pre> <p>Returns a <code translate="no" dir="ltr">QueueRunner</code> object created from <code translate="no" dir="ltr">queue_runner_def</code>.</p> <h3 id="to_proto"><code translate="no" dir="ltr">to_proto</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.1/tensorflow/python/training/queue_runner_impl.py#L358-L385">View source</a></p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">to_proto(export_scope=None)
</pre> <p>Converts this <code translate="no" dir="ltr">QueueRunner</code> to a <code translate="no" dir="ltr">QueueRunnerDef</code> protocol buffer.</p> <h4 id="args_3">Args:</h4> <ul> <li>
<b><code translate="no" dir="ltr">export_scope</code></b>: Optional <code translate="no" dir="ltr">string</code>. Name scope to remove.</li> </ul> <h4 id="returns_3">Returns:</h4> <p>A <code translate="no" dir="ltr">QueueRunnerDef</code> protocol buffer, or <code translate="no" dir="ltr">None</code> if the <code translate="no" dir="ltr">Variable</code> is not in the specified name scope.</p> <h2 id="compat_aliases">Compat aliases</h2> <ul> <li><a href="queuerunner"><code translate="no" dir="ltr">tf.compat.v1.train.queue_runner.QueueRunner</code></a></li> </ul>  <devsite-page-rating position="footer" selected-rating="0" hover-rating-star="0"> </devsite-page-rating><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2019 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/api_docs/python/tf/compat/v1/train/QueueRunner" class="_attribution-link">https://www.tensorflow.org/api_docs/python/tf/compat/v1/train/QueueRunner</a>
  </p>
</div>
