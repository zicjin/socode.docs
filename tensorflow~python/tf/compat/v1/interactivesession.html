<h1 class="devsite-page-title">tf.compat.v1.InteractiveSession</h1>     <div itemscope itemtype="http://developers.google.com/ReferenceObject"> <meta itemprop="name" content="tf.compat.v1.InteractiveSession"> <meta itemprop="path" content="Stable"> <meta itemprop="property" content="graph"> <meta itemprop="property" content="graph_def"> <meta itemprop="property" content="sess_str"> <meta itemprop="property" content="__init__"> <meta itemprop="property" content="as_default"> <meta itemprop="property" content="close"> <meta itemprop="property" content="list_devices"> <meta itemprop="property" content="make_callable"> <meta itemprop="property" content="partial_run"> <meta itemprop="property" content="partial_run_setup"> <meta itemprop="property" content="run"> </div>  <table class="tfo-notebook-buttons tfo-api" align="left"> <td> <a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.1/tensorflow/python/client/session.py#L1680-L1785">  View source on GitHub </a> </td>
</table>  <h2 id="class_interactivesession">Class <code translate="no" dir="ltr">InteractiveSession</code>
</h2> <p>A TensorFlow <code translate="no" dir="ltr">Session</code> for use in interactive contexts, such as a shell.</p>  <p>The only difference with a regular <code translate="no" dir="ltr">Session</code> is that an <code translate="no" dir="ltr">InteractiveSession</code> installs itself as the default session on construction. The methods <a href="../../tensor#eval"><code translate="no" dir="ltr">tf.Tensor.eval</code></a> and <a href="../../operation#run"><code translate="no" dir="ltr">tf.Operation.run</code></a> will use that session to run ops.</p> <p>This is convenient in interactive shells and <a href="http://ipython.org">IPython notebooks</a>, as it avoids having to pass an explicit <code translate="no" dir="ltr">Session</code> object to run ops.</p> <h4 id="for_example">For example:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">sess = tf.compat.v1.InteractiveSession()
a = tf.constant(5.0)
b = tf.constant(6.0)
c = a * b
# We can just use 'c.eval()' without passing 'sess'
print(c.eval())
sess.close()
</pre> <p>Note that a regular session installs itself as the default session when it is created in a <code translate="no" dir="ltr">with</code> statement. The common usage in non-interactive programs is to follow that pattern:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">a = tf.constant(5.0)
b = tf.constant(6.0)
c = a * b
with tf.compat.v1.Session():
  # We can also use 'c.eval()' here.
  print(c.eval())
</pre> <h2 id="__init__"><code translate="no" dir="ltr">__init__</code></h2> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.1/tensorflow/python/client/session.py#L1722-L1770">View source</a></p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">__init__(
    target='',
    graph=None,
    config=None
)
</pre> <p>Creates a new interactive TensorFlow session.</p> <p>If no <code translate="no" dir="ltr">graph</code> argument is specified when constructing the session, the default graph will be launched in the session. If you are using more than one graph (created with <a href="../../graph"><code translate="no" dir="ltr">tf.Graph()</code></a>) in the same process, you will have to use different sessions for each graph, but each graph can be used in multiple sessions. In this case, it is often clearer to pass the graph to be launched explicitly to the session constructor.</p> <h4 id="args">Args:</h4> <ul> <li>
<b><code translate="no" dir="ltr">target</code></b>: (Optional.) The execution engine to connect to. Defaults to using an in-process engine.</li> <li>
<b><code translate="no" dir="ltr">graph</code></b>: (Optional.) The <code translate="no" dir="ltr">Graph</code> to be launched (described above).</li> <li>
<b><code translate="no" dir="ltr">config</code></b>: (Optional) <code translate="no" dir="ltr">ConfigProto</code> proto used to configure the session.</li> </ul> <h2 id="properties">Properties</h2> <h3 id="graph"><code translate="no" dir="ltr">graph</code></h3> <p>The graph that was launched in this session.</p> <h3 id="graph_def"><code translate="no" dir="ltr">graph_def</code></h3> <p>A serializable version of the underlying TensorFlow graph.</p> <h4 id="returns">Returns:</h4> <p>A graph_pb2.GraphDef proto containing nodes for all of the Operations in the underlying TensorFlow graph.</p> <h3 id="sess_str"><code translate="no" dir="ltr">sess_str</code></h3> <p>The TensorFlow process to which this session will connect.</p> <h2 id="methods">Methods</h2> <h3 id="as_default"><code translate="no" dir="ltr">as_default</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.1/tensorflow/python/client/session.py#L795-L848">View source</a></p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">as_default()
</pre> <p>Returns a context manager that makes this object the default session.</p> <p>Use with the <code translate="no" dir="ltr">with</code> keyword to specify that calls to <a href="../../operation#run"><code translate="no" dir="ltr">tf.Operation.run</code></a> or <a href="../../tensor#eval"><code translate="no" dir="ltr">tf.Tensor.eval</code></a> should be executed in this session.</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">c = tf.constant(..)
sess = tf.compat.v1.Session()

with sess.as_default():
  assert tf.compat.v1.get_default_session() is sess
  print(c.eval())
</pre> <p>To get the current default session, use <a href="get_default_session"><code translate="no" dir="ltr">tf.compat.v1.get_default_session</code></a>.</p> <p><em>N.B.</em> The <code translate="no" dir="ltr">as_default</code> context manager <em>does not</em> close the session when you exit the context, and you must close the session explicitly.</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">c = tf.constant(...)
sess = tf.compat.v1.Session()
with sess.as_default():
  print(c.eval())
# ...
with sess.as_default():
  print(c.eval())

sess.close()
</pre> <p>Alternatively, you can use <code translate="no" dir="ltr">with tf.compat.v1.Session():</code> to create a session that is automatically closed on exiting the context, including when an uncaught exception is raised.</p> <p><em>N.B.</em> The default session is a property of the current thread. If you create a new thread, and wish to use the default session in that thread, you must explicitly add a <code translate="no" dir="ltr">with sess.as_default():</code> in that thread's function.</p> <p><em>N.B.</em> Entering a <code translate="no" dir="ltr">with sess.as_default():</code> block does not affect the current default graph. If you are using multiple graphs, and <code translate="no" dir="ltr">sess.graph</code> is different from the value of <a href="get_default_graph"><code translate="no" dir="ltr">tf.compat.v1.get_default_graph</code></a>, you must explicitly enter a <code translate="no" dir="ltr">with sess.graph.as_default():</code> block to make <code translate="no" dir="ltr">sess.graph</code> the default graph.</p> <h4 id="returns_2">Returns:</h4> <p>A context manager using this session as the default session.</p> <h3 id="close"><code translate="no" dir="ltr">close</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.1/tensorflow/python/client/session.py#L1772-L1785">View source</a></p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">close()
</pre> <p>Closes an <code translate="no" dir="ltr">InteractiveSession</code>.</p> <h3 id="list_devices"><code translate="no" dir="ltr">list_devices</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.1/tensorflow/python/client/session.py#L708-L744">View source</a></p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">list_devices()
</pre> <p>Lists available devices in this session.</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">devices = sess.list_devices()
for d in devices:
  print(d.name)
</pre> <h4 id="where">Where:</h4> <p>Each element in the list has the following properties</p> <ul> <li>
<b><code translate="no" dir="ltr">name</code></b>: A string with the full name of the device. ex: <code translate="no" dir="ltr">/job:worker/replica:0/task:3/device:CPU:0</code>
</li> <li>
<b><code translate="no" dir="ltr">device_type</code></b>: The type of the device (e.g. <code translate="no" dir="ltr">CPU</code>, <code translate="no" dir="ltr">GPU</code>, <code translate="no" dir="ltr">TPU</code>.)</li> <li>
<b><code translate="no" dir="ltr">memory_limit</code></b>: The maximum amount of memory available on the device. Note: depending on the device, it is possible the usable memory could be substantially less.</li> </ul> <h4 id="raises">Raises:</h4> <ul> <li>
<b><a href="../../errors/operror"><code translate="no" dir="ltr">tf.errors.OpError</code></a></b>: If it encounters an error (e.g. session is in an invalid state, or network errors occur).</li> </ul> <h4 id="returns_3">Returns:</h4> <p>A list of devices in the session.</p> <h3 id="make_callable"><code translate="no" dir="ltr">make_callable</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.1/tensorflow/python/client/session.py#L1188-L1311">View source</a></p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">make_callable(
    fetches,
    feed_list=None,
    accept_options=False
)
</pre> <p>Returns a Python callable that runs a particular step.</p> <p>The returned callable will take <code translate="no" dir="ltr">len(feed_list)</code> arguments whose types must be compatible feed values for the respective elements of <code translate="no" dir="ltr">feed_list</code>. For example, if element <code translate="no" dir="ltr">i</code> of <code translate="no" dir="ltr">feed_list</code> is a <a href="../../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, the <code translate="no" dir="ltr">i</code>th argument to the returned callable must be a numpy ndarray (or something convertible to an ndarray) with matching element type and shape. See <code translate="no" dir="ltr">tf.Session.run</code> for details of the allowable feed key and value types.</p> <p>The returned callable will have the same return type as <code translate="no" dir="ltr">tf.Session.run(fetches, ...)</code>. For example, if <code translate="no" dir="ltr">fetches</code> is a <a href="../../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, the callable will return a numpy ndarray; if <code translate="no" dir="ltr">fetches</code> is a <a href="../../operation"><code translate="no" dir="ltr">tf.Operation</code></a>, it will return <code translate="no" dir="ltr">None</code>.</p> <h4 id="args_2">Args:</h4> <ul> <li>
<b><code translate="no" dir="ltr">fetches</code></b>: A value or list of values to fetch. See <code translate="no" dir="ltr">tf.Session.run</code> for details of the allowable fetch types.</li> <li>
<b><code translate="no" dir="ltr">feed_list</code></b>: (Optional.) A list of <code translate="no" dir="ltr">feed_dict</code> keys. See <code translate="no" dir="ltr">tf.Session.run</code> for details of the allowable feed key types.</li> <li>
<b><code translate="no" dir="ltr">accept_options</code></b>: (Optional.) If <code translate="no" dir="ltr">True</code>, the returned <code translate="no" dir="ltr">Callable</code> will be able to accept <a href="runoptions"><code translate="no" dir="ltr">tf.compat.v1.RunOptions</code></a> and <a href="runmetadata"><code translate="no" dir="ltr">tf.compat.v1.RunMetadata</code></a> as optional keyword arguments <code translate="no" dir="ltr">options</code> and <code translate="no" dir="ltr">run_metadata</code>, respectively, with the same syntax and semantics as <code translate="no" dir="ltr">tf.Session.run</code>, which is useful for certain use cases (profiling and debugging) but will result in measurable slowdown of the <code translate="no" dir="ltr">Callable</code>'s performance. Default: <code translate="no" dir="ltr">False</code>.</li> </ul> <h4 id="returns_4">Returns:</h4> <p>A function that when called will execute the step defined by <code translate="no" dir="ltr">feed_list</code> and <code translate="no" dir="ltr">fetches</code> in this session.</p> <h4 id="raises_2">Raises:</h4> <ul> <li>
<b><code translate="no" dir="ltr">TypeError</code></b>: If <code translate="no" dir="ltr">fetches</code> or <code translate="no" dir="ltr">feed_list</code> cannot be interpreted as arguments to <code translate="no" dir="ltr">tf.Session.run</code>.</li> </ul> <h3 id="partial_run"><code translate="no" dir="ltr">partial_run</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.1/tensorflow/python/client/session.py#L971-L1016">View source</a></p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">partial_run(
    handle,
    fetches,
    feed_dict=None
)
</pre> <p>Continues the execution with more feeds and fetches.</p> <p>This is EXPERIMENTAL and subject to change.</p> <p>To use partial execution, a user first calls <code translate="no" dir="ltr">partial_run_setup()</code> and then a sequence of <code translate="no" dir="ltr">partial_run()</code>. <code translate="no" dir="ltr">partial_run_setup</code> specifies the list of feeds and fetches that will be used in the subsequent <code translate="no" dir="ltr">partial_run</code> calls.</p> <p>The optional <code translate="no" dir="ltr">feed_dict</code> argument allows the caller to override the value of tensors in the graph. See run() for more information.</p> <p>Below is a simple example:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">a = array_ops.placeholder(dtypes.float32, shape=[])
b = array_ops.placeholder(dtypes.float32, shape=[])
c = array_ops.placeholder(dtypes.float32, shape=[])
r1 = math_ops.add(a, b)
r2 = math_ops.multiply(r1, c)

h = sess.partial_run_setup([r1, r2], [a, b, c])
res = sess.partial_run(h, r1, feed_dict={a: 1, b: 2})
res = sess.partial_run(h, r2, feed_dict={c: res})
</pre> <h4 id="args_3">Args:</h4> <ul> <li>
<b><code translate="no" dir="ltr">handle</code></b>: A handle for a sequence of partial runs.</li> <li>
<b><code translate="no" dir="ltr">fetches</code></b>: A single graph element, a list of graph elements, or a dictionary whose values are graph elements or lists of graph elements (see documentation for <code translate="no" dir="ltr">run</code>).</li> <li>
<b><code translate="no" dir="ltr">feed_dict</code></b>: A dictionary that maps graph elements to values (described above).</li> </ul> <h4 id="returns_5">Returns:</h4> <p>Either a single value if <code translate="no" dir="ltr">fetches</code> is a single graph element, or a list of values if <code translate="no" dir="ltr">fetches</code> is a list, or a dictionary with the same keys as <code translate="no" dir="ltr">fetches</code> if that is a dictionary (see documentation for <code translate="no" dir="ltr">run</code>).</p> <h4 id="raises_3">Raises:</h4> <ul> <li>
<b><a href="../../errors/operror"><code translate="no" dir="ltr">tf.errors.OpError</code></a></b>: Or one of its subclasses on error.</li> </ul> <h3 id="partial_run_setup"><code translate="no" dir="ltr">partial_run_setup</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.1/tensorflow/python/client/session.py#L1018-L1092">View source</a></p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">partial_run_setup(
    fetches,
    feeds=None
)
</pre> <p>Sets up a graph with feeds and fetches for partial run.</p> <p>This is EXPERIMENTAL and subject to change.</p> <p>Note that contrary to <code translate="no" dir="ltr">run</code>, <code translate="no" dir="ltr">feeds</code> only specifies the graph elements. The tensors will be supplied by the subsequent <code translate="no" dir="ltr">partial_run</code> calls.</p> <h4 id="args_4">Args:</h4> <ul> <li>
<b><code translate="no" dir="ltr">fetches</code></b>: A single graph element, or a list of graph elements.</li> <li>
<b><code translate="no" dir="ltr">feeds</code></b>: A single graph element, or a list of graph elements.</li> </ul> <h4 id="returns_6">Returns:</h4> <p>A handle for partial run.</p> <h4 id="raises_4">Raises:</h4> <ul> <li>
<b><code translate="no" dir="ltr">RuntimeError</code></b>: If this <code translate="no" dir="ltr">Session</code> is in an invalid state (e.g. has been closed).</li> <li>
<b><code translate="no" dir="ltr">TypeError</code></b>: If <code translate="no" dir="ltr">fetches</code> or <code translate="no" dir="ltr">feed_dict</code> keys are of an inappropriate type.</li> <li>
<b><a href="../../errors/operror"><code translate="no" dir="ltr">tf.errors.OpError</code></a></b>: Or one of its subclasses if a TensorFlow error happens.</li> </ul> <h3 id="run"><code translate="no" dir="ltr">run</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.1/tensorflow/python/client/session.py#L850-L969">View source</a></p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">run(
    fetches,
    feed_dict=None,
    options=None,
    run_metadata=None
)
</pre> <p>Runs operations and evaluates tensors in <code translate="no" dir="ltr">fetches</code>.</p> <p>This method runs one "step" of TensorFlow computation, by running the necessary graph fragment to execute every <code translate="no" dir="ltr">Operation</code> and evaluate every <code translate="no" dir="ltr">Tensor</code> in <code translate="no" dir="ltr">fetches</code>, substituting the values in <code translate="no" dir="ltr">feed_dict</code> for the corresponding input values.</p> <p>The <code translate="no" dir="ltr">fetches</code> argument may be a single graph element, or an arbitrarily nested list, tuple, namedtuple, dict, or OrderedDict containing graph elements at its leaves. A graph element can be one of the following types:</p> <ul> <li>A <a href="../../operation"><code translate="no" dir="ltr">tf.Operation</code></a>. The corresponding fetched value will be <code translate="no" dir="ltr">None</code>.</li> <li>A <a href="../../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>. The corresponding fetched value will be a numpy ndarray containing the value of that tensor.</li> <li>A <a href="../../sparse/sparsetensor"><code translate="no" dir="ltr">tf.SparseTensor</code></a>. The corresponding fetched value will be a <a href="sparsetensorvalue"><code translate="no" dir="ltr">tf.compat.v1.SparseTensorValue</code></a> containing the value of that sparse tensor.</li> <li>A <code translate="no" dir="ltr">get_tensor_handle</code> op. The corresponding fetched value will be a numpy ndarray containing the handle of that tensor.</li> <li>A <code translate="no" dir="ltr">string</code> which is the name of a tensor or operation in the graph.</li> </ul> <p>The value returned by <code translate="no" dir="ltr">run()</code> has the same shape as the <code translate="no" dir="ltr">fetches</code> argument, where the leaves are replaced by the corresponding values returned by TensorFlow.</p> <h4 id="example">Example:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">a = tf.constant([10, 20])
b = tf.constant([1.0, 2.0])
# 'fetches' can be a singleton
v = session.run(a)
# v is the numpy array [10, 20]
# 'fetches' can be a list.
v = session.run([a, b])
# v is a Python list with 2 numpy arrays: the 1-D array [10, 20] and the
# 1-D array [1.0, 2.0]
# 'fetches' can be arbitrary lists, tuples, namedtuple, dicts:
MyData = collections.namedtuple('MyData', ['a', 'b'])
v = session.run({'k1': MyData(a, b), 'k2': [b, a]})
# v is a dict with
# v['k1'] is a MyData namedtuple with 'a' (the numpy array [10, 20]) and
# 'b' (the numpy array [1.0, 2.0])
# v['k2'] is a list with the numpy array [1.0, 2.0] and the numpy array
# [10, 20].
</pre> <p>The optional <code translate="no" dir="ltr">feed_dict</code> argument allows the caller to override the value of tensors in the graph. Each key in <code translate="no" dir="ltr">feed_dict</code> can be one of the following types:</p> <ul> <li>If the key is a <a href="../../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, the value may be a Python scalar, string, list, or numpy ndarray that can be converted to the same <code translate="no" dir="ltr">dtype</code> as that tensor. Additionally, if the key is a <a href="placeholder"><code translate="no" dir="ltr">tf.compat.v1.placeholder</code></a>, the shape of the value will be checked for compatibility with the placeholder.</li> <li>If the key is a <a href="../../sparse/sparsetensor"><code translate="no" dir="ltr">tf.SparseTensor</code></a>, the value should be a <a href="sparsetensorvalue"><code translate="no" dir="ltr">tf.compat.v1.SparseTensorValue</code></a>.</li> <li>If the key is a nested tuple of <code translate="no" dir="ltr">Tensor</code>s or <code translate="no" dir="ltr">SparseTensor</code>s, the value should be a nested tuple with the same structure that maps to their corresponding values as above.</li> </ul> <p>Each value in <code translate="no" dir="ltr">feed_dict</code> must be convertible to a numpy array of the dtype of the corresponding key.</p> <p>The optional <code translate="no" dir="ltr">options</code> argument expects a [<code translate="no" dir="ltr">RunOptions</code>] proto. The options allow controlling the behavior of this particular step (e.g. turning tracing on).</p> <p>The optional <code translate="no" dir="ltr">run_metadata</code> argument expects a [<code translate="no" dir="ltr">RunMetadata</code>] proto. When appropriate, the non-Tensor output of this step will be collected there. For example, when users turn on tracing in <code translate="no" dir="ltr">options</code>, the profiled info will be collected into this argument and passed back.</p> <h4 id="args_5">Args:</h4> <ul> <li>
<b><code translate="no" dir="ltr">fetches</code></b>: A single graph element, a list of graph elements, or a dictionary whose values are graph elements or lists of graph elements (described above).</li> <li>
<b><code translate="no" dir="ltr">feed_dict</code></b>: A dictionary that maps graph elements to values (described above).</li> <li>
<b><code translate="no" dir="ltr">options</code></b>: A [<code translate="no" dir="ltr">RunOptions</code>] protocol buffer</li> <li>
<b><code translate="no" dir="ltr">run_metadata</code></b>: A [<code translate="no" dir="ltr">RunMetadata</code>] protocol buffer</li> </ul> <h4 id="returns_7">Returns:</h4> <p>Either a single value if <code translate="no" dir="ltr">fetches</code> is a single graph element, or a list of values if <code translate="no" dir="ltr">fetches</code> is a list, or a dictionary with the same keys as <code translate="no" dir="ltr">fetches</code> if that is a dictionary (described above). Order in which <code translate="no" dir="ltr">fetches</code> operations are evaluated inside the call is undefined.</p> <h4 id="raises_5">Raises:</h4> <ul> <li>
<b><code translate="no" dir="ltr">RuntimeError</code></b>: If this <code translate="no" dir="ltr">Session</code> is in an invalid state (e.g. has been closed).</li> <li>
<b><code translate="no" dir="ltr">TypeError</code></b>: If <code translate="no" dir="ltr">fetches</code> or <code translate="no" dir="ltr">feed_dict</code> keys are of an inappropriate type.</li> <li>
<b><code translate="no" dir="ltr">ValueError</code></b>: If <code translate="no" dir="ltr">fetches</code> or <code translate="no" dir="ltr">feed_dict</code> keys are invalid or refer to a <code translate="no" dir="ltr">Tensor</code> that doesn't exist.</li> </ul>  <devsite-page-rating position="footer" selected-rating="0" hover-rating-star="0"> </devsite-page-rating><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2019 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/api_docs/python/tf/compat/v1/InteractiveSession" class="_attribution-link">https://www.tensorflow.org/api_docs/python/tf/compat/v1/InteractiveSession</a>
  </p>
</div>
