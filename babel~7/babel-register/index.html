<div class="navPusher"><div class="docMainWrapper wrapper">

<div class="container mainContainer docsContainer"><div class="wrapper"><div class="post">
<header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">@babel/register</h1></header><article><div><span><p>One of the ways you can use Babel is through the require hook. The require hook will bind itself to node's <code>require</code> and automatically compile files on the fly. This is equivalent to CoffeeScript's <a href="http://coffeescript.org/v2/annotated-source/register.html">coffee-script/register</a>.</p> <h2>
Install</h2> <pre><code class="hljs css language-sh">npm install @babel/core @babel/register --save-dev
</code></pre> <h2>
Usage</h2> <pre><code class="hljs css language-js"><span class="hljs-built_in">require</span>(<span class="hljs-string">"@babel/register"</span>);
</code></pre> <p>All subsequent files required by node with the extensions <code>.es6</code>, <code>.es</code>, <code>.jsx</code>, <code>.mjs</code>, and <code>.js</code> will be transformed by Babel.</p> <blockquote class="babel-callout babel-callout-info"> <h4>Polyfill not included</h4> <p> You must include the <a href="babel-polyfill.html/index">polyfill</a> separately when using features that require it, like generators. </p> </blockquote> <h3>
Ignores <code>node_modules</code> by default</h3> <p><strong>NOTE:</strong> By default all requires to <code>node_modules</code> will be ignored. You can override this by passing an ignore regex via:</p> <pre><code class="hljs css language-js"><span class="hljs-built_in">require</span>(<span class="hljs-string">"@babel/register"</span>)({
  <span class="hljs-comment">// This will override `node_modules` ignoring - you can alternatively pass</span>
  <span class="hljs-comment">// an array of strings to be explicitly matched or a regex / glob</span>
  <span class="hljs-attr">ignore</span>: [],
});
</code></pre> <h2>
Specifying options</h2> <pre><code class="hljs css language-javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">"@babel/register"</span>)({
  <span class="hljs-comment">// Array of ignore conditions, either a regex or a function. (Optional)</span>
  <span class="hljs-comment">// File paths that match any condition are not compiled.</span>
  <span class="hljs-attr">ignore</span>: [
    <span class="hljs-comment">// When a file path matches this regex then it is **not** compiled</span>
    <span class="hljs-regexp">/regex/</span>,

    <span class="hljs-comment">// The file's path is also passed to any ignore functions. It will</span>
    <span class="hljs-comment">// **not** be compiled if `true` is returned.</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">filepath</span>) </span>{
      <span class="hljs-keyword">return</span> filepath !== <span class="hljs-string">"/path/to/es6-file.js"</span>;
    },
  ],

  <span class="hljs-comment">// Array of accept conditions, either a regex or a function. (Optional)</span>
  <span class="hljs-comment">// File paths that match all conditions are compiled.</span>
  <span class="hljs-attr">only</span>: [
    <span class="hljs-comment">// File paths that **don't** match this regex are not compiled</span>
    <span class="hljs-regexp">/my_es6_folder/</span>,

    <span class="hljs-comment">// File paths that **do not** return true are not compiled</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">filepath</span>) </span>{
      <span class="hljs-keyword">return</span> filepath === <span class="hljs-string">"/path/to/es6-file.js"</span>;
    },
  ],

  <span class="hljs-comment">// Setting this will remove the currently hooked extensions of `.es6`, `.es`, `.jsx`, `.mjs`</span>
  <span class="hljs-comment">// and .js so you'll have to add them back if you want them to be used again.</span>
  <span class="hljs-attr">extensions</span>: [<span class="hljs-string">".es6"</span>, <span class="hljs-string">".es"</span>, <span class="hljs-string">".jsx"</span>, <span class="hljs-string">".js"</span>, <span class="hljs-string">".mjs"</span>],

  <span class="hljs-comment">// Setting this to false will disable the cache.</span>
  <span class="hljs-attr">cache</span>: <span class="hljs-literal">true</span>,
});
</code></pre> <p>You can pass in all other <a href="../options/index">options</a> as well, including <code>plugins</code> and <code>presets</code>. Note that <a href="../config-files/index">config files</a> will also be loaded and the programmatic config will be merged over top of the file config options. <code>@babel/register</code> does not support <code>ignore</code> and <code>only</code> in config files.</p> <h2>
Environment variables</h2> <p>By default <code>@babel/node</code> cli and <code>@babel/register</code> will save to a json cache in your temporary directory.</p> <p>This will heavily improve with the startup and compilation of your files. There are however scenarios where you want to change this behaviour and there are environment variables exposed to allow you to do this.</p> <h3>
BABEL_CACHE_PATH</h3> <p>Specify a different cache location.</p> <pre><code class="hljs css language-sh">BABEL_CACHE_PATH=/foo/my-cache.json babel-node script.js
</code></pre> <h3>
BABEL_DISABLE_CACHE</h3> <p>Disable the cache.</p> <pre><code class="hljs css language-sh">BABEL_DISABLE_CACHE=1 babel-node script.js
</code></pre> <h2>
Compiling plugins and presets on the fly</h2> <p><code>@babel/register</code> uses Node's <code>require()</code> hook system to compile files on the fly when they are loaded. While this is quite helpful overall, it means that there can be confusing cases where code within a <code>require()</code> hook causes <em>more</em> calls to <code>require</code>, causing a dependency cycle. In Babel's case for instance, this could mean that in the process of Babel trying to compile a user's file, Babel could end up trying to compile itself <em>as it is loading</em>.</p> <p>To avoid this problem, this module explicitly disallows re-entrant compilation, e.g. Babel's own compilation logic explicitly cannot trigger further compilation of any other files on the fly. The downside of this is that if you want to define a plugin or preset that is itself live-compiled, the process is complicated.</p> <p>The crux of it is that your own code needs to load the plugin/preset first. Assuming the plugin/preset loads all of its dependencies up front, what you'll want to do is:</p> <pre><code class="hljs"><span class="hljs-selector-tag">require</span>(<span class="hljs-string">"@babel/register"</span>)({
  <span class="hljs-comment">// ...</span>
});

<span class="hljs-selector-tag">require</span>(<span class="hljs-string">"./my-plugin"</span>);
</code></pre> <p>Because it is your own code that triggered the load, and not the logic within <code>@babel/register</code> itself, this should successfully compile any plugin/preset that loads synchronously.</p> <p><strong>Note:</strong> <code>@babel/register</code> does <em>not</em> support compiling native Node.js ES modules on the fly, since currently there is no stable API for intercepting ES modules loading.</p> </span></div></article>
</div></div></div>

</div></div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://babeljs.io/docs/en/babel-register/" class="_attribution-link" target="_blank">https://babeljs.io/docs/en/babel-register/</a>
  </p>
</div>
