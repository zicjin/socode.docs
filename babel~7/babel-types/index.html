<div class="navPusher"><div class="docMainWrapper wrapper">

<div class="container mainContainer docsContainer"><div class="wrapper"><div class="post">
<header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">@babel/types</h1></header><article><div><span> <blockquote> <p>This module contains methods for building ASTs manually and for checking the types of AST nodes.</p> </blockquote> <h2>
Install</h2> <pre data-language="sh">npm install --save-dev @babel/types
</pre> <h2>
API</h2> <h3>
Node Builders</h3> <h4>
anyTypeAnnotation</h4> <pre data-language="javascript">t.anyTypeAnnotation();
</pre> <p>See also <code>t.isAnyTypeAnnotation(node, opts)</code> and <code>t.assertAnyTypeAnnotation(node, opts)</code>.</p> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a>, <a href="#flowbaseannotation"><code>FlowBaseAnnotation</code></a></p> <hr> <h4>
argumentPlaceholder</h4> <pre data-language="javascript">t.argumentPlaceholder();
</pre> <p>See also <code>t.isArgumentPlaceholder(node, opts)</code> and <code>t.assertArgumentPlaceholder(node, opts)</code>.</p> <p>Aliases: <a href="#proposal"><code>Proposal</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a></p> <hr> <h4>
arrayExpression</h4> <pre data-language="javascript">t.arrayExpression(elements);
</pre> <p>See also <code>t.isArrayExpression(node, opts)</code> and <code>t.assertArrayExpression(node, opts)</code>.</p> <p>AST Node <code>ArrayExpression</code> shape:</p> <ul> <li>
<code>elements</code>: <code>Array&lt;null | Expression | SpreadElement&gt;</code> (default: <code>[]</code>)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
arrayPattern</h4> <pre data-language="javascript">t.arrayPattern(elements);
</pre> <p>See also <code>t.isArrayPattern(node, opts)</code> and <code>t.assertArrayPattern(node, opts)</code>.</p> <p>AST Node <code>ArrayPattern</code> shape:</p> <ul> <li>
<code>elements</code>: <code>Array&lt;null | PatternLike&gt;</code> (required)</li> <li>
<code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>optional</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>typeAnnotation</code>: <code>TypeAnnotation | TSTypeAnnotation | Noop</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#pattern"><code>Pattern</code></a>, <a href="#patternlike"><code>PatternLike</code></a>, <a href="#lval"><code>LVal</code></a></p> <hr> <h4>
arrayTypeAnnotation</h4> <pre data-language="javascript">t.arrayTypeAnnotation(elementType);
</pre> <p>See also <code>t.isArrayTypeAnnotation(node, opts)</code> and <code>t.assertArrayTypeAnnotation(node, opts)</code>.</p> <p>AST Node <code>ArrayTypeAnnotation</code> shape:</p> <ul> <li>
<code>elementType</code>: <code>FlowType</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a></p> <hr> <h4>
arrowFunctionExpression</h4> <pre data-language="javascript">t.arrowFunctionExpression(params, body, async);
</pre> <p>See also <code>t.isArrowFunctionExpression(node, opts)</code> and <code>t.assertArrowFunctionExpression(node, opts)</code>.</p> <p>AST Node <code>ArrowFunctionExpression</code> shape:</p> <ul> <li>
<code>params</code>: <code>Array&lt;Identifier | Pattern | RestElement&gt;</code> (required)</li> <li>
<code>body</code>: <code>BlockStatement | Expression</code> (required)</li> <li>
<code>async</code>: <code>boolean</code> (default: <code>false</code>)</li> <li>
<code>expression</code>: <code>boolean</code> (required)</li> <li>
<code>generator</code>: <code>boolean</code> (default: <code>false</code>, excluded from builder function)</li> <li>
<code>returnType</code>: <code>TypeAnnotation | TSTypeAnnotation | Noop</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>typeParameters</code>: <code>TypeParameterDeclaration | TSTypeParameterDeclaration | Noop</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#scopable"><code>Scopable</code></a>, <a href="#function"><code>Function</code></a>, <a href="#blockparent"><code>BlockParent</code></a>, <a href="#functionparent"><code>FunctionParent</code></a>, <a href="#expression"><code>Expression</code></a>, <a href="#pureish"><code>Pureish</code></a></p> <hr> <h4>
assignmentExpression</h4> <pre data-language="javascript">t.assignmentExpression(operator, left, right);
</pre> <p>See also <code>t.isAssignmentExpression(node, opts)</code> and <code>t.assertAssignmentExpression(node, opts)</code>.</p> <p>AST Node <code>AssignmentExpression</code> shape:</p> <ul> <li>
<code>operator</code>: <code>string</code> (required)</li> <li>
<code>left</code>: <code>LVal</code> (required)</li> <li>
<code>right</code>: <code>Expression</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
assignmentPattern</h4> <pre data-language="javascript">t.assignmentPattern(left, right);
</pre> <p>See also <code>t.isAssignmentPattern(node, opts)</code> and <code>t.assertAssignmentPattern(node, opts)</code>.</p> <p>AST Node <code>AssignmentPattern</code> shape:</p> <ul> <li>
<code>left</code>: <code>Identifier | ObjectPattern | ArrayPattern | MemberExpression</code> (required)</li> <li>
<code>right</code>: <code>Expression</code> (required)</li> <li>
<code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>typeAnnotation</code>: <code>TypeAnnotation | TSTypeAnnotation | Noop</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#pattern"><code>Pattern</code></a>, <a href="#patternlike"><code>PatternLike</code></a>, <a href="#lval"><code>LVal</code></a></p> <hr> <h4>
awaitExpression</h4> <pre data-language="javascript">t.awaitExpression(argument);
</pre> <p>See also <code>t.isAwaitExpression(node, opts)</code> and <code>t.assertAwaitExpression(node, opts)</code>.</p> <p>AST Node <code>AwaitExpression</code> shape:</p> <ul> <li>
<code>argument</code>: <code>Expression</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a>, <a href="#terminatorless"><code>Terminatorless</code></a></p> <hr> <h4>
bigIntLiteral</h4> <pre data-language="javascript">t.bigIntLiteral(value);
</pre> <p>See also <code>t.isBigIntLiteral(node, opts)</code> and <code>t.assertBigIntLiteral(node, opts)</code>.</p> <p>AST Node <code>BigIntLiteral</code> shape:</p> <ul> <li>
<code>value</code>: <code>string</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a>, <a href="#pureish"><code>Pureish</code></a>, <a href="#literal"><code>Literal</code></a>, <a href="#immutable"><code>Immutable</code></a></p> <hr> <h4>
binaryExpression</h4> <pre data-language="javascript">t.binaryExpression(operator, left, right);
</pre> <p>See also <code>t.isBinaryExpression(node, opts)</code> and <code>t.assertBinaryExpression(node, opts)</code>.</p> <p>AST Node <code>BinaryExpression</code> shape:</p> <ul> <li>
<code>operator</code>: <code>"+" | "-" | "/" | "%" | "*" | "**" | "&amp;" | "|" | "&gt;&gt;" | "&gt;&gt;&gt;" | "&lt;&lt;" | "^" | "==" | "===" | "!=" | "!==" | "in" | "instanceof" | "&gt;" | "&lt;" | "&gt;=" | "&lt;="</code> (required)</li> <li>
<code>left</code>: <code>Expression | PrivateName</code> (required)</li> <li>
<code>right</code>: <code>Expression</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#binary"><code>Binary</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
bindExpression</h4> <pre data-language="javascript">t.bindExpression(object, callee);
</pre> <p>See also <code>t.isBindExpression(node, opts)</code> and <code>t.assertBindExpression(node, opts)</code>.</p> <p>AST Node <code>BindExpression</code> shape:</p> <ul> <li>
<code>object</code>: <code>Expression</code> (required)</li> <li>
<code>callee</code>: <code>Expression</code> (required)</li> </ul> <p>Aliases: <a href="#proposal"><code>Proposal</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
blockStatement</h4> <pre data-language="javascript">t.blockStatement(body, directives);
</pre> <p>See also <code>t.isBlockStatement(node, opts)</code> and <code>t.assertBlockStatement(node, opts)</code>.</p> <p>AST Node <code>BlockStatement</code> shape:</p> <ul> <li>
<code>body</code>: <code>Array&lt;Statement&gt;</code> (required)</li> <li>
<code>directives</code>: <code>Array&lt;Directive&gt;</code> (default: <code>[]</code>)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#scopable"><code>Scopable</code></a>, <a href="#blockparent"><code>BlockParent</code></a>, <a href="#block"><code>Block</code></a>, <a href="#statement"><code>Statement</code></a></p> <hr> <h4>
booleanLiteral</h4> <pre data-language="javascript">t.booleanLiteral(value);
</pre> <p>See also <code>t.isBooleanLiteral(node, opts)</code> and <code>t.assertBooleanLiteral(node, opts)</code>.</p> <p>AST Node <code>BooleanLiteral</code> shape:</p> <ul> <li>
<code>value</code>: <code>boolean</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a>, <a href="#pureish"><code>Pureish</code></a>, <a href="#literal"><code>Literal</code></a>, <a href="#immutable"><code>Immutable</code></a></p> <hr> <h4>
booleanLiteralTypeAnnotation</h4> <pre data-language="javascript">t.booleanLiteralTypeAnnotation(value);
</pre> <p>See also <code>t.isBooleanLiteralTypeAnnotation(node, opts)</code> and <code>t.assertBooleanLiteralTypeAnnotation(node, opts)</code>.</p> <p>AST Node <code>BooleanLiteralTypeAnnotation</code> shape:</p> <ul> <li>
<code>value</code>: <code>boolean</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a></p> <hr> <h4>
booleanTypeAnnotation</h4> <pre data-language="javascript">t.booleanTypeAnnotation();
</pre> <p>See also <code>t.isBooleanTypeAnnotation(node, opts)</code> and <code>t.assertBooleanTypeAnnotation(node, opts)</code>.</p> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a>, <a href="#flowbaseannotation"><code>FlowBaseAnnotation</code></a></p> <hr> <h4>
breakStatement</h4> <pre data-language="javascript">t.breakStatement(label);
</pre> <p>See also <code>t.isBreakStatement(node, opts)</code> and <code>t.assertBreakStatement(node, opts)</code>.</p> <p>AST Node <code>BreakStatement</code> shape:</p> <ul> <li>
<code>label</code>: <code>Identifier</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#terminatorless"><code>Terminatorless</code></a>, <a href="#completionstatement"><code>CompletionStatement</code></a></p> <hr> <h4>
callExpression</h4> <pre data-language="javascript">t.callExpression(callee, arguments);
</pre> <p>See also <code>t.isCallExpression(node, opts)</code> and <code>t.assertCallExpression(node, opts)</code>.</p> <p>AST Node <code>CallExpression</code> shape:</p> <ul> <li>
<code>callee</code>: <code>Expression | V8IntrinsicIdentifier</code> (required)</li> <li>
<code>arguments</code>: <code>Array&lt;Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder&gt;</code> (required)</li> <li>
<code>optional</code>: <code>true | false</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>typeArguments</code>: <code>TypeParameterInstantiation</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>typeParameters</code>: <code>TSTypeParameterInstantiation</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
catchClause</h4> <pre data-language="javascript">t.catchClause(param, body);
</pre> <p>See also <code>t.isCatchClause(node, opts)</code> and <code>t.assertCatchClause(node, opts)</code>.</p> <p>AST Node <code>CatchClause</code> shape:</p> <ul> <li>
<code>param</code>: <code>Identifier | ArrayPattern | ObjectPattern</code> (default: <code>null</code>)</li> <li>
<code>body</code>: <code>BlockStatement</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#scopable"><code>Scopable</code></a>, <a href="#blockparent"><code>BlockParent</code></a></p> <hr> <h4>
classBody</h4> <pre data-language="javascript">t.classBody(body);
</pre> <p>See also <code>t.isClassBody(node, opts)</code> and <code>t.assertClassBody(node, opts)</code>.</p> <p>AST Node <code>ClassBody</code> shape:</p> <ul> <li>
<code>body</code>: <code>Array&lt;ClassMethod | ClassPrivateMethod | ClassProperty | ClassPrivateProperty | TSDeclareMethod | TSIndexSignature&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a></p> <hr> <h4>
classDeclaration</h4> <pre data-language="javascript">t.classDeclaration(id, superClass, body, decorators);
</pre> <p>See also <code>t.isClassDeclaration(node, opts)</code> and <code>t.assertClassDeclaration(node, opts)</code>.</p> <p>AST Node <code>ClassDeclaration</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> <li>
<code>superClass</code>: <code>Expression</code> (default: <code>null</code>)</li> <li>
<code>body</code>: <code>ClassBody</code> (required)</li> <li>
<code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>)</li> <li>
<code>abstract</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>declare</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>implements</code>: <code>Array&lt;TSExpressionWithTypeArguments | ClassImplements&gt;</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>mixins</code>: <code>InterfaceExtends</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>superTypeParameters</code>: <code>TypeParameterInstantiation | TSTypeParameterInstantiation</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>typeParameters</code>: <code>TypeParameterDeclaration | TSTypeParameterDeclaration | Noop</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#scopable"><code>Scopable</code></a>, <a href="#class"><code>Class</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
classExpression</h4> <pre data-language="javascript">t.classExpression(id, superClass, body, decorators);
</pre> <p>See also <code>t.isClassExpression(node, opts)</code> and <code>t.assertClassExpression(node, opts)</code>.</p> <p>AST Node <code>ClassExpression</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (default: <code>null</code>)</li> <li>
<code>superClass</code>: <code>Expression</code> (default: <code>null</code>)</li> <li>
<code>body</code>: <code>ClassBody</code> (required)</li> <li>
<code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>)</li> <li>
<code>implements</code>: <code>Array&lt;TSExpressionWithTypeArguments | ClassImplements&gt;</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>mixins</code>: <code>InterfaceExtends</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>superTypeParameters</code>: <code>TypeParameterInstantiation | TSTypeParameterInstantiation</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>typeParameters</code>: <code>TypeParameterDeclaration | TSTypeParameterDeclaration | Noop</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#scopable"><code>Scopable</code></a>, <a href="#class"><code>Class</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
classImplements</h4> <pre data-language="javascript">t.classImplements(id, typeParameters);
</pre> <p>See also <code>t.isClassImplements(node, opts)</code> and <code>t.assertClassImplements(node, opts)</code>.</p> <p>AST Node <code>ClassImplements</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> <li>
<code>typeParameters</code>: <code>TypeParameterInstantiation</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a></p> <hr> <h4>
classMethod</h4> <pre data-language="javascript">t.classMethod(kind, key, params, body, computed, static, generator, async);
</pre> <p>See also <code>t.isClassMethod(node, opts)</code> and <code>t.assertClassMethod(node, opts)</code>.</p> <p>AST Node <code>ClassMethod</code> shape:</p> <ul> <li>
<code>kind</code>: <code>"get" | "set" | "method" | "constructor"</code> (default: <code>'method'</code>)</li> <li>
<code>key</code>: if computed then <code>Expression</code> else <code>Identifier | Literal</code> (required)</li> <li>
<code>params</code>: <code>Array&lt;Identifier | Pattern | RestElement | TSParameterProperty&gt;</code> (required)</li> <li>
<code>body</code>: <code>BlockStatement</code> (required)</li> <li>
<code>computed</code>: <code>boolean</code> (default: <code>false</code>)</li> <li>
<code>static</code>: <code>boolean</code> (default: <code>false</code>)</li> <li>
<code>generator</code>: <code>boolean</code> (default: <code>false</code>)</li> <li>
<code>async</code>: <code>boolean</code> (default: <code>false</code>)</li> <li>
<code>abstract</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>access</code>: <code>"public" | "private" | "protected"</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>accessibility</code>: <code>"public" | "private" | "protected"</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>optional</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>override</code>: <code>boolean</code> (default: <code>false</code>, excluded from builder function)</li> <li>
<code>returnType</code>: <code>TypeAnnotation | TSTypeAnnotation | Noop</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>typeParameters</code>: <code>TypeParameterDeclaration | TSTypeParameterDeclaration | Noop</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#function"><code>Function</code></a>, <a href="#scopable"><code>Scopable</code></a>, <a href="#blockparent"><code>BlockParent</code></a>, <a href="#functionparent"><code>FunctionParent</code></a>, <a href="#method"><code>Method</code></a></p> <hr> <h4>
classPrivateMethod</h4> <pre data-language="javascript">t.classPrivateMethod(kind, key, params, body, static);
</pre> <p>See also <code>t.isClassPrivateMethod(node, opts)</code> and <code>t.assertClassPrivateMethod(node, opts)</code>.</p> <p>AST Node <code>ClassPrivateMethod</code> shape:</p> <ul> <li>
<code>kind</code>: <code>"get" | "set" | "method" | "constructor"</code> (default: <code>'method'</code>)</li> <li>
<code>key</code>: <code>PrivateName</code> (required)</li> <li>
<code>params</code>: <code>Array&lt;Identifier | Pattern | RestElement | TSParameterProperty&gt;</code> (required)</li> <li>
<code>body</code>: <code>BlockStatement</code> (required)</li> <li>
<code>static</code>: <code>boolean</code> (default: <code>false</code>)</li> <li>
<code>abstract</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>access</code>: <code>"public" | "private" | "protected"</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>accessibility</code>: <code>"public" | "private" | "protected"</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>async</code>: <code>boolean</code> (default: <code>false</code>, excluded from builder function)</li> <li>
<code>computed</code>: 'false' (default: <code>false</code>, excluded from builder function)</li> <li>
<code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>generator</code>: <code>boolean</code> (default: <code>false</code>, excluded from builder function)</li> <li>
<code>optional</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>override</code>: <code>boolean</code> (default: <code>false</code>, excluded from builder function)</li> <li>
<code>returnType</code>: <code>TypeAnnotation | TSTypeAnnotation | Noop</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>typeParameters</code>: <code>TypeParameterDeclaration | TSTypeParameterDeclaration | Noop</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#function"><code>Function</code></a>, <a href="#scopable"><code>Scopable</code></a>, <a href="#blockparent"><code>BlockParent</code></a>, <a href="#functionparent"><code>FunctionParent</code></a>, <a href="#method"><code>Method</code></a>, <a href="#private"><code>Private</code></a></p> <hr> <h4>
classPrivateProperty</h4> <pre data-language="javascript">t.classPrivateProperty(key, value, decorators, static);
</pre> <p>See also <code>t.isClassPrivateProperty(node, opts)</code> and <code>t.assertClassPrivateProperty(node, opts)</code>.</p> <p>AST Node <code>ClassPrivateProperty</code> shape:</p> <ul> <li>
<code>key</code>: <code>PrivateName</code> (required)</li> <li>
<code>value</code>: <code>Expression</code> (default: <code>null</code>)</li> <li>
<code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>)</li> <li>
<code>static</code> (required)</li> <li>
<code>definite</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>readonly</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>typeAnnotation</code>: <code>TypeAnnotation | TSTypeAnnotation | Noop</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>variance</code>: <code>Variance</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#property"><code>Property</code></a>, <a href="#private"><code>Private</code></a></p> <hr> <h4>
classProperty</h4> <pre data-language="javascript">t.classProperty(key, value, typeAnnotation, decorators, computed, static);
</pre> <p><details> <summary>History</summary></details></p> <table> <thead> <tr>
<th>Version</th>
<th>Changes</th>
</tr> </thead> <tbody> <tr>
<td><code>v7.6.0</code></td>
<td>Supports <code>static</code>
</td>
</tr> </tbody> </table>  <p>See also <code>t.isClassProperty(node, opts)</code> and <code>t.assertClassProperty(node, opts)</code>.</p> <p>AST Node <code>ClassProperty</code> shape:</p> <ul> <li>
<code>key</code>: <code>Identifier | StringLiteral | NumericLiteral | Expression</code> (required)</li> <li>
<code>value</code>: <code>Expression</code> (default: <code>null</code>)</li> <li>
<code>typeAnnotation</code>: <code>TypeAnnotation | TSTypeAnnotation | Noop</code> (default: <code>null</code>)</li> <li>
<code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>)</li> <li>
<code>computed</code>: <code>boolean</code> (default: <code>false</code>)</li> <li>
<code>static</code>: <code>boolean</code> (default: <code>false</code>)</li> <li>
<code>abstract</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>accessibility</code>: <code>"public" | "private" | "protected"</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>declare</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>definite</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>optional</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>override</code>: <code>boolean</code> (default: <code>false</code>, excluded from builder function)</li> <li>
<code>readonly</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>variance</code>: <code>Variance</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#property"><code>Property</code></a></p> <hr> <h4>
conditionalExpression</h4> <pre data-language="javascript">t.conditionalExpression(test, consequent, alternate);
</pre> <p>See also <code>t.isConditionalExpression(node, opts)</code> and <code>t.assertConditionalExpression(node, opts)</code>.</p> <p>AST Node <code>ConditionalExpression</code> shape:</p> <ul> <li>
<code>test</code>: <code>Expression</code> (required)</li> <li>
<code>consequent</code>: <code>Expression</code> (required)</li> <li>
<code>alternate</code>: <code>Expression</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a>, <a href="#conditional"><code>Conditional</code></a></p> <hr> <h4>
continueStatement</h4> <pre data-language="javascript">t.continueStatement(label);
</pre> <p>See also <code>t.isContinueStatement(node, opts)</code> and <code>t.assertContinueStatement(node, opts)</code>.</p> <p>AST Node <code>ContinueStatement</code> shape:</p> <ul> <li>
<code>label</code>: <code>Identifier</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#terminatorless"><code>Terminatorless</code></a>, <a href="#completionstatement"><code>CompletionStatement</code></a></p> <hr> <h4>
debuggerStatement</h4> <pre data-language="javascript">t.debuggerStatement();
</pre> <p>See also <code>t.isDebuggerStatement(node, opts)</code> and <code>t.assertDebuggerStatement(node, opts)</code>.</p> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#statement"><code>Statement</code></a></p> <hr> <h4>
decimalLiteral</h4> <pre data-language="javascript">t.decimalLiteral(value);
</pre> <p>See also <code>t.isDecimalLiteral(node, opts)</code> and <code>t.assertDecimalLiteral(node, opts)</code>.</p> <p>AST Node <code>DecimalLiteral</code> shape:</p> <ul> <li>
<code>value</code>: <code>string</code> (required)</li> </ul> <p>Aliases: <a href="#proposal"><code>Proposal</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a>, <a href="#pureish"><code>Pureish</code></a>, <a href="#literal"><code>Literal</code></a>, <a href="#immutable"><code>Immutable</code></a></p> <hr> <h4>
declareClass</h4> <pre data-language="javascript">t.declareClass(id, typeParameters, extends, body);
</pre> <p>See also <code>t.isDeclareClass(node, opts)</code> and <code>t.assertDeclareClass(node, opts)</code>.</p> <p>AST Node <code>DeclareClass</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> <li>
<code>typeParameters</code>: <code>TypeParameterDeclaration</code> (default: <code>null</code>)</li> <li>
<code>extends</code>: <code>Array&lt;InterfaceExtends&gt;</code> (default: <code>null</code>)</li> <li>
<code>body</code>: <code>ObjectTypeAnnotation</code> (required)</li> <li>
<code>implements</code>: <code>Array&lt;ClassImplements&gt;</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>mixins</code>: <code>Array&lt;InterfaceExtends&gt;</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowdeclaration"><code>FlowDeclaration</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
declareExportAllDeclaration</h4> <pre data-language="javascript">t.declareExportAllDeclaration(source);
</pre> <p>See also <code>t.isDeclareExportAllDeclaration(node, opts)</code> and <code>t.assertDeclareExportAllDeclaration(node, opts)</code>.</p> <p>AST Node <code>DeclareExportAllDeclaration</code> shape:</p> <ul> <li>
<code>source</code>: <code>StringLiteral</code> (required)</li> <li>
<code>exportKind</code>: <code>"type" | "value"</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowdeclaration"><code>FlowDeclaration</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
declareExportDeclaration</h4> <pre data-language="javascript">t.declareExportDeclaration(declaration, specifiers, source);
</pre> <p>See also <code>t.isDeclareExportDeclaration(node, opts)</code> and <code>t.assertDeclareExportDeclaration(node, opts)</code>.</p> <p>AST Node <code>DeclareExportDeclaration</code> shape:</p> <ul> <li>
<code>declaration</code>: <code>Flow</code> (default: <code>null</code>)</li> <li>
<code>specifiers</code>: <code>Array&lt;ExportSpecifier | ExportNamespaceSpecifier&gt;</code> (default: <code>null</code>)</li> <li>
<code>source</code>: <code>StringLiteral</code> (default: <code>null</code>)</li> <li>
<code>default</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowdeclaration"><code>FlowDeclaration</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
declareFunction</h4> <pre data-language="javascript">t.declareFunction(id);
</pre> <p>See also <code>t.isDeclareFunction(node, opts)</code> and <code>t.assertDeclareFunction(node, opts)</code>.</p> <p>AST Node <code>DeclareFunction</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> <li>
<code>predicate</code>: <code>DeclaredPredicate</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowdeclaration"><code>FlowDeclaration</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
declareInterface</h4> <pre data-language="javascript">t.declareInterface(id, typeParameters, extends, body);
</pre> <p>See also <code>t.isDeclareInterface(node, opts)</code> and <code>t.assertDeclareInterface(node, opts)</code>.</p> <p>AST Node <code>DeclareInterface</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> <li>
<code>typeParameters</code>: <code>TypeParameterDeclaration</code> (default: <code>null</code>)</li> <li>
<code>extends</code>: <code>Array&lt;InterfaceExtends&gt;</code> (default: <code>null</code>)</li> <li>
<code>body</code>: <code>ObjectTypeAnnotation</code> (required)</li> <li>
<code>implements</code>: <code>Array&lt;ClassImplements&gt;</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>mixins</code>: <code>Array&lt;InterfaceExtends&gt;</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowdeclaration"><code>FlowDeclaration</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
declareModule</h4> <pre data-language="javascript">t.declareModule(id, body, kind);
</pre> <p>See also <code>t.isDeclareModule(node, opts)</code> and <code>t.assertDeclareModule(node, opts)</code>.</p> <p>AST Node <code>DeclareModule</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier | StringLiteral</code> (required)</li> <li>
<code>body</code>: <code>BlockStatement</code> (required)</li> <li>
<code>kind</code>: <code>"CommonJS" | "ES"</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowdeclaration"><code>FlowDeclaration</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
declareModuleExports</h4> <pre data-language="javascript">t.declareModuleExports(typeAnnotation);
</pre> <p>See also <code>t.isDeclareModuleExports(node, opts)</code> and <code>t.assertDeclareModuleExports(node, opts)</code>.</p> <p>AST Node <code>DeclareModuleExports</code> shape:</p> <ul> <li>
<code>typeAnnotation</code>: <code>TypeAnnotation</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowdeclaration"><code>FlowDeclaration</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
declareOpaqueType</h4> <pre data-language="javascript">t.declareOpaqueType(id, typeParameters, supertype);
</pre> <p>See also <code>t.isDeclareOpaqueType(node, opts)</code> and <code>t.assertDeclareOpaqueType(node, opts)</code>.</p> <p>AST Node <code>DeclareOpaqueType</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> <li>
<code>typeParameters</code>: <code>TypeParameterDeclaration</code> (default: <code>null</code>)</li> <li>
<code>supertype</code>: <code>FlowType</code> (default: <code>null</code>)</li> <li>
<code>impltype</code>: <code>FlowType</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowdeclaration"><code>FlowDeclaration</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
declareTypeAlias</h4> <pre data-language="javascript">t.declareTypeAlias(id, typeParameters, right);
</pre> <p>See also <code>t.isDeclareTypeAlias(node, opts)</code> and <code>t.assertDeclareTypeAlias(node, opts)</code>.</p> <p>AST Node <code>DeclareTypeAlias</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> <li>
<code>typeParameters</code>: <code>TypeParameterDeclaration</code> (default: <code>null</code>)</li> <li>
<code>right</code>: <code>FlowType</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowdeclaration"><code>FlowDeclaration</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
declareVariable</h4> <pre data-language="javascript">t.declareVariable(id);
</pre> <p>See also <code>t.isDeclareVariable(node, opts)</code> and <code>t.assertDeclareVariable(node, opts)</code>.</p> <p>AST Node <code>DeclareVariable</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowdeclaration"><code>FlowDeclaration</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
declaredPredicate</h4> <pre data-language="javascript">t.declaredPredicate(value);
</pre> <p>See also <code>t.isDeclaredPredicate(node, opts)</code> and <code>t.assertDeclaredPredicate(node, opts)</code>.</p> <p>AST Node <code>DeclaredPredicate</code> shape:</p> <ul> <li>
<code>value</code>: <code>Flow</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowpredicate"><code>FlowPredicate</code></a></p> <hr> <h4>
decorator</h4> <pre data-language="javascript">t.decorator(expression);
</pre> <p>See also <code>t.isDecorator(node, opts)</code> and <code>t.assertDecorator(node, opts)</code>.</p> <p>AST Node <code>Decorator</code> shape:</p> <ul> <li>
<code>expression</code>: <code>Expression</code> (required)</li> </ul> <p>Aliases: <a href="#proposal"><code>Proposal</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a></p> <hr> <h4>
directive</h4> <pre data-language="javascript">t.directive(value);
</pre> <p>See also <code>t.isDirective(node, opts)</code> and <code>t.assertDirective(node, opts)</code>.</p> <p>AST Node <code>Directive</code> shape:</p> <ul> <li>
<code>value</code>: <code>DirectiveLiteral</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a></p> <hr> <h4>
directiveLiteral</h4> <pre data-language="javascript">t.directiveLiteral(value);
</pre> <p>See also <code>t.isDirectiveLiteral(node, opts)</code> and <code>t.assertDirectiveLiteral(node, opts)</code>.</p> <p>AST Node <code>DirectiveLiteral</code> shape:</p> <ul> <li>
<code>value</code>: <code>string</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a></p> <hr> <h4>
doExpression</h4> <pre data-language="javascript">t.doExpression(body, async);
</pre> <p>See also <code>t.isDoExpression(node, opts)</code> and <code>t.assertDoExpression(node, opts)</code>.</p> <p>AST Node <code>DoExpression</code> shape:</p> <ul> <li>
<code>body</code>: <code>BlockStatement</code> (required)</li> <li>
<code>async</code>: <code>boolean</code> (default: <code>false</code>)</li> </ul> <p>Aliases: <a href="#proposal"><code>Proposal</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
doWhileStatement</h4> <pre data-language="javascript">t.doWhileStatement(test, body);
</pre> <p>See also <code>t.isDoWhileStatement(node, opts)</code> and <code>t.assertDoWhileStatement(node, opts)</code>.</p> <p>AST Node <code>DoWhileStatement</code> shape:</p> <ul> <li>
<code>test</code>: <code>Expression</code> (required)</li> <li>
<code>body</code>: <code>Statement</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#blockparent"><code>BlockParent</code></a>, <a href="#loop"><code>Loop</code></a>, <a href="#while"><code>While</code></a>, <a href="#scopable"><code>Scopable</code></a></p> <hr> <h4>
emptyStatement</h4> <pre data-language="javascript">t.emptyStatement();
</pre> <p>See also <code>t.isEmptyStatement(node, opts)</code> and <code>t.assertEmptyStatement(node, opts)</code>.</p> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#statement"><code>Statement</code></a></p> <hr> <h4>
emptyTypeAnnotation</h4> <pre data-language="javascript">t.emptyTypeAnnotation();
</pre> <p>See also <code>t.isEmptyTypeAnnotation(node, opts)</code> and <code>t.assertEmptyTypeAnnotation(node, opts)</code>.</p> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a>, <a href="#flowbaseannotation"><code>FlowBaseAnnotation</code></a></p> <hr> <h4>
enumBooleanBody</h4> <pre data-language="javascript">t.enumBooleanBody(members);
</pre> <p>See also <code>t.isEnumBooleanBody(node, opts)</code> and <code>t.assertEnumBooleanBody(node, opts)</code>.</p> <p>AST Node <code>EnumBooleanBody</code> shape:</p> <ul> <li>
<code>members</code>: <code>Array&lt;EnumBooleanMember&gt;</code> (required)</li> <li>
<code>explicitType</code>: <code>boolean</code> (required)</li> <li>
<code>hasUnknownMembers</code>: <code>boolean</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#enumbody"><code>EnumBody</code></a></p> <hr> <h4>
enumBooleanMember</h4> <pre data-language="javascript">t.enumBooleanMember(id);
</pre> <p>See also <code>t.isEnumBooleanMember(node, opts)</code> and <code>t.assertEnumBooleanMember(node, opts)</code>.</p> <p>AST Node <code>EnumBooleanMember</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> <li>
<code>init</code>: <code>BooleanLiteral</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#enummember"><code>EnumMember</code></a></p> <hr> <h4>
enumDeclaration</h4> <pre data-language="javascript">t.enumDeclaration(id, body);
</pre> <p>See also <code>t.isEnumDeclaration(node, opts)</code> and <code>t.assertEnumDeclaration(node, opts)</code>.</p> <p>AST Node <code>EnumDeclaration</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> <li>
<code>body</code>: <code>EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
enumDefaultedMember</h4> <pre data-language="javascript">t.enumDefaultedMember(id);
</pre> <p>See also <code>t.isEnumDefaultedMember(node, opts)</code> and <code>t.assertEnumDefaultedMember(node, opts)</code>.</p> <p>AST Node <code>EnumDefaultedMember</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#enummember"><code>EnumMember</code></a></p> <hr> <h4>
enumNumberBody</h4> <pre data-language="javascript">t.enumNumberBody(members);
</pre> <p>See also <code>t.isEnumNumberBody(node, opts)</code> and <code>t.assertEnumNumberBody(node, opts)</code>.</p> <p>AST Node <code>EnumNumberBody</code> shape:</p> <ul> <li>
<code>members</code>: <code>Array&lt;EnumNumberMember&gt;</code> (required)</li> <li>
<code>explicitType</code>: <code>boolean</code> (required)</li> <li>
<code>hasUnknownMembers</code>: <code>boolean</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#enumbody"><code>EnumBody</code></a></p> <hr> <h4>
enumNumberMember</h4> <pre data-language="javascript">t.enumNumberMember(id, init);
</pre> <p>See also <code>t.isEnumNumberMember(node, opts)</code> and <code>t.assertEnumNumberMember(node, opts)</code>.</p> <p>AST Node <code>EnumNumberMember</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> <li>
<code>init</code>: <code>NumericLiteral</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#enummember"><code>EnumMember</code></a></p> <hr> <h4>
enumStringBody</h4> <pre data-language="javascript">t.enumStringBody(members);
</pre> <p>See also <code>t.isEnumStringBody(node, opts)</code> and <code>t.assertEnumStringBody(node, opts)</code>.</p> <p>AST Node <code>EnumStringBody</code> shape:</p> <ul> <li>
<code>members</code>: <code>Array&lt;EnumStringMember | EnumDefaultedMember&gt;</code> (required)</li> <li>
<code>explicitType</code>: <code>boolean</code> (required)</li> <li>
<code>hasUnknownMembers</code>: <code>boolean</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#enumbody"><code>EnumBody</code></a></p> <hr> <h4>
enumStringMember</h4> <pre data-language="javascript">t.enumStringMember(id, init);
</pre> <p>See also <code>t.isEnumStringMember(node, opts)</code> and <code>t.assertEnumStringMember(node, opts)</code>.</p> <p>AST Node <code>EnumStringMember</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> <li>
<code>init</code>: <code>StringLiteral</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#enummember"><code>EnumMember</code></a></p> <hr> <h4>
enumSymbolBody</h4> <pre data-language="javascript">t.enumSymbolBody(members);
</pre> <p>See also <code>t.isEnumSymbolBody(node, opts)</code> and <code>t.assertEnumSymbolBody(node, opts)</code>.</p> <p>AST Node <code>EnumSymbolBody</code> shape:</p> <ul> <li>
<code>members</code>: <code>Array&lt;EnumDefaultedMember&gt;</code> (required)</li> <li>
<code>hasUnknownMembers</code>: <code>boolean</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#enumbody"><code>EnumBody</code></a></p> <hr> <h4>
existsTypeAnnotation</h4> <pre data-language="javascript">t.existsTypeAnnotation();
</pre> <p>See also <code>t.isExistsTypeAnnotation(node, opts)</code> and <code>t.assertExistsTypeAnnotation(node, opts)</code>.</p> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a></p> <hr> <h4>
exportAllDeclaration</h4> <pre data-language="javascript">t.exportAllDeclaration(source);
</pre> <p>See also <code>t.isExportAllDeclaration(node, opts)</code> and <code>t.assertExportAllDeclaration(node, opts)</code>.</p> <p>AST Node <code>ExportAllDeclaration</code> shape:</p> <ul> <li>
<code>source</code>: <code>StringLiteral</code> (required)</li> <li>
<code>assertions</code>: <code>Array&lt;ImportAttribute&gt;</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>exportKind</code>: <code>"type" | "value"</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a>, <a href="#moduledeclaration"><code>ModuleDeclaration</code></a>, <a href="#exportdeclaration"><code>ExportDeclaration</code></a></p> <hr> <h4>
exportDefaultDeclaration</h4> <pre data-language="javascript">t.exportDefaultDeclaration(declaration);
</pre> <p>See also <code>t.isExportDefaultDeclaration(node, opts)</code> and <code>t.assertExportDefaultDeclaration(node, opts)</code>.</p> <p>AST Node <code>ExportDefaultDeclaration</code> shape:</p> <ul> <li>
<code>declaration</code>: <code>FunctionDeclaration | TSDeclareFunction | ClassDeclaration | Expression</code> (required)</li> <li>
<code>exportKind</code>: <code>"value"</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a>, <a href="#moduledeclaration"><code>ModuleDeclaration</code></a>, <a href="#exportdeclaration"><code>ExportDeclaration</code></a></p> <hr> <h4>
exportDefaultSpecifier</h4> <pre data-language="javascript">t.exportDefaultSpecifier(exported);
</pre> <p>See also <code>t.isExportDefaultSpecifier(node, opts)</code> and <code>t.assertExportDefaultSpecifier(node, opts)</code>.</p> <p>AST Node <code>ExportDefaultSpecifier</code> shape:</p> <ul> <li>
<code>exported</code>: <code>Identifier</code> (required)</li> </ul> <p>Aliases: <a href="#proposal"><code>Proposal</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#modulespecifier"><code>ModuleSpecifier</code></a></p> <hr> <h4>
exportNamedDeclaration</h4> <pre data-language="javascript">t.exportNamedDeclaration(declaration, specifiers, source);
</pre> <p>See also <code>t.isExportNamedDeclaration(node, opts)</code> and <code>t.assertExportNamedDeclaration(node, opts)</code>.</p> <p>AST Node <code>ExportNamedDeclaration</code> shape:</p> <ul> <li>
<code>declaration</code>: <code>Declaration</code> (default: <code>null</code>)</li> <li>
<code>specifiers</code>: <code>Array&lt;ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier&gt;</code> (default: <code>[]</code>)</li> <li>
<code>source</code>: <code>StringLiteral</code> (default: <code>null</code>)</li> <li>
<code>assertions</code>: <code>Array&lt;ImportAttribute&gt;</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>exportKind</code>: <code>"type" | "value"</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a>, <a href="#moduledeclaration"><code>ModuleDeclaration</code></a>, <a href="#exportdeclaration"><code>ExportDeclaration</code></a></p> <hr> <h4>
exportNamespaceSpecifier</h4> <pre data-language="javascript">t.exportNamespaceSpecifier(exported);
</pre> <p>See also <code>t.isExportNamespaceSpecifier(node, opts)</code> and <code>t.assertExportNamespaceSpecifier(node, opts)</code>.</p> <p>AST Node <code>ExportNamespaceSpecifier</code> shape:</p> <ul> <li>
<code>exported</code>: <code>Identifier</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#modulespecifier"><code>ModuleSpecifier</code></a></p> <hr> <h4>
exportSpecifier</h4> <pre data-language="javascript">t.exportSpecifier(local, exported);
</pre> <p>See also <code>t.isExportSpecifier(node, opts)</code> and <code>t.assertExportSpecifier(node, opts)</code>.</p> <p>AST Node <code>ExportSpecifier</code> shape:</p> <ul> <li>
<code>local</code>: <code>Identifier</code> (required)</li> <li>
<code>exported</code>: <code>Identifier | StringLiteral</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#modulespecifier"><code>ModuleSpecifier</code></a></p> <hr> <h4>
expressionStatement</h4> <pre data-language="javascript">t.expressionStatement(expression);
</pre> <p>See also <code>t.isExpressionStatement(node, opts)</code> and <code>t.assertExpressionStatement(node, opts)</code>.</p> <p>AST Node <code>ExpressionStatement</code> shape:</p> <ul> <li>
<code>expression</code>: <code>Expression</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#expressionwrapper"><code>ExpressionWrapper</code></a></p> <hr> <h4>
file</h4> <pre data-language="javascript">t.file(program, comments, tokens);
</pre> <p>See also <code>t.isFile(node, opts)</code> and <code>t.assertFile(node, opts)</code>.</p> <p>AST Node <code>File</code> shape:</p> <ul> <li>
<code>program</code>: <code>Program</code> (required)</li> <li>
<code>comments</code>: <code>Array&lt;CommentBlock | CommentLine&gt;</code> (default: <code>null</code>)</li> <li>
<code>tokens</code>: <code>Array&lt;any&gt;</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a></p> <hr> <h4>
forInStatement</h4> <pre data-language="javascript">t.forInStatement(left, right, body);
</pre> <p>See also <code>t.isForInStatement(node, opts)</code> and <code>t.assertForInStatement(node, opts)</code>.</p> <p>AST Node <code>ForInStatement</code> shape:</p> <ul> <li>
<code>left</code>: <code>VariableDeclaration | LVal</code> (required)</li> <li>
<code>right</code>: <code>Expression</code> (required)</li> <li>
<code>body</code>: <code>Statement</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#scopable"><code>Scopable</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#for"><code>For</code></a>, <a href="#blockparent"><code>BlockParent</code></a>, <a href="#loop"><code>Loop</code></a>, <a href="#forxstatement"><code>ForXStatement</code></a></p> <hr> <h4>
forOfStatement</h4> <pre data-language="javascript">t.forOfStatement(left, right, body, await);
</pre> <p>See also <code>t.isForOfStatement(node, opts)</code> and <code>t.assertForOfStatement(node, opts)</code>.</p> <p>AST Node <code>ForOfStatement</code> shape:</p> <ul> <li>
<code>left</code>: <code>VariableDeclaration | LVal</code> (required)</li> <li>
<code>right</code>: <code>Expression</code> (required)</li> <li>
<code>body</code>: <code>Statement</code> (required)</li> <li>
<code>await</code>: <code>boolean</code> (default: <code>false</code>)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#scopable"><code>Scopable</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#for"><code>For</code></a>, <a href="#blockparent"><code>BlockParent</code></a>, <a href="#loop"><code>Loop</code></a>, <a href="#forxstatement"><code>ForXStatement</code></a></p> <hr> <h4>
forStatement</h4> <pre data-language="javascript">t.forStatement(init, test, update, body);
</pre> <p>See also <code>t.isForStatement(node, opts)</code> and <code>t.assertForStatement(node, opts)</code>.</p> <p>AST Node <code>ForStatement</code> shape:</p> <ul> <li>
<code>init</code>: <code>VariableDeclaration | Expression</code> (default: <code>null</code>)</li> <li>
<code>test</code>: <code>Expression</code> (default: <code>null</code>)</li> <li>
<code>update</code>: <code>Expression</code> (default: <code>null</code>)</li> <li>
<code>body</code>: <code>Statement</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#scopable"><code>Scopable</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#for"><code>For</code></a>, <a href="#blockparent"><code>BlockParent</code></a>, <a href="#loop"><code>Loop</code></a></p> <hr> <h4>
functionDeclaration</h4> <pre data-language="javascript">t.functionDeclaration(id, params, body, generator, async);
</pre> <p>See also <code>t.isFunctionDeclaration(node, opts)</code> and <code>t.assertFunctionDeclaration(node, opts)</code>.</p> <p>AST Node <code>FunctionDeclaration</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (default: <code>null</code>)</li> <li>
<code>params</code>: <code>Array&lt;Identifier | Pattern | RestElement&gt;</code> (required)</li> <li>
<code>body</code>: <code>BlockStatement</code> (required)</li> <li>
<code>generator</code>: <code>boolean</code> (default: <code>false</code>)</li> <li>
<code>async</code>: <code>boolean</code> (default: <code>false</code>)</li> <li>
<code>declare</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>returnType</code>: <code>TypeAnnotation | TSTypeAnnotation | Noop</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>typeParameters</code>: <code>TypeParameterDeclaration | TSTypeParameterDeclaration | Noop</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#scopable"><code>Scopable</code></a>, <a href="#function"><code>Function</code></a>, <a href="#blockparent"><code>BlockParent</code></a>, <a href="#functionparent"><code>FunctionParent</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#pureish"><code>Pureish</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
functionExpression</h4> <pre data-language="javascript">t.functionExpression(id, params, body, generator, async);
</pre> <p>See also <code>t.isFunctionExpression(node, opts)</code> and <code>t.assertFunctionExpression(node, opts)</code>.</p> <p>AST Node <code>FunctionExpression</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (default: <code>null</code>)</li> <li>
<code>params</code>: <code>Array&lt;Identifier | Pattern | RestElement&gt;</code> (required)</li> <li>
<code>body</code>: <code>BlockStatement</code> (required)</li> <li>
<code>generator</code>: <code>boolean</code> (default: <code>false</code>)</li> <li>
<code>async</code>: <code>boolean</code> (default: <code>false</code>)</li> <li>
<code>returnType</code>: <code>TypeAnnotation | TSTypeAnnotation | Noop</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>typeParameters</code>: <code>TypeParameterDeclaration | TSTypeParameterDeclaration | Noop</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#scopable"><code>Scopable</code></a>, <a href="#function"><code>Function</code></a>, <a href="#blockparent"><code>BlockParent</code></a>, <a href="#functionparent"><code>FunctionParent</code></a>, <a href="#expression"><code>Expression</code></a>, <a href="#pureish"><code>Pureish</code></a></p> <hr> <h4>
functionTypeAnnotation</h4> <pre data-language="javascript">t.functionTypeAnnotation(typeParameters, params, rest, returnType);
</pre> <p>See also <code>t.isFunctionTypeAnnotation(node, opts)</code> and <code>t.assertFunctionTypeAnnotation(node, opts)</code>.</p> <p>AST Node <code>FunctionTypeAnnotation</code> shape:</p> <ul> <li>
<code>typeParameters</code>: <code>TypeParameterDeclaration</code> (default: <code>null</code>)</li> <li>
<code>params</code>: <code>Array&lt;FunctionTypeParam&gt;</code> (required)</li> <li>
<code>rest</code>: <code>FunctionTypeParam</code> (default: <code>null</code>)</li> <li>
<code>returnType</code>: <code>FlowType</code> (required)</li> <li>
<code>this</code>: <code>FunctionTypeParam</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a></p> <hr> <h4>
functionTypeParam</h4> <pre data-language="javascript">t.functionTypeParam(name, typeAnnotation);
</pre> <p>See also <code>t.isFunctionTypeParam(node, opts)</code> and <code>t.assertFunctionTypeParam(node, opts)</code>.</p> <p>AST Node <code>FunctionTypeParam</code> shape:</p> <ul> <li>
<code>name</code>: <code>Identifier</code> (default: <code>null</code>)</li> <li>
<code>typeAnnotation</code>: <code>FlowType</code> (required)</li> <li>
<code>optional</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a></p> <hr> <h4>
genericTypeAnnotation</h4> <pre data-language="javascript">t.genericTypeAnnotation(id, typeParameters);
</pre> <p>See also <code>t.isGenericTypeAnnotation(node, opts)</code> and <code>t.assertGenericTypeAnnotation(node, opts)</code>.</p> <p>AST Node <code>GenericTypeAnnotation</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier | QualifiedTypeIdentifier</code> (required)</li> <li>
<code>typeParameters</code>: <code>TypeParameterInstantiation</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a></p> <hr> <h4>
identifier</h4> <pre data-language="javascript">t.identifier(name);
</pre> <p>See also <code>t.isIdentifier(node, opts)</code> and <code>t.assertIdentifier(node, opts)</code>.</p> <p>AST Node <code>Identifier</code> shape:</p> <ul> <li>
<code>name</code>: <code>string</code> (required)</li> <li>
<code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>optional</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>typeAnnotation</code>: <code>TypeAnnotation | TSTypeAnnotation | Noop</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a>, <a href="#patternlike"><code>PatternLike</code></a>, <a href="#lval"><code>LVal</code></a>, <a href="#tsentityname"><code>TSEntityName</code></a></p> <hr> <h4>
ifStatement</h4> <pre data-language="javascript">t.ifStatement(test, consequent, alternate);
</pre> <p>See also <code>t.isIfStatement(node, opts)</code> and <code>t.assertIfStatement(node, opts)</code>.</p> <p>AST Node <code>IfStatement</code> shape:</p> <ul> <li>
<code>test</code>: <code>Expression</code> (required)</li> <li>
<code>consequent</code>: <code>Statement</code> (required)</li> <li>
<code>alternate</code>: <code>Statement</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#conditional"><code>Conditional</code></a></p> <hr> <h4>
import</h4> <pre data-language="javascript">t.import();
</pre> <p>See also <code>t.isImport(node, opts)</code> and <code>t.assertImport(node, opts)</code>.</p> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
importAttribute</h4> <pre data-language="javascript">t.importAttribute(key, value);
</pre> <p>See also <code>t.isImportAttribute(node, opts)</code> and <code>t.assertImportAttribute(node, opts)</code>.</p> <p>AST Node <code>ImportAttribute</code> shape:</p> <ul> <li>
<code>key</code>: <code>Identifier | StringLiteral</code> (required)</li> <li>
<code>value</code>: <code>StringLiteral</code> (required)</li> </ul> <p>Aliases: <a href="#proposal"><code>Proposal</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a></p> <hr> <h4>
importDeclaration</h4> <pre data-language="javascript">t.importDeclaration(specifiers, source);
</pre> <p>See also <code>t.isImportDeclaration(node, opts)</code> and <code>t.assertImportDeclaration(node, opts)</code>.</p> <p>AST Node <code>ImportDeclaration</code> shape:</p> <ul> <li>
<code>specifiers</code>: <code>Array&lt;ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier&gt;</code> (required)</li> <li>
<code>source</code>: <code>StringLiteral</code> (required)</li> <li>
<code>assertions</code>: <code>Array&lt;ImportAttribute&gt;</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>importKind</code>: <code>"type" | "typeof" | "value"</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a>, <a href="#moduledeclaration"><code>ModuleDeclaration</code></a></p> <hr> <h4>
importDefaultSpecifier</h4> <pre data-language="javascript">t.importDefaultSpecifier(local);
</pre> <p>See also <code>t.isImportDefaultSpecifier(node, opts)</code> and <code>t.assertImportDefaultSpecifier(node, opts)</code>.</p> <p>AST Node <code>ImportDefaultSpecifier</code> shape:</p> <ul> <li>
<code>local</code>: <code>Identifier</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#modulespecifier"><code>ModuleSpecifier</code></a></p> <hr> <h4>
importNamespaceSpecifier</h4> <pre data-language="javascript">t.importNamespaceSpecifier(local);
</pre> <p>See also <code>t.isImportNamespaceSpecifier(node, opts)</code> and <code>t.assertImportNamespaceSpecifier(node, opts)</code>.</p> <p>AST Node <code>ImportNamespaceSpecifier</code> shape:</p> <ul> <li>
<code>local</code>: <code>Identifier</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#modulespecifier"><code>ModuleSpecifier</code></a></p> <hr> <h4>
importSpecifier</h4> <pre data-language="javascript">t.importSpecifier(local, imported);
</pre> <p>See also <code>t.isImportSpecifier(node, opts)</code> and <code>t.assertImportSpecifier(node, opts)</code>.</p> <p>AST Node <code>ImportSpecifier</code> shape:</p> <ul> <li>
<code>local</code>: <code>Identifier</code> (required)</li> <li>
<code>imported</code>: <code>Identifier | StringLiteral</code> (required)</li> <li>
<code>importKind</code>: <code>"type" | "typeof"</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#modulespecifier"><code>ModuleSpecifier</code></a></p> <hr> <h4>
indexedAccessType</h4> <pre data-language="javascript">t.indexedAccessType(objectType, indexType);
</pre> <p>See also <code>t.isIndexedAccessType(node, opts)</code> and <code>t.assertIndexedAccessType(node, opts)</code>.</p> <p>AST Node <code>IndexedAccessType</code> shape:</p> <ul> <li>
<code>objectType</code>: <code>FlowType</code> (required)</li> <li>
<code>indexType</code>: <code>FlowType</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a></p> <hr> <h4>
indexedAccessType</h4> <pre data-language="javascript">t.indexedAccessType(objectType, indexType);
</pre> <p>See also <code>t.isIndexedAccessType(node, opts)</code> and <code>t.assertIndexedAccessType(node, opts)</code>.</p> <p>AST Node <code>IndexedAccessType</code> shape:</p> <ul> <li>
<code>objectType</code>: <code>FlowType</code> (required)</li> <li>
<code>indexType</code>: <code>FlowType</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a></p> <hr> <h4>
inferredPredicate</h4> <pre data-language="javascript">t.inferredPredicate();
</pre> <p>See also <code>t.isInferredPredicate(node, opts)</code> and <code>t.assertInferredPredicate(node, opts)</code>.</p> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowpredicate"><code>FlowPredicate</code></a></p> <hr> <h4>
interfaceDeclaration</h4> <pre data-language="javascript">t.interfaceDeclaration(id, typeParameters, extends, body);
</pre> <p>See also <code>t.isInterfaceDeclaration(node, opts)</code> and <code>t.assertInterfaceDeclaration(node, opts)</code>.</p> <p>AST Node <code>InterfaceDeclaration</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> <li>
<code>typeParameters</code>: <code>TypeParameterDeclaration</code> (default: <code>null</code>)</li> <li>
<code>extends</code>: <code>Array&lt;InterfaceExtends&gt;</code> (default: <code>null</code>)</li> <li>
<code>body</code>: <code>ObjectTypeAnnotation</code> (required)</li> <li>
<code>implements</code>: <code>Array&lt;ClassImplements&gt;</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>mixins</code>: <code>Array&lt;InterfaceExtends&gt;</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowdeclaration"><code>FlowDeclaration</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
interfaceExtends</h4> <pre data-language="javascript">t.interfaceExtends(id, typeParameters);
</pre> <p>See also <code>t.isInterfaceExtends(node, opts)</code> and <code>t.assertInterfaceExtends(node, opts)</code>.</p> <p>AST Node <code>InterfaceExtends</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier | QualifiedTypeIdentifier</code> (required)</li> <li>
<code>typeParameters</code>: <code>TypeParameterInstantiation</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a></p> <hr> <h4>
interfaceTypeAnnotation</h4> <pre data-language="javascript">t.interfaceTypeAnnotation(extends, body);
</pre> <p>See also <code>t.isInterfaceTypeAnnotation(node, opts)</code> and <code>t.assertInterfaceTypeAnnotation(node, opts)</code>.</p> <p>AST Node <code>InterfaceTypeAnnotation</code> shape:</p> <ul> <li>
<code>extends</code>: <code>Array&lt;InterfaceExtends&gt;</code> (default: <code>null</code>)</li> <li>
<code>body</code>: <code>ObjectTypeAnnotation</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a></p> <hr> <h4>
interpreterDirective</h4> <pre data-language="javascript">t.interpreterDirective(value);
</pre> <p>See also <code>t.isInterpreterDirective(node, opts)</code> and <code>t.assertInterpreterDirective(node, opts)</code>.</p> <p>AST Node <code>InterpreterDirective</code> shape:</p> <ul> <li>
<code>value</code>: <code>string</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a></p> <hr> <h4>
intersectionTypeAnnotation</h4> <pre data-language="javascript">t.intersectionTypeAnnotation(types);
</pre> <p>See also <code>t.isIntersectionTypeAnnotation(node, opts)</code> and <code>t.assertIntersectionTypeAnnotation(node, opts)</code>.</p> <p>AST Node <code>IntersectionTypeAnnotation</code> shape:</p> <ul> <li>
<code>types</code>: <code>Array&lt;FlowType&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a></p> <hr> <h4>
jsxAttribute</h4> <pre data-language="javascript">t.jsxAttribute(name, value);
</pre> <p>See also <code>t.isJSXAttribute(node, opts)</code> and <code>t.assertJSXAttribute(node, opts)</code>.</p> <p>AST Node <code>JSXAttribute</code> shape:</p> <ul> <li>
<code>name</code>: <code>JSXIdentifier | JSXNamespacedName</code> (required)</li> <li>
<code>value</code>: <code>JSXElement | JSXFragment | StringLiteral | JSXExpressionContainer</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#jsx"><code>JSX</code></a>, <a href="#immutable"><code>Immutable</code></a></p> <hr> <h4>
jsxClosingElement</h4> <pre data-language="javascript">t.jsxClosingElement(name);
</pre> <p>See also <code>t.isJSXClosingElement(node, opts)</code> and <code>t.assertJSXClosingElement(node, opts)</code>.</p> <p>AST Node <code>JSXClosingElement</code> shape:</p> <ul> <li>
<code>name</code>: <code>JSXIdentifier | JSXMemberExpression | JSXNamespacedName</code> (required)</li> </ul> <p>Aliases: <a href="#jsx"><code>JSX</code></a>, <a href="#immutable"><code>Immutable</code></a></p> <hr> <h4>
jsxClosingFragment</h4> <pre data-language="javascript">t.jsxClosingFragment();
</pre> <p>See also <code>t.isJSXClosingFragment(node, opts)</code> and <code>t.assertJSXClosingFragment(node, opts)</code>.</p> <p>Aliases: <a href="#jsx"><code>JSX</code></a>, <a href="#immutable"><code>Immutable</code></a></p> <hr> <h4>
jsxElement</h4> <pre data-language="javascript">t.jsxElement(openingElement, closingElement, children, selfClosing);
</pre> <p>See also <code>t.isJSXElement(node, opts)</code> and <code>t.assertJSXElement(node, opts)</code>.</p> <p>AST Node <code>JSXElement</code> shape:</p> <ul> <li>
<code>openingElement</code>: <code>JSXOpeningElement</code> (required)</li> <li>
<code>closingElement</code>: <code>JSXClosingElement</code> (default: <code>null</code>)</li> <li>
<code>children</code>: <code>Array&lt;JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment&gt;</code> (required)</li> <li>
<code>selfClosing</code>: <code>boolean</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#jsx"><code>JSX</code></a>, <a href="#immutable"><code>Immutable</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
jsxEmptyExpression</h4> <pre data-language="javascript">t.jsxEmptyExpression();
</pre> <p>See also <code>t.isJSXEmptyExpression(node, opts)</code> and <code>t.assertJSXEmptyExpression(node, opts)</code>.</p> <p>Aliases: <a href="#jsx"><code>JSX</code></a></p> <hr> <h4>
jsxExpressionContainer</h4> <pre data-language="javascript">t.jsxExpressionContainer(expression);
</pre> <p>See also <code>t.isJSXExpressionContainer(node, opts)</code> and <code>t.assertJSXExpressionContainer(node, opts)</code>.</p> <p>AST Node <code>JSXExpressionContainer</code> shape:</p> <ul> <li>
<code>expression</code>: <code>Expression | JSXEmptyExpression</code> (required)</li> </ul> <p>Aliases: <a href="#jsx"><code>JSX</code></a>, <a href="#immutable"><code>Immutable</code></a></p> <hr> <h4>
jsxFragment</h4> <pre data-language="javascript">t.jsxFragment(openingFragment, closingFragment, children);
</pre> <p>See also <code>t.isJSXFragment(node, opts)</code> and <code>t.assertJSXFragment(node, opts)</code>.</p> <p>AST Node <code>JSXFragment</code> shape:</p> <ul> <li>
<code>openingFragment</code>: <code>JSXOpeningFragment</code> (required)</li> <li>
<code>closingFragment</code>: <code>JSXClosingFragment</code> (required)</li> <li>
<code>children</code>: <code>Array&lt;JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#jsx"><code>JSX</code></a>, <a href="#immutable"><code>Immutable</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
jsxIdentifier</h4> <pre data-language="javascript">t.jsxIdentifier(name);
</pre> <p>See also <code>t.isJSXIdentifier(node, opts)</code> and <code>t.assertJSXIdentifier(node, opts)</code>.</p> <p>AST Node <code>JSXIdentifier</code> shape:</p> <ul> <li>
<code>name</code>: <code>string</code> (required)</li> </ul> <p>Aliases: <a href="#jsx"><code>JSX</code></a></p> <hr> <h4>
jsxMemberExpression</h4> <pre data-language="javascript">t.jsxMemberExpression(object, property);
</pre> <p>See also <code>t.isJSXMemberExpression(node, opts)</code> and <code>t.assertJSXMemberExpression(node, opts)</code>.</p> <p>AST Node <code>JSXMemberExpression</code> shape:</p> <ul> <li>
<code>object</code>: <code>JSXMemberExpression | JSXIdentifier</code> (required)</li> <li>
<code>property</code>: <code>JSXIdentifier</code> (required)</li> </ul> <p>Aliases: <a href="#jsx"><code>JSX</code></a></p> <hr> <h4>
jsxNamespacedName</h4> <pre data-language="javascript">t.jsxNamespacedName(namespace, name);
</pre> <p>See also <code>t.isJSXNamespacedName(node, opts)</code> and <code>t.assertJSXNamespacedName(node, opts)</code>.</p> <p>AST Node <code>JSXNamespacedName</code> shape:</p> <ul> <li>
<code>namespace</code>: <code>JSXIdentifier</code> (required)</li> <li>
<code>name</code>: <code>JSXIdentifier</code> (required)</li> </ul> <p>Aliases: <a href="#jsx"><code>JSX</code></a></p> <hr> <h4>
jsxOpeningElement</h4> <pre data-language="javascript">t.jsxOpeningElement(name, attributes, selfClosing);
</pre> <p>See also <code>t.isJSXOpeningElement(node, opts)</code> and <code>t.assertJSXOpeningElement(node, opts)</code>.</p> <p>AST Node <code>JSXOpeningElement</code> shape:</p> <ul> <li>
<code>name</code>: <code>JSXIdentifier | JSXMemberExpression | JSXNamespacedName</code> (required)</li> <li>
<code>attributes</code>: <code>Array&lt;JSXAttribute | JSXSpreadAttribute&gt;</code> (required)</li> <li>
<code>selfClosing</code>: <code>boolean</code> (default: <code>false</code>)</li> <li>
<code>typeParameters</code>: <code>TypeParameterInstantiation | TSTypeParameterInstantiation</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#jsx"><code>JSX</code></a>, <a href="#immutable"><code>Immutable</code></a></p> <hr> <h4>
jsxOpeningFragment</h4> <pre data-language="javascript">t.jsxOpeningFragment();
</pre> <p>See also <code>t.isJSXOpeningFragment(node, opts)</code> and <code>t.assertJSXOpeningFragment(node, opts)</code>.</p> <p>Aliases: <a href="#jsx"><code>JSX</code></a>, <a href="#immutable"><code>Immutable</code></a></p> <hr> <h4>
jsxSpreadAttribute</h4> <pre data-language="javascript">t.jsxSpreadAttribute(argument);
</pre> <p>See also <code>t.isJSXSpreadAttribute(node, opts)</code> and <code>t.assertJSXSpreadAttribute(node, opts)</code>.</p> <p>AST Node <code>JSXSpreadAttribute</code> shape:</p> <ul> <li>
<code>argument</code>: <code>Expression</code> (required)</li> </ul> <p>Aliases: <a href="#jsx"><code>JSX</code></a></p> <hr> <h4>
jsxSpreadChild</h4> <pre data-language="javascript">t.jsxSpreadChild(expression);
</pre> <p>See also <code>t.isJSXSpreadChild(node, opts)</code> and <code>t.assertJSXSpreadChild(node, opts)</code>.</p> <p>AST Node <code>JSXSpreadChild</code> shape:</p> <ul> <li>
<code>expression</code>: <code>Expression</code> (required)</li> </ul> <p>Aliases: <a href="#jsx"><code>JSX</code></a>, <a href="#immutable"><code>Immutable</code></a></p> <hr> <h4>
jsxText</h4> <pre data-language="javascript">t.jsxText(value);
</pre> <p>See also <code>t.isJSXText(node, opts)</code> and <code>t.assertJSXText(node, opts)</code>.</p> <p>AST Node <code>JSXText</code> shape:</p> <ul> <li>
<code>value</code>: <code>string</code> (required)</li> </ul> <p>Aliases: <a href="#jsx"><code>JSX</code></a>, <a href="#immutable"><code>Immutable</code></a></p> <hr> <h4>
labeledStatement</h4> <pre data-language="javascript">t.labeledStatement(label, body);
</pre> <p>See also <code>t.isLabeledStatement(node, opts)</code> and <code>t.assertLabeledStatement(node, opts)</code>.</p> <p>AST Node <code>LabeledStatement</code> shape:</p> <ul> <li>
<code>label</code>: <code>Identifier</code> (required)</li> <li>
<code>body</code>: <code>Statement</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#statement"><code>Statement</code></a></p> <hr> <h4>
logicalExpression</h4> <pre data-language="javascript">t.logicalExpression(operator, left, right);
</pre> <p>See also <code>t.isLogicalExpression(node, opts)</code> and <code>t.assertLogicalExpression(node, opts)</code>.</p> <p>AST Node <code>LogicalExpression</code> shape:</p> <ul> <li>
<code>operator</code>: <code>"||" | "&amp;&amp;" | "??"</code> (required)</li> <li>
<code>left</code>: <code>Expression</code> (required)</li> <li>
<code>right</code>: <code>Expression</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#binary"><code>Binary</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
memberExpression</h4> <pre data-language="javascript">t.memberExpression(object, property, computed, optional);
</pre> <p>See also <code>t.isMemberExpression(node, opts)</code> and <code>t.assertMemberExpression(node, opts)</code>.</p> <p>AST Node <code>MemberExpression</code> shape:</p> <ul> <li>
<code>object</code>: <code>Expression</code> (required)</li> <li>
<code>property</code>: if computed then <code>Expression</code> else <code>Identifier</code> (required)</li> <li>
<code>computed</code>: <code>boolean</code> (default: <code>false</code>)</li> <li>
<code>optional</code>: <code>true | false</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a>, <a href="#lval"><code>LVal</code></a></p> <hr> <h4>
metaProperty</h4> <pre data-language="javascript">t.metaProperty(meta, property);
</pre> <p>See also <code>t.isMetaProperty(node, opts)</code> and <code>t.assertMetaProperty(node, opts)</code>.</p> <p>AST Node <code>MetaProperty</code> shape:</p> <ul> <li>
<code>meta</code>: <code>Identifier</code> (required)</li> <li>
<code>property</code>: <code>Identifier</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
mixedTypeAnnotation</h4> <pre data-language="javascript">t.mixedTypeAnnotation();
</pre> <p>See also <code>t.isMixedTypeAnnotation(node, opts)</code> and <code>t.assertMixedTypeAnnotation(node, opts)</code>.</p> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a>, <a href="#flowbaseannotation"><code>FlowBaseAnnotation</code></a></p> <hr> <h4>
moduleExpression</h4> <pre data-language="javascript">t.moduleExpression(body);
</pre> <p>See also <code>t.isModuleExpression(node, opts)</code> and <code>t.assertModuleExpression(node, opts)</code>.</p> <p>AST Node <code>ModuleExpression</code> shape:</p> <ul> <li>
<code>body</code>: <code>Program</code> (required)</li> </ul> <p>Aliases: <a href="#proposal"><code>Proposal</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
newExpression</h4> <pre data-language="javascript">t.newExpression(callee, arguments);
</pre> <p>See also <code>t.isNewExpression(node, opts)</code> and <code>t.assertNewExpression(node, opts)</code>.</p> <p>AST Node <code>NewExpression</code> shape:</p> <ul> <li>
<code>callee</code>: <code>Expression | V8IntrinsicIdentifier</code> (required)</li> <li>
<code>arguments</code>: <code>Array&lt;Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder&gt;</code> (required)</li> <li>
<code>optional</code>: <code>true | false</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>typeArguments</code>: <code>TypeParameterInstantiation</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>typeParameters</code>: <code>TSTypeParameterInstantiation</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a></p> <hr> <h4>
noop</h4> <pre data-language="javascript">t.noop();
</pre> <p>See also <code>t.isNoop(node, opts)</code> and <code>t.assertNoop(node, opts)</code>.</p> <p>Aliases: <a href="#miscellaneous"><code>Miscellaneous</code></a></p> <hr> <h4>
nullLiteral</h4> <pre data-language="javascript">t.nullLiteral();
</pre> <p>See also <code>t.isNullLiteral(node, opts)</code> and <code>t.assertNullLiteral(node, opts)</code>.</p> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a>, <a href="#pureish"><code>Pureish</code></a>, <a href="#literal"><code>Literal</code></a>, <a href="#immutable"><code>Immutable</code></a></p> <hr> <h4>
nullLiteralTypeAnnotation</h4> <pre data-language="javascript">t.nullLiteralTypeAnnotation();
</pre> <p>See also <code>t.isNullLiteralTypeAnnotation(node, opts)</code> and <code>t.assertNullLiteralTypeAnnotation(node, opts)</code>.</p> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a>, <a href="#flowbaseannotation"><code>FlowBaseAnnotation</code></a></p> <hr> <h4>
nullableTypeAnnotation</h4> <pre data-language="javascript">t.nullableTypeAnnotation(typeAnnotation);
</pre> <p>See also <code>t.isNullableTypeAnnotation(node, opts)</code> and <code>t.assertNullableTypeAnnotation(node, opts)</code>.</p> <p>AST Node <code>NullableTypeAnnotation</code> shape:</p> <ul> <li>
<code>typeAnnotation</code>: <code>FlowType</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a></p> <hr> <h4>
numberLiteralTypeAnnotation</h4> <pre data-language="javascript">t.numberLiteralTypeAnnotation(value);
</pre> <p>See also <code>t.isNumberLiteralTypeAnnotation(node, opts)</code> and <code>t.assertNumberLiteralTypeAnnotation(node, opts)</code>.</p> <p>AST Node <code>NumberLiteralTypeAnnotation</code> shape:</p> <ul> <li>
<code>value</code>: <code>number</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a></p> <hr> <h4>
numberTypeAnnotation</h4> <pre data-language="javascript">t.numberTypeAnnotation();
</pre> <p>See also <code>t.isNumberTypeAnnotation(node, opts)</code> and <code>t.assertNumberTypeAnnotation(node, opts)</code>.</p> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a>, <a href="#flowbaseannotation"><code>FlowBaseAnnotation</code></a></p> <hr> <h4>
numericLiteral</h4> <pre data-language="javascript">t.numericLiteral(value);
</pre> <p>See also <code>t.isNumericLiteral(node, opts)</code> and <code>t.assertNumericLiteral(node, opts)</code>.</p> <p>AST Node <code>NumericLiteral</code> shape:</p> <ul> <li>
<code>value</code>: <code>number</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a>, <a href="#pureish"><code>Pureish</code></a>, <a href="#literal"><code>Literal</code></a>, <a href="#immutable"><code>Immutable</code></a></p> <hr> <h4>
objectExpression</h4> <pre data-language="javascript">t.objectExpression(properties);
</pre> <p>See also <code>t.isObjectExpression(node, opts)</code> and <code>t.assertObjectExpression(node, opts)</code>.</p> <p>AST Node <code>ObjectExpression</code> shape:</p> <ul> <li>
<code>properties</code>: <code>Array&lt;ObjectMethod | ObjectProperty | SpreadElement&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
objectMethod</h4> <pre data-language="javascript">t.objectMethod(kind, key, params, body, computed, generator, async);
</pre> <p>See also <code>t.isObjectMethod(node, opts)</code> and <code>t.assertObjectMethod(node, opts)</code>.</p> <p>AST Node <code>ObjectMethod</code> shape:</p> <ul> <li>
<code>kind</code>: <code>"method" | "get" | "set"</code> (default: <code>'method'</code>)</li> <li>
<code>key</code>: if computed then <code>Expression</code> else <code>Identifier | Literal</code> (required)</li> <li>
<code>params</code>: <code>Array&lt;Identifier | Pattern | RestElement&gt;</code> (required)</li> <li>
<code>body</code>: <code>BlockStatement</code> (required)</li> <li>
<code>computed</code>: <code>boolean</code> (default: <code>false</code>)</li> <li>
<code>generator</code>: <code>boolean</code> (default: <code>false</code>)</li> <li>
<code>async</code>: <code>boolean</code> (default: <code>false</code>)</li> <li>
<code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>returnType</code>: <code>TypeAnnotation | TSTypeAnnotation | Noop</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>typeParameters</code>: <code>TypeParameterDeclaration | TSTypeParameterDeclaration | Noop</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#userwhitespacable"><code>UserWhitespacable</code></a>, <a href="#function"><code>Function</code></a>, <a href="#scopable"><code>Scopable</code></a>, <a href="#blockparent"><code>BlockParent</code></a>, <a href="#functionparent"><code>FunctionParent</code></a>, <a href="#method"><code>Method</code></a>, <a href="#objectmember"><code>ObjectMember</code></a></p> <hr> <h4>
objectPattern</h4> <pre data-language="javascript">t.objectPattern(properties);
</pre> <p>See also <code>t.isObjectPattern(node, opts)</code> and <code>t.assertObjectPattern(node, opts)</code>.</p> <p>AST Node <code>ObjectPattern</code> shape:</p> <ul> <li>
<code>properties</code>: <code>Array&lt;RestElement | ObjectProperty&gt;</code> (required)</li> <li>
<code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>typeAnnotation</code>: <code>TypeAnnotation | TSTypeAnnotation | Noop</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#pattern"><code>Pattern</code></a>, <a href="#patternlike"><code>PatternLike</code></a>, <a href="#lval"><code>LVal</code></a></p> <hr> <h4>
objectProperty</h4> <pre data-language="javascript">t.objectProperty(key, value, computed, shorthand, decorators);
</pre> <p>See also <code>t.isObjectProperty(node, opts)</code> and <code>t.assertObjectProperty(node, opts)</code>.</p> <p>AST Node <code>ObjectProperty</code> shape:</p> <ul> <li>
<code>key</code>: if computed then <code>Expression</code> else <code>Identifier | Literal</code> (required)</li> <li>
<code>value</code>: <code>Expression | PatternLike</code> (required)</li> <li>
<code>computed</code>: <code>boolean</code> (default: <code>false</code>)</li> <li>
<code>shorthand</code>: <code>boolean</code> (default: <code>false</code>)</li> <li>
<code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#userwhitespacable"><code>UserWhitespacable</code></a>, <a href="#property"><code>Property</code></a>, <a href="#objectmember"><code>ObjectMember</code></a></p> <hr> <h4>
objectTypeAnnotation</h4> <pre data-language="javascript">t.objectTypeAnnotation(properties, indexers, callProperties, internalSlots, exact);
</pre> <p>See also <code>t.isObjectTypeAnnotation(node, opts)</code> and <code>t.assertObjectTypeAnnotation(node, opts)</code>.</p> <p>AST Node <code>ObjectTypeAnnotation</code> shape:</p> <ul> <li>
<code>properties</code>: <code>Array&lt;ObjectTypeProperty | ObjectTypeSpreadProperty&gt;</code> (required)</li> <li>
<code>indexers</code>: <code>Array&lt;ObjectTypeIndexer&gt;</code> (default: <code>null</code>)</li> <li>
<code>callProperties</code>: <code>Array&lt;ObjectTypeCallProperty&gt;</code> (default: <code>null</code>)</li> <li>
<code>internalSlots</code>: <code>Array&lt;ObjectTypeInternalSlot&gt;</code> (default: <code>null</code>)</li> <li>
<code>exact</code>: <code>boolean</code> (default: <code>false</code>)</li> <li>
<code>inexact</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a></p> <hr> <h4>
objectTypeCallProperty</h4> <pre data-language="javascript">t.objectTypeCallProperty(value);
</pre> <p>See also <code>t.isObjectTypeCallProperty(node, opts)</code> and <code>t.assertObjectTypeCallProperty(node, opts)</code>.</p> <p>AST Node <code>ObjectTypeCallProperty</code> shape:</p> <ul> <li>
<code>value</code>: <code>FlowType</code> (required)</li> <li>
<code>static</code>: <code>boolean</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#userwhitespacable"><code>UserWhitespacable</code></a></p> <hr> <h4>
objectTypeIndexer</h4> <pre data-language="javascript">t.objectTypeIndexer(id, key, value, variance);
</pre> <p>See also <code>t.isObjectTypeIndexer(node, opts)</code> and <code>t.assertObjectTypeIndexer(node, opts)</code>.</p> <p>AST Node <code>ObjectTypeIndexer</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (default: <code>null</code>)</li> <li>
<code>key</code>: <code>FlowType</code> (required)</li> <li>
<code>value</code>: <code>FlowType</code> (required)</li> <li>
<code>variance</code>: <code>Variance</code> (default: <code>null</code>)</li> <li>
<code>static</code>: <code>boolean</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#userwhitespacable"><code>UserWhitespacable</code></a></p> <hr> <h4>
objectTypeInternalSlot</h4> <pre data-language="javascript">t.objectTypeInternalSlot(id, value, optional, static, method);
</pre> <p>See also <code>t.isObjectTypeInternalSlot(node, opts)</code> and <code>t.assertObjectTypeInternalSlot(node, opts)</code>.</p> <p>AST Node <code>ObjectTypeInternalSlot</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> <li>
<code>value</code>: <code>FlowType</code> (required)</li> <li>
<code>optional</code>: <code>boolean</code> (required)</li> <li>
<code>static</code>: <code>boolean</code> (required)</li> <li>
<code>method</code>: <code>boolean</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#userwhitespacable"><code>UserWhitespacable</code></a></p> <hr> <h4>
objectTypeProperty</h4> <pre data-language="javascript">t.objectTypeProperty(key, value, variance);
</pre> <p>See also <code>t.isObjectTypeProperty(node, opts)</code> and <code>t.assertObjectTypeProperty(node, opts)</code>.</p> <p>AST Node <code>ObjectTypeProperty</code> shape:</p> <ul> <li>
<code>key</code>: <code>Identifier | StringLiteral</code> (required)</li> <li>
<code>value</code>: <code>FlowType</code> (required)</li> <li>
<code>variance</code>: <code>Variance</code> (default: <code>null</code>)</li> <li>
<code>kind</code>: <code>"init" | "get" | "set"</code> (required)</li> <li>
<code>method</code>: <code>boolean</code> (required)</li> <li>
<code>optional</code>: <code>boolean</code> (required)</li> <li>
<code>proto</code>: <code>boolean</code> (required)</li> <li>
<code>static</code>: <code>boolean</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#userwhitespacable"><code>UserWhitespacable</code></a></p> <hr> <h4>
objectTypeSpreadProperty</h4> <pre data-language="javascript">t.objectTypeSpreadProperty(argument);
</pre> <p>See also <code>t.isObjectTypeSpreadProperty(node, opts)</code> and <code>t.assertObjectTypeSpreadProperty(node, opts)</code>.</p> <p>AST Node <code>ObjectTypeSpreadProperty</code> shape:</p> <ul> <li>
<code>argument</code>: <code>FlowType</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#userwhitespacable"><code>UserWhitespacable</code></a></p> <hr> <h4>
opaqueType</h4> <pre data-language="javascript">t.opaqueType(id, typeParameters, supertype, impltype);
</pre> <p>See also <code>t.isOpaqueType(node, opts)</code> and <code>t.assertOpaqueType(node, opts)</code>.</p> <p>AST Node <code>OpaqueType</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> <li>
<code>typeParameters</code>: <code>TypeParameterDeclaration</code> (default: <code>null</code>)</li> <li>
<code>supertype</code>: <code>FlowType</code> (default: <code>null</code>)</li> <li>
<code>impltype</code>: <code>FlowType</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowdeclaration"><code>FlowDeclaration</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
optionalCallExpression</h4> <pre data-language="javascript">t.optionalCallExpression(callee, arguments, optional);
</pre> <p>See also <code>t.isOptionalCallExpression(node, opts)</code> and <code>t.assertOptionalCallExpression(node, opts)</code>.</p> <p>AST Node <code>OptionalCallExpression</code> shape:</p> <ul> <li>
<code>callee</code>: <code>Expression</code> (required)</li> <li>
<code>arguments</code>: <code>Array&lt;Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder&gt;</code> (required)</li> <li>
<code>optional</code>: <code>boolean</code> (required)</li> <li>
<code>typeArguments</code>: <code>TypeParameterInstantiation</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>typeParameters</code>: <code>TSTypeParameterInstantiation</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
optionalIndexedAccessType</h4> <pre data-language="javascript">t.optionalIndexedAccessType(objectType, indexType);
</pre> <p>See also <code>t.isOptionalIndexedAccessType(node, opts)</code> and <code>t.assertOptionalIndexedAccessType(node, opts)</code>.</p> <p>AST Node <code>OptionalIndexedAccessType</code> shape:</p> <ul> <li>
<code>objectType</code>: <code>FlowType</code> (required)</li> <li>
<code>indexType</code>: <code>FlowType</code> (required)</li> <li>
<code>optional</code>: <code>boolean</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a></p> <hr> <h4>
optionalIndexedAccessType</h4> <pre data-language="javascript">t.optionalIndexedAccessType(objectType, indexType);
</pre> <p>See also <code>t.isOptionalIndexedAccessType(node, opts)</code> and <code>t.assertOptionalIndexedAccessType(node, opts)</code>.</p> <p>AST Node <code>OptionalIndexedAccessType</code> shape:</p> <ul> <li>
<code>objectType</code>: <code>FlowType</code> (required)</li> <li>
<code>indexType</code>: <code>FlowType</code> (required)</li> <li>
<code>optional</code>: <code>boolean</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a></p> <hr> <h4>
optionalMemberExpression</h4> <pre data-language="javascript">t.optionalMemberExpression(object, property, computed, optional);
</pre> <p>See also <code>t.isOptionalMemberExpression(node, opts)</code> and <code>t.assertOptionalMemberExpression(node, opts)</code>.</p> <p>AST Node <code>OptionalMemberExpression</code> shape:</p> <ul> <li>
<code>object</code>: <code>Expression</code> (required)</li> <li>
<code>property</code>: <code>Expression | Identifier</code> (required)</li> <li>
<code>computed</code>: <code>boolean</code> (default: <code>false</code>)</li> <li>
<code>optional</code>: <code>boolean</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
parenthesizedExpression</h4> <pre data-language="javascript">t.parenthesizedExpression(expression);
</pre> <p>See also <code>t.isParenthesizedExpression(node, opts)</code> and <code>t.assertParenthesizedExpression(node, opts)</code>.</p> <p>AST Node <code>ParenthesizedExpression</code> shape:</p> <ul> <li>
<code>expression</code>: <code>Expression</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a>, <a href="#expressionwrapper"><code>ExpressionWrapper</code></a></p> <hr> <h4>
pipelineBareFunction</h4> <pre data-language="javascript">t.pipelineBareFunction(callee);
</pre> <p>See also <code>t.isPipelineBareFunction(node, opts)</code> and <code>t.assertPipelineBareFunction(node, opts)</code>.</p> <p>AST Node <code>PipelineBareFunction</code> shape:</p> <ul> <li>
<code>callee</code>: <code>Expression</code> (required)</li> </ul> <p>Aliases: <a href="#expression"><code>Expression</code></a>, <a href="#proposal"><code>Proposal</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a></p> <hr> <h4>
pipelinePrimaryTopicReference</h4> <pre data-language="javascript">t.pipelinePrimaryTopicReference();
</pre> <p>See also <code>t.isPipelinePrimaryTopicReference(node, opts)</code> and <code>t.assertPipelinePrimaryTopicReference(node, opts)</code>.</p> <p>Aliases: <a href="#proposal"><code>Proposal</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
pipelineTopicExpression</h4> <pre data-language="javascript">t.pipelineTopicExpression(expression);
</pre> <p>See also <code>t.isPipelineTopicExpression(node, opts)</code> and <code>t.assertPipelineTopicExpression(node, opts)</code>.</p> <p>AST Node <code>PipelineTopicExpression</code> shape:</p> <ul> <li>
<code>expression</code>: <code>Expression</code> (required)</li> </ul> <p>Aliases: <a href="#expression"><code>Expression</code></a>, <a href="#proposal"><code>Proposal</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a></p> <hr> <h4>
placeholder</h4> <pre data-language="javascript">t.placeholder(expectedNode, name);
</pre> <p>See also <code>t.isPlaceholder(node, opts)</code> and <code>t.assertPlaceholder(node, opts)</code>.</p> <p>AST Node <code>Placeholder</code> shape:</p> <ul> <li>
<code>expectedNode</code>: <code>"Identifier" | "StringLiteral" | "Expression" | "Statement" | "Declaration" | "BlockStatement" | "ClassBody" | "Pattern"</code> (required)</li> <li>
<code>name</code>: <code>Identifier</code> (required)</li> </ul> <p>Aliases: <a href="#miscellaneous"><code>Miscellaneous</code></a></p> <hr> <h4>
privateName</h4> <pre data-language="javascript">t.privateName(id);
</pre> <p>See also <code>t.isPrivateName(node, opts)</code> and <code>t.assertPrivateName(node, opts)</code>.</p> <p>AST Node <code>PrivateName</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#private"><code>Private</code></a></p> <hr> <h4>
program</h4> <pre data-language="javascript">t.program(body, directives, sourceType, interpreter);
</pre> <p>See also <code>t.isProgram(node, opts)</code> and <code>t.assertProgram(node, opts)</code>.</p> <p>AST Node <code>Program</code> shape:</p> <ul> <li>
<code>body</code>: <code>Array&lt;Statement&gt;</code> (required)</li> <li>
<code>directives</code>: <code>Array&lt;Directive&gt;</code> (default: <code>[]</code>)</li> <li>
<code>sourceType</code>: <code>"script" | "module"</code> (default: <code>'script'</code>)</li> <li>
<code>interpreter</code>: <code>InterpreterDirective</code> (default: <code>null</code>)</li> <li>
<code>sourceFile</code>: <code>string</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#scopable"><code>Scopable</code></a>, <a href="#blockparent"><code>BlockParent</code></a>, <a href="#block"><code>Block</code></a></p> <hr> <h4>
qualifiedTypeIdentifier</h4> <pre data-language="javascript">t.qualifiedTypeIdentifier(id, qualification);
</pre> <p>See also <code>t.isQualifiedTypeIdentifier(node, opts)</code> and <code>t.assertQualifiedTypeIdentifier(node, opts)</code>.</p> <p>AST Node <code>QualifiedTypeIdentifier</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> <li>
<code>qualification</code>: <code>Identifier | QualifiedTypeIdentifier</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a></p> <hr> <h4>
recordExpression</h4> <pre data-language="javascript">t.recordExpression(properties);
</pre> <p>See also <code>t.isRecordExpression(node, opts)</code> and <code>t.assertRecordExpression(node, opts)</code>.</p> <p>AST Node <code>RecordExpression</code> shape:</p> <ul> <li>
<code>properties</code>: <code>Array&lt;ObjectProperty | SpreadElement&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#proposal"><code>Proposal</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
regExpLiteral</h4> <pre data-language="javascript">t.regExpLiteral(pattern, flags);
</pre> <p>See also <code>t.isRegExpLiteral(node, opts)</code> and <code>t.assertRegExpLiteral(node, opts)</code>.</p> <p>AST Node <code>RegExpLiteral</code> shape:</p> <ul> <li>
<code>pattern</code>: <code>string</code> (required)</li> <li>
<code>flags</code>: <code>string</code> (default: <code>''</code>)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a>, <a href="#pureish"><code>Pureish</code></a>, <a href="#literal"><code>Literal</code></a></p> <hr> <h4>
restElement</h4> <pre data-language="javascript">t.restElement(argument);
</pre> <p>See also <code>t.isRestElement(node, opts)</code> and <code>t.assertRestElement(node, opts)</code>.</p> <p>AST Node <code>RestElement</code> shape:</p> <ul> <li>
<code>argument</code>: <code>LVal</code> (required)</li> <li>
<code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>optional</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>typeAnnotation</code>: <code>TypeAnnotation | TSTypeAnnotation | Noop</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#lval"><code>LVal</code></a>, <a href="#patternlike"><code>PatternLike</code></a></p> <hr> <h4>
returnStatement</h4> <pre data-language="javascript">t.returnStatement(argument);
</pre> <p>See also <code>t.isReturnStatement(node, opts)</code> and <code>t.assertReturnStatement(node, opts)</code>.</p> <p>AST Node <code>ReturnStatement</code> shape:</p> <ul> <li>
<code>argument</code>: <code>Expression</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#terminatorless"><code>Terminatorless</code></a>, <a href="#completionstatement"><code>CompletionStatement</code></a></p> <hr> <h4>
sequenceExpression</h4> <pre data-language="javascript">t.sequenceExpression(expressions);
</pre> <p>See also <code>t.isSequenceExpression(node, opts)</code> and <code>t.assertSequenceExpression(node, opts)</code>.</p> <p>AST Node <code>SequenceExpression</code> shape:</p> <ul> <li>
<code>expressions</code>: <code>Array&lt;Expression&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
spreadElement</h4> <pre data-language="javascript">t.spreadElement(argument);
</pre> <p>See also <code>t.isSpreadElement(node, opts)</code> and <code>t.assertSpreadElement(node, opts)</code>.</p> <p>AST Node <code>SpreadElement</code> shape:</p> <ul> <li>
<code>argument</code>: <code>Expression</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#unarylike"><code>UnaryLike</code></a></p> <hr> <h4>
staticBlock</h4> <pre data-language="javascript">t.staticBlock(body);
</pre> <p>See also <code>t.isStaticBlock(node, opts)</code> and <code>t.assertStaticBlock(node, opts)</code>.</p> <p>AST Node <code>StaticBlock</code> shape:</p> <ul> <li>
<code>body</code>: <code>Array&lt;Statement&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#proposal"><code>Proposal</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#scopable"><code>Scopable</code></a>, <a href="#blockparent"><code>BlockParent</code></a></p> <hr> <h4>
stringLiteral</h4> <pre data-language="javascript">t.stringLiteral(value);
</pre> <p>See also <code>t.isStringLiteral(node, opts)</code> and <code>t.assertStringLiteral(node, opts)</code>.</p> <p>AST Node <code>StringLiteral</code> shape:</p> <ul> <li>
<code>value</code>: <code>string</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a>, <a href="#pureish"><code>Pureish</code></a>, <a href="#literal"><code>Literal</code></a>, <a href="#immutable"><code>Immutable</code></a></p> <hr> <h4>
stringLiteralTypeAnnotation</h4> <pre data-language="javascript">t.stringLiteralTypeAnnotation(value);
</pre> <p>See also <code>t.isStringLiteralTypeAnnotation(node, opts)</code> and <code>t.assertStringLiteralTypeAnnotation(node, opts)</code>.</p> <p>AST Node <code>StringLiteralTypeAnnotation</code> shape:</p> <ul> <li>
<code>value</code>: <code>string</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a></p> <hr> <h4>
stringTypeAnnotation</h4> <pre data-language="javascript">t.stringTypeAnnotation();
</pre> <p>See also <code>t.isStringTypeAnnotation(node, opts)</code> and <code>t.assertStringTypeAnnotation(node, opts)</code>.</p> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a>, <a href="#flowbaseannotation"><code>FlowBaseAnnotation</code></a></p> <hr> <h4>
super</h4> <pre data-language="javascript">t.super();
</pre> <p>See also <code>t.isSuper(node, opts)</code> and <code>t.assertSuper(node, opts)</code>.</p> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
switchCase</h4> <pre data-language="javascript">t.switchCase(test, consequent);
</pre> <p>See also <code>t.isSwitchCase(node, opts)</code> and <code>t.assertSwitchCase(node, opts)</code>.</p> <p>AST Node <code>SwitchCase</code> shape:</p> <ul> <li>
<code>test</code>: <code>Expression</code> (default: <code>null</code>)</li> <li>
<code>consequent</code>: <code>Array&lt;Statement&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a></p> <hr> <h4>
switchStatement</h4> <pre data-language="javascript">t.switchStatement(discriminant, cases);
</pre> <p>See also <code>t.isSwitchStatement(node, opts)</code> and <code>t.assertSwitchStatement(node, opts)</code>.</p> <p>AST Node <code>SwitchStatement</code> shape:</p> <ul> <li>
<code>discriminant</code>: <code>Expression</code> (required)</li> <li>
<code>cases</code>: <code>Array&lt;SwitchCase&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#blockparent"><code>BlockParent</code></a>, <a href="#scopable"><code>Scopable</code></a></p> <hr> <h4>
symbolTypeAnnotation</h4> <pre data-language="javascript">t.symbolTypeAnnotation();
</pre> <p>See also <code>t.isSymbolTypeAnnotation(node, opts)</code> and <code>t.assertSymbolTypeAnnotation(node, opts)</code>.</p> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a>, <a href="#flowbaseannotation"><code>FlowBaseAnnotation</code></a></p> <hr> <h4>
tsAnyKeyword</h4> <pre data-language="javascript">t.tsAnyKeyword();
</pre> <p>See also <code>t.isTSAnyKeyword(node, opts)</code> and <code>t.assertTSAnyKeyword(node, opts)</code>.</p> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a>, <a href="#tsbasetype"><code>TSBaseType</code></a></p> <hr> <h4>
tsArrayType</h4> <pre data-language="javascript">t.tsArrayType(elementType);
</pre> <p>See also <code>t.isTSArrayType(node, opts)</code> and <code>t.assertTSArrayType(node, opts)</code>.</p> <p>AST Node <code>TSArrayType</code> shape:</p> <ul> <li>
<code>elementType</code>: <code>TSType</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a></p> <hr> <h4>
tsAsExpression</h4> <pre data-language="javascript">t.tsAsExpression(expression, typeAnnotation);
</pre> <p>See also <code>t.isTSAsExpression(node, opts)</code> and <code>t.assertTSAsExpression(node, opts)</code>.</p> <p>AST Node <code>TSAsExpression</code> shape:</p> <ul> <li>
<code>expression</code>: <code>Expression</code> (required)</li> <li>
<code>typeAnnotation</code>: <code>TSType</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
tsBigIntKeyword</h4> <pre data-language="javascript">t.tsBigIntKeyword();
</pre> <p>See also <code>t.isTSBigIntKeyword(node, opts)</code> and <code>t.assertTSBigIntKeyword(node, opts)</code>.</p> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a>, <a href="#tsbasetype"><code>TSBaseType</code></a></p> <hr> <h4>
tsBooleanKeyword</h4> <pre data-language="javascript">t.tsBooleanKeyword();
</pre> <p>See also <code>t.isTSBooleanKeyword(node, opts)</code> and <code>t.assertTSBooleanKeyword(node, opts)</code>.</p> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a>, <a href="#tsbasetype"><code>TSBaseType</code></a></p> <hr> <h4>
tsCallSignatureDeclaration</h4> <pre data-language="javascript">t.tsCallSignatureDeclaration(typeParameters, parameters, typeAnnotation);
</pre> <p>See also <code>t.isTSCallSignatureDeclaration(node, opts)</code> and <code>t.assertTSCallSignatureDeclaration(node, opts)</code>.</p> <p>AST Node <code>TSCallSignatureDeclaration</code> shape:</p> <ul> <li>
<code>typeParameters</code>: <code>TSTypeParameterDeclaration</code> (default: <code>null</code>)</li> <li>
<code>parameters</code>: <code>Array&lt;Identifier | RestElement&gt;</code> (required)</li> <li>
<code>typeAnnotation</code>: <code>TSTypeAnnotation</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstypeelement"><code>TSTypeElement</code></a></p> <hr> <h4>
tsConditionalType</h4> <pre data-language="javascript">t.tsConditionalType(checkType, extendsType, trueType, falseType);
</pre> <p>See also <code>t.isTSConditionalType(node, opts)</code> and <code>t.assertTSConditionalType(node, opts)</code>.</p> <p>AST Node <code>TSConditionalType</code> shape:</p> <ul> <li>
<code>checkType</code>: <code>TSType</code> (required)</li> <li>
<code>extendsType</code>: <code>TSType</code> (required)</li> <li>
<code>trueType</code>: <code>TSType</code> (required)</li> <li>
<code>falseType</code>: <code>TSType</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a></p> <hr> <h4>
tsConstructSignatureDeclaration</h4> <pre data-language="javascript">t.tsConstructSignatureDeclaration(typeParameters, parameters, typeAnnotation);
</pre> <p>See also <code>t.isTSConstructSignatureDeclaration(node, opts)</code> and <code>t.assertTSConstructSignatureDeclaration(node, opts)</code>.</p> <p>AST Node <code>TSConstructSignatureDeclaration</code> shape:</p> <ul> <li>
<code>typeParameters</code>: <code>TSTypeParameterDeclaration</code> (default: <code>null</code>)</li> <li>
<code>parameters</code>: <code>Array&lt;Identifier | RestElement&gt;</code> (required)</li> <li>
<code>typeAnnotation</code>: <code>TSTypeAnnotation</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstypeelement"><code>TSTypeElement</code></a></p> <hr> <h4>
tsConstructorType</h4> <pre data-language="javascript">t.tsConstructorType(typeParameters, parameters, typeAnnotation);
</pre> <p>See also <code>t.isTSConstructorType(node, opts)</code> and <code>t.assertTSConstructorType(node, opts)</code>.</p> <p>AST Node <code>TSConstructorType</code> shape:</p> <ul> <li>
<code>typeParameters</code>: <code>TSTypeParameterDeclaration</code> (default: <code>null</code>)</li> <li>
<code>parameters</code>: <code>Array&lt;Identifier | RestElement&gt;</code> (required)</li> <li>
<code>typeAnnotation</code>: <code>TSTypeAnnotation</code> (default: <code>null</code>)</li> <li>
<code>abstract</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a></p> <hr> <h4>
tsDeclareFunction</h4> <pre data-language="javascript">t.tsDeclareFunction(id, typeParameters, params, returnType);
</pre> <p>See also <code>t.isTSDeclareFunction(node, opts)</code> and <code>t.assertTSDeclareFunction(node, opts)</code>.</p> <p>AST Node <code>TSDeclareFunction</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (default: <code>null</code>)</li> <li>
<code>typeParameters</code>: <code>TSTypeParameterDeclaration | Noop</code> (default: <code>null</code>)</li> <li>
<code>params</code>: <code>Array&lt;Identifier | Pattern | RestElement&gt;</code> (required)</li> <li>
<code>returnType</code>: <code>TSTypeAnnotation | Noop</code> (default: <code>null</code>)</li> <li>
<code>async</code>: <code>boolean</code> (default: <code>false</code>, excluded from builder function)</li> <li>
<code>declare</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>generator</code>: <code>boolean</code> (default: <code>false</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
tsDeclareMethod</h4> <pre data-language="javascript">t.tsDeclareMethod(decorators, key, typeParameters, params, returnType);
</pre> <p>See also <code>t.isTSDeclareMethod(node, opts)</code> and <code>t.assertTSDeclareMethod(node, opts)</code>.</p> <p>AST Node <code>TSDeclareMethod</code> shape:</p> <ul> <li>
<code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>)</li> <li>
<code>key</code>: <code>Identifier | StringLiteral | NumericLiteral | Expression</code> (required)</li> <li>
<code>typeParameters</code>: <code>TSTypeParameterDeclaration | Noop</code> (default: <code>null</code>)</li> <li>
<code>params</code>: <code>Array&lt;Identifier | Pattern | RestElement | TSParameterProperty&gt;</code> (required)</li> <li>
<code>returnType</code>: <code>TSTypeAnnotation | Noop</code> (default: <code>null</code>)</li> <li>
<code>abstract</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>access</code>: <code>"public" | "private" | "protected"</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>accessibility</code>: <code>"public" | "private" | "protected"</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>async</code>: <code>boolean</code> (default: <code>false</code>, excluded from builder function)</li> <li>
<code>computed</code>: <code>boolean</code> (default: <code>false</code>, excluded from builder function)</li> <li>
<code>generator</code>: <code>boolean</code> (default: <code>false</code>, excluded from builder function)</li> <li>
<code>kind</code>: <code>"get" | "set" | "method" | "constructor"</code> (default: <code>'method'</code>, excluded from builder function)</li> <li>
<code>optional</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>override</code>: <code>boolean</code> (default: <code>false</code>, excluded from builder function)</li> <li>
<code>static</code>: <code>boolean</code> (default: <code>false</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a></p> <hr> <h4>
tsEnumDeclaration</h4> <pre data-language="javascript">t.tsEnumDeclaration(id, members);
</pre> <p>See also <code>t.isTSEnumDeclaration(node, opts)</code> and <code>t.assertTSEnumDeclaration(node, opts)</code>.</p> <p>AST Node <code>TSEnumDeclaration</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> <li>
<code>members</code>: <code>Array&lt;TSEnumMember&gt;</code> (required)</li> <li>
<code>const</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>declare</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>initializer</code>: <code>Expression</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
tsEnumMember</h4> <pre data-language="javascript">t.tsEnumMember(id, initializer);
</pre> <p>See also <code>t.isTSEnumMember(node, opts)</code> and <code>t.assertTSEnumMember(node, opts)</code>.</p> <p>AST Node <code>TSEnumMember</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier | StringLiteral</code> (required)</li> <li>
<code>initializer</code>: <code>Expression</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a></p> <hr> <h4>
tsExportAssignment</h4> <pre data-language="javascript">t.tsExportAssignment(expression);
</pre> <p>See also <code>t.isTSExportAssignment(node, opts)</code> and <code>t.assertTSExportAssignment(node, opts)</code>.</p> <p>AST Node <code>TSExportAssignment</code> shape:</p> <ul> <li>
<code>expression</code>: <code>Expression</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#statement"><code>Statement</code></a></p> <hr> <h4>
tsExpressionWithTypeArguments</h4> <pre data-language="javascript">t.tsExpressionWithTypeArguments(expression, typeParameters);
</pre> <p>See also <code>t.isTSExpressionWithTypeArguments(node, opts)</code> and <code>t.assertTSExpressionWithTypeArguments(node, opts)</code>.</p> <p>AST Node <code>TSExpressionWithTypeArguments</code> shape:</p> <ul> <li>
<code>expression</code>: <code>TSEntityName</code> (required)</li> <li>
<code>typeParameters</code>: <code>TSTypeParameterInstantiation</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a></p> <hr> <h4>
tsExternalModuleReference</h4> <pre data-language="javascript">t.tsExternalModuleReference(expression);
</pre> <p>See also <code>t.isTSExternalModuleReference(node, opts)</code> and <code>t.assertTSExternalModuleReference(node, opts)</code>.</p> <p>AST Node <code>TSExternalModuleReference</code> shape:</p> <ul> <li>
<code>expression</code>: <code>StringLiteral</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a></p> <hr> <h4>
tsFunctionType</h4> <pre data-language="javascript">t.tsFunctionType(typeParameters, parameters, typeAnnotation);
</pre> <p>See also <code>t.isTSFunctionType(node, opts)</code> and <code>t.assertTSFunctionType(node, opts)</code>.</p> <p>AST Node <code>TSFunctionType</code> shape:</p> <ul> <li>
<code>typeParameters</code>: <code>TSTypeParameterDeclaration</code> (default: <code>null</code>)</li> <li>
<code>parameters</code>: <code>Array&lt;Identifier | RestElement&gt;</code> (required)</li> <li>
<code>typeAnnotation</code>: <code>TSTypeAnnotation</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a></p> <hr> <h4>
tsImportEqualsDeclaration</h4> <pre data-language="javascript">t.tsImportEqualsDeclaration(id, moduleReference);
</pre> <p>See also <code>t.isTSImportEqualsDeclaration(node, opts)</code> and <code>t.assertTSImportEqualsDeclaration(node, opts)</code>.</p> <p>AST Node <code>TSImportEqualsDeclaration</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> <li>
<code>moduleReference</code>: <code>TSEntityName | TSExternalModuleReference</code> (required)</li> <li>
<code>importKind</code>: <code>"type" | "value"</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>isExport</code>: <code>boolean</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#statement"><code>Statement</code></a></p> <hr> <h4>
tsImportType</h4> <pre data-language="javascript">t.tsImportType(argument, qualifier, typeParameters);
</pre> <p>See also <code>t.isTSImportType(node, opts)</code> and <code>t.assertTSImportType(node, opts)</code>.</p> <p>AST Node <code>TSImportType</code> shape:</p> <ul> <li>
<code>argument</code>: <code>StringLiteral</code> (required)</li> <li>
<code>qualifier</code>: <code>TSEntityName</code> (default: <code>null</code>)</li> <li>
<code>typeParameters</code>: <code>TSTypeParameterInstantiation</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a></p> <hr> <h4>
tsIndexSignature</h4> <pre data-language="javascript">t.tsIndexSignature(parameters, typeAnnotation);
</pre> <p>See also <code>t.isTSIndexSignature(node, opts)</code> and <code>t.assertTSIndexSignature(node, opts)</code>.</p> <p>AST Node <code>TSIndexSignature</code> shape:</p> <ul> <li>
<code>parameters</code>: <code>Array&lt;Identifier&gt;</code> (required)</li> <li>
<code>typeAnnotation</code>: <code>TSTypeAnnotation</code> (default: <code>null</code>)</li> <li>
<code>readonly</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>static</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstypeelement"><code>TSTypeElement</code></a></p> <hr> <h4>
tsIndexedAccessType</h4> <pre data-language="javascript">t.tsIndexedAccessType(objectType, indexType);
</pre> <p>See also <code>t.isTSIndexedAccessType(node, opts)</code> and <code>t.assertTSIndexedAccessType(node, opts)</code>.</p> <p>AST Node <code>TSIndexedAccessType</code> shape:</p> <ul> <li>
<code>objectType</code>: <code>TSType</code> (required)</li> <li>
<code>indexType</code>: <code>TSType</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a></p> <hr> <h4>
tsInferType</h4> <pre data-language="javascript">t.tsInferType(typeParameter);
</pre> <p>See also <code>t.isTSInferType(node, opts)</code> and <code>t.assertTSInferType(node, opts)</code>.</p> <p>AST Node <code>TSInferType</code> shape:</p> <ul> <li>
<code>typeParameter</code>: <code>TSTypeParameter</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a></p> <hr> <h4>
tsInterfaceBody</h4> <pre data-language="javascript">t.tsInterfaceBody(body);
</pre> <p>See also <code>t.isTSInterfaceBody(node, opts)</code> and <code>t.assertTSInterfaceBody(node, opts)</code>.</p> <p>AST Node <code>TSInterfaceBody</code> shape:</p> <ul> <li>
<code>body</code>: <code>Array&lt;TSTypeElement&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a></p> <hr> <h4>
tsInterfaceDeclaration</h4> <pre data-language="javascript">t.tsInterfaceDeclaration(id, typeParameters, extends, body);
</pre> <p>See also <code>t.isTSInterfaceDeclaration(node, opts)</code> and <code>t.assertTSInterfaceDeclaration(node, opts)</code>.</p> <p>AST Node <code>TSInterfaceDeclaration</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> <li>
<code>typeParameters</code>: <code>TSTypeParameterDeclaration</code> (default: <code>null</code>)</li> <li>
<code>extends</code>: <code>Array&lt;TSExpressionWithTypeArguments&gt;</code> (default: <code>null</code>)</li> <li>
<code>body</code>: <code>TSInterfaceBody</code> (required)</li> <li>
<code>declare</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
tsIntersectionType</h4> <pre data-language="javascript">t.tsIntersectionType(types);
</pre> <p>See also <code>t.isTSIntersectionType(node, opts)</code> and <code>t.assertTSIntersectionType(node, opts)</code>.</p> <p>AST Node <code>TSIntersectionType</code> shape:</p> <ul> <li>
<code>types</code>: <code>Array&lt;TSType&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a></p> <hr> <h4>
tsIntrinsicKeyword</h4> <pre data-language="javascript">t.tsIntrinsicKeyword();
</pre> <p>See also <code>t.isTSIntrinsicKeyword(node, opts)</code> and <code>t.assertTSIntrinsicKeyword(node, opts)</code>.</p> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a>, <a href="#tsbasetype"><code>TSBaseType</code></a></p> <hr> <h4>
tsLiteralType</h4> <pre data-language="javascript">t.tsLiteralType(literal);
</pre> <p>See also <code>t.isTSLiteralType(node, opts)</code> and <code>t.assertTSLiteralType(node, opts)</code>.</p> <p>AST Node <code>TSLiteralType</code> shape:</p> <ul> <li>
<code>literal</code>: <code>NumericLiteral | StringLiteral | BooleanLiteral | BigIntLiteral | UnaryExpression</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a>, <a href="#tsbasetype"><code>TSBaseType</code></a></p> <hr> <h4>
tsMappedType</h4> <pre data-language="javascript">t.tsMappedType(typeParameter, typeAnnotation, nameType);
</pre> <p>See also <code>t.isTSMappedType(node, opts)</code> and <code>t.assertTSMappedType(node, opts)</code>.</p> <p>AST Node <code>TSMappedType</code> shape:</p> <ul> <li>
<code>typeParameter</code>: <code>TSTypeParameter</code> (required)</li> <li>
<code>typeAnnotation</code>: <code>TSType</code> (default: <code>null</code>)</li> <li>
<code>nameType</code>: <code>TSType</code> (default: <code>null</code>)</li> <li>
<code>optional</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>readonly</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a></p> <hr> <h4>
tsMethodSignature</h4> <pre data-language="javascript">t.tsMethodSignature(key, typeParameters, parameters, typeAnnotation);
</pre> <p>See also <code>t.isTSMethodSignature(node, opts)</code> and <code>t.assertTSMethodSignature(node, opts)</code>.</p> <p>AST Node <code>TSMethodSignature</code> shape:</p> <ul> <li>
<code>key</code>: <code>Expression</code> (required)</li> <li>
<code>typeParameters</code>: <code>TSTypeParameterDeclaration</code> (default: <code>null</code>)</li> <li>
<code>parameters</code>: <code>Array&lt;Identifier | RestElement&gt;</code> (required)</li> <li>
<code>typeAnnotation</code>: <code>TSTypeAnnotation</code> (default: <code>null</code>)</li> <li>
<code>computed</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>kind</code>: <code>"method" | "get" | "set"</code> (required)</li> <li>
<code>optional</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstypeelement"><code>TSTypeElement</code></a></p> <hr> <h4>
tsModuleBlock</h4> <pre data-language="javascript">t.tsModuleBlock(body);
</pre> <p>See also <code>t.isTSModuleBlock(node, opts)</code> and <code>t.assertTSModuleBlock(node, opts)</code>.</p> <p>AST Node <code>TSModuleBlock</code> shape:</p> <ul> <li>
<code>body</code>: <code>Array&lt;Statement&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#scopable"><code>Scopable</code></a>, <a href="#block"><code>Block</code></a>, <a href="#blockparent"><code>BlockParent</code></a></p> <hr> <h4>
tsModuleDeclaration</h4> <pre data-language="javascript">t.tsModuleDeclaration(id, body);
</pre> <p>See also <code>t.isTSModuleDeclaration(node, opts)</code> and <code>t.assertTSModuleDeclaration(node, opts)</code>.</p> <p>AST Node <code>TSModuleDeclaration</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier | StringLiteral</code> (required)</li> <li>
<code>body</code>: <code>TSModuleBlock | TSModuleDeclaration</code> (required)</li> <li>
<code>declare</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>global</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
tsNamedTupleMember</h4> <pre data-language="javascript">t.tsNamedTupleMember(label, elementType, optional);
</pre> <p>See also <code>t.isTSNamedTupleMember(node, opts)</code> and <code>t.assertTSNamedTupleMember(node, opts)</code>.</p> <p>AST Node <code>TSNamedTupleMember</code> shape:</p> <ul> <li>
<code>label</code>: <code>Identifier</code> (required)</li> <li>
<code>elementType</code>: <code>TSType</code> (required)</li> <li>
<code>optional</code>: <code>boolean</code> (default: <code>false</code>)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a></p> <hr> <h4>
tsNamespaceExportDeclaration</h4> <pre data-language="javascript">t.tsNamespaceExportDeclaration(id);
</pre> <p>See also <code>t.isTSNamespaceExportDeclaration(node, opts)</code> and <code>t.assertTSNamespaceExportDeclaration(node, opts)</code>.</p> <p>AST Node <code>TSNamespaceExportDeclaration</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#statement"><code>Statement</code></a></p> <hr> <h4>
tsNeverKeyword</h4> <pre data-language="javascript">t.tsNeverKeyword();
</pre> <p>See also <code>t.isTSNeverKeyword(node, opts)</code> and <code>t.assertTSNeverKeyword(node, opts)</code>.</p> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a>, <a href="#tsbasetype"><code>TSBaseType</code></a></p> <hr> <h4>
tsNonNullExpression</h4> <pre data-language="javascript">t.tsNonNullExpression(expression);
</pre> <p>See also <code>t.isTSNonNullExpression(node, opts)</code> and <code>t.assertTSNonNullExpression(node, opts)</code>.</p> <p>AST Node <code>TSNonNullExpression</code> shape:</p> <ul> <li>
<code>expression</code>: <code>Expression</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
tsNullKeyword</h4> <pre data-language="javascript">t.tsNullKeyword();
</pre> <p>See also <code>t.isTSNullKeyword(node, opts)</code> and <code>t.assertTSNullKeyword(node, opts)</code>.</p> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a>, <a href="#tsbasetype"><code>TSBaseType</code></a></p> <hr> <h4>
tsNumberKeyword</h4> <pre data-language="javascript">t.tsNumberKeyword();
</pre> <p>See also <code>t.isTSNumberKeyword(node, opts)</code> and <code>t.assertTSNumberKeyword(node, opts)</code>.</p> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a>, <a href="#tsbasetype"><code>TSBaseType</code></a></p> <hr> <h4>
tsObjectKeyword</h4> <pre data-language="javascript">t.tsObjectKeyword();
</pre> <p>See also <code>t.isTSObjectKeyword(node, opts)</code> and <code>t.assertTSObjectKeyword(node, opts)</code>.</p> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a>, <a href="#tsbasetype"><code>TSBaseType</code></a></p> <hr> <h4>
tsOptionalType</h4> <pre data-language="javascript">t.tsOptionalType(typeAnnotation);
</pre> <p>See also <code>t.isTSOptionalType(node, opts)</code> and <code>t.assertTSOptionalType(node, opts)</code>.</p> <p>AST Node <code>TSOptionalType</code> shape:</p> <ul> <li>
<code>typeAnnotation</code>: <code>TSType</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a></p> <hr> <h4>
tsParameterProperty</h4> <pre data-language="javascript">t.tsParameterProperty(parameter);
</pre> <p>See also <code>t.isTSParameterProperty(node, opts)</code> and <code>t.assertTSParameterProperty(node, opts)</code>.</p> <p>AST Node <code>TSParameterProperty</code> shape:</p> <ul> <li>
<code>parameter</code>: <code>Identifier | AssignmentPattern</code> (required)</li> <li>
<code>accessibility</code>: <code>"public" | "private" | "protected"</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>override</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>readonly</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#lval"><code>LVal</code></a></p> <hr> <h4>
tsParenthesizedType</h4> <pre data-language="javascript">t.tsParenthesizedType(typeAnnotation);
</pre> <p>See also <code>t.isTSParenthesizedType(node, opts)</code> and <code>t.assertTSParenthesizedType(node, opts)</code>.</p> <p>AST Node <code>TSParenthesizedType</code> shape:</p> <ul> <li>
<code>typeAnnotation</code>: <code>TSType</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a></p> <hr> <h4>
tsPropertySignature</h4> <pre data-language="javascript">t.tsPropertySignature(key, typeAnnotation, initializer);
</pre> <p>See also <code>t.isTSPropertySignature(node, opts)</code> and <code>t.assertTSPropertySignature(node, opts)</code>.</p> <p>AST Node <code>TSPropertySignature</code> shape:</p> <ul> <li>
<code>key</code>: <code>Expression</code> (required)</li> <li>
<code>typeAnnotation</code>: <code>TSTypeAnnotation</code> (default: <code>null</code>)</li> <li>
<code>initializer</code>: <code>Expression</code> (default: <code>null</code>)</li> <li>
<code>computed</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>kind</code>: <code>"get" | "set"</code> (required)</li> <li>
<code>optional</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> <li>
<code>readonly</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstypeelement"><code>TSTypeElement</code></a></p> <hr> <h4>
tsQualifiedName</h4> <pre data-language="javascript">t.tsQualifiedName(left, right);
</pre> <p>See also <code>t.isTSQualifiedName(node, opts)</code> and <code>t.assertTSQualifiedName(node, opts)</code>.</p> <p>AST Node <code>TSQualifiedName</code> shape:</p> <ul> <li>
<code>left</code>: <code>TSEntityName</code> (required)</li> <li>
<code>right</code>: <code>Identifier</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tsentityname"><code>TSEntityName</code></a></p> <hr> <h4>
tsRestType</h4> <pre data-language="javascript">t.tsRestType(typeAnnotation);
</pre> <p>See also <code>t.isTSRestType(node, opts)</code> and <code>t.assertTSRestType(node, opts)</code>.</p> <p>AST Node <code>TSRestType</code> shape:</p> <ul> <li>
<code>typeAnnotation</code>: <code>TSType</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a></p> <hr> <h4>
tsStringKeyword</h4> <pre data-language="javascript">t.tsStringKeyword();
</pre> <p>See also <code>t.isTSStringKeyword(node, opts)</code> and <code>t.assertTSStringKeyword(node, opts)</code>.</p> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a>, <a href="#tsbasetype"><code>TSBaseType</code></a></p> <hr> <h4>
tsSymbolKeyword</h4> <pre data-language="javascript">t.tsSymbolKeyword();
</pre> <p>See also <code>t.isTSSymbolKeyword(node, opts)</code> and <code>t.assertTSSymbolKeyword(node, opts)</code>.</p> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a>, <a href="#tsbasetype"><code>TSBaseType</code></a></p> <hr> <h4>
tsThisType</h4> <pre data-language="javascript">t.tsThisType();
</pre> <p>See also <code>t.isTSThisType(node, opts)</code> and <code>t.assertTSThisType(node, opts)</code>.</p> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a>, <a href="#tsbasetype"><code>TSBaseType</code></a></p> <hr> <h4>
tsTupleType</h4> <pre data-language="javascript">t.tsTupleType(elementTypes);
</pre> <p>See also <code>t.isTSTupleType(node, opts)</code> and <code>t.assertTSTupleType(node, opts)</code>.</p> <p>AST Node <code>TSTupleType</code> shape:</p> <ul> <li>
<code>elementTypes</code>: <code>Array&lt;TSType | TSNamedTupleMember&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a></p> <hr> <h4>
tsTypeAliasDeclaration</h4> <pre data-language="javascript">t.tsTypeAliasDeclaration(id, typeParameters, typeAnnotation);
</pre> <p>See also <code>t.isTSTypeAliasDeclaration(node, opts)</code> and <code>t.assertTSTypeAliasDeclaration(node, opts)</code>.</p> <p>AST Node <code>TSTypeAliasDeclaration</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> <li>
<code>typeParameters</code>: <code>TSTypeParameterDeclaration</code> (default: <code>null</code>)</li> <li>
<code>typeAnnotation</code>: <code>TSType</code> (required)</li> <li>
<code>declare</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
tsTypeAnnotation</h4> <pre data-language="javascript">t.tsTypeAnnotation(typeAnnotation);
</pre> <p>See also <code>t.isTSTypeAnnotation(node, opts)</code> and <code>t.assertTSTypeAnnotation(node, opts)</code>.</p> <p>AST Node <code>TSTypeAnnotation</code> shape:</p> <ul> <li>
<code>typeAnnotation</code>: <code>TSType</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a></p> <hr> <h4>
tsTypeAssertion</h4> <pre data-language="javascript">t.tsTypeAssertion(typeAnnotation, expression);
</pre> <p>See also <code>t.isTSTypeAssertion(node, opts)</code> and <code>t.assertTSTypeAssertion(node, opts)</code>.</p> <p>AST Node <code>TSTypeAssertion</code> shape:</p> <ul> <li>
<code>typeAnnotation</code>: <code>TSType</code> (required)</li> <li>
<code>expression</code>: <code>Expression</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
tsTypeLiteral</h4> <pre data-language="javascript">t.tsTypeLiteral(members);
</pre> <p>See also <code>t.isTSTypeLiteral(node, opts)</code> and <code>t.assertTSTypeLiteral(node, opts)</code>.</p> <p>AST Node <code>TSTypeLiteral</code> shape:</p> <ul> <li>
<code>members</code>: <code>Array&lt;TSTypeElement&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a></p> <hr> <h4>
tsTypeOperator</h4> <pre data-language="javascript">t.tsTypeOperator(typeAnnotation);
</pre> <p>See also <code>t.isTSTypeOperator(node, opts)</code> and <code>t.assertTSTypeOperator(node, opts)</code>.</p> <p>AST Node <code>TSTypeOperator</code> shape:</p> <ul> <li>
<code>typeAnnotation</code>: <code>TSType</code> (required)</li> <li>
<code>operator</code>: <code>string</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a></p> <hr> <h4>
tsTypeParameter</h4> <pre data-language="javascript">t.tsTypeParameter(constraint, default, name);
</pre> <p>See also <code>t.isTSTypeParameter(node, opts)</code> and <code>t.assertTSTypeParameter(node, opts)</code>.</p> <p>AST Node <code>TSTypeParameter</code> shape:</p> <ul> <li>
<code>constraint</code>: <code>TSType</code> (default: <code>null</code>)</li> <li>
<code>default</code>: <code>TSType</code> (default: <code>null</code>)</li> <li>
<code>name</code>: <code>string</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a></p> <hr> <h4>
tsTypeParameterDeclaration</h4> <pre data-language="javascript">t.tsTypeParameterDeclaration(params);
</pre> <p>See also <code>t.isTSTypeParameterDeclaration(node, opts)</code> and <code>t.assertTSTypeParameterDeclaration(node, opts)</code>.</p> <p>AST Node <code>TSTypeParameterDeclaration</code> shape:</p> <ul> <li>
<code>params</code>: <code>Array&lt;TSTypeParameter&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a></p> <hr> <h4>
tsTypeParameterInstantiation</h4> <pre data-language="javascript">t.tsTypeParameterInstantiation(params);
</pre> <p>See also <code>t.isTSTypeParameterInstantiation(node, opts)</code> and <code>t.assertTSTypeParameterInstantiation(node, opts)</code>.</p> <p>AST Node <code>TSTypeParameterInstantiation</code> shape:</p> <ul> <li>
<code>params</code>: <code>Array&lt;TSType&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a></p> <hr> <h4>
tsTypePredicate</h4> <pre data-language="javascript">t.tsTypePredicate(parameterName, typeAnnotation, asserts);
</pre> <p>See also <code>t.isTSTypePredicate(node, opts)</code> and <code>t.assertTSTypePredicate(node, opts)</code>.</p> <p>AST Node <code>TSTypePredicate</code> shape:</p> <ul> <li>
<code>parameterName</code>: <code>Identifier | TSThisType</code> (required)</li> <li>
<code>typeAnnotation</code>: <code>TSTypeAnnotation</code> (default: <code>null</code>)</li> <li>
<code>asserts</code>: <code>boolean</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a></p> <hr> <h4>
tsTypeQuery</h4> <pre data-language="javascript">t.tsTypeQuery(exprName);
</pre> <p>See also <code>t.isTSTypeQuery(node, opts)</code> and <code>t.assertTSTypeQuery(node, opts)</code>.</p> <p>AST Node <code>TSTypeQuery</code> shape:</p> <ul> <li>
<code>exprName</code>: <code>TSEntityName | TSImportType</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a></p> <hr> <h4>
tsTypeReference</h4> <pre data-language="javascript">t.tsTypeReference(typeName, typeParameters);
</pre> <p>See also <code>t.isTSTypeReference(node, opts)</code> and <code>t.assertTSTypeReference(node, opts)</code>.</p> <p>AST Node <code>TSTypeReference</code> shape:</p> <ul> <li>
<code>typeName</code>: <code>TSEntityName</code> (required)</li> <li>
<code>typeParameters</code>: <code>TSTypeParameterInstantiation</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a></p> <hr> <h4>
tsUndefinedKeyword</h4> <pre data-language="javascript">t.tsUndefinedKeyword();
</pre> <p>See also <code>t.isTSUndefinedKeyword(node, opts)</code> and <code>t.assertTSUndefinedKeyword(node, opts)</code>.</p> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a>, <a href="#tsbasetype"><code>TSBaseType</code></a></p> <hr> <h4>
tsUnionType</h4> <pre data-language="javascript">t.tsUnionType(types);
</pre> <p>See also <code>t.isTSUnionType(node, opts)</code> and <code>t.assertTSUnionType(node, opts)</code>.</p> <p>AST Node <code>TSUnionType</code> shape:</p> <ul> <li>
<code>types</code>: <code>Array&lt;TSType&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a></p> <hr> <h4>
tsUnknownKeyword</h4> <pre data-language="javascript">t.tsUnknownKeyword();
</pre> <p>See also <code>t.isTSUnknownKeyword(node, opts)</code> and <code>t.assertTSUnknownKeyword(node, opts)</code>.</p> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a>, <a href="#tsbasetype"><code>TSBaseType</code></a></p> <hr> <h4>
tsVoidKeyword</h4> <pre data-language="javascript">t.tsVoidKeyword();
</pre> <p>See also <code>t.isTSVoidKeyword(node, opts)</code> and <code>t.assertTSVoidKeyword(node, opts)</code>.</p> <p>Aliases: <a href="#typescript"><code>TypeScript</code></a>, <a href="#tstype"><code>TSType</code></a>, <a href="#tsbasetype"><code>TSBaseType</code></a></p> <hr> <h4>
taggedTemplateExpression</h4> <pre data-language="javascript">t.taggedTemplateExpression(tag, quasi);
</pre> <p>See also <code>t.isTaggedTemplateExpression(node, opts)</code> and <code>t.assertTaggedTemplateExpression(node, opts)</code>.</p> <p>AST Node <code>TaggedTemplateExpression</code> shape:</p> <ul> <li>
<code>tag</code>: <code>Expression</code> (required)</li> <li>
<code>quasi</code>: <code>TemplateLiteral</code> (required)</li> <li>
<code>typeParameters</code>: <code>TypeParameterInstantiation | TSTypeParameterInstantiation</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
templateElement</h4> <pre data-language="javascript">t.templateElement(value, tail);
</pre> <p>See also <code>t.isTemplateElement(node, opts)</code> and <code>t.assertTemplateElement(node, opts)</code>.</p> <p>AST Node <code>TemplateElement</code> shape:</p> <ul> <li>
<code>value</code>: <code>{ raw: string, cooked?: string }</code> (required)</li> <li>
<code>tail</code>: <code>boolean</code> (default: <code>false</code>)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a></p> <hr> <h4>
templateLiteral</h4> <pre data-language="javascript">t.templateLiteral(quasis, expressions);
</pre> <p>See also <code>t.isTemplateLiteral(node, opts)</code> and <code>t.assertTemplateLiteral(node, opts)</code>.</p> <p>AST Node <code>TemplateLiteral</code> shape:</p> <ul> <li>
<code>quasis</code>: <code>Array&lt;TemplateElement&gt;</code> (required)</li> <li>
<code>expressions</code>: <code>Array&lt;Expression | TSType&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a>, <a href="#literal"><code>Literal</code></a></p> <hr> <h4>
thisExpression</h4> <pre data-language="javascript">t.thisExpression();
</pre> <p>See also <code>t.isThisExpression(node, opts)</code> and <code>t.assertThisExpression(node, opts)</code>.</p> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
thisTypeAnnotation</h4> <pre data-language="javascript">t.thisTypeAnnotation();
</pre> <p>See also <code>t.isThisTypeAnnotation(node, opts)</code> and <code>t.assertThisTypeAnnotation(node, opts)</code>.</p> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a>, <a href="#flowbaseannotation"><code>FlowBaseAnnotation</code></a></p> <hr> <h4>
throwStatement</h4> <pre data-language="javascript">t.throwStatement(argument);
</pre> <p>See also <code>t.isThrowStatement(node, opts)</code> and <code>t.assertThrowStatement(node, opts)</code>.</p> <p>AST Node <code>ThrowStatement</code> shape:</p> <ul> <li>
<code>argument</code>: <code>Expression</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#terminatorless"><code>Terminatorless</code></a>, <a href="#completionstatement"><code>CompletionStatement</code></a></p> <hr> <h4>
topicReference</h4> <pre data-language="javascript">t.topicReference();
</pre> <p>See also <code>t.isTopicReference(node, opts)</code> and <code>t.assertTopicReference(node, opts)</code>.</p> <p>Aliases: <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
tryStatement</h4> <pre data-language="javascript">t.tryStatement(block, handler, finalizer);
</pre> <p>See also <code>t.isTryStatement(node, opts)</code> and <code>t.assertTryStatement(node, opts)</code>.</p> <p>AST Node <code>TryStatement</code> shape:</p> <ul> <li>
<code>block</code>: <code>BlockStatement</code> (required)</li> <li>
<code>handler</code>: <code>CatchClause</code> (default: <code>null</code>)</li> <li>
<code>finalizer</code>: <code>BlockStatement</code> (default: <code>null</code>)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#statement"><code>Statement</code></a></p> <hr> <h4>
tupleExpression</h4> <pre data-language="javascript">t.tupleExpression(elements);
</pre> <p>See also <code>t.isTupleExpression(node, opts)</code> and <code>t.assertTupleExpression(node, opts)</code>.</p> <p>AST Node <code>TupleExpression</code> shape:</p> <ul> <li>
<code>elements</code>: <code>Array&lt;Expression | SpreadElement&gt;</code> (default: <code>[]</code>)</li> </ul> <p>Aliases: <a href="#proposal"><code>Proposal</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
tupleTypeAnnotation</h4> <pre data-language="javascript">t.tupleTypeAnnotation(types);
</pre> <p>See also <code>t.isTupleTypeAnnotation(node, opts)</code> and <code>t.assertTupleTypeAnnotation(node, opts)</code>.</p> <p>AST Node <code>TupleTypeAnnotation</code> shape:</p> <ul> <li>
<code>types</code>: <code>Array&lt;FlowType&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a></p> <hr> <h4>
typeAlias</h4> <pre data-language="javascript">t.typeAlias(id, typeParameters, right);
</pre> <p>See also <code>t.isTypeAlias(node, opts)</code> and <code>t.assertTypeAlias(node, opts)</code>.</p> <p>AST Node <code>TypeAlias</code> shape:</p> <ul> <li>
<code>id</code>: <code>Identifier</code> (required)</li> <li>
<code>typeParameters</code>: <code>TypeParameterDeclaration</code> (default: <code>null</code>)</li> <li>
<code>right</code>: <code>FlowType</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowdeclaration"><code>FlowDeclaration</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
typeAnnotation</h4> <pre data-language="javascript">t.typeAnnotation(typeAnnotation);
</pre> <p>See also <code>t.isTypeAnnotation(node, opts)</code> and <code>t.assertTypeAnnotation(node, opts)</code>.</p> <p>AST Node <code>TypeAnnotation</code> shape:</p> <ul> <li>
<code>typeAnnotation</code>: <code>FlowType</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a></p> <hr> <h4>
typeCastExpression</h4> <pre data-language="javascript">t.typeCastExpression(expression, typeAnnotation);
</pre> <p>See also <code>t.isTypeCastExpression(node, opts)</code> and <code>t.assertTypeCastExpression(node, opts)</code>.</p> <p>AST Node <code>TypeCastExpression</code> shape:</p> <ul> <li>
<code>expression</code>: <code>Expression</code> (required)</li> <li>
<code>typeAnnotation</code>: <code>TypeAnnotation</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#expressionwrapper"><code>ExpressionWrapper</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
typeParameter</h4> <pre data-language="javascript">t.typeParameter(bound, default, variance);
</pre> <p>See also <code>t.isTypeParameter(node, opts)</code> and <code>t.assertTypeParameter(node, opts)</code>.</p> <p>AST Node <code>TypeParameter</code> shape:</p> <ul> <li>
<code>bound</code>: <code>TypeAnnotation</code> (default: <code>null</code>)</li> <li>
<code>default</code>: <code>FlowType</code> (default: <code>null</code>)</li> <li>
<code>variance</code>: <code>Variance</code> (default: <code>null</code>)</li> <li>
<code>name</code>: <code>string</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a></p> <hr> <h4>
typeParameterDeclaration</h4> <pre data-language="javascript">t.typeParameterDeclaration(params);
</pre> <p>See also <code>t.isTypeParameterDeclaration(node, opts)</code> and <code>t.assertTypeParameterDeclaration(node, opts)</code>.</p> <p>AST Node <code>TypeParameterDeclaration</code> shape:</p> <ul> <li>
<code>params</code>: <code>Array&lt;TypeParameter&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a></p> <hr> <h4>
typeParameterInstantiation</h4> <pre data-language="javascript">t.typeParameterInstantiation(params);
</pre> <p>See also <code>t.isTypeParameterInstantiation(node, opts)</code> and <code>t.assertTypeParameterInstantiation(node, opts)</code>.</p> <p>AST Node <code>TypeParameterInstantiation</code> shape:</p> <ul> <li>
<code>params</code>: <code>Array&lt;FlowType&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a></p> <hr> <h4>
typeofTypeAnnotation</h4> <pre data-language="javascript">t.typeofTypeAnnotation(argument);
</pre> <p>See also <code>t.isTypeofTypeAnnotation(node, opts)</code> and <code>t.assertTypeofTypeAnnotation(node, opts)</code>.</p> <p>AST Node <code>TypeofTypeAnnotation</code> shape:</p> <ul> <li>
<code>argument</code>: <code>FlowType</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a></p> <hr> <h4>
unaryExpression</h4> <pre data-language="javascript">t.unaryExpression(operator, argument, prefix);
</pre> <p>See also <code>t.isUnaryExpression(node, opts)</code> and <code>t.assertUnaryExpression(node, opts)</code>.</p> <p>AST Node <code>UnaryExpression</code> shape:</p> <ul> <li>
<code>operator</code>: <code>"void" | "throw" | "delete" | "!" | "+" | "-" | "~" | "typeof"</code> (required)</li> <li>
<code>argument</code>: <code>Expression</code> (required)</li> <li>
<code>prefix</code>: <code>boolean</code> (default: <code>true</code>)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#unarylike"><code>UnaryLike</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
unionTypeAnnotation</h4> <pre data-language="javascript">t.unionTypeAnnotation(types);
</pre> <p>See also <code>t.isUnionTypeAnnotation(node, opts)</code> and <code>t.assertUnionTypeAnnotation(node, opts)</code>.</p> <p>AST Node <code>UnionTypeAnnotation</code> shape:</p> <ul> <li>
<code>types</code>: <code>Array&lt;FlowType&gt;</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a></p> <hr> <h4>
updateExpression</h4> <pre data-language="javascript">t.updateExpression(operator, argument, prefix);
</pre> <p>See also <code>t.isUpdateExpression(node, opts)</code> and <code>t.assertUpdateExpression(node, opts)</code>.</p> <p>AST Node <code>UpdateExpression</code> shape:</p> <ul> <li>
<code>operator</code>: <code>"++" | "--"</code> (required)</li> <li>
<code>argument</code>: <code>Expression</code> (required)</li> <li>
<code>prefix</code>: <code>boolean</code> (default: <code>false</code>)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a></p> <hr> <h4>
v8IntrinsicIdentifier</h4> <pre data-language="javascript">t.v8IntrinsicIdentifier(name);
</pre> <p>See also <code>t.isV8IntrinsicIdentifier(node, opts)</code> and <code>t.assertV8IntrinsicIdentifier(node, opts)</code>.</p> <p>AST Node <code>V8IntrinsicIdentifier</code> shape:</p> <ul> <li>
<code>name</code>: <code>string</code> (required)</li> </ul> <p>Aliases: <a href="#miscellaneous"><code>Miscellaneous</code></a></p> <hr> <h4>
variableDeclaration</h4> <pre data-language="javascript">t.variableDeclaration(kind, declarations);
</pre> <p>See also <code>t.isVariableDeclaration(node, opts)</code> and <code>t.assertVariableDeclaration(node, opts)</code>.</p> <p>AST Node <code>VariableDeclaration</code> shape:</p> <ul> <li>
<code>kind</code>: <code>"var" | "let" | "const"</code> (required)</li> <li>
<code>declarations</code>: <code>Array&lt;VariableDeclarator&gt;</code> (required)</li> <li>
<code>declare</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#declaration"><code>Declaration</code></a></p> <hr> <h4>
variableDeclarator</h4> <pre data-language="javascript">t.variableDeclarator(id, init);
</pre> <p>See also <code>t.isVariableDeclarator(node, opts)</code> and <code>t.assertVariableDeclarator(node, opts)</code>.</p> <p>AST Node <code>VariableDeclarator</code> shape:</p> <ul> <li>
<code>id</code>: <code>LVal</code> (required)</li> <li>
<code>init</code>: <code>Expression</code> (default: <code>null</code>)</li> <li>
<code>definite</code>: <code>boolean</code> (default: <code>null</code>, excluded from builder function)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a></p> <hr> <h4>
variance</h4> <pre data-language="javascript">t.variance(kind);
</pre> <p>See also <code>t.isVariance(node, opts)</code> and <code>t.assertVariance(node, opts)</code>.</p> <p>AST Node <code>Variance</code> shape:</p> <ul> <li>
<code>kind</code>: <code>"minus" | "plus"</code> (required)</li> </ul> <p>Aliases: <a href="#flow"><code>Flow</code></a></p> <hr> <h4>
voidTypeAnnotation</h4> <pre data-language="javascript">t.voidTypeAnnotation();
</pre> <p>See also <code>t.isVoidTypeAnnotation(node, opts)</code> and <code>t.assertVoidTypeAnnotation(node, opts)</code>.</p> <p>Aliases: <a href="#flow"><code>Flow</code></a>, <a href="#flowtype"><code>FlowType</code></a>, <a href="#flowbaseannotation"><code>FlowBaseAnnotation</code></a></p> <hr> <h4>
whileStatement</h4> <pre data-language="javascript">t.whileStatement(test, body);
</pre> <p>See also <code>t.isWhileStatement(node, opts)</code> and <code>t.assertWhileStatement(node, opts)</code>.</p> <p>AST Node <code>WhileStatement</code> shape:</p> <ul> <li>
<code>test</code>: <code>Expression</code> (required)</li> <li>
<code>body</code>: <code>Statement</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#statement"><code>Statement</code></a>, <a href="#blockparent"><code>BlockParent</code></a>, <a href="#loop"><code>Loop</code></a>, <a href="#while"><code>While</code></a>, <a href="#scopable"><code>Scopable</code></a></p> <hr> <h4>
withStatement</h4> <pre data-language="javascript">t.withStatement(object, body);
</pre> <p>See also <code>t.isWithStatement(node, opts)</code> and <code>t.assertWithStatement(node, opts)</code>.</p> <p>AST Node <code>WithStatement</code> shape:</p> <ul> <li>
<code>object</code>: <code>Expression</code> (required)</li> <li>
<code>body</code>: <code>Statement</code> (required)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#statement"><code>Statement</code></a></p> <hr> <h4>
yieldExpression</h4> <pre data-language="javascript">t.yieldExpression(argument, delegate);
</pre> <p>See also <code>t.isYieldExpression(node, opts)</code> and <code>t.assertYieldExpression(node, opts)</code>.</p> <p>AST Node <code>YieldExpression</code> shape:</p> <ul> <li>
<code>argument</code>: <code>Expression</code> (default: <code>null</code>)</li> <li>
<code>delegate</code>: <code>boolean</code> (default: <code>false</code>)</li> </ul> <p>Aliases: <a href="#standardized"><code>Standardized</code></a>, <a href="#standardizedorproposal"><code>StandardizedOrProposal</code></a>, <a href="#expression"><code>Expression</code></a>, <a href="#terminatorless"><code>Terminatorless</code></a></p> <hr> <h3>
Aliases</h3> <h4>
Binary</h4> <p>A cover of BinaryExpression and LogicalExpression, which share the same AST shape.</p> <pre data-language="javascript">t.isBinary(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#binaryexpression"><code>BinaryExpression</code></a></li> <li><a href="#logicalexpression"><code>LogicalExpression</code></a></li> </ul> <h4>
Block</h4> <p>Deprecated. Will be removed in Babel 8.</p> <pre data-language="javascript">t.isBlock(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#blockstatement"><code>BlockStatement</code></a></li> <li><a href="#program"><code>Program</code></a></li> <li><a href="#tsmoduleblock"><code>TSModuleBlock</code></a></li> </ul> <h4>
BlockParent</h4> <p>A cover of AST nodes that start an execution context with new <a href="https://tc39.es/ecma262/#table-additional-state-components-for-ecmascript-code-execution-contexts">LexicalEnvironment</a>. In other words, they define the scope of <code>let</code> and <code>const</code> declarations.</p> <pre data-language="javascript">t.isBlockParent(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#arrowfunctionexpression"><code>ArrowFunctionExpression</code></a></li> <li><a href="#blockstatement"><code>BlockStatement</code></a></li> <li><a href="#catchclause"><code>CatchClause</code></a></li> <li><a href="#classmethod"><code>ClassMethod</code></a></li> <li><a href="#classprivatemethod"><code>ClassPrivateMethod</code></a></li> <li><a href="#dowhilestatement"><code>DoWhileStatement</code></a></li> <li><a href="#forinstatement"><code>ForInStatement</code></a></li> <li><a href="#forofstatement"><code>ForOfStatement</code></a></li> <li><a href="#forstatement"><code>ForStatement</code></a></li> <li><a href="#functiondeclaration"><code>FunctionDeclaration</code></a></li> <li><a href="#functionexpression"><code>FunctionExpression</code></a></li> <li><a href="#objectmethod"><code>ObjectMethod</code></a></li> <li><a href="#program"><code>Program</code></a></li> <li><a href="#staticblock"><code>StaticBlock</code></a></li> <li><a href="#switchstatement"><code>SwitchStatement</code></a></li> <li><a href="#tsmoduleblock"><code>TSModuleBlock</code></a></li> <li><a href="#whilestatement"><code>WhileStatement</code></a></li> </ul> <h4>
Class</h4> <p>A cover of ClassExpression and ClassDeclaration, which share the same AST shape.</p> <pre data-language="javascript">t.isClass(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#classdeclaration"><code>ClassDeclaration</code></a></li> <li><a href="#classexpression"><code>ClassExpression</code></a></li> </ul> <h4>
CompletionStatement</h4> <p>A statement that indicates the <a href="https://tc39.es/ecma262/#sec-completion-record-specification-type">completion records</a>. In other words, they define the control flow of the program, such as when should a loop break or an action throws critical errors.</p> <pre data-language="javascript">t.isCompletionStatement(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#breakstatement"><code>BreakStatement</code></a></li> <li><a href="#continuestatement"><code>ContinueStatement</code></a></li> <li><a href="#returnstatement"><code>ReturnStatement</code></a></li> <li><a href="#throwstatement"><code>ThrowStatement</code></a></li> </ul> <h4>
Conditional</h4> <p>A cover of ConditionalExpression and IfStatement, which share the same AST shape.</p> <pre data-language="javascript">t.isConditional(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#conditionalexpression"><code>ConditionalExpression</code></a></li> <li><a href="#ifstatement"><code>IfStatement</code></a></li> </ul> <h4>
Declaration</h4> <p>A cover of any <a href="https://tc39.es/ecma262/#prod-Declaration">Declaration</a>s.</p> <pre data-language="javascript">t.isDeclaration(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#classdeclaration"><code>ClassDeclaration</code></a></li> <li><a href="#declareclass"><code>DeclareClass</code></a></li> <li><a href="#declareexportalldeclaration"><code>DeclareExportAllDeclaration</code></a></li> <li><a href="#declareexportdeclaration"><code>DeclareExportDeclaration</code></a></li> <li><a href="#declarefunction"><code>DeclareFunction</code></a></li> <li><a href="#declareinterface"><code>DeclareInterface</code></a></li> <li><a href="#declaremodule"><code>DeclareModule</code></a></li> <li><a href="#declaremoduleexports"><code>DeclareModuleExports</code></a></li> <li><a href="#declareopaquetype"><code>DeclareOpaqueType</code></a></li> <li><a href="#declaretypealias"><code>DeclareTypeAlias</code></a></li> <li><a href="#declarevariable"><code>DeclareVariable</code></a></li> <li><a href="#enumdeclaration"><code>EnumDeclaration</code></a></li> <li><a href="#exportalldeclaration"><code>ExportAllDeclaration</code></a></li> <li><a href="#exportdefaultdeclaration"><code>ExportDefaultDeclaration</code></a></li> <li><a href="#exportnameddeclaration"><code>ExportNamedDeclaration</code></a></li> <li><a href="#functiondeclaration"><code>FunctionDeclaration</code></a></li> <li><a href="#importdeclaration"><code>ImportDeclaration</code></a></li> <li><a href="#interfacedeclaration"><code>InterfaceDeclaration</code></a></li> <li><a href="#opaquetype"><code>OpaqueType</code></a></li> <li><a href="#tsdeclarefunction"><code>TSDeclareFunction</code></a></li> <li><a href="#tsenumdeclaration"><code>TSEnumDeclaration</code></a></li> <li><a href="#tsinterfacedeclaration"><code>TSInterfaceDeclaration</code></a></li> <li><a href="#tsmoduledeclaration"><code>TSModuleDeclaration</code></a></li> <li><a href="#tstypealiasdeclaration"><code>TSTypeAliasDeclaration</code></a></li> <li><a href="#typealias"><code>TypeAlias</code></a></li> <li><a href="#variabledeclaration"><code>VariableDeclaration</code></a></li> </ul> <h4>
EnumBody</h4> <p>A cover of Flow enum bodies.</p> <pre data-language="javascript">t.isEnumBody(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#enumbooleanbody"><code>EnumBooleanBody</code></a></li> <li><a href="#enumnumberbody"><code>EnumNumberBody</code></a></li> <li><a href="#enumstringbody"><code>EnumStringBody</code></a></li> <li><a href="#enumsymbolbody"><code>EnumSymbolBody</code></a></li> </ul> <h4>
EnumMember</h4> <p>A cover of Flow enum membors.</p> <pre data-language="javascript">t.isEnumMember(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#enumbooleanmember"><code>EnumBooleanMember</code></a></li> <li><a href="#enumdefaultedmember"><code>EnumDefaultedMember</code></a></li> <li><a href="#enumnumbermember"><code>EnumNumberMember</code></a></li> <li><a href="#enumstringmember"><code>EnumStringMember</code></a></li> </ul> <h4>
ExportDeclaration</h4> <p>A cover of any <a href="https://tc39.es/ecma262/#prod-ExportDeclaration">ExportDeclaration</a>s.</p> <pre data-language="javascript">t.isExportDeclaration(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#exportalldeclaration"><code>ExportAllDeclaration</code></a></li> <li><a href="#exportdefaultdeclaration"><code>ExportDefaultDeclaration</code></a></li> <li><a href="#exportnameddeclaration"><code>ExportNamedDeclaration</code></a></li> </ul> <h4>
Expression</h4> <p>A cover of any <a href="https://tc39.es/ecma262/#sec-ecmascript-language-expressions">Expression</a>s.</p> <pre data-language="javascript">t.isExpression(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#arrayexpression"><code>ArrayExpression</code></a></li> <li><a href="#arrowfunctionexpression"><code>ArrowFunctionExpression</code></a></li> <li><a href="#assignmentexpression"><code>AssignmentExpression</code></a></li> <li><a href="#awaitexpression"><code>AwaitExpression</code></a></li> <li><a href="#bigintliteral"><code>BigIntLiteral</code></a></li> <li><a href="#binaryexpression"><code>BinaryExpression</code></a></li> <li><a href="#bindexpression"><code>BindExpression</code></a></li> <li><a href="#booleanliteral"><code>BooleanLiteral</code></a></li> <li><a href="#callexpression"><code>CallExpression</code></a></li> <li><a href="#classexpression"><code>ClassExpression</code></a></li> <li><a href="#conditionalexpression"><code>ConditionalExpression</code></a></li> <li><a href="#decimalliteral"><code>DecimalLiteral</code></a></li> <li><a href="#doexpression"><code>DoExpression</code></a></li> <li><a href="#functionexpression"><code>FunctionExpression</code></a></li> <li><a href="#identifier"><code>Identifier</code></a></li> <li><a href="#import"><code>Import</code></a></li> <li><a href="#jsxelement"><code>JSXElement</code></a></li> <li><a href="#jsxfragment"><code>JSXFragment</code></a></li> <li><a href="#logicalexpression"><code>LogicalExpression</code></a></li> <li><a href="#memberexpression"><code>MemberExpression</code></a></li> <li><a href="#metaproperty"><code>MetaProperty</code></a></li> <li><a href="#moduleexpression"><code>ModuleExpression</code></a></li> <li><a href="#nullliteral"><code>NullLiteral</code></a></li> <li><a href="#numericliteral"><code>NumericLiteral</code></a></li> <li><a href="#objectexpression"><code>ObjectExpression</code></a></li> <li><a href="#optionalcallexpression"><code>OptionalCallExpression</code></a></li> <li><a href="#optionalmemberexpression"><code>OptionalMemberExpression</code></a></li> <li><a href="#parenthesizedexpression"><code>ParenthesizedExpression</code></a></li> <li><a href="#pipelinebarefunction"><code>PipelineBareFunction</code></a></li> <li><a href="#pipelineprimarytopicreference"><code>PipelinePrimaryTopicReference</code></a></li> <li><a href="#pipelinetopicexpression"><code>PipelineTopicExpression</code></a></li> <li><a href="#recordexpression"><code>RecordExpression</code></a></li> <li><a href="#regexpliteral"><code>RegExpLiteral</code></a></li> <li><a href="#sequenceexpression"><code>SequenceExpression</code></a></li> <li><a href="#stringliteral"><code>StringLiteral</code></a></li> <li><a href="#super"><code>Super</code></a></li> <li><a href="#tsasexpression"><code>TSAsExpression</code></a></li> <li><a href="#tsnonnullexpression"><code>TSNonNullExpression</code></a></li> <li><a href="#tstypeassertion"><code>TSTypeAssertion</code></a></li> <li><a href="#taggedtemplateexpression"><code>TaggedTemplateExpression</code></a></li> <li><a href="#templateliteral"><code>TemplateLiteral</code></a></li> <li><a href="#thisexpression"><code>ThisExpression</code></a></li> <li><a href="#topicreference"><code>TopicReference</code></a></li> <li><a href="#tupleexpression"><code>TupleExpression</code></a></li> <li><a href="#typecastexpression"><code>TypeCastExpression</code></a></li> <li><a href="#unaryexpression"><code>UnaryExpression</code></a></li> <li><a href="#updateexpression"><code>UpdateExpression</code></a></li> <li><a href="#yieldexpression"><code>YieldExpression</code></a></li> </ul> <h4>
ExpressionWrapper</h4> <p>A wrapper of expression that does not have runtime semantics.</p> <pre data-language="javascript">t.isExpressionWrapper(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#expressionstatement"><code>ExpressionStatement</code></a></li> <li><a href="#parenthesizedexpression"><code>ParenthesizedExpression</code></a></li> <li><a href="#typecastexpression"><code>TypeCastExpression</code></a></li> </ul> <h4>
Flow</h4> <p>A cover of AST nodes defined for Flow.</p> <pre data-language="javascript">t.isFlow(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#anytypeannotation"><code>AnyTypeAnnotation</code></a></li> <li><a href="#arraytypeannotation"><code>ArrayTypeAnnotation</code></a></li> <li><a href="#booleanliteraltypeannotation"><code>BooleanLiteralTypeAnnotation</code></a></li> <li><a href="#booleantypeannotation"><code>BooleanTypeAnnotation</code></a></li> <li><a href="#classimplements"><code>ClassImplements</code></a></li> <li><a href="#declareclass"><code>DeclareClass</code></a></li> <li><a href="#declareexportalldeclaration"><code>DeclareExportAllDeclaration</code></a></li> <li><a href="#declareexportdeclaration"><code>DeclareExportDeclaration</code></a></li> <li><a href="#declarefunction"><code>DeclareFunction</code></a></li> <li><a href="#declareinterface"><code>DeclareInterface</code></a></li> <li><a href="#declaremodule"><code>DeclareModule</code></a></li> <li><a href="#declaremoduleexports"><code>DeclareModuleExports</code></a></li> <li><a href="#declareopaquetype"><code>DeclareOpaqueType</code></a></li> <li><a href="#declaretypealias"><code>DeclareTypeAlias</code></a></li> <li><a href="#declarevariable"><code>DeclareVariable</code></a></li> <li><a href="#declaredpredicate"><code>DeclaredPredicate</code></a></li> <li><a href="#emptytypeannotation"><code>EmptyTypeAnnotation</code></a></li> <li><a href="#enumbooleanbody"><code>EnumBooleanBody</code></a></li> <li><a href="#enumbooleanmember"><code>EnumBooleanMember</code></a></li> <li><a href="#enumdeclaration"><code>EnumDeclaration</code></a></li> <li><a href="#enumdefaultedmember"><code>EnumDefaultedMember</code></a></li> <li><a href="#enumnumberbody"><code>EnumNumberBody</code></a></li> <li><a href="#enumnumbermember"><code>EnumNumberMember</code></a></li> <li><a href="#enumstringbody"><code>EnumStringBody</code></a></li> <li><a href="#enumstringmember"><code>EnumStringMember</code></a></li> <li><a href="#enumsymbolbody"><code>EnumSymbolBody</code></a></li> <li><a href="#existstypeannotation"><code>ExistsTypeAnnotation</code></a></li> <li><a href="#functiontypeannotation"><code>FunctionTypeAnnotation</code></a></li> <li><a href="#functiontypeparam"><code>FunctionTypeParam</code></a></li> <li><a href="#generictypeannotation"><code>GenericTypeAnnotation</code></a></li> <li><a href="#indexedaccesstype"><code>IndexedAccessType</code></a></li> <li><a href="#inferredpredicate"><code>InferredPredicate</code></a></li> <li><a href="#interfacedeclaration"><code>InterfaceDeclaration</code></a></li> <li><a href="#interfaceextends"><code>InterfaceExtends</code></a></li> <li><a href="#interfacetypeannotation"><code>InterfaceTypeAnnotation</code></a></li> <li><a href="#intersectiontypeannotation"><code>IntersectionTypeAnnotation</code></a></li> <li><a href="#mixedtypeannotation"><code>MixedTypeAnnotation</code></a></li> <li><a href="#nullliteraltypeannotation"><code>NullLiteralTypeAnnotation</code></a></li> <li><a href="#nullabletypeannotation"><code>NullableTypeAnnotation</code></a></li> <li><a href="#numberliteraltypeannotation"><code>NumberLiteralTypeAnnotation</code></a></li> <li><a href="#numbertypeannotation"><code>NumberTypeAnnotation</code></a></li> <li><a href="#objecttypeannotation"><code>ObjectTypeAnnotation</code></a></li> <li><a href="#objecttypecallproperty"><code>ObjectTypeCallProperty</code></a></li> <li><a href="#objecttypeindexer"><code>ObjectTypeIndexer</code></a></li> <li><a href="#objecttypeinternalslot"><code>ObjectTypeInternalSlot</code></a></li> <li><a href="#objecttypeproperty"><code>ObjectTypeProperty</code></a></li> <li><a href="#objecttypespreadproperty"><code>ObjectTypeSpreadProperty</code></a></li> <li><a href="#opaquetype"><code>OpaqueType</code></a></li> <li><a href="#optionalindexedaccesstype"><code>OptionalIndexedAccessType</code></a></li> <li><a href="#qualifiedtypeidentifier"><code>QualifiedTypeIdentifier</code></a></li> <li><a href="#stringliteraltypeannotation"><code>StringLiteralTypeAnnotation</code></a></li> <li><a href="#stringtypeannotation"><code>StringTypeAnnotation</code></a></li> <li><a href="#symboltypeannotation"><code>SymbolTypeAnnotation</code></a></li> <li><a href="#thistypeannotation"><code>ThisTypeAnnotation</code></a></li> <li><a href="#tupletypeannotation"><code>TupleTypeAnnotation</code></a></li> <li><a href="#typealias"><code>TypeAlias</code></a></li> <li><a href="#typeannotation"><code>TypeAnnotation</code></a></li> <li><a href="#typecastexpression"><code>TypeCastExpression</code></a></li> <li><a href="#typeparameter"><code>TypeParameter</code></a></li> <li><a href="#typeparameterdeclaration"><code>TypeParameterDeclaration</code></a></li> <li><a href="#typeparameterinstantiation"><code>TypeParameterInstantiation</code></a></li> <li><a href="#typeoftypeannotation"><code>TypeofTypeAnnotation</code></a></li> <li><a href="#uniontypeannotation"><code>UnionTypeAnnotation</code></a></li> <li><a href="#variance"><code>Variance</code></a></li> <li><a href="#voidtypeannotation"><code>VoidTypeAnnotation</code></a></li> </ul> <h4>
FlowBaseAnnotation</h4> <p>A cover of primary Flow type annotations.</p> <pre data-language="javascript">t.isFlowBaseAnnotation(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#anytypeannotation"><code>AnyTypeAnnotation</code></a></li> <li><a href="#booleantypeannotation"><code>BooleanTypeAnnotation</code></a></li> <li><a href="#emptytypeannotation"><code>EmptyTypeAnnotation</code></a></li> <li><a href="#mixedtypeannotation"><code>MixedTypeAnnotation</code></a></li> <li><a href="#nullliteraltypeannotation"><code>NullLiteralTypeAnnotation</code></a></li> <li><a href="#numbertypeannotation"><code>NumberTypeAnnotation</code></a></li> <li><a href="#stringtypeannotation"><code>StringTypeAnnotation</code></a></li> <li><a href="#symboltypeannotation"><code>SymbolTypeAnnotation</code></a></li> <li><a href="#thistypeannotation"><code>ThisTypeAnnotation</code></a></li> <li><a href="#voidtypeannotation"><code>VoidTypeAnnotation</code></a></li> </ul> <h4>
FlowDeclaration</h4> <p>A cover of Flow declarations.</p> <pre data-language="javascript">t.isFlowDeclaration(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#declareclass"><code>DeclareClass</code></a></li> <li><a href="#declareexportalldeclaration"><code>DeclareExportAllDeclaration</code></a></li> <li><a href="#declareexportdeclaration"><code>DeclareExportDeclaration</code></a></li> <li><a href="#declarefunction"><code>DeclareFunction</code></a></li> <li><a href="#declareinterface"><code>DeclareInterface</code></a></li> <li><a href="#declaremodule"><code>DeclareModule</code></a></li> <li><a href="#declaremoduleexports"><code>DeclareModuleExports</code></a></li> <li><a href="#declareopaquetype"><code>DeclareOpaqueType</code></a></li> <li><a href="#declaretypealias"><code>DeclareTypeAlias</code></a></li> <li><a href="#declarevariable"><code>DeclareVariable</code></a></li> <li><a href="#interfacedeclaration"><code>InterfaceDeclaration</code></a></li> <li><a href="#opaquetype"><code>OpaqueType</code></a></li> <li><a href="#typealias"><code>TypeAlias</code></a></li> </ul> <h4>
FlowPredicate</h4> <p>A cover of Flow predicates.</p> <pre data-language="javascript">t.isFlowPredicate(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#declaredpredicate"><code>DeclaredPredicate</code></a></li> <li><a href="#inferredpredicate"><code>InferredPredicate</code></a></li> </ul> <h4>
FlowType</h4> <p>A cover of Flow type annotations.</p> <pre data-language="javascript">t.isFlowType(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#anytypeannotation"><code>AnyTypeAnnotation</code></a></li> <li><a href="#arraytypeannotation"><code>ArrayTypeAnnotation</code></a></li> <li><a href="#booleanliteraltypeannotation"><code>BooleanLiteralTypeAnnotation</code></a></li> <li><a href="#booleantypeannotation"><code>BooleanTypeAnnotation</code></a></li> <li><a href="#emptytypeannotation"><code>EmptyTypeAnnotation</code></a></li> <li><a href="#existstypeannotation"><code>ExistsTypeAnnotation</code></a></li> <li><a href="#functiontypeannotation"><code>FunctionTypeAnnotation</code></a></li> <li><a href="#generictypeannotation"><code>GenericTypeAnnotation</code></a></li> <li><a href="#indexedaccesstype"><code>IndexedAccessType</code></a></li> <li><a href="#interfacetypeannotation"><code>InterfaceTypeAnnotation</code></a></li> <li><a href="#intersectiontypeannotation"><code>IntersectionTypeAnnotation</code></a></li> <li><a href="#mixedtypeannotation"><code>MixedTypeAnnotation</code></a></li> <li><a href="#nullliteraltypeannotation"><code>NullLiteralTypeAnnotation</code></a></li> <li><a href="#nullabletypeannotation"><code>NullableTypeAnnotation</code></a></li> <li><a href="#numberliteraltypeannotation"><code>NumberLiteralTypeAnnotation</code></a></li> <li><a href="#numbertypeannotation"><code>NumberTypeAnnotation</code></a></li> <li><a href="#objecttypeannotation"><code>ObjectTypeAnnotation</code></a></li> <li><a href="#optionalindexedaccesstype"><code>OptionalIndexedAccessType</code></a></li> <li><a href="#stringliteraltypeannotation"><code>StringLiteralTypeAnnotation</code></a></li> <li><a href="#stringtypeannotation"><code>StringTypeAnnotation</code></a></li> <li><a href="#symboltypeannotation"><code>SymbolTypeAnnotation</code></a></li> <li><a href="#thistypeannotation"><code>ThisTypeAnnotation</code></a></li> <li><a href="#tupletypeannotation"><code>TupleTypeAnnotation</code></a></li> <li><a href="#typeoftypeannotation"><code>TypeofTypeAnnotation</code></a></li> <li><a href="#uniontypeannotation"><code>UnionTypeAnnotation</code></a></li> <li><a href="#voidtypeannotation"><code>VoidTypeAnnotation</code></a></li> </ul> <h4>
For</h4> <p>A cover of <a href="https://tc39.es/ecma262/#sec-for-statement">ForStatement</a>s and <a href="#forxstatement">ForXStatement</a>s.</p> <pre data-language="javascript">t.isFor(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#forinstatement"><code>ForInStatement</code></a></li> <li><a href="#forofstatement"><code>ForOfStatement</code></a></li> <li><a href="#forstatement"><code>ForStatement</code></a></li> </ul> <h4>
ForXStatement</h4> <p>A cover of <a href="https://tc39.es/ecma262/#sec-for-in-and-for-of-statements">ForInStatements and ForOfStatements</a>.</p> <pre data-language="javascript">t.isForXStatement(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#forinstatement"><code>ForInStatement</code></a></li> <li><a href="#forofstatement"><code>ForOfStatement</code></a></li> </ul> <h4>
Function</h4> <p>A cover of functions and <a href="#method">method</a>s, the must have <code>body</code> and <code>params</code>. Note: <code>Function</code> is different to <code>FunctionParent</code>.</p> <pre data-language="javascript">t.isFunction(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#arrowfunctionexpression"><code>ArrowFunctionExpression</code></a></li> <li><a href="#classmethod"><code>ClassMethod</code></a></li> <li><a href="#classprivatemethod"><code>ClassPrivateMethod</code></a></li> <li><a href="#functiondeclaration"><code>FunctionDeclaration</code></a></li> <li><a href="#functionexpression"><code>FunctionExpression</code></a></li> <li><a href="#objectmethod"><code>ObjectMethod</code></a></li> </ul> <h4>
FunctionParent</h4> <p>A cover of AST nodes that start an execution context with new <a href="https://tc39.es/ecma262/#table-additional-state-components-for-ecmascript-code-execution-contexts">VariableEnvironment</a>. In other words, they define the scope of <code>var</code> declarations. FunctionParent did not include <code>Program</code> since Babel 7.</p> <pre data-language="javascript">t.isFunctionParent(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#arrowfunctionexpression"><code>ArrowFunctionExpression</code></a></li> <li><a href="#classmethod"><code>ClassMethod</code></a></li> <li><a href="#classprivatemethod"><code>ClassPrivateMethod</code></a></li> <li><a href="#functiondeclaration"><code>FunctionDeclaration</code></a></li> <li><a href="#functionexpression"><code>FunctionExpression</code></a></li> <li><a href="#objectmethod"><code>ObjectMethod</code></a></li> </ul> <h4>
Immutable</h4> <p>A cover of immutable objects and JSX elements. An object is <a href="https://tc39.es/ecma262/#immutable-prototype-exotic-object">immutable</a> if no other properties can be defined once created.</p> <pre data-language="javascript">t.isImmutable(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#bigintliteral"><code>BigIntLiteral</code></a></li> <li><a href="#booleanliteral"><code>BooleanLiteral</code></a></li> <li><a href="#decimalliteral"><code>DecimalLiteral</code></a></li> <li><a href="#jsxattribute"><code>JSXAttribute</code></a></li> <li><a href="#jsxclosingelement"><code>JSXClosingElement</code></a></li> <li><a href="#jsxclosingfragment"><code>JSXClosingFragment</code></a></li> <li><a href="#jsxelement"><code>JSXElement</code></a></li> <li><a href="#jsxexpressioncontainer"><code>JSXExpressionContainer</code></a></li> <li><a href="#jsxfragment"><code>JSXFragment</code></a></li> <li><a href="#jsxopeningelement"><code>JSXOpeningElement</code></a></li> <li><a href="#jsxopeningfragment"><code>JSXOpeningFragment</code></a></li> <li><a href="#jsxspreadchild"><code>JSXSpreadChild</code></a></li> <li><a href="#jsxtext"><code>JSXText</code></a></li> <li><a href="#nullliteral"><code>NullLiteral</code></a></li> <li><a href="#numericliteral"><code>NumericLiteral</code></a></li> <li><a href="#stringliteral"><code>StringLiteral</code></a></li> </ul> <h4>
JSX</h4> <p>A cover of AST nodes defined for <a href="https://facebook.github.io/jsx/">JSX</a>.</p> <pre data-language="javascript">t.isJSX(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#jsxattribute"><code>JSXAttribute</code></a></li> <li><a href="#jsxclosingelement"><code>JSXClosingElement</code></a></li> <li><a href="#jsxclosingfragment"><code>JSXClosingFragment</code></a></li> <li><a href="#jsxelement"><code>JSXElement</code></a></li> <li><a href="#jsxemptyexpression"><code>JSXEmptyExpression</code></a></li> <li><a href="#jsxexpressioncontainer"><code>JSXExpressionContainer</code></a></li> <li><a href="#jsxfragment"><code>JSXFragment</code></a></li> <li><a href="#jsxidentifier"><code>JSXIdentifier</code></a></li> <li><a href="#jsxmemberexpression"><code>JSXMemberExpression</code></a></li> <li><a href="#jsxnamespacedname"><code>JSXNamespacedName</code></a></li> <li><a href="#jsxopeningelement"><code>JSXOpeningElement</code></a></li> <li><a href="#jsxopeningfragment"><code>JSXOpeningFragment</code></a></li> <li><a href="#jsxspreadattribute"><code>JSXSpreadAttribute</code></a></li> <li><a href="#jsxspreadchild"><code>JSXSpreadChild</code></a></li> <li><a href="#jsxtext"><code>JSXText</code></a></li> </ul> <h4>
LVal</h4> <p>A cover of left hand side expressions used in the <code>left</code> of assignment expressions and <a href="#forxstatement">ForXStatement</a>s.</p> <pre data-language="javascript">t.isLVal(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#arraypattern"><code>ArrayPattern</code></a></li> <li><a href="#assignmentpattern"><code>AssignmentPattern</code></a></li> <li><a href="#identifier"><code>Identifier</code></a></li> <li><a href="#memberexpression"><code>MemberExpression</code></a></li> <li><a href="#objectpattern"><code>ObjectPattern</code></a></li> <li><a href="#restelement"><code>RestElement</code></a></li> <li><a href="#tsparameterproperty"><code>TSParameterProperty</code></a></li> </ul> <h4>
Literal</h4> <p>A cover of <a href="https://tc39.es/ecma262/#sec-primary-expression-literals">Literal</a>s, <a href="https://tc39.es/ecma262/#sec-primary-expression-regular-expression-literals">Regular Expression Literal</a>s and <a href="https://tc39.es/ecma262/#sec-template-literals">Template Literal</a>s.</p> <pre data-language="javascript">t.isLiteral(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#bigintliteral"><code>BigIntLiteral</code></a></li> <li><a href="#booleanliteral"><code>BooleanLiteral</code></a></li> <li><a href="#decimalliteral"><code>DecimalLiteral</code></a></li> <li><a href="#nullliteral"><code>NullLiteral</code></a></li> <li><a href="#numericliteral"><code>NumericLiteral</code></a></li> <li><a href="#regexpliteral"><code>RegExpLiteral</code></a></li> <li><a href="#stringliteral"><code>StringLiteral</code></a></li> <li><a href="#templateliteral"><code>TemplateLiteral</code></a></li> </ul> <h4>
Loop</h4> <p>A cover of loop statements.</p> <pre data-language="javascript">t.isLoop(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#dowhilestatement"><code>DoWhileStatement</code></a></li> <li><a href="#forinstatement"><code>ForInStatement</code></a></li> <li><a href="#forofstatement"><code>ForOfStatement</code></a></li> <li><a href="#forstatement"><code>ForStatement</code></a></li> <li><a href="#whilestatement"><code>WhileStatement</code></a></li> </ul> <h4>
Method</h4> <p>A cover of object methods and class methods.</p> <pre data-language="javascript">t.isMethod(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#classmethod"><code>ClassMethod</code></a></li> <li><a href="#classprivatemethod"><code>ClassPrivateMethod</code></a></li> <li><a href="#objectmethod"><code>ObjectMethod</code></a></li> </ul> <h4>
Miscellaneous</h4> <p>A cover of non-standard AST types that are sometimes useful for development.</p> <pre data-language="javascript">t.isMiscellaneous(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#noop"><code>Noop</code></a></li> <li><a href="#placeholder"><code>Placeholder</code></a></li> <li><a href="#v8intrinsicidentifier"><code>V8IntrinsicIdentifier</code></a></li> </ul> <h4>
ModuleDeclaration</h4> <p>A cover of ImportDeclaration and <a href="#exportdeclaration">ExportDeclaration</a></p> <pre data-language="javascript">t.isModuleDeclaration(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#exportalldeclaration"><code>ExportAllDeclaration</code></a></li> <li><a href="#exportdefaultdeclaration"><code>ExportDefaultDeclaration</code></a></li> <li><a href="#exportnameddeclaration"><code>ExportNamedDeclaration</code></a></li> <li><a href="#importdeclaration"><code>ImportDeclaration</code></a></li> </ul> <h4>
ModuleSpecifier</h4> <p>A cover of import and export specifiers. Note: It is <em>not</em> the <a href="https://tc39.es/ecma262/#prod-ModuleSpecifier">ModuleSpecifier</a> defined in the spec.</p> <pre data-language="javascript">t.isModuleSpecifier(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#exportdefaultspecifier"><code>ExportDefaultSpecifier</code></a></li> <li><a href="#exportnamespacespecifier"><code>ExportNamespaceSpecifier</code></a></li> <li><a href="#exportspecifier"><code>ExportSpecifier</code></a></li> <li><a href="#importdefaultspecifier"><code>ImportDefaultSpecifier</code></a></li> <li><a href="#importnamespacespecifier"><code>ImportNamespaceSpecifier</code></a></li> <li><a href="#importspecifier"><code>ImportSpecifier</code></a></li> </ul> <h4>
ObjectMember</h4> <p>A cover of <a href="https://tc39.es/ecma262/#prod-PropertyDefinitionList">members</a> in an object literal.</p> <pre data-language="javascript">t.isObjectMember(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#objectmethod"><code>ObjectMethod</code></a></li> <li><a href="#objectproperty"><code>ObjectProperty</code></a></li> </ul> <h4>
Pattern</h4> <p>A cover of <a href="https://tc39.es/ecma262/#prod-BindingPattern">BindingPattern</a> except Identifiers.</p> <pre data-language="javascript">t.isPattern(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#arraypattern"><code>ArrayPattern</code></a></li> <li><a href="#assignmentpattern"><code>AssignmentPattern</code></a></li> <li><a href="#objectpattern"><code>ObjectPattern</code></a></li> </ul> <h4>
PatternLike</h4> <p>A cover of <a href="https://tc39.es/ecma262/#prod-BindingPattern">BindingPattern</a>s.</p> <pre data-language="javascript">t.isPatternLike(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#arraypattern"><code>ArrayPattern</code></a></li> <li><a href="#assignmentpattern"><code>AssignmentPattern</code></a></li> <li><a href="#identifier"><code>Identifier</code></a></li> <li><a href="#objectpattern"><code>ObjectPattern</code></a></li> <li><a href="#restelement"><code>RestElement</code></a></li> </ul> <h4>
Private</h4> <p>A cover of private class elements and private identifiers.</p> <pre data-language="javascript">t.isPrivate(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#classprivatemethod"><code>ClassPrivateMethod</code></a></li> <li><a href="#classprivateproperty"><code>ClassPrivateProperty</code></a></li> <li><a href="#privatename"><code>PrivateName</code></a></li> </ul> <h4>
Property</h4> <p>A cover of object properties and class properties.</p> <pre data-language="javascript">t.isProperty(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#classprivateproperty"><code>ClassPrivateProperty</code></a></li> <li><a href="#classproperty"><code>ClassProperty</code></a></li> <li><a href="#objectproperty"><code>ObjectProperty</code></a></li> </ul> <h4>
Proposal</h4> <p>A cover of AST nodes which are proprosed for inclusion in ECMAScript.</p> <pre data-language="javascript">t.isProposal(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#argumentplaceholder"><code>ArgumentPlaceholder</code></a></li> <li><a href="#bindexpression"><code>BindExpression</code></a></li> <li><a href="#decimalliteral"><code>DecimalLiteral</code></a></li> <li><a href="#decorator"><code>Decorator</code></a></li> <li><a href="#doexpression"><code>DoExpression</code></a></li> <li><a href="#exportdefaultspecifier"><code>ExportDefaultSpecifier</code></a></li> <li><a href="#importattribute"><code>ImportAttribute</code></a></li> <li><a href="#moduleexpression"><code>ModuleExpression</code></a></li> <li><a href="#pipelinebarefunction"><code>PipelineBareFunction</code></a></li> <li><a href="#pipelineprimarytopicreference"><code>PipelinePrimaryTopicReference</code></a></li> <li><a href="#pipelinetopicexpression"><code>PipelineTopicExpression</code></a></li> <li><a href="#recordexpression"><code>RecordExpression</code></a></li> <li><a href="#staticblock"><code>StaticBlock</code></a></li> <li><a href="#tupleexpression"><code>TupleExpression</code></a></li> </ul> <h4>
Pureish</h4> <p>A cover of AST nodes which do not have side-effects. In other words, there is no observable behaviour changes if they are evaluated more than once.</p> <pre data-language="javascript">t.isPureish(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#arrowfunctionexpression"><code>ArrowFunctionExpression</code></a></li> <li><a href="#bigintliteral"><code>BigIntLiteral</code></a></li> <li><a href="#booleanliteral"><code>BooleanLiteral</code></a></li> <li><a href="#decimalliteral"><code>DecimalLiteral</code></a></li> <li><a href="#functiondeclaration"><code>FunctionDeclaration</code></a></li> <li><a href="#functionexpression"><code>FunctionExpression</code></a></li> <li><a href="#nullliteral"><code>NullLiteral</code></a></li> <li><a href="#numericliteral"><code>NumericLiteral</code></a></li> <li><a href="#regexpliteral"><code>RegExpLiteral</code></a></li> <li><a href="#stringliteral"><code>StringLiteral</code></a></li> </ul> <h4>
Scopable</h4> <p>A cover of <a href="#functionparent">FunctionParent</a> and <a href="#blockparent">BlockParent</a>.</p> <pre data-language="javascript">t.isScopable(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#arrowfunctionexpression"><code>ArrowFunctionExpression</code></a></li> <li><a href="#blockstatement"><code>BlockStatement</code></a></li> <li><a href="#catchclause"><code>CatchClause</code></a></li> <li><a href="#classdeclaration"><code>ClassDeclaration</code></a></li> <li><a href="#classexpression"><code>ClassExpression</code></a></li> <li><a href="#classmethod"><code>ClassMethod</code></a></li> <li><a href="#classprivatemethod"><code>ClassPrivateMethod</code></a></li> <li><a href="#dowhilestatement"><code>DoWhileStatement</code></a></li> <li><a href="#forinstatement"><code>ForInStatement</code></a></li> <li><a href="#forofstatement"><code>ForOfStatement</code></a></li> <li><a href="#forstatement"><code>ForStatement</code></a></li> <li><a href="#functiondeclaration"><code>FunctionDeclaration</code></a></li> <li><a href="#functionexpression"><code>FunctionExpression</code></a></li> <li><a href="#objectmethod"><code>ObjectMethod</code></a></li> <li><a href="#program"><code>Program</code></a></li> <li><a href="#staticblock"><code>StaticBlock</code></a></li> <li><a href="#switchstatement"><code>SwitchStatement</code></a></li> <li><a href="#tsmoduleblock"><code>TSModuleBlock</code></a></li> <li><a href="#whilestatement"><code>WhileStatement</code></a></li> </ul> <h4>
Standardized</h4> <p>A cover of AST nodes which are part of an official ECMAScript specification.</p> <pre data-language="javascript">t.isStandardized(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#arrayexpression"><code>ArrayExpression</code></a></li> <li><a href="#arraypattern"><code>ArrayPattern</code></a></li> <li><a href="#arrowfunctionexpression"><code>ArrowFunctionExpression</code></a></li> <li><a href="#assignmentexpression"><code>AssignmentExpression</code></a></li> <li><a href="#assignmentpattern"><code>AssignmentPattern</code></a></li> <li><a href="#awaitexpression"><code>AwaitExpression</code></a></li> <li><a href="#bigintliteral"><code>BigIntLiteral</code></a></li> <li><a href="#binaryexpression"><code>BinaryExpression</code></a></li> <li><a href="#blockstatement"><code>BlockStatement</code></a></li> <li><a href="#booleanliteral"><code>BooleanLiteral</code></a></li> <li><a href="#breakstatement"><code>BreakStatement</code></a></li> <li><a href="#callexpression"><code>CallExpression</code></a></li> <li><a href="#catchclause"><code>CatchClause</code></a></li> <li><a href="#classbody"><code>ClassBody</code></a></li> <li><a href="#classdeclaration"><code>ClassDeclaration</code></a></li> <li><a href="#classexpression"><code>ClassExpression</code></a></li> <li><a href="#classmethod"><code>ClassMethod</code></a></li> <li><a href="#classprivatemethod"><code>ClassPrivateMethod</code></a></li> <li><a href="#classprivateproperty"><code>ClassPrivateProperty</code></a></li> <li><a href="#classproperty"><code>ClassProperty</code></a></li> <li><a href="#conditionalexpression"><code>ConditionalExpression</code></a></li> <li><a href="#continuestatement"><code>ContinueStatement</code></a></li> <li><a href="#debuggerstatement"><code>DebuggerStatement</code></a></li> <li><a href="#directive"><code>Directive</code></a></li> <li><a href="#directiveliteral"><code>DirectiveLiteral</code></a></li> <li><a href="#dowhilestatement"><code>DoWhileStatement</code></a></li> <li><a href="#emptystatement"><code>EmptyStatement</code></a></li> <li><a href="#exportalldeclaration"><code>ExportAllDeclaration</code></a></li> <li><a href="#exportdefaultdeclaration"><code>ExportDefaultDeclaration</code></a></li> <li><a href="#exportnameddeclaration"><code>ExportNamedDeclaration</code></a></li> <li><a href="#exportnamespacespecifier"><code>ExportNamespaceSpecifier</code></a></li> <li><a href="#exportspecifier"><code>ExportSpecifier</code></a></li> <li><a href="#expressionstatement"><code>ExpressionStatement</code></a></li> <li><a href="#file"><code>File</code></a></li> <li><a href="#forinstatement"><code>ForInStatement</code></a></li> <li><a href="#forofstatement"><code>ForOfStatement</code></a></li> <li><a href="#forstatement"><code>ForStatement</code></a></li> <li><a href="#functiondeclaration"><code>FunctionDeclaration</code></a></li> <li><a href="#functionexpression"><code>FunctionExpression</code></a></li> <li><a href="#identifier"><code>Identifier</code></a></li> <li><a href="#ifstatement"><code>IfStatement</code></a></li> <li><a href="#import"><code>Import</code></a></li> <li><a href="#importdeclaration"><code>ImportDeclaration</code></a></li> <li><a href="#importdefaultspecifier"><code>ImportDefaultSpecifier</code></a></li> <li><a href="#importnamespacespecifier"><code>ImportNamespaceSpecifier</code></a></li> <li><a href="#importspecifier"><code>ImportSpecifier</code></a></li> <li><a href="#interpreterdirective"><code>InterpreterDirective</code></a></li> <li><a href="#labeledstatement"><code>LabeledStatement</code></a></li> <li><a href="#logicalexpression"><code>LogicalExpression</code></a></li> <li><a href="#memberexpression"><code>MemberExpression</code></a></li> <li><a href="#metaproperty"><code>MetaProperty</code></a></li> <li><a href="#newexpression"><code>NewExpression</code></a></li> <li><a href="#nullliteral"><code>NullLiteral</code></a></li> <li><a href="#numericliteral"><code>NumericLiteral</code></a></li> <li><a href="#objectexpression"><code>ObjectExpression</code></a></li> <li><a href="#objectmethod"><code>ObjectMethod</code></a></li> <li><a href="#objectpattern"><code>ObjectPattern</code></a></li> <li><a href="#objectproperty"><code>ObjectProperty</code></a></li> <li><a href="#optionalcallexpression"><code>OptionalCallExpression</code></a></li> <li><a href="#optionalmemberexpression"><code>OptionalMemberExpression</code></a></li> <li><a href="#parenthesizedexpression"><code>ParenthesizedExpression</code></a></li> <li><a href="#privatename"><code>PrivateName</code></a></li> <li><a href="#program"><code>Program</code></a></li> <li><a href="#regexpliteral"><code>RegExpLiteral</code></a></li> <li><a href="#restelement"><code>RestElement</code></a></li> <li><a href="#returnstatement"><code>ReturnStatement</code></a></li> <li><a href="#sequenceexpression"><code>SequenceExpression</code></a></li> <li><a href="#spreadelement"><code>SpreadElement</code></a></li> <li><a href="#stringliteral"><code>StringLiteral</code></a></li> <li><a href="#super"><code>Super</code></a></li> <li><a href="#switchcase"><code>SwitchCase</code></a></li> <li><a href="#switchstatement"><code>SwitchStatement</code></a></li> <li><a href="#taggedtemplateexpression"><code>TaggedTemplateExpression</code></a></li> <li><a href="#templateelement"><code>TemplateElement</code></a></li> <li><a href="#templateliteral"><code>TemplateLiteral</code></a></li> <li><a href="#thisexpression"><code>ThisExpression</code></a></li> <li><a href="#throwstatement"><code>ThrowStatement</code></a></li> <li><a href="#trystatement"><code>TryStatement</code></a></li> <li><a href="#unaryexpression"><code>UnaryExpression</code></a></li> <li><a href="#updateexpression"><code>UpdateExpression</code></a></li> <li><a href="#variabledeclaration"><code>VariableDeclaration</code></a></li> <li><a href="#variabledeclarator"><code>VariableDeclarator</code></a></li> <li><a href="#whilestatement"><code>WhileStatement</code></a></li> <li><a href="#withstatement"><code>WithStatement</code></a></li> <li><a href="#yieldexpression"><code>YieldExpression</code></a></li> </ul> <h4>
StandardizedOrProposal</h4> <p>A cover of AST nodes which are part of an official ECMAScript specification or a proposed for inclusion.</p> <pre data-language="javascript">t.isStandardizedOrProposal(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#argumentplaceholder"><code>ArgumentPlaceholder</code></a></li> <li><a href="#arrayexpression"><code>ArrayExpression</code></a></li> <li><a href="#arraypattern"><code>ArrayPattern</code></a></li> <li><a href="#arrowfunctionexpression"><code>ArrowFunctionExpression</code></a></li> <li><a href="#assignmentexpression"><code>AssignmentExpression</code></a></li> <li><a href="#assignmentpattern"><code>AssignmentPattern</code></a></li> <li><a href="#awaitexpression"><code>AwaitExpression</code></a></li> <li><a href="#bigintliteral"><code>BigIntLiteral</code></a></li> <li><a href="#binaryexpression"><code>BinaryExpression</code></a></li> <li><a href="#bindexpression"><code>BindExpression</code></a></li> <li><a href="#blockstatement"><code>BlockStatement</code></a></li> <li><a href="#booleanliteral"><code>BooleanLiteral</code></a></li> <li><a href="#breakstatement"><code>BreakStatement</code></a></li> <li><a href="#callexpression"><code>CallExpression</code></a></li> <li><a href="#catchclause"><code>CatchClause</code></a></li> <li><a href="#classbody"><code>ClassBody</code></a></li> <li><a href="#classdeclaration"><code>ClassDeclaration</code></a></li> <li><a href="#classexpression"><code>ClassExpression</code></a></li> <li><a href="#classmethod"><code>ClassMethod</code></a></li> <li><a href="#classprivatemethod"><code>ClassPrivateMethod</code></a></li> <li><a href="#classprivateproperty"><code>ClassPrivateProperty</code></a></li> <li><a href="#classproperty"><code>ClassProperty</code></a></li> <li><a href="#conditionalexpression"><code>ConditionalExpression</code></a></li> <li><a href="#continuestatement"><code>ContinueStatement</code></a></li> <li><a href="#debuggerstatement"><code>DebuggerStatement</code></a></li> <li><a href="#decimalliteral"><code>DecimalLiteral</code></a></li> <li><a href="#decorator"><code>Decorator</code></a></li> <li><a href="#directive"><code>Directive</code></a></li> <li><a href="#directiveliteral"><code>DirectiveLiteral</code></a></li> <li><a href="#doexpression"><code>DoExpression</code></a></li> <li><a href="#dowhilestatement"><code>DoWhileStatement</code></a></li> <li><a href="#emptystatement"><code>EmptyStatement</code></a></li> <li><a href="#exportalldeclaration"><code>ExportAllDeclaration</code></a></li> <li><a href="#exportdefaultdeclaration"><code>ExportDefaultDeclaration</code></a></li> <li><a href="#exportdefaultspecifier"><code>ExportDefaultSpecifier</code></a></li> <li><a href="#exportnameddeclaration"><code>ExportNamedDeclaration</code></a></li> <li><a href="#exportnamespacespecifier"><code>ExportNamespaceSpecifier</code></a></li> <li><a href="#exportspecifier"><code>ExportSpecifier</code></a></li> <li><a href="#expressionstatement"><code>ExpressionStatement</code></a></li> <li><a href="#file"><code>File</code></a></li> <li><a href="#forinstatement"><code>ForInStatement</code></a></li> <li><a href="#forofstatement"><code>ForOfStatement</code></a></li> <li><a href="#forstatement"><code>ForStatement</code></a></li> <li><a href="#functiondeclaration"><code>FunctionDeclaration</code></a></li> <li><a href="#functionexpression"><code>FunctionExpression</code></a></li> <li><a href="#identifier"><code>Identifier</code></a></li> <li><a href="#ifstatement"><code>IfStatement</code></a></li> <li><a href="#import"><code>Import</code></a></li> <li><a href="#importattribute"><code>ImportAttribute</code></a></li> <li><a href="#importdeclaration"><code>ImportDeclaration</code></a></li> <li><a href="#importdefaultspecifier"><code>ImportDefaultSpecifier</code></a></li> <li><a href="#importnamespacespecifier"><code>ImportNamespaceSpecifier</code></a></li> <li><a href="#importspecifier"><code>ImportSpecifier</code></a></li> <li><a href="#interpreterdirective"><code>InterpreterDirective</code></a></li> <li><a href="#labeledstatement"><code>LabeledStatement</code></a></li> <li><a href="#logicalexpression"><code>LogicalExpression</code></a></li> <li><a href="#memberexpression"><code>MemberExpression</code></a></li> <li><a href="#metaproperty"><code>MetaProperty</code></a></li> <li><a href="#moduleexpression"><code>ModuleExpression</code></a></li> <li><a href="#newexpression"><code>NewExpression</code></a></li> <li><a href="#nullliteral"><code>NullLiteral</code></a></li> <li><a href="#numericliteral"><code>NumericLiteral</code></a></li> <li><a href="#objectexpression"><code>ObjectExpression</code></a></li> <li><a href="#objectmethod"><code>ObjectMethod</code></a></li> <li><a href="#objectpattern"><code>ObjectPattern</code></a></li> <li><a href="#objectproperty"><code>ObjectProperty</code></a></li> <li><a href="#optionalcallexpression"><code>OptionalCallExpression</code></a></li> <li><a href="#optionalmemberexpression"><code>OptionalMemberExpression</code></a></li> <li><a href="#parenthesizedexpression"><code>ParenthesizedExpression</code></a></li> <li><a href="#pipelinebarefunction"><code>PipelineBareFunction</code></a></li> <li><a href="#pipelineprimarytopicreference"><code>PipelinePrimaryTopicReference</code></a></li> <li><a href="#pipelinetopicexpression"><code>PipelineTopicExpression</code></a></li> <li><a href="#privatename"><code>PrivateName</code></a></li> <li><a href="#program"><code>Program</code></a></li> <li><a href="#recordexpression"><code>RecordExpression</code></a></li> <li><a href="#regexpliteral"><code>RegExpLiteral</code></a></li> <li><a href="#restelement"><code>RestElement</code></a></li> <li><a href="#returnstatement"><code>ReturnStatement</code></a></li> <li><a href="#sequenceexpression"><code>SequenceExpression</code></a></li> <li><a href="#spreadelement"><code>SpreadElement</code></a></li> <li><a href="#staticblock"><code>StaticBlock</code></a></li> <li><a href="#stringliteral"><code>StringLiteral</code></a></li> <li><a href="#super"><code>Super</code></a></li> <li><a href="#switchcase"><code>SwitchCase</code></a></li> <li><a href="#switchstatement"><code>SwitchStatement</code></a></li> <li><a href="#taggedtemplateexpression"><code>TaggedTemplateExpression</code></a></li> <li><a href="#templateelement"><code>TemplateElement</code></a></li> <li><a href="#templateliteral"><code>TemplateLiteral</code></a></li> <li><a href="#thisexpression"><code>ThisExpression</code></a></li> <li><a href="#throwstatement"><code>ThrowStatement</code></a></li> <li><a href="#trystatement"><code>TryStatement</code></a></li> <li><a href="#tupleexpression"><code>TupleExpression</code></a></li> <li><a href="#unaryexpression"><code>UnaryExpression</code></a></li> <li><a href="#updateexpression"><code>UpdateExpression</code></a></li> <li><a href="#variabledeclaration"><code>VariableDeclaration</code></a></li> <li><a href="#variabledeclarator"><code>VariableDeclarator</code></a></li> <li><a href="#whilestatement"><code>WhileStatement</code></a></li> <li><a href="#withstatement"><code>WithStatement</code></a></li> <li><a href="#yieldexpression"><code>YieldExpression</code></a></li> </ul> <h4>
Statement</h4> <p>A cover of any <a href="https://tc39.es/ecma262/#prod-Statement">Statement</a>s.</p> <pre data-language="javascript">t.isStatement(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#blockstatement"><code>BlockStatement</code></a></li> <li><a href="#breakstatement"><code>BreakStatement</code></a></li> <li><a href="#classdeclaration"><code>ClassDeclaration</code></a></li> <li><a href="#continuestatement"><code>ContinueStatement</code></a></li> <li><a href="#debuggerstatement"><code>DebuggerStatement</code></a></li> <li><a href="#declareclass"><code>DeclareClass</code></a></li> <li><a href="#declareexportalldeclaration"><code>DeclareExportAllDeclaration</code></a></li> <li><a href="#declareexportdeclaration"><code>DeclareExportDeclaration</code></a></li> <li><a href="#declarefunction"><code>DeclareFunction</code></a></li> <li><a href="#declareinterface"><code>DeclareInterface</code></a></li> <li><a href="#declaremodule"><code>DeclareModule</code></a></li> <li><a href="#declaremoduleexports"><code>DeclareModuleExports</code></a></li> <li><a href="#declareopaquetype"><code>DeclareOpaqueType</code></a></li> <li><a href="#declaretypealias"><code>DeclareTypeAlias</code></a></li> <li><a href="#declarevariable"><code>DeclareVariable</code></a></li> <li><a href="#dowhilestatement"><code>DoWhileStatement</code></a></li> <li><a href="#emptystatement"><code>EmptyStatement</code></a></li> <li><a href="#enumdeclaration"><code>EnumDeclaration</code></a></li> <li><a href="#exportalldeclaration"><code>ExportAllDeclaration</code></a></li> <li><a href="#exportdefaultdeclaration"><code>ExportDefaultDeclaration</code></a></li> <li><a href="#exportnameddeclaration"><code>ExportNamedDeclaration</code></a></li> <li><a href="#expressionstatement"><code>ExpressionStatement</code></a></li> <li><a href="#forinstatement"><code>ForInStatement</code></a></li> <li><a href="#forofstatement"><code>ForOfStatement</code></a></li> <li><a href="#forstatement"><code>ForStatement</code></a></li> <li><a href="#functiondeclaration"><code>FunctionDeclaration</code></a></li> <li><a href="#ifstatement"><code>IfStatement</code></a></li> <li><a href="#importdeclaration"><code>ImportDeclaration</code></a></li> <li><a href="#interfacedeclaration"><code>InterfaceDeclaration</code></a></li> <li><a href="#labeledstatement"><code>LabeledStatement</code></a></li> <li><a href="#opaquetype"><code>OpaqueType</code></a></li> <li><a href="#returnstatement"><code>ReturnStatement</code></a></li> <li><a href="#switchstatement"><code>SwitchStatement</code></a></li> <li><a href="#tsdeclarefunction"><code>TSDeclareFunction</code></a></li> <li><a href="#tsenumdeclaration"><code>TSEnumDeclaration</code></a></li> <li><a href="#tsexportassignment"><code>TSExportAssignment</code></a></li> <li><a href="#tsimportequalsdeclaration"><code>TSImportEqualsDeclaration</code></a></li> <li><a href="#tsinterfacedeclaration"><code>TSInterfaceDeclaration</code></a></li> <li><a href="#tsmoduledeclaration"><code>TSModuleDeclaration</code></a></li> <li><a href="#tsnamespaceexportdeclaration"><code>TSNamespaceExportDeclaration</code></a></li> <li><a href="#tstypealiasdeclaration"><code>TSTypeAliasDeclaration</code></a></li> <li><a href="#throwstatement"><code>ThrowStatement</code></a></li> <li><a href="#trystatement"><code>TryStatement</code></a></li> <li><a href="#typealias"><code>TypeAlias</code></a></li> <li><a href="#variabledeclaration"><code>VariableDeclaration</code></a></li> <li><a href="#whilestatement"><code>WhileStatement</code></a></li> <li><a href="#withstatement"><code>WithStatement</code></a></li> </ul> <h4>
TSBaseType</h4> <p>A cover of primary TypeScript type annotations.</p> <pre data-language="javascript">t.isTSBaseType(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#tsanykeyword"><code>TSAnyKeyword</code></a></li> <li><a href="#tsbigintkeyword"><code>TSBigIntKeyword</code></a></li> <li><a href="#tsbooleankeyword"><code>TSBooleanKeyword</code></a></li> <li><a href="#tsintrinsickeyword"><code>TSIntrinsicKeyword</code></a></li> <li><a href="#tsliteraltype"><code>TSLiteralType</code></a></li> <li><a href="#tsneverkeyword"><code>TSNeverKeyword</code></a></li> <li><a href="#tsnullkeyword"><code>TSNullKeyword</code></a></li> <li><a href="#tsnumberkeyword"><code>TSNumberKeyword</code></a></li> <li><a href="#tsobjectkeyword"><code>TSObjectKeyword</code></a></li> <li><a href="#tsstringkeyword"><code>TSStringKeyword</code></a></li> <li><a href="#tssymbolkeyword"><code>TSSymbolKeyword</code></a></li> <li><a href="#tsthistype"><code>TSThisType</code></a></li> <li><a href="#tsundefinedkeyword"><code>TSUndefinedKeyword</code></a></li> <li><a href="#tsunknownkeyword"><code>TSUnknownKeyword</code></a></li> <li><a href="#tsvoidkeyword"><code>TSVoidKeyword</code></a></li> </ul> <h4>
TSEntityName</h4> <p>A cover of ts entities.</p> <pre data-language="javascript">t.isTSEntityName(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#identifier"><code>Identifier</code></a></li> <li><a href="#tsqualifiedname"><code>TSQualifiedName</code></a></li> </ul> <h4>
TSType</h4> <p>A cover of TypeScript type annotations.</p> <pre data-language="javascript">t.isTSType(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#tsanykeyword"><code>TSAnyKeyword</code></a></li> <li><a href="#tsarraytype"><code>TSArrayType</code></a></li> <li><a href="#tsbigintkeyword"><code>TSBigIntKeyword</code></a></li> <li><a href="#tsbooleankeyword"><code>TSBooleanKeyword</code></a></li> <li><a href="#tsconditionaltype"><code>TSConditionalType</code></a></li> <li><a href="#tsconstructortype"><code>TSConstructorType</code></a></li> <li><a href="#tsexpressionwithtypearguments"><code>TSExpressionWithTypeArguments</code></a></li> <li><a href="#tsfunctiontype"><code>TSFunctionType</code></a></li> <li><a href="#tsimporttype"><code>TSImportType</code></a></li> <li><a href="#tsindexedaccesstype"><code>TSIndexedAccessType</code></a></li> <li><a href="#tsinfertype"><code>TSInferType</code></a></li> <li><a href="#tsintersectiontype"><code>TSIntersectionType</code></a></li> <li><a href="#tsintrinsickeyword"><code>TSIntrinsicKeyword</code></a></li> <li><a href="#tsliteraltype"><code>TSLiteralType</code></a></li> <li><a href="#tsmappedtype"><code>TSMappedType</code></a></li> <li><a href="#tsneverkeyword"><code>TSNeverKeyword</code></a></li> <li><a href="#tsnullkeyword"><code>TSNullKeyword</code></a></li> <li><a href="#tsnumberkeyword"><code>TSNumberKeyword</code></a></li> <li><a href="#tsobjectkeyword"><code>TSObjectKeyword</code></a></li> <li><a href="#tsoptionaltype"><code>TSOptionalType</code></a></li> <li><a href="#tsparenthesizedtype"><code>TSParenthesizedType</code></a></li> <li><a href="#tsresttype"><code>TSRestType</code></a></li> <li><a href="#tsstringkeyword"><code>TSStringKeyword</code></a></li> <li><a href="#tssymbolkeyword"><code>TSSymbolKeyword</code></a></li> <li><a href="#tsthistype"><code>TSThisType</code></a></li> <li><a href="#tstupletype"><code>TSTupleType</code></a></li> <li><a href="#tstypeliteral"><code>TSTypeLiteral</code></a></li> <li><a href="#tstypeoperator"><code>TSTypeOperator</code></a></li> <li><a href="#tstypepredicate"><code>TSTypePredicate</code></a></li> <li><a href="#tstypequery"><code>TSTypeQuery</code></a></li> <li><a href="#tstypereference"><code>TSTypeReference</code></a></li> <li><a href="#tsundefinedkeyword"><code>TSUndefinedKeyword</code></a></li> <li><a href="#tsuniontype"><code>TSUnionType</code></a></li> <li><a href="#tsunknownkeyword"><code>TSUnknownKeyword</code></a></li> <li><a href="#tsvoidkeyword"><code>TSVoidKeyword</code></a></li> </ul> <h4>
TSTypeElement</h4> <p>A cover of TypeScript type declarations.</p> <pre data-language="javascript">t.isTSTypeElement(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#tscallsignaturedeclaration"><code>TSCallSignatureDeclaration</code></a></li> <li><a href="#tsconstructsignaturedeclaration"><code>TSConstructSignatureDeclaration</code></a></li> <li><a href="#tsindexsignature"><code>TSIndexSignature</code></a></li> <li><a href="#tsmethodsignature"><code>TSMethodSignature</code></a></li> <li><a href="#tspropertysignature"><code>TSPropertySignature</code></a></li> </ul> <h4>
Terminatorless</h4> <p>A cover of AST nodes whose semantic will change when a line terminator is inserted between the operator and the operand.</p> <pre data-language="javascript">t.isTerminatorless(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#awaitexpression"><code>AwaitExpression</code></a></li> <li><a href="#breakstatement"><code>BreakStatement</code></a></li> <li><a href="#continuestatement"><code>ContinueStatement</code></a></li> <li><a href="#returnstatement"><code>ReturnStatement</code></a></li> <li><a href="#throwstatement"><code>ThrowStatement</code></a></li> <li><a href="#yieldexpression"><code>YieldExpression</code></a></li> </ul> <h4>
TypeScript</h4> <p>A cover of AST nodes defined for TypeScript.</p> <pre data-language="javascript">t.isTypeScript(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#tsanykeyword"><code>TSAnyKeyword</code></a></li> <li><a href="#tsarraytype"><code>TSArrayType</code></a></li> <li><a href="#tsasexpression"><code>TSAsExpression</code></a></li> <li><a href="#tsbigintkeyword"><code>TSBigIntKeyword</code></a></li> <li><a href="#tsbooleankeyword"><code>TSBooleanKeyword</code></a></li> <li><a href="#tscallsignaturedeclaration"><code>TSCallSignatureDeclaration</code></a></li> <li><a href="#tsconditionaltype"><code>TSConditionalType</code></a></li> <li><a href="#tsconstructsignaturedeclaration"><code>TSConstructSignatureDeclaration</code></a></li> <li><a href="#tsconstructortype"><code>TSConstructorType</code></a></li> <li><a href="#tsdeclarefunction"><code>TSDeclareFunction</code></a></li> <li><a href="#tsdeclaremethod"><code>TSDeclareMethod</code></a></li> <li><a href="#tsenumdeclaration"><code>TSEnumDeclaration</code></a></li> <li><a href="#tsenummember"><code>TSEnumMember</code></a></li> <li><a href="#tsexportassignment"><code>TSExportAssignment</code></a></li> <li><a href="#tsexpressionwithtypearguments"><code>TSExpressionWithTypeArguments</code></a></li> <li><a href="#tsexternalmodulereference"><code>TSExternalModuleReference</code></a></li> <li><a href="#tsfunctiontype"><code>TSFunctionType</code></a></li> <li><a href="#tsimportequalsdeclaration"><code>TSImportEqualsDeclaration</code></a></li> <li><a href="#tsimporttype"><code>TSImportType</code></a></li> <li><a href="#tsindexsignature"><code>TSIndexSignature</code></a></li> <li><a href="#tsindexedaccesstype"><code>TSIndexedAccessType</code></a></li> <li><a href="#tsinfertype"><code>TSInferType</code></a></li> <li><a href="#tsinterfacebody"><code>TSInterfaceBody</code></a></li> <li><a href="#tsinterfacedeclaration"><code>TSInterfaceDeclaration</code></a></li> <li><a href="#tsintersectiontype"><code>TSIntersectionType</code></a></li> <li><a href="#tsintrinsickeyword"><code>TSIntrinsicKeyword</code></a></li> <li><a href="#tsliteraltype"><code>TSLiteralType</code></a></li> <li><a href="#tsmappedtype"><code>TSMappedType</code></a></li> <li><a href="#tsmethodsignature"><code>TSMethodSignature</code></a></li> <li><a href="#tsmoduleblock"><code>TSModuleBlock</code></a></li> <li><a href="#tsmoduledeclaration"><code>TSModuleDeclaration</code></a></li> <li><a href="#tsnamedtuplemember"><code>TSNamedTupleMember</code></a></li> <li><a href="#tsnamespaceexportdeclaration"><code>TSNamespaceExportDeclaration</code></a></li> <li><a href="#tsneverkeyword"><code>TSNeverKeyword</code></a></li> <li><a href="#tsnonnullexpression"><code>TSNonNullExpression</code></a></li> <li><a href="#tsnullkeyword"><code>TSNullKeyword</code></a></li> <li><a href="#tsnumberkeyword"><code>TSNumberKeyword</code></a></li> <li><a href="#tsobjectkeyword"><code>TSObjectKeyword</code></a></li> <li><a href="#tsoptionaltype"><code>TSOptionalType</code></a></li> <li><a href="#tsparameterproperty"><code>TSParameterProperty</code></a></li> <li><a href="#tsparenthesizedtype"><code>TSParenthesizedType</code></a></li> <li><a href="#tspropertysignature"><code>TSPropertySignature</code></a></li> <li><a href="#tsqualifiedname"><code>TSQualifiedName</code></a></li> <li><a href="#tsresttype"><code>TSRestType</code></a></li> <li><a href="#tsstringkeyword"><code>TSStringKeyword</code></a></li> <li><a href="#tssymbolkeyword"><code>TSSymbolKeyword</code></a></li> <li><a href="#tsthistype"><code>TSThisType</code></a></li> <li><a href="#tstupletype"><code>TSTupleType</code></a></li> <li><a href="#tstypealiasdeclaration"><code>TSTypeAliasDeclaration</code></a></li> <li><a href="#tstypeannotation"><code>TSTypeAnnotation</code></a></li> <li><a href="#tstypeassertion"><code>TSTypeAssertion</code></a></li> <li><a href="#tstypeliteral"><code>TSTypeLiteral</code></a></li> <li><a href="#tstypeoperator"><code>TSTypeOperator</code></a></li> <li><a href="#tstypeparameter"><code>TSTypeParameter</code></a></li> <li><a href="#tstypeparameterdeclaration"><code>TSTypeParameterDeclaration</code></a></li> <li><a href="#tstypeparameterinstantiation"><code>TSTypeParameterInstantiation</code></a></li> <li><a href="#tstypepredicate"><code>TSTypePredicate</code></a></li> <li><a href="#tstypequery"><code>TSTypeQuery</code></a></li> <li><a href="#tstypereference"><code>TSTypeReference</code></a></li> <li><a href="#tsundefinedkeyword"><code>TSUndefinedKeyword</code></a></li> <li><a href="#tsuniontype"><code>TSUnionType</code></a></li> <li><a href="#tsunknownkeyword"><code>TSUnknownKeyword</code></a></li> <li><a href="#tsvoidkeyword"><code>TSVoidKeyword</code></a></li> </ul> <h4>
UnaryLike</h4> <p>A cover of UnaryExpression and SpreadElement.</p> <pre data-language="javascript">t.isUnaryLike(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#spreadelement"><code>SpreadElement</code></a></li> <li><a href="#unaryexpression"><code>UnaryExpression</code></a></li> </ul> <h4>
UserWhitespacable</h4> <p>Deprecated. Will be removed in Babel 8.</p> <pre data-language="javascript">t.isUserWhitespacable(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#objectmethod"><code>ObjectMethod</code></a></li> <li><a href="#objectproperty"><code>ObjectProperty</code></a></li> <li><a href="#objecttypecallproperty"><code>ObjectTypeCallProperty</code></a></li> <li><a href="#objecttypeindexer"><code>ObjectTypeIndexer</code></a></li> <li><a href="#objecttypeinternalslot"><code>ObjectTypeInternalSlot</code></a></li> <li><a href="#objecttypeproperty"><code>ObjectTypeProperty</code></a></li> <li><a href="#objecttypespreadproperty"><code>ObjectTypeSpreadProperty</code></a></li> </ul> <h4>
While</h4> <p>A cover of DoWhileStatement and WhileStatement, which share the same AST shape.</p> <pre data-language="javascript">t.isWhile(node);
</pre> <p>Covered nodes:</p> <ul> <li><a href="#dowhilestatement"><code>DoWhileStatement</code></a></li> <li><a href="#whilestatement"><code>WhileStatement</code></a></li> </ul> </span></div></article>
</div></div></div>

</div></div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://babeljs.io/docs/en/babel-types/" class="_attribution-link" target="_blank">https://babeljs.io/docs/en/babel-types/</a>
  </p>
</div>
