<h1 id="module-ActiveRecord::AttributeMethods::Serialization::ClassMethods" class="module"> module ActiveRecord::AttributeMethods::Serialization::ClassMethods </h1>  <section id="5Buntitled-5D" class="documentation-section"> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-serialize"> <span class="method-name">serialize</span><span class="method-args">(attr_name, class_name_or_coder = Object, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="serialize-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/attribute_methods/serialization.rb, line 66
def serialize(attr_name, class_name_or_coder = Object, **options)
  # When ::JSON is used, force it to go through the Active Support JSON encoder
  # to ensure special objects (e.g. Active Record models) are dumped correctly
  # using the #as_json hook.
  coder = if class_name_or_coder == ::JSON
    Coders::JSON
  elsif [:load, :dump].all? { |x| class_name_or_coder.respond_to?(x) }
    class_name_or_coder
  else
    Coders::YAMLColumn.new(attr_name, class_name_or_coder)
  end

  decorate_attribute_type(attr_name.to_s, **options) do |cast_type|
    if type_incompatible_with_serialize?(cast_type, class_name_or_coder)
      raise ColumnNotSerializableError.new(attr_name, cast_type)
    end

    Type::Serialized.new(cast_type, coder)
  end
end</pre> </div> <p>If you have an attribute that needs to be saved to the database as an object, and retrieved as the same object, then specify the name of that attribute using this method and it will be handled automatically. The serialization is done through YAML. If <code>class_name</code> is specified, the serialized object must be of that class on assignment and retrieval. Otherwise <a href="../../serializationtypemismatch"><code>SerializationTypeMismatch</code></a> will be raised.</p> <p>Empty objects as <code>{}</code>, in the case of <code>Hash</code>, or <code>[]</code>, in the case of <code>Array</code>, will always be persisted as null.</p> <p>Keep in mind that database adapters handle certain serialization tasks for you. For instance: <code>json</code> and <code>jsonb</code> types in PostgreSQL will be converted between JSON object/array syntax and Ruby <code>Hash</code> or <code>Array</code> objects transparently. There is no need to use <a href="classmethods#method-i-serialize"><code>serialize</code></a> in this case.</p> <p>For more complex cases, such as conversion to or from your application domain objects, consider using the <a href="../../attributes"><code>ActiveRecord::Attributes</code></a> API.</p> <h4 id="method-i-serialize-label-Parameters">Parameters</h4> <ul>
<li> <p><code>attr_name</code> - The field name that should be serialized.</p> </li>
<li> <p><code>class_name_or_coder</code> - Optional, a coder object, which responds to <code>.load</code> and <code>.dump</code> or a class name that the object type should be equal to.</p> </li>
</ul> <h4 id="method-i-serialize-label-Options">Options</h4> <p><code>default</code> The default value to use when no value is provided. If this option is not passed, the previous default value (if any) will be used. Otherwise, the default will be <code>nil</code>.</p> <h4 id="method-i-serialize-label-Example">Example</h4> <pre class="ruby" data-language="ruby"># Serialize a preferences attribute.
class User &lt; ActiveRecord::Base
  serialize :preferences
end

# Serialize preferences using JSON as coder.
class User &lt; ActiveRecord::Base
  serialize :preferences, JSON
end

# Serialize preferences as Hash using YAML coder.
class User &lt; ActiveRecord::Base
  serialize :preferences, Hash
end
</pre>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2004&ndash;2020 David Heinemeier Hansson<br>Licensed under the MIT License.<br>
    
  </p>
</div>
