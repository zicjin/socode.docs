<h1>Active Record Validations</h1>
<div class="_simple"> <p>This guide teaches you how to validate the state of objects before they go into the database using Active Record's validations feature.</p>
<p>After reading this guide, you will know:</p> <ul> <li>How to use the built-in Active Record validation helpers.</li> <li>How to create your own custom validation methods.</li> <li>How to work with the error messages generated by the validation process.</li> </ul>  <h2 class="chapter">Chapters</h2> <ol class="chapters"> <li> <a href="#validations-overview">Validations Overview</a> <ul> <li><a href="#why-use-validations-questionmark">Why Use Validations?</a></li> <li><a href="#when-does-validation-happen-questionmark">When Does Validation Happen?</a></li> <li><a href="#skipping-validations">Skipping Validations</a></li> <li><a href="#valid-questionmark-and-invalid-questionmark"><code>valid?</code> and <code>invalid?</code></a></li> <li><a href="#validations-overview-errors"><code>errors[]</code></a></li> </ul> </li> <li> <a href="#validation-helpers">Validation Helpers</a> <ul> <li><a href="#acceptance"><code>acceptance</code></a></li> <li><a href="#validates-associated"><code>validates_associated</code></a></li> <li><a href="#confirmation"><code>confirmation</code></a></li> <li><a href="#exclusion"><code>exclusion</code></a></li> <li><a href="#format"><code>format</code></a></li> <li><a href="#inclusion"><code>inclusion</code></a></li> <li><a href="#length"><code>length</code></a></li> <li><a href="#numericality"><code>numericality</code></a></li> <li><a href="#presence"><code>presence</code></a></li> <li><a href="#absence"><code>absence</code></a></li> <li><a href="#uniqueness"><code>uniqueness</code></a></li> <li><a href="#validates-with"><code>validates_with</code></a></li> <li><a href="#validates-each"><code>validates_each</code></a></li> </ul> </li> <li> <a href="#common-validation-options">Common Validation Options</a> <ul> <li><a href="#allow-nil"><code>:allow_nil</code></a></li> <li><a href="#allow-blank"><code>:allow_blank</code></a></li> <li><a href="#message"><code>:message</code></a></li> <li><a href="#on"><code>:on</code></a></li> </ul> </li> <li><a href="#strict-validations">Strict Validations</a></li> <li> <a href="#conditional-validation">Conditional Validation</a> <ul> <li><a href="#using-a-symbol-with-if-and-unless">Using a Symbol with <code>:if</code> and <code>:unless</code></a></li> <li><a href="#using-a-proc-with-if-and-unless">Using a Proc with <code>:if</code> and <code>:unless</code></a></li> <li><a href="#grouping-conditional-validations">Grouping Conditional validations</a></li> <li><a href="#combining-validation-conditions">Combining Validation Conditions</a></li> </ul> </li> <li> <a href="#performing-custom-validations">Performing Custom Validations</a> <ul> <li><a href="#custom-validators">Custom Validators</a></li> <li><a href="#custom-methods">Custom Methods</a></li> </ul> </li> <li> <a href="#working-with-validation-errors">Working with Validation Errors</a> <ul> <li><a href="#working-with-validation-errors-errors"><code>errors</code></a></li> <li><a href="#errors"><code>errors[]</code></a></li> <li><a href="#errors-where-and-error-object"><code>errors.where</code> and error object</a></li> <li><a href="#errors-add"><code>errors.add</code></a></li> <li><a href="#errors-base"><code>errors[:base]</code></a></li> <li><a href="#errors-clear"><code>errors.clear</code></a></li> <li><a href="#errors-size"><code>errors.size</code></a></li> </ul> </li> <li><a href="#displaying-validation-errors-in-views">Displaying Validation Errors in Views</a></li> </ol>   <h2 id="validations-overview"><a class="anchorlink" href="#validations-overview">1 Validations Overview</a></h2>
<p>Here's an example of a very simple validation:</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :name, presence: true
end</pre> <textarea class="clipboard-content" id="clipboard-2793b691c2e95462de5f293d046880b7">class Person &lt; ApplicationRecord validates :name, presence: true end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-2793b691c2e95462de5f293d046880b7">Copy</button>   <pre data-language="irb">irb&gt; Person.create(name: "John Doe").valid?
=&gt; true
irb&gt; Person.create(name: nil).valid?
=&gt; false</pre> <textarea class="clipboard-content" id="clipboard-2798d2d870eaa228cc11e26ca42a35d6">Person.create(name: "John Doe").valid? Person.create(name: nil).valid? </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-2798d2d870eaa228cc11e26ca42a35d6">Copy</button>  <p>As you can see, our validation lets us know that our <code>Person</code> is not valid without a <code>name</code> attribute. The second <code>Person</code> will not be persisted to the database.</p>
<p>Before we dig into more details, let's talk about how validations fit into the big picture of your application.</p>
<h3 id="why-use-validations-questionmark"><a class="anchorlink" href="#why-use-validations-questionmark">1.1 Why Use Validations?</a></h3>
<p>Validations are used to ensure that only valid data is saved into your database. For example, it may be important to your application to ensure that every user provides a valid email address and mailing address. Model-level validations are the best way to ensure that only valid data is saved into your database. They are database agnostic, cannot be bypassed by end users, and are convenient to test and maintain. Rails provides built-in helpers for common needs, and allows you to create your own validation methods as well.</p>
<p>There are several other ways to validate data before it is saved into your database, including native database constraints, client-side validations and controller-level validations. Here's a summary of the pros and cons:</p> <ul> <li>Database constraints and/or stored procedures make the validation mechanisms database-dependent and can make testing and maintenance more difficult. However, if your database is used by other applications, it may be a good idea to use some constraints at the database level. Additionally, database-level validations can safely handle some things (such as uniqueness in heavily-used tables) that can be difficult to implement otherwise.</li> <li>Client-side validations can be useful, but are generally unreliable if used alone. If they are implemented using JavaScript, they may be bypassed if JavaScript is turned off in the user's browser. However, if combined with other techniques, client-side validation can be a convenient way to provide users with immediate feedback as they use your site.</li> <li>Controller-level validations can be tempting to use, but often become unwieldy and difficult to test and maintain. Whenever possible, it's a good idea to keep your controllers skinny, as it will make your application a pleasure to work with in the long run.</li> </ul> <p>Choose these in certain, specific cases. It's the opinion of the Rails team that model-level validations are the most appropriate in most circumstances.</p>
<h3 id="when-does-validation-happen-questionmark"><a class="anchorlink" href="#when-does-validation-happen-questionmark">1.2 When Does Validation Happen?</a></h3>
<p>There are two kinds of Active Record objects: those that correspond to a row inside your database and those that do not. When you create a fresh object, for example using the <code>new</code> method, that object does not belong to the database yet. Once you call <code>save</code> upon that object it will be saved into the appropriate database table. Active Record uses the <code>new_record?</code> instance method to determine whether an object is already in the database or not. Consider the following Active Record class:</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
end</pre> <textarea class="clipboard-content" id="clipboard-843682fdfc97d8f7373bc9e56c10ff49">class Person &lt; ApplicationRecord end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-843682fdfc97d8f7373bc9e56c10ff49">Copy</button>  <p>We can see how it works by looking at some <code>bin/rails console</code> output:</p> <pre data-language="irb">irb&gt; p = Person.new(name: "John Doe")
=&gt; #&lt;Person id: nil, name: "John Doe", created_at: nil, updated_at: nil&gt;

irb&gt; p.new_record?
=&gt; true

irb&gt; p.save
=&gt; true

irb&gt; p.new_record?
=&gt; false</pre> <textarea class="clipboard-content" id="clipboard-c6ad822a1335c47f1f7760b1a6e0b67a">p = Person.new(name: "John Doe") p.new_record? p.save p.new_record? </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-c6ad822a1335c47f1f7760b1a6e0b67a">Copy</button>  <p>Creating and saving a new record will send an SQL <code>INSERT</code> operation to the database. Updating an existing record will send an SQL <code>UPDATE</code> operation instead. Validations are typically run before these commands are sent to the database. If any validations fail, the object will be marked as invalid and Active Record will not perform the <code>INSERT</code> or <code>UPDATE</code> operation. This avoids storing an invalid object in the database. You can choose to have specific validations run when an object is created, saved, or updated.</p>
<div class="warning"><p>There are many ways to change the state of an object in the database. Some methods will trigger validations, but some will not. This means that it's possible to save an object in the database in an invalid state if you aren't careful.</p></div>
<p>The following methods trigger validations, and will save the object to the database only if the object is valid:</p> <ul> <li><code>create</code></li> <li><code>create!</code></li> <li><code>save</code></li> <li><code>save!</code></li> <li><code>update</code></li> <li><code>update!</code></li> </ul> <p>The bang versions (e.g. <code>save!</code>) raise an exception if the record is invalid. The non-bang versions don't: <code>save</code> and <code>update</code> return <code>false</code>, and <code>create</code> returns the object.</p>
<h3 id="skipping-validations"><a class="anchorlink" href="#skipping-validations">1.3 Skipping Validations</a></h3>
<p>The following methods skip validations, and will save the object to the database regardless of its validity. They should be used with caution.</p> <ul> <li><code>decrement!</code></li> <li><code>decrement_counter</code></li> <li><code>increment!</code></li> <li><code>increment_counter</code></li> <li><code>insert</code></li> <li><code>insert!</code></li> <li><code>insert_all</code></li> <li><code>insert_all!</code></li> <li><code>toggle!</code></li> <li><code>touch</code></li> <li><code>touch_all</code></li> <li><code>update_all</code></li> <li><code>update_attribute</code></li> <li><code>update_column</code></li> <li><code>update_columns</code></li> <li><code>update_counters</code></li> <li><code>upsert</code></li> <li><code>upsert_all</code></li> </ul> <p>Note that <code>save</code> also has the ability to skip validations if passed <code>validate:
false</code> as an argument. This technique should be used with caution.</p> <ul> <li><code>save(validate: false)</code></li> </ul> <h3 id="valid-questionmark-and-invalid-questionmark"><a class="anchorlink" href="#valid-questionmark-and-invalid-questionmark">1.4 <code>valid?</code> and <code>invalid?</code></a></h3>
<p>Before saving an Active Record object, Rails runs your validations. If these validations produce any errors, Rails does not save the object.</p>
<p>You can also run these validations on your own. <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Validations.html#method-i-valid-3F"><code>valid?</code></a> triggers your validations and returns true if no errors were found in the object, and false otherwise. As you saw above:</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :name, presence: true
end</pre> <textarea class="clipboard-content" id="clipboard-a630c25fd794a4eba29f36397aa75095">class Person &lt; ApplicationRecord validates :name, presence: true end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-a630c25fd794a4eba29f36397aa75095">Copy</button>   <pre data-language="irb">irb&gt; Person.create(name: "John Doe").valid?
=&gt; true
irb&gt; Person.create(name: nil).valid?
=&gt; false</pre> <textarea class="clipboard-content" id="clipboard-5cd00bd8078d66bb53155ffbc424ac95">Person.create(name: "John Doe").valid? Person.create(name: nil).valid? </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-5cd00bd8078d66bb53155ffbc424ac95">Copy</button>  <p>After Active Record has performed validations, any errors found can be accessed through the <a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Validations.html#method-i-errors"><code>errors</code></a> instance method, which returns a collection of errors. By definition, an object is valid if this collection is empty after running validations.</p>
<p>Note that an object instantiated with <code>new</code> will not report errors even if it's technically invalid, because validations are automatically run only when the object is saved, such as with the <code>create</code> or <code>save</code> methods.</p> <pre data-language="plaintext">class Person &lt; ApplicationRecord
  validates :name, presence: true
end</pre> <textarea class="clipboard-content" id="clipboard-0d4cf10e7eb3af26634ad2e31f8df38a">class Person &lt; ApplicationRecord validates :name, presence: true end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-0d4cf10e7eb3af26634ad2e31f8df38a">Copy</button>   <pre data-language="irb">irb&gt; p = Person.new
=&gt; #&lt;Person id: nil, name: nil&gt;
irb&gt; p.errors.size
=&gt; 0

irb&gt; p.valid?
=&gt; false
irb&gt; p.errors.objects.first.full_message
=&gt; "Name can't be blank"

irb&gt; p = Person.create
=&gt; #&lt;Person id: nil, name: nil&gt;
irb&gt; p.errors.objects.first.full_message
=&gt; "Name can't be blank"

irb&gt; p.save
=&gt; false

irb&gt; p.save!
ActiveRecord::RecordInvalid: Validation failed: Name can't be blank

irb&gt; Person.create!
ActiveRecord::RecordInvalid: Validation failed: Name can't be blank</pre> <textarea class="clipboard-content" id="clipboard-4487c746dd378aa78506224e4be52231">p = Person.new p.errors.size p.valid? p.errors.objects.first.full_message p = Person.create p.errors.objects.first.full_message p.save p.save! Person.create! </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-4487c746dd378aa78506224e4be52231">Copy</button>  <p><a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Validations.html#method-i-invalid-3F"><code>invalid?</code></a> is the inverse of <code>valid?</code>. It triggers your validations, returning true if any errors were found in the object, and false otherwise.</p>
<h3 id="validations-overview-errors"><a class="anchorlink" href="#validations-overview-errors">1.5 <code>errors[]</code></a></h3>
<p>To verify whether or not a particular attribute of an object is valid, you can use <a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Errors.html#method-i-5B-5D"><code>errors[:attribute]</code></a>. It returns an array of all the error messages for <code>:attribute</code>. If there are no errors on the specified attribute, an empty array is returned.</p>
<p>This method is only useful <em>after</em> validations have been run, because it only inspects the errors collection and does not trigger validations itself. It's different from the <code>ActiveRecord::Base#invalid?</code> method explained above because it doesn't verify the validity of the object as a whole. It only checks to see whether there are errors found on an individual attribute of the object.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :name, presence: true
end</pre> <textarea class="clipboard-content" id="clipboard-a42ef208485534c7eb88c4e2c59b5caa">class Person &lt; ApplicationRecord validates :name, presence: true end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-a42ef208485534c7eb88c4e2c59b5caa">Copy</button>   <pre data-language="irb">irb&gt; Person.new.errors[:name].any?
=&gt; false
irb&gt; Person.create.errors[:name].any?
=&gt; true</pre> <textarea class="clipboard-content" id="clipboard-7b26c876a953ddac2a6f0008fc4b2d9c">Person.new.errors[:name].any? Person.create.errors[:name].any? </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-7b26c876a953ddac2a6f0008fc4b2d9c">Copy</button>  <p>We'll cover validation errors in greater depth in the <a href="#working-with-validation-errors">Working with Validation Errors</a> section.</p>
<h2 id="validation-helpers"><a class="anchorlink" href="#validation-helpers">2 Validation Helpers</a></h2>
<p>Active Record offers many pre-defined validation helpers that you can use directly inside your class definitions. These helpers provide common validation rules. Every time a validation fails, an error is added to the object's <code>errors</code> collection, and this is associated with the attribute being validated.</p>
<p>Each helper accepts an arbitrary number of attribute names, so with a single line of code you can add the same kind of validation to several attributes.</p>
<p>All of them accept the <code>:on</code> and <code>:message</code> options, which define when the validation should be run and what message should be added to the <code>errors</code> collection if it fails, respectively. The <code>:on</code> option takes one of the values <code>:create</code> or <code>:update</code>. There is a default error message for each one of the validation helpers. These messages are used when the <code>:message</code> option isn't specified. Let's take a look at each one of the available helpers.</p>
<h3 id="acceptance"><a class="anchorlink" href="#acceptance">2.1 <code>acceptance</code></a></h3>
<p>This method validates that a checkbox on the user interface was checked when a form was submitted. This is typically used when the user needs to agree to your application's terms of service, confirm that some text is read, or any similar concept.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :terms_of_service, acceptance: true
end</pre> <textarea class="clipboard-content" id="clipboard-0c2cfd1cc5c7f7ece737baeb77dd9e86">class Person &lt; ApplicationRecord validates :terms_of_service, acceptance: true end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-0c2cfd1cc5c7f7ece737baeb77dd9e86">Copy</button>  <p>This check is performed only if <code>terms_of_service</code> is not <code>nil</code>. The default error message for this helper is <em>"must be accepted"</em>. You can also pass in a custom message via the <code>message</code> option.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :terms_of_service, acceptance: { message: 'must be abided' }
end</pre> <textarea class="clipboard-content" id="clipboard-d13e7bce096864ae7765e4b8ca3cb6d0">class Person &lt; ApplicationRecord validates :terms_of_service, acceptance: { message: 'must be abided' } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-d13e7bce096864ae7765e4b8ca3cb6d0">Copy</button>  <p>It can also receive an <code>:accept</code> option, which determines the allowed values that will be considered as accepted. It defaults to <code>['1', true]</code> and can be easily changed.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :terms_of_service, acceptance: { accept: 'yes' }
  validates :eula, acceptance: { accept: ['TRUE', 'accepted'] }
end</pre> <textarea class="clipboard-content" id="clipboard-9ad129c725f337c4c25429ea1f1f6887">class Person &lt; ApplicationRecord validates :terms_of_service, acceptance: { accept: 'yes' } validates :eula, acceptance: { accept: ['TRUE', 'accepted'] } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-9ad129c725f337c4c25429ea1f1f6887">Copy</button>  <p>This validation is very specific to web applications and this 'acceptance' does not need to be recorded anywhere in your database. If you don't have a field for it, the helper will create a virtual attribute. If the field does exist in your database, the <code>accept</code> option must be set to or include <code>true</code> or else the validation will not run.</p>
<h3 id="validates-associated"><a class="anchorlink" href="#validates-associated">2.2 <code>validates_associated</code></a></h3>
<p>You should use this helper when your model has associations with other models and they also need to be validated. When you try to save your object, <code>valid?</code> will be called upon each one of the associated objects.</p> <pre data-language="ruby">class Library &lt; ApplicationRecord
  has_many :books
  validates_associated :books
end</pre> <textarea class="clipboard-content" id="clipboard-7b55cde92d9d0e2c4404f79fb8611c71">class Library &lt; ApplicationRecord has_many :books validates_associated :books end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-7b55cde92d9d0e2c4404f79fb8611c71">Copy</button>  <p>This validation will work with all of the association types.</p>
<div class="warning"><p>Don't use <code>validates_associated</code> on both ends of your associations. They would call each other in an infinite loop.</p></div>
<p>The default error message for <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Validations/ClassMethods.html#method-i-validates_associated"><code>validates_associated</code></a> is <em>"is invalid"</em>. Note that each associated object will contain its own <code>errors</code> collection; errors do not bubble up to the calling model.</p>
<h3 id="confirmation"><a class="anchorlink" href="#confirmation">2.3 <code>confirmation</code></a></h3>
<p>You should use this helper when you have two text fields that should receive exactly the same content. For example, you may want to confirm an email address or a password. This validation creates a virtual attribute whose name is the name of the field that has to be confirmed with "_confirmation" appended.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :email, confirmation: true
end</pre> <textarea class="clipboard-content" id="clipboard-4081e83386519502828d83f0800de734">class Person &lt; ApplicationRecord validates :email, confirmation: true end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-4081e83386519502828d83f0800de734">Copy</button>  <p>In your view template you could use something like</p> <pre data-language="erb">&lt;%= text_field :person, :email %&gt;
&lt;%= text_field :person, :email_confirmation %&gt;</pre> <textarea class="clipboard-content" id="clipboard-99076a06e7e05144723cff51d9df0f5f">&lt;%= text_field :person, :email %&gt; &lt;%= text_field :person, :email_confirmation %&gt; </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-99076a06e7e05144723cff51d9df0f5f">Copy</button>  <p>This check is performed only if <code>email_confirmation</code> is not <code>nil</code>. To require confirmation, make sure to add a presence check for the confirmation attribute (we'll take a look at <code>presence</code> later on in this guide):</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :email, confirmation: true
  validates :email_confirmation, presence: true
end</pre> <textarea class="clipboard-content" id="clipboard-5127aac600083343e26b25302935f8e3">class Person &lt; ApplicationRecord validates :email, confirmation: true validates :email_confirmation, presence: true end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-5127aac600083343e26b25302935f8e3">Copy</button>  <p>There is also a <code>:case_sensitive</code> option that you can use to define whether the confirmation constraint will be case sensitive or not. This option defaults to true.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :email, confirmation: { case_sensitive: false }
end</pre> <textarea class="clipboard-content" id="clipboard-e60c7314e1f6ddfb4b8aac9b1307cd22">class Person &lt; ApplicationRecord validates :email, confirmation: { case_sensitive: false } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-e60c7314e1f6ddfb4b8aac9b1307cd22">Copy</button>  <p>The default error message for this helper is <em>"doesn't match confirmation"</em>.</p>
<h3 id="exclusion"><a class="anchorlink" href="#exclusion">2.4 <code>exclusion</code></a></h3>
<p>This helper validates that the attributes' values are not included in a given set. In fact, this set can be any enumerable object.</p> <pre data-language="ruby">class Account &lt; ApplicationRecord
  validates :subdomain, exclusion: { in: %w(www us ca jp),
    message: "%{value} is reserved." }
end</pre> <textarea class="clipboard-content" id="clipboard-993213428ff29dedf89bee3176ffb05f">class Account &lt; ApplicationRecord validates :subdomain, exclusion: { in: %w(www us ca jp), message: "%{value} is reserved." } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-993213428ff29dedf89bee3176ffb05f">Copy</button>  <p>The <code>exclusion</code> helper has an option <code>:in</code> that receives the set of values that will not be accepted for the validated attributes. The <code>:in</code> option has an alias called <code>:within</code> that you can use for the same purpose, if you'd like to. This example uses the <code>:message</code> option to show how you can include the attribute's value. For full options to the message argument please see the <a href="#message">message documentation</a>.</p>
<p>The default error message is <em>"is reserved"</em>.</p>
<h3 id="format"><a class="anchorlink" href="#format">2.5 <code>format</code></a></h3>
<p>This helper validates the attributes' values by testing whether they match a given regular expression, which is specified using the <code>:with</code> option.</p> <pre data-language="ruby">class Product &lt; ApplicationRecord
  validates :legacy_code, format: { with: /\A[a-zA-Z]+\z/,
    message: "only allows letters" }
end</pre> <textarea class="clipboard-content" id="clipboard-308d62798d9ba829023451539630f2cd">class Product &lt; ApplicationRecord validates :legacy_code, format: { with: /\A[a-zA-Z]+\z/, message: "only allows letters" } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-308d62798d9ba829023451539630f2cd">Copy</button>  <p>Alternatively, you can require that the specified attribute does <em>not</em> match the regular expression by using the <code>:without</code> option.</p>
<p>The default error message is <em>"is invalid"</em>.</p>
<h3 id="inclusion"><a class="anchorlink" href="#inclusion">2.6 <code>inclusion</code></a></h3>
<p>This helper validates that the attributes' values are included in a given set. In fact, this set can be any enumerable object.</p> <pre data-language="ruby">class Coffee &lt; ApplicationRecord
  validates :size, inclusion: { in: %w(small medium large),
    message: "%{value} is not a valid size" }
end</pre> <textarea class="clipboard-content" id="clipboard-a7f3291940a2502b307e52146752a9ef">class Coffee &lt; ApplicationRecord validates :size, inclusion: { in: %w(small medium large), message: "%{value} is not a valid size" } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-a7f3291940a2502b307e52146752a9ef">Copy</button>  <p>The <code>inclusion</code> helper has an option <code>:in</code> that receives the set of values that will be accepted. The <code>:in</code> option has an alias called <code>:within</code> that you can use for the same purpose, if you'd like to. The previous example uses the <code>:message</code> option to show how you can include the attribute's value. For full options please see the <a href="#message">message documentation</a>.</p>
<p>The default error message for this helper is <em>"is not included in the list"</em>.</p>
<h3 id="length"><a class="anchorlink" href="#length">2.7 <code>length</code></a></h3>
<p>This helper validates the length of the attributes' values. It provides a variety of options, so you can specify length constraints in different ways:</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :name, length: { minimum: 2 }
  validates :bio, length: { maximum: 500 }
  validates :password, length: { in: 6..20 }
  validates :registration_number, length: { is: 6 }
end</pre> <textarea class="clipboard-content" id="clipboard-be699d29755dc88b9e9a8206b03bb0f8">class Person &lt; ApplicationRecord validates :name, length: { minimum: 2 } validates :bio, length: { maximum: 500 } validates :password, length: { in: 6..20 } validates :registration_number, length: { is: 6 } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-be699d29755dc88b9e9a8206b03bb0f8">Copy</button>  <p>The possible length constraint options are:</p> <ul> <li> <code>:minimum</code> - The attribute cannot have less than the specified length.</li> <li> <code>:maximum</code> - The attribute cannot have more than the specified length.</li> <li> <code>:in</code> (or <code>:within</code>) - The attribute length must be included in a given interval. The value for this option must be a range.</li> <li> <code>:is</code> - The attribute length must be equal to the given value.</li> </ul> <p>The default error messages depend on the type of length validation being performed. You can customize these messages using the <code>:wrong_length</code>, <code>:too_long</code>, and <code>:too_short</code> options and <code>%{count}</code> as a placeholder for the number corresponding to the length constraint being used. You can still use the <code>:message</code> option to specify an error message.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :bio, length: { maximum: 1000,
    too_long: "%{count} characters is the maximum allowed" }
end</pre> <textarea class="clipboard-content" id="clipboard-3849ebd891740ae4f459863edb7f6c49">class Person &lt; ApplicationRecord validates :bio, length: { maximum: 1000, too_long: "%{count} characters is the maximum allowed" } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-3849ebd891740ae4f459863edb7f6c49">Copy</button>  <p>Note that the default error messages are plural (e.g., "is too short (minimum is %{count} characters)"). For this reason, when <code>:minimum</code> is 1 you should provide a custom message or use <code>presence: true</code> instead. When <code>:in</code> or <code>:within</code> have a lower limit of 1, you should either provide a custom message or call <code>presence</code> prior to <code>length</code>.</p>
<h3 id="numericality"><a class="anchorlink" href="#numericality">2.8 <code>numericality</code></a></h3>
<p>This helper validates that your attributes have only numeric values. By default, it will match an optional sign followed by an integral or floating point number.</p>
<p>To specify that only integral numbers are allowed, set <code>:only_integer</code> to true. Then it will use the</p> <pre data-language="ruby">/\A[+-]?\d+\z/</pre> <textarea class="clipboard-content" id="clipboard-b5b73fed16d85309617257b254434e60">/\A[+-]?\d+\z/ </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-b5b73fed16d85309617257b254434e60">Copy</button>  <p>regular expression to validate the attribute's value. Otherwise, it will try to convert the value to a number using <code>Float</code>. <code>Float</code>s are casted to <code>BigDecimal</code> using the column's precision value or 15.</p> <pre data-language="ruby">class Player &lt; ApplicationRecord
  validates :points, numericality: true
  validates :games_played, numericality: { only_integer: true }
end</pre> <textarea class="clipboard-content" id="clipboard-ac0eebedfa956b3a2b9c81d8409d9a2a">class Player &lt; ApplicationRecord validates :points, numericality: true validates :games_played, numericality: { only_integer: true } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-ac0eebedfa956b3a2b9c81d8409d9a2a">Copy</button>  <p>The default error message for <code>:only_integer</code> is <em>"must be an integer"</em>.</p>
<p>Besides <code>:only_integer</code>, this helper also accepts the following options to add constraints to acceptable values:</p> <ul> <li> <code>:greater_than</code> - Specifies the value must be greater than the supplied value. The default error message for this option is <em>"must be greater than %{count}"</em>.</li> <li> <code>:greater_than_or_equal_to</code> - Specifies the value must be greater than or equal to the supplied value. The default error message for this option is <em>"must be greater than or equal to %{count}"</em>.</li> <li> <code>:equal_to</code> - Specifies the value must be equal to the supplied value. The default error message for this option is <em>"must be equal to %{count}"</em>.</li> <li> <code>:less_than</code> - Specifies the value must be less than the supplied value. The default error message for this option is <em>"must be less than %{count}"</em>.</li> <li> <code>:less_than_or_equal_to</code> - Specifies the value must be less than or equal to the supplied value. The default error message for this option is <em>"must be less than or equal to %{count}"</em>.</li> <li> <code>:other_than</code> - Specifies the value must be other than the supplied value. The default error message for this option is <em>"must be other than %{count}"</em>.</li> <li> <code>:odd</code> - Specifies the value must be an odd number if set to true. The default error message for this option is <em>"must be odd"</em>.</li> <li> <code>:even</code> - Specifies the value must be an even number if set to true. The default error message for this option is <em>"must be even"</em>.</li> </ul> <div class="note"><p>By default, <code>numericality</code> doesn't allow <code>nil</code> values. You can use <code>allow_nil: true</code> option to permit it.</p></div>
<p>The default error message when no options are specified is <em>"is not a number"</em>.</p>
<h3 id="presence"><a class="anchorlink" href="#presence">2.9 <code>presence</code></a></h3>
<p>This helper validates that the specified attributes are not empty. It uses the <code>blank?</code> method to check if the value is either <code>nil</code> or a blank string, that is, a string that is either empty or consists of whitespace.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :name, :login, :email, presence: true
end</pre> <textarea class="clipboard-content" id="clipboard-8e27e11fe92bc3d5b8eb2df42788b228">class Person &lt; ApplicationRecord validates :name, :login, :email, presence: true end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-8e27e11fe92bc3d5b8eb2df42788b228">Copy</button>  <p>If you want to be sure that an association is present, you'll need to test whether the associated object itself is present, and not the foreign key used to map the association. This way, it is not only checked that the foreign key is not empty but also that the referenced object exists.</p> <pre data-language="ruby">class Supplier &lt; ApplicationRecord
  has_one :account
  validates :account, presence: true
end</pre> <textarea class="clipboard-content" id="clipboard-e3b8a12a839ba2c887f0564fc02481f1">class Supplier &lt; ApplicationRecord has_one :account validates :account, presence: true end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-e3b8a12a839ba2c887f0564fc02481f1">Copy</button>  <p>In order to validate associated records whose presence is required, you must specify the <code>:inverse_of</code> option for the association:</p>
<div class="note"><p>If you want to ensure that the association it is both present and valid, you also need to use <code>validates_associated</code>.</p></div> <pre data-language="ruby">class Order &lt; ApplicationRecord
  has_many :line_items, inverse_of: :order
end</pre> <textarea class="clipboard-content" id="clipboard-d56ffe2b4f3cadd073468c011bd899c5">class Order &lt; ApplicationRecord has_many :line_items, inverse_of: :order end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-d56ffe2b4f3cadd073468c011bd899c5">Copy</button>  <p>If you validate the presence of an object associated via a <code>has_one</code> or <code>has_many</code> relationship, it will check that the object is neither <code>blank?</code> nor <code>marked_for_destruction?</code>.</p>
<p>Since <code>false.blank?</code> is true, if you want to validate the presence of a boolean field you should use one of the following validations:</p> <pre data-language="ruby">validates :boolean_field_name, inclusion: [true, false]
validates :boolean_field_name, exclusion: [nil]</pre> <textarea class="clipboard-content" id="clipboard-4f47eabffbd945c5547dd7f4b27afe18">validates :boolean_field_name, inclusion: [true, false] validates :boolean_field_name, exclusion: [nil] </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-4f47eabffbd945c5547dd7f4b27afe18">Copy</button>  <p>By using one of these validations, you will ensure the value will NOT be <code>nil</code> which would result in a <code>NULL</code> value in most cases.</p>
<h3 id="absence"><a class="anchorlink" href="#absence">2.10 <code>absence</code></a></h3>
<p>This helper validates that the specified attributes are absent. It uses the <code>present?</code> method to check if the value is not either nil or a blank string, that is, a string that is either empty or consists of whitespace.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :name, :login, :email, absence: true
end</pre> <textarea class="clipboard-content" id="clipboard-1efa80f2e2b0eae381bfbae95678b77d">class Person &lt; ApplicationRecord validates :name, :login, :email, absence: true end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-1efa80f2e2b0eae381bfbae95678b77d">Copy</button>  <p>If you want to be sure that an association is absent, you'll need to test whether the associated object itself is absent, and not the foreign key used to map the association.</p> <pre data-language="ruby">class LineItem &lt; ApplicationRecord
  belongs_to :order
  validates :order, absence: true
end</pre> <textarea class="clipboard-content" id="clipboard-24e94fa7ca471f98d05492cdee8db7f4">class LineItem &lt; ApplicationRecord belongs_to :order validates :order, absence: true end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-24e94fa7ca471f98d05492cdee8db7f4">Copy</button>  <p>In order to validate associated records whose absence is required, you must specify the <code>:inverse_of</code> option for the association:</p> <pre data-language="ruby">class Order &lt; ApplicationRecord
  has_many :line_items, inverse_of: :order
end</pre> <textarea class="clipboard-content" id="clipboard-c277c899602f80cbf2dd906399e2853b">class Order &lt; ApplicationRecord has_many :line_items, inverse_of: :order end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-c277c899602f80cbf2dd906399e2853b">Copy</button>  <p>If you validate the absence of an object associated via a <code>has_one</code> or <code>has_many</code> relationship, it will check that the object is neither <code>present?</code> nor <code>marked_for_destruction?</code>.</p>
<p>Since <code>false.present?</code> is false, if you want to validate the absence of a boolean field you should use <code>validates :field_name, exclusion: { in: [true, false] }</code>.</p>
<p>The default error message is <em>"must be blank"</em>.</p>
<h3 id="uniqueness"><a class="anchorlink" href="#uniqueness">2.11 <code>uniqueness</code></a></h3>
<p>This helper validates that the attribute's value is unique right before the object gets saved. It does not create a uniqueness constraint in the database, so it may happen that two different database connections create two records with the same value for a column that you intend to be unique. To avoid that, you must create a unique index on that column in your database.</p> <pre data-language="ruby">class Account &lt; ApplicationRecord
  validates :email, uniqueness: true
end</pre> <textarea class="clipboard-content" id="clipboard-1cf22b17f8ad67b59e6a651aa1bde47e">class Account &lt; ApplicationRecord validates :email, uniqueness: true end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-1cf22b17f8ad67b59e6a651aa1bde47e">Copy</button>  <p>The validation happens by performing an SQL query into the model's table, searching for an existing record with the same value in that attribute.</p>
<p>There is a <code>:scope</code> option that you can use to specify one or more attributes that are used to limit the uniqueness check:</p> <pre data-language="ruby">class Holiday &lt; ApplicationRecord
  validates :name, uniqueness: { scope: :year,
    message: "should happen once per year" }
end</pre> <textarea class="clipboard-content" id="clipboard-267889f046be01f8ae74d22b979f36b9">class Holiday &lt; ApplicationRecord validates :name, uniqueness: { scope: :year, message: "should happen once per year" } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-267889f046be01f8ae74d22b979f36b9">Copy</button>  <p>Should you wish to create a database constraint to prevent possible violations of a uniqueness validation using the <code>:scope</code> option, you must create a unique index on both columns in your database. See <a href="https://dev.mysql.com/doc/refman/en/multiple-column-indexes.html">the MySQL manual</a> for more details about multiple column indexes or <a href="https://www.postgresql.org/docs/current/static/ddl-constraints.html">the PostgreSQL manual</a> for examples of unique constraints that refer to a group of columns.</p>
<p>There is also a <code>:case_sensitive</code> option that you can use to define whether the uniqueness constraint will be case sensitive or not. This option defaults to true.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :name, uniqueness: { case_sensitive: false }
end</pre> <textarea class="clipboard-content" id="clipboard-95a3ff5942c8e10b3f024740122ca5a7">class Person &lt; ApplicationRecord validates :name, uniqueness: { case_sensitive: false } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-95a3ff5942c8e10b3f024740122ca5a7">Copy</button>  <div class="warning"><p>Note that some databases are configured to perform case-insensitive searches anyway.</p></div>
<p>The default error message is <em>"has already been taken"</em>.</p>
<h3 id="validates-with"><a class="anchorlink" href="#validates-with">2.12 <code>validates_with</code></a></h3>
<p>This helper passes the record to a separate class for validation.</p> <pre data-language="ruby">class GoodnessValidator &lt; ActiveModel::Validator
  def validate(record)
    if record.first_name == "Evil"
      record.errors.add :base, "This person is evil"
    end
  end
end

class Person &lt; ApplicationRecord
  validates_with GoodnessValidator
end</pre> <textarea class="clipboard-content" id="clipboard-7abc55c112db7a0eb522248b99a0dfe1">class GoodnessValidator &lt; ActiveModel::Validator def validate(record) if record.first_name == "Evil" record.errors.add :base, "This person is evil" end end end class Person &lt; ApplicationRecord validates_with GoodnessValidator end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-7abc55c112db7a0eb522248b99a0dfe1">Copy</button>  <div class="note"><p>Errors added to <code>record.errors[:base]</code> relate to the state of the record as a whole, and not to a specific attribute.</p></div>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Validations/ClassMethods.html#method-i-validates_with"><code>validates_with</code></a> helper takes a class, or a list of classes to use for validation. There is no default error message for <code>validates_with</code>. You must manually add errors to the record's errors collection in the validator class.</p>
<p>To implement the validate method, you must have a <code>record</code> parameter defined, which is the record to be validated.</p>
<p>Like all other validations, <code>validates_with</code> takes the <code>:if</code>, <code>:unless</code> and <code>:on</code> options. If you pass any other options, it will send those options to the validator class as <code>options</code>:</p> <pre data-language="ruby">class GoodnessValidator &lt; ActiveModel::Validator
  def validate(record)
    if options[:fields].any? { |field| record.send(field) == "Evil" }
      record.errors.add :base, "This person is evil"
    end
  end
end

class Person &lt; ApplicationRecord
  validates_with GoodnessValidator, fields: [:first_name, :last_name]
end</pre> <textarea class="clipboard-content" id="clipboard-9e3160c6da6b02cfc76013ecdf05e6c2">class GoodnessValidator &lt; ActiveModel::Validator def validate(record) if options[:fields].any? { |field| record.send(field) == "Evil" } record.errors.add :base, "This person is evil" end end end class Person &lt; ApplicationRecord validates_with GoodnessValidator, fields: [:first_name, :last_name] end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-9e3160c6da6b02cfc76013ecdf05e6c2">Copy</button>  <p>Note that the validator will be initialized <em>only once</em> for the whole application life cycle, and not on each validation run, so be careful about using instance variables inside it.</p>
<p>If your validator is complex enough that you want instance variables, you can easily use a plain old Ruby object instead:</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validate do |person|
    GoodnessValidator.new(person).validate
  end
end

class GoodnessValidator
  def initialize(person)
    @person = person
  end

  def validate
    if some_complex_condition_involving_ivars_and_private_methods?
      @person.errors.add :base, "This person is evil"
    end
  end

  # ...
end</pre> <textarea class="clipboard-content" id="clipboard-8881433286e34e99f356760b6c5bad4b">class Person &lt; ApplicationRecord validate do |person| GoodnessValidator.new(person).validate end end class GoodnessValidator def initialize(person) @person = person end def validate if some_complex_condition_involving_ivars_and_private_methods? @person.errors.add :base, "This person is evil" end end # ... end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-8881433286e34e99f356760b6c5bad4b">Copy</button>  <h3 id="validates-each"><a class="anchorlink" href="#validates-each">2.13 <code>validates_each</code></a></h3>
<p>This helper validates attributes against a block. It doesn't have a predefined validation function. You should create one using a block, and every attribute passed to <a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Validations/ClassMethods.html#method-i-validates_each"><code>validates_each</code></a> will be tested against it. In the following example, we don't want names and surnames to begin with lower case.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates_each :name, :surname do |record, attr, value|
    record.errors.add(attr, 'must start with upper case') if value =~ /\A[[:lower:]]/
  end
end</pre> <textarea class="clipboard-content" id="clipboard-d92a51cbf27563779e6a71554d92729d">class Person &lt; ApplicationRecord validates_each :name, :surname do |record, attr, value| record.errors.add(attr, 'must start with upper case') if value =~ /\A[[:lower:]]/ end end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-d92a51cbf27563779e6a71554d92729d">Copy</button>  <p>The block receives the record, the attribute's name, and the attribute's value. You can do anything you like to check for valid data within the block. If your validation fails, you should add an error to the model, therefore making it invalid.</p>
<h2 id="common-validation-options"><a class="anchorlink" href="#common-validation-options">3 Common Validation Options</a></h2>
<p>These are common validation options:</p>
<h3 id="allow-nil"><a class="anchorlink" href="#allow-nil">3.1 <code>:allow_nil</code></a></h3>
<p>The <code>:allow_nil</code> option skips the validation when the value being validated is <code>nil</code>.</p> <pre data-language="ruby">class Coffee &lt; ApplicationRecord
  validates :size, inclusion: { in: %w(small medium large),
    message: "%{value} is not a valid size" }, allow_nil: true
end</pre> <textarea class="clipboard-content" id="clipboard-1e1f0da7b961585dfd1a64750b0ee537">class Coffee &lt; ApplicationRecord validates :size, inclusion: { in: %w(small medium large), message: "%{value} is not a valid size" }, allow_nil: true end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-1e1f0da7b961585dfd1a64750b0ee537">Copy</button>  <p>For full options to the message argument please see the <a href="#message">message documentation</a>.</p>
<h3 id="allow-blank"><a class="anchorlink" href="#allow-blank">3.2 <code>:allow_blank</code></a></h3>
<p>The <code>:allow_blank</code> option is similar to the <code>:allow_nil</code> option. This option will let validation pass if the attribute's value is <code>blank?</code>, like <code>nil</code> or an empty string for example.</p> <pre data-language="ruby">class Topic &lt; ApplicationRecord
  validates :title, length: { is: 5 }, allow_blank: true
end</pre> <textarea class="clipboard-content" id="clipboard-021ba6ede7be276a86965cf5e74feafc">class Topic &lt; ApplicationRecord validates :title, length: { is: 5 }, allow_blank: true end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-021ba6ede7be276a86965cf5e74feafc">Copy</button>   <pre data-language="irb">irb&gt; Topic.create(title: "").valid?
=&gt; true
irb&gt; Topic.create(title: nil).valid?
=&gt; true</pre> <textarea class="clipboard-content" id="clipboard-ea2eec012513102b8c1a586eaf2c141a">Topic.create(title: "").valid? Topic.create(title: nil).valid? </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-ea2eec012513102b8c1a586eaf2c141a">Copy</button>  <h3 id="message"><a class="anchorlink" href="#message">3.3 <code>:message</code></a></h3>
<p>As you've already seen, the <code>:message</code> option lets you specify the message that will be added to the <code>errors</code> collection when validation fails. When this option is not used, Active Record will use the respective default error message for each validation helper. The <code>:message</code> option accepts a <code>String</code> or <code>Proc</code>.</p>
<p>A <code>String</code> <code>:message</code> value can optionally contain any/all of <code>%{value}</code>, <code>%{attribute}</code>, and <code>%{model}</code> which will be dynamically replaced when validation fails. This replacement is done using the I18n gem, and the placeholders must match exactly, no spaces are allowed.</p>
<p>A <code>Proc</code> <code>:message</code> value is given two arguments: the object being validated, and a hash with <code>:model</code>, <code>:attribute</code>, and <code>:value</code> key-value pairs.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  # Hard-coded message
  validates :name, presence: { message: "must be given please" }

  # Message with dynamic attribute value. %{value} will be replaced
  # with the actual value of the attribute. %{attribute} and %{model}
  # are also available.
  validates :age, numericality: { message: "%{value} seems wrong" }

  # Proc
  validates :username,
    uniqueness: {
      # object = person object being validated
      # data = { model: "Person", attribute: "Username", value: &lt;username&gt; }
      message: -&gt;(object, data) do
        "Hey #{object.name}, #{data[:value]} is already taken."
      end
    }
end</pre> <textarea class="clipboard-content" id="clipboard-fc912f80c142b0e82697b195f0d5fb99">class Person &lt; ApplicationRecord # Hard-coded message validates :name, presence: { message: "must be given please" } # Message with dynamic attribute value. %{value} will be replaced # with the actual value of the attribute. %{attribute} and %{model} # are also available. validates :age, numericality: { message: "%{value} seems wrong" } # Proc validates :username, uniqueness: { # object = person object being validated # data = { model: "Person", attribute: "Username", value: &lt;username&gt; } message: -&gt;(object, data) do "Hey #{object.name}, #{data[:value]} is already taken." end } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-fc912f80c142b0e82697b195f0d5fb99">Copy</button>  <h3 id="on"><a class="anchorlink" href="#on">3.4 <code>:on</code></a></h3>
<p>The <code>:on</code> option lets you specify when the validation should happen. The default behavior for all the built-in validation helpers is to be run on save (both when you're creating a new record and when you're updating it). If you want to change it, you can use <code>on: :create</code> to run the validation only when a new record is created or <code>on: :update</code> to run the validation only when a record is updated.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  # it will be possible to update email with a duplicated value
  validates :email, uniqueness: true, on: :create

  # it will be possible to create the record with a non-numerical age
  validates :age, numericality: true, on: :update

  # the default (validates on both create and update)
  validates :name, presence: true
end</pre> <textarea class="clipboard-content" id="clipboard-a758e8ec30d9f3dd0452f38bb8ca4313">class Person &lt; ApplicationRecord # it will be possible to update email with a duplicated value validates :email, uniqueness: true, on: :create # it will be possible to create the record with a non-numerical age validates :age, numericality: true, on: :update # the default (validates on both create and update) validates :name, presence: true end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-a758e8ec30d9f3dd0452f38bb8ca4313">Copy</button>  <p>You can also use <code>on:</code> to define custom contexts. Custom contexts need to be triggered explicitly by passing the name of the context to <code>valid?</code>, <code>invalid?</code>, or <code>save</code>.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :email, uniqueness: true, on: :account_setup
  validates :age, numericality: true, on: :account_setup
end</pre> <textarea class="clipboard-content" id="clipboard-eb1e098755303c9152afb4190167ed2b">class Person &lt; ApplicationRecord validates :email, uniqueness: true, on: :account_setup validates :age, numericality: true, on: :account_setup end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-eb1e098755303c9152afb4190167ed2b">Copy</button>   <pre data-language="irb">irb&gt; person = Person.new(age: 'thirty-three')
irb&gt; person.valid?
=&gt; true
irb&gt; person.valid?(:account_setup)
=&gt; false
irb&gt; person.errors.messages
=&gt; {:email=&gt;["has already been taken"], :age=&gt;["is not a number"]}</pre> <textarea class="clipboard-content" id="clipboard-73a8373ff6f2b22f80d413c0358f0824">person = Person.new(age: 'thirty-three') person.valid? person.valid?(:account_setup) person.errors.messages </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-73a8373ff6f2b22f80d413c0358f0824">Copy</button>  <p><code>person.valid?(:account_setup)</code> executes both the validations without saving the model. <code>person.save(context: :account_setup)</code> validates <code>person</code> in the <code>account_setup</code> context before saving.</p>
<p>When triggered by an explicit context, validations are run for that context, as well as any validations <em>without</em> a context.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :email, uniqueness: true, on: :account_setup
  validates :age, numericality: true, on: :account_setup
  validates :name, presence: true
end</pre> <textarea class="clipboard-content" id="clipboard-1a3ac80441edfac803f1905ecdbfa4bc">class Person &lt; ApplicationRecord validates :email, uniqueness: true, on: :account_setup validates :age, numericality: true, on: :account_setup validates :name, presence: true end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-1a3ac80441edfac803f1905ecdbfa4bc">Copy</button>   <pre data-language="irb">irb&gt; person = Person.new
irb&gt; person.valid?(:account_setup)
=&gt; false
irb&gt; person.errors.messages
=&gt; {:email=&gt;["has already been taken"], :age=&gt;["is not a number"], :name=&gt;["can't be blank"]}</pre> <textarea class="clipboard-content" id="clipboard-2a25ab27ee383751c3762f8f202f4993">person = Person.new person.valid?(:account_setup) person.errors.messages </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-2a25ab27ee383751c3762f8f202f4993">Copy</button>  <h2 id="strict-validations"><a class="anchorlink" href="#strict-validations">4 Strict Validations</a></h2>
<p>You can also specify validations to be strict and raise <code>ActiveModel::StrictValidationFailed</code> when the object is invalid.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :name, presence: { strict: true }
end</pre> <textarea class="clipboard-content" id="clipboard-43b9bd663382fc040feb506c1d6636d5">class Person &lt; ApplicationRecord validates :name, presence: { strict: true } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-43b9bd663382fc040feb506c1d6636d5">Copy</button>   <pre data-language="irb">irb&gt; Person.new.valid?
ActiveModel::StrictValidationFailed: Name can't be blank</pre> <textarea class="clipboard-content" id="clipboard-bf9b79efb9f3e494584dff70ca4bc24a">Person.new.valid? </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-bf9b79efb9f3e494584dff70ca4bc24a">Copy</button>  <p>There is also the ability to pass a custom exception to the <code>:strict</code> option.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :token, presence: true, uniqueness: true, strict: TokenGenerationException
end</pre> <textarea class="clipboard-content" id="clipboard-ce0dcbf1d5571dc409ed8dfcf6129432">class Person &lt; ApplicationRecord validates :token, presence: true, uniqueness: true, strict: TokenGenerationException end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-ce0dcbf1d5571dc409ed8dfcf6129432">Copy</button>   <pre data-language="irb">irb&gt; Person.new.valid?
TokenGenerationException: Token can't be blank</pre> <textarea class="clipboard-content" id="clipboard-22044acd8104cdb6460eeecba0f1d041">Person.new.valid? </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-22044acd8104cdb6460eeecba0f1d041">Copy</button>  <h2 id="conditional-validation"><a class="anchorlink" href="#conditional-validation">5 Conditional Validation</a></h2>
<p>Sometimes it will make sense to validate an object only when a given predicate is satisfied. You can do that by using the <code>:if</code> and <code>:unless</code> options, which can take a symbol, a <code>Proc</code> or an <code>Array</code>. You may use the <code>:if</code> option when you want to specify when the validation <strong>should</strong> happen. If you want to specify when the validation <strong>should not</strong> happen, then you may use the <code>:unless</code> option.</p>
<h3 id="using-a-symbol-with-if-and-unless"><a class="anchorlink" href="#using-a-symbol-with-if-and-unless">5.1 Using a Symbol with <code>:if</code> and <code>:unless</code></a></h3>
<p>You can associate the <code>:if</code> and <code>:unless</code> options with a symbol corresponding to the name of a method that will get called right before validation happens. This is the most commonly used option.</p> <pre data-language="ruby">class Order &lt; ApplicationRecord
  validates :card_number, presence: true, if: :paid_with_card?

  def paid_with_card?
    payment_type == "card"
  end
end</pre> <textarea class="clipboard-content" id="clipboard-3cb429d757818bd7697f8b2a7253dc55">class Order &lt; ApplicationRecord validates :card_number, presence: true, if: :paid_with_card? def paid_with_card? payment_type == "card" end end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-3cb429d757818bd7697f8b2a7253dc55">Copy</button>  <h3 id="using-a-proc-with-if-and-unless"><a class="anchorlink" href="#using-a-proc-with-if-and-unless">5.2 Using a Proc with <code>:if</code> and <code>:unless</code></a></h3>
<p>It is possible to associate <code>:if</code> and <code>:unless</code> with a <code>Proc</code> object which will be called. Using a <code>Proc</code> object gives you the ability to write an inline condition instead of a separate method. This option is best suited for one-liners.</p> <pre data-language="ruby">class Account &lt; ApplicationRecord
  validates :password, confirmation: true,
    unless: Proc.new { |a| a.password.blank? }
end</pre> <textarea class="clipboard-content" id="clipboard-f7e29708ad172f865bf5cbe6cecbbc24">class Account &lt; ApplicationRecord validates :password, confirmation: true, unless: Proc.new { |a| a.password.blank? } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-f7e29708ad172f865bf5cbe6cecbbc24">Copy</button>  <p>As <code>Lambdas</code> are a type of <code>Proc</code>, they can also be used to write inline conditions in a shorter way.</p> <pre data-language="ruby">validates :password, confirmation: true, unless: -&gt; { password.blank? }</pre> <textarea class="clipboard-content" id="clipboard-5d6f03bd96993a435337228f30662351">validates :password, confirmation: true, unless: -&gt; { password.blank? } </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-5d6f03bd96993a435337228f30662351">Copy</button>  <h3 id="grouping-conditional-validations"><a class="anchorlink" href="#grouping-conditional-validations">5.3 Grouping Conditional validations</a></h3>
<p>Sometimes it is useful to have multiple validations use one condition. It can be easily achieved using <a href="https://edgeapi.rubyonrails.org/classes/Object.html#method-i-with_options"><code>with_options</code></a>.</p> <pre data-language="ruby">class User &lt; ApplicationRecord
  with_options if: :is_admin? do |admin|
    admin.validates :password, length: { minimum: 10 }
    admin.validates :email, presence: true
  end
end</pre> <textarea class="clipboard-content" id="clipboard-8298a28b13955c3fbd74ea5fe60cd76d">class User &lt; ApplicationRecord with_options if: :is_admin? do |admin| admin.validates :password, length: { minimum: 10 } admin.validates :email, presence: true end end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-8298a28b13955c3fbd74ea5fe60cd76d">Copy</button>  <p>All validations inside of the <code>with_options</code> block will have automatically passed the condition <code>if: :is_admin?</code></p>
<h3 id="combining-validation-conditions"><a class="anchorlink" href="#combining-validation-conditions">5.4 Combining Validation Conditions</a></h3>
<p>On the other hand, when multiple conditions define whether or not a validation should happen, an <code>Array</code> can be used. Moreover, you can apply both <code>:if</code> and <code>:unless</code> to the same validation.</p> <pre data-language="ruby">class Computer &lt; ApplicationRecord
  validates :mouse, presence: true,
                    if: [Proc.new { |c| c.market.retail? }, :desktop?],
                    unless: Proc.new { |c| c.trackpad.present? }
end</pre> <textarea class="clipboard-content" id="clipboard-4686ea74f2206d66c157a074521d7818">class Computer &lt; ApplicationRecord validates :mouse, presence: true, if: [Proc.new { |c| c.market.retail? }, :desktop?], unless: Proc.new { |c| c.trackpad.present? } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-4686ea74f2206d66c157a074521d7818">Copy</button>  <p>The validation only runs when all the <code>:if</code> conditions and none of the <code>:unless</code> conditions are evaluated to <code>true</code>.</p>
<h2 id="performing-custom-validations"><a class="anchorlink" href="#performing-custom-validations">6 Performing Custom Validations</a></h2>
<p>When the built-in validation helpers are not enough for your needs, you can write your own validators or validation methods as you prefer.</p>
<h3 id="custom-validators"><a class="anchorlink" href="#custom-validators">6.1 Custom Validators</a></h3>
<p>Custom validators are classes that inherit from <a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Validator.html"><code>ActiveModel::Validator</code></a>. These classes must implement the <code>validate</code> method which takes a record as an argument and performs the validation on it. The custom validator is called using the <code>validates_with</code> method.</p> <pre data-language="ruby">class MyValidator &lt; ActiveModel::Validator
  def validate(record)
    unless record.name.start_with? 'X'
      record.errors.add :name, "Need a name starting with X please!"
    end
  end
end

class Person
  include ActiveModel::Validations
  validates_with MyValidator
end</pre> <textarea class="clipboard-content" id="clipboard-57fa7042ff27dcb4621e33dae7bfb31a">class MyValidator &lt; ActiveModel::Validator def validate(record) unless record.name.start_with? 'X' record.errors.add :name, "Need a name starting with X please!" end end end class Person include ActiveModel::Validations validates_with MyValidator end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-57fa7042ff27dcb4621e33dae7bfb31a">Copy</button>  <p>The easiest way to add custom validators for validating individual attributes is with the convenient <code>ActiveModel::EachValidator</code>. In this case, the custom validator class must implement a <code>validate_each</code> method which takes three arguments: record, attribute, and value. These correspond to the instance, the attribute to be validated, and the value of the attribute in the passed instance.</p> <pre data-language="ruby">class EmailValidator &lt; ActiveModel::EachValidator
  def validate_each(record, attribute, value)
    unless value =~ /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/i
      record.errors.add attribute, (options[:message] || "is not an email")
    end
  end
end

class Person &lt; ApplicationRecord
  validates :email, presence: true, email: true
end</pre> <textarea class="clipboard-content" id="clipboard-a2fe112a0a2a04cd3d04e507a99b4280">class EmailValidator &lt; ActiveModel::EachValidator def validate_each(record, attribute, value) unless value =~ /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/i record.errors.add attribute, (options[:message] || "is not an email") end end end class Person &lt; ApplicationRecord validates :email, presence: true, email: true end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-a2fe112a0a2a04cd3d04e507a99b4280">Copy</button>  <p>As shown in the example, you can also combine standard validations with your own custom validators.</p>
<h3 id="custom-methods"><a class="anchorlink" href="#custom-methods">6.2 Custom Methods</a></h3>
<p>You can also create methods that verify the state of your models and add errors to the <code>errors</code> collection when they are invalid. You must then register these methods by using the <a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Validations/ClassMethods.html#method-i-validate"><code>validate</code></a> class method, passing in the symbols for the validation methods' names.</p>
<p>You can pass more than one symbol for each class method and the respective validations will be run in the same order as they were registered.</p>
<p>The <code>valid?</code> method will verify that the errors collection is empty, so your custom validation methods should add errors to it when you wish validation to fail:</p> <pre data-language="ruby">class Invoice &lt; ApplicationRecord
  validate :expiration_date_cannot_be_in_the_past,
    :discount_cannot_be_greater_than_total_value

  def expiration_date_cannot_be_in_the_past
    if expiration_date.present? &amp;&amp; expiration_date &lt; Date.today
      errors.add(:expiration_date, "can't be in the past")
    end
  end

  def discount_cannot_be_greater_than_total_value
    if discount &gt; total_value
      errors.add(:discount, "can't be greater than total value")
    end
  end
end</pre> <textarea class="clipboard-content" id="clipboard-0a51a4f68c9d4fbe4dc747d1deb07529">class Invoice &lt; ApplicationRecord validate :expiration_date_cannot_be_in_the_past, :discount_cannot_be_greater_than_total_value def expiration_date_cannot_be_in_the_past if expiration_date.present? &amp;&amp; expiration_date &lt; Date.today errors.add(:expiration_date, "can't be in the past") end end def discount_cannot_be_greater_than_total_value if discount &gt; total_value errors.add(:discount, "can't be greater than total value") end end end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-0a51a4f68c9d4fbe4dc747d1deb07529">Copy</button>  <p>By default, such validations will run every time you call <code>valid?</code> or save the object. But it is also possible to control when to run these custom validations by giving an <code>:on</code> option to the <code>validate</code> method, with either: <code>:create</code> or <code>:update</code>.</p> <pre data-language="ruby">class Invoice &lt; ApplicationRecord
  validate :active_customer, on: :create

  def active_customer
    errors.add(:customer_id, "is not active") unless customer.active?
  end
end</pre> <textarea class="clipboard-content" id="clipboard-6293356049dc6ed1520df935c975d9d6">class Invoice &lt; ApplicationRecord validate :active_customer, on: :create def active_customer errors.add(:customer_id, "is not active") unless customer.active? end end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-6293356049dc6ed1520df935c975d9d6">Copy</button>  <h2 id="working-with-validation-errors"><a class="anchorlink" href="#working-with-validation-errors">7 Working with Validation Errors</a></h2>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Validations.html#method-i-valid-3F"><code>valid?</code></a> and <a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Validations.html#method-i-invalid-3F"><code>invalid?</code></a> methods only provide a summary status on validity. However you can dig deeper into each individual error by using various methods from the <a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Validations.html#method-i-errors"><code>errors</code></a> collection.</p>
<p>The following is a list of the most commonly used methods. Please refer to the <a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Errors.html"><code>ActiveModel::Errors</code></a> documentation for a list of all the available methods.</p>
<h3 id="working-with-validation-errors-errors"><a class="anchorlink" href="#working-with-validation-errors-errors">7.1 <code>errors</code></a></h3>
<p>The gateway through which you can drill down into various details of each error.</p>
<p>This returns an instance of the class <code>ActiveModel::Errors</code> containing all errors, each error is represented by an <a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Error.html"><code>ActiveModel::Error</code></a> object.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end</pre> <textarea class="clipboard-content" id="clipboard-f9456035f06b170cfb7a27380d165a9d">class Person &lt; ApplicationRecord validates :name, presence: true, length: { minimum: 3 } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-f9456035f06b170cfb7a27380d165a9d">Copy</button>   <pre data-language="irb">irb&gt; person = Person.new
irb&gt; person.valid?
=&gt; false
irb&gt; person.errors.full_messages
=&gt; ["Name can't be blank", "Name is too short (minimum is 3 characters)"]

irb&gt; person = Person.new(name: "John Doe")
irb&gt; person.valid?
=&gt; true
irb&gt; person.errors.full_messages
=&gt; []</pre> <textarea class="clipboard-content" id="clipboard-87e93bfb061b09ea4ea7d574406435fd">person = Person.new person.valid? person.errors.full_messages person = Person.new(name: "John Doe") person.valid? person.errors.full_messages </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-87e93bfb061b09ea4ea7d574406435fd">Copy</button>  <h3 id="errors"><a class="anchorlink" href="#errors">7.2 <code>errors[]</code></a></h3>
<p><a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Errors.html#method-i-5B-5D"><code>errors[]</code></a> is used when you want to check the error messages for a specific attribute. It returns an array of strings with all error messages for the given attribute, each string with one error message. If there are no errors related to the attribute, it returns an empty array.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end</pre> <textarea class="clipboard-content" id="clipboard-6c90a4b4fe861915e5512e909e81ee49">class Person &lt; ApplicationRecord validates :name, presence: true, length: { minimum: 3 } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-6c90a4b4fe861915e5512e909e81ee49">Copy</button>   <pre data-language="irb">irb&gt; person = Person.new(name: "John Doe")
irb&gt; person.valid?
=&gt; true
irb&gt; person.errors[:name]
=&gt; []

irb&gt; person = Person.new(name: "JD")
irb&gt; person.valid?
=&gt; false
irb&gt; person.errors[:name]
=&gt; ["is too short (minimum is 3 characters)"]

irb&gt; person = Person.new
irb&gt; person.valid?
=&gt; false
irb&gt; person.errors[:name]
=&gt; ["can't be blank", "is too short (minimum is 3 characters)"]</pre> <textarea class="clipboard-content" id="clipboard-cf34e03b4a7a31fcb7348e96d9bf5756">person = Person.new(name: "John Doe") person.valid? person.errors[:name] person = Person.new(name: "JD") person.valid? person.errors[:name] person = Person.new person.valid? person.errors[:name] </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-cf34e03b4a7a31fcb7348e96d9bf5756">Copy</button>  <h3 id="errors-where-and-error-object"><a class="anchorlink" href="#errors-where-and-error-object">7.3 <code>errors.where</code> and error object</a></h3>
<p>Sometimes we may need more information about each error beside its message. Each error is encapsulated as an <code>ActiveModel::Error</code> object, and <a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Errors.html#method-i-where"><code>where</code></a> method is the most common way of access.</p>
<p><code>where</code> returns an array of error objects, filtered by various degree of conditions.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end</pre> <textarea class="clipboard-content" id="clipboard-9d080527489e5f632a51f46eb1f8aaa1">class Person &lt; ApplicationRecord validates :name, presence: true, length: { minimum: 3 } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-9d080527489e5f632a51f46eb1f8aaa1">Copy</button>   <pre data-language="irb">irb&gt; person = Person.new
irb&gt; person.valid?
=&gt; false

irb&gt; person.errors.where(:name)
=&gt; [ ... ] # all errors for :name attribute

irb&gt; person.errors.where(:name, :too_short)
=&gt; [ ... ] # :too_short errors for :name attribute</pre> <textarea class="clipboard-content" id="clipboard-bcda106565908ca4fed2dcaee242393e">person = Person.new person.valid? person.errors.where(:name) person.errors.where(:name, :too_short) </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-bcda106565908ca4fed2dcaee242393e">Copy</button>  <p>You can read various information from these error objects:</p> <pre data-language="irb">irb&gt; error = person.errors.where(:name).last

irb&gt; error.attribute
=&gt; :name
irb&gt; error.type
=&gt; :too_short
irb&gt; error.options[:count]
=&gt; 3</pre> <textarea class="clipboard-content" id="clipboard-14a90ba201dfca17749b80653c8bba70">error = person.errors.where(:name).last error.attribute error.type error.options[:count] </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-14a90ba201dfca17749b80653c8bba70">Copy</button>  <p>You can also generate the error message:</p> <pre data-language="irb">irb&gt; error.message
=&gt; "is too short (minimum is 3 characters)"
irb&gt; error.full_message
=&gt; "Name is too short (minimum is 3 characters)"</pre> <textarea class="clipboard-content" id="clipboard-cdd570372dfb19e00776d39ac4e00e7a">error.message error.full_message </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-cdd570372dfb19e00776d39ac4e00e7a">Copy</button>  <p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Errors.html#method-i-full_message"><code>full_message</code></a> method generates a more user-friendly message, with the capitalized attribute name prepended.</p>
<h3 id="errors-add"><a class="anchorlink" href="#errors-add">7.4 <code>errors.add</code></a></h3>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveModel/Errors.html#method-i-add"><code>add</code></a> method creates the error object by taking the <code>attribute</code>, the error <code>type</code> and additional options hash. This is useful for writing your own validator.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validate do |person|
    errors.add :name, :too_plain, message: "is not cool enough"
  end
end</pre> <textarea class="clipboard-content" id="clipboard-56ce474bac0e479e9bc5d6ea71f2d664">class Person &lt; ApplicationRecord validate do |person| errors.add :name, :too_plain, message: "is not cool enough" end end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-56ce474bac0e479e9bc5d6ea71f2d664">Copy</button>   <pre data-language="irb">irb&gt; person = Person.create
irb&gt; person.errors.where(:name).first.type
=&gt; :too_plain
irb&gt; person.errors.where(:name).first.full_message
=&gt; "Name is not cool enough"</pre> <textarea class="clipboard-content" id="clipboard-66136f71c0df4277d23c5d222bd318b7">person = Person.create person.errors.where(:name).first.type person.errors.where(:name).first.full_message </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-66136f71c0df4277d23c5d222bd318b7">Copy</button>  <h3 id="errors-base"><a class="anchorlink" href="#errors-base">7.5 <code>errors[:base]</code></a></h3>
<p>You can add errors that are related to the object's state as a whole, instead of being related to a specific attribute. You can add errors to <code>:base</code> when you want to say that the object is invalid, no matter the values of its attributes.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validate do |person|
    errors.add :base, :invalid, message: "This person is invalid because ..."
  end
end</pre> <textarea class="clipboard-content" id="clipboard-f394063040d83798af87edf4a884ebe0">class Person &lt; ApplicationRecord validate do |person| errors.add :base, :invalid, message: "This person is invalid because ..." end end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-f394063040d83798af87edf4a884ebe0">Copy</button>   <pre data-language="irb">irb&gt; person = Person.create
irb&gt; person.errors.where(:base).first.full_message
=&gt; "This person is invalid because ..."</pre> <textarea class="clipboard-content" id="clipboard-901884882653a2d123f45b20b6e28edd">person = Person.create person.errors.where(:base).first.full_message </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-901884882653a2d123f45b20b6e28edd">Copy</button>  <h3 id="errors-clear"><a class="anchorlink" href="#errors-clear">7.6 <code>errors.clear</code></a></h3>
<p>The <code>clear</code> method is used when you intentionally want to clear the <code>errors</code> collection. Of course, calling <code>errors.clear</code> upon an invalid object won't actually make it valid: the <code>errors</code> collection will now be empty, but the next time you call <code>valid?</code> or any method that tries to save this object to the database, the validations will run again. If any of the validations fail, the <code>errors</code> collection will be filled again.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end</pre> <textarea class="clipboard-content" id="clipboard-107aaa89c960a226ca4b2ddfed1aa86f">class Person &lt; ApplicationRecord validates :name, presence: true, length: { minimum: 3 } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-107aaa89c960a226ca4b2ddfed1aa86f">Copy</button>   <pre data-language="irb">irb&gt; person = Person.new
irb&gt; person.valid?
=&gt; false
irb&gt; person.errors.empty?
=&gt; false

irb&gt; person.errors.clear
irb&gt; person.errors.empty?
=&gt; true

irb&gt; person.save
=&gt; false

irb&gt; person.errors.empty?
=&gt; false</pre> <textarea class="clipboard-content" id="clipboard-b554ef48584ca00541795403e6facfc4">person = Person.new person.valid? person.errors.empty? person.errors.clear person.errors.empty? person.save person.errors.empty? </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-b554ef48584ca00541795403e6facfc4">Copy</button>  <h3 id="errors-size"><a class="anchorlink" href="#errors-size">7.7 <code>errors.size</code></a></h3>
<p>The <code>size</code> method returns the total number of errors for the object.</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end</pre> <textarea class="clipboard-content" id="clipboard-8e01dc43797fd734f8ef2d448bce2cda">class Person &lt; ApplicationRecord validates :name, presence: true, length: { minimum: 3 } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-8e01dc43797fd734f8ef2d448bce2cda">Copy</button>   <pre data-language="irb">irb&gt; person = Person.new
irb&gt; person.valid?
=&gt; false
irb&gt; person.errors.size
=&gt; 2

irb&gt; person = Person.new(name: "Andrea", email: "andrea@example.com")
irb&gt; person.valid?
=&gt; true
irb&gt; person.errors.size
=&gt; 0</pre> <textarea class="clipboard-content" id="clipboard-66ab0d54b402895dfc032af73f65dbf0">person = Person.new person.valid? person.errors.size person = Person.new(name: "Andrea", email: "andrea@example.com") person.valid? person.errors.size </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-66ab0d54b402895dfc032af73f65dbf0">Copy</button>  <h2 id="displaying-validation-errors-in-views"><a class="anchorlink" href="#displaying-validation-errors-in-views">8 Displaying Validation Errors in Views</a></h2>
<p>Once you've created a model and added validations, if that model is created via a web form, you probably want to display an error message when one of the validations fail.</p>
<p>Because every application handles this kind of thing differently, Rails does not include any view helpers to help you generate these messages directly. However, due to the rich number of methods Rails gives you to interact with validations in general, you can build your own. In addition, when generating a scaffold, Rails will put some ERB into the <code>_form.html.erb</code> that it generates that displays the full list of errors on that model.</p>
<p>Assuming we have a model that's been saved in an instance variable named <code>@article</code>, it looks like this:</p> <pre data-language="erb">&lt;% if @article.errors.any? %&gt;
  &lt;div id="error_explanation"&gt;
    &lt;h2&gt;&lt;%= pluralize(@article.errors.count, "error") %&gt; prohibited this article from being saved:&lt;/h2&gt;

    &lt;ul&gt;
      &lt;% @article.errors.each do |error| %&gt;
        &lt;li&gt;&lt;%= error.full_message %&gt;&lt;/li&gt;
      &lt;% end %&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;% end %&gt;</pre> <textarea class="clipboard-content" id="clipboard-51dc0690cd2870f6cf4593cc8cd6d76f">&lt;% if @article.errors.any? %&gt; &lt;div id="error_explanation"&gt; &lt;h2&gt;&lt;%= pluralize(@article.errors.count, "error") %&gt; prohibited this article from being saved:&lt;/h2&gt; &lt;ul&gt; &lt;% @article.errors.each do |error| %&gt; &lt;li&gt;&lt;%= error.full_message %&gt;&lt;/li&gt; &lt;% end %&gt; &lt;/ul&gt; &lt;/div&gt; &lt;% end %&gt; </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-51dc0690cd2870f6cf4593cc8cd6d76f">Copy</button>  <p>Furthermore, if you use the Rails form helpers to generate your forms, when a validation error occurs on a field, it will generate an extra <code>&lt;div&gt;</code> around the entry.</p> <pre data-language="html">&lt;div class="field_with_errors"&gt;
  &lt;input id="article_title" name="article[title]" size="30" type="text" value=""&gt;
&lt;/div&gt;</pre> <textarea class="clipboard-content" id="clipboard-db13a04eef3ed9f3abb40d39b7715a47">&lt;div class="field_with_errors"&gt; &lt;input id="article_title" name="article[title]" size="30" type="text" value=""&gt; &lt;/div&gt; </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-db13a04eef3ed9f3abb40d39b7715a47">Copy</button>  <p>You can then style this div however you'd like. The default scaffold that Rails generates, for example, adds this CSS rule:</p> <pre data-language="css">.field_with_errors {
  padding: 2px;
  background-color: red;
  display: table;
}</pre> <textarea class="clipboard-content" id="clipboard-6c90e84fcc7fc93cdcdb0646956a8609">.field_with_errors { padding: 2px; background-color: red; display: table; } </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-6c90e84fcc7fc93cdcdb0646956a8609">Copy</button>  <p>This means that any field with an error ends up with a 2 pixel red border.</p> <h2>Feedback</h2> <p> You're encouraged to help improve the quality of this guide. </p> <p> Please contribute if you see any typos or factual errors. To get started, you can read our <a href="https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#contributing-to-the-rails-documentation">documentation contributions</a> section. </p> <p> You may also find incomplete content or stuff that is not up to date. Please do add any missing documentation for master. Make sure to check <a href="https://edgeguides.rubyonrails.org">Edge Guides</a> first to verify if the issues are already fixed or not on the master branch. Check the <span>Ruby on Rails Guides Guidelines</span> for style and conventions. </p> <p> If for whatever reason you spot something to fix but cannot patch it yourself, please <a href="https://github.com/rails/rails/issues">open an issue</a>. </p> <p>And last but not least, any kind of discussion regarding Ruby on Rails documentation is very welcome on the <a href="https://discuss.rubyonrails.org/c/rubyonrails-docs">rubyonrails-docs mailing list</a>. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2004&ndash;2020 David Heinemeier Hansson<br>Licensed under the Creative Commons Attribution-ShareAlike 4.0 International License.<br>
    
  </p>
</div>
