<h1>Multiple Databases with Active Record</h1>
<div class="_simple"> <p>This guide covers using multiple databases with your Rails application.</p>
<p>After reading this guide you will know:</p> <ul> <li>How to set up your application for multiple databases.</li> <li>How automatic connection switching works.</li> <li>How to use horizontal sharding for multiple databases.</li> <li>What features are supported and what's still a work in progress.</li> </ul>  <h2 class="chapter">Chapters</h2> <ol class="chapters"> <li><a href="#setting-up-your-application">Setting up your application</a></li> <li><a href="#generators-and-migrations">Generators and Migrations</a></li> <li><a href="#activating-automatic-connection-switching">Activating automatic connection switching</a></li> <li><a href="#using-manual-connection-switching">Using manual connection switching</a></li> <li><a href="#horizontal-sharding">Horizontal sharding</a></li> <li><a href="#granular-database-connection-switching">Granular Database Connection Switching</a></li> <li> <a href="#caveats">Caveats</a> <ul> <li><a href="#automatic-swapping-for-horizontal-sharding">Automatic swapping for horizontal sharding</a></li> <li><a href="#load-balancing-replicas">Load Balancing Replicas</a></li> <li><a href="#joining-across-databases">Joining Across Databases</a></li> <li><a href="#schema-cache">Schema Cache</a></li> </ul> </li> </ol>   <p>As an application grows in popularity and usage you'll need to scale the application to support your new users and their data. One way in which your application may need to scale is on the database level. Rails now has support for multiple databases so you don't have to store your data all in one place.</p>
<p>At this time the following features are supported:</p> <ul> <li>Multiple writer databases and a replica for each</li> <li>Automatic connection switching for the model you're working with</li> <li>Automatic swapping between the writer and replica depending on the HTTP verb and recent writes</li> <li>Rails tasks for creating, dropping, migrating, and interacting with the multiple databases</li> </ul> <p>The following features are not (yet) supported:</p> <ul> <li>Automatic swapping for horizontal sharding</li> <li>Joining across clusters</li> <li>Load balancing replicas</li> <li>Dumping schema caches for multiple databases</li> </ul> <h2 id="setting-up-your-application"><a class="anchorlink" href="#setting-up-your-application">1 Setting up your application</a></h2>
<p>While Rails tries to do most of the work for you there are still some steps you'll need to do to get your application ready for multiple databases.</p>
<p>Let's say we have an application with a single writer database and we need to add a new database for some new tables we're adding. The name of the new database will be "animals".</p>
<p>The <code>database.yml</code> looks like this:</p> <pre data-language="yaml">production:
  database: my_primary_database
  user: root
  adapter: mysql</pre> <textarea class="clipboard-content" id="clipboard-ed70149f5de7ddc828bd7c561b12e9b5">production: database: my_primary_database user: root adapter: mysql </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-ed70149f5de7ddc828bd7c561b12e9b5">Copy</button>  <p>Let's add a replica for the first configuration, and a second database called animals and a replica for that as well. To do this we need to change our <code>database.yml</code> from a 2-tier to a 3-tier config.</p>
<p>If a primary configuration is provided this will be used as the "default" configuration. If there is no configuration named "primary" Rails will use the first configuration for an environment. The default configurations will use the default Rails filenames. For example primary configurations will use <code>schema.rb</code> for the schema file whereas all other entries will use <code>[CONFIGURATION_NAMESPACE]_schema.rb</code> for the filename.</p> <pre data-language="yaml">production:
  primary:
    database: my_primary_database
    user: root
    adapter: mysql
  primary_replica:
    database: my_primary_database
    user: root_readonly
    adapter: mysql
    replica: true
  animals:
    database: my_animals_database
    user: animals_root
    adapter: mysql
    migrations_paths: db/animals_migrate
  animals_replica:
    database: my_animals_database
    user: animals_readonly
    adapter: mysql
    replica: true</pre> <textarea class="clipboard-content" id="clipboard-cc083ed51f0e6e48e9e179154dae5ad0">production: primary: database: my_primary_database user: root adapter: mysql primary_replica: database: my_primary_database user: root_readonly adapter: mysql replica: true animals: database: my_animals_database user: animals_root adapter: mysql migrations_paths: db/animals_migrate animals_replica: database: my_animals_database user: animals_readonly adapter: mysql replica: true </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-cc083ed51f0e6e48e9e179154dae5ad0">Copy</button>  <p>When using multiple databases there are a few important settings.</p>
<p>First, the database name for the <code>primary</code> and <code>primary_replica</code> should be the same because they contain the same data. This is also the case for <code>animals</code> and <code>animals_replica</code>.</p>
<p>Second, the username for the writers and replicas should be different, and the replica user's permissions should be set to only read and not write.</p>
<p>When using a replica database you need to add a <code>replica: true</code> entry to the replica in the <code>database.yml</code>. This is because Rails otherwise has no way of knowing which one is a replica and which one is the writer.</p>
<p>Lastly, for new writer databases you need to set the <code>migrations_paths</code> to the directory where you will store migrations for that database. We'll look more at <code>migrations_paths</code> later on in this guide.</p>
<p>Now that we have a new database, let's set up the connection model. In order to use the new database we need to create a new abstract class and connect to the animals databases.</p> <pre data-language="ruby">class AnimalsRecord &lt; ApplicationRecord
  self.abstract_class = true

  connects_to database: { writing: :animals, reading: :animals_replica }
end</pre> <textarea class="clipboard-content" id="clipboard-57e4fd990710922bef60c5ca0761c5d4">class AnimalsRecord &lt; ApplicationRecord self.abstract_class = true connects_to database: { writing: :animals, reading: :animals_replica } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-57e4fd990710922bef60c5ca0761c5d4">Copy</button>  <p>Then we need to update <code>ApplicationRecord</code> to be aware of our new replica.</p> <pre data-language="ruby">class ApplicationRecord &lt; ActiveRecord::Base
  self.abstract_class = true

  connects_to database: { writing: :primary, reading: :primary_replica }
end</pre> <textarea class="clipboard-content" id="clipboard-be80879088905eb3a710fa480f8f4f8d">class ApplicationRecord &lt; ActiveRecord::Base self.abstract_class = true connects_to database: { writing: :primary, reading: :primary_replica } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-be80879088905eb3a710fa480f8f4f8d">Copy</button>  <p>Classes that connect to primary/primary_replica can inherit from <code>ApplicationRecord</code> like standard Rails applications:</p> <pre data-language="ruby">class Person &lt; ApplicationRecord
end</pre> <textarea class="clipboard-content" id="clipboard-f75f27ecbe0cf248e0e42b72414a895f">class Person &lt; ApplicationRecord end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-f75f27ecbe0cf248e0e42b72414a895f">Copy</button>  <p>By default Rails expects the database roles to be <code>writing</code> and <code>reading</code> for the primary and replica respectively. If you have a legacy system you may already have roles set up that you don't want to change. In that case you can set a new role name in your application config.</p> <pre data-language="ruby">config.active_record.writing_role = :default
config.active_record.reading_role = :readonly</pre> <textarea class="clipboard-content" id="clipboard-de26f7bfde9814c6c95c53400d275e29">config.active_record.writing_role = :default config.active_record.reading_role = :readonly </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-de26f7bfde9814c6c95c53400d275e29">Copy</button>  <p>It's important to connect to your database in a single model and then inherit from that model for the tables rather than connect multiple individual models to the same database. Database clients have a limit to the number of open connections there can be and if you do this it will multiply the number of connections you have since Rails uses the model class name for the connection specification name.</p>
<p>Now that we have the <code>database.yml</code> and the new model set up it's time to create the databases. Rails 6.0 ships with all the rails tasks you need to use multiple databases in Rails.</p>
<p>You can run <code>bin/rails -T</code> to see all the commands you're able to run. You should see the following:</p> <pre data-language="console">$ bin/rails -T
rails db:create                          # Creates the database from DATABASE_URL or config/database.yml for the ...
rails db:create:animals                  # Create animals database for current environment
rails db:create:primary                  # Create primary database for current environment
rails db:drop                            # Drops the database from DATABASE_URL or config/database.yml for the cu...
rails db:drop:animals                    # Drop animals database for current environment
rails db:drop:primary                    # Drop primary database for current environment
rails db:migrate                         # Migrate the database (options: VERSION=x, VERBOSE=false, SCOPE=blog)
rails db:migrate:animals                 # Migrate animals database for current environment
rails db:migrate:primary                 # Migrate primary database for current environment
rails db:migrate:status                  # Display status of migrations
rails db:migrate:status:animals          # Display status of migrations for animals database
rails db:migrate:status:primary          # Display status of migrations for primary database
rails db:rollback                        # Rolls the schema back to the previous version (specify steps w/ STEP=n)
rails db:rollback:animals                # Rollback animals database for current environment (specify steps w/ STEP=n)
rails db:rollback:primary                # Rollback primary database for current environment (specify steps w/ STEP=n)
rails db:schema:dump                     # Creates a database schema file (either db/schema.rb or db/structure.sql  ...
rails db:schema:dump:animals             # Creates a database schema file (either db/schema.rb or db/structure.sql  ...
rails db:schema:dump:primary             # Creates a db/schema.rb file that is portable against any DB supported  ...
rails db:schema:load                     # Loads a database schema file (either db/schema.rb or db/structure.sql  ...
rails db:schema:load:animals             # Loads a database schema file (either db/schema.rb or db/structure.sql  ...
rails db:schema:load:primary             # Loads a database schema file (either db/schema.rb or db/structure.sql  ...</pre> <textarea class="clipboard-content" id="clipboard-c59a7f2b544a761e87cea4f445277af1">bin/rails -T </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-c59a7f2b544a761e87cea4f445277af1">Copy</button>  <p>Running a command like <code>bin/rails db:create</code> will create both the primary and animals databases. Note that there is no command for creating the users and you'll need to do that manually to support the readonly users for your replicas. If you want to create just the animals database you can run <code>bin/rails db:create:animals</code>.</p>
<h2 id="generators-and-migrations"><a class="anchorlink" href="#generators-and-migrations">2 Generators and Migrations</a></h2>
<p>Migrations for multiple databases should live in their own folders prefixed with the name of the database key in the configuration.</p>
<p>You also need to set the <code>migrations_paths</code> in the database configurations to tell Rails where to find the migrations.</p>
<p>For example the <code>animals</code> database would look for migrations in the <code>db/animals_migrate</code> directory and <code>primary</code> would look in <code>db/migrate</code>. Rails generators now take a <code>--database</code> option so that the file is generated in the correct directory. The command can be run like so:</p> <pre data-language="console">$ bin/rails generate migration CreateDogs name:string --database animals</pre> <textarea class="clipboard-content" id="clipboard-2703f482dff57cf6cc45263dabda3346">bin/rails generate migration CreateDogs name:string --database animals </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-2703f482dff57cf6cc45263dabda3346">Copy</button>  <p>If you are using Rails generators, the scaffold and model generators will create the abstract class for you. Simply pass the database key to the command line</p> <pre data-language="console">$ bin/rails generate scaffold Dog name:string --database animals</pre> <textarea class="clipboard-content" id="clipboard-ec496e0cbe39f32a579f4d446af50fe3">bin/rails generate scaffold Dog name:string --database animals </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-ec496e0cbe39f32a579f4d446af50fe3">Copy</button>  <p>A class with the database name and <code>Record</code> will be created. In this example the database is <code>Animals</code> so we end up with <code>AnimalsRecord</code>:</p> <pre data-language="ruby">class AnimalsRecord &lt; ApplicationRecord
  self.abstract_class = true

  connects_to database: { writing: :animals }
end</pre> <textarea class="clipboard-content" id="clipboard-7caf61c3d89e6ffecace996e90cf7bde">class AnimalsRecord &lt; ApplicationRecord self.abstract_class = true connects_to database: { writing: :animals } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-7caf61c3d89e6ffecace996e90cf7bde">Copy</button>  <p>The generated model will automatically inherit from <code>AnimalsRecord</code>.</p> <pre data-language="ruby">class Dog &lt; AnimalsRecord
end</pre> <textarea class="clipboard-content" id="clipboard-db5e7b87e24f6c6830dc34f53d2817b0">class Dog &lt; AnimalsRecord end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-db5e7b87e24f6c6830dc34f53d2817b0">Copy</button>  <p>Note: Since Rails doesn't know which database is the replica for your writer you will need to add this to the abstract class after you're done.</p>
<p>Rails will only generate the new class once. It will not be overwritten by new scaffolds or deleted if the scaffold is deleted.</p>
<p>If you already have an abstract class and its name differs from <code>AnimalsRecord</code> you can pass the <code>--parent</code> option to indicate you want a different abstract class:</p> <pre data-language="console">$ bin/rails generate scaffold Dog name:string --database animals --parent Animals::Record</pre> <textarea class="clipboard-content" id="clipboard-0f13aba442de65bc1865d5fa7fb77fb5">bin/rails generate scaffold Dog name:string --database animals --parent Animals::Record </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-0f13aba442de65bc1865d5fa7fb77fb5">Copy</button>  <p>This will skip generating <code>AnimalsRecord</code> since you've indicated to Rails that you want to use a different parent class.</p>
<h2 id="activating-automatic-connection-switching"><a class="anchorlink" href="#activating-automatic-connection-switching">3 Activating automatic connection switching</a></h2>
<p>Finally, in order to use the read-only replica in your application you'll need to activate the middleware for automatic switching.</p>
<p>Automatic switching allows the application to switch from the writer to replica or replica to writer based on the HTTP verb and whether there was a recent write.</p>
<p>If the application is receiving a POST, PUT, DELETE, or PATCH request the application will automatically write to the writer database. For the specified time after the write, the application will read from the primary. For a GET or HEAD request the application will read from the replica unless there was a recent write.</p>
<p>To activate the automatic connection switching middleware, add or uncomment the following lines in your application config.</p> <pre data-language="ruby">config.active_record.database_selector = { delay: 2.seconds }
config.active_record.database_resolver = ActiveRecord::Middleware::DatabaseSelector::Resolver
config.active_record.database_resolver_context = ActiveRecord::Middleware::DatabaseSelector::Resolver::Session</pre> <textarea class="clipboard-content" id="clipboard-c2f34633e4f2958cdf4c6a1ac256c8a4">config.active_record.database_selector = { delay: 2.seconds } config.active_record.database_resolver = ActiveRecord::Middleware::DatabaseSelector::Resolver config.active_record.database_resolver_context = ActiveRecord::Middleware::DatabaseSelector::Resolver::Session </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-c2f34633e4f2958cdf4c6a1ac256c8a4">Copy</button>  <p>Rails guarantees "read your own write" and will send your GET or HEAD request to the writer if it's within the <code>delay</code> window. By default the delay is set to 2 seconds. You should change this based on your database infrastructure. Rails doesn't guarantee "read a recent write" for other users within the delay window and will send GET and HEAD requests to the replicas unless they wrote recently.</p>
<p>The automatic connection switching in Rails is relatively primitive and deliberately doesn't do a whole lot. The goal is a system that demonstrates how to do automatic connection switching that was flexible enough to be customizable by app developers.</p>
<p>The setup in Rails allows you to easily change how the switching is done and what parameters it's based on. Let's say you want to use a cookie instead of a session to decide when to swap connections. You can write your own class:</p> <pre data-language="ruby">class MyCookieResolver
  # code for your cookie class
end</pre> <textarea class="clipboard-content" id="clipboard-385902cfeab7371fb064490bbec46494">class MyCookieResolver # code for your cookie class end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-385902cfeab7371fb064490bbec46494">Copy</button>  <p>And then pass it to the middleware:</p> <pre data-language="ruby">config.active_record.database_selector = { delay: 2.seconds }
config.active_record.database_resolver = ActiveRecord::Middleware::DatabaseSelector::Resolver
config.active_record.database_resolver_context = MyCookieResolver</pre> <textarea class="clipboard-content" id="clipboard-1450ce31bc652fca4170cbe41b1476b8">config.active_record.database_selector = { delay: 2.seconds } config.active_record.database_resolver = ActiveRecord::Middleware::DatabaseSelector::Resolver config.active_record.database_resolver_context = MyCookieResolver </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-1450ce31bc652fca4170cbe41b1476b8">Copy</button>  <h2 id="using-manual-connection-switching"><a class="anchorlink" href="#using-manual-connection-switching">4 Using manual connection switching</a></h2>
<p>There are some cases where you may want your application to connect to a writer or a replica and the automatic connection switching isn't adequate. For example, you may know that for a particular request you always want to send the request to a replica, even when you are in a POST request path.</p>
<p>To do this Rails provides a <code>connected_to</code> method that will switch to the connection you need.</p> <pre data-language="ruby">ActiveRecord::Base.connected_to(role: :reading) do
  # all code in this block will be connected to the reading role
end</pre> <textarea class="clipboard-content" id="clipboard-2605e31e51364f76c9f7a8bea6cc8c02">ActiveRecord::Base.connected_to(role: :reading) do # all code in this block will be connected to the reading role end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-2605e31e51364f76c9f7a8bea6cc8c02">Copy</button>  <p>The "role" in the <code>connected_to</code> call looks up the connections that are connected on that connection handler (or role). The <code>reading</code> connection handler will hold all the connections that were connected via <code>connects_to</code> with the role name of <code>reading</code>.</p>
<p>Note that <code>connected_to</code> with a role will look up an existing connection and switch using the connection specification name. This means that if you pass an unknown role like <code>connected_to(role: :nonexistent)</code> you will get an error that says <code>ActiveRecord::ConnectionNotEstablished (No connection pool for 'ActiveRecord::Base' found for the 'nonexistent' role.)</code></p>
<h2 id="horizontal-sharding"><a class="anchorlink" href="#horizontal-sharding">5 Horizontal sharding</a></h2>
<p>Horizontal sharding is when you split up your database to reduce the number of rows on each database server, but maintain the same schema across "shards". This is commonly called "multi-tenant" sharding.</p>
<p>The API for supporting horizontal sharding in Rails is similar to the multiple database / vertical sharding API that's existed since Rails 6.0.</p>
<p>Shards are declared in the three-tier config like this:</p> <pre data-language="yaml">production:
  primary:
    database: my_primary_database
    adapter: mysql
  primary_replica:
    database: my_primary_database
    adapter: mysql
    replica: true
  primary_shard_one:
    database: my_primary_shard_one
    adapter: mysql
  primary_shard_one_replica:
    database: my_primary_shard_one
    adapter: mysql
    replica: true</pre> <textarea class="clipboard-content" id="clipboard-239e8cb4c266a1b8715989a0de1ecc3b">production: primary: database: my_primary_database adapter: mysql primary_replica: database: my_primary_database adapter: mysql replica: true primary_shard_one: database: my_primary_shard_one adapter: mysql primary_shard_one_replica: database: my_primary_shard_one adapter: mysql replica: true </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-239e8cb4c266a1b8715989a0de1ecc3b">Copy</button>  <p>Models are then connected with the <code>connects_to</code> API via the <code>shards</code> key:</p> <pre data-language="ruby">class ApplicationRecord &lt; ActiveRecord::Base
  self.abstract_class = true

  connects_to shards: {
    default: { writing: :primary, reading: :primary_replica },
    shard_one: { writing: :primary_shard_one, reading: :primary_shard_one_replica }
  }
end</pre> <textarea class="clipboard-content" id="clipboard-2784ee5a9c4dc765ad5629d333f34fe1">class ApplicationRecord &lt; ActiveRecord::Base self.abstract_class = true connects_to shards: { default: { writing: :primary, reading: :primary_replica }, shard_one: { writing: :primary_shard_one, reading: :primary_shard_one_replica } } end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-2784ee5a9c4dc765ad5629d333f34fe1">Copy</button>  <p>Then models can swap connections manually via the <code>connected_to</code> API. If using sharding both a <code>role</code> and <code>shard</code> must be passed:</p> <pre data-language="ruby">ActiveRecord::Base.connected_to(role: :writing, shard: :default) do
  @id = Person.create! # Creates a record in shard default
end

ActiveRecord::Base.connected_to(role: :writing, shard: :shard_one) do
  Person.find(@id) # Can't find record, doesn't exist because it was created
                   # in the default shard
end</pre> <textarea class="clipboard-content" id="clipboard-dbe0507e3f956a3e5d05c19d59899322">ActiveRecord::Base.connected_to(role: :writing, shard: :default) do @id = Person.create! # Creates a record in shard default end ActiveRecord::Base.connected_to(role: :writing, shard: :shard_one) do Person.find(@id) # Can't find record, doesn't exist because it was created # in the default shard end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-dbe0507e3f956a3e5d05c19d59899322">Copy</button>  <p>The horizontal sharding API also supports read replicas. You can swap the role and the shard with the <code>connected_to</code> API.</p> <pre data-language="ruby">ActiveRecord::Base.connected_to(role: :reading, shard: :shard_one) do
  Person.first # Lookup record from read replica of shard one
end</pre> <textarea class="clipboard-content" id="clipboard-7397294096fae3e3567df8f55687c2a1">ActiveRecord::Base.connected_to(role: :reading, shard: :shard_one) do Person.first # Lookup record from read replica of shard one end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-7397294096fae3e3567df8f55687c2a1">Copy</button>  <h2 id="granular-database-connection-switching"><a class="anchorlink" href="#granular-database-connection-switching">6 Granular Database Connection Switching</a></h2>
<p>In Rails 6.1 it's possible to switch connections for one database instead of all databases globally. To use this feature you must first set <code>config.active_record.legacy_connection_handling</code> to <code>false</code> in your application configuration. The majority of applications should not need to make any other changes since the public APIs have the same behavior.</p>
<p>With <code>legacy_connection_handling</code> set to false, any abstract connection class will be able to switch connections without affecting other connections. This is useful for switching your <code>AnimalsRecord</code> queries to read from the replica while ensuring your <code>ApplicationRecord</code> queries go to the primary.</p> <pre data-language="ruby">AnimalsRecord.connected_to(role: :reading) do
  Dog.first # Reads from animals_replica
  Person.first  # Reads from primary
end</pre> <textarea class="clipboard-content" id="clipboard-de831e9f97fbdf49995529dae696d610">AnimalsRecord.connected_to(role: :reading) do Dog.first # Reads from animals_replica Person.first # Reads from primary end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-de831e9f97fbdf49995529dae696d610">Copy</button>  <p>It's also possible to swap connections granularly for shards.</p> <pre data-language="ruby">AnimalsRecord.connected_to(role: :reading, shard: :shard_one) do
  Dog.first # Will read from shard_one_replica. If no connection exists for shard_one_replica,
  # a ConnectionNotEstablished error will be raised
  Person.first # Will read from primary writer
end</pre> <textarea class="clipboard-content" id="clipboard-03217377623b5947628674fad9201005">AnimalsRecord.connected_to(role: :reading, shard: :shard_one) do Dog.first # Will read from shard_one_replica. If no connection exists for shard_one_replica, # a ConnectionNotEstablished error will be raised Person.first # Will read from primary writer end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-03217377623b5947628674fad9201005">Copy</button>  <p>To switch only the primary database cluster use <code>ApplicationRecord</code>:</p> <pre data-language="ruby">ApplicationRecord.connected_to(role: :reading, shard: :shard_one) do
  Person.first # Reads from primary_shard_one_replica
  Dog.first # Reads from animals_primary
end</pre> <textarea class="clipboard-content" id="clipboard-a9f617ccc3aed0eff8e0c29e542f59d5">ApplicationRecord.connected_to(role: :reading, shard: :shard_one) do Person.first # Reads from primary_shard_one_replica Dog.first # Reads from animals_primary end </textarea> <button class="clipboard-button" data-clipboard-target="#clipboard-a9f617ccc3aed0eff8e0c29e542f59d5">Copy</button>  <p><code>ActiveRecord::Base.connected_to</code> maintains the ability to switch connections globally.</p>
<h2 id="caveats"><a class="anchorlink" href="#caveats">7 Caveats</a></h2>
<h3 id="automatic-swapping-for-horizontal-sharding"><a class="anchorlink" href="#automatic-swapping-for-horizontal-sharding">7.1 Automatic swapping for horizontal sharding</a></h3>
<p>While Rails now supports an API for connecting to and swapping connections of shards, it does not yet support an automatic swapping strategy. Any shard swapping will need to be done manually in your app via a middleware or <code>around_action</code>.</p>
<h3 id="load-balancing-replicas"><a class="anchorlink" href="#load-balancing-replicas">7.2 Load Balancing Replicas</a></h3>
<p>Rails also doesn't support automatic load balancing of replicas. This is very dependent on your infrastructure. We may implement basic, primitive load balancing in the future, but for an application at scale this should be something your application handles outside of Rails.</p>
<h3 id="joining-across-databases"><a class="anchorlink" href="#joining-across-databases">7.3 Joining Across Databases</a></h3>
<p>Applications cannot join across databases. Rails 6.1 will support using <code>has_many</code> relationships and creating 2 queries instead of joining, but Rails 6.0 will require you to split the joins into 2 selects manually.</p>
<h3 id="schema-cache"><a class="anchorlink" href="#schema-cache">7.4 Schema Cache</a></h3>
<p>If you use a schema cache and multiple databases you'll need to write an initializer that loads the schema cache from your app. This wasn't an issue we could resolve in time for Rails 6.0 but hope to have it in a future version soon.</p> <h2>Feedback</h2> <p> You're encouraged to help improve the quality of this guide. </p> <p> Please contribute if you see any typos or factual errors. To get started, you can read our <a href="https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#contributing-to-the-rails-documentation">documentation contributions</a> section. </p> <p> You may also find incomplete content or stuff that is not up to date. Please do add any missing documentation for master. Make sure to check <a href="https://edgeguides.rubyonrails.org">Edge Guides</a> first to verify if the issues are already fixed or not on the master branch. Check the <span>Ruby on Rails Guides Guidelines</span> for style and conventions. </p> <p> If for whatever reason you spot something to fix but cannot patch it yourself, please <a href="https://github.com/rails/rails/issues">open an issue</a>. </p> <p>And last but not least, any kind of discussion regarding Ruby on Rails documentation is very welcome on the <a href="https://discuss.rubyonrails.org/c/rubyonrails-docs">rubyonrails-docs mailing list</a>. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2004&ndash;2020 David Heinemeier Hansson<br>Licensed under the Creative Commons Attribution-ShareAlike 4.0 International License.<br>
    
  </p>
</div>
