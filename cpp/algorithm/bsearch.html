   <h1 id="firstHeading" class="firstHeading">std::bsearch</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/cstdlib" title="cpp/header/cstdlib">&lt;cstdlib&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void* bsearch( const void* key, const void* ptr, std::size_t count,
               std::size_t size, /*compare-pred*/* comp );
void* bsearch( const void* key, const void* ptr, std::size_t count,
               std::size_t size, /*c-compare-pred*/* comp );</pre>
</td> <td> (1) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">extern "C++" using /*compare-pred*/ = int(const void*, const void*); // exposition-only
extern "C" using /*c-compare-pred*/ = int(const void*, const void*); // exposition-only</pre>
</td> <td> (2) </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>Finds an element equal to element pointed to by <code>key</code> in an array pointed to by <code>ptr</code>. The array contains <code>count</code> elements of <code>size</code> bytes each and must be partitioned with respect to the object pointed to by <code>key</code>, that is, all the elements that compare less than must appear before all the elements that compare equal to, and those must appear before all the elements that compare greater than the key object. A fully sorted array satisfies these requirements. The elements are compared using function pointed to by <code>comp</code>.</p>
<p>The behavior is undefined if the array is not already partitioned in ascending order with respect to key, according to the same criterion that <code>comp</code> uses.</p>
<p>If the array contains several elements that <code>comp</code> would indicate as equal to the element searched for, then it is unspecified which element the function will return as the result.</p>
<h3 id="Parameters">Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> key </td> <td> - </td> <td> pointer to the element to search for </td>
</tr> <tr class="t-par"> <td> ptr </td> <td> - </td> <td> pointer to the array to examine </td>
</tr> <tr class="t-par"> <td> count </td> <td> - </td> <td> number of element in the array </td>
</tr> <tr class="t-par"> <td> size </td> <td> - </td> <td> size of each element in the array in bytes </td>
</tr> <tr class="t-par"> <td> comp </td> <td> - </td> <td> comparison function which returns ​a negative integer value if the first argument is <i>less</i> than the second, <br> <p>a positive integer value if the first argument is <i>greater</i> than the second and zero if the arguments are equal. <code>key</code> is passed as the first argument, an element from the array as the second.<br> The signature of the comparison function should be equivalent to the following:</p>
<p><span class="t-cc"><code> int cmp(const void *a, const void *b);</code></span></p>
<p>The function must not modify the objects passed to it and must return consistent results when called for the same objects, regardless of their positions in the array.</p>
<p>​</p>
</td>
</tr>
</table> <h3 id="Return_value">Return value</h3> <p>Pointer to the found element or null pointer if the element has not been found.</p>
<h3 id="Notes">Notes</h3> <p>Despite the name, neither C nor POSIX standards require this function to be implemented using binary search or make any complexity guarantees.</p>
<p>The two overloads provided by the C++ standard library are distinct because the types of the parameter <code>comp</code> are distinct (<a href="../language/language_linkage" title="cpp/language/language linkage">language linkage</a> is part of its type).</p>
<h3 id="Example">Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
 
int compare(const void *ap, const void *bp)
{
    const int *a = (int *) ap;
    const int *b = (int *) bp;
    if(*a &lt; *b)
        return -1;
    else if(*a &gt; *b)
        return 1;
    else
        return 0;
}
 
int main(int argc, char **argv)
{
    const int ARR_SIZE = 8;
    int arr[ARR_SIZE] = { 1, 2, 3, 4, 5, 6, 7, 8 };
 
    int key1 = 4;
    int *p1 = (int *) std::bsearch(&amp;key1, arr, ARR_SIZE, sizeof(arr[0]), compare);
    if(p1)
        std::cout &lt;&lt; "value " &lt;&lt; key1 &lt;&lt; " found at position " &lt;&lt; (p1 - arr) &lt;&lt; '\n';
     else
        std::cout &lt;&lt; "value " &lt;&lt; key1 &lt;&lt; " not found\n";
 
    int key2 = 9;
    int *p2 = (int *) std::bsearch(&amp;key2, arr, ARR_SIZE, sizeof(arr[0]), compare);
    if(p2)
        std::cout &lt;&lt; "value " &lt;&lt; key2 &lt;&lt; " found at position " &lt;&lt; (p2 - arr) &lt;&lt; '\n';
     else
        std::cout &lt;&lt; "value " &lt;&lt; key2 &lt;&lt; " not found\n";
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">value 4 found at position 3
value 9 not found</pre></div> </div> <h3 id="See_also">See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="qsort" title="cpp/algorithm/qsort"> <span class="t-lines"><span>qsort</span></span></a></div> </td> <td> sorts a range of elements with unspecified type <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="equal_range" title="cpp/algorithm/equal range"> <span class="t-lines"><span>equal_range</span></span></a></div> </td> <td> returns range of elements matching a specific key <br> <span class="t-mark">(function template)</span> </td>
</tr> </table>          <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/algorithm/bsearch" class="_attribution-link">http://en.cppreference.com/w/cpp/algorithm/bsearch</a>
  </p>
</div>
