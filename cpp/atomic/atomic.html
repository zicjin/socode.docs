   <h1 id="firstHeading" class="firstHeading">std::atomic</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/atomic" title="cpp/header/atomic">&lt;atomic&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class T &gt;
struct atomic;</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class T &gt;
struct atomic&lt;T*&gt;;</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/memory" title="cpp/header/memory">&lt;memory&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt;class T&gt;
struct atomic&lt;std::shared_ptr&lt;T&gt;&gt;;</pre>
</td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt;class T&gt;
struct atomic&lt;std::weak_ptr&lt;T&gt;&gt;;</pre>
</td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>  </table> <p>Each instantiation and full specialization of the <code>std::atomic</code> template defines an atomic type. If one thread writes to an atomic object while another thread reads from it, the behavior is well-defined (see <a href="../language/memory_model" title="cpp/language/memory model">memory model</a> for details on data races).</p>
<p>In addition, accesses to atomic objects may establish inter-thread synchronization and order non-atomic memory accesses as specified by <code><a href="memory_order" title="cpp/atomic/memory order">std::memory_order</a></code>.</p>
<p>std::atomic is neither copyable nor movable.</p>
<h3 id="Specializations"> Specializations </h3> <h4 id="Primary_template">Primary template</h4> <p>The primary <code>std::atomic</code> template may be instantiated with any <a href="../named_req/triviallycopyable" title="cpp/named req/TriviallyCopyable">TriviallyCopyable</a> type <code>T</code> satisfying both <a href="../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a> and <a href="../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>. The program is ill-formed if any of following values is <code>false</code>:</p>
<ul>
<li> <code><a href="../types/is_trivially_copyable"><span class="kw500">std::<span class="me2">is_trivially_copyable</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span></code> </li>
<li> <code><a href="../types/is_copy_constructible"><span class="kw532">std::<span class="me2">is_copy_constructible</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span></code> </li>
<li> <code><a href="../types/is_move_constructible"><span class="kw538">std::<span class="me2">is_move_constructible</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span></code> </li>
<li> <code><a href="../types/is_copy_assignable"><span class="kw550">std::<span class="me2">is_copy_assignable</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span></code> </li>
<li> <code><a href="../types/is_move_assignable"><span class="kw556">std::<span class="me2">is_move_assignable</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span></code> </li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">struct Counters { int a; int b; }; // user-defined trivially-copyable type
std::atomic&lt;Counters&gt; cnt;         // specialization for the user-defined type</pre></div> <p><code>std::atomic&lt;bool&gt;</code> uses the primary template. It is guaranteed to be a standard layout struct.</p>
<h4 id="Partial_specializations">Partial specializations</h4> <p>The standard library provides partial specializations of the <code>std::atomic</code> template for the following types with additional properties that the primary template does not have:</p>
<p>2) Partial specializations <code>std::atomic&lt;T*&gt;</code> for all pointer types. These specializations have standard layout, trivial default constructors, and trivial destructors. Besides the operations provided for all atomic types, these specializations additionally support atomic arithmetic operations appropriate to pointer types, such as <a href="atomic/fetch_add" title="cpp/atomic/atomic/fetch add"><code>fetch_add</code></a>, <a href="atomic/fetch_sub" title="cpp/atomic/atomic/fetch sub"><code>fetch_sub</code></a>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>3-4) Partial specializations <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../memory/shared_ptr"><span class="kw729">std::<span class="me2">shared_ptr</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;&gt;</span></code> and <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../memory/weak_ptr"><span class="kw736">std::<span class="me2">weak_ptr</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;&gt;</span></code> are provided for <code><a href="../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code> and <code><a href="../memory/weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>.</p>
<p>See <a href="../memory/shared_ptr/atomic2" title="cpp/memory/shared ptr/atomic2">std::atomic<span class="t-dsc-small">&lt;std::shared_ptr&gt;</span></a> and <a href="../memory/weak_ptr/atomic2" title="cpp/memory/weak ptr/atomic2">std::atomic<span class="t-dsc-small">&lt;std::weak_ptr&gt;</span></a> for details.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <h4 id="Specializations_for_integral_types"> Specializations for integral types </h4> <p>When instantiated with one of the following integral types, <code>std::atomic</code> provides additional atomic operations appropriate to integral types such as <a href="atomic/fetch_add" title="cpp/atomic/atomic/fetch add"><code>fetch_add</code></a>, <a href="atomic/fetch_sub" title="cpp/atomic/atomic/fetch sub"><code>fetch_sub</code></a>, <a href="atomic/fetch_and" title="cpp/atomic/atomic/fetch and"><code>fetch_and</code></a>, <a href="atomic/fetch_or" title="cpp/atomic/atomic/fetch or"><code>fetch_or</code></a>, <a href="atomic/fetch_xor" title="cpp/atomic/atomic/fetch xor"><code>fetch_xor</code></a>:</p>
<ul>
<li> The character types <code>char</code><span class="t-rev-inl t-since-cxx20"><span>, <code>char8_t</code></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>, <code>char16_t</code>, <code>char32_t</code>, and <code>wchar_t</code>; </li>
<li> The standard signed integer types: <code>signed char</code>, <code>short</code>, <code>int</code>, <code>long</code>, and <code>long long</code>; </li>
<li> The standard unsigned integer types: <code>unsigned char</code>, <code>unsigned short</code>, <code>unsigned int</code>, <code>unsigned long</code>, and <code>unsigned long long</code>; </li>
<li> Any additional integral types needed by the typedefs in the header <a href="../header/cstdint" title="cpp/header/cstdint"><code>&lt;cstdint&gt;</code></a>. </li>
</ul> <p>Additionally, the resulting <code>std::atomic&lt;<i>Integral</i>&gt;</code> specialization has standard layout, a trivial default constructor, and a trivial destructor. Signed integer arithmetic is defined to use two's complement; there are no undefined results.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <h4 id="Specializations_for_floating-point_types">  Specializations for floating-point types </h4> <p>When instantiated with one of the floating-point types <code>float</code>, <code>double</code>, and <code>long double</code>, <code>std::atomic</code> provides additional atomic operations appropriate to floating-point types such as <a href="atomic/fetch_add" title="cpp/atomic/atomic/fetch add"><code>fetch_add</code></a> and <a href="atomic/fetch_sub" title="cpp/atomic/atomic/fetch sub"><code>fetch_sub</code></a>.</p>
<p>Additionally, the resulting <code>std::atomic&lt;<i>Floating</i>&gt;</code> specialization has standard layout, a trivial default constructor, and a trivial destructor.</p>
<p>No operations result in undefined behavior even if the result is not representable in the floating-point type. The <a href="../numeric/fenv" title="cpp/numeric/fenv">floating-point environment</a> in effect may be different from the calling thread's floating-point environment.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <h3 id="Type_aliases"> Type aliases </h3> <p>Type aliases are provided for <code>bool</code> and all integral types listed above, as follows:</p>
<table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Type alias </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_bool</code> </td> <td> <code>std::atomic&lt;bool&gt;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_char</code> </td> <td> <code>std::atomic&lt;char&gt;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_schar</code> </td> <td> <code>std::atomic&lt;signed char&gt;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_uchar</code> </td> <td> <code>std::atomic&lt;unsigned char&gt;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_short</code> </td> <td> <code>std::atomic&lt;short&gt;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_ushort</code> </td> <td> <code>std::atomic&lt;unsigned short&gt;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_int</code> </td> <td> <code>std::atomic&lt;int&gt;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_uint</code> </td> <td> <code>std::atomic&lt;unsigned int&gt;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_long</code> </td> <td> <code>std::atomic&lt;long&gt;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_ulong</code> </td> <td> <code>std::atomic&lt;unsigned long&gt;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_llong</code> </td> <td> <code>std::atomic&lt;long long&gt;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_ullong</code> </td> <td> <code>std::atomic&lt;unsigned long long&gt;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_char8_t</code> </td> <td> <code>std::atomic&lt;char8_t&gt;</code> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_char16_t</code> </td> <td> <code>std::atomic&lt;char16_t&gt;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_char32_t</code> </td> <td> <code>std::atomic&lt;char32_t&gt;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_wchar_t</code> </td> <td> <code>std::atomic&lt;wchar_t&gt;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_int8_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw106">std::<span class="me2">int8_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_uint8_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw120">std::<span class="me2">uint8_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_int16_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw107">std::<span class="me2">int16_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_uint16_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw121">std::<span class="me2">uint16_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_int32_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw108">std::<span class="me2">int32_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_uint32_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw122">std::<span class="me2">uint32_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_int64_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw109">std::<span class="me2">int64_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_uint64_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw123">std::<span class="me2">uint64_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_int_least8_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw114">std::<span class="me2">int_least8_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_uint_least8_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw128">std::<span class="me2">uint_least8_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_int_least16_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw115">std::<span class="me2">int_least16_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_uint_least16_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw129">std::<span class="me2">uint_least16_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_int_least32_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw116">std::<span class="me2">int_least32_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_uint_least32_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw130">std::<span class="me2">uint_least32_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_int_least64_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw117">std::<span class="me2">int_least64_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_uint_least64_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw131">std::<span class="me2">uint_least64_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_int_fast8_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw110">std::<span class="me2">int_fast8_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_uint_fast8_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw124">std::<span class="me2">uint_fast8_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_int_fast16_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw111">std::<span class="me2">int_fast16_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_uint_fast16_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw125">std::<span class="me2">uint_fast16_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_int_fast32_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw112">std::<span class="me2">int_fast32_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_uint_fast32_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw126">std::<span class="me2">uint_fast32_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_int_fast64_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw113">std::<span class="me2">int_fast64_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_uint_fast64_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw127">std::<span class="me2">uint_fast64_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_intptr_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw119">std::<span class="me2">intptr_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_uintptr_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw133">std::<span class="me2">uintptr_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_size_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/size_t"><span class="kw100">std::<span class="me2">size_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_ptrdiff_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/ptrdiff_t"><span class="kw101">std::<span class="me2">ptrdiff_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_intmax_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw118">std::<span class="me2">intmax_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>std::atomic_uintmax_t</code> </td> <td> <code>std<span class="sy4">::</span><span class="me2">atomic</span><span class="sy1">&lt;</span><a href="../types/integer"><span class="kw132">std::<span class="me2">uintmax_t</span></span></a><span class="sy1">&gt;</span></code> </td>
</tr> </table> <p>Note: <code>std::atomic_int<i>N</i>_t</code>, <code>std::atomic_uint<i>N</i>_t</code>, <code>std::atomic_intptr_t</code>, and <code>atomic_uintptr_t</code> are defined if and only if <code>std::int<i>N</i>_t</code>, <code>std::uint<i>N</i>_t</code>, <code>std::intptr_t</code>, and <code>std::uintptr_t</code> are defined, respectively.</p>
<h3 id="Member_types">Member types</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Member type </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> <code>value_type</code> </td> <td> <i>see below</i> </td>
</tr> <tr class="t-dsc"> <td> <code>difference_type</code> </td> <td> <code>value_type</code> <span class="t-mark">(only for <code>atomic&lt;<i>Integral</i>&gt;</code> <span class="t-rev-inl t-since-cxx20"><span>and <code>atomic&lt;<i>Floating</i>&gt;</code></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> specializations)</span><br> <code><a href="../types/ptrdiff_t" title="cpp/types/ptrdiff t">std::ptrdiff_t</a></code> <span class="t-mark">(only for <code>atomic&lt;T*&gt;</code> specializations)</span> </td>
</tr> </table> <p>For every <code>std::atomic&lt;X&gt;</code> (whether or not specialized), <code>std::atomic&lt;X&gt;::value_type</code> is <code>X</code>.</p>
<p><code>difference_type</code> is not defined in the primary <code>atomic</code> template or in the partial specializations for <code><a href="../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code> and <code><a href="../memory/weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>.</p>
<h3 id="Member_functions">Member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="atomic/atomic" title="cpp/atomic/atomic/atomic"> <span class="t-lines"><span>(constructor)</span></span></a></div> </td> <td> constructs an atomic object <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="atomic/operator=" title="cpp/atomic/atomic/operator="> <span class="t-lines"><span>operator=</span></span></a></div> </td> <td> stores a value into an atomic object <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="atomic/is_lock_free" title="cpp/atomic/atomic/is lock free"> <span class="t-lines"><span>is_lock_free</span></span></a></div> </td> <td> checks if the atomic object is lock-free <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="atomic/store" title="cpp/atomic/atomic/store"> <span class="t-lines"><span>store</span></span></a></div> </td> <td> atomically replaces the value of the atomic object with a non-atomic argument <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="atomic/load" title="cpp/atomic/atomic/load"> <span class="t-lines"><span>load</span></span></a></div> </td> <td> atomically obtains the value of the atomic object <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="atomic/operator_t" title="cpp/atomic/atomic/operator T"> <span class="t-lines"><span>operator T</span></span></a></div> </td> <td> loads a value from an atomic object <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="atomic/exchange" title="cpp/atomic/atomic/exchange"> <span class="t-lines"><span>exchange</span></span></a></div> </td> <td> atomically replaces the value of the atomic object and obtains the value held previously <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="atomic/compare_exchange" title="cpp/atomic/atomic/compare exchange"> <span class="t-lines"><span>compare_exchange_weak</span><span>compare_exchange_strong</span></span></a></div> </td> <td> atomically compares the value of the atomic object with non-atomic argument and performs atomic exchange if equal or atomic load if not <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr> <td colspan="2"> <h3 id="Constants">  Constants</h3> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="atomic/is_always_lock_free" title="cpp/atomic/atomic/is always lock free"> <span class="t-lines"><span>is_always_lock_free</span></span></a></div>
<div><span class="t-lines"><span><span class="t-cmark">[static]</span> <span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> indicates that the type is always lock-free <br> <span class="t-mark">(public static member constant)</span> </td>
</tr> </table> <h3 id="Specialized_member_functions">Specialized member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="atomic/fetch_add" title="cpp/atomic/atomic/fetch add"> <span class="t-lines"><span>fetch_add</span></span></a></div> </td> <td> atomically adds the argument to the value stored in the atomic object and obtains the value held previously <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="atomic/fetch_sub" title="cpp/atomic/atomic/fetch sub"> <span class="t-lines"><span>fetch_sub</span></span></a></div> </td> <td> atomically subtracts the argument from the value stored in the atomic object and obtains the value held previously <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="atomic/fetch_and" title="cpp/atomic/atomic/fetch and"> <span class="t-lines"><span>fetch_and</span></span></a></div> </td> <td> atomically performs bitwise AND between the argument and the value of the atomic object and obtains the value held previously <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="atomic/fetch_or" title="cpp/atomic/atomic/fetch or"> <span class="t-lines"><span>fetch_or</span></span></a></div> </td> <td> atomically performs bitwise OR between the argument and the value of the atomic object and obtains the value held previously <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="atomic/fetch_xor" title="cpp/atomic/atomic/fetch xor"> <span class="t-lines"><span>fetch_xor</span></span></a></div> </td> <td> atomically performs bitwise XOR between the argument and the value of the atomic object and obtains the value held previously <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="atomic/operator_arith" title="cpp/atomic/atomic/operator arith"> <span class="t-lines"><span>operator++</span><span>operator++<span class="t-dsc-small">(int)</span></span><span>operator--</span><span>operator--<span class="t-dsc-small">(int)</span></span></span></a></div> </td> <td> increments or decrements the atomic value by one <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="atomic/operator_arith2" title="cpp/atomic/atomic/operator arith2"> <span class="t-lines"><span>operator+=</span><span>operator-=</span><span>operator&amp;=</span><span>operator|=</span><span>operator^=</span></span></a></div> </td> <td> adds, subtracts, or performs bitwise AND, OR, XOR with the atomic value <br> <span class="t-mark">(public member function)</span> </td>
</tr> </table> <h3 id="Notes">Notes</h3> <p>There are non-member function template equivalents for all member functions of <code>std::atomic</code>. Those non-member functions may be additionally overloaded for types that are not specializations of <code>std::atomic</code>, but are able to guarantee atomicity. The only such type in the standard library is <code><a href="../memory/shared_ptr"><span class="kw729">std::<span class="me2">shared_ptr</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span></code>.</p>
<p>On gcc and clang, some of the functionality described here requires linking against <code>-latomic</code>.</p>
<h3 id="Defect_reports">Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2441">LWG 2441</a> </td> <td> C++11 </td> <td> </td> <td> added specializations for the <span class="t-mark">(optional)</span> <a href="../types/integer" title="cpp/types/integer">fixed width integer types</a> </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/P0558R1">P0558R1</a> </td> <td> C++11 </td> <td> </td> <td> specification was substantially rewritten to resolve numerous issues<br>in particular, member typedefs value_type and difference_type are added </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue3012">LWG 3012</a> </td> <td> C++11 </td> <td> <code>std::atomic&lt;T&gt;</code> was permitted for<br>any <code>T</code> that is trivially copyable but not copyable </td> <td> such specializations are forbidden </td>
</tr>
</table> <h3 id="See_also">See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="atomic_flag" title="cpp/atomic/atomic flag"> <span class="t-lines"><span>atomic_flag</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> the lock-free boolean atomic type <br> <span class="t-mark">(class)</span> </td>
</tr> </table>          <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/atomic/atomic" class="_attribution-link">http://en.cppreference.com/w/cpp/atomic/atomic</a>
  </p>
</div>
