    <h1 id="firstHeading" class="firstHeading">std::reverse_iterator</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/iterator" title="cpp/header/iterator">&lt;iterator&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">template&lt; class Iter &gt;
class reverse_iterator;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p><code>std::reverse_iterator</code> is an iterator adaptor that reverses the direction of a given iterator, which must be at least a <a href="../named_req/bidirectionaliterator" title="cpp/named req/BidirectionalIterator">LegacyBidirectionalIterator</a><span class="t-rev-inl t-since-cxx20"><span> or model <a href="bidirectional_iterator" title="cpp/iterator/bidirectional iterator"><code>bidirectional_iterator</code></a></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>. In other words, when provided with a bidirectional iterator, <code>std::reverse_iterator</code> produces a new iterator that moves from the end to the beginning of the sequence defined by the underlying bidirectional iterator.</p>
<p>For a reverse iterator <code>r</code> constructed from an iterator <code>i</code>, the relationship <code>&amp;*r == &amp;*(i-1)</code> is always true (as long as <code>r</code> is dereferenceable); thus a reverse iterator constructed from a one-past-the-end iterator dereferences to the last element in a sequence.</p>
<p>This is the iterator returned by member functions <code>rbegin()</code> and <code>rend()</code> of the standard library containers.</p>
<p><img alt="range-rbegin-rend.svg" src="" width="589" height="250"></p>
<h3 id="Member_types"> Member types</h3> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Member type </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> <code>iterator_type</code> </td> <td> <code>Iter</code> </td>
</tr> <tr class="t-dsc"> <td> <code>iterator_category</code> </td> <td> <code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw653">std::<span class="me2">iterator_traits</span></span></a><span class="sy1">&lt;</span>Iter<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">iterator_category</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>value_type</code> </td> <td> <code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw653">std::<span class="me2">iterator_traits</span></span></a><span class="sy1">&lt;</span>Iter<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value_type</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>difference_type</code> </td> <td> <code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw653">std::<span class="me2">iterator_traits</span></span></a><span class="sy1">&lt;</span>Iter<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">difference_type</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>pointer</code> </td> <td> <code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw653">std::<span class="me2">iterator_traits</span></span></a><span class="sy1">&lt;</span>Iter<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">pointer</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>reference</code> </td> <td> <code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw653">std::<span class="me2">iterator_traits</span></span></a><span class="sy1">&lt;</span>Iter<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">reference</span></code> </td>
</tr> </table> </td> <td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Member type </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> <code>iterator_type</code> </td> <td> <code>Iter</code> </td>
</tr> <tr class="t-dsc"> <td> <code>iterator_concept</code> </td> <td> If <code>Iter</code> models <code><a href="http://en.cppreference.com/w/cpp/iterator/random_access_iterator"><span class="kw2870">std::<span class="me2">random_access_iterator</span></span></a></code>, this is <code><a href="iterator_tags" title="cpp/iterator/iterator tags">std::random_access_iterator_tag</a></code>. Otherwise, this is <code><a href="iterator_tags" title="cpp/iterator/iterator tags">std::bidirectional_iterator_tag</a></code> </td>
</tr> <tr class="t-dsc"> <td> <code>iterator_category</code> </td> <td> If <code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw653">std::<span class="me2">iterator_traits</span></span></a><span class="sy1">&lt;</span>Iter<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">iterator_category</span></code> models <code><a href="http://en.cppreference.com/w/cpp/concepts/derived_from"><span class="kw2936">std::<span class="me2">derived_from</span></span></a><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/iterator/iterator_tags"><span class="kw658">std::<span class="me2">random_access_iterator_tag</span></span></a><span class="sy1">&gt;</span></code>, this is <code><a href="iterator_tags" title="cpp/iterator/iterator tags">std::random_access_iterator_tag</a></code>. Otherwise, this is <code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw653">std::<span class="me2">iterator_traits</span></span></a><span class="sy1">&lt;</span>Iter<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">iterator_category</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>value_type</code> </td> <td> <code><a href="http://en.cppreference.com/w/cpp/iterator/iter_t"><span class="kw2874">std::<span class="me2">iter_value_t</span></span></a><span class="sy1">&lt;</span>Iter<span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>difference_type</code> </td> <td> <code><a href="http://en.cppreference.com/w/cpp/iterator/iter_t"><span class="kw2877">std::<span class="me2">iter_difference_t</span></span></a><span class="sy1">&lt;</span>Iter<span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>pointer</code> </td> <td> <code><a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw653">std::<span class="me2">iterator_traits</span></span></a><span class="sy1">&lt;</span>Iter<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">pointer</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>reference</code> </td> <td> <code><a href="http://en.cppreference.com/w/cpp/iterator/iter_t"><span class="kw2875">std::<span class="me2">iter_reference_t</span></span></a><span class="sy1">&lt;</span>Iter<span class="sy1">&gt;</span></code> </td>
</tr> </table> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <p>Member types <code>iterator_category</code>, <code>value_type</code>, <code>difference_type</code>, <code>pointer</code> and <code>reference</code> are required to be obtained by inheriting from <code><a href="http://en.cppreference.com/w/cpp/iterator/iterator"><span class="kw659">std::<span class="me2">iterator</span></span></a><span class="sy1">&lt;</span><br> <a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw653">std::<span class="me2">iterator_traits</span></span></a><span class="sy1">&lt;</span>Iter<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">iterator_category</span><br> , <a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw653">std::<span class="me2">iterator_traits</span></span></a><span class="sy1">&lt;</span>Iter<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value_type</span><br> , <a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw653">std::<span class="me2">iterator_traits</span></span></a><span class="sy1">&lt;</span>Iter<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">difference_type</span><br> , <a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw653">std::<span class="me2">iterator_traits</span></span></a><span class="sy1">&lt;</span>Iter<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">pointer</span><br> , <a href="http://en.cppreference.com/w/cpp/iterator/iterator_traits"><span class="kw653">std::<span class="me2">iterator_traits</span></span></a><span class="sy1">&lt;</span>Iter<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">reference</span><br> <span class="sy1">&gt;</span></code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> </table> <h3 id="Member_functions"> Member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="reverse_iterator/reverse_iterator" title="cpp/iterator/reverse iterator/reverse iterator"> <span class="t-lines"><span>(constructor)</span></span></a></div> </td> <td> constructs a new iterator adaptor <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="reverse_iterator/operator=" title="cpp/iterator/reverse iterator/operator="> <span class="t-lines"><span>operator=</span></span></a></div> </td> <td> assigns another iterator adaptor <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="reverse_iterator/base" title="cpp/iterator/reverse iterator/base"> <span class="t-lines"><span>base</span></span></a></div> </td> <td> accesses the underlying iterator <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="reverse_iterator/operator*" title="cpp/iterator/reverse iterator/operator*"> <span class="t-lines"><span>operator*</span><span>operator-&gt;</span></span></a></div> </td> <td> accesses the pointed-to element <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="reverse_iterator/operator_at" title="cpp/iterator/reverse iterator/operator at"> <span class="t-lines"><span>operator[]</span></span></a></div> </td> <td> accesses an element by index <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="reverse_iterator/operator_arith" title="cpp/iterator/reverse iterator/operator arith"> <span class="t-lines"><span>operator++</span><span>operator++<span class="t-dsc-small">(int)</span></span><span>operator+=</span><span>operator+</span><span>operator--</span><span>operator--<span class="t-dsc-small">(int)</span></span><span>operator-=</span><span>operator-</span></span></a></div> </td> <td> advances or decrements the iterator <br> <span class="t-mark">(public member function)</span>  </td>
</tr> </table> <h3 id="Member_objects"> Member objects</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Member name </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> <code>current</code> <span class="t-mark">(protected)</span> </td> <td> the underlying iterator of which <a href="reverse_iterator/base" title="cpp/iterator/reverse iterator/base"><code>base()</code></a> returns a copy </td>
</tr> </table> <h3 id="Non-member_functions"> Non-member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="reverse_iterator/operator_cmp" title="cpp/iterator/reverse iterator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span><span>operator&lt;=&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> compares the underlying iterators <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="reverse_iterator/operator_plus_" title="cpp/iterator/reverse iterator/operator+"> <span class="t-lines"><span>operator+</span></span></a></div> </td> <td> advances the iterator <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="reverse_iterator/operator-" title="cpp/iterator/reverse iterator/operator-"> <span class="t-lines"><span>operator-</span></span></a></div> </td> <td> computes the distance between two iterator adaptors <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="reverse_iterator/iter_move" title="cpp/iterator/reverse iterator/iter move"> <span class="t-lines"><span>iter_move</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> casts the result of dereferencing the adjusted underlying iterator to its associated rvalue reference type <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="reverse_iterator/iter_swap" title="cpp/iterator/reverse iterator/iter swap"> <span class="t-lines"><span>iter_swap</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> swaps the objects pointed to by two adjusted underlying iterators <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="make_reverse_iterator" title="cpp/iterator/make reverse iterator"> <span class="t-lines"><span>make_reverse_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> creates a <code>std::reverse_iterator</code> of type inferred from the argument <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table> <h3 id="Helper_templates"> Helper templates</h3> <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt; class Iterator1, class Iterator2 &gt;
    requires (!std::sized_sentinel_for&lt;Iterator1, Iterator2&gt;)
inline constexpr bool disable_sized_sentinel_for&lt;
    std::reverse_iterator&lt;Iterator1&gt;, 
    std::reverse_iterator&lt;Iterator2&gt;&gt; = true;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>  </table> <p>This partial specialization of <code>std::disable_sized_sentinel_for</code> prevents specializations of <code>reverse_iterator</code> from satisfying <a href="sized_sentinel_for" title="cpp/iterator/sized sentinel for"><code>sized_sentinel_for</code></a> if their underlying iterators do not satisfy the concept.</p>
<h3 id="Possible_implementation"> Possible implementation</h3> <p>Below is a partial implementation focusing on the way the inner iterator is saved, calling prev only when the content is fetched via operator*.</p>
<table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename Itr&gt;
class reverse_iterator {
    Itr itr;
public:
    constexpr explicit reverse_iterator(Itr itr): itr(itr) {}
    constexpr auto&amp; operator*() {
        return *std::prev(itr); // &lt;== returns the content of prev
    }
    constexpr auto&amp; operator++() {
        --itr;
        return *this;
    }
    constexpr friend bool operator!=(reverse_iterator&lt;Itr&gt; a, reverse_iterator&lt;Itr&gt; b) {
        return a.itr != b.itr;
    }
};</pre></div> </td>
</tr>
</table> <h3 id="Notes"> Notes</h3> <p><code>std::reverse_iterator</code> does not work with iterators whose dereference returns a reference to a member of <code>*this</code> (so-called "stashing iterators").</p>
<h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;iterator&gt;
 
template&lt;typename T, size_t SIZE&gt;
class Stack {
    T arr[SIZE];
    size_t pos = 0;
public:
    T pop() {
        return arr[--pos];
    }
    Stack&amp; push(const T&amp; t) {
        arr[pos++] = t;
        return *this;
    }
    // we wish that looping on Stack would be in LIFO order
    // thus we use std::reverse_iterator as an adaptor to existing iterators
    // (which are in this case the simple pointers: [arr, arr+pos)
    auto begin() {
        return std::reverse_iterator(arr + pos);
    }
    auto end() {
        return std::reverse_iterator(arr);
    }
};
 
int main() {
    Stack&lt;int, 8&gt; s;
    s.push(5).push(15).push(25).push(35);
    for(int val: s) {
        std::cout &lt;&lt; val &lt;&lt; ' ';
    }
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">35 25 15 5</pre></div> </div> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="make_reverse_iterator" title="cpp/iterator/make reverse iterator"> <span class="t-lines"><span>make_reverse_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> creates a <code>std::reverse_iterator</code> of type inferred from the argument <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="iterator" title="cpp/iterator/iterator"> <span class="t-lines"><span>iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span></span></div> </td> <td> base class to ease the definition of required types for simple iterators <br> <span class="t-mark">(class template)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/iterator/reverse_iterator" class="_attribution-link">https://en.cppreference.com/w/cpp/iterator/reverse_iterator</a>
  </p>
</div>
