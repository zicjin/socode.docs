   <h1 id="firstHeading" class="firstHeading">std::basic_string&lt;CharT,Traits,Allocator&gt;::operator=</h1>            <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">basic_string&amp; operator=( const basic_string&amp; str );</pre>
</td> <td> (1) </td> <td class="t-dcl-nopad"> </td> </tr>  <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx17"> <td> <pre data-language="cpp">basic_string&amp; operator=( basic_string&amp;&amp; str );</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> <br><span class="t-mark-rev t-until-cxx17">(until C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">basic_string&amp; operator=( basic_string&amp;&amp; str ) noexcept(/* see below */);</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  <tr class="t-dcl"> <td> <pre data-language="cpp">basic_string&amp; operator=( const CharT* s );</pre>
</td> <td> (3) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">basic_string&amp; operator=( CharT ch );</pre>
</td> <td> (4) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">basic_string&amp; operator=( std::initializer_list&lt;CharT&gt; ilist );</pre>
</td> <td> (5) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">template&lt;class T&gt;
basic_string&amp; operator=( const T&amp; t );</pre>
</td> <td> (6) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  </table> <p>Replaces the contents of the string.</p>
<div class="t-li1">
<span class="t-li">1)</span> Replaces the contents with a copy of <code>str</code>. If <code>*this</code> and <code>str</code> are the same object, this function has no effect.</div> <div class="t-li1">
<span class="t-li">2)</span> Replaces the contents with those of <code>str</code> using move semantics. <code>str</code> is in a valid but unspecified state afterwards. If <code>std::allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment()</code> is <code>true</code>, the target allocator is replaced by a copy of the source allocator. If it is <code>false</code> and the source and the target allocators do not compare equal, the target cannot take ownership of the source memory and must assign each character individually, allocating additional memory using its own allocator as needed. Unlike other container move assignments, references, pointers, and iterators to <code>str</code> may be invalidated.</div> <div class="t-li1">
<span class="t-li">3)</span> Replaces the contents with those of null-terminated character string pointed to by <code>s</code> as if by <code>assign(s, Traits::length(s))</code>.</div> <div class="t-li1">
<span class="t-li">4)</span> Replaces the contents with character <code>ch</code> as if by <code>assign<span class="br0">(</span><a href="../../memory/addressof"><span class="kw752">std::<span class="me2">addressof</span></span></a><span class="br0">(</span>ch<span class="br0">)</span>, <span class="nu0">1</span><span class="br0">)</span></code>
</div> <div class="t-li1">
<span class="t-li">5)</span> Replaces the contents with those of the initializer list <code>ilist</code> as if by <code>assign(ilist.begin(), ilist.size())</code>
</div> <div class="t-li1">
<span class="t-li">6)</span> Implicitly converts <code>t</code> to a string view <code>sv</code> as if by <code><a href="../basic_string_view"><span class="kw1243">std::<span class="me2">basic_string_view</span></span></a><span class="sy1">&lt;</span>CharT, Traits<span class="sy1">&gt;</span> sv <span class="sy1">=</span> t<span class="sy4">;</span></code>, then replaces the contents with those of the <code>sv</code> as if by <code>assign(sv)</code>. This overload only participates in overload resolution if <code><a href="../../types/is_convertible"><span class="kw589">std::<span class="me2">is_convertible_v</span></span></a><span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy3">&amp;</span>, <a href="../basic_string_view"><span class="kw1243">std::<span class="me2">basic_string_view</span></span></a><span class="sy1">&lt;</span>CharT, Traits<span class="sy1">&gt;&gt;</span></code> is <code>true</code> and <code><a href="../../types/is_convertible"><span class="kw589">std::<span class="me2">is_convertible_v</span></span></a><span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy3">&amp;</span>, <span class="kw4">const</span> CharT<span class="sy2">*</span><span class="sy1">&gt;</span></code> is <code>false</code>.</div> <h3 id="Parameters">Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> ch </td> <td> - </td> <td> value to initialize characters of the string with </td>
</tr> <tr class="t-par"> <td> str </td> <td> - </td> <td> string to be used as source to initialize the string with </td>
</tr> <tr class="t-par"> <td> s </td> <td> - </td> <td> pointer to a null-terminated character string to use as source to initialize the string with </td>
</tr> <tr class="t-par"> <td> ilist </td> <td> - </td> <td> <code><a href="../../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code> to initialize the string with </td>
</tr> <tr class="t-par"> <td> t </td> <td> - </td> <td> object convertible to <code><a href="../basic_string_view" title="cpp/string/basic string view">std::basic_string_view</a></code> to initialize the string with </td>
</tr>
</table> <h3 id="Return_value">Return value</h3> <p><code>*this</code>.</p>
<h3 id="Complexity">Complexity</h3> <div class="t-li1">
<span class="t-li">1)</span> linear in size of <code>str</code>
</div> <div class="t-li1">
<span class="t-li">2)</span> linear in the size of <code>this</code> (formally, each CharT has to be destroyed). If allocators do not compare equal and do not propagate, then also linear in the size of <code>str</code> (copy must be made)</div> <div class="t-li1">
<span class="t-li">3)</span> linear in size of <code>s</code>
</div> <div class="t-li1">
<span class="t-li">4)</span> constant.</div> <div class="t-li1">
<span class="t-li">5)</span> linear in size of <code>ilist</code>
</div> <h3 id="Exceptions">Exceptions</h3> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <span class="t-li">2)</span> <div class="t-noexcept-full">
<a href="../../language/noexcept_spec" title="cpp/language/noexcept spec"><code>noexcept</code></a> specification: <div class="t-noexcept-box"><span class="t-cc"><code><span class="kw1">noexcept</span><span class="br0">(</span><a href="../../memory/allocator_traits"><span class="kw696">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>Allocator<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">propagate_on_container_move_assignment</span><span class="sy4">::</span><span class="me2">value</span><br> <span class="sy3">||</span> <a href="../../memory/allocator_traits"><span class="kw696">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>Allocator<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">is_always_equal</span><span class="sy4">::</span><span class="me2">value</span><span class="br0">)</span></code></span></div>
</div> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <p>If the operation would result in <code>size() &gt; max_size()</code>, throws <code><a href="../../error/length_error/length_error" title="cpp/error/length error">std::length_error</a></code>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>If an exception is thrown for any reason, this function has no effect (strong exception guarantee).</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Defect_reports">Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2063">LWG 2063</a> </td> <td> C++11 </td> <td> non-normative note stated that swap is a valid implementation of move assignment </td> <td> corrected to support allocators </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2946">LWG 2946</a> </td> <td> C++17 </td> <td> <code>string_view</code> overload causes ambiguity in some cases </td> <td> avoided by making it a template </td>
</tr>
</table> <h3 id="Example">Example</h3>  <h3 id="See_also">See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="basic_string" title="cpp/string/basic string/basic string"> <span class="t-lines"><span>(constructor)</span></span></a></div> </td> <td> constructs a <code>basic_string</code> <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="assign" title="cpp/string/basic string/assign"> <span class="t-lines"><span>assign</span></span></a></div> </td> <td> assign characters to a string <br> <span class="t-mark">(public member function)</span> </td>
</tr> </table>          <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/string/basic_string/operator=" class="_attribution-link">http://en.cppreference.com/w/cpp/string/basic_string/operator=</a>
  </p>
</div>
