   <h1 id="firstHeading" class="firstHeading">Standard library header &lt;string&gt;</h1>            <p>This header is part of the <a href="../string" title="cpp/string">strings</a> library.</p>
<h3 id="Includes">Includes</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <a href="initializer_list" title="cpp/header/initializer list"><code>&lt;initializer_list&gt;</code></a> </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> </table> <h3 id="Classes">Classes</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Name </th> <th> Description </th>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/char_traits" title="cpp/string/char traits">std::char_traits</a></code> </td> <td> Class Template which describes properties of a character type <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/char_traits"><span class="kw1264">std::<span class="me2">char_traits</span></span></a><span class="sy1">&lt;</span><span class="kw4">char</span><span class="sy1">&gt;</span></code> </td> <td> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/char_traits"><span class="kw1264">std::<span class="me2">char_traits</span></span></a><span class="sy1">&lt;</span><span class="kw4">wchar_t</span><span class="sy1">&gt;</span></code> </td> <td> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/char_traits"><span class="kw1264">std::<span class="me2">char_traits</span></span></a><span class="sy1">&lt;</span>char8_t<span class="sy1">&gt;</span></code> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td> <td> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/char_traits"><span class="kw1264">std::<span class="me2">char_traits</span></span></a><span class="sy1">&lt;</span><span class="kw4">char16_t</span><span class="sy1">&gt;</span></code> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/char_traits"><span class="kw1264">std::<span class="me2">char_traits</span></span></a><span class="sy1">&lt;</span><span class="kw4">char32_t</span><span class="sy1">&gt;</span></code> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/basic_string" title="cpp/string/basic string">std::basic_string</a></code> </td> <td> Class template representing a text string object <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/basic_string" title="cpp/string/basic string">std::string</a></code> </td> <td> <code><a href="../string/basic_string"><span class="kw1225">std::<span class="me2">basic_string</span></span></a><span class="sy1">&lt;</span><span class="kw4">char</span><span class="sy1">&gt;</span></code> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <code>std::u8string</code> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td> <td> <code><a href="../string/basic_string"><span class="kw1225">std::<span class="me2">basic_string</span></span></a><span class="sy1">&lt;</span>char8_t<span class="sy1">&gt;</span></code> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/basic_string" title="cpp/string/basic string">std::u16string</a></code> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> <code><a href="../string/basic_string"><span class="kw1225">std::<span class="me2">basic_string</span></span></a><span class="sy1">&lt;</span><span class="kw4">char16_t</span><span class="sy1">&gt;</span></code> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/basic_string" title="cpp/string/basic string">std::u32string</a></code> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> <code><a href="../string/basic_string"><span class="kw1225">std::<span class="me2">basic_string</span></span></a><span class="sy1">&lt;</span><span class="kw4">char32_t</span><span class="sy1">&gt;</span></code> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/basic_string" title="cpp/string/basic string">std::wstring</a></code> </td> <td> <code><a href="../string/basic_string"><span class="kw1225">std::<span class="me2">basic_string</span></span></a><span class="sy1">&lt;</span><span class="kw4">wchar_t</span><span class="sy1">&gt;</span></code> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <code>std::pmr::basic_string</code> </td> <td> <span class="t-mark">(alias template)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/basic_string" title="cpp/string/basic string">std::pmr::string</a></code> <span class="t-mark-rev t-since-cxx17">(C++17)</span> </td> <td> <code>std::pmr::basic_string&lt;char&gt;</code> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <code>std::pmr::u8string</code> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td> <td> <code>std::pmr::basic_string&lt;char8_t&gt;</code> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/basic_string" title="cpp/string/basic string">std::pmr::u16string</a></code> <span class="t-mark-rev t-since-cxx17">(C++17)</span> </td> <td> <code>std::pmr::basic_string&lt;char16_t&gt;</code> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/basic_string" title="cpp/string/basic string">std::pmr::u32string</a></code> <span class="t-mark-rev t-since-cxx17">(C++17)</span> </td> <td> <code>std::pmr::basic_string&lt;char32_t&gt;</code> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../string/basic_string" title="cpp/string/basic string">std::pmr::wstring</a></code> <span class="t-mark-rev t-since-cxx17">(C++17)</span> </td> <td> <code>std::pmr::basic_string&lt;wchar_t&gt;</code> <span class="t-mark">(typedef)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../utility/hash"><span class="kw1121">std::<span class="me2">hash</span></span></a><span class="sy1">&lt;</span><a href="../string/basic_string"><span class="kw1227">std::<span class="me2">string</span></span></a><span class="sy1">&gt;</span></code> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../utility/hash"><span class="kw1121">std::<span class="me2">hash</span></span></a><span class="sy1">&lt;</span>std<span class="sy4">::</span><span class="me2">u8string</span><span class="sy1">&gt;</span></code> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td> <td> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../utility/hash"><span class="kw1121">std::<span class="me2">hash</span></span></a><span class="sy1">&lt;</span><a href="../string/basic_string"><span class="kw1231">std::<span class="me2">u16string</span></span></a><span class="sy1">&gt;</span></code> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../utility/hash"><span class="kw1121">std::<span class="me2">hash</span></span></a><span class="sy1">&lt;</span><a href="../string/basic_string"><span class="kw1233">std::<span class="me2">u32string</span></span></a><span class="sy1">&gt;</span></code> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../utility/hash"><span class="kw1121">std::<span class="me2">hash</span></span></a><span class="sy1">&lt;</span><a href="../string/basic_string"><span class="kw1229">std::<span class="me2">wstring</span></span></a><span class="sy1">&gt;</span></code> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../utility/hash"><span class="kw1121">std::<span class="me2">hash</span></span></a><span class="sy1">&lt;</span><a href="../string/basic_string"><span class="kw1235">std::<span class="me2">pmr</span><span class="sy4">::</span><span class="me2">string</span></span></a><span class="sy1">&gt;</span></code> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td> <td> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../utility/hash"><span class="kw1121">std::<span class="me2">hash</span></span></a><span class="sy1">&lt;</span>std<span class="sy4">::</span><span class="me2">pmr</span><span class="sy4">::</span><span class="me2">u8string</span><span class="sy1">&gt;</span></code> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td> <td> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../utility/hash"><span class="kw1121">std::<span class="me2">hash</span></span></a><span class="sy1">&lt;</span><a href="../string/basic_string"><span class="kw1239">std::<span class="me2">pmr</span><span class="sy4">::</span><span class="me2">u16string</span></span></a><span class="sy1">&gt;</span></code> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td> <td> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../utility/hash"><span class="kw1121">std::<span class="me2">hash</span></span></a><span class="sy1">&lt;</span><a href="../string/basic_string"><span class="kw1241">std::<span class="me2">pmr</span><span class="sy4">::</span><span class="me2">u32string</span></span></a><span class="sy1">&gt;</span></code> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td> <td> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <code><a href="../utility/hash"><span class="kw1121">std::<span class="me2">hash</span></span></a><span class="sy1">&lt;</span><a href="../string/basic_string"><span class="kw1237">std::<span class="me2">pmr</span><span class="sy4">::</span><span class="me2">wstring</span></span></a><span class="sy1">&gt;</span></code> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td> <td> <span class="t-mark">(class template specialization)</span> </td>
</tr> </table> <h3 id="Functions">Functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="http://en.cppreference.com/w/cpp/string/basic_string/operator%20" title="cpp/string/basic string/operator+"> <span class="t-lines"><span>operator+</span></span></a></div> </td> <td> concatenates two strings or a string and a char <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/operator_cmp" title="cpp/string/basic string/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&gt;</span><span>operator&lt;=</span><span>operator&gt;=</span></span></a></div> </td> <td> lexicographically compares two strings <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/swap2" title="cpp/string/basic string/swap2"> <span class="t-lines"><span>std::swap<span class="t-dsc-small">(std::basic_string)</span></span></span></a></div> </td> <td> specializes the <code><a href="../algorithm/swap" title="cpp/algorithm/swap">std::swap</a></code> algorithm <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Input.2Foutput">  Input/output </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/operator_ltltgtgt" title="cpp/string/basic string/operator ltltgtgt"> <span class="t-lines"><span>operator&lt;&lt;</span><span>operator&gt;&gt;</span></span></a></div> </td> <td> performs stream input and output on strings <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/getline" title="cpp/string/basic string/getline"> <span class="t-lines"><span>getline</span></span></a></div> </td> <td> read data from an I/O stream into a string <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Numeric_conversions">  Numeric conversions </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/stol" title="cpp/string/basic string/stol"> <span class="t-lines"><span>stoi</span><span>stol</span><span>stoll</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> converts a string to a signed integer <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/stoul" title="cpp/string/basic string/stoul"> <span class="t-lines"><span>stoul</span><span>stoull</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> converts a string to an unsigned integer <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/stof" title="cpp/string/basic string/stof"> <span class="t-lines"><span>stof</span><span>stod</span><span>stold</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> converts a string to a floating point value <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/to_string" title="cpp/string/basic string/to string"> <span class="t-lines"><span>to_string</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> converts an integral or floating point value to <code>string</code> <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/to_wstring" title="cpp/string/basic string/to wstring"> <span class="t-lines"><span>to_wstring</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> converts an integral or floating point value to <code>wstring</code> <br> <span class="t-mark">(function)</span> </td>
</tr> </table> <h3 id="Literals">Literals</h3> <table class="t-dsc-begin"> <tr class="t-dsc-header"> <th colspan="2"> Defined in inline namespace <code>std::literals::string_literals</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/operator_q__q_s" title='cpp/string/basic string/operator""s'> <span class="t-lines"><span>operator""s</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> Converts a character array literal to <code>basic_string</code> <br> <span class="t-mark">(function)</span> </td>
</tr> </table> <h3 id="Synopsis">Synopsis</h3> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;initializer_list&gt;
namespace std {
  // character traits
  template&lt;class charT&gt; struct char_traits;
  template&lt;&gt; struct char_traits&lt;char&gt;;
  template&lt;&gt; struct char_traits&lt;char8_t&gt;;
  template&lt;&gt; struct char_traits&lt;char16_t&gt;;
  template&lt;&gt; struct char_traits&lt;char32_t&gt;;
  template&lt;&gt; struct char_traits&lt;wchar_t&gt;;
  // basic_string
  template&lt;class charT, class traits = char_traits&lt;charT&gt;, class Allocator = allocator&lt;charT&gt;&gt;
  class basic_string;
  template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT, traits, Allocator&gt; operator+(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);
template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT, traits, Allocator&gt; operator+(basic_string&lt;charT, traits, Allocator&gt;&amp;&amp; lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);
  template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT, traits, Allocator&gt; operator+(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, basic_string&lt;charT, traits, Allocator&gt;&amp;&amp; rhs);
  template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT, traits, Allocator&gt; operator+(basic_string&lt;charT, traits, Allocator&gt;&amp;&amp; lhs,
basic_string&lt;charT, traits, Allocator&gt;&amp;&amp; rhs);
  template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT, traits, Allocator&gt; operator+(const charT* lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);
  template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT, traits, Allocator&gt; operator+(const charT* lhs, basic_string&lt;charT, traits, Allocator&gt;&amp;&amp; rhs);
  template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT, traits, Allocator&gt; operator+(charT lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);
  template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT, traits, Allocator&gt; operator+(charT lhs, basic_string&lt;charT, traits, Allocator&gt;&amp;&amp; rhs);
  template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT, traits, Allocator&gt; operator+(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, const charT* rhs);
  template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT, traits, Allocator&gt; operator+(basic_string&lt;charT, traits, Allocator&gt;&amp;&amp; lhs,
const charT* rhs);
  template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT, traits, Allocator&gt; operator+(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, charT rhs);
  template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT, traits, Allocator&gt; operator+(basic_string&lt;charT, traits, Allocator&gt;&amp;&amp; lhs, charT rhs);
  template&lt;class charT, class traits, class Allocator&gt;
  bool operator==(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;
  template&lt;class charT, class traits, class Allocator&gt;
  bool operator==(const charT* lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);
  template&lt;class charT, class traits, class Allocator&gt;
  bool operator==(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, const charT* rhs);
  template&lt;class charT, class traits, class Allocator&gt;
  bool operator!=(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;
  template&lt;class charT, class traits, class Allocator&gt;
  bool operator!=(const charT* lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);
  template&lt;class charT, class traits, class Allocator&gt;
  bool operator!=(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, const charT* rhs);
  template&lt;class charT, class traits, class Allocator&gt;
  bool operator&lt; (const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;
  template&lt;class charT, class traits, class Allocator&gt;
  bool operator&lt; (const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, const charT* rhs);
  template&lt;class charT, class traits, class Allocator&gt;
  bool operator&lt; (const charT* lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);
  template&lt;class charT, class traits, class Allocator&gt;
  bool operator&gt; (const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;
  template&lt;class charT, class traits, class Allocator&gt;
  bool operator&gt; (const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, const charT* rhs);
template&lt;class charT, class traits, class Allocator&gt;
  bool operator&gt; (const charT* lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);
  template&lt;class charT, class traits, class Allocator&gt;
  bool operator&lt;=(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;
  template&lt;class charT, class traits, class Allocator&gt;
  bool operator&lt;=(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, const charT* rhs);
  template&lt;class charT, class traits, class Allocator&gt;
  bool operator&lt;=(const charT* lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);
  template&lt;class charT, class traits, class Allocator&gt;
  bool operator&gt;=(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;
  template&lt;class charT, class traits, class Allocator&gt;
  bool operator&gt;=(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, const charT* rhs);
  template&lt;class charT, class traits, class Allocator&gt;
  bool operator&gt;=(const charT* lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);
  // swap
  template&lt;class charT, class traits, class Allocator&gt;
  void swap(basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept(noexcept(lhs.swap(rhs)));
  // inserters and extractors
  template&lt;class charT, class traits, class Allocator&gt;
  basic_istream&lt;charT, traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, basic_string&lt;charT, traits, Allocator&gt;&amp; str);
  template&lt;class charT, class traits, class Allocator&gt;
  basic_ostream&lt;charT, traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const basic_string&lt;charT, traits, Allocator&gt;&amp; str);
  template&lt;class charT, class traits, class Allocator&gt; basic_istream&lt;charT, traits&gt;&amp; getline(basic_istream&lt;charT, traits&gt;&amp; is, basic_string&lt;charT, traits, Allocator&gt;&amp; str,
charT delim);
  template&lt;class charT, class traits, class Allocator&gt;
  basic_istream&lt;charT, traits&gt;&amp; getline(basic_istream&lt;charT, traits&gt;&amp;&amp; is, basic_string&lt;charT, traits, Allocator&gt;&amp; str, charT delim);
  template&lt;class charT, class traits, class Allocator&gt;
  basic_istream&lt;charT, traits&gt;&amp; getline(basic_istream&lt;charT, traits&gt;&amp; is, basic_string&lt;charT, traits, Allocator&gt;&amp; str);
  template&lt;class charT, class traits, class Allocator&gt;
  basic_istream&lt;charT, traits&gt;&amp; getline(basic_istream&lt;charT, traits&gt;&amp;&amp; is, basic_string&lt;charT, traits, Allocator&gt;&amp; str);
  // basic_string typedef names
  using string = basic_string&lt;char&gt;;
  using u8string = basic_string&lt;char8_t&gt;;
  using u16string = basic_string&lt;char16_t&gt;;
  using u32string = basic_string&lt;char32_t&gt;;
  using wstring = basic_string&lt;wchar_t&gt;;
  // numeric conversions
  int stoi(const string&amp; str, size_t* idx = 0, int base = 10);
  long stol(const string&amp; str, size_t* idx = 0, int base = 10);
  unsigned long stoul(const string&amp; str, size_t* idx = 0, int base = 10);
  long long stoll(const string&amp; str, size_t* idx = 0, int base = 10);
  unsigned long long stoull(const string&amp; str, size_t* idx = 0, int base = 10);
  float stof(const string&amp; str, size_t* idx = 0);
  double stod(const string&amp; str, size_t* idx = 0);
  long double stold(const string&amp; str, size_t* idx = 0);
  string to_string(int val);
  string to_string(unsigned val);
  string to_string(long val);
  string to_string(unsigned long val);
  string to_string(long long val);
  string to_string(unsigned long long val);
  string to_string(float val);
  string to_string(double val);
  string to_string(long double val);
  int stoi(const wstring&amp; str, size_t* idx = 0, int base = 10);
  long stol(const wstring&amp; str, size_t* idx = 0, int base = 10);
  unsigned long stoul(const wstring&amp; str, size_t* idx = 0, int base = 10);
  long long stoll(const wstring&amp; str, size_t* idx = 0, int base = 10);
  unsigned long long stoull(const wstring&amp; str, size_t* idx = 0, int base = 10);
  float stof(const wstring&amp; str, size_t* idx = 0);
  double stod(const wstring&amp; str, size_t* idx = 0);
  long double stold(const wstring&amp; str, size_t* idx = 0);
  wstring to_wstring(int val);
  wstring to_wstring(unsigned val);
  wstring to_wstring(long val);
  wstring to_wstring(unsigned long val);
  wstring to_wstring(long long val);
  wstring to_wstring(unsigned long long val);
  wstring to_wstring(float val);
  wstring to_wstring(double val);
  wstring to_wstring(long double val);
  namespace pmr {
    template &lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
    using basic_string = std::basic_string&lt;charT, traits, polymorphic_allocator&lt;charT&gt;&gt;;
    using string = basic_string&lt;char&gt;;
    using u8string = basic_string&lt;char8_t&gt;;
    using u16string = basic_string&lt;char16_t&gt;;
    using u32string = basic_string&lt;char32_t&gt;;
    using wstring = basic_string&lt;wchar_t&gt;;
  }
  // hash support
  template&lt;class T&gt; struct hash;
  template&lt;&gt; struct hash&lt;string&gt;;
  template&lt;&gt; struct hash&lt;u8string&gt;;
  template&lt;&gt; struct hash&lt;u16string&gt;;
  template&lt;&gt; struct hash&lt;u32string&gt;;
  template&lt;&gt; struct hash&lt;wstring&gt;;
  template&lt;&gt; struct hash&lt;pmr::string&gt;;
  template&lt;&gt; struct hash&lt;pmr::u8string&gt;;
  template&lt;&gt; struct hash&lt;pmr::u16string&gt;;
  template&lt;&gt; struct hash&lt;pmr::u32string&gt;;
  template&lt;&gt; struct hash&lt;pmr::wstring&gt;;
  inline namespace literals {
    inline namespace string_literals {
      // suffix for basic_string literals
      string operator""s(const char* str, size_t len);
      u8string operator""s(const char8_t* str, size_t len);
      u16string operator""s(const char16_t* str, size_t len);
      u32string operator""s(const char32_t* str, size_t len);
      wstring operator""s(const wchar_t* str, size_t len);
    }
  }
}</pre></div> <h4 id="Class_template_std::char_traits">Class template <code><a href="../string/char_traits" title="cpp/string/char traits">std::char_traits</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;&gt; struct char_traits&lt;char&gt; {
    using char_type = char;
    using int_type = int;
    using off_type = streamoff;
    using pos_type = streampos;
    using state_type = mbstate_t;
    static constexpr void assign(char_type&amp; c1, const char_type&amp; c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;
    static constexpr int compare(const char_type* s1, const char_type* s2, size_t n);
    static constexpr size_t length(const char_type* s);
    static constexpr const char_type* find(const char_type* s, size_t n, const char_type&amp; a);
    static constexpr char_type* move(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* copy(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* assign(char_type* s, size_t n, char_type a);
    static constexpr int_type not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type to_int_type(char_type c) noexcept;
    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type eof() noexcept;
  };
 
  template&lt;&gt; struct char_traits&lt;char8_t&gt; {
    using char_type = char8_t;
    using int_type = unsigned int;
    using off_type = streamoff;
    using pos_type = u8streampos;
    using state_type = mbstate_t;
    static constexpr void assign(char_type&amp; c1, const char_type&amp; c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;
    static constexpr int compare(const char_type* s1, const char_type* s2, size_t n);
    static constexpr size_t length(const char_type* s);
    static constexpr const char_type* find(const char_type* s, size_t n, const char_type&amp; a);
    static constexpr char_type* move(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* copy(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* assign(char_type* s, size_t n, char_type a);
    static constexpr int_type not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type to_int_type(char_type c) noexcept;
    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type eof() noexcept;
  };
 
  template&lt;&gt; struct char_traits&lt;char16_t&gt; {
    using char_type = char16_t;
    using int_type = uint_least16_t;
    using off_type = streamoff;
    using pos_type = u16streampos;
    using state_type = mbstate_t;
    static constexpr void assign(char_type&amp; c1, const char_type&amp; c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;
    static constexpr int compare(const char_type* s1, const char_type* s2, size_t n);
    static constexpr size_t length(const char_type* s);
    static constexpr const char_type* find(const char_type* s, size_t n, const char_type&amp; a);
    static constexpr char_type* move(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* copy(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* assign(char_type* s, size_t n, char_type a);
    static constexpr int_type not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type to_int_type(char_type c) noexcept;
    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type eof() noexcept;
  };
 
  template&lt;&gt; struct char_traits&lt;char32_t&gt; {
    using char_type = char32_t;
    using int_type = uint_least32_t;
    using off_type = streamoff;
    using pos_type = u32streampos;
    using state_type = mbstate_t;
    static constexpr void assign(char_type&amp; c1, const char_type&amp; c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;
    static constexpr int compare(const char_type* s1, const char_type* s2, size_t n);
    static constexpr size_t length(const char_type* s);
    static constexpr const char_type* find(const char_type* s, size_t n, const char_type&amp; a);
    static constexpr char_type* move(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* copy(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* assign(char_type* s, size_t n, char_type a);
    static constexpr int_type not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type to_int_type(char_type c) noexcept;
    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type eof() noexcept;
  };
 
  template&lt;&gt; struct char_traits&lt;wchar_t&gt; {
    using char_type = wchar_t;
    using int_type = wint_t;
    using off_type = streamoff;
    using pos_type = wstreampos;
    using state_type = mbstate_t;
    static constexpr void assign(char_type&amp; c1, const char_type&amp; c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;
    static constexpr int compare(const char_type* s1, const char_type* s2, size_t n);
    static constexpr size_t length(const char_type* s);
    static constexpr const char_type* find(const char_type* s, size_t n, const char_type&amp; a);
    static constexpr char_type* move(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* copy(char_type* s1, const char_type* s2, size_t n);
    static constexpr char_type* assign(char_type* s, size_t n, char_type a);
    static constexpr int_type not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type to_int_type(char_type c) noexcept;
    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type eof() noexcept;
  };
}</pre></div> <h4 id="Class_template_std::basic_string">Class template <code><a href="../string/basic_string" title="cpp/string/basic string">std::basic_string</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;, class Allocator = allocator&lt;charT&gt;&gt;
  class basic_string {
  public:
    // types:
    using traits_type = traits;
    using value_type = charT;
    using allocator_type = Allocator;
    using size_type = typename allocator_traits&lt;Allocator&gt;::size_type;
    using difference_type = typename allocator_traits&lt;Allocator&gt;::difference_type;
    using pointer = typename allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer = typename allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference = value_type&amp;;
    using const_reference = const value_type&amp;;
    using iterator = /* see definition */ ;
    using const_iterator = /* see definition */ ;
    using reverse_iterator = std::reverse_iterator&lt;iterator&gt;;
    using const_reverse_iterator = std::reverse_iterator&lt;const_iterator&gt;;
    static const size_type npos = -1;
    // construct/copy/destroy
    basic_string() noexcept(noexcept(Allocator())) : basic_string(Allocator()) { }
    explicit basic_string(const Allocator&amp; a) noexcept;
    basic_string(const basic_string&amp; str);
    basic_string(basic_string&amp;&amp; str) noexcept;
    basic_string(const basic_string&amp; str, size_type pos, const Allocator&amp; a = Allocator());
    basic_string(const basic_string&amp; str, size_type pos, size_type n, const Allocator&amp; a = Allocator());
    template&lt;class T&gt;
    basic_string(const T&amp; t, size_type pos, size_type n, const Allocator&amp; a = Allocator());
    explicit basic_string(basic_string_view&lt;charT, traits&gt; sv, const Allocator&amp; a = Allocator());
    basic_string(const charT* s, size_type n, const Allocator&amp; a = Allocator());
    basic_string(const charT* s, const Allocator&amp; a = Allocator());
    basic_string(size_type n, charT c, const Allocator&amp; a = Allocator());
    template&lt;class InputIt&gt;
    basic_string(InputIt begin, InputIt end, const Allocator&amp; a = Allocator());
    basic_string(initializer_list&lt;charT&gt;, const Allocator&amp; = Allocator());
    basic_string(const basic_string&amp;, const Allocator&amp;);
    basic_string(basic_string&amp;&amp;, const Allocator&amp;);
    ~basic_string();
    basic_string&amp; operator=(const basic_string&amp; str);
    basic_string&amp; operator=(basic_string&amp;&amp; str) noexcept(allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value ||
allocator_traits&lt;Allocator&gt;::is_always_equal::value);
    basic_string&amp; operator=(basic_string_view&lt;charT, traits&gt; sv);
    basic_string&amp; operator=(const charT* s);
    basic_string&amp; operator=(charT c);
    basic_string&amp; operator=(initializer_list&lt;charT&gt;);
    // iterators
    iterator begin() noexcept;
    const_iterator begin() const noexcept;
    iterator end() noexcept;
    const_iterator end() const noexcept;
    reverse_iterator rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator rend() noexcept;
    const_reverse_iterator rend() const noexcept;
    const_iterator cbegin() const noexcept;
    const_iterator cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;
    // capacity
    size_type size() const noexcept;
    size_type length() const noexcept;
    size_type max_size() const noexcept;
    void resize(size_type n, charT c);
    void resize(size_type n);
    size_type capacity() const noexcept;
    void reserve(size_type res_arg = 0);
    void shrink_to_fit();
    void clear() noexcept;
    [[nodiscard]] bool empty() const noexcept;
    // element access
    const_reference operator[](size_type pos) const;
    reference operator[](size_type pos);
    const_reference at(size_type n) const;
    reference at(size_type n);
    const charT&amp; front() const;
    charT&amp; front();
    const charT&amp; back() const;
    charT&amp; back();
    // modifiers
    basic_string&amp; operator+=(const basic_string&amp; str);
    basic_string&amp; operator+=(basic_string_view&lt;charT, traits&gt; sv);
    basic_string&amp; operator+=(const charT* s);
    basic_string&amp; operator+=(charT c);
    basic_string&amp; operator+=(initializer_list&lt;charT&gt;);
    basic_string&amp; append(const basic_string&amp; str);
    basic_string&amp; append(const basic_string&amp; str, size_type pos, size_type n = npos);
    basic_string&amp; append(basic_string_view&lt;charT, traits&gt; sv);
    template&lt;class T&gt;
    basic_string&amp; append(const T&amp; t, size_type pos, size_type n = npos);
    basic_string&amp; append(const charT* s, size_type n);
    basic_string&amp; append(const charT* s);
    basic_string&amp; append(size_type n, charT c);
    template&lt;class InputIt&gt;
    basic_string&amp; append(InputIt first, InputIt last);
    basic_string&amp; append(initializer_list&lt;charT&gt;);
    void push_back(charT c);
    basic_string&amp; assign(const basic_string&amp; str);
    basic_string&amp; assign(basic_string&amp;&amp; str) noexcept(allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value ||
allocator_traits&lt;Allocator&gt;::is_always_equal::value);
    basic_string&amp; assign(const basic_string&amp; str, size_type pos, size_type n = npos);
    basic_string&amp; assign(basic_string_view&lt;charT, traits&gt; sv);
    template&lt;class T&gt;
    basic_string&amp; assign(const T&amp; t, size_type pos, size_type n = npos);
    basic_string&amp; assign(const charT* s, size_type n);
    basic_string&amp; assign(const charT* s);
    basic_string&amp; assign(size_type n, charT c);
    template&lt;class InputIt&gt;
    basic_string&amp; assign(InputIt first, InputIt last);
    basic_string&amp; assign(initializer_list&lt;charT&gt;);
    basic_string&amp; insert(size_type pos, const basic_string&amp; str);
    basic_string&amp; insert(size_type pos1, const basic_string&amp; str, size_type pos2, size_type n = npos);
    basic_string&amp; insert(size_type pos, basic_string_view&lt;charT, traits&gt; sv);
    template&lt;class T&gt;
    basic_string&amp; insert(size_type pos1, const T&amp; t, size_type pos2, size_type n = npos);
    basic_string&amp; insert(size_type pos, const charT* s, size_type n);
    basic_string&amp; insert(size_type pos, const charT* s);
    basic_string&amp; insert(size_type pos, size_type n, charT c);
    iterator insert(const_iterator p, charT c);
    iterator insert(const_iterator p, size_type n, charT c);
    template&lt;class InputIt&gt;
    iterator insert(const_iterator p, InputIt first, InputIt last);
    iterator insert(const_iterator p, initializer_list&lt;charT&gt;);
    basic_string&amp; erase(size_type pos = 0, size_type n = npos);
    iterator erase(const_iterator p);
    iterator erase(const_iterator first, const_iterator last);
    void pop_back();
    basic_string&amp; replace(size_type pos1, size_type n1, const basic_string&amp; str);
    basic_string&amp; replace(size_type pos1, size_type n1, const basic_string&amp; str, size_type pos2, size_type n2 = npos);
    basic_string&amp; replace(size_type pos1, size_type n1, basic_string_view&lt;charT, traits&gt; sv);
    template&lt;class T&gt;
    basic_string&amp; replace(size_type pos1, size_type n1, const T&amp; t, size_type pos2, size_type n2 = npos);
    basic_string&amp; replace(size_type pos, size_type n1, const charT* s, size_type n2);
    basic_string&amp; replace(size_type pos, size_type n1, const charT* s);
    basic_string&amp; replace(size_type pos, size_type n1, size_type n2, charT c);
    basic_string&amp; replace(const_iterator i1, const_iterator i2, const basic_string&amp; str);
    basic_string&amp; replace(const_iterator i1, const_iterator i2, basic_string_view&lt;charT, traits&gt; sv);
    basic_string&amp; replace(const_iterator i1, const_iterator i2, const charT* s, size_type n);
    basic_string&amp; replace(const_iterator i1, const_iterator i2, const charT* s);
    basic_string&amp; replace(const_iterator i1, const_iterator i2, size_type n, charT c);
    template&lt;class InputIt&gt;
    basic_string&amp; replace(const_iterator i1, const_iterator i2, InputIt j1, InputIt j2);
    basic_string&amp; replace(const_iterator, const_iterator, initializer_list&lt;charT&gt;);
    size_type copy(charT* s, size_type n, size_type pos = 0) const;
    void swap(basic_string&amp; str) noexcept(allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value ||
allocator_traits&lt;Allocator&gt;::is_always_equal::value);
    // string operations
    const charT* c_str() const noexcept;
    const charT* data() const noexcept;
    charT* data() noexcept;
    operator basic_string_view&lt;charT, traits&gt;() const noexcept;
    allocator_type get_allocator() const noexcept;
    size_type find (basic_string_view&lt;charT, traits&gt; sv, size_type pos = 0) const noexcept;
    size_type find (const basic_string&amp; str, size_type pos = 0) const noexcept;
    size_type find (const charT* s, size_type pos, size_type n) const;
    size_type find (const charT* s, size_type pos = 0) const;
    size_type find (charT c, size_type pos = 0) const;
    size_type rfind(basic_string_view&lt;charT, traits&gt; sv, size_type pos = npos) const noexcept;
    size_type rfind(const basic_string&amp; str, size_type pos = npos) const noexcept;
    size_type rfind(const charT* s, size_type pos, size_type n) const;
    size_type rfind(const charT* s, size_type pos = npos) const;
    size_type rfind(charT c, size_type pos = npos) const;
    size_type find_first_of(basic_string_view&lt;charT, traits&gt; sv, size_type pos = 0) const noexcept;
    size_type find_first_of(const basic_string&amp; str, size_type pos = 0) const noexcept;
    size_type find_first_of(const charT* s, size_type pos, size_type n) const;
    size_type find_first_of(const charT* s, size_type pos = 0) const;
    size_type find_first_of(charT c, size_type pos = 0) const;
    size_type find_last_of (basic_string_view&lt;charT, traits&gt; sv, size_type pos = npos) const noexcept;
    size_type find_last_of (const basic_string&amp; str, size_type pos = npos) const noexcept;
    size_type find_last_of (const charT* s, size_type pos, size_type n) const;
    size_type find_last_of (const charT* s, size_type pos = npos) const;
    size_type find_last_of (charT c, size_type pos = npos) const;
    size_type find_first_not_of(basic_string_view&lt;charT, traits&gt; sv, size_type pos = 0) const noexcept;
    size_type find_first_not_of(const basic_string&amp; str, size_type pos = 0) const noexcept;
    size_type find_first_not_of(const charT* s, size_type pos, size_type n) const;
    size_type find_first_not_of(const charT* s, size_type pos = 0) const;
    size_type find_first_not_of(charT c, size_type pos = 0) const;
    size_type find_last_not_of (basic_string_view&lt;charT, traits&gt; sv, size_type pos = npos) const noexcept;
    size_type find_last_not_of (const basic_string&amp; str, size_type pos = npos) const noexcept;
    size_type find_last_not_of (const charT* s, size_type pos, size_type n) const;
    size_type find_last_not_of (const charT* s, size_type pos = npos) const;
    size_type find_last_not_of (charT c, size_type pos = npos) const;
    basic_string substr(size_type pos = 0, size_type n = npos) const;
    int compare(basic_string_view&lt;charT, traits&gt; sv) const noexcept;
    int compare(size_type pos1, size_type n1,
    basic_string_view&lt;charT, traits&gt; sv) const;
    template&lt;class T&gt;
    int compare(size_type pos1, size_type n1, const T&amp; t, size_type pos2, size_type n2 = npos) const;
    int compare(const basic_string&amp; str) const noexcept;
    int compare(size_type pos1, size_type n1, const basic_string&amp; str) const;
    int compare(size_type pos1, size_type n1, const basic_string&amp; str, size_type pos2, size_type n2 = npos) const;
    int compare(const charT* s) const;
    int compare(size_type pos1, size_type n1, const charT* s) const;
    int compare(size_type pos1, size_type n1, const charT* s, size_type n2) const;
    bool starts_with(basic_string_view&lt;charT, traits&gt; x) const noexcept;
    bool starts_with(charT x) const noexcept;
    bool starts_with(const charT* x) const;
    bool ends_with(basic_string_view&lt;charT, traits&gt; x) const noexcept;
    bool ends_with(charT x) const noexcept;
    bool ends_with(const charT* x) const;
  };
  template&lt;class InputIt,
  class Allocator = allocator&lt;typename iterator_traits&lt;InputIt&gt;::value_type&gt;&gt;
  basic_string(InputIt, InputIt, Allocator = Allocator())
  -&gt; basic_string&lt;typename iterator_traits&lt;InputIt&gt;::value_type,
                  char_traits&lt;typename iterator_traits&lt;InputIt&gt;::value_type&gt;,
                  Allocator&gt;;
}</pre></div>          <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/header/string" class="_attribution-link">http://en.cppreference.com/w/cpp/header/string</a>
  </p>
</div>
