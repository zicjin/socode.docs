    <h1 id="firstHeading" class="firstHeading">Standard library header &lt;ranges&gt;</h1>            <p>This header is part of the <a href="../ranges" title="cpp/ranges">ranges</a> library.</p>
<h3 id="Namespace_aliases">  Namespace aliases </h3> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">namespace std {
    namespace views = ranges::views;
}</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>The namespace alias <code>std::views</code> is provided as a shorthand for <code>std::ranges::views</code>.</p>
<table class="t-dsc-begin"> <tr> <td colspan="2"> <h3 id="Concepts">  Concepts</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Range_concepts">  Range concepts </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/range" title="cpp/ranges/range"> <span class="t-lines"><span>ranges::range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a type is a range, that is, it provides a <code>begin</code> iterator and an <code>end</code> sentinel <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/borrowed_range" title="cpp/ranges/borrowed range"> <span class="t-lines"><span>ranges::borrowed_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a type is a <a href="../ranges/range" title="cpp/ranges/range"><code>range</code></a> and iterators obtained from an expression of it can be safely returned without danger of dangling <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/sized_range" title="cpp/ranges/sized range"> <span class="t-lines"><span>ranges::sized_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a range knows its size in constant time <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/view" title="cpp/ranges/view"> <span class="t-lines"><span>ranges::view</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a range is a view, that is, it has constant time copy/move/assignment <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/input_range" title="cpp/ranges/input range"> <span class="t-lines"><span>ranges::input_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies a range whose iterator type satisfies <a href="../iterator/input_iterator" title="cpp/iterator/input iterator"><code>input_iterator</code></a> <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/output_range" title="cpp/ranges/output range"> <span class="t-lines"><span>ranges::output_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies a range whose iterator type satisfies <a href="../iterator/output_iterator" title="cpp/iterator/output iterator"><code>output_iterator</code></a> <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/forward_range" title="cpp/ranges/forward range"> <span class="t-lines"><span>ranges::forward_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies a range whose iterator type satisfies <a href="../iterator/forward_iterator" title="cpp/iterator/forward iterator"><code>forward_iterator</code></a> <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/bidirectional_range" title="cpp/ranges/bidirectional range"> <span class="t-lines"><span>ranges::bidirectional_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies a range whose iterator type satisfies <a href="../iterator/bidirectional_iterator" title="cpp/iterator/bidirectional iterator"><code>bidirectional_iterator</code></a> <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/random_access_range" title="cpp/ranges/random access range"> <span class="t-lines"><span>ranges::random_access_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies a range whose iterator type satisfies <a href="../iterator/random_access_iterator" title="cpp/iterator/random access iterator"><code>random_access_iterator</code></a> <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/contiguous_range" title="cpp/ranges/contiguous range"> <span class="t-lines"><span>ranges::contiguous_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies a range whose iterator type satisfies <a href="../iterator/contiguous_iterator" title="cpp/iterator/contiguous iterator"><code>contiguous_iterator</code></a> <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/common_range" title="cpp/ranges/common range"> <span class="t-lines"><span>ranges::common_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies that a range has identical iterator and sentinel types <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/viewable_range" title="cpp/ranges/viewable range"> <span class="t-lines"><span>ranges::viewable_range</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies the requirements for a <a href="../ranges/range" title="cpp/ranges/range"><code>range</code></a> to be safely convertible to a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> <br> <span class="t-mark">(concept)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Functions">  Functions</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Range_conversions">  Range conversions </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/to&amp;action=edit&amp;redlink=1" class="new" title="cpp/ranges/to (page does not exist)"> <span class="t-lines"><span>ranges::to</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> constructs an object (usually a container) from a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Classes">  Classes</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Range_primitives">  Range primitives </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/iterator_t" title="cpp/ranges/iterator t"> <span class="t-lines"><span>ranges::iterator_t</span><span>ranges::sentinel_t</span><span>ranges::range_difference_t</span><span>ranges::range_size_t </span><span>ranges::range_value_t</span><span>ranges::range_reference_t</span><span>ranges::range_rvalue_reference_t</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> obtains associated types of a range <br> <span class="t-mark">(alias template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Views">  Views </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/view_interface" title="cpp/ranges/view interface"> <span class="t-lines"><span>ranges::view_interface</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> helper class template for defining a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a>, using the <a href="../language/crtp" title="cpp/language/crtp">curiously recurring template pattern</a> <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/subrange" title="cpp/ranges/subrange"> <span class="t-lines"><span>ranges::subrange</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> combines an iterator-sentinel pair into a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Dangling_iterator_handling">  Dangling iterator handling </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/dangling" title="cpp/ranges/dangling"> <span class="t-lines"><span>ranges::dangling</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a placeholder type indicating that an iterator or a <code>subrange</code> should not be returned since it would be dangling <br> <span class="t-mark">(class)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/borrowed_iterator_t" title="cpp/ranges/borrowed iterator t"> <span class="t-lines"><span>ranges::borrowed_iterator_t</span><span>ranges::borrowed_subrange_t</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> obtains iterator type or <code>subrange</code> type of a <a href="../ranges/borrowed_range" title="cpp/ranges/borrowed range"><code>borrowed_range</code></a> <br> <span class="t-mark">(alias template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Range_adaptor_objects_utility">  Range adaptor objects utility </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/range_adaptor_closure&amp;action=edit&amp;redlink=1" class="new" title="cpp/ranges/range adaptor closure (page does not exist)"> <span class="t-lines"><span>ranges::range_adaptor_closure</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> helper base class template for defining a range adaptor closure object <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Factories">  Factories </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/empty_view" title="cpp/ranges/empty view"> <span class="t-lines"><span>ranges::empty_view</span><span>views::empty</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> an empty <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> with no elements <br> <span class="t-mark">(class template)</span> <span class="t-mark">(variable template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/single_view" title="cpp/ranges/single view"> <span class="t-lines"><span>ranges::single_view</span><span>views::single</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> that contains a single element of a specified value <br> <span class="t-mark">(class template)</span> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/iota_view" title="cpp/ranges/iota view"> <span class="t-lines"><span>ranges::iota_view</span><span>views::iota</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of a sequence generated by repeatedly incrementing an initial value <br> <span class="t-mark">(class template)</span> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/basic_istream_view" title="cpp/ranges/basic istream view"> <span class="t-lines"><span>ranges::basic_istream_view</span><span>views::istream</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of the elements obtained by successive application of operator&gt;&gt; on the associated input stream <br> <span class="t-mark">(class template)</span> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Adaptors">  Adaptors </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/all_view" title="cpp/ranges/all view"> <span class="t-lines"><span>views::all_t</span><span>views::all</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> that includes all elements of a <a href="../ranges/range" title="cpp/ranges/range"><code>range</code></a> <br> <span class="t-mark">(alias template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/ref_view" title="cpp/ranges/ref view"> <span class="t-lines"><span>ranges::ref_view</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> of the elements of some other <a href="../ranges/range" title="cpp/ranges/range"><code>range</code></a> <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/owning_view" title="cpp/ranges/owning view"> <span class="t-lines"><span>ranges::owning_view</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> with unique ownership of some <a href="../ranges/range" title="cpp/ranges/range"><code>range</code></a> <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/filter_view" title="cpp/ranges/filter view"> <span class="t-lines"><span>ranges::filter_view</span><span>views::filter</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> that consists of the elements of a <a href="../ranges/range" title="cpp/ranges/range"><code>range</code></a> that satisfies a predicate <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/transform_view" title="cpp/ranges/transform view"> <span class="t-lines"><span>ranges::transform_view</span><span>views::transform</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> of a sequence that applies a transformation function to each element <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/take_view" title="cpp/ranges/take view"> <span class="t-lines"><span>ranges::take_view</span><span>views::take</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of the first N elements of another <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/take_while_view" title="cpp/ranges/take while view"> <span class="t-lines"><span>ranges::take_while_view</span><span>views::take_while</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of the initial elements of another <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a>, until the first element on which a predicate returns false <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/drop_view" title="cpp/ranges/drop view"> <span class="t-lines"><span>ranges::drop_view</span><span>views::drop</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of elements of another <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a>, skipping the first N elements <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/drop_while_view" title="cpp/ranges/drop while view"> <span class="t-lines"><span>ranges::drop_while_view</span><span>views::drop_while</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of the elements of another <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a>, skipping the initial subsequence of elements until the first element where the predicate returns false <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/join_view" title="cpp/ranges/join view"> <span class="t-lines"><span>ranges::join_view</span><span>views::join</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of the sequence obtained from flattening a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> of <a href="../ranges/range" title="cpp/ranges/range"><code>range</code>s</a> <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/lazy_split_view" title="cpp/ranges/lazy split view"> <span class="t-lines"><span>ranges::lazy_split_view</span><span>views::lazy_split</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> over the subranges obtained from splitting another <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> using a delimiter <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/split_view" title="cpp/ranges/split view"> <span class="t-lines"><span>ranges::split_view</span><span>views::split</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> over the subranges obtained from splitting another <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> using a delimiter <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/view_counted" title="cpp/ranges/view counted"> <span class="t-lines"><span>views::counted</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> creates a subrange from an iterator and a count <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/common_view" title="cpp/ranges/common view"> <span class="t-lines"><span>ranges::common_view</span><span>views::common</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> converts a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> into a <a href="../ranges/common_range" title="cpp/ranges/common range"><code>common_range</code></a> <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/reverse_view" title="cpp/ranges/reverse view"> <span class="t-lines"><span>ranges::reverse_view</span><span>views::reverse</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> that iterates over the elements of another bidirectional view in reverse order <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/elements_view" title="cpp/ranges/elements view"> <span class="t-lines"><span>ranges::elements_view</span><span>views::elements</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> takes a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of tuple-like values and a number N and produces a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> of N'th element of each tuple <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/keys_view" title="cpp/ranges/keys view"> <span class="t-lines"><span>ranges::keys_view</span><span>views::keys</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> takes a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of pair-like values and produces a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> of the first elements of each pair <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/values_view" title="cpp/ranges/values view"> <span class="t-lines"><span>ranges::values_view</span><span>views::values</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> takes a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of pair-like values and produces a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> of the second elements of each pair <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/zip_view" title="cpp/ranges/zip view"> <span class="t-lines"><span>ranges::zip_view</span><span>views::zip</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of tuples of references to corresponding elements of the adapted views <br> <span class="t-mark">(class template)</span> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/zip_transform_view" title="cpp/ranges/zip transform view"> <span class="t-lines"><span>ranges::zip_transform_view</span><span>views::zip_transform</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of tuples of results of application of a transformation function to corresponding elements of the adapted views <br> <span class="t-mark">(class template)</span> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/adjacent_view&amp;action=edit&amp;redlink=1" class="new" title="cpp/ranges/adjacent view (page does not exist)"> <span class="t-lines"><span>ranges::adjacent_view</span><span>views::adjacent</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of tuples of references to adjacent elements of the adapted view <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/adjacent_transform_view&amp;action=edit&amp;redlink=1" class="new" title="cpp/ranges/adjacent transform view (page does not exist)"> <span class="t-lines"><span>ranges::adjacent_transform_view</span><span>views::adjacent_transform</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of tuples of results of application of a transformation function to adjacent elements of the adapted view <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/join_with_view" title="cpp/ranges/join with view"> <span class="t-lines"><span>ranges::join_with_view</span><span>views::join_with</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a> consisting of the sequence obtained from flattening a view of ranges, with the delimiter in between elements <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Customization_point_objects">  Customization point objects</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Range_access">  Range access </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/begin" title="cpp/ranges/begin"> <span class="t-lines"><span>ranges::begin</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns an iterator to the beginning of a range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/end" title="cpp/ranges/end"> <span class="t-lines"><span>ranges::end</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns a sentinel indicating the end of a range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/cbegin" title="cpp/ranges/cbegin"> <span class="t-lines"><span>ranges::cbegin</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns an iterator to the beginning of a read-only range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/cend" title="cpp/ranges/cend"> <span class="t-lines"><span>ranges::cend</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns a sentinel indicating the end of a read-only range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/rbegin" title="cpp/ranges/rbegin"> <span class="t-lines"><span>ranges::rbegin</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns a reverse iterator to a range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/rend" title="cpp/ranges/rend"> <span class="t-lines"><span>ranges::rend</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns a reverse end iterator to a range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/crbegin" title="cpp/ranges/crbegin"> <span class="t-lines"><span>ranges::crbegin</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns a reverse iterator to a read-only range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/crend" title="cpp/ranges/crend"> <span class="t-lines"><span>ranges::crend</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns a reverse end iterator to a read-only range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/size" title="cpp/ranges/size"> <span class="t-lines"><span>ranges::size</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns an integer equal to the size of a range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/ssize" title="cpp/ranges/ssize"> <span class="t-lines"><span>ranges::ssize</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns a signed integer equal to the size of a range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/empty" title="cpp/ranges/empty"> <span class="t-lines"><span>ranges::empty</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> checks whether a range is empty <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/data" title="cpp/ranges/data"> <span class="t-lines"><span>ranges::data</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> obtains a pointer to the beginning of a contiguous range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/cdata" title="cpp/ranges/cdata"> <span class="t-lines"><span>ranges::cdata</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> obtains a pointer to the beginning of a read-only contiguous range <br> <span class="t-mark">(customization point object)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Enumerations">  Enumerations</h3> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/subrange_kind" title="cpp/ranges/subrange kind"> <span class="t-lines"><span>ranges::subrange_kind</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specifies whether a <code><a href="../ranges/subrange" title="cpp/ranges/subrange">std::ranges::subrange</a></code> models <code><a href="../ranges/sized_range" title="cpp/ranges/sized range">std::ranges::sized_range</a></code> <br> <span class="t-mark">(enum)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Helpers">  Helpers</h3> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/from_range&amp;action=edit&amp;redlink=1" class="new" title="cpp/ranges/from range (page does not exist)"> <span class="t-lines"><span>from_range</span><span>from_range_t</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> from-range construction tag <br> <span class="t-mark">(class)</span>  </td>
</tr> </table> <h3 id="Synopsis"> Synopsis</h3> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;compare&gt;
#include &lt;initializer_list&gt;
#include &lt;iterator&gt;
 
namespace std::ranges {
  inline namespace /* unspecified */ {
    // range access
    inline constexpr /* unspecified */ begin   = /* unspecified */;
    inline constexpr /* unspecified */ end     = /* unspecified */;
    inline constexpr /* unspecified */ cbegin  = /* unspecified */;
    inline constexpr /* unspecified */ cend    = /* unspecified */;
    inline constexpr /* unspecified */ rbegin  = /* unspecified */;
    inline constexpr /* unspecified */ rend    = /* unspecified */;
    inline constexpr /* unspecified */ crbegin = /* unspecified */;
    inline constexpr /* unspecified */ crend   = /* unspecified */;
 
    inline constexpr /* unspecified */ size    = /* unspecified */;
    inline constexpr /* unspecified */ ssize   = /* unspecified */;
    inline constexpr /* unspecified */ empty   = /* unspecified */;
    inline constexpr /* unspecified */ data    = /* unspecified */;
    inline constexpr /* unspecified */ cdata   = /* unspecified */;
  }
 
  // ranges
  template&lt;class T&gt;
    concept range = /* see description */;
 
  template&lt;class T&gt;
    inline constexpr bool enable_borrowed_range = false;
 
  template&lt;class T&gt;
    concept borrowed_range = /* see description */;
 
  template&lt;class T&gt;
    using iterator_t = decltype(ranges::begin(declval&lt;T&amp;&gt;()));
  template&lt;range R&gt;
    using sentinel_t = decltype(ranges::end(declval&lt;R&amp;&gt;()));
  template&lt;range R&gt;
    using range_difference_t = iter_difference_t&lt;iterator_t&lt;R&gt;&gt;;
  template&lt;sized_range R&gt;
    using range_size_t = decltype(ranges::size(declval&lt;R&amp;&gt;()));
  template&lt;range R&gt;
    using range_value_t = iter_value_t&lt;iterator_t&lt;R&gt;&gt;;
  template&lt;range R&gt;
    using range_reference_t = iter_reference_t&lt;iterator_t&lt;R&gt;&gt;;
  template&lt;range R&gt;
    using range_rvalue_reference_t = iter_rvalue_reference_t&lt;iterator_t&lt;R&gt;&gt;;
 
  // sized ranges
  template&lt;class&gt;
    inline constexpr bool disable_sized_range = false;
 
  template&lt;class T&gt;
    concept sized_range = /* see description */;
 
  // views
  template&lt;class T&gt;
    inline constexpr bool enable_view = /* see description */;
 
  struct view_base {};
 
  template&lt;class T&gt;
    concept view = /* see description */;
 
  // other range refinements
  template&lt;class R, class T&gt;
    concept output_range = /* see description */;
 
  template&lt;class T&gt;
    concept input_range = /* see description */;
 
  template&lt;class T&gt;
    concept forward_range = /* see description */;
 
  template&lt;class T&gt;
    concept bidirectional_range = /* see description */;
 
  template&lt;class T&gt;
    concept random_access_range = /* see description */;
 
  template&lt;class T&gt;
    concept contiguous_range = /* see description */;
 
  template&lt;class T&gt;
    concept common_range = /* see description */;
 
  template&lt;class T&gt;
    concept viewable_range = /* see description */;
 
  // class template view_interface
  template&lt;class D&gt;
    requires is_class_v&lt;D&gt; &amp;&amp; same_as&lt;D, remove_cv_t&lt;D&gt;&gt;
  class view_interface;
 
  // sub-ranges
  enum class subrange_kind : bool { unsized, sized };
 
  template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S = I, subrange_kind K =
      sized_sentinel_for&lt;S, I&gt; ? subrange_kind::sized : subrange_kind::unsized&gt;
    requires (K == subrange_kind::sized || !sized_sentinel_for&lt;S, I&gt;)
  class subrange;
 
  template&lt;class I, class S, subrange_kind K&gt;
    inline constexpr bool enable_borrowed_range&lt;subrange&lt;I, S, K&gt;&gt; = true;
 
  // dangling iterator handling
  struct dangling;
 
  template&lt;range R&gt;
    using borrowed_iterator_t = /* see description */;
 
  template&lt;range R&gt;
    using borrowed_subrange_t = /* see description */;
 
  // range conversions
  template&lt;class C, input_range R, class... Args&gt; requires (!view&lt;C&gt;)
    constexpr C to(R&amp;&amp; r, Args&amp;&amp;... args);
  template&lt;template&lt;class...&gt; class C, input_range R, class... Args&gt;
    constexpr auto to(R&amp;&amp; r, Args&amp;&amp;... args) -&gt; /* see description */;
  template&lt;class C, class... Args&gt; requires (!view&lt;C&gt;)
    constexpr auto to(Args&amp;&amp;... args) -&gt; /* see description */;
  template&lt;template&lt;class...&gt; class C, class... Args&gt;
    constexpr auto to(Args&amp;&amp;... args) -&gt; /* see description */;
 
  // empty view
  template&lt;class T&gt;
    requires is_object_v&lt;T&gt;
  class empty_view;
 
  template&lt;class T&gt;
    inline constexpr bool enable_borrowed_range&lt;empty_view&lt;T&gt;&gt; = true;
 
  namespace views {
    template&lt;class T&gt;
      inline constexpr empty_view&lt;T&gt; empty{};
  }
 
  // single view
  template&lt;copy_constructible T&gt;
    requires is_object_v&lt;T&gt;
  class single_view;
 
  namespace views { inline constexpr /* unspecified */ single = /* unspecified */; }
 
  template&lt;bool Const, class T&gt;
    using /*maybe-const*/ = conditional_t&lt;Const, const T, T&gt;;   // exposition only
 
  // iota view
  template&lt;weakly_incrementable W, semiregular Bound = unreachable_sentinel_t&gt;
    requires /*weakly-equality-comparable-with*/&lt;W, Bound&gt; &amp;&amp; copyable&lt;W&gt;
  class iota_view;
 
  template&lt;class W, class Bound&gt;
    inline constexpr bool enable_borrowed_range&lt;iota_view&lt;W, Bound&gt;&gt; = true;
 
  namespace views { inline constexpr /* unspecified */ iota = /* unspecified */; }
 
  // istream view
  template&lt;movable Val, class CharT, class Traits = char_traits&lt;CharT&gt;&gt;
    requires /* see description */
  class basic_istream_view;
  template&lt;class Val&gt;
    using istream_view = basic_istream_view&lt;Val, char&gt;;
  template&lt;class Val&gt;
    using wistream_view = basic_istream_view&lt;Val, wchar_t&gt;;
 
  namespace views { template&lt;class T&gt;
      inline constexpr /* unspecified */ istream = /* unspecified */; }
 
  // range adaptor objects
  template&lt;class D&gt;
    requires is_class_v&lt;D&gt; &amp;&amp; same_as&lt;D, remove_cv_t&lt;D&gt;&gt;
  class range_adaptor_closure { };
 
  // all view
  namespace views {
    inline constexpr /* unspecified */ all = /* unspecified */;
 
    template&lt;viewable_range R&gt;
      using all_t = decltype(all(declval&lt;R&gt;()));
  }
 
  template&lt;range R&gt;
    requires is_object_v&lt;R&gt;
  class ref_view;
 
  template&lt;class T&gt;
    inline constexpr bool enable_borrowed_range&lt;ref_view&lt;T&gt;&gt; = true;
 
  // owning view
  template&lt;range R&gt;
    requires /* see description */
  class owning_view;
 
  template&lt;class T&gt;
    inline constexpr bool enable_borrowed_range&lt;owning_view&lt;T&gt;&gt; =
      enable_borrowed_range&lt;T&gt;;
 
  // filter view
  template&lt;input_range V, indirect_unary_predicate&lt;iterator_t&lt;V&gt;&gt; Pred&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class filter_view;
 
  namespace views { inline constexpr /* unspecified */ filter = /* unspecified */; }
 
  // transform view
  template&lt;input_range V, copy_constructible F&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, range_reference_t&lt;V&gt;&gt; &amp;&amp;
             /*can-reference*/&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;V&gt;&gt;&gt;
  class transform_view;
 
  namespace views { inline constexpr /* unspecified */ transform = /* unspecified */; }
 
  // take view
  template&lt;view&gt; class take_view;
 
  template&lt;class T&gt;
    inline constexpr bool enable_borrowed_range&lt;take_view&lt;T&gt;&gt; = enable_borrowed_range&lt;T&gt;;
 
  namespace views { inline constexpr /* unspecified */ take = /* unspecified */; }
 
  // take while view
  template&lt;view V, class Pred&gt;
    requires input_range&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt; &amp;&amp;
             indirect_unary_predicate&lt;const Pred, iterator_t&lt;V&gt;&gt;
    class take_while_view;
 
  namespace views { inline constexpr /* unspecified */ take_while = /* unspecified */; }
 
  // drop view
  template&lt;view V&gt;
    class drop_view;
 
  template&lt;class T&gt;
    inline constexpr bool enable_borrowed_range&lt;drop_view&lt;T&gt;&gt; = enable_borrowed_range&lt;T&gt;;
 
  namespace views { inline constexpr /* unspecified */ drop = /* unspecified */; }
 
  // drop while view
  template&lt;view V, class Pred&gt;
    requires input_range&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt; &amp;&amp;
             indirect_unary_predicate&lt;const Pred, iterator_t&lt;V&gt;&gt;
    class drop_while_view;
 
  template&lt;class T, class Pred&gt;
    inline constexpr bool enable_borrowed_range&lt;drop_while_view&lt;T, Pred&gt;&gt; =
      enable_borrowed_range&lt;T&gt;;
 
  namespace views { inline constexpr /* unspecified */ drop_while = /* unspecified */; }
 
  // join view
  template&lt;input_range V&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
  class join_view;
 
  namespace views { inline constexpr /* unspecified */ join = /* unspecified */; }
 
  // join with view
  template&lt;class R, class P&gt;
    concept /*compatible-joinable-ranges*/ = /* see description */;
 
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
          &amp;&amp; view&lt;Pattern&gt;
          &amp;&amp; /*compatible-joinable-ranges*/&lt;range_reference_t&lt;V&gt;, Pattern&gt;
  class join_with_view;
 
  namespace view { inline constexpr /* unspecified */ join_with = /* unspecified */; }
 
  // lazy split view
  template&lt;class R&gt;
    concept /*tiny-range*/ = /* see description */;   // exposition only
 
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt;
             &amp;&amp; (forward_range&lt;V&gt; || /*tiny-range*/&lt;Pattern&gt;)
  class lazy_split_view;
 
  // split view
 template&lt;forward_range V, forward_range Pattern&gt;
   requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
            indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt;
  class split_view;
 
  namespace views {
    inline constexpr /* unspecified */ lazy_split = /* unspecified */;
    inline constexpr /* unspecified */ split = /* unspecified */;
  }
 
  // counted view
  namespace views { inline constexpr /* unspecified */ counted = /* unspecified */; }
 
  // common view
  template&lt;view V&gt;
    requires (!common_range&lt;V&gt; &amp;&amp; copyable&lt;iterator_t&lt;V&gt;&gt;)
  class common_view;
 
  template&lt;class T&gt;
    inline constexpr bool enable_borrowed_range&lt;common_view&lt;T&gt;&gt; =
      enable_borrowed_range&lt;T&gt;;
 
  namespace views { inline constexpr /* unspecified */ common = /* unspecified */; }
 
  // reverse view
  template&lt;view V&gt;
    requires bidirectional_range&lt;V&gt;
  class reverse_view;
 
  template&lt;class T&gt;
    inline constexpr bool enable_borrowed_range&lt;reverse_view&lt;T&gt;&gt; =
      enable_borrowed_range&lt;T&gt;;
 
  namespace views { inline constexpr /* unspecified */ reverse = /* unspecified */; }
 
  // elements view
  template&lt;input_range V, size_t N&gt;
    requires /* see description */
  class elements_view;
 
  template&lt;class T, size_t N&gt;
    inline constexpr bool enable_borrowed_range&lt;elements_view&lt;T, N&gt;&gt; =
      enable_borrowed_range&lt;T&gt;;
 
  template&lt;class R&gt;
    using keys_view = elements_view&lt;R, 0&gt;;
  template&lt;class R&gt;
    using values_view = elements_view&lt;R, 1&gt;;
 
  namespace views {
    template&lt;size_t N&gt;
      inline constexpr /* unspecified */ elements = /* unspecified */;
    inline constexpr auto keys = elements&lt;0&gt;;
    inline constexpr auto values = elements&lt;1&gt;;
  }
 
  // zip view
  template&lt;input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0)
  class zip_view;
 
  template&lt;class... Views&gt;
    inline constexpr bool enable_borrowed_range&lt;zip_view&lt;Views...&gt;&gt; =
      (enable_borrowed_range&lt;Views&gt; &amp;&amp; ...);
 
  namespace views { inline constexpr /* unspecified */ zip = /* unspecified */; }
 
  // zip transform view
  template&lt;copy_constructible F, input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt; &amp;&amp;
             /*can-reference*/&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt;&gt;
  class zip_transform_view;
 
  namespace views {
    inline constexpr /* unspecified */ zip_transform = /* unspecified */; }
 
  // adjacent view
  template&lt;forward_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0)
  class adjacent_view;
 
  template&lt;class V, size_t N&gt;
    inline constexpr bool enable_borrowed_range&lt;adjacent_view&lt;V, N&gt;&gt; =
      enable_borrowed_range&lt;V&gt;;
 
  namespace views {
    template&lt;size_t N&gt;
      inline constexpr /* unspecified */ adjacent = /* unspecified */ ;
    inline constexpr auto pairwise = adjacent&lt;2&gt;;
  }
 
  // adjacent transform view
  template&lt;forward_range V, copy_constructible F, size_t N&gt;
    requires /* see description */
  class adjacent_transform_view;
 
  namespace views {
    template&lt;size_t N&gt;
      inline constexpr /* unspecified */ adjacent_transform = /* unspecified */;
    inline constexpr auto pairwise_transform = adjacent_transform&lt;2&gt;;
  }
 
  // chunk view
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class chunk_view;
 
  template&lt;view V&gt;
    requires forward_range&lt;V&gt;
  class chunk_view&lt;V&gt;;
 
  template&lt;class V&gt;
    inline constexpr bool enable_borrowed_range&lt;chunk_view&lt;V&gt;&gt; =
      forward_range&lt;V&gt; &amp;&amp; enable_borrowed_range&lt;V&gt;;
 
  namespace views { inline constexpr /* unspecified */ chunk = /* unspecified */; }
 
  // slide view
  template&lt;view V&gt;
    requires forward_range&lt;V&gt;
  class slide_view;
 
  template&lt;class V&gt;
    inline constexpr bool enable_borrowed_range&lt;slide_view&lt;V&gt;&gt; =
      enable_borrowed_range&lt;V&gt;;
 
  namespace views { inline constexpr /* unspecified */ slide = /* unspecified */; }
 
  // chunk by view
  template&lt;forward_range V, indirect_binary_predicate&lt;iterator_t&lt;V&gt;, iterator_t&lt;V&gt;&gt; Pred&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class chunk_by_view;
 
  namespace views { inline constexpr /* unspecified */ chunk_by = /* unspecified */; }
}
 
namespace std {
  namespace views = ranges::views;
 
  template&lt;class T&gt; struct tuple_size;
  template&lt;size_t I, class T&gt; struct tuple_element;
 
  template&lt;class I, class S, ranges::subrange_kind K&gt;
  struct tuple_size&lt;ranges::subrange&lt;I, S, K&gt;&gt;
    : integral_constant&lt;size_t, 2&gt; {};
  template&lt;class I, class S, ranges::subrange_kind K&gt;
  struct tuple_element&lt;0, ranges::subrange&lt;I, S, K&gt;&gt; {
    using type = I;
  };
  template&lt;class I, class S, ranges::subrange_kind K&gt;
  struct tuple_element&lt;1, ranges::subrange&lt;I, S, K&gt;&gt; {
    using type = S;
  };
  template&lt;class I, class S, ranges::subrange_kind K&gt;
  struct tuple_element&lt;0, const ranges::subrange&lt;I, S, K&gt;&gt; {
    using type = I;
  };
  template&lt;class I, class S, ranges::subrange_kind K&gt;
  struct tuple_element&lt;1, const ranges::subrange&lt;I, S, K&gt;&gt; {
    using type = S;
  };
 
  struct from_range_t { explicit from_range_t() = default; };
  inline constexpr from_range_t from_range{};
}</pre></div> <h4 id="Concept_range"> Concept <a href="../ranges/range" title="cpp/ranges/range"><code>range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt; class T &gt;
    concept range = requires(T&amp; t) {
      ranges::begin(t); // equality-preserving for forward iterators
      ranges::end(t);
  };
}</pre></div> <h4 id="Concept_borrowed_range"> Concept <a href="../ranges/borrowed_range" title="cpp/ranges/borrowed range"><code>borrowed_range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept borrowed_range =
      range&lt;T&gt; &amp;&amp; (is_lvalue_reference_v&lt;T&gt; ||
        enable_borrowed_range&lt;remove_cvref_t&lt;T&gt;&gt;);
}</pre></div> <h4 id="Concept_sized_range"> Concept <a href="../ranges/sized_range" title="cpp/ranges/sized range"><code>sized_range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt; class T &gt;
    concept sized_range = range&lt;T&gt; &amp;&amp;
      requires(T&amp; t) {
        ranges::size(t);
      };
}</pre></div> <h4 id="Concept_view"> Concept <a href="../ranges/view" title="cpp/ranges/view"><code>view</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    inline constexpr bool enable_view = derived_from&lt;T, view_base&gt;;
 
  template&lt;class T&gt;
    concept view = range&lt;T&gt;
                &amp;&amp; movable&lt;T&gt;
                &amp;&amp; enable_view&lt;T&gt;;
}</pre></div> <h4 id="Concept_output_range"> Concept <a href="../ranges/output_range" title="cpp/ranges/output range"><code>output_range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class R, class T&gt;
    concept output_range =
      range&lt;R&gt; &amp;&amp; output_iterator&lt;iterator_t&lt;R&gt;, T&gt;;
}</pre></div> <h4 id="Concept_input_range"> Concept <a href="../ranges/input_range" title="cpp/ranges/input range"><code>input_range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept input_range =
      range&lt;T&gt; &amp;&amp; input_iterator&lt;iterator_t&lt;T&gt;&gt;;
}</pre></div> <h4 id="Concept_forward_range"> Concept <a href="../ranges/forward_range" title="cpp/ranges/forward range"><code>forward_range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept forward_range =
      input_range&lt;T&gt; &amp;&amp; forward_iterator&lt;iterator_t&lt;T&gt;&gt;;
}</pre></div> <h4 id="Concept_bidirectional_range"> Concept <a href="../ranges/bidirectional_range" title="cpp/ranges/bidirectional range"><code>bidirectional_range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept bidirectional_range =
      forward_range&lt;T&gt; &amp;&amp; bidirectional_iterator&lt;iterator_t&lt;T&gt;&gt;;
}</pre></div> <h4 id="Concept_random_access_range"> Concept <a href="../ranges/random_access_range" title="cpp/ranges/random access range"><code>random_access_range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept random_access_range =
      bidirectional_range&lt;T&gt; &amp;&amp; random_access_iterator&lt;iterator_t&lt;T&gt;&gt;;
}</pre></div> <h4 id="Concept_contiguous_range"> Concept <a href="../ranges/contiguous_range" title="cpp/ranges/contiguous range"><code>contiguous_range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept contiguous_range =
      random_access_range&lt;T&gt; &amp;&amp; contiguous_iterator&lt;iterator_t&lt;T&gt;&gt; &amp;&amp;
        requires(T&amp; t) {
          { ranges::data(t) } -&gt; same_as&lt;add_pointer_t&lt;range_reference_t&lt;T&gt;&gt;&gt;;
        };
}</pre></div> <h4 id="Concept_common_range"> Concept <a href="../ranges/common_range" title="cpp/ranges/common range"><code>common_range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept common_range =
      range&lt;T&gt; &amp;&amp; same_as&lt;iterator_t&lt;T&gt;, sentinel_t&lt;T&gt;&gt;;
}</pre></div> <h4 id="Concept_viewable_range"> Concept <a href="../ranges/viewable_range" title="cpp/ranges/viewable range"><code>viewable_range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept viewable_range =
      range&lt;T&gt; &amp;&amp; (borrowed_range&lt;T&gt; || view&lt;remove_cvref_t&lt;T&gt;&gt;);
}</pre></div> <h4 id="Helper_concepts"> Helper concepts</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges { // unspecified, for name lookup only
  template&lt;class R&gt;
    concept /*simple-view*/ =                                     // exposition only
      view&lt;R&gt; &amp;&amp; range&lt;const R&gt; &amp;&amp;
      same_as&lt;iterator_t&lt;R&gt;, iterator_t&lt;const R&gt;&gt; &amp;&amp;
      same_as&lt;sentinel_t&lt;R&gt;, sentinel_t&lt;const R&gt;&gt;;
 
  template&lt;class I&gt;
    concept /*has-arrow*/ =                                       // exposition only
      input_iterator&lt;I&gt; &amp;&amp;
      (is_pointer_v&lt;I&gt; || requires(I i) { i.operator-&gt;(); });
 
  template&lt;class T, class U&gt;
    concept /*different-from*/ =                                  // exposition only
      !same_as&lt;remove_cvref_t&lt;T&gt;, remove_cvref_t&lt;U&gt;&gt;;
 
  template&lt;class I&gt;
    concept /*decrementable*/ =                                   // exposition only
      incrementable&lt;I&gt; &amp;&amp; requires(I i) {
        { --i } -&gt; same_as&lt;I&amp;&gt;;
        { i-- } -&gt; same_as&lt;I&gt;;
      };
 
  template&lt;class I&gt;
    concept /*advanceable*/ =                                     // exposition only
      /*decrementable*/&lt;I&gt; &amp;&amp; totally_ordered&lt;I&gt; &amp;&amp;
      requires(I i, const I j, const iter_difference_t&lt;I&gt; n) {
          { i += n } -&gt; same_as&lt;I&amp;&gt;;
          { i -= n } -&gt; same_as&lt;I&amp;&gt;;
        I { j +  n };
        I { n +  j };
        I { j -  n };
          { j -  j } -&gt; convertible_to&lt;iter_difference_t&lt;I&gt;&gt;;
      };
}</pre></div> <p>Note: These names are only for exposition, they are not part of the interface.</p>
<h4 id="Class_template_std::ranges::view_interface"> Class template <code>std::ranges::view_interface</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class D&gt;
    requires is_class_v&lt;D&gt; &amp;&amp; same_as&lt;D, remove_cv_t&lt;D&gt;&gt;
  class view_interface {
  private:
    constexpr D&amp; derived() noexcept {               // exposition only
      return static_cast&lt;D&amp;&gt;(*this);
    }
    constexpr const D&amp; derived() const noexcept {   // exposition only
      return static_cast&lt;const D&amp;&gt;(*this);
    }
 
  public:
    constexpr bool empty() requires forward_range&lt;D&gt; {
      return ranges::begin(derived()) == ranges::end(derived());
    }
    constexpr bool empty() const requires forward_range&lt;const D&gt; {
      return ranges::begin(derived()) == ranges::end(derived());
    }
 
    constexpr explicit operator bool()
      requires requires { ranges::empty(derived()); } {
        return !ranges::empty(derived());
      }
    constexpr explicit operator bool() const
      requires requires { ranges::empty(derived()); } {
        return !ranges::empty(derived());
      }
 
    constexpr auto data() requires contiguous_iterator&lt;iterator_t&lt;D&gt;&gt; {
      return to_address(ranges::begin(derived()));
    }
    constexpr auto data() const
      requires range&lt;const D&gt; &amp;&amp; contiguous_iterator&lt;iterator_t&lt;const D&gt;&gt; {
        return to_address(ranges::begin(derived()));
      }
 
    constexpr auto size() requires forward_range&lt;D&gt; &amp;&amp;
      sized_sentinel_for&lt;sentinel_t&lt;D&gt;, iterator_t&lt;D&gt;&gt; {
        return ranges::end(derived()) - ranges::begin(derived());
      }
    constexpr auto size() const requires forward_range&lt;const D&gt; &amp;&amp;
      sized_sentinel_for&lt;sentinel_t&lt;const D&gt;, iterator_t&lt;const D&gt;&gt; {
        return ranges::end(derived()) - ranges::begin(derived());
      }
 
    constexpr decltype(auto) front() requires forward_range&lt;D&gt;;
    constexpr decltype(auto) front() const requires forward_range&lt;const D&gt;;
 
    constexpr decltype(auto) back() requires bidirectional_range&lt;D&gt; &amp;&amp; common_range&lt;D&gt;;
    constexpr decltype(auto) back() const
      requires bidirectional_range&lt;const D&gt; &amp;&amp; common_range&lt;const D&gt;;
 
    template&lt;random_access_range R = D&gt;
      constexpr decltype(auto) operator[](range_difference_t&lt;R&gt; n) {
        return ranges::begin(derived())[n];
      }
    template&lt;random_access_range R = const D&gt;
      constexpr decltype(auto) operator[](range_difference_t&lt;R&gt; n) const {
        return ranges::begin(derived())[n];
      }
  };
}</pre></div> <h4 id="Class_template_std::ranges::subrange"> Class template <code><a href="../ranges/subrange" title="cpp/ranges/subrange">std::ranges::subrange</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class From, class To&gt;
    concept /*uses-nonqualification-pointer-conversion*/ =      // exposition only
      is_pointer_v&lt;From&gt; &amp;&amp; is_pointer_v&lt;To&gt; &amp;&amp;
      !convertible_to&lt;remove_pointer_t&lt;From&gt;(*)[], remove_pointer_t&lt;To&gt;(*)[]&gt;;
 
  template&lt;class From, class To&gt;
    concept /*convertible-to-non-slicing*/ =                    // exposition only
      convertible_to&lt;From, To&gt; &amp;&amp;
      !/*uses-nonqualification-pointer-conversion*/&lt;decay_t&lt;From&gt;, decay_t&lt;To&gt;&gt;;
 
  template&lt;class T&gt;
    concept /*pair-like*/ =                                     // exposition only
      !is_reference_v&lt;T&gt; &amp;&amp; requires(T t) {
        typename tuple_size&lt;T&gt;::type;                       // ensures tuple_size&lt;T&gt;
                                                            // is complete
        requires derived_from&lt;tuple_size&lt;T&gt;, integral_constant&lt;size_t, 2&gt;&gt;;
        typename tuple_element_t&lt;0, remove_const_t&lt;T&gt;&gt;;
        typename tuple_element_t&lt;1, remove_const_t&lt;T&gt;&gt;;
        { std::get&lt;0&gt;(t) } -&gt; convertible_to&lt;const tuple_element_t&lt;0, T&gt;&amp;&gt;;
        { std::get&lt;1&gt;(t) } -&gt; convertible_to&lt;const tuple_element_t&lt;1, T&gt;&amp;&gt;;
      };
 
  template&lt;class T, class U, class V&gt;
    concept /*pair-like-convertible-from*/ =                    // exposition only
      !range&lt;T&gt; &amp;&amp; /*pair-like*/&lt;T&gt; &amp;&amp;
      constructible_from&lt;T, U, V&gt; &amp;&amp;
      /*convertible-to-non-slicing*/&lt;U, tuple_element_t&lt;0, T&gt;&gt; &amp;&amp;
      convertible_to&lt;V, tuple_element_t&lt;1, T&gt;&gt;;
 
  template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S = I, subrange_kind K =
      sized_sentinel_for&lt;S, I&gt; ? subrange_kind::sized : subrange_kind::unsized&gt;
    requires (K == subrange_kind::sized || !sized_sentinel_for&lt;S, I&gt;)
  class subrange : public view_interface&lt;subrange&lt;I, S, K&gt;&gt; {
  private:
    static constexpr bool StoreSize =                       // exposition only
      K == subrange_kind::sized &amp;&amp; !sized_sentinel_for&lt;S, I&gt;;
    I begin_ = I();                                         // exposition only
    S end_ = S();                                           // exposition only
    /*make-unsigned-like-t*/&lt;iter_difference_t&lt;I&gt;&gt; size_ = 0;   // exposition only;
                                                                // present only
                                                                // when StoreSize is true
  public:
    subrange() requires default_initializable&lt;I&gt; = default;
 
    constexpr subrange(/*convertible-to-non-slicing*/&lt;I&gt; auto i, S s)
      requires (!StoreSize);
 
    constexpr subrange(/*convertible-to-non-slicing*/&lt;I&gt; auto i, S s,
                       /*make-unsigned-like-t*/&lt;iter_difference_t&lt;I&gt;&gt; n)
      requires (K == subrange_kind::sized);
 
    template&lt;/*different-from*/&lt;subrange&gt; R&gt;
      requires borrowed_range&lt;R&gt; &amp;&amp;
               /*convertible-to-non-slicing*/&lt;iterator_t&lt;R&gt;, I&gt; &amp;&amp;
               convertible_to&lt;sentinel_t&lt;R&gt;, S&gt;
    constexpr subrange(R&amp;&amp; r) requires (!StoreSize || sized_range&lt;R&gt;);
 
    template&lt;borrowed_range R&gt;
      requires /*convertible-to-non-slicing*/&lt;iterator_t&lt;R&gt;, I&gt; &amp;&amp;
               convertible_to&lt;sentinel_t&lt;R&gt;, S&gt;
    constexpr subrange(R&amp;&amp; r, /*make-unsigned-like-t*/&lt;iter_difference_t&lt;I&gt;&gt; n)
      requires (K == subrange_kind::sized)
        : subrange{ranges::begin(r), ranges::end(r), n} {}
 
    template&lt;/*different-from*/&lt;subrange&gt; PairLike&gt;
      requires /*pair-like-convertible-from*/&lt;PairLike, const I&amp;, const S&amp;&gt;
    constexpr operator PairLike() const;
 
    constexpr I begin() const requires copyable&lt;I&gt;;
    [[nodiscard]] constexpr I begin() requires (!copyable&lt;I&gt;);
    constexpr S end() const;
 
    constexpr bool empty() const;
    constexpr /*make-unsigned-like-t*/&lt;iter_difference_t&lt;I&gt;&gt; size() const
      requires (K == subrange_kind::sized);
 
    [[nodiscard]] constexpr subrange next(iter_difference_t&lt;I&gt; n = 1) const &amp;
      requires forward_iterator&lt;I&gt;;
    [[nodiscard]] constexpr subrange next(iter_difference_t&lt;I&gt; n = 1) &amp;&amp;;
    [[nodiscard]] constexpr subrange prev(iter_difference_t&lt;I&gt; n = 1) const
      requires bidirectional_iterator&lt;I&gt;;
    constexpr subrange&amp; advance(iter_difference_t&lt;I&gt; n);
  };
 
  template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S&gt;
    subrange(I, S) -&gt; subrange&lt;I, S&gt;;
 
  template&lt;input_or_output_iterator I, sentinel_for&lt;I&gt; S&gt;
    subrange(I, S, /*make-unsigned-like-t*/&lt;iter_difference_t&lt;I&gt;&gt;) -&gt;
      subrange&lt;I, S, subrange_kind::sized&gt;;
 
  template&lt;borrowed_range R&gt;
    subrange(R&amp;&amp;) -&gt;
      subrange&lt;iterator_t&lt;R&gt;, sentinel_t&lt;R&gt;,
               (sized_range&lt;R&gt; || sized_sentinel_for&lt;sentinel_t&lt;R&gt;, iterator_t&lt;R&gt;&gt;)
                 ? subrange_kind::sized : subrange_kind::unsized&gt;;
 
  template&lt;borrowed_range R&gt;
    subrange(R&amp;&amp;, /*make-unsigned-like-t*/&lt;range_difference_t&lt;R&gt;&gt;) -&gt;
      subrange&lt;iterator_t&lt;R&gt;, sentinel_t&lt;R&gt;, subrange_kind::sized&gt;;
 
  template&lt;size_t N, class I, class S, subrange_kind K&gt;
    requires ((N == 0 &amp;&amp; copyable&lt;I&gt;) || N == 1)
    constexpr auto get(const subrange&lt;I, S, K&gt;&amp; r);
 
  template&lt;size_t N, class I, class S, subrange_kind K&gt;
    requires (N &lt; 2)
    constexpr auto get(subrange&lt;I, S, K&gt;&amp;&amp; r);
}
 
namespace std {
  using ranges::get;
}</pre></div> <h4 id="Class_std::ranges::dangling"> Class <code><a href="../ranges/dangling" title="cpp/ranges/dangling">std::ranges::dangling</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  struct dangling {
    constexpr dangling() noexcept = default;
    constexpr dangling(auto&amp;&amp;...) noexcept {}
  };
}</pre></div> <h4 id="Class_template_std::ranges::empty_view"> Class template <code><a href="../ranges/empty_view" title="cpp/ranges/empty view">std::ranges::empty_view</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    requires is_object_v&lt;T&gt;
  class empty_view : public view_interface&lt;empty_view&lt;T&gt;&gt; {
  public:
    static constexpr T* begin() noexcept { return nullptr; }
    static constexpr T* end() noexcept { return nullptr; }
    static constexpr T* data() noexcept { return nullptr; }
    static constexpr size_t size() noexcept { return 0; }
    static constexpr bool empty() noexcept { return true; }
  };
}</pre></div> <h4 id="Class_template_std::ranges::single_view"> Class template <code>std::ranges::single_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;copy_constructible T&gt;
    requires is_object_v&lt;T&gt;
  class single_view : public view_interface&lt;single_view&lt;T&gt;&gt; {
  private:
    /*copyable-box*/&lt;T&gt; value_;             // exposition only
 
  public:
    single_view() requires default_initializable&lt;T&gt; = default;
    constexpr explicit single_view(const T&amp; t);
    constexpr explicit single_view(T&amp;&amp; t);
    template&lt;class... Args&gt;
      requires constructible_from&lt;T, Args...&gt;
    constexpr explicit single_view(in_place_t, Args&amp;&amp;... args);
 
    constexpr T* begin() noexcept;
    constexpr const T* begin() const noexcept;
    constexpr T* end() noexcept;
    constexpr const T* end() const noexcept;
    static constexpr size_t size() noexcept;
    constexpr T* data() noexcept;
    constexpr const T* data() const noexcept;
  };
 
  template&lt;class T&gt;
    single_view(T) -&gt; single_view&lt;T&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::iota_view"> Class template <code><a href="../ranges/iota_view" title="cpp/ranges/iota view">std::ranges::iota_view</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class I&gt;
    concept decrementable = /* see description */;  // exposition only
 
  template&lt;class I&gt;
    concept advanceable = /* see description */;    // exposition only
 
  template&lt;weakly_incrementable W, semiregular Bound = unreachable_sentinel_t&gt;
    requires /*weakly-equality-comparable-with*/&lt;W, Bound&gt; &amp;&amp; copyable&lt;W&gt;
  class iota_view : public view_interface&lt;iota_view&lt;W, Bound&gt;&gt; {
  private:
    // class iota_view::iterator
    struct iterator;                    // exposition only
 
    // class iota_view::sentinel
    struct sentinel;                    // exposition only
 
    W value_ = W();                     // exposition only
    Bound bound_ = Bound();             // exposition only
 
  public:
    iota_view() requires default_initializable&lt;W&gt; = default;
    constexpr explicit iota_view(W value);
    constexpr iota_view(type_identity_t&lt;W&gt; value, type_identity_t&lt;Bound&gt; bound);
    constexpr iota_view(iterator first, /* see description */ last);
 
    constexpr iterator begin() const;
    constexpr auto end() const;
    constexpr iterator end() const requires same_as&lt;W, Bound&gt;;
 
    constexpr auto size() const requires /* see description */;
  };
 
  template&lt;class W, class Bound&gt;
    requires (!/*is-integer-like*/&lt;W&gt; || !/*is-integer-like*/&lt;Bound&gt; ||
              (/*is-signed-integer-like*/&lt;W&gt; == /*is-signed-integer-like*/&lt;Bound&gt;))
    iota_view(W, Bound) -&gt; iota_view&lt;W, Bound&gt;;
}</pre></div> <h4 id="Class_std::ranges::iota_view::iterator"> Class <code>std::ranges::iota_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;weakly_incrementable W, semiregular Bound&gt;
    requires /*weakly-equality-comparable-with*/&lt;W, Bound&gt; &amp;&amp; copyable&lt;W&gt;
  struct iota_view&lt;W, Bound&gt;::iterator {
  private:
    W value_ = W();             // exposition only
  public:
    using iterator_concept = /* see description */;
    using iterator_category = input_iterator_tag; // present only if W models incrementable
    using value_type = W;
    using difference_type = /*IOTA-DIFF-T*/(W);
 
    iterator() requires default_initializable&lt;W&gt; = default;
    constexpr explicit iterator(W value);
 
    constexpr W operator*() const noexcept(is_nothrow_copy_constructible_v&lt;W&gt;);
 
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires incrementable&lt;W&gt;;
 
    constexpr iterator&amp; operator--() requires /*decrementable*/&lt;W&gt;;
    constexpr iterator operator--(int) requires /*decrementable*/&lt;W&gt;;
 
    constexpr iterator&amp; operator+=(difference_type n)
      requires /*advanceable*/&lt;W&gt;;
    constexpr iterator&amp; operator-=(difference_type n)
      requires /*advanceable*/&lt;W&gt;;
    constexpr W operator[](difference_type n) const
      requires /*advanceable*/&lt;W&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
      requires equality_comparable&lt;W&gt;;
 
    friend constexpr bool operator&lt;(const iterator&amp; x, const iterator&amp; y)
      requires totally_ordered&lt;W&gt;;
    friend constexpr bool operator&gt;(const iterator&amp; x, const iterator&amp; y)
      requires totally_ordered&lt;W&gt;;
    friend constexpr bool operator&lt;=(const iterator&amp; x, const iterator&amp; y)
      requires totally_ordered&lt;W&gt;;
    friend constexpr bool operator&gt;=(const iterator&amp; x, const iterator&amp; y)
      requires totally_ordered&lt;W&gt;;
    friend constexpr auto operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
      requires totally_ordered&lt;W&gt; &amp;&amp; three_way_comparable&lt;W&gt;;
 
    friend constexpr iterator operator+(iterator i, difference_type n)
      requires /*advanceable*/&lt;W&gt;;
    friend constexpr iterator operator+(difference_type n, iterator i)
      requires /*advanceable*/&lt;W&gt;;
 
    friend constexpr iterator operator-(iterator i, difference_type n)
      requires /*advanceable*/&lt;W&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires /*advanceable*/&lt;W&gt;;
  };
}</pre></div> <h4 id="Class_std::ranges::iota_view::sentinel"> Class <code>std::ranges::iota_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;weakly_incrementable W, semiregular Bound&gt;
    requires /*weakly-equality-comparable-with*/&lt;W, Bound&gt; &amp;&amp; copyable&lt;W&gt;
  struct iota_view&lt;W, Bound&gt;::sentinel {
  private:
    Bound bound_ = Bound();     // exposition only
  public:
    sentinel() = default;
    constexpr explicit sentinel(Bound bound);
 
    friend constexpr bool operator==(const iterator&amp; x, const sentinel&amp; y);
 
    friend constexpr iter_difference_t&lt;W&gt; operator-(const iterator&amp; x, const sentinel&amp; y)
      requires sized_sentinel_for&lt;Bound, W&gt;;
    friend constexpr iter_difference_t&lt;W&gt; operator-(const sentinel&amp; x, const iterator&amp; y)
      requires sized_sentinel_for&lt;Bound, W&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::basic_istream_view"> Class template <code>std::ranges::basic_istream_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class Val, class CharT, class Traits&gt;
    concept /*stream-extractable*/ =                // exposition only
      requires(basic_istream&lt;CharT, Traits&gt;&amp; is, Val&amp; t) {
         is &gt;&gt; t;
      };
 
  template&lt;movable Val, class CharT, class Traits = char_traits&lt;CharT&gt;&gt;
    requires default_initializable&lt;Val&gt; &amp;&amp;
             /*stream-extractable*/&lt;Val, CharT, Traits&gt;
  class basic_istream_view :
    public view_interface&lt;basic_istream_view&lt;Val, CharT, Traits&gt;&gt; {
  public:
    constexpr explicit basic_istream_view(basic_istream&lt;CharT, Traits&gt;&amp; stream);
 
    constexpr auto begin() {
      *stream_ &gt;&gt; value_;
      return iterator{*this};
    }
 
    constexpr default_sentinel_t end() const noexcept;
 
  private:
    struct iterator;                            // exposition only
    basic_istream&lt;CharT, Traits&gt;* stream_;      // exposition only
    Val value_ = Val();                         // exposition only
  };
}</pre></div> <h4 id="Class_template_std::ranges::basic_istream_view::iterator"> Class template <code>std::ranges::basic_istream_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;movable Val, class CharT, class Traits&gt;
    requires default_initializable&lt;Val&gt; &amp;&amp;
             /*stream-extractable*/&lt;Val, CharT, Traits&gt;
  class basic_istream_view&lt;Val, CharT, Traits&gt;::iterator {
  public:
    using iterator_concept = input_iterator_tag;
    using difference_type = ptrdiff_t;
    using value_type = Val;
 
    constexpr explicit iterator(basic_istream_view&amp; parent) noexcept;
 
    iterator(const iterator&amp;) = delete;
    iterator(iterator&amp;&amp;) = default;
 
    iterator&amp; operator=(const iterator&amp;) = delete;
    iterator&amp; operator=(iterator&amp;&amp;) = default;
 
    iterator&amp; operator++();
    void operator++(int);
 
    Val&amp; operator*() const;
 
    friend bool operator==(const iterator&amp; x, default_sentinel_t);
 
  private:
    basic_istream_view* parent_;                                // exposition only
  };
}</pre></div> <h4 id="Class_template_std::ranges::ref_view"> Class template <code><a href="../ranges/ref_view" title="cpp/ranges/ref view">std::ranges::ref_view</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;range R&gt;
    requires is_object_v&lt;R&gt;
  class ref_view : public view_interface&lt;ref_view&lt;R&gt;&gt; {
  private:
    R* r_;                      // exposition only
  public:
    template&lt;/*different-from*/&lt;ref_view&gt; T&gt;
      requires /* see description */
    constexpr ref_view(T&amp;&amp; t);
 
    constexpr R&amp; base() const { return *r_; }
 
    constexpr iterator_t&lt;R&gt; begin() const { return ranges::begin(*r_); }
    constexpr sentinel_t&lt;R&gt; end() const { return ranges::end(*r_); }
 
    constexpr bool empty() const
      requires requires { ranges::empty(*r_); }
    { return ranges::empty(*r_); }
 
    constexpr auto size() const requires sized_range&lt;R&gt;
    { return ranges::size(*r_); }
 
    constexpr auto data() const requires contiguous_range&lt;R&gt;
    { return ranges::data(*r_); }
  };
 
  template&lt;class R&gt;
    ref_view(R&amp;) -&gt; ref_view&lt;R&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::owning_view"> Class template <code>std::ranges::owning_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;range R&gt;
    requires movable&lt;R&gt; &amp;&amp; (!/*is-initializer-list*/&lt;R&gt;)
  class owning_view : public view_interface&lt;owning_view&lt;R&gt;&gt; {
  private:
    R r_ = R();         // exposition only
  public:
    owning_view() requires default_initializable&lt;R&gt; = default;
    constexpr owning_view(R&amp;&amp; t);
 
    owning_view(owning_view&amp;&amp;) = default;
    owning_view&amp; operator=(owning_view&amp;&amp;) = default;
 
    constexpr R&amp; base() &amp; noexcept { return r_; }
    constexpr const R&amp; base() const&amp; noexcept { return r_; }
    constexpr R&amp;&amp; base() &amp;&amp; noexcept { return std::move(r_); }
    constexpr const R&amp;&amp; base() const&amp;&amp; noexcept { return std::move(r_); }
 
    constexpr iterator_t&lt;R&gt; begin() { return ranges::begin(r_); }
    constexpr sentinel_t&lt;R&gt; end() { return ranges::end(r_); }
 
    constexpr auto begin() const requires range&lt;const R&gt;
    { return ranges::begin(r_); }
    constexpr auto end() const requires range&lt;const R&gt;
    { return ranges::end(r_); }
 
    constexpr bool empty() requires requires { ranges::empty(r_); }
    { return ranges::empty(r_); }
    constexpr bool empty() const requires requires { ranges::empty(r_); }
    { return ranges::empty(r_); }
 
    constexpr auto size() requires sized_range&lt;R&gt;
    { return ranges::size(r_); }
    constexpr auto size() const requires sized_range&lt;const R&gt;
    { return ranges::size(r_); }
 
    constexpr auto data() requires contiguous_range&lt;R&gt;
    { return ranges::data(r_); }
    constexpr auto data() const requires contiguous_range&lt;const R&gt;
    { return ranges::data(r_); }
  };
}</pre></div> <h4 id="Class_template_std::ranges::filter_view"> Class template <code><a href="../ranges/filter_view" title="cpp/ranges/filter view">std::ranges::filter_view</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, indirect_unary_predicate&lt;iterator_t&lt;V&gt;&gt; Pred&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class filter_view : public view_interface&lt;filter_view&lt;V, Pred&gt;&gt; {
  private:
    V base_ = V();                              // exposition only
    /*copyable-box*/&lt;Pred&gt; pred_;               // exposition only
 
    // class filter_view::iterator
    class iterator;                             // exposition only
 
    // class filter_view::sentinel
    class sentinel;                             // exposition only
 
  public:
    filter_view() requires default_initializable&lt;V&gt; &amp;&amp;
      default_initializable&lt;Pred&gt; = default;
    constexpr filter_view(V base, Pred pred);
 
    constexpr V base() const&amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr const Pred&amp; pred() const;
 
    constexpr iterator begin();
    constexpr auto end() {
      if constexpr (common_range&lt;V&gt;)
        return iterator{*this, ranges::end(base_)};
      else
        return sentinel{*this};
    }
  };
 
  template&lt;class R, class Pred&gt;
    filter_view(R&amp;&amp;, Pred) -&gt; filter_view&lt;views::all_t&lt;R&gt;, Pred&gt;;
}</pre></div> <h4 id="Class_std::ranges::filter_view::iterator"> Class <code>std::ranges::filter_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, indirect_unary_predicate&lt;iterator_t&lt;V&gt;&gt; Pred&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class filter_view&lt;V, Pred&gt;::iterator {
  private:
    iterator_t&lt;V&gt; current_ = iterator_t&lt;V&gt;();   // exposition only
    filter_view* parent_ = nullptr;             // exposition only
 
  public:
    using iterator_concept  = /* see description */;
    using iterator_category = /* see description */;        // not always present
    using value_type        = range_value_t&lt;V&gt;;
    using difference_type   = range_difference_t&lt;V&gt;;
 
    iterator() requires default_initializable&lt;iterator_t&lt;V&gt;&gt; = default;
    constexpr iterator(filter_view&amp; parent, iterator_t&lt;V&gt; current);
 
    constexpr const iterator_t&lt;V&gt;&amp; base() const &amp; noexcept;
    constexpr iterator_t&lt;V&gt; base() &amp;&amp;;
    constexpr range_reference_t&lt;V&gt; operator*() const;
    constexpr iterator_t&lt;V&gt; operator-&gt;() const
      requires /*has-arrow*/&lt;iterator_t&lt;V&gt;&gt; &amp;&amp; copyable&lt;iterator_t&lt;V&gt;&gt;;
 
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires forward_range&lt;V&gt;;
 
    constexpr iterator&amp; operator--() requires bidirectional_range&lt;V&gt;;
    constexpr iterator operator--(int) requires bidirectional_range&lt;V&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
      requires equality_comparable&lt;iterator_t&lt;V&gt;&gt;;
 
    friend constexpr range_rvalue_reference_t&lt;V&gt; iter_move(const iterator&amp; i)
      noexcept(noexcept(ranges::iter_move(i.current_)));
 
    friend constexpr void iter_swap(const iterator&amp; x, const iterator&amp; y)
      noexcept(noexcept(ranges::iter_swap(x.current_, y.current_)))
      requires indirectly_swappable&lt;iterator_t&lt;V&gt;&gt;;
  };
}</pre></div> <h4 id="Class_std::ranges::filter_view::sentinel"> Class <code>std::ranges::filter_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, indirect_unary_predicate&lt;iterator_t&lt;V&gt;&gt; Pred&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class filter_view&lt;V, Pred&gt;::sentinel {
  private:
    sentinel_t&lt;V&gt; end_ = sentinel_t&lt;V&gt;();       // exposition only
 
  public:
    sentinel() = default;
    constexpr explicit sentinel(filter_view&amp; parent);
 
    constexpr sentinel_t&lt;V&gt; base() const;
 
    friend constexpr bool operator==(const iterator&amp; x, const sentinel&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::transform_view"> Class template <code><a href="../ranges/transform_view" title="cpp/ranges/transform view">std::ranges::transform_view</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, copy_constructible F&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, range_reference_t&lt;V&gt;&gt; &amp;&amp;
             /*can-reference*/&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;V&gt;&gt;&gt;
  class transform_view : public view_interface&lt;transform_view&lt;V, F&gt;&gt; {
  private:
    // class template transform_view::iterator
    template&lt;bool&gt; struct iterator;             // exposition only
 
    // class template transform_view::sentinel
    template&lt;bool&gt; struct sentinel;             // exposition only
 
    V base_ = V();                              // exposition only
    /*copyable-box*/&lt;F&gt; fun_;                   // exposition only
 
  public:
    transform_view() requires default_initializable&lt;V&gt; &amp;&amp;
      default_initializable&lt;F&gt; = default;
    constexpr transform_view(V base, F fun);
 
    constexpr V base() const&amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr iterator&lt;false&gt; begin();
    constexpr iterator&lt;true&gt; begin() const
      requires range&lt;const V&gt; &amp;&amp;
               regular_invocable&lt;const F&amp;, range_reference_t&lt;const V&gt;&gt;;
 
    constexpr sentinel&lt;false&gt; end();
    constexpr iterator&lt;false&gt; end() requires common_range&lt;V&gt;;
    constexpr sentinel&lt;true&gt; end() const
      requires range&lt;const V&gt; &amp;&amp;
               regular_invocable&lt;const F&amp;, range_reference_t&lt;const V&gt;&gt;;
    constexpr iterator&lt;true&gt; end() const
      requires common_range&lt;const V&gt; &amp;&amp;
               regular_invocable&lt;const F&amp;, range_reference_t&lt;const V&gt;&gt;;
 
    constexpr auto size() requires sized_range&lt;V&gt; { return ranges::size(base_); }
    constexpr auto size() const requires sized_range&lt;const V&gt;
    { return ranges::size(base_); }
  };
 
  template&lt;class R, class F&gt;
    transform_view(R&amp;&amp;, F) -&gt; transform_view&lt;views::all_t&lt;R&gt;, F&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::transform_view::iterator"> Class template <code>std::ranges::transform_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, copy_constructible F&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, range_reference_t&lt;V&gt;&gt; &amp;&amp;
             /*can-reference*/&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;V&gt;&gt;&gt;
  template&lt;bool Const&gt;
  class transform_view&lt;V, F&gt;::iterator {
  private:
    using Parent = /*maybe-const*/&lt;Const, transform_view&gt;;      // exposition only
    using Base = /*maybe-const*/&lt;Const, V&gt;;                     // exposition only
    iterator_t&lt;Base&gt; current_ = iterator_t&lt;Base&gt;();             // exposition only
    Parent* parent_ = nullptr;                                  // exposition only
 
  public:
    using iterator_concept  = /* see description */;
    using iterator_category = /* see description */;            // not always present
    using value_type        =
      remove_cvref_t&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;Base&gt;&gt;&gt;;
    using difference_type   = range_difference_t&lt;Base&gt;;
 
    iterator() requires default_initializable&lt;iterator_t&lt;Base&gt;&gt; = default;
    constexpr iterator(Parent&amp; parent, iterator_t&lt;Base&gt; current);
    constexpr iterator(iterator&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;iterator_t&lt;V&gt;, iterator_t&lt;Base&gt;&gt;;
 
    constexpr const iterator_t&lt;Base&gt;&amp; base() const &amp; noexcept;
    constexpr iterator_t&lt;Base&gt; base() &amp;&amp;;
 
    constexpr decltype(auto) operator*() const {
      return invoke(*parent_-&gt;fun_, *current_);
    }
 
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires forward_range&lt;Base&gt;;
 
    constexpr iterator&amp; operator--() requires bidirectional_range&lt;Base&gt;;
    constexpr iterator operator--(int) requires bidirectional_range&lt;Base&gt;;
 
    constexpr iterator&amp; operator+=(difference_type n)
      requires random_access_range&lt;Base&gt;;
    constexpr iterator&amp; operator-=(difference_type n)
      requires random_access_range&lt;Base&gt;;
 
    constexpr decltype(auto) operator[](difference_type n) const
      requires random_access_range&lt;Base&gt; {
      return invoke(*parent_-&gt;fun_, current_[n]);
    }
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
      requires equality_comparable&lt;iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr bool operator&lt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&lt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr auto operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt; &amp;&amp; three_way_comparable&lt;iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr iterator operator+(iterator i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator+(difference_type n, iterator i)
      requires random_access_range&lt;Base&gt;;
 
    friend constexpr iterator operator-(iterator i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires sized_sentinel_for&lt;iterator_t&lt;Base&gt;, iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr decltype(auto) iter_move(const iterator&amp; i)
      noexcept(noexcept(invoke(*i.parent_-&gt;fun_, *i.current_))) {
      if constexpr (is_lvalue_reference_v&lt;decltype(*i)&gt;)
        return std::move(*i);
      else
        return *i;
    }
  };
}</pre></div> <h4 id="Class_template_std::ranges::transform_view::sentinel"> Class template <code>std::ranges::transform_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, copy_constructible F&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, range_reference_t&lt;V&gt;&gt; &amp;&amp;
             /*can-reference*/&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;V&gt;&gt;&gt;
  template&lt;bool Const&gt;
  class transform_view&lt;V, F&gt;::sentinel {
  private:
    using Parent = /*maybe-const*/&lt;Const, transform_view&gt;;  // exposition only
    using Base = /*maybe-const*/&lt;Const, V&gt;;                 // exposition only
    sentinel_t&lt;Base&gt; end_ = sentinel_t&lt;Base&gt;();             // exposition only
  public:
    sentinel() = default;
    constexpr explicit sentinel(sentinel_t&lt;Base&gt; end);
    constexpr sentinel(sentinel&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;Base&gt;&gt;;
 
    constexpr sentinel_t&lt;Base&gt; base() const;
 
    template&lt;bool OtherConst&gt;
      requires sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;/*maybe-const*/&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr bool operator==(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;sentinel_t&lt;Base&gt;,
        iterator_t&lt;/*maybe-const*/&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr range_difference_t&lt;/*maybe-const*/&lt;OtherConst, V&gt;&gt;
      operator-(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;sentinel_t&lt;Base&gt;,
        iterator_t&lt;/*maybe-const*/&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr range_difference_t&lt;/*maybe-const*/&lt;OtherConst, V&gt;&gt;
      operator-(const sentinel&amp; y, const iterator&lt;OtherConst&gt;&amp; x);
  };
}</pre></div> <h4 id="Class_template_std::ranges::take_view"> Class template <code><a href="../ranges/take_view" title="cpp/ranges/take view">std::ranges::take_view</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
  class take_view : public view_interface&lt;take_view&lt;V&gt;&gt; {
  private:
    V base_ = V();                                      // exposition only
    range_difference_t&lt;V&gt; count_ = 0;                   // exposition only
 
    // class template take_view::sentinel
    template&lt;bool&gt; struct sentinel;                     // exposition only
 
  public:
    take_view() requires default_initializable&lt;V&gt; = default;
    constexpr take_view(V base, range_difference_t&lt;V&gt; count);
 
    constexpr V base() const&amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr auto begin() requires (!/*simple-view*/&lt;V&gt;) {
      if constexpr (sized_range&lt;V&gt;) {
        if constexpr (random_access_range&lt;V&gt;) {
          return ranges::begin(base_);
        } else {
          auto sz = range_difference_t&lt;V&gt;(size());
          return counted_iterator(ranges::begin(base_), sz);
        }
      } else {
        return counted_iterator(ranges::begin(base_), count_);
      }
    }
 
    constexpr auto begin() const requires range&lt;const V&gt; {
      if constexpr (sized_range&lt;const V&gt;) {
        if constexpr (random_access_range&lt;const V&gt;) {
          return ranges::begin(base_);
        } else {
          auto sz = range_difference_t&lt;const V&gt;(size());
          return counted_iterator(ranges::begin(base_), sz);
        }
      } else {
        return counted_iterator(ranges::begin(base_), count_);
      }
    }
 
    constexpr auto end() requires (!/*simple-view*/&lt;V&gt;) {
      if constexpr (sized_range&lt;V&gt;) {
        if constexpr (random_access_range&lt;V&gt;)
          return ranges::begin(base_) + range_difference_t&lt;V&gt;(size());
        else
          return default_sentinel;
      } else {
        return sentinel&lt;false&gt;{ranges::end(base_)};
      }
    }
 
    constexpr auto end() const requires range&lt;const V&gt; {
      if constexpr (sized_range&lt;const V&gt;) {
        if constexpr (random_access_range&lt;const V&gt;)
          return ranges::begin(base_) + range_difference_t&lt;const V&gt;(size());
        else
          return default_sentinel;
      } else {
        return sentinel&lt;true&gt;{ranges::end(base_)};
      }
    }
 
    constexpr auto size() requires sized_range&lt;V&gt; {
      auto n = ranges::size(base_);
      return ranges::min(n, static_cast&lt;decltype(n)&gt;(count_));
    }
 
    constexpr auto size() const requires sized_range&lt;const V&gt; {
      auto n = ranges::size(base_);
      return ranges::min(n, static_cast&lt;decltype(n)&gt;(count_));
    }
  };
 
  template&lt;class R&gt;
    take_view(R&amp;&amp;, range_difference_t&lt;R&gt;)
      -&gt; take_view&lt;views::all_t&lt;R&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::take_view::sentinel"> Class template <code>std::ranges::take_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
  template&lt;bool Const&gt;
  class take_view&lt;V&gt;::sentinel {
  private:
    using Base = /*maybe-const*/&lt;Const, V&gt;;                            // exposition only
    template&lt;bool OtherConst&gt;
      using CI =
        counted_iterator&lt;iterator_t&lt;/*maybe-const*/&lt;OtherConst, V&gt;&gt;&gt;;  // exposition only
    sentinel_t&lt;Base&gt; end_ = sentinel_t&lt;Base&gt;();                        // exposition only
  public:
    sentinel() = default;
    constexpr explicit sentinel(sentinel_t&lt;Base&gt; end);
    constexpr sentinel(sentinel&lt;!Const&gt; s)
      requires Const &amp;&amp; convertible_to&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;Base&gt;&gt;;
 
    constexpr sentinel_t&lt;Base&gt; base() const;
 
    friend constexpr bool operator==(const CI&lt;Const&gt;&amp; y, const sentinel&amp; x);
 
    template&lt;bool OtherConst = !Const&gt;
      requires sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;/*maybe-const*/&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr bool operator==(const CI&lt;OtherConst&gt;&amp; y, const sentinel&amp; x);
  };
}</pre></div> <h4 id="Class_template_std::ranges::take_while_view"> Class template <code><a href="../ranges/take_while_view" title="cpp/ranges/take while view">std::ranges::take_while_view</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V, class Pred&gt;
    requires input_range&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt; &amp;&amp;
             indirect_unary_predicate&lt;const Pred, iterator_t&lt;V&gt;&gt;
  class take_while_view : public view_interface&lt;take_while_view&lt;V, Pred&gt;&gt; {
    // class template take_while_view::sentinel
    template&lt;bool&gt; class sentinel;                      // exposition only
 
    V base_ = V();                                      // exposition only
    /*copyable-box*/&lt;Pred&gt; pred_;                       // exposition only
 
  public:
    take_while_view() requires default_initializable&lt;V&gt; &amp;&amp;
      default_initializable&lt;Pred&gt; = default;
    constexpr take_while_view(V base, Pred pred);
 
    constexpr V base() const&amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr const Pred&amp; pred() const;
 
    constexpr auto begin() requires (!/*simple-view*/&lt;V&gt;)
    { return ranges::begin(base_); }
 
    constexpr auto begin() const
      requires range&lt;const V&gt; &amp;&amp;
               indirect_unary_predicate&lt;const Pred, iterator_t&lt;const V&gt;&gt;
    { return ranges::begin(base_); }
 
    constexpr auto end() requires (!/*simple-view*/&lt;V&gt;)
    { return sentinel&lt;false&gt;(ranges::end(base_), addressof(*pred_)); }
 
    constexpr auto end() const
      requires range&lt;const V&gt; &amp;&amp;
               indirect_unary_predicate&lt;const Pred, iterator_t&lt;const V&gt;&gt;
    { return sentinel&lt;true&gt;(ranges::end(base_), addressof(*pred_)); }
  };
 
  template&lt;class R, class Pred&gt;
    take_while_view(R&amp;&amp;, Pred) -&gt; take_while_view&lt;views::all_t&lt;R&gt;, Pred&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::take_while_view::sentinel"> Class template <code>std::ranges::take_while_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V, class Pred&gt;
    requires input_range&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt; &amp;&amp;
             indirect_unary_predicate&lt;const Pred, iterator_t&lt;V&gt;&gt;
  template&lt;bool Const&gt;
  class take_while_view&lt;V, Pred&gt;::sentinel {
    using Base = /*maybe-const*/&lt;Const, V&gt;;             // exposition only
 
    sentinel_t&lt;Base&gt; end_ = sentinel_t&lt;Base&gt;();         // exposition only
    const Pred* pred_ = nullptr;                        // exposition only
 
  public:
    sentinel() = default;
    constexpr explicit sentinel(sentinel_t&lt;Base&gt; end, const Pred* pred);
    constexpr sentinel(sentinel&lt;!Const&gt; s)
      requires Const &amp;&amp; convertible_to&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;Base&gt;&gt;;
 
    constexpr sentinel_t&lt;Base&gt; base() const { return end_; }
 
    friend constexpr bool operator==(const iterator_t&lt;Base&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst = !Const&gt;
      requires sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;/*maybe-const*/&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr bool operator==(const iterator_t&lt;/*maybe-const*/&lt;OtherConst, V&gt;&gt;&amp; x,
                                     const sentinel&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::drop_view"> Class template <code><a href="../ranges/drop_view" title="cpp/ranges/drop view">std::ranges::drop_view</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
  class drop_view : public view_interface&lt;drop_view&lt;V&gt;&gt; {
  public:
    drop_view() requires default_initializable&lt;V&gt; = default;
    constexpr drop_view(V base, range_difference_t&lt;V&gt; count);
 
    constexpr V base() const&amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr auto begin()
      requires (!(/*simple-view*/&lt;V&gt; &amp;&amp;
                  random_access_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;));
    constexpr auto begin() const
      requires random_access_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;;
 
    constexpr auto end() requires (!/*simple-view*/&lt;V&gt;)
    { return ranges::end(base_); }
 
    constexpr auto end() const requires range&lt;const V&gt;
    { return ranges::end(base_); }
 
    constexpr auto size() requires sized_range&lt;V&gt; {
      const auto s = ranges::size(base_);
      const auto c = static_cast&lt;decltype(s)&gt;(count_);
      return s &lt; c ? 0 : s - c;
    }
 
    constexpr auto size() const requires sized_range&lt;const V&gt; {
      const auto s = ranges::size(base_);
      const auto c = static_cast&lt;decltype(s)&gt;(count_);
      return s &lt; c ? 0 : s - c;
    }
 
  private:
    V base_ = V();                              // exposition only
    range_difference_t&lt;V&gt; count_ = 0;           // exposition only
  };
 
  template&lt;class R&gt;
    drop_view(R&amp;&amp;, range_difference_t&lt;R&gt;) -&gt; drop_view&lt;views::all_t&lt;R&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::drop_while_view"> Class template <code><a href="../ranges/drop_while_view" title="cpp/ranges/drop while view">std::ranges::drop_while_view</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V, class Pred&gt;
    requires input_range&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt; &amp;&amp;
             indirect_unary_predicate&lt;const Pred, iterator_t&lt;V&gt;&gt;
  class drop_while_view : public view_interface&lt;drop_while_view&lt;V, Pred&gt;&gt; {
  public:
    drop_while_view() requires default_initializable&lt;V&gt; &amp;&amp;
      default_initializable&lt;Pred&gt; = default;
    constexpr drop_while_view(V base, Pred pred);
 
    constexpr V base() const&amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr const Pred&amp; pred() const;
 
    constexpr auto begin();
 
    constexpr auto end() { return ranges::end(base_); }
 
  private:
    V base_ = V();                                      // exposition only
    /*copyable-box*/&lt;Pred&gt; pred_;                       // exposition only
  };
 
  template&lt;class R, class Pred&gt;
    drop_while_view(R&amp;&amp;, Pred) -&gt; drop_while_view&lt;views::all_t&lt;R&gt;, Pred&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::join_view"> Class template <code>std::ranges::join_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
  class join_view : public view_interface&lt;join_view&lt;V&gt;&gt; {
  private:
    using InnerRng = range_reference_t&lt;V&gt;;                  // exposition only
 
    // class template join_view::iterator
    template&lt;bool Const&gt;
      struct iterator;                                      // exposition only
 
    // class template join_view::sentinel
    template&lt;bool Const&gt;
      struct sentinel;                                      // exposition only
 
    V base_ = V();                                          // exposition only
 
    /*non-propagating-cache*/&lt;remove_cv_t&lt;InnerRng&gt;&gt;inner_;
      // exposition only, present only when !is_reference_v&lt;InnerRng&gt;
 
  public:
    join_view() requires default_initializable&lt;V&gt; = default;
    constexpr explicit join_view(V base);
 
    constexpr V base() const&amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr auto begin() {
      constexpr bool use_const = /*simple-view*/&lt;V&gt; &amp;&amp;
                                 is_reference_v&lt;range_reference_t&lt;V&gt;&gt;;
      return iterator&lt;use_const&gt;{*this, ranges::begin(base_)};
    }
 
    constexpr auto begin() const
      requires input_range&lt;const V&gt; &amp;&amp;
               is_reference_v&lt;range_reference_t&lt;const V&gt;&gt;
    { return iterator&lt;true&gt;{*this, ranges::begin(base_)}; }
 
    constexpr auto end() {
      if constexpr (forward_range&lt;V&gt; &amp;&amp;
                    is_reference_v&lt;InnerRng&gt; &amp;&amp; forward_range&lt;InnerRng&gt; &amp;&amp;
                    common_range&lt;V&gt; &amp;&amp; common_range&lt;InnerRng&gt;)
        return iterator&lt;/*simple-view*/&lt;V&gt;&gt;{*this, ranges::end(base_)};
      else
        return sentinel&lt;/*simple-view*/&lt;V&gt;&gt;{*this};
    }
 
    constexpr auto end() const
      requires input_range&lt;const V&gt; &amp;&amp;
               is_reference_v&lt;range_reference_t&lt;const V&gt;&gt; {
      if constexpr (forward_range&lt;const V&gt; &amp;&amp;
                    forward_range&lt;range_reference_t&lt;const V&gt;&gt; &amp;&amp;
                    common_range&lt;const V&gt; &amp;&amp;
                    common_range&lt;range_reference_t&lt;const V&gt;&gt;)
        return iterator&lt;true&gt;{*this, ranges::end(base_)};
      else
        return sentinel&lt;true&gt;{*this};
    }
  };
 
  template&lt;class R&gt;
    explicit join_view(R&amp;&amp;) -&gt; join_view&lt;views::all_t&lt;R&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::join_view::iterator"> Class template <code>std::ranges::join_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
  template&lt;bool Const&gt;
  struct join_view&lt;V&gt;::iterator {
  private:
    using Parent    = /*maybe-const*/&lt;Const, join_view&gt;;        // exposition only
    using Base      = /*maybe-const*/&lt;Const, V&gt;;                // exposition only
    using OuterIter = iterator_t&lt;Base&gt;;                         // exposition only
    using InnerIter = iterator_t&lt;range_reference_t&lt;Base&gt;&gt;;      // exposition only
 
    static constexpr bool /*ref-is-glvalue*/ =                  // exposition only
      is_reference_v&lt;range_reference_t&lt;Base&gt;&gt;;
 
    OuterIter outer_ = OuterIter();                             // exposition only
    InnerIter inner_ = InnerIter();                             // exposition only
    Parent* parent_  = nullptr;                                 // exposition only
 
    constexpr void satisfy();                                   // exposition only
 
  public:
    using iterator_concept  = /* see description */;
    using iterator_category = /* see description */;            // not always present
    using value_type        = range_value_t&lt;range_reference_t&lt;Base&gt;&gt;;
    using difference_type   = /* see description */;
 
    iterator() requires default_initializable&lt;OuterIter&gt; &amp;&amp;
                         default_initializable&lt;InnerIter&gt; = default;
    constexpr iterator(Parent&amp; parent, OuterIter outer);
    constexpr iterator(iterator&lt;!Const&gt; i)
      requires Const &amp;&amp;
               convertible_to&lt;iterator_t&lt;V&gt;, OuterIter&gt; &amp;&amp;
               convertible_to&lt;iterator_t&lt;InnerRng&gt;, InnerIter&gt;;
 
    constexpr decltype(auto) operator*() const { return *inner_; }
 
    constexpr InnerIter operator-&gt;() const
      requires /*has-arrow*/&lt;InnerIter&gt; &amp;&amp; copyable&lt;InnerIter&gt;;
 
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int)
      requires /*ref-is-glvalue*/ &amp;&amp; forward_range&lt;Base&gt; &amp;&amp;
               forward_range&lt;range_reference_t&lt;Base&gt;&gt;;
 
    constexpr iterator&amp; operator--()
      requires /*ref-is-glvalue*/ &amp;&amp; bidirectional_range&lt;Base&gt; &amp;&amp;
               bidirectional_range&lt;range_reference_t&lt;Base&gt;&gt; &amp;&amp;
               common_range&lt;range_reference_t&lt;Base&gt;&gt;;
 
    constexpr iterator operator--(int)
      requires /*ref-is-glvalue*/ &amp;&amp; bidirectional_range&lt;Base&gt; &amp;&amp;
               bidirectional_range&lt;range_reference_t&lt;Base&gt;&gt; &amp;&amp;
               common_range&lt;range_reference_t&lt;Base&gt;&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
      requires /*ref-is-glvalue*/ &amp;&amp; equality_comparable&lt;iterator_t&lt;Base&gt;&gt; &amp;&amp;
               equality_comparable&lt;iterator_t&lt;range_reference_t&lt;Base&gt;&gt;&gt;;
 
    friend constexpr decltype(auto) iter_move(const iterator&amp; i)
    noexcept(noexcept(ranges::iter_move(i.inner_))) {
      return ranges::iter_move(i.inner_);
    }
 
    friend constexpr void iter_swap(const iterator&amp; x, const iterator&amp; y)
      noexcept(noexcept(ranges::iter_swap(x.inner_, y.inner_)))
      requires indirectly_swappable&lt;InnerIter&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::join_view::sentinel"> Class template <code>std::ranges::join_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
  template&lt;bool Const&gt;
  struct join_view&lt;V&gt;::sentinel {
  private:
    using Parent = /*maybe-const*/&lt;Const, join_view&gt;;       // exposition only
    using Base = /*maybe-const*/&lt;Const, V&gt;;                 // exposition only
    sentinel_t&lt;Base&gt; end_ = sentinel_t&lt;Base&gt;();             // exposition only
 
  public:
    sentinel() = default;
 
    constexpr explicit sentinel(Parent&amp; parent);
    constexpr sentinel(sentinel&lt;!Const&gt; s)
      requires Const &amp;&amp; convertible_to&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;Base&gt;&gt;;
 
    template&lt;bool OtherConst&gt;
      requires sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;/*maybe-const*/&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr bool operator==(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::join_with_view"> Class template <code>std::ranges::join_with_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class R, class P&gt;
  concept /*compatible-joinable-ranges*/ =            // exposition only
      common_with&lt;range_value_t&lt;R&gt;, range_value_t&lt;P&gt;&gt; &amp;&amp;
      common_reference_with&lt;range_reference_t&lt;R&gt;, range_reference_t&lt;P&gt;&gt; &amp;&amp;
      common_reference_with&lt;range_rvalue_reference_t&lt;R&gt;, range_rvalue_reference_t&lt;P&gt;&gt;;
 
  template&lt;class R&gt;
  concept /*bidirectional-common*/ =                  // exposition only
        bidirectional_range&lt;R&gt; &amp;&amp; common_range&lt;R&gt;;
 
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
          &amp;&amp; view&lt;Pattern&gt;
          &amp;&amp; /*compatible-joinable-ranges*/&lt;range_reference_t&lt;V&gt;, Pattern&gt;
  class join_with_view : public view_interface&lt;join_with_view&lt;V, Pattern&gt;&gt; {
    using InnerRng = range_reference_t&lt;V&gt;;             // exposition only
 
    V base_ = V();                                          // exposition only
        // exposition only, present only when !is_reference_v&lt;inner-rng&gt;
    /*non-propagating-cache*/&lt;remove_cv_t&lt;InnerRng&gt;&gt; inner_;
    Pattern pattern_ = Pattern();                           // exposition only
 
    // class template join_with_view::iterator
    template&lt;bool Const&gt; struct iterator;                   // exposition only
 
    // class template join_with_view::sentinel
    template&lt;bool Const&gt; struct sentinel;                   // exposition only
 
  public:
    join_with_view()
      requires default_initializable&lt;V&gt; &amp;&amp; default_initializable&lt;Pattern&gt; = default;
 
    constexpr join_with_view(V base, Pattern pattern);
 
    template&lt;input_range R&gt;
      requires constructible_from&lt;V, views::all_t&lt;R&gt;&gt; &amp;&amp;
               constructible_from&lt;Pattern, single_view&lt;range_value_t&lt;InnerRng&gt;&gt;&gt;
    constexpr join_with_view(R&amp;&amp; r, range_value_t&lt;InnerRng&gt; e);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr auto begin() {
      constexpr bool use_const =
          /*simple-view*/&lt;V&gt;
       &amp;&amp; is_reference_v&lt;InnerRng&gt;
       &amp;&amp; /*simple-view*/&lt;Pattern&gt;;
      return iterator&lt;use_const&gt;{*this, ranges::begin(base_)};
    }
    constexpr auto begin() const
      requires input_range&lt;const V&gt; &amp;&amp;
               forward_range&lt;const Pattern&gt; &amp;&amp;
               is_reference_v&lt;range_reference_t&lt;const V&gt;&gt; {
      return iterator&lt;true&gt;{*this, ranges::begin(base_)};
    }
 
    constexpr auto end() {
      if constexpr (forward_range&lt;V&gt; &amp;&amp;
                    is_reference_v&lt;InnerRng&gt; &amp;&amp; forward_range&lt;InnerRng&gt; &amp;&amp;
                    common_range&lt;V&gt; &amp;&amp; common_range&lt;InnerRng&gt;)
        return iterator&lt;/*simple-view*/&lt;V&gt; &amp;&amp; /*simple-view*/&lt;Pattern&gt;&gt;{
          *this, ranges::end(base_)
        };
      else
        return sentinel&lt;/*simple-view*/&lt;V&gt; &amp;&amp; /*simple-view*/&lt;Pattern&gt;&gt;{*this};
    }
    constexpr auto end() const
      requires input_range&lt;const V&gt; &amp;&amp; forward_range&lt;const Pattern&gt; &amp;&amp;
               is_reference_v&lt;range_reference_t&lt;const V&gt;&gt; {
      using InnerConstRng = range_reference_t&lt;const V&gt;;
      if constexpr (forward_range&lt;const V&gt; &amp;&amp; forward_range&lt;InnerConstRng&gt; &amp;&amp;
                    common_range&lt;const V&gt; &amp;&amp; common_range&lt;InnerConstRng&gt;)
        return iterator&lt;true&gt;{*this, ranges::end(base_)};
      else
        return sentinel&lt;true&gt;{*this};
    }
  };
 
  template&lt;class R, class P&gt;
    join_with_view(R&amp;&amp;, P&amp;&amp;) -&gt; join_with_view&lt;views::all_t&lt;R&gt;, views::all_t&lt;P&gt;&gt;;
 
  template&lt;input_range R&gt;
    join_with_view(R&amp;&amp;, range_value_t&lt;range_reference_t&lt;R&gt;&gt;)
      -&gt; join_with_view&lt;views::all_t&lt;R&gt;, single_view&lt;range_value_t&lt;range_reference_t&lt;R&gt;&gt;&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::join_with_view::iterator"> Class template <code>std::ranges::join_with_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
          &amp;&amp; view&lt;Pattern&gt; &amp;&amp; /*compatible-joinable-ranges*/&lt;range_reference_t&lt;V&gt;, Pattern&gt;
  template&lt;bool Const&gt;
  class join_with_view&lt;V, Pattern&gt;::iterator {
    using Parent = /*maybe-const*/&lt;Const, join_with_view&gt;;              // exposition only
    using Base = /*maybe-const*/&lt;Const, V&gt;;                             // exposition only
    using InnerBase = range_reference_t&lt;Base&gt;;                          // exposition only
    using PatternBase = /*maybe-const*/&lt;Const, Pattern&gt;;                // exposition only
 
    using OuterIter = iterator_t&lt;Base&gt;;                                 // exposition only
    using InnerIter = iterator_t&lt;InnerBase&gt;;                            // exposition only
    using PatternIter = iterator_t&lt;PatternBase&gt;;                        // exposition only
 
    static constexpr bool /*ref-is-glvalue*/ = is_reference_v&lt;InnerBase&gt;; // exposition only
 
    Parent* parent_ = nullptr;                                          // exposition only
    OuterIter outer_it_ = OuterIter();                                  // exposition only
    variant&lt;PatternIter, InnerIter&gt; inner_it_;                          // exposition only
 
    constexpr iterator(Parent&amp; parent, iterator_t&lt;Base&gt; outer);         // exposition only
    constexpr auto&amp;&amp; /*update-inner*/(const OuterIter&amp;);                // exposition only
    constexpr auto&amp;&amp; /*get-inner*/(const OuterIter&amp;);                   // exposition only
    constexpr void /*satisfy*/();                                       // exposition only
 
  public:
    using iterator_concept = /* see description */;
    using iterator_category = /* see description */;                // not always present
    using value_type = /* see description */;
    using difference_type = /* see description */;
 
    iterator() requires default_initializable&lt;OuterIter&gt; = default;
    constexpr iterator(iterator&lt;!Const&gt; i)
        requires Const &amp;&amp; convertible_to&lt;iterator_t&lt;V&gt;, OuterIter&gt; &amp;&amp;
                 convertible_to&lt;iterator_t&lt;InnerRng&gt;, InnerIter&gt; &amp;&amp;
                 convertible_to&lt;iterator_t&lt;Pattern&gt;, PatternIter&gt;;
 
    constexpr decltype(auto) operator*() const;
 
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int)
        requires /*ref-is-glvalue*/ &amp;&amp; forward_iterator&lt;OuterIter&gt; &amp;&amp;
                 forward_iterator&lt;InnerIter&gt;;
 
    constexpr iterator&amp; operator--()
        requires /*ref-is-glvalue*/ &amp;&amp; bidirectional_range&lt;Base&gt; &amp;&amp;
                 /*bidirectional-common*/&lt;InnerBase&gt; &amp;&amp;
                 /*bidirectional-common*/&lt;PatternBase&gt;;
    constexpr iterator operator--(int)
        requires /*ref-is-glvalue*/ &amp;&amp; bidirectional_range&lt;Base&gt; &amp;&amp;
                 /*bidirectional-common*/&lt;InnerBase&gt; &amp;&amp;
                 /*bidirectional-common*/&lt;PatternBase&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
        requires /*ref-is-glvalue*/ &amp;&amp; equality_comparable&lt;OuterIter&gt; &amp;&amp;
                 equality_comparable&lt;InnerIter&gt;;
 
    friend constexpr decltype(auto) iter_move(const iterator&amp; x) {
      using rvalue_reference = common_reference_t&lt;
        iter_rvalue_reference_t&lt;InnerIter&gt;,
        iter_rvalue_reference_t&lt;PatternIter&gt;&gt;;
      return visit&lt;rvalue_reference&gt;(ranges::iter_move, x.inner_it_);
    }
 
    friend constexpr void iter_swap(const iterator&amp; x, const iterator&amp; y)
        requires indirectly_swappable&lt;InnerIter, PatternIter&gt; {
      visit(ranges::iter_swap, x.inner_it_, y.inner_it_);
    }
  };
}</pre></div> <h4 id="Class_template_std::ranges::join_with_view::sentinel"> Class template <code>std::ranges::join_with_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; input_range&lt;range_reference_t&lt;V&gt;&gt;
          &amp;&amp; view&lt;Pattern&gt; &amp;&amp; /*compatible-joinable-ranges*/&lt;range_reference_t&lt;V&gt;, Pattern&gt;
  template&lt;bool Const&gt;
  class join_with_view&lt;V, Pattern&gt;::sentinel {
    using Parent = /*maybe-const*/&lt;Const, join_with_view&gt;;  // exposition only
    using Base = /*maybe-const*/&lt;Const, V&gt;;                 // exposition only
    sentinel_t&lt;Base&gt; end_ = sentinel_t&lt;Base&gt;();             // exposition only
 
    constexpr explicit sentinel(Parent&amp; parent);            // exposition only
 
  public:
    sentinel() = default;
    constexpr sentinel(sentinel&lt;!Const&gt; s)
      requires Const &amp;&amp; convertible_to&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;Base&gt;&gt;;
 
    template &lt;bool OtherConst&gt;
      requires sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;/*maybe-const*/&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr bool operator==(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::lazy_split_view"> Class template <code>std::ranges::lazy_split_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;auto&gt; struct /*require-constant*/;                       // exposition only
 
  template&lt;class R&gt;
  concept /*tiny-range*/ =                                          // exposition only
    sized_range&lt;R&gt; &amp;&amp;
    requires { typename /*require-constant*/&lt;remove_reference_t&lt;R&gt;::size()&gt;; } &amp;&amp;
    (remove_reference_t&lt;R&gt;::size() &lt;= 1);
 
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt;
             &amp;&amp; (forward_range&lt;V&gt; || /*tiny-range*/&lt;Pattern&gt;)
  class lazy_split_view : public view_interface&lt;lazy_split_view&lt;V, Pattern&gt;&gt; {
  private:
    V base_ = V();                                      // exposition only
    Pattern pattern_ = Pattern();                       // exposition only
 
    /*non-propagating-cache*/&lt;iterator_t&lt;V&gt;&gt; current_;  // exposition only, present only
                                                        // if !forward_range&lt;V&gt;
 
    // class template lazy_split_view::/*outer-iterator*/
    template&lt;bool&gt; struct /*outer-iterator*/;           // exposition only
 
    // class template lazy_split_view::/*inner-iterator*/
    template&lt;bool&gt; struct /*inner-iterator*/;           // exposition only
 
  public:
    lazy_split_view()
      requires default_initializable&lt;V&gt; &amp;&amp; default_initializable&lt;Pattern&gt; = default;
    constexpr lazy_split_view(V base, Pattern pattern);
 
    template&lt;input_range R&gt;
      requires constructible_from&lt;V, views::all_t&lt;R&gt;&gt; &amp;&amp;
               constructible_from&lt;Pattern, single_view&lt;range_value_t&lt;R&gt;&gt;&gt;
    constexpr lazy_split_view(R&amp;&amp; r, range_value_t&lt;R&gt; e);
 
    constexpr V base() const&amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr auto begin() {
      if constexpr (forward_range&lt;V&gt;) {
        return /*outer-iterator*/&lt;/*simple-view*/&lt;V&gt; &amp;&amp; /*simple-view*/&lt;Pattern&gt;&gt;
          {*this, ranges::begin(base_)};
      } else {
        current_ = ranges::begin(base_);
        return /*outer-iterator*/&lt;false&gt;{*this};
      }
    }
 
    constexpr auto begin() const requires forward_range&lt;V&gt; &amp;&amp; forward_range&lt;const V&gt; {
      return /*outer-iterator*/&lt;true&gt;{*this, ranges::begin(base_)};
    }
 
    constexpr auto end() requires forward_range&lt;V&gt; &amp;&amp; common_range&lt;V&gt; {
      return /*outer-iterator*/&lt;/*simple-view*/&lt;V&gt; &amp;&amp; /*simple-view*/&lt;Pattern&gt;&gt;
        {*this, ranges::end(base_)};
    }
 
    constexpr auto end() const {
      if constexpr (forward_range&lt;V&gt; &amp;&amp; forward_range&lt;const V&gt; &amp;&amp; common_range&lt;const V&gt;)
        return /*outer-iterator*/&lt;true&gt;{*this, ranges::end(base_)};
      else
        return default_sentinel;
    }
  };
 
  template&lt;class R, class P&gt;
    lazy_split_view(R&amp;&amp;, P&amp;&amp;) -&gt; lazy_split_view&lt;views::all_t&lt;R&gt;, views::all_t&lt;P&gt;&gt;;
 
  template&lt;input_range R&gt;
    lazy_split_view(R&amp;&amp;, range_value_t&lt;R&gt;)
      -&gt; lazy_split_view&lt;views::all_t&lt;R&gt;, single_view&lt;range_value_t&lt;R&gt;&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::lazy_split_view::outer_iterator"> Class template <code>std::ranges::lazy_split_view::outer_iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt;
             &amp;&amp; (forward_range&lt;V&gt; || /*tiny-range*/&lt;Pattern&gt;)
  template&lt;bool Const&gt;
  struct lazy_split_view&lt;V, Pattern&gt;::/*outer-iterator*/ {
  private:
    using Parent = /*maybe-const*/&lt;Const, lazy_split_view&gt;; // exposition only
    using Base = /*maybe-const*/&lt;Const, V&gt;;                 // exposition only
    Parent* parent_ = nullptr;                              // exposition only
 
    iterator_t&lt;Base&gt; current_ = iterator_t&lt;Base&gt;();      // exposition only, present only
                                                         // if V models forward_range
 
    bool trailing_empty_ = false;                        // exposition only
 
  public:
    using iterator_concept  =
      conditional_t&lt;forward_range&lt;Base&gt;, forward_iterator_tag, input_iterator_tag&gt;;
 
    using iterator_category = input_iterator_tag;        // present only if Base
                                                         // models forward_range
 
    // class lazy_split_view::/*outer-iterator*/::value_type
    struct value_type;
    using difference_type   = range_difference_t&lt;Base&gt;;
 
    /*outer-iterator*/() = default;
    constexpr explicit /*outer-iterator*/(Parent&amp; parent)
      requires (!forward_range&lt;Base&gt;);
    constexpr /*outer-iterator*/(Parent&amp; parent, iterator_t&lt;Base&gt; current)
      requires forward_range&lt;Base&gt;;
    constexpr /*outer-iterator*/(/*outer-iterator*/&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;iterator_t&lt;V&gt;, iterator_t&lt;Base&gt;&gt;;
 
    constexpr value_type operator*() const;
 
    constexpr /*outer-iterator*/&amp; operator++();
    constexpr decltype(auto) operator++(int) {
      if constexpr (forward_range&lt;Base&gt;) {
        auto tmp = *this;
        ++*this;
        return tmp;
      } else
        ++*this;
    }
 
    friend constexpr bool operator==(const /*outer-iterator*/&amp; x,
                                     const /*outer-iterator*/&amp; y)
      requires forward_range&lt;Base&gt;;
 
    friend constexpr bool operator==(const /*outer-iterator*/&amp; x, default_sentinel_t);
  };
}</pre></div> <h4 id="Class_std::ranges::lazy_split_view::outer_iterator::value_type"> Class <code>std::ranges::lazy_split_view::outer_iterator::value_type</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt;
             &amp;&amp; (forward_range&lt;V&gt; || /*tiny-range*/&lt;Pattern&gt;)
  template&lt;bool Const&gt;
  struct lazy_split_view&lt;V, Pattern&gt;::/*outer-iterator*/&lt;Const&gt;::value_type
    : view_interface&lt;value_type&gt; {
  private:
    /*outer-iterator*/ i_ = /*outer-iterator*/();               // exposition only
  public:
    value_type() = default;
    constexpr explicit value_type(/*outer-iterator*/ i);
 
    constexpr /*inner-iterator*/&lt;Const&gt; begin() const;
    constexpr default_sentinel_t end() const noexcept;
  };
}</pre></div> <h4 id="Class_template_std::ranges::lazy_split_view::inner_iterator"> Class template <code>std::ranges::lazy_split_view::inner_iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt;
             &amp;&amp; (forward_range&lt;V&gt; || /*tiny-range*/&lt;Pattern&gt;)
  template&lt;bool Const&gt;
  struct lazy_split_view&lt;V, Pattern&gt;::/*inner-iterator*/ {
  private:
    using Base = /*maybe-const*/&lt;Const, V&gt;;                     // exposition only
    /*outer-iterator*/&lt;Const&gt; i_ = /*outer-iterator*/&lt;Const&gt;(); // exposition only
    bool incremented_ = false;                                  // exposition only
 
  public:
    using iterator_concept  = typename /*outer-iterator*/&lt;Const&gt;::iterator_concept;
 
    using iterator_category = /* see description */;        // present only if Base
                                                            // models forward_range
    using value_type        = range_value_t&lt;Base&gt;;
    using difference_type   = range_difference_t&lt;Base&gt;;
 
    /*inner-iterator*/() = default;
    constexpr explicit /*inner-iterator*/(/*outer-iterator*/&lt;Const&gt; i);
 
    constexpr const iterator_t&lt;Base&gt;&amp; base() const &amp; noexcept;
    constexpr iterator_t&lt;Base&gt; base() &amp;&amp; requires forward_range&lt;V&gt;;
 
    constexpr decltype(auto) operator*() const { return *i_.current; }
 
    constexpr /*inner-iterator*/&amp; operator++();
    constexpr decltype(auto) operator++(int) {
      if constexpr (forward_range&lt;Base&gt;) {
        auto tmp = *this;
        ++*this;
        return tmp;
      } else
        ++*this;
    }
 
    friend constexpr bool operator==(const /*inner-iterator*/&amp; x,
                                     const /*inner-iterator*/&amp; y)
      requires forward_range&lt;Base&gt;;
 
    friend constexpr bool operator==(const /*inner-iterator*/&amp; x, default_sentinel_t);
 
    friend constexpr decltype(auto) iter_move(const /*inner-iterator*/&amp; i)
    noexcept(noexcept(ranges::iter_move(i.i_.current))) {
      return ranges::iter_move(i.i_.current);
    }
 
    friend constexpr void iter_swap(const /*inner-iterator*/&amp; x,
                                    const /*inner-iterator*/&amp; y)
      noexcept(noexcept(ranges::iter_swap(x.i_.current, y.i_.current)))
      requires indirectly_swappable&lt;iterator_t&lt;Base&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::split_view"> Class template <code>std::ranges::split_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt;
  class split_view : public view_interface&lt;split_view&lt;V, Pattern&gt;&gt; {
  private:
    V base_ = V();                              // exposition only
    Pattern pattern_ = Pattern();               // exposition only
 
    // class split_view::iterator
    struct iterator;                            // exposition only
 
    // class split_view::sentinel
    struct sentinel;                            // exposition only
 
  public:
    split_view()
      requires default_initializable&lt;V&gt; &amp;&amp; default_initializable&lt;Pattern&gt; = default;
    constexpr split_view(V base, Pattern pattern);
 
    template&lt;forward_range R&gt;
      requires constructible_from&lt;V, views::all_t&lt;R&gt;&gt; &amp;&amp;
               constructible_from&lt;Pattern, single_view&lt;range_value_t&lt;R&gt;&gt;&gt;
    constexpr split_view(R&amp;&amp; r, range_value_t&lt;R&gt; e);
 
    constexpr V base() const&amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr iterator begin();
 
    constexpr auto end() {
      if constexpr (common_range&lt;V&gt;) {
        return iterator{*this, ranges::end(base_), {} };
      } else {
        return sentinel{*this};
      }
    }
 
    constexpr subrange&lt;iterator_t&lt;V&gt;&gt; /*find-next*/(iterator_t&lt;V&gt;); // exposition only
  };
 
  template&lt;class R, class P&gt;
    split_view(R&amp;&amp;, P&amp;&amp;) -&gt; split_view&lt;views::all_t&lt;R&gt;, views::all_t&lt;P&gt;&gt;;
 
  template&lt;forward_range R&gt;
    split_view(R&amp;&amp;, range_value_t&lt;R&gt;)
      -&gt; split_view&lt;views::all_t&lt;R&gt;, single_view&lt;range_value_t&lt;R&gt;&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::split_view::iterator"> Class template <code>std::ranges::split_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt;
  class split_view&lt;V, Pattern&gt;::iterator {
  private:
    split_view* parent_ = nullptr;                              // exposition only
    iterator_t&lt;V&gt; cur_ = iterator_t&lt;V&gt;();                       // exposition only
    subrange&lt;iterator_t&lt;V&gt;&gt; next_ = subrange&lt;iterator_t&lt;V&gt;&gt;();  // exposition only
    bool trailing_empty_ = false;                               // exposition only
 
  public:
    using iterator_concept = forward_iterator_tag;
    using iterator_category = input_iterator_tag;
    using value_type = subrange&lt;iterator_t&lt;V&gt;&gt;;
    using difference_type = range_difference_t&lt;V&gt;;
 
    iterator() = default;
    constexpr iterator(split_view&amp; parent, iterator_t&lt;V&gt; current,
                       subrange&lt;iterator_t&lt;V&gt;&gt; next);
    constexpr iterator_t&lt;V&gt; base() const;
    constexpr value_type operator*() const;
 
    constexpr iterator&amp; operator++();
    constexpr iterator operator++(int);
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::split_view::sentinel"> Class template <code>std::ranges::split_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, forward_range Pattern&gt;
    requires view&lt;V&gt; &amp;&amp; view&lt;Pattern&gt; &amp;&amp;
             indirectly_comparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt;
  struct split_view&lt;V, Pattern&gt;::sentinel {
  private:
    sentinel_t&lt;V&gt; end_ = sentinel_t&lt;V&gt;();               // exposition only
 
  public:
    sentinel() = default;
    constexpr explicit sentinel(split_view&amp; parent);
 
    friend constexpr bool operator==(const iterator&amp; x, const sentinel&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::common_view"> Class template <code>std::ranges::common_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
    requires (!common_range&lt;V&gt; &amp;&amp; copyable&lt;iterator_t&lt;V&gt;&gt;)
  class common_view : public view_interface&lt;common_view&lt;V&gt;&gt; {
  private:
    V base_ = V();  // exposition only
  public:
    common_view() requires default_initializable&lt;V&gt; = default;
 
    constexpr explicit common_view(V r);
 
    constexpr V base() const&amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr auto begin() {
      if constexpr (random_access_range&lt;V&gt; &amp;&amp; sized_range&lt;V&gt;)
        return ranges::begin(base_);
      else
        return common_iterator&lt;iterator_t&lt;V&gt;, sentinel_t&lt;V&gt;&gt;(ranges::begin(base_));
    }
 
    constexpr auto begin() const requires range&lt;const V&gt; {
      if constexpr (random_access_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;)
        return ranges::begin(base_);
      else
        return common_iterator&lt;iterator_t&lt;const V&gt;,
          sentinel_t&lt;const V&gt;&gt;(ranges::begin(base_));
    }
 
    constexpr auto end() {
      if constexpr (random_access_range&lt;V&gt; &amp;&amp; sized_range&lt;V&gt;)
        return ranges::begin(base_) + ranges::size(base_);
      else
        return common_iterator&lt;iterator_t&lt;V&gt;, sentinel_t&lt;V&gt;&gt;(ranges::end(base_));
    }
 
    constexpr auto end() const requires range&lt;const V&gt; {
      if constexpr (random_access_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;)
        return ranges::begin(base_) + ranges::size(base_);
      else
        return common_iterator&lt;iterator_t&lt;const V&gt;,
          sentinel_t&lt;const V&gt;&gt;(ranges::end(base_));
    }
 
    constexpr auto size() requires sized_range&lt;V&gt; {
      return ranges::size(base_);
    }
    constexpr auto size() const requires sized_range&lt;const V&gt; {
      return ranges::size(base_);
    }
  };
 
  template&lt;class R&gt;
    common_view(R&amp;&amp;) -&gt; common_view&lt;views::all_t&lt;R&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::reverse_view"> Class template <code><a href="../ranges/reverse_view" title="cpp/ranges/reverse view">std::ranges::reverse_view</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
    requires bidirectional_range&lt;V&gt;
  class reverse_view : public view_interface&lt;reverse_view&lt;V&gt;&gt; {
  private:
    V base_ = V();  // exposition only
  public:
    reverse_view() requires default_initializable&lt;V&gt; = default;
 
    constexpr explicit reverse_view(V r);
 
    constexpr V base() const&amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr reverse_iterator&lt;iterator_t&lt;V&gt;&gt; begin();
    constexpr reverse_iterator&lt;iterator_t&lt;V&gt;&gt; begin() requires common_range&lt;V&gt;;
    constexpr auto begin() const requires common_range&lt;const V&gt;;
 
    constexpr reverse_iterator&lt;iterator_t&lt;V&gt;&gt; end();
    constexpr auto end() const requires common_range&lt;const V&gt;;
 
    constexpr auto size() requires sized_range&lt;V&gt; {
      return ranges::size(base_);
    }
 
    constexpr auto size() const requires sized_range&lt;const V&gt; {
      return ranges::size(base_);
    }
  };
 
  template&lt;class R&gt;
    reverse_view(R&amp;&amp;) -&gt; reverse_view&lt;views::all_t&lt;R&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::elements_view"> Class template <code>std::ranges::elements_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T, size_t N&gt;
  concept /*has-tuple-element*/ =                   // exposition only
    requires(T t) {
      typename tuple_size&lt;T&gt;::type;
      requires N &lt; tuple_size_v&lt;T&gt;;
      typename tuple_element_t&lt;N, T&gt;;
      { std::get&lt;N&gt;(t) } -&gt; convertible_to&lt;const tuple_element_t&lt;N, T&gt;&amp;&gt;;
    };
 
  template&lt;class T, size_t N&gt;
  concept /*returnable-element*/ =                  // exposition only
    is_reference_v&lt;T&gt; || move_constructible&lt;tuple_element_t&lt;N, T&gt;&gt;;
 
  template&lt;input_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; /*has-tuple-element*/&lt;range_value_t&lt;V&gt;, N&gt; &amp;&amp;
             /*has-tuple-element*/&lt;remove_reference_t&lt;range_reference_t&lt;V&gt;&gt;, N&gt; &amp;&amp;
             /*returnable-element*/&lt;range_reference_t&lt;V&gt;, N&gt;
  class elements_view : public view_interface&lt;elements_view&lt;V, N&gt;&gt; {
  public:
    elements_view() requires default_initializable&lt;V&gt; = default;
    constexpr explicit elements_view(V base);
 
    constexpr V base() const&amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr auto begin() requires (!/*simple-view*/&lt;V&gt;)
    { return iterator&lt;false&gt;(ranges::begin(base_)); }
 
    constexpr auto begin() const requires range&lt;const V&gt;
    { return iterator&lt;true&gt;(ranges::begin(base_)); }
 
    constexpr auto end() requires (!/*simple-view*/&lt;V&gt; &amp;&amp; !common_range&lt;V&gt;)
    { return sentinel&lt;false&gt;{ranges::end(base_)}; }
 
    constexpr auto end() requires (!/*simple-view*/&lt;V&gt; &amp;&amp; common_range&lt;V&gt;)
    { return iterator&lt;false&gt;{ranges::end(base_)}; }
 
    constexpr auto end() const requires range&lt;const V&gt;
    { return sentinel&lt;true&gt;{ranges::end(base_)}; }
 
    constexpr auto end() const requires common_range&lt;const V&gt;
    { return iterator&lt;true&gt;{ranges::end(base_)}; }
 
    constexpr auto size() requires sized_range&lt;V&gt;
    { return ranges::size(base_); }
 
    constexpr auto size() const requires sized_range&lt;const V&gt;
    { return ranges::size(base_); }
 
  private:
    // class template elements_view::iterator
    template&lt;bool&gt; struct iterator;                     // exposition only
 
    // class template elements_view::sentinel
    template&lt;bool&gt; struct sentinel;                     // exposition only
 
    V base_ = V();                                      // exposition only
  };
}</pre></div> <h4 id="Class_template_std::ranges::elements_view::iterator"> Class template <code>std::ranges::elements_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; /*has-tuple-element*/&lt;range_value_t&lt;V&gt;, N&gt; &amp;&amp;
             /*has-tuple-element*/&lt;remove_reference_t&lt;range_reference_t&lt;V&gt;&gt;, N&gt; &amp;&amp;
             /*returnable-element*/&lt;range_reference_t&lt;V&gt;, N&gt;
  template&lt;bool Const&gt;
  class elements_view&lt;V, N&gt;::iterator {
    using Base = /*maybe-const*/&lt;Const, V&gt;;             // exposition only
 
    iterator_t&lt;Base&gt; current_ = iterator_t&lt;Base&gt;();     // exposition only
 
    static constexpr decltype(auto) /*get-element*/(const iterator_t&lt;Base&gt;&amp; i);
      // exposition only
 
  public:
    using iterator_concept = /* see description */;
    using iterator_category = /* see description */;                // not always present
    using value_type = remove_cvref_t&lt;tuple_element_t&lt;N, range_value_t&lt;Base&gt;&gt;&gt;;
    using difference_type = range_difference_t&lt;Base&gt;;
 
    iterator() requires default_initializable&lt;iterator_t&lt;Base&gt;&gt; = default;
    constexpr explicit iterator(iterator_t&lt;Base&gt; current);
    constexpr iterator(iterator&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;iterator_t&lt;V&gt;, iterator_t&lt;Base&gt;&gt;;
 
    constexpr const iterator_t&lt;Base&gt;&amp; base() const &amp; noexcept;
    constexpr iterator_t&lt;Base&gt; base() &amp;&amp;;
 
    constexpr decltype(auto) operator*() const
    { return /*get-element*/(current_); }
 
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires forward_range&lt;Base&gt;;
 
    constexpr iterator&amp; operator--() requires bidirectional_range&lt;Base&gt;;
    constexpr iterator operator--(int) requires bidirectional_range&lt;Base&gt;;
 
    constexpr iterator&amp; operator+=(difference_type x)
      requires random_access_range&lt;Base&gt;;
    constexpr iterator&amp; operator-=(difference_type x)
      requires random_access_range&lt;Base&gt;;
 
    constexpr decltype(auto) operator[](difference_type n) const
      requires random_access_range&lt;Base&gt;
    { return /*get-element*/(current_ + n); }
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
      requires equality_comparable&lt;iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr bool operator&lt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&lt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr auto operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt; &amp;&amp; three_way_comparable&lt;iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr iterator operator+(const iterator&amp; x, difference_type y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator+(difference_type x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator-(const iterator&amp; x, difference_type y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires sized_sentinel_for&lt;iterator_t&lt;Base&gt;, iterator_t&lt;Base&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::elements_view::sentinel"> Class template <code>std::ranges::elements_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; /*has-tuple-element*/&lt;range_value_t&lt;V&gt;, N&gt; &amp;&amp;
             /*has-tuple-element*/&lt;remove_reference_t&lt;range_reference_t&lt;V&gt;&gt;, N&gt; &amp;&amp;
             /*returnable-element*/&lt;range_reference_t&lt;V&gt;, N&gt;
  template&lt;bool Const&gt;
  class elements_view&lt;V, N&gt;::sentinel {
  private:
    using Base = /*maybe-const*/&lt;Const, V&gt;;             // exposition only
    sentinel_t&lt;Base&gt; end_ = sentinel_t&lt;Base&gt;();         // exposition only
  public:
    sentinel() = default;
    constexpr explicit sentinel(sentinel_t&lt;Base&gt; end);
    constexpr sentinel(sentinel&lt;!Const&gt; other)
      requires Const &amp;&amp; convertible_to&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;Base&gt;&gt;;
 
    constexpr sentinel_t&lt;Base&gt; base() const;
 
    template&lt;bool OtherConst&gt;
      requires sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;/*maybe-const*/&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr bool operator==(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;sentinel_t&lt;Base&gt;,
        iterator_t&lt;/*maybe-const*/&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr range_difference_t&lt;/*maybe-const*/&lt;OtherConst, V&gt;&gt;
      operator-(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;sentinel_t&lt;Base&gt;,
        iterator_t&lt;/*maybe-const*/&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr range_difference_t&lt;/*maybe-const*/&lt;OtherConst, V&gt;&gt;
      operator-(const sentinel&amp; x, const iterator&lt;OtherConst&gt;&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::zip_view"> Class template <code>std::ranges::zip_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class... Rs&gt;
  concept /*zip-is-common*/ =                                // exposition only
    (sizeof...(Rs) == 1 &amp;&amp; (common_range&lt;Rs&gt; &amp;&amp; ...)) ||
    (!(bidirectional_range&lt;Rs&gt; &amp;&amp; ...) &amp;&amp; (common_range&lt;Rs&gt; &amp;&amp; ...)) ||
    ((random_access_range&lt;Rs&gt; &amp;&amp; ...) &amp;&amp; (sized_range&lt;Rs&gt; &amp;&amp; ...));
 
  template&lt;class... Ts&gt;
    using /*tuple-or-pair*/ = /* see description */;         // exposition only
 
  template&lt;class F, class Tuple&gt;
  constexpr auto /*tuple-transform*/(F&amp;&amp; f, Tuple&amp;&amp; tuple) { // exposition only
    return apply([&amp;]&lt;class... Ts&gt;(Ts&amp;&amp;... elements) {
      return /*tuple-or-pair*/&lt;invoke_result_t&lt;F&amp;, Ts&gt;...&gt;(
        invoke(f, std::forward&lt;Ts&gt;(elements))...
      );
    }, std::forward&lt;Tuple&gt;(tuple));
  }
 
  template&lt;class F, class Tuple&gt;
  constexpr void /*tuple-for-each*/(F&amp;&amp; f, Tuple&amp;&amp; tuple) { // exposition only
    apply([&amp;]&lt;class... Ts&gt;(Ts&amp;&amp;... elements) {
      (invoke(f, std::forward&lt;Ts&gt;(elements)), ...);
    }, std::forward&lt;Tuple&gt;(tuple));
  }
 
  template&lt;input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0)
  class zip_view : public view_interface&lt;zip_view&lt;Views...&gt;&gt; {
    tuple&lt;Views...&gt; views_;             // exposition only
 
    // class template zip_view::iterator
    template&lt;bool&gt; class iterator;      // exposition only
 
    // class template zip_view::sentinel
    template&lt;bool&gt; class sentinel;      // exposition only
 
  public:
    zip_view() = default;
    constexpr explicit zip_view(Views... views);
 
    constexpr auto begin() requires (!(/*simple-view*/&lt;Views&gt; &amp;&amp; ...)) {
      return iterator&lt;false&gt;(/*tuple-transform*/(ranges::begin, views_));
    }
    constexpr auto begin() const requires (range&lt;const Views&gt; &amp;&amp; ...) {
      return iterator&lt;true&gt;(/*tuple-transform*/(ranges::begin, views_));
    }
 
    constexpr auto end() requires (!(/*simple-view*/&lt;Views&gt; &amp;&amp; ...)) {
      if constexpr (!/*zip-is-common*/&lt;Views...&gt;) {
        return sentinel&lt;false&gt;(/*tuple-transform*/(ranges::end, views_));
      } else if constexpr ((random_access_range&lt;Views&gt; &amp;&amp; ...)) {
        return begin() + iter_difference_t&lt;iterator&lt;false&gt;&gt;(size());
      } else {
        return iterator&lt;false&gt;(/*tuple-transform*/(ranges::end, views_));
      }
    }
 
    constexpr auto end() const requires (range&lt;const Views&gt; &amp;&amp; ...) {
      if constexpr (!/*zip-is-common*/&lt;const Views...&gt;) {
        return sentinel&lt;true&gt;(/*tuple-transform*/(ranges::end, views_));
      } else if constexpr ((random_access_range&lt;const Views&gt; &amp;&amp; ...)) {
        return begin() + iter_difference_t&lt;iterator&lt;true&gt;&gt;(size());
      } else {
        return iterator&lt;true&gt;(/*tuple-transform*/(ranges::end, views_));
      }
    }
 
    constexpr auto size() requires (sized_range&lt;Views&gt; &amp;&amp; ...);
    constexpr auto size() const requires (sized_range&lt;const Views&gt; &amp;&amp; ...);
  };
 
  template&lt;class... Rs&gt;
    zip_view(Rs&amp;&amp;...) -&gt; zip_view&lt;views::all_t&lt;Rs&gt;...&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::zip_view::iterator"> Class template <code>std::ranges::zip_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;bool Const, class... Views&gt;
    concept /*all-random-access*/ =                 // exposition only
      (random_access_range&lt;/*maybe-const*/&lt;Const, Views&gt;&gt; &amp;&amp; ...);
  template&lt;bool Const, class... Views&gt;
    concept /*all-bidirectional*/ =                 // exposition only
      (bidirectional_range&lt;/*maybe-const*/&lt;Const, Views&gt;&gt; &amp;&amp; ...);
  template&lt;bool Const, class... Views&gt;
    concept /*all-forward*/ =                       // exposition only
      (forward_range&lt;/*maybe-const*/&lt;Const, Views&gt;&gt; &amp;&amp; ...);
 
  template&lt;input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0)
  template&lt;bool Const&gt;
  class zip_view&lt;Views...&gt;::iterator {
    /*tuple-or-pair*/&lt;iterator_t&lt;/*maybe-const*/&lt;Const, Views&gt;&gt;...&gt;
      current_;       // exposition only
    constexpr explicit iterator(/*tuple-or-pair*/&lt;iterator_t&lt;
      /*maybe-const*/&lt;Const, Views&gt;&gt;...&gt;);          // exposition only
  public:
    using iterator_category = input_iterator_tag;   // not always present
    using iterator_concept  = /* see description */;
    using value_type = /*tuple-or-pair*/&lt;range_value_t&lt;
      /*maybe-const*/&lt;Const, Views&gt;&gt;...&gt;;
    using difference_type = common_type_t&lt;range_difference_t&lt;
      /*maybe-const*/&lt;Const, Views&gt;&gt;...&gt;;
 
    iterator() = default;
    constexpr iterator(iterator&lt;!Const&gt; i)
      requires Const &amp;&amp; (convertible_to&lt;iterator_t&lt;Views&gt;,
        iterator_t&lt;/*maybe-const*/&lt;Const, Views&gt;&gt;&gt; &amp;&amp; ...);
 
    constexpr auto operator*() const;
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires /*all-forward*/&lt;Const, Views...&gt;;
 
    constexpr iterator&amp; operator--() requires /*all-bidirectional*/&lt;Const, Views...&gt;;
    constexpr iterator operator--(int) requires /*all-bidirectional*/&lt;Const, Views...&gt;;
 
    constexpr iterator&amp; operator+=(difference_type x)
      requires /*all-random-access*/&lt;Const, Views...&gt;;
    constexpr iterator&amp; operator-=(difference_type x)
      requires /*all-random-access*/&lt;Const, Views...&gt;;
 
    constexpr auto operator[](difference_type n) const
      requires /*all-random-access*/&lt;Const, Views...&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
      requires (equality_comparable&lt;iterator_t&lt;/*maybe-const*/&lt;Const, Views&gt;&gt;&gt; &amp;&amp; ...);
 
    friend constexpr bool operator&lt;(const iterator&amp; x, const iterator&amp; y)
      requires /*all-random-access*/&lt;Const, Views...&gt;;
    friend constexpr bool operator&gt;(const iterator&amp; x, const iterator&amp; y)
      requires /*all-random-access*/&lt;Const, Views...&gt;;
    friend constexpr bool operator&lt;=(const iterator&amp; x, const iterator&amp; y)
      requires /*all-random-access*/&lt;Const, Views...&gt;;
    friend constexpr bool operator&gt;=(const iterator&amp; x, const iterator&amp; y)
      requires /*all-random-access*/&lt;Const, Views...&gt;;
    friend constexpr auto operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
      requires /*all-random-access*/&lt;Const, Views...&gt; &amp;&amp;
               (three_way_comparable&lt;iterator_t&lt;/*maybe-const*/&lt;Const, Views&gt;&gt;&gt; &amp;&amp; ...);
 
    friend constexpr iterator operator+(const iterator&amp; i, difference_type n)
      requires /*all-random-access*/&lt;Const, Views...&gt;;
    friend constexpr iterator operator+(difference_type n, const iterator&amp; i)
      requires /*all-random-access*/&lt;Const, Views...&gt;;
    friend constexpr iterator operator-(const iterator&amp; i, difference_type n)
      requires /*all-random-access*/&lt;Const, Views...&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires (sized_sentinel_for&lt;iterator_t&lt;/*maybe-const*/&lt;Const, Views&gt;&gt;,
                                   iterator_t&lt;/*maybe-const*/&lt;Const, Views&gt;&gt;&gt; &amp;&amp; ...);
 
    friend constexpr auto iter_move(const iterator&amp; i) noexcept(/* see description */);
 
    friend constexpr void iter_swap(const iterator&amp; l, const iterator&amp; r)
      noexcept(/* see description */)
      requires (indirectly_swappable&lt;iterator_t&lt;/*maybe-const*/&lt;Const, Views&gt;&gt;&gt; &amp;&amp; ...);
  };
}</pre></div> <h4 id="Class_template_std::ranges::zip_view::sentinel"> Class template <code>std::ranges::zip_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0)
  template&lt;bool Const&gt;
  class zip_view&lt;Views...&gt;::sentinel {
    /*tuple-or-pair*/&lt;sentinel_t&lt;/*maybe-const*/&lt;Const, Views&gt;&gt;...&gt;
      end_;   // exposition only
    constexpr explicit sentinel(/*tuple-or-pair*/&lt;sentinel_t&lt;
      /*maybe-const*/&lt;Const, Views&gt;&gt;...&gt; end);  // exposition only
  public:
    sentinel() = default;
    constexpr sentinel(sentinel&lt;!Const&gt; i)
      requires Const &amp;&amp;
               (convertible_to&lt;sentinel_t&lt;Views&gt;, sentinel_t&lt;
                 /*maybe-const*/&lt;Const, Views&gt;&gt;&gt; &amp;&amp; ...);
 
    template&lt;bool OtherConst&gt;
      requires (sentinel_for&lt;sentinel_t&lt;/*maybe-const*/&lt;Const, Views&gt;&gt;,
                             iterator_t&lt;/*maybe-const*/&lt;OtherConst, Views&gt;&gt;&gt; &amp;&amp; ...)
    friend constexpr bool operator==(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires (sized_sentinel_for&lt;sentinel_t&lt;/*maybe-const*/&lt;Const, Views&gt;&gt;,
                                   iterator_t&lt;/*maybe-const*/&lt;OtherConst, Views&gt;&gt;&gt; &amp;&amp; ...)
    friend constexpr common_type_t&lt;range_difference_t&lt;
      /*maybe-const*/&lt;OtherConst, Views&gt;&gt;...&gt;
      operator-(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires (sized_sentinel_for&lt;sentinel_t&lt;/*maybe-const*/&lt;Const, Views&gt;&gt;,
                                   iterator_t&lt;/*maybe-const*/&lt;OtherConst, Views&gt;&gt;&gt; &amp;&amp; ...)
    friend constexpr common_type_t&lt;range_difference_t&lt;
      /*maybe-const*/&lt;OtherConst, Views&gt;&gt;...&gt;
      operator-(const sentinel&amp; y, const iterator&lt;OtherConst&gt;&amp; x);
  };
}</pre></div> <h4 id="Class_template_std::ranges::zip_transform_view"> Class template <code>std::ranges::zip_transform_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;copy_constructible F, input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
              regular_invocable&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt; &amp;&amp;
              /*can-reference*/&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt;&gt;
  class zip_transform_view : public view_interface&lt;zip_transform_view&lt;F, Views...&gt;&gt; {
    /*copyable-box*/&lt;F&gt; fun_;               // exposition only
    zip_view&lt;Views...&gt; zip_;                // exposition only
 
    using InnerView = zip_view&lt;Views...&gt;;   // exposition only
    template&lt;bool Const&gt;
      using ziperator = iterator_t&lt;/*maybe-const*/&lt;Const, InnerView&gt;&gt;; // exposition only
    template&lt;bool Const&gt;
      using zentinel = sentinel_t&lt;/*maybe-const*/&lt;Const, InnerView&gt;&gt;;  // exposition only
 
    // class template zip_transform_view::iterator
    template&lt;bool&gt; class iterator;          // exposition only
 
    // class template zip_transform_view::sentinel
    template&lt;bool&gt; class sentinel;          // exposition only
 
  public:
    zip_transform_view() = default;
 
    constexpr explicit zip_transform_view(F fun, Views... views);
 
    constexpr auto begin() { return iterator&lt;false&gt;(*this, zip_.begin()); }
 
    constexpr auto begin() const
      requires range&lt;const InnerView&gt; &amp;&amp;
               regular_invocable&lt;const F&amp;, range_reference_t&lt;const Views&gt;...&gt; {
      return iterator&lt;true&gt;(*this, zip_.begin());
    }
 
    constexpr auto end() {
      if constexpr (common_range&lt;InnerView&gt;) {
        return iterator&lt;false&gt;(*this, zip_.end());
      } else {
        return sentinel&lt;false&gt;(zip_.end());
      }
    }
 
    constexpr auto end() const
      requires range&lt;const InnerView&gt; &amp;&amp;
               regular_invocable&lt;const F&amp;, range_reference_t&lt;const Views&gt;...&gt; {
      if constexpr (common_range&lt;const InnerView&gt;) {
        return iterator&lt;true&gt;(*this, zip_.end());
      } else {
        return sentinel&lt;true&gt;(zip_.end());
      }
    }
 
    constexpr auto size() requires sized_range&lt;InnerView&gt; {
      return zip_.size();
    }
 
    constexpr auto size() const requires sized_range&lt;const InnerView&gt; {
      return zip_.size();
    }
  };
 
  template&lt;class F, class... Rs&gt;
    zip_transform_view(F, Rs&amp;&amp;...) -&gt; zip_transform_view&lt;F, views::all_t&lt;Rs&gt;...&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::zip_transform_view::iterator"> Class template <code>std::ranges::zip_transform_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;copy_constructible F, input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
              regular_invocable&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt; &amp;&amp;
              /*can-reference*/&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt;&gt;
  template&lt;bool Const&gt;
  class zip_transform_view&lt;F, Views...&gt;::iterator {
    using Parent = /*maybe-const*/&lt;Const, zip_transform_view&gt;;  // exposition only
    using Base = /*maybe-const*/&lt;Const, InnerView&gt;;             // exposition only
    Parent* parent_ = nullptr;                                  // exposition only
    ziperator&lt;Const&gt; inner_;                                    // exposition only
 
    constexpr iterator(Parent&amp; parent, ziperator&lt;Const&gt; inner); // exposition only
 
  public:
    using iterator_category = /* see description */;            // not always present
    using iterator_concept  = typename ziperator&lt;Const&gt;::iterator_concept;
    using value_type =
      remove_cvref_t&lt;invoke_result_t&lt;/*maybe-const*/&lt;Const, F&gt;&amp;,
                                     range_reference_t&lt;
                                       /*maybe-const*/&lt;Const, Views&gt;&gt;...&gt;&gt;;
    using difference_type = range_difference_t&lt;Base&gt;;
 
    iterator() = default;
    constexpr iterator(iterator&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;ziperator&lt;false&gt;, ziperator&lt;Const&gt;&gt;;
 
    constexpr decltype(auto) operator*() const noexcept(/* see description */);
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires forward_range&lt;Base&gt;;
 
    constexpr iterator&amp; operator--() requires bidirectional_range&lt;Base&gt;;
    constexpr iterator operator--(int) requires bidirectional_range&lt;Base&gt;;
 
    constexpr iterator&amp; operator+=(difference_type x) requires random_access_range&lt;Base&gt;;
    constexpr iterator&amp; operator-=(difference_type x) requires random_access_range&lt;Base&gt;;
 
    constexpr decltype(auto) operator[](difference_type n) const
      requires random_access_range&lt;Base&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
      requires equality_comparable&lt;ziperator&lt;Const&gt;&gt;;
 
    friend constexpr bool operator&lt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&lt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr auto operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt; &amp;&amp; three_way_comparable&lt;ziperator&lt;Const&gt;&gt;;
 
    friend constexpr iterator operator+(const iterator&amp; i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator+(difference_type n, const iterator&amp; i)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator-(const iterator&amp; i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires sized_sentinel_for&lt;ziperator&lt;Const&gt;, ziperator&lt;Const&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::zip_transform_view::sentinel"> Class template <code>std::ranges::zip_transform_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;copy_constructible F, input_range... Views&gt;
    requires (view&lt;Views&gt; &amp;&amp; ...) &amp;&amp; (sizeof...(Views) &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
              regular_invocable&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt; &amp;&amp;
              /*can-reference*/&lt;invoke_result_t&lt;F&amp;, range_reference_t&lt;Views&gt;...&gt;&gt;
  template&lt;bool Const&gt;
  class zip_transform_view&lt;F, Views...&gt;::sentinel {
    zentinel&lt;Const&gt; inner_;                                     // exposition only
    constexpr explicit sentinel(zentinel&lt;Const&gt; inner);         // exposition only
 
  public:
    sentinel() = default;
    constexpr sentinel(sentinel&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;zentinel&lt;false&gt;, zentinel&lt;Const&gt;&gt;;
 
    template&lt;bool OtherConst&gt;
      requires sentinel_for&lt;zentinel&lt;Const&gt;, ziperator&lt;OtherConst&gt;&gt;
    friend constexpr bool operator==(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;zentinel&lt;Const&gt;, ziperator&lt;OtherConst&gt;&gt;
    friend constexpr range_difference_t&lt;/*maybe-const*/&lt;OtherConst, InnerView&gt;&gt;
      operator-(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;zentinel&lt;Const&gt;, ziperator&lt;OtherConst&gt;&gt;
    friend constexpr range_difference_t&lt;/*maybe-const*/&lt;OtherConst, InnerView&gt;&gt;
      operator-(const sentinel&amp; x, const iterator&lt;OtherConst&gt;&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::adjacent_view"> Class template <code>std::ranges::adjacent_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0)
  class adjacent_view : public view_interface&lt;adjacent_view&lt;V, N&gt;&gt; {
    V base_ = V();                      // exposition only
 
    // class template adjacent_view::iterator
    template&lt;bool&gt; class iterator;      // exposition only
 
    // class template adjacent_view::sentinel
    template&lt;bool&gt; class sentinel;      // exposition only
 
    struct /*as-sentinel*/{};               // exposition only
 
  public:
    adjacent_view() requires default_initializable&lt;V&gt; = default;
    constexpr explicit adjacent_view(V base);
 
    constexpr auto begin() requires (!/*simple-view*/&lt;V&gt;) {
      return iterator&lt;false&gt;(ranges::begin(base_), ranges::end(base_));
    }
 
    constexpr auto begin() const requires range&lt;const V&gt; {
      return iterator&lt;true&gt;(ranges::begin(base_), ranges::end(base_));
    }
 
    constexpr auto end() requires (!/*simple-view*/&lt;V&gt;) {
      if constexpr (common_range&lt;V&gt;) {
        return iterator&lt;false&gt;(/*as-sentinel*/{}, ranges::begin(base_),
          ranges::end(base_));
      } else {
        return sentinel&lt;false&gt;(ranges::end(base_));
      }
    }
 
    constexpr auto end() const requires range&lt;const V&gt; {
      if constexpr (common_range&lt;const V&gt;) {
        return iterator&lt;true&gt;(/*as-sentinel*/{}, ranges::begin(base_),
          ranges::end(base_));
      } else {
        return sentinel&lt;true&gt;(ranges::end(base_));
      }
    }
 
    constexpr auto size() requires sized_range&lt;V&gt;;
    constexpr auto size() const requires sized_range&lt;const V&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::adjacent_view::iterator"> Class template <code>std::ranges::adjacent_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0)
  template&lt;bool Const&gt;
  class adjacent_view&lt;V, N&gt;::iterator {
    using Base = /*maybe-const*/&lt;Const, V&gt;;                             // exposition only
    array&lt;iterator_t&lt;Base&gt;, N&gt; current_ = array&lt;iterator_t&lt;Base&gt;, N&gt;(); // exposition only
    constexpr iterator(iterator_t&lt;Base&gt; first, sentinel_t&lt;Base&gt; last);  // exposition only
    constexpr iterator(/*as-sentinel*/, iterator_t&lt;Base&gt; first, iterator_t&lt;Base&gt; last);
                                                                        // exposition only
  public:
    using iterator_category = input_iterator_tag;
    using iterator_concept  = /* see description */;
    using value_type = /*tuple-or-pair*/&lt;/*REPEAT*/(range_value_t&lt;Base&gt;, N)...&gt;;
    using difference_type = range_difference_t&lt;Base&gt;;
 
    iterator() = default;
    constexpr iterator(iterator&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;iterator_t&lt;V&gt;, iterator_t&lt;Base&gt;&gt;;
 
    constexpr auto operator*() const;
    constexpr iterator&amp; operator++();
    constexpr iterator operator++(int);
 
    constexpr iterator&amp; operator--() requires bidirectional_range&lt;Base&gt;;
    constexpr iterator operator--(int) requires bidirectional_range&lt;Base&gt;;
 
    constexpr iterator&amp; operator+=(difference_type x)
      requires random_access_range&lt;Base&gt;;
    constexpr iterator&amp; operator-=(difference_type x)
      requires random_access_range&lt;Base&gt;;
 
    constexpr auto operator[](difference_type n) const
      requires random_access_range&lt;Base&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y);
    friend constexpr bool operator&lt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&lt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr auto operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt; &amp;&amp;
               three_way_comparable&lt;iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr iterator operator+(const iterator&amp; i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator+(difference_type n, const iterator&amp; i)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator-(const iterator&amp; i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires sized_sentinel_for&lt;iterator_t&lt;Base&gt;, iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr auto iter_move(const iterator&amp; i) noexcept(/* see description */);
    friend constexpr void iter_swap(const iterator&amp; l, const iterator&amp; r)
      noexcept(/* see description */)
      requires indirectly_swappable&lt;iterator_t&lt;Base&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::adjacent_view::sentinel"> Class template <code>std::ranges::adjacent_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0)
  template&lt;bool Const&gt;
  class adjacent_view&lt;V, N&gt;::sentinel {
    using Base = /*maybe-const*/&lt;Const, V&gt;;                     // exposition only
    sentinel_t&lt;Base&gt; end_ = sentinel_t&lt;Base&gt;();                 // exposition only
    constexpr explicit sentinel(sentinel_t&lt;Base&gt; end);          // exposition only
 
  public:
    sentinel() = default;
    constexpr sentinel(sentinel&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;Base&gt;&gt;;
 
    template&lt;bool OtherConst&gt;
      requires sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;/*maybe-const*/&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr bool operator==(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;
        /*maybe-const*/&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr range_difference_t&lt;/*maybe-const*/&lt;OtherConst, V&gt;&gt;
      operator-(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;
        /*maybe-const*/&lt;OtherConst, V&gt;&gt;&gt;
    friend constexpr range_difference_t&lt;/*maybe-const*/&lt;OtherConst, V&gt;&gt;
      operator-(const sentinel&amp; y, const iterator&lt;OtherConst&gt;&amp; x);
  };
}</pre></div> <h4 id="Class_template_std::ranges::adjacent_transform_view"> Class template <code>std::ranges::adjacent_transform_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, copy_constructible F, size_t N&gt;
   requires view&lt;V&gt; &amp;&amp; (N &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
            regular_invocable&lt;F&amp;, /*REPEAT*/(range_reference_t&lt;V&gt;, N)...&gt; &amp;&amp;
            /*can-reference*/&lt;invoke_result_t&lt;F&amp;, /*REPEAT*/(range_reference_t&lt;V&gt;, N)...&gt;&gt;
  class adjacent_transform_view :
    public view_interface&lt;adjacent_transform_view&lt;V, F, N&gt;&gt; {
    /*copyable-box*/&lt;F&gt; fun_;                       // exposition only
    adjacent_view&lt;V, N&gt; inner_;                 // exposition only
 
    using InnerView = adjacent_view&lt;V, N&gt;;      // exposition only
    template&lt;bool Const&gt;
      using /*inner-iterator*/ =
        iterator_t&lt;/*maybe-const*/&lt;Const, InnerView&gt;&gt;;         // exposition only
    template&lt;bool Const&gt;
      using /*inner-sentinel*/ =
        sentinel_t&lt;/*maybe-const*/&lt;Const, InnerView&gt;&gt;;         // exposition only
 
    // class template adjacent_transform_view::iterator
    template&lt;bool&gt; class iterator;              // exposition only
 
    // class template adjacent_transform_view::sentinel
    template&lt;bool&gt; class sentinel;              // exposition only
 
  public:
    adjacent_transform_view() = default;
    constexpr explicit adjacent_transform_view(V base, F fun);
 
    constexpr auto begin() {
      return iterator&lt;false&gt;(*this, inner_.begin());
    }
 
    constexpr auto begin() const
      requires range&lt;const InnerView&gt; &amp;&amp;
               regular_invocable&lt;const F&amp;, /*REPEAT*/(range_reference_t&lt;const V&gt;, N)...&gt; {
      return iterator&lt;true&gt;(*this, inner_.begin());
    }
 
    constexpr auto end() {
      if constexpr (common_range&lt;InnerView&gt;) {
        return iterator&lt;false&gt;(*this, inner_.end());
      } else {
        return sentinel&lt;false&gt;(inner_.end());
      }
    }
 
    constexpr auto end() const
      requires range&lt;const InnerView&gt; &amp;&amp;
               regular_invocable&lt;const F&amp;, /*REPEAT*/(range_reference_t&lt;const V&gt;, N)...&gt; {
      if constexpr (common_range&lt;const InnerView&gt;) {
        return iterator&lt;true&gt;(*this, inner_.end());
      } else {
        return sentinel&lt;true&gt;(inner_.end());
      }
    }
 
    constexpr auto size() requires sized_range&lt;InnerView&gt; {
      return inner_.size();
    }
 
    constexpr auto size() const requires sized_range&lt;const InnerView&gt; {
      return inner_.size();
    }
  };
}</pre></div> <h4 id="Class_template_std::ranges::adjacent_transform_view::iterator"> Class template <code>std::ranges::adjacent_transform_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, copy_constructible F, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, /*REPEAT*/(range_reference_t&lt;V&gt;, N)...&gt; &amp;&amp;
             /*can-reference*/&lt;invoke_result_t&lt;F&amp;,
               /*REPEAT*/(range_reference_t&lt;V&gt;, N)...&gt;&gt;
  template&lt;bool Const&gt;
  class adjacent_transform_view&lt;F, V...&gt;::iterator {
    using Parent = /*maybe-const*/&lt;Const, adjacent_transform_view&gt;;  // exposition only
    using Base = /*maybe-const*/&lt;Const, V&gt;;                          // exposition only
    Parent* parent_ = nullptr;                                       // exposition only
    /*inner-iterator*/&lt;Const&gt; inner_;                                // exposition only
 
    constexpr iterator(Parent&amp; parent,
      /*inner-iterator*/&lt;Const&gt; inner);    // exposition only
 
  public:
    using iterator_category = /* see description */;
    using iterator_concept  = typename /*inner-iterator*/&lt;Const&gt;::iterator_concept;
    using value_type =
      remove_cvref_t&lt;invoke_result_t&lt;/*maybe-const*/&lt;Const, F&gt;&amp;,
                                     /*REPEAT*/(range_reference_t&lt;Base&gt;, N)...&gt;&gt;;
    using difference_type = range_difference_t&lt;Base&gt;;
 
    iterator() = default;
    constexpr iterator(iterator&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;/*inner-iterator*/&lt;false&gt;,
        /*inner-iterator*/&lt;Const&gt;&gt;;
 
    constexpr decltype(auto) operator*() const noexcept(/* see description */);
    constexpr iterator&amp; operator++();
    constexpr iterator operator++(int);
    constexpr iterator&amp; operator--() requires bidirectional_range&lt;Base&gt;;
    constexpr iterator operator--(int) requires bidirectional_range&lt;Base&gt;;
    constexpr iterator&amp; operator+=(difference_type x) requires random_access_range&lt;Base&gt;;
    constexpr iterator&amp; operator-=(difference_type x) requires random_access_range&lt;Base&gt;;
 
    constexpr decltype(auto) operator[](difference_type n) const
      requires random_access_range&lt;Base&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y);
    friend constexpr bool operator&lt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&lt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr auto operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt; &amp;&amp; three_way_comparable&lt;
        /*inner-iterator*/&lt;Const&gt;&gt;;
 
    friend constexpr iterator operator+(const iterator&amp; i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator+(difference_type n, const iterator&amp; i)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator-(const iterator&amp; i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires sized_sentinel_for&lt;/*inner-iterator*/&lt;Const&gt;, /*inner-iterator*/&lt;Const&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::adjacent_transform_view::sentinel"> Class template <code>std::ranges::adjacent_transform_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, copy_constructible F, size_t N&gt;
    requires view&lt;V&gt; &amp;&amp; (N &gt; 0) &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             regular_invocable&lt;F&amp;, /*REPEAT*/(range_reference_t&lt;V&gt;, N)...&gt; &amp;&amp;
             /*can-reference*/&lt;invoke_result_t&lt;F&amp;,
               /*REPEAT*/(range_reference_t&lt;V&gt;, N)...&gt;&gt;
  template&lt;bool Const&gt;
  class adjacent_transform_view&lt;V, F, N&gt;::sentinel {
    /*inner-sentinel*/&lt;Const&gt; inner_;                               // exposition only
    constexpr explicit sentinel(/*inner-sentinel*/&lt;Const&gt; inner);   // exposition only
 
  public:
    sentinel() = default;
    constexpr sentinel(sentinel&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;/*inner-sentinel*/&lt;false&gt;,
                                       /*inner-sentinel*/&lt;Const&gt;&gt;;
    template&lt;bool OtherConst&gt;
      requires sentinel_for&lt;/*inner-sentinel*/&lt;Const&gt;, /*inner-iterator*/&lt;OtherConst&gt;&gt;
    friend constexpr bool operator==(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;/*inner-sentinel*/&lt;Const&gt;,
                                  /*inner-iterator*/&lt;OtherConst&gt;&gt;
    friend constexpr range_difference_t&lt;/*maybe-const*/&lt;OtherConst, InnerView&gt;&gt;
      operator-(const iterator&lt;OtherConst&gt;&amp; x, const sentinel&amp; y);
 
    template&lt;bool OtherConst&gt;
      requires sized_sentinel_for&lt;/*inner-sentinel*/&lt;Const&gt;,
                                  /*inner-iterator*/&lt;OtherConst&gt;&gt;
    friend constexpr range_difference_t&lt;/*maybe-const*/&lt;OtherConst, InnerView&gt;&gt;
      operator-(const sentinel&amp; x, const iterator&lt;OtherConst&gt;&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::chunk_view_for_input_ranges"> Class template <code>std::ranges::chunk_view</code> for input ranges</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class I&gt;
  constexpr I /*div-ceil*/(I num, I denom) {              // exposition only
    I r = num / denom;
    if (num % denom)
      ++r;
    return r;
  }
 
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class chunk_view : public view_interface&lt;chunk_view&lt;V&gt;&gt; {
    V base_ = V();                                        // exposition only
    range_difference_t&lt;V&gt; n_ = 0;                         // exposition only
    range_difference_t&lt;V&gt; remainder_ = 0;                 // exposition only
 
    /*non-propagating-cache*/&lt;iterator_t&lt;V&gt;&gt; current_;    // exposition only
 
    // class chunk_view::/*outer-iterator*/
    class /*outer-iterator*/;                             // exposition only
 
    // class chunk_view::/*inner-iterator*/
    class /*inner-iterator*/;                             // exposition only
 
  public:
    chunk_view() requires default_initializable&lt;V&gt; = default;
    constexpr explicit chunk_view(V base, range_difference_t&lt;V&gt; n);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr /*outer-iterator*/ begin();
    constexpr default_sentinel_t end() noexcept;
 
    constexpr auto size() requires sized_range&lt;V&gt;;
    constexpr auto size() const requires sized_range&lt;const V&gt;;
  };
 
  template&lt;class R&gt;
    chunk_view(R&amp;&amp; r, range_difference_t&lt;R&gt;) -&gt; chunk_view&lt;views::all_t&lt;R&gt;&gt;;
}</pre></div> <h4 id="Class_std::ranges::chunk_view::outer_iterator_for_input_ranges"> Class <code>std::ranges::chunk_view::outer_iterator</code> for input ranges</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class chunk_view&lt;V&gt;::/*outer-iterator*/ {
    chunk_view* parent_;                                        // exposition only
 
    constexpr explicit /*outer-iterator*/(chunk_view&amp; parent);  // exposition only
 
  public:
    using iterator_concept = input_iterator_tag;
    using difference_type  = range_difference_t&lt;V&gt;;
 
    // class chunk_view::/*outer-iterator*/::value_type
    struct value_type;
 
    /*outer-iterator*/(/*outer-iterator*/&amp;&amp;) = default;
    /*outer-iterator*/r&amp; operator=(/*outer-iterator*/&amp;&amp;) = default;
 
    constexpr value_type operator*() const;
    constexpr /*outer-iterator*/&amp; operator++();
    constexpr void operator++(int);
 
    friend constexpr bool operator==(const /*outer-iterator*/&amp; x, default_sentinel_t);
 
    friend constexpr difference_type operator-(default_sentinel_t y,
                                               const /*outer-iterator*/&amp; x)
      requires sized_sentinel_for&lt;sentinel_t&lt;V&gt;, iterator_t&lt;V&gt;&gt;;
    friend constexpr difference_type operator-(const /*outer-iterator*/&amp; x,
                                               default_sentinel_t y)
      requires sized_sentinel_for&lt;sentinel_t&lt;V&gt;, iterator_t&lt;V&gt;&gt;;
  };
}</pre></div> <h4 id="Class_std::ranges::chunk_view::outer_iterator::value_type_for_input_ranges"> Class <code>std::ranges::chunk_view::outer_iterator::value_type</code> for input ranges</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  struct chunk_view&lt;V&gt;::/*outer-iterator*/::value_type
  : view_interface&lt;value_type&gt; {
  private:
    chunk_view* parent_;                                        // exposition only
 
    constexpr explicit value_type(chunk_view&amp; parent);          // exposition only
 
  public:
    constexpr /*inner-iterator*/ begin() const noexcept;
    constexpr default_sentinel_t end() const noexcept;
 
    constexpr auto size() const
      requires sized_sentinel_for&lt;sentinel_t&lt;V&gt;, iterator_t&lt;V&gt;&gt;;
  };
}</pre></div> <h4 id="Class_std::ranges::chunk_view::inner_iterator_for_input_ranges"> Class <code>std::ranges::chunk_view::inner_iterator</code> for input ranges</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
    requires input_range&lt;V&gt;
  class chunk_view&lt;V&gt;::/*inner-iterator*/ {
    chunk_view* parent_;                                                // exposition only
 
    constexpr explicit /*inner-iterator*/(chunk_view&amp; parent) noexcept;     // exposition only
 
  public:
    using iterator_concept = input_iterator_tag;
    using difference_type = range_difference_t&lt;V&gt;;
    using value_type = range_value_t&lt;V&gt;;
 
    /*inner-iterator*/(/*inner-iterator*/&amp;&amp;) = default;
    /*inner-iterator*/&amp; operator=(/*inner-iterator*/&amp;&amp;) = default;
 
    constexpr const iterator_t&lt;V&gt;&amp; base() const &amp;;
 
    constexpr range_reference_t&lt;V&gt; operator*() const;
    constexpr /*inner-iterator*/&amp; operator++();
    constexpr void operator++(int);
 
    friend constexpr bool operator==(const /*inner-iterator*/&amp; x, default_sentinel_t);
 
    friend constexpr difference_type operator-(default_sentinel_t y,
                                               const /*inner-iterator*/&amp; x)
      requires sized_sentinel_for&lt;sentinel_t&lt;V&gt;, iterator_t&lt;V&gt;&gt;;
    friend constexpr difference_type operator-(const /*inner-iterator*/&amp; x,
                                               default_sentinel_t y)
      requires sized_sentinel_for&lt;sentinel_t&lt;V&gt;, iterator_t&lt;V&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::chunk_view_for_forward_ranges"> Class template <code>std::ranges::chunk_view</code> for forward ranges</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
    requires forward_range&lt;V&gt;
  class chunk_view&lt;V&gt; : public view_interface&lt;chunk_view&lt;V&gt;&gt; {
    V base_ = V();                      // exposition only
    range_difference_t&lt;V&gt; n_ = 0;       // exposition only
 
    // class template chunk_view::iterator
    template&lt;bool&gt; class iterator;      // exposition only
 
  public:
    chunk_view() requires default_initializable&lt;V&gt; = default;
    constexpr explicit chunk_view(V base, range_difference_t&lt;V&gt; n);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr auto begin() requires (!/*simple-view*/&lt;V&gt;) {
      return iterator&lt;false&gt;(this, ranges::begin(base_));
    }
 
    constexpr auto begin() const requires forward_range&lt;const V&gt; {
      return iterator&lt;true&gt;(this, ranges::begin(base_));
    }
 
    constexpr auto end() requires (!/*simple-view*/&lt;V&gt;) {
      if constexpr (common_range&lt;V&gt; &amp;&amp; sized_range&lt;V&gt;) {
        auto missing = (n_ - ranges::distance(base_) % n_) % n_;
        return iterator&lt;false&gt;(this, ranges::end(base_), missing);
      } else if constexpr (common_range&lt;V&gt; &amp;&amp; !bidirectional_range&lt;V&gt;) {
        return iterator&lt;false&gt;(this, ranges::end(base_));
      } else {
        return default_sentinel;
      }
    }
 
    constexpr auto end() const requires forward_range&lt;const V&gt; {
      if constexpr (common_range&lt;const V&gt; &amp;&amp; sized_range&lt;const V&gt;) {
        auto missing = (n_ - ranges::distance(base_) % n_) % n_;
        return iterator&lt;true&gt;(this, ranges::end(base_), missing);
      } else if constexpr (common_range&lt;const V&gt; &amp;&amp; !bidirectional_range&lt;const V&gt;) {
        return iterator&lt;true&gt;(this, ranges::end(base_));
      } else {
        return default_sentinel;
      }
    }
 
    constexpr auto size() requires sized_range&lt;V&gt;;
    constexpr auto size() const requires sized_range&lt;const V&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::chunk_view::iterator_for_forward_ranges"> Class template <code>std::ranges::chunk_view::iterator</code> for forward ranges</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;view V&gt;
    requires forward_range&lt;V&gt;
  template&lt;bool Const&gt;
  class chunk_view&lt;V&gt;::iterator {
    using Parent = /*maybe-const*/&lt;Const, chunk_view&gt;;                  // exposition only
    using Base = /*maybe-const*/&lt;Const, V&gt;;                             // exposition only
 
    iterator_t&lt;Base&gt; current_ = iterator_t&lt;Base&gt;();                     // exposition only
    sentinel_t&lt;Base&gt; end_ = sentinel_t&lt;Base&gt;();                         // exposition only
    range_difference_t&lt;Base&gt; n_ = 0;                                    // exposition only
    range_difference_t&lt;Base&gt; missing_ = 0;                              // exposition only
 
    constexpr iterator(Parent* parent, iterator_t&lt;Base&gt; current,        // exposition only
                       range_difference_t&lt;Base&gt; missing = 0);
 
  public:
    using iterator_category = input_iterator_tag;
    using iterator_concept = /* see description */;
    using value_type = decltype(views::take(subrange(current_, end_), n_));
    using difference_type = range_difference_t&lt;Base&gt;;
 
    iterator() = default;
    constexpr iterator(iterator&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;iterator_t&lt;V&gt;, iterator_t&lt;Base&gt;&gt;
                     &amp;&amp; convertible_to&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;Base&gt;&gt;;
 
    constexpr iterator_t&lt;Base&gt; base() const;
 
    constexpr value_type operator*() const;
    constexpr iterator&amp; operator++();
    constexpr iterator operator++(int);
 
    constexpr iterator&amp; operator--() requires bidirectional_range&lt;Base&gt;;
    constexpr iterator operator--(int) requires bidirectional_range&lt;Base&gt;;
 
    constexpr iterator&amp; operator+=(difference_type x)
      requires random_access_range&lt;Base&gt;;
    constexpr iterator&amp; operator-=(difference_type x)
      requires random_access_range&lt;Base&gt;;
 
    constexpr value_type operator[](difference_type n) const
      requires random_access_range&lt;Base&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y);
    friend constexpr bool operator==(const iterator&amp; x, default_sentinel_t);
 
    friend constexpr bool operator&lt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&lt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr auto operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt; &amp;&amp;
               three_way_comparable&lt;iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr iterator operator+(const iterator&amp; i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator+(difference_type n, const iterator&amp; i)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator-(const iterator&amp; i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires sized_sentinel_for&lt;iterator_t&lt;Base&gt;, iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr difference_type operator-(default_sentinel_t y, const iterator&amp; x)
      requires sized_sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;Base&gt;&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, default_sentinel_t y)
      requires sized_sentinel_for&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;Base&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::slide_view"> Class template <code>std::ranges::slide_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class V&gt;
  concept /*slide-caches-nothing*/ = random_access_range&lt;V&gt; // exposition only
                                  &amp;&amp; sized_range&lt;V&gt;;
 
  template&lt;class V&gt;
  concept /*slide-caches-last*/ =                           // exposition only
    !/*slide-caches-nothing*/&lt;V&gt; &amp;&amp; bidirectional_range&lt;V&gt; &amp;&amp; common_range&lt;V&gt;;
 
  template&lt;class V&gt;
  concept /*slide-caches-first*/ =                          // exposition only
    !/*slide-caches-nothing*/&lt;V&gt; &amp;&amp; !/*slide-caches-last*/&lt;V&gt;;
 
  template&lt;forward_range V&gt;
    requires view&lt;V&gt;
  class slide_view : public view_interface&lt;slide_view&lt;V&gt;&gt; {
    V base_ = V();                      // exposition only
    range_difference_t&lt;V&gt; n_ = 0;       // exposition only
 
    // class template slide_view::iterator
    template&lt;bool&gt; class iterator;      // exposition only
 
    // class slide_view::sentinel
    class sentinel;                     // exposition only
 
  public:
    slide_view() requires default_initializable&lt;V&gt; = default;
    constexpr explicit slide_view(V base, range_difference_t&lt;V&gt; n);
 
    constexpr auto begin()
      requires (!(/*simple-view*/&lt;V&gt; &amp;&amp; /*slide-caches-nothing*/&lt;const V&gt;));
    constexpr auto begin() const requires /*slide-caches-nothing*/&lt;const V&gt;;
 
    constexpr auto end()
      requires (!(/*simple-view*/&lt;V&gt; &amp;&amp; /*slide-caches-nothing*/&lt;const V&gt;));
    constexpr auto end() const requires /*slide-caches-nothing*/&lt;const V&gt;;
 
    constexpr auto size() requires sized_range&lt;V&gt;;
    constexpr auto size() const requires sized_range&lt;const V&gt;;
  };
 
  template&lt;class R&gt;
    slide_view(R&amp;&amp; r, range_difference_t&lt;R&gt;) -&gt; slide_view&lt;views::all_t&lt;R&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::slide_view::iterator"> Class template <code>std::ranges::slide_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V&gt;
    requires view&lt;V&gt;
  template&lt;bool Const&gt;
  class slide_view&lt;V&gt;::iterator {
    using Base = /*maybe-const*/&lt;Const, V&gt;;             // exposition only
    iterator_t&lt;Base&gt; current_   = iterator_t&lt;Base&gt;();   // exposition only
    iterator_t&lt;Base&gt; last_ele_  = iterator_t&lt;Base&gt;();   // exposition only,
                          // present only if Base models slide-caches-first
    range_difference_t&lt;Base&gt; n_ = 0;                    // exposition only
 
    constexpr iterator(iterator_t&lt;Base&gt; current, range_difference_t&lt;Base&gt; n) // exposition only
      requires (!/*slide-caches-first*/&lt;Base&gt;);
 
    constexpr iterator(iterator_t&lt;Base&gt; current, iterator_t&lt;Base&gt; last_ele,  // exposition only
                       range_difference_t&lt;Base&gt; n)
      requires /*slide-caches-first*/&lt;Base&gt;;
 
  public:
    using iterator_category = input_iterator_tag;
    using iterator_concept = /* see description */;
    using value_type = decltype(views::counted(current_, n_));
    using difference_type = range_difference_t&lt;Base&gt;;
 
    iterator() = default;
    constexpr iterator(iterator&lt;!Const&gt; i)
      requires Const &amp;&amp; convertible_to&lt;iterator_t&lt;V&gt;, iterator_t&lt;Base&gt;&gt;;
 
    constexpr auto operator*() const;
    constexpr iterator&amp; operator++();
    constexpr iterator operator++(int);
 
    constexpr iterator&amp; operator--() requires bidirectional_range&lt;Base&gt;;
    constexpr iterator operator--(int) requires bidirectional_range&lt;Base&gt;;
 
    constexpr iterator&amp; operator+=(difference_type x)
      requires random_access_range&lt;Base&gt;;
    constexpr iterator&amp; operator-=(difference_type x)
      requires random_access_range&lt;Base&gt;;
 
    constexpr auto operator[](difference_type n) const
      requires rrandom_access_range&lt;Base&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y);
 
    friend constexpr bool operator&lt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&lt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr bool operator&gt;=(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt;;
    friend constexpr auto operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
      requires random_access_range&lt;Base&gt; &amp;&amp;
               three_way_comparable&lt;iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr iterator operator+(const iterator&amp; i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator+(difference_type n, const iterator&amp; i)
      requires random_access_range&lt;Base&gt;;
    friend constexpr iterator operator-(const iterator&amp; i, difference_type n)
      requires random_access_range&lt;Base&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires sized_sentinel_for&lt;iterator_t&lt;Base&gt;, iterator_t&lt;Base&gt;&gt;;
  };
}</pre></div> <h4 id="Class_std::ranges::slide_view::sentinel"> Class <code>std::ranges::slide_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V&gt;
    requires view&lt;V&gt;
  class slide_view&lt;V&gt;::sentinel {
    sentinel_t&lt;V&gt; end_ = sentinel_t&lt;V&gt;();             // exposition only
    constexpr explicit sentinel(sentinel_t&lt;V&gt; end);   // exposition only
 
  public:
    sentinel() = default;
 
    friend constexpr bool operator==(const iterator&lt;false&gt;&amp; x, const sentinel&amp; y);
 
    friend constexpr range_difference_t&lt;V&gt;
      operator-(const iterator&lt;false&gt;&amp; x, const sentinel&amp; y)
        requires sized_sentinel_for&lt;sentinel_t&lt;V&gt;, iterator_t&lt;V&gt;&gt;;
 
    friend constexpr range_difference_t&lt;V&gt;
      operator-(const sentinel&amp; y, const iterator&lt;false&gt;&amp; x)
        requires sized_sentinel_for&lt;sentinel_t&lt;V&gt;, iterator_t&lt;V&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::chunk_by_view"> Class template <code>std::ranges::chunk_by_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, indirect_binary_predicate&lt;iterator_t&lt;V&gt;, iterator_t&lt;V&gt;&gt; Pred&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class chunk_by_view : public view_interface&lt;chunk_by_view&lt;V, Pred&gt;&gt; {
    V base_ = V();                          // exposition only
    /*copyable-box*/&lt;Pred&gt; pred_ = Pred();  // exposition only
 
    // class chunk_by_view::iterator
    class iterator;                         // exposition only
 
  public:
    chunk_by_view()
        requires default_initializable&lt;V&gt; &amp;&amp; default_initializable&lt;Pred&gt; = default;
    constexpr explicit chunk_by_view(V base, Pred pred);
 
    constexpr V base() const &amp; requires copy_constructible&lt;V&gt; { return base_; }
    constexpr V base() &amp;&amp; { return std::move(base_); }
 
    constexpr const Pred&amp; pred() const;
 
    constexpr iterator begin();
    constexpr auto end();
 
    constexpr iterator_t&lt;V&gt; /*find-next*/(iterator_t&lt;V&gt;);   // exposition only
    constexpr iterator_t&lt;V&gt; /*find-prev*/(iterator_t&lt;V&gt;)    // exposition only
      requires bidirectional_range&lt;V&gt;;
  };
 
  template&lt;class R, class Pred&gt;
    chunk_by_view(R&amp;&amp;, Pred) -&gt; chunk_by_view&lt;views::all_t&lt;R&gt;, Pred&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::chunk_by_view::iterator"> Class template <code>std::ranges::chunk_by_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;forward_range V, indirect_binary_predicate&lt;iterator_t&lt;V&gt;, iterator_t&lt;V&gt;&gt; Pred&gt;
    requires view&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class chunk_by_view&lt;V, Pred&gt;::iterator {
    chunk_by_view* parent_ = nullptr;           // exposition only
    iterator_t&lt;V&gt; current_ = iterator_t&lt;V&gt;();   // exposition only
    iterator_t&lt;V&gt; next_    = iterator_t&lt;V&gt;();   // exposition only
 
    constexpr iterator(chunk_by_view&amp; parent, iterator_t&lt;V&gt; current,    // exposition only
                       iterator_t&lt;V&gt; next);
 
  public:
    using value_type = subrange&lt;iterator_t&lt;V&gt;&gt;;
    using difference_type  = range_difference_t&lt;V&gt;;
    using iterator_category = input_iterator_tag;
    using iterator_concept = /* see description */;
 
    iterator() = default;
 
    constexpr value_type operator*() const;
    constexpr iterator&amp; operator++();
    constexpr iterator operator++(int);
 
    constexpr iterator&amp; operator--() requires bidirectional_range&lt;V&gt;;
    constexpr iterator operator--(int) requires bidirectional_range&lt;V&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y);
    friend constexpr bool operator==(const iterator&amp; x, default_sentinel_t);
  };
}</pre></div>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/header/ranges" class="_attribution-link">https://en.cppreference.com/w/cpp/header/ranges</a>
  </p>
</div>
