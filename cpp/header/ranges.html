   <h1 id="firstHeading" class="firstHeading">Standard library header &lt;ranges&gt;</h1>            <p>This header is part of the <a href="../ranges" title="cpp/ranges">ranges</a> library.</p>
<h3 id="Namespace_aliases"> Namespace aliases </h3> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">namespace std {
    namespace view = ranges::view;
}</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>The namespace alias <code>std::view</code> is provided as a shorthand for <code>std::ranges::view</code>.</p>
<table class="t-dsc-begin"> <tr> <td colspan="2"> <h3 id="Concepts">  Concepts</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Range_concepts">  Range concepts </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/range" title="cpp/ranges/Range"> <span class="t-lines"><span>Range</span></span></a></div> </td> <td> specifies that a type is a range, that is, it provides a <code>begin</code> iterator and an <code>end</code> sentinel <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/sizedrange" title="cpp/ranges/SizedRange"> <span class="t-lines"><span>SizedRange</span></span></a></div> </td> <td> specifies that a range knows its size in constant time <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/view" title="cpp/ranges/View"> <span class="t-lines"><span>View</span></span></a></div> </td> <td> specifies that a range is a view, that is, it has constant time copy/move/assignment <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/inputrange" title="cpp/ranges/InputRange"> <span class="t-lines"><span>InputRange</span></span></a></div> </td> <td> specifies a range whose iterator type satisfies <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/InputIterator（页面不存在）"><code>InputIterator</code></a> <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/outputrange" title="cpp/ranges/OutputRange"> <span class="t-lines"><span>OutputRange</span></span></a></div> </td> <td> specifies a range whose iterator type satisfies <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/OutputIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/OutputIterator（页面不存在）"><code>OutputIterator</code></a> <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/forwardrange" title="cpp/ranges/ForwardRange"> <span class="t-lines"><span>ForwardRange</span></span></a></div> </td> <td> specifies a range whose iterator type satisfies <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/ForwardIterator（页面不存在）"><code>ForwardIterator</code></a> <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/bidirectionalrange" title="cpp/ranges/BidirectionalRange"> <span class="t-lines"><span>BidirectionalRange</span></span></a></div> </td> <td> specifies a range whose iterator type satisfies <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/BidirectionalIterator（页面不存在）"><code>BidirectionalIterator</code></a> <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/randomaccessrange" title="cpp/ranges/RandomAccessRange"> <span class="t-lines"><span>RandomAccessRange</span></span></a></div> </td> <td> specifies a range whose iterator type satisfies <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/RandomAccessIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/RandomAccessIterator（页面不存在）"><code>RandomAccessIterator</code></a> <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/contiguousrange" title="cpp/ranges/ContiguousRange"> <span class="t-lines"><span>ContiguousRange</span></span></a></div> </td> <td> specifies a range whose iterator type satisfies <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ContiguousIterator&amp;action=edit&amp;redlink=1" class="new" title="cpp/iterator/ContiguousIterator（页面不存在）"><code>ContiguousIterator</code></a> <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/commonrange" title="cpp/ranges/CommonRange"> <span class="t-lines"><span>CommonRange</span></span></a></div> </td> <td> specifies that a range has identical iterator and sentinel types <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/viewablerange" title="cpp/ranges/ViewableRange"> <span class="t-lines"><span>ViewableRange</span></span></a></div> </td> <td> specifies the requirements for a <a href="../ranges/range" title="cpp/ranges/Range"><code>Range</code></a> to be safely convertible to a <a href="../ranges/view" title="cpp/ranges/View"><code>View</code></a> <br> <span class="t-mark">(concept)</span> </td>
</tr> <tr> <td colspan="2"> <h3 id="Classes">  Classes</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Range_primitives">  Range primitives </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/iterator_t" title="cpp/ranges/iterator t"> <span class="t-lines"><span>iterator_t</span><span>sentinel_t</span></span></a></div> </td> <td> obtains the iterator and sentinel types of a range <br> <span class="t-mark">(alias template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Views">  Views </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/view_interface&amp;action=edit&amp;redlink=1" class="new" title="cpp/ranges/view interface（页面不存在）"> <span class="t-lines"><span>view_interface</span></span></a></div> </td> <td> helper class template for defining <a href="../ranges/view" title="cpp/ranges/View"><code>View</code>s</a>, using the curiously recurring template pattern <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/subrange&amp;action=edit&amp;redlink=1" class="new" title="cpp/ranges/subrange（页面不存在）"> <span class="t-lines"><span>subrange</span></span></a></div> </td> <td> combines an iterator-sentinel pair into a <a href="../ranges/view" title="cpp/ranges/View"><code>View</code></a> <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Dangling_iterator_handling">  Dangling iterator handling </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/dangling" title="cpp/ranges/dangling"> <span class="t-lines"><span>dangling</span></span></a></div> </td> <td> a placeholder type indicating that an iterator or a <code>subrange</code> should not be returned since it would be dangling <br> <span class="t-mark">(class)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/safe_iterator_t" title="cpp/ranges/safe iterator t"> <span class="t-lines"><span>safe_iterator_t</span><span>safe_subrange_t</span></span></a></div> </td> <td> obtains iterator type or <code>subrange</code> type of a <a href="../ranges/range" title="cpp/ranges/Range"><code>Range</code></a> which also models <a href="../ranges/range" title="cpp/ranges/Range"><code>__ForwardingRange</code></a> <br> <span class="t-mark">(alias template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Factories">  Factories </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/empty_view" title="cpp/ranges/empty view"> <span class="t-lines"><span>empty_view</span><span>view::empty</span></span></a></div> </td> <td> an empty <a href="../ranges/view" title="cpp/ranges/View"><code>View</code></a> with no elements <br> <span class="t-mark">(class template)</span> <span class="t-mark">(variable template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/single_view&amp;action=edit&amp;redlink=1" class="new" title="cpp/ranges/single view（页面不存在）"> <span class="t-lines"><span>single_view</span><span>view::single</span></span></a></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/View"><code>View</code></a> that contains a single element of a specified value <br> <span class="t-mark">(class template)</span> <span class="t-mark">(customization point object)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/iota_view" title="cpp/ranges/iota view"> <span class="t-lines"><span>iota_view</span><span>view::iota</span></span></a></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/View"><code>View</code></a> consisting of a sequence generated by repeatedly incrementing an initial value <br> <span class="t-mark">(class template)</span> <span class="t-mark">(customization point object)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/view_counted" title="cpp/ranges/view counted"> <span class="t-lines"><span>view::counted</span></span></a></div> </td> <td> creates a subrange from an iterator and a count <br> <span class="t-mark">(customization point object)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Adaptors">  Adaptors </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/all_view" title="cpp/ranges/all view"> <span class="t-lines"><span>all_view</span><span>view::all</span></span></a></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/View"><code>View</code></a> that includes all elements of a <a href="../ranges/range" title="cpp/ranges/Range"><code>Range</code></a> <br> <span class="t-mark">(alias template)</span> <span class="t-mark">(range adaptor object)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/ref_view" title="cpp/ranges/ref view"> <span class="t-lines"><span>ref_view</span></span></a></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/View"><code>View</code></a> of the elements of some other <a href="../ranges/range" title="cpp/ranges/Range"><code>Range</code></a> <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/filter_view" title="cpp/ranges/filter view"> <span class="t-lines"><span>filter_view</span><span>view::filter</span></span></a></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/View"><code>View</code></a> that consists of the elements of a <a href="../ranges/range" title="cpp/ranges/Range"><code>Range</code></a> that satisfies a predicate <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/transform_view&amp;action=edit&amp;redlink=1" class="new" title="cpp/ranges/transform view（页面不存在）"> <span class="t-lines"><span>transform_view</span><span>view::transform</span></span></a></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/View"><code>View</code></a> of a sequence that applies a transformation function to each element <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/take_view&amp;action=edit&amp;redlink=1" class="new" title="cpp/ranges/take view（页面不存在）"> <span class="t-lines"><span>take_view</span><span>view::take</span></span></a></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/View"><code>View</code></a> consisting of the first N elements of another <a href="../ranges/view" title="cpp/ranges/View"><code>View</code></a> <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/join_view&amp;action=edit&amp;redlink=1" class="new" title="cpp/ranges/join view（页面不存在）"> <span class="t-lines"><span>join_view</span><span>view::join</span></span></a></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/View"><code>View</code></a> consisting of the sequence obtained from flattening a <a href="../ranges/view" title="cpp/ranges/View"><code>View</code></a> of <a href="../ranges/range" title="cpp/ranges/Range"><code>Range</code>s</a> <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/split_view&amp;action=edit&amp;redlink=1" class="new" title="cpp/ranges/split view（页面不存在）"> <span class="t-lines"><span>split_view</span><span>view::split</span></span></a></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/View"><code>View</code></a> over the subranges obtained from splitting another <a href="../ranges/view" title="cpp/ranges/View"><code>View</code></a> using a delimiter <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/common_view&amp;action=edit&amp;redlink=1" class="new" title="cpp/ranges/common view（页面不存在）"> <span class="t-lines"><span>common_view</span><span>view::common</span></span></a></div> </td> <td> converts a <a href="../ranges/view" title="cpp/ranges/View"><code>View</code></a> into a <a href="../ranges/commonrange" title="cpp/ranges/CommonRange"><code>CommonRange</code></a> <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/reverse_view" title="cpp/ranges/reverse view"> <span class="t-lines"><span>reverse_view</span><span>view::reverse</span></span></a></div> </td> <td> a <a href="../ranges/view" title="cpp/ranges/View"><code>View</code></a> that iterates over the elements of another bidirectional view in reverse order <br> <span class="t-mark">(class template)</span> <span class="t-mark">(range adaptor object)</span> </td>
</tr> <tr> <td colspan="2"> <h3 id="Customization_point_objects">  Customization point objects</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Range_access">  Range access </h5> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="../ranges/begin" title="cpp/ranges/begin"> <span class="t-lines"><span>begin</span><span>cbegin</span></span></a></div> </td> <td> returns an iterator to the beginning of a range <br> <span class="t-mark">(customization point object)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/end&amp;action=edit&amp;redlink=1" class="new" title="cpp/ranges/end（页面不存在）"> <span class="t-lines"><span>end</span><span>cend</span></span></a></div> </td> <td> returns an iterator to the end of a range <br> <span class="t-mark">(customization point object)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/rbegin&amp;action=edit&amp;redlink=1" class="new" title="cpp/ranges/rbegin（页面不存在）"> <span class="t-lines"><span>rbegin</span><span>crbegin</span></span></a></div> </td> <td> returns a reverse iterator to a range <br> <span class="t-mark">(customization point object)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/rend&amp;action=edit&amp;redlink=1" class="new" title="cpp/ranges/rend（页面不存在）"> <span class="t-lines"><span>rend</span><span>crend</span></span></a></div> </td> <td> returns a reverse end iterator to a range <br> <span class="t-mark">(customization point object)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/size&amp;action=edit&amp;redlink=1" class="new" title="cpp/ranges/size（页面不存在）"> <span class="t-lines"><span>size</span></span></a></div> </td> <td> obtains the size of a range whose size can be calculated in constant time <br> <span class="t-mark">(customization point object)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/empty&amp;action=edit&amp;redlink=1" class="new" title="cpp/ranges/empty（页面不存在）"> <span class="t-lines"><span>empty</span></span></a></div> </td> <td> checks whether a range is empty <br> <span class="t-mark">(customization point object)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/data&amp;action=edit&amp;redlink=1" class="new" title="cpp/ranges/data（页面不存在）"> <span class="t-lines"><span>data</span><span>cdata</span></span></a></div> </td> <td> obtains a pointer to the beginning of a contiguous range <br> <span class="t-mark">(customization point object)</span> </td>
</tr> </table> <h3 id="Synopsis">Synopsis</h3> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;initializer_list&gt;
#include &lt;iterator&gt;
 
namespace std::ranges {
  inline namespace /* unspecified */ {
    // range access
    inline constexpr /* unspecified */ begin = /* unspecified */;
    inline constexpr /* unspecified */ end = /* unspecified */;
    inline constexpr /* unspecified */ cbegin = /* unspecified */;
    inline constexpr /* unspecified */ cend = /* unspecified */;
    inline constexpr /* unspecified */ rbegin = /* unspecified */;
    inline constexpr /* unspecified */ rend = /* unspecified */;
    inline constexpr /* unspecified */ crbegin = /* unspecified */;
    inline constexpr /* unspecified */ crend = /* unspecified */;
 
    inline constexpr /* unspecified */ size = /* unspecified */;
    inline constexpr /* unspecified */ empty = /* unspecified */;
    inline constexpr /* unspecified */ data = /* unspecified */;
    inline constexpr /* unspecified */ cdata = /* unspecified */;
  }
 
  // ranges
  template&lt;class T&gt;
    using iterator_t = decltype(ranges::begin(declval&lt;T&amp;&gt;()));
 
  template&lt;class T&gt;
    using sentinel_t = decltype(ranges::end(declval&lt;T&amp;&gt;()));
 
  template&lt;class T&gt;
    concept Range = /* see definition */;
 
  // sized ranges
  template&lt;class&gt;
    inline constexpr bool disable_sized_range = false;
 
  template&lt;class T&gt;
    concept SizedRange = /* see definition */;
 
  // views
  template&lt;class T&gt;
    inline constexpr bool enable_view = /* see definition */;
 
  struct view_base { };
 
  template&lt;class T&gt;
    concept View = /* see definition */;
 
  // other range refinements
  template&lt;class R, class T&gt;
    concept OutputRange = /* see definition */;
 
  template&lt;class T&gt;
    concept InputRange = /* see definition */;
 
  template&lt;class T&gt;
    concept ForwardRange = /* see definition */;
 
  template&lt;class T&gt;
    concept BidirectionalRange = /* see definition */;
 
  template&lt;class T&gt;
    concept RandomAccessRange = /* see definition */;
 
  template&lt;class T&gt;
    concept ContiguousRange = /* see definition */;
 
  template&lt;class T&gt;
    concept CommonRange = /* see definition */;
 
  template&lt;class T&gt;
    concept ViewableRange = /* see definition */;
 
  // class template view_interface
  template&lt;class D&gt;
    requires is_class_v&lt;D&gt; &amp;&amp; Same&lt;D, remove_cv_t&lt;D&gt;&gt;
  class view_interface;
 
  // sub-ranges
  enum class subrange_kind : bool { unsized, sized };
 
  template&lt;Iterator I, Sentinel&lt;I&gt; S = I, subrange_kind K = /* see definition */&gt;
    requires (K == subrange_kind::sized || !SizedSentinel&lt;S, I&gt;)
  class subrange;
 
  // dangling iterator handling
  struct dangling;
 
  template&lt;Range R&gt;
    using safe_iterator_t = conditional_t&lt;__ForwardingRange&lt;R&gt;, iterator_t&lt;R&gt;, dangling&gt;;
 
  template&lt;Range R&gt;
    using safe_subrange_t =
      conditional_t&lt;__ForwardingRange&lt;R&gt;, subrange&lt;iterator_t&lt;R&gt;&gt;, dangling&gt;;
 
  // empty view
  template&lt;class T&gt;
    requires is_object_v&lt;T&gt;
  class empty_view;
 
  namespace view {
    template&lt;class T&gt;
      inline constexpr empty_view&lt;T&gt; empty{};
  }
 
  // single view
  template&lt;CopyConstructible T&gt;
    requires is_object_v&lt;T&gt;
  class single_view;
 
  namespace view { inline constexpr /* unspecified */ single = /* unspecified */; }
 
  // iota view
  template&lt;WeaklyIncrementable W, Semiregular Bound = unreachable_sentinel_t&gt;
    requires __WeaklyEqualityComparableWith&lt;W, Bound&gt;
  class iota_view;
 
  namespace view { inline constexpr /* unspecified */ iota = /* unspecified */; }
 
  // all view
  namespace view { inline constexpr /* unspecified */ all = /* unspecified */; }
 
  template&lt;ViewableRange R&gt;
    using all_view = decltype(view::all(declval&lt;R&gt;()));
 
  template&lt;Range R&gt;
    requires is_object_v&lt;R&gt;
  class ref_view;
 
  // filter view
  template&lt;InputRange V, IndirectUnaryPredicate&lt;iterator_t&lt;V&gt;&gt; Pred&gt;
    requires View&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class filter_view;
 
  namespace view { inline constexpr /* unspecified */ filter = /* unspecified */; }
 
  // transform view
  template&lt;InputRange V, CopyConstructible F&gt;
    requires View&lt;V&gt; &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             RegularInvocable&lt;F&amp;, iter_reference_t&lt;iterator_t&lt;V&gt;&gt;&gt;
  class transform_view;
 
  namespace view { inline constexpr /* unspecified */ transform = /* unspecified */; }
 
  // take view
  template&lt;View&gt; class take_view;
 
  namespace view { inline constexpr /* unspecified */ take = /* unspecified */; }
 
  // join view
  template&lt;InputRange V&gt;
    requires View&lt;V&gt; &amp;&amp; InputRange&lt;iter_reference_t&lt;iterator_t&lt;V&gt;&gt;&gt; &amp;&amp;
             (is_reference_v&lt;iter_reference_t&lt;iterator_t&lt;V&gt;&gt;&gt; ||
              View&lt;iter_value_t&lt;iterator_t&lt;V&gt;&gt;&gt;)
  class join_view;
 
  namespace view { inline constexpr /* unspecified */ join = /* unspecified */; }
 
  // split view
  template&lt;class R&gt;
    concept __TinyRange = /* see definition */;   // exposition only
 
  template&lt;InputRange V, ForwardRange Pattern&gt;
    requires View&lt;V&gt; &amp;&amp; View&lt;Pattern&gt; &amp;&amp;
             IndirectlyComparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt; &amp;&amp;
             (ForwardRange&lt;V&gt; || __TinyRange&lt;Pattern&gt;)
  class split_view;
 
  namespace view { inline constexpr /* unspecified */ split = /* unspecified */; }
 
  // counted view
  namespace view { inline constexpr /* unspecified */ counted = /* unspecified */; }
 
  // common view
  template&lt;View V&gt;
    requires (!CommonRange&lt;V&gt;)
  class common_view;
 
  namespace view { inline constexpr /* unspecified */ common = /* unspecified */; }
 
  // reverse view
  template&lt;View V&gt;
    requires BidirectionalRange&lt;V&gt;
  class reverse_view;
 
  namespace view { inline constexpr /* unspecified */ reverse = /* unspecified */; }
}
 
namespace std {
  namespace view = ranges::view;
 
  template&lt;class I, class S, ranges::subrange_kind K&gt;
  struct tuple_size&lt;ranges::subrange&lt;I, S, K&gt;&gt;
    : integral_constant&lt;size_t, 2&gt; {};
  template&lt;class I, class S, ranges::subrange_kind K&gt;
  struct tuple_element&lt;0, ranges::subrange&lt;I, S, K&gt;&gt; {
    using type = I;
  };
  template&lt;class I, class S, ranges::subrange_kind K&gt;
  struct tuple_element&lt;1, ranges::subrange&lt;I, S, K&gt;&gt; {
    using type = S;
  };
}</pre></div> <h4 id="Concept_Range">Concept <a href="../ranges/range" title="cpp/ranges/Range"><code>Range</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept __RangeImpl =          // exposition only
      requires(T&amp;&amp; t) {
        ranges::begin(std::forward&lt;T&gt;(t));// sometimes equality-preserving (see definition)
        ranges::end(std::forward&lt;T&gt;(t));
      };
 
  template&lt;class T&gt;
    concept Range = __RangeImpl&lt;T&amp;&gt;;
 
  template&lt;class T&gt;
    concept __ForwardingRange =    // exposition only
      Range&lt;T&gt; &amp;&amp; __RangeImpl&lt;T&gt;;
}</pre></div> <h4 id="Concept_SizedRange">Concept <a href="../ranges/sizedrange" title="cpp/ranges/SizedRange"><code>SizedRange</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept SizedRange =
      Range&lt;T&gt; &amp;&amp;
      !disable_sized_range&lt;remove_cvref_t&lt;T&gt;&gt; &amp;&amp;
      requires(T&amp; t) { ranges::size(t); };
}</pre></div> <h4 id="Concept_View">Concept <a href="../ranges/view" title="cpp/ranges/View"><code>View</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    inline constexpr bool enable_view = /* see definition */;
 
  template&lt;class T&gt;
    concept View =
      Range&lt;T&gt; &amp;&amp; Semiregular&lt;T&gt; &amp;&amp; enable_view&lt;T&gt;;
}</pre></div> <h4 id="Concept_OutputRange">Concept <a href="../ranges/outputrange" title="cpp/ranges/OutputRange"><code>OutputRange</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class R, class T&gt;
    concept OutputRange =
      Range&lt;R&gt; &amp;&amp; OutputIterator&lt;iterator_t&lt;R&gt;, T&gt;;
}</pre></div> <h4 id="Concept_InputRange">Concept <a href="../ranges/inputrange" title="cpp/ranges/InputRange"><code>InputRange</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept InputRange =
      Range&lt;T&gt; &amp;&amp; InputIterator&lt;iterator_t&lt;T&gt;&gt;;
}</pre></div> <h4 id="Concept_ForwardRange">Concept <a href="../ranges/forwardrange" title="cpp/ranges/ForwardRange"><code>ForwardRange</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept ForwardRange =
      InputRange&lt;T&gt; &amp;&amp; ForwardIterator&lt;iterator_t&lt;T&gt;&gt;;
}</pre></div> <h4 id="Concept_BidirectionalRange">Concept <a href="../ranges/bidirectionalrange" title="cpp/ranges/BidirectionalRange"><code>BidirectionalRange</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept BidirectionalRange =
      ForwardRange&lt;T&gt; &amp;&amp; BidirectionalIterator&lt;iterator_t&lt;T&gt;&gt;;
}</pre></div> <h4 id="Concept_RandomAccessRange">Concept <a href="../ranges/randomaccessrange" title="cpp/ranges/RandomAccessRange"><code>RandomAccessRange</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept RandomAccessRange =
      BidirectionalRange&lt;T&gt; &amp;&amp; RandomAccessIterator&lt;iterator_t&lt;T&gt;&gt;;
}</pre></div> <h4 id="Concept_ContiguousRange">Concept <a href="../ranges/contiguousrange" title="cpp/ranges/ContiguousRange"><code>ContiguousRange</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept ContiguousRange =
     RandomAccessRange&lt;T&gt; &amp;&amp; ContiguousIterator&lt;iterator_t&lt;T&gt;&gt; &amp;&amp;
      requires(T&amp; t) {
        { ranges::data(t) } -&gt; Same&lt;add_pointer_t&lt;iter_reference_t&lt;iterator_t&lt;T&gt;&gt;&gt;&gt;;
      };
}</pre></div> <h4 id="Concept_CommonRange">Concept <a href="../ranges/commonrange" title="cpp/ranges/CommonRange"><code>CommonRange</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept CommonRange =
      Range&lt;T&gt; &amp;&amp; Same&lt;iterator_t&lt;T&gt;, sentinel_t&lt;T&gt;&gt;;
}</pre></div> <h4 id="Concept_ViewableRange">Concept <a href="../ranges/viewablerange" title="cpp/ranges/ViewableRange"><code>ViewableRange</code></a>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept ViewableRange =
      Range&lt;T&gt; &amp;&amp; (__ForwardingRange&lt;T&gt; || View&lt;decay_t&lt;T&gt;&gt;);
}</pre></div> <h4 id="Helper_concepts">Helper concepts</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges { // unspecified, for name lookup only
  template&lt;class R&gt;
    concept __SimpleView =                        // exposition only
      View&lt;R&gt; &amp;&amp; Range&lt;const R&gt; &amp;&amp;
      Same&lt;iterator_t&lt;R&gt;, iterator_t&lt;const R&gt;&gt; &amp;&amp;
      Same&lt;sentinel_t&lt;R&gt;, sentinel_t&lt;const R&gt;&gt;;
 
  template&lt;InputIterator I&gt;
    concept __HasArrow =                          // exposition only
      is_pointer_v&lt;I&gt; || requires(I i) { i.operator-&gt;(); };
 
  template&lt;class T, class U&gt;
    concept __NotSameAs =                         // exposition only
      !Same&lt;remove_cvref_t&lt;T&gt;, remove_cvref_t&lt;U&gt;&gt;;
 
  template&lt;class I&gt;
    concept _Decrementable =                      // exposition only
      Incrementable&lt;I&gt; &amp;&amp; requires(I i) {
        { --i } -&gt; Same&lt;I&amp;&gt;;
        { i-- } -&gt; Same&lt;I&gt;;
      };
 
  template&lt;class I&gt;
    concept _Advanceable =                        // exposition only
      _Decrementable&lt;I&gt; &amp;&amp; StrictTotallyOrdered&lt;I&gt; &amp;&amp;
      requires(I i, const I j, const iter_difference_t&lt;I&gt; n) {
        { i += n } -&gt; Same&lt;I&amp;&gt;;
        { i -= n } -&gt; Same&lt;I&amp;&gt;;
        { j +  n } -&gt; Same&lt;I&gt;;
        { n +  j } -&gt; Same&lt;I&gt;;
        { j -  n } -&gt; Same&lt;I&gt;;
        { j -  j } -&gt; Same&lt;iter_difference_t&lt;I&gt;&gt;;
      };
}</pre></div> <p>Note: These names are only for exposition, they are not part of the interface.</p>
<h4 id="Class_template_std::ranges::view_interface">Class template <code>std::ranges::view_interface</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class D&gt;
    requires is_class_v&lt;D&gt; &amp;&amp; Same&lt;D, remove_cv_t&lt;D&gt;&gt;
  class view_interface : public view_base {
  private:
    constexpr D&amp; derived() noexcept {                   // exposition only
      return static_cast&lt;D&amp;&gt;(*this);
    }
    constexpr const D&amp; derived() const noexcept {       // exposition only
      return static_cast&lt;const D&amp;&gt;(*this);
    }
  public:
    constexpr bool empty() requires ForwardRange&lt;D&gt; {
      return ranges::begin(derived()) == ranges::end(derived());
    }
    constexpr bool empty() const requires ForwardRange&lt;const D&gt; {
      return ranges::begin(derived()) == ranges::end(derived());
    }
 
    constexpr explicit operator bool()
      requires requires { ranges::empty(derived()); } {
        return !ranges::empty(derived());
      }
    constexpr explicit operator bool() const
      requires requires { ranges::empty(derived()); } {
        return !ranges::empty(derived());
      }
 
    constexpr auto data() requires ContiguousIterator&lt;iterator_t&lt;D&gt;&gt; {
      return ranges::empty(derived()) ? nullptr : addressof(*ranges::begin(derived()));
    }
    constexpr auto data() const
      requires Range&lt;const D&gt; &amp;&amp; ContiguousIterator&lt;iterator_t&lt;const D&gt;&gt; {
        return ranges::empty(derived()) ? nullptr : addressof(*ranges::begin(derived()));
      }
 
    constexpr auto size() requires ForwardRange&lt;D&gt; &amp;&amp;
      SizedSentinel&lt;sentinel_t&lt;D&gt;, iterator_t&lt;D&gt;&gt; {
        return ranges::end(derived()) - ranges::begin(derived());
      }
    constexpr auto size() const requires ForwardRange&lt;const D&gt; &amp;&amp;
      SizedSentinel&lt;sentinel_t&lt;const D&gt;, iterator_t&lt;const D&gt;&gt; {
        return ranges::end(derived()) - ranges::begin(derived());
      }
 
    constexpr decltype(auto) front() requires ForwardRange&lt;D&gt;;
    constexpr decltype(auto) front() const requires ForwardRange&lt;const D&gt;;
 
    constexpr decltype(auto) back() requires BidirectionalRange&lt;D&gt; &amp;&amp; CommonRange&lt;D&gt;;
    constexpr decltype(auto) back() const
      requires BidirectionalRange&lt;const D&gt; &amp;&amp; CommonRange&lt;const D&gt;;
 
    template&lt;RandomAccessRange R = D&gt;
      constexpr decltype(auto) operator[](iter_difference_t&lt;iterator_t&lt;R&gt;&gt; n) {
        return ranges::begin(derived())[n];
      }
    template&lt;RandomAccessRange R = const D&gt;
      constexpr decltype(auto) operator[](iter_difference_t&lt;iterator_t&lt;R&gt;&gt; n) const {
        return ranges::begin(derived())[n];
      }
  };
}</pre></div> <h4 id="Class_template_std::ranges::subrange">Class template <code>std::ranges::subrange</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    concept __PairLike =                                // exposition only
      !is_reference_v&lt;T&gt; &amp;&amp; requires(T t) {
        typename tuple_size&lt;T&gt;::type;   // ensures tuple_­size&lt;T&gt; is complete
        requires DerivedFrom&lt;tuple_size&lt;T&gt;, integral_constant&lt;size_t, 2&gt;&gt;;
        typename tuple_element_t&lt;0, remove_const_t&lt;T&gt;&gt;;
        typename tuple_element_t&lt;1, remove_const_t&lt;T&gt;&gt;;
        { get&lt;0&gt;(t) } -&gt; const tuple_element_t&lt;0, T&gt;&amp;;
        { get&lt;1&gt;(t) } -&gt; const tuple_element_t&lt;1, T&gt;&amp;;
      };
 
  template&lt;class T, class U, class V&gt;
    concept __PairLikeConvertibleTo =                   // exposition only
      !Range&lt;T&gt; &amp;&amp; __PairLike&lt;remove_reference_t&lt;T&gt;&gt; &amp;&amp;
      requires(T&amp;&amp; t) {
        { get&lt;0&gt;(std::forward&lt;T&gt;(t)) } -&gt; ConvertibleTo&lt;U&gt;;
        { get&lt;1&gt;(std::forward&lt;T&gt;(t)) } -&gt; ConvertibleTo&lt;V&gt;;
      };
 
  template&lt;class T, class U, class V&gt;
    concept __PairLikeConvertibleFrom =                 // exposition only
      !Range&lt;T&gt; &amp;&amp; __PairLike&lt;T&gt; &amp;&amp; Constructible&lt;T, U, V&gt;;
 
  template&lt;class T&gt;
    concept __IteratorSentinelPair =                    // exposition only
      !Range&lt;T&gt; &amp;&amp; __PairLike&lt;T&gt; &amp;&amp;
      Sentinel&lt;tuple_element_t&lt;1, T&gt;, tuple_element_t&lt;0, T&gt;&gt;;
 
  template&lt;Iterator I, Sentinel&lt;I&gt; S = I, subrange_kind K =
      SizedSentinel&lt;S, I&gt; ? subrange_kind::sized : subrange_kind::unsized&gt;
    requires (K == subrange_kind::sized || !SizedSentinel&lt;S, I&gt;)
  class subrange : public view_interface&lt;subrange&lt;I, S, K&gt;&gt; {
  private:
    static constexpr bool StoreSize =                   // exposition only
      K == subrange_kind::sized &amp;&amp; !SizedSentinel&lt;S, I&gt;;
    I begin_ = I();                                     // exposition only
    S end_ = S();                                       // exposition only
    iter_difference_t&lt;I&gt; size_ = 0;                     // exposition only; present only
                                                        // when StoreSize is true
  public:
    subrange() = default;
 
    constexpr subrange(I i, S s) requires (!StoreSize);
 
    constexpr subrange(I i, S s, iter_difference_t&lt;I&gt; n)
      requires (K == subrange_kind::sized);
 
    template&lt;__NotSameAs&lt;subrange&gt; R&gt;
      requires __ForwardingRange&lt;R&gt; &amp;&amp;
        ConvertibleTo&lt;iterator_t&lt;R&gt;, I&gt; &amp;&amp; ConvertibleTo&lt;sentinel_t&lt;R&gt;, S&gt;
    constexpr subrange(R&amp;&amp; r) requires (!StoreSize || SizedRange&lt;R&gt;);
 
    template&lt;__ForwardingRange R&gt;
      requires ConvertibleTo&lt;iterator_t&lt;R&gt;, I&gt; &amp;&amp; ConvertibleTo&lt;sentinel_t&lt;R&gt;, S&gt;
    constexpr subrange(R&amp;&amp; r, iter_difference_t&lt;I&gt; n)
      requires (K == subrange_kind::sized)
        : subrange{ranges::begin(r), ranges::end(r), n}
    {}
 
    template&lt;__NotSameAs&lt;subrange&gt; PairLike&gt;
      requires __PairLikeConvertibleTo&lt;PairLike, I, S&gt;
    constexpr subrange(PairLike&amp;&amp; r) requires (!StoreSize)
      : subrange{std::get&lt;0&gt;(std::forward&lt;PairLike&gt;(r)),
                 std::get&lt;1&gt;(std::forward&lt;PairLike&gt;(r))}
    {}
 
    template&lt;__PairLikeConvertibleTo&lt;I, S&gt; PairLike&gt;
    constexpr subrange(PairLike&amp;&amp; r, iter_difference_t&lt;I&gt; n)
      requires (K == subrange_kind::sized)
      : subrange{std::get&lt;0&gt;(std::forward&lt;PairLike&gt;(r)),
                 std::get&lt;1&gt;(std::forward&lt;PairLike&gt;(r)), n}
    {}
 
    template&lt;__NotSameAs&lt;subrange&gt; PairLike&gt;
      requires __PairLikeConvertibleFrom&lt;PairLike, const I&amp;, const S&amp;&gt;
    constexpr operator PairLike() const;
 
    constexpr I begin() const;
    constexpr S end() const;
 
    constexpr bool empty() const;
    constexpr iter_difference_t&lt;I&gt; size() const
      requires (K == subrange_kind::sized);
 
    [[nodiscard]] constexpr subrange next(iter_difference_t&lt;I&gt; n = 1) const;
    [[nodiscard]] constexpr subrange prev(iter_difference_t&lt;I&gt; n = 1) const
      requires BidirectionalIterator&lt;I&gt;;
    constexpr subrange&amp; advance(iter_difference_t&lt;I&gt; n);
 
    friend constexpr I begin(subrange&amp;&amp; r) { return r.begin(); }
    friend constexpr S end(subrange&amp;&amp; r) { return r.end(); }
  };
 
  template&lt;Iterator I, Sentinel&lt;I&gt; S&gt;
    subrange(I, S, iter_difference_t&lt;I&gt;) -&gt; subrange&lt;I, S, subrange_kind::sized&gt;;
 
  template&lt;__IteratorSentinelPair P&gt;
    subrange(P) -&gt; subrange&lt;tuple_element_t&lt;0, P&gt;, tuple_element_t&lt;1, P&gt;&gt;;
 
  template&lt;__IteratorSentinelPair P&gt;
    subrange(P, iter_difference_t&lt;tuple_element_t&lt;0, P&gt;&gt;) -&gt;
      subrange&lt;tuple_element_t&lt;0, P&gt;, tuple_element_t&lt;1, P&gt;, subrange_kind::sized&gt;;
 
  template&lt;__ForwardingRange R&gt;
    subrange(R&amp;&amp;) -&gt;
      subrange&lt;iterator_t&lt;R&gt;, sentinel_t&lt;R&gt;,
               (SizedRange&lt;R&gt; || SizedSentinel&lt;sentinel_t&lt;R&gt;, iterator_t&lt;R&gt;&gt;)
                 ? subrange_kind::sized : subrange_kind::unsized&gt;;
 
  template&lt;__ForwardingRange R&gt;
    subrange(R&amp;&amp;, iter_difference_t&lt;iterator_t&lt;R&gt;&gt;) -&gt;
      subrange&lt;iterator_t&lt;R&gt;, sentinel_t&lt;R&gt;, subrange_kind::sized&gt;;
 
  template&lt;size_t N, class I, class S, subrange_kind K&gt;
    requires (N &lt; 2)
  constexpr auto get(const subrange&lt;I, S, K&gt;&amp; r);
}
 
namespace std {
  using ranges::get;
}</pre></div> <h4 id="Class_std::ranges::dangling">Class <code>std::ranges::dangling</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  struct dangling {
    constexpr dangling() noexcept = default;
    template&lt;class... Args&gt;
      constexpr dangling(Args&amp;&amp;...) noexcept { }
  };
}</pre></div> <h4 id="Class_template_std::ranges::empty_view">Class template <code>std::ranges::empty_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class T&gt;
    requires is_object_v&lt;T&gt;
  class empty_view : public view_interface&lt;empty_view&lt;T&gt;&gt; {
  public:
    static constexpr T* begin() noexcept { return nullptr; }
    static constexpr T* end() noexcept { return nullptr; }
    static constexpr T* data() noexcept { return nullptr; }
    static constexpr ptrdiff_t size() noexcept { return 0; }
    static constexpr bool empty() noexcept { return true; }
 
    friend constexpr T* begin(empty_view) noexcept { return nullptr; }
    friend constexpr T* end(empty_view) noexcept { return nullptr; }
  };
}</pre></div> <h4 id="Class_template_std::ranges::empty_view_2">Class template <code>std::ranges::empty_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;CopyConstructible T&gt;
    requires is_object_v&lt;T&gt;
  class single_view : public view_interface&lt;single_view&lt;T&gt;&gt; {
  private:
    semiregular&lt;T&gt; value_;      // exposition only
  public:
    single_view() = default;
    constexpr explicit single_view(const T&amp; t);
    constexpr explicit single_view(T&amp;&amp; t);
    template&lt;class... Args&gt;
      requires Constructible&lt;T, Args...&gt;
    constexpr single_view(in_place_t, Args&amp;&amp;... args);
 
    constexpr T* begin() noexcept;
    constexpr const T* begin() const noexcept;
    constexpr T* end() noexcept;
    constexpr const T* end() const noexcept;
    static constexpr ptrdiff_t size() noexcept;
    constexpr T* data() noexcept;
    constexpr const T* data() const noexcept;
  };
}</pre></div> <h4 id="Class_template_std::ranges::iota_view">Class template <code>std::ranges::iota_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class I&gt;
    concept _Decrementable =    // exposition only
      /* see definition */;
  template&lt;class I&gt;
    concept _Advanceable =      // exposition only
      /* see definition */;
 
  template&lt;WeaklyIncrementable W, Semiregular Bound = unreachable_sentinel_t&gt;
    requires __WeaklyEqualityComparableWith&lt;W, Bound&gt;
  class iota_view : public view_interface&lt;iota_view&lt;W, Bound&gt;&gt; {
  private:
    // class iota_­view​::​iterator
    struct iterator;            // exposition only
    // class iota_­view​::​sentinel
    struct sentinel;            // exposition only
    W value_ = W();             // exposition only
    Bound bound_ = Bound();     // exposition only
  public:
    iota_view() = default;
    constexpr explicit iota_view(W value);
    constexpr iota_view(type_identity_t&lt;W&gt; value,
                        type_identity_t&lt;Bound&gt; bound);
 
    constexpr iterator begin() const;
    constexpr sentinel end() const;
    constexpr iterator end() const requires Same&lt;W, Bound&gt;;
 
    constexpr auto size() const
      requires (Same&lt;W, Bound&gt; &amp;&amp; _Advanceable&lt;W&gt;) ||
               (Integral&lt;W&gt; &amp;&amp; Integral&lt;Bound&gt;) ||
               SizedSentinel&lt;Bound, W&gt;
    { return bound_ - value_; }
  };
 
  template&lt;class W, class Bound&gt;
    requires (!Integral&lt;W&gt; || !Integral&lt;Bound&gt; || is_signed_v&lt;W&gt; == is_signed_v&lt;Bound&gt;)
  iota_view(W, Bound) -&gt; iota_view&lt;W, Bound&gt;;
}</pre></div> <h4 id="Class_std::ranges::iota_view::iterator">Class <code>std::ranges::iota_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class W, class Bound&gt;
  struct iota_view&lt;W, Bound&gt;::iterator {
  private:
    W value_ = W();             // exposition only
  public:
    using iterator_category = /* see definition */;
    using value_type = W;
    using difference_type = iter_difference_t&lt;W&gt;;
 
    iterator() = default;
    constexpr explicit iterator(W value);
 
    constexpr W operator*() const noexcept(is_nothrow_copy_constructible_v&lt;W&gt;);
 
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires Incrementable&lt;W&gt;;
 
    constexpr iterator&amp; operator--() requires _Decrementable&lt;W&gt;;
    constexpr iterator operator--(int) requires _Decrementable&lt;W&gt;;
 
    constexpr iterator&amp; operator+=(difference_type n)
      requires _Advanceable&lt;W&gt;;
    constexpr iterator&amp; operator-=(difference_type n)
      requires _Advanceable&lt;W&gt;;
    constexpr W operator[](difference_type n) const
      requires _Advanceable&lt;W&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
      requires EqualityComparable&lt;W&gt;;
    friend constexpr bool operator!=(const iterator&amp; x, const iterator&amp; y)
      requires EqualityComparable&lt;W&gt;;
 
    friend constexpr bool operator&lt;(const iterator&amp; x, const iterator&amp; y)
      requires StrictTotallyOrdered&lt;W&gt;;
    friend constexpr bool operator&gt;(const iterator&amp; x, const iterator&amp; y)
      requires StrictTotallyOrdered&lt;W&gt;;
    friend constexpr bool operator&lt;=(const iterator&amp; x, const iterator&amp; y)
      requires StrictTotallyOrdered&lt;W&gt;;
    friend constexpr bool operator&gt;=(const iterator&amp; x, const iterator&amp; y)
      requires StrictTotallyOrdered&lt;W&gt;;
 
    friend constexpr iterator operator+(iterator i, difference_type n)
      requires _Advanceable&lt;W&gt;;
    friend constexpr iterator operator+(difference_type n, iterator i)
      requires _Advanceable&lt;W&gt;;
 
    friend constexpr iterator operator-(iterator i, difference_type n)
      requires _Advanceable&lt;W&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires _Advanceable&lt;W&gt;;
  };
}</pre></div> <h4 id="Class_std::ranges::iota_view::sentinel">Class <code>std::ranges::iota_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class W, class Bound&gt;
  struct iota_view&lt;W, Bound&gt;::sentinel {
  private:
    Bound bound_ = Bound();     // exposition only
  public:
    sentinel() = default;
    constexpr explicit sentinel(Bound bound);
 
    friend constexpr bool operator==(const iterator&amp; x, const sentinel&amp; y);
    friend constexpr bool operator==(const sentinel&amp; x, const iterator&amp; y);
    friend constexpr bool operator!=(const iterator&amp; x, const sentinel&amp; y);
    friend constexpr bool operator!=(const sentinel&amp; x, const iterator&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::ref_view">Class template <code>std::ranges::ref_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;Range R&gt;
    requires is_object_v&lt;R&gt;
  class ref_view : public view_interface&lt;ref_view&lt;R&gt;&gt; {
  private:
    R* r_ = nullptr;            // exposition only
  public:
    constexpr ref_view() noexcept = default;
 
    template&lt;__NotSameAs&lt;ref_view&gt; T&gt;
      requires /* see definition */
    constexpr ref_view(T&amp;&amp; t);
 
    constexpr R&amp; base() const { return *r_; }
 
    constexpr iterator_t&lt;R&gt; begin() const { return ranges::begin(*r_); }
    constexpr sentinel_t&lt;R&gt; end() const { return ranges::end(*r_); }
 
    constexpr bool empty() const
      requires requires { ranges::empty(*r_); }
    { return ranges::empty(*r_); }
 
    constexpr auto size() const requires SizedRange&lt;R&gt;
    { return ranges::size(*r_); }
 
    constexpr auto data() const requires ContiguousRange&lt;R&gt;
    { return ranges::data(*r_); }
 
    friend constexpr iterator_t&lt;R&gt; begin(ref_view r)
    { return r.begin(); }
 
    friend constexpr sentinel_t&lt;R&gt; end(ref_view r)
    { return r.end(); }
  };
  template&lt;class R&gt;
    ref_view(R&amp;) -&gt; ref_view&lt;R&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::filter_view">Class template <code>std::ranges::filter_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;InputRange V, IndirectUnaryPredicate&lt;iterator_t&lt;V&gt;&gt; Pred&gt;
    requires View&lt;V&gt; &amp;&amp; is_object_v&lt;Pred&gt;
  class filter_view : public view_interface&lt;filter_view&lt;V, Pred&gt;&gt; {
  private:
    V base_ = V();              // exposition only
    semiregular&lt;Pred&gt; pred_;    // exposition only
 
    // class filter_view​::​iterator
    class iterator;             // exposition only
    // class filter_view​::​sentinel
    class sentinel;             // exposition only
 
  public:
    filter_view() = default;
    constexpr filter_view(V base, Pred pred);
    template&lt;InputRange R&gt;
      requires ViewableRange&lt;R&gt; &amp;&amp; Constructible&lt;V, all_view&lt;R&gt;&gt;
    constexpr filter_view(R&amp;&amp; r, Pred pred);
 
    constexpr V base() const;
 
    constexpr iterator begin();
    constexpr auto end() {
      if constexpr (CommonRange&lt;V&gt;)
        return iterator{*this, ranges::end(base_)};
      else
        return sentinel{*this};
    }
  };
 
  template&lt;class R, class Pred&gt;
    filter_view(R&amp;&amp;, Pred) -&gt; filter_view&lt;all_view&lt;R&gt;, Pred&gt;;
}</pre></div> <h4 id="Class_std::ranges::filter_view::iterator">Class <code>std::ranges::filter_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class V, class Pred&gt;
  class filter_view&lt;V, Pred&gt;::iterator {
  private:
    iterator_t&lt;V&gt; current_ = iterator_t&lt;V&gt;();   // exposition only
    filter_view* parent_ = nullptr;             // exposition only
  public:
    using iterator_concept  = /* see definition */;
    using iterator_category = /* see definition */;
    using value_type        = iter_value_t&lt;iterator_t&lt;V&gt;&gt;;
    using difference_type   = iter_difference_t&lt;iterator_t&lt;V&gt;&gt;;
 
    iterator() = default;
    constexpr iterator(filter_view&amp; parent, iterator_t&lt;V&gt; current);
 
    constexpr iterator_t&lt;V&gt; base() const;
    constexpr iter_reference_t&lt;iterator_t&lt;V&gt;&gt; operator*() const;
    constexpr iterator_t&lt;V&gt; operator-&gt;() const
      requires has-arrow&lt;iterator_t&lt;V&gt;&gt;;
 
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires ForwardRange&lt;V&gt;;
 
    constexpr iterator&amp; operator--() requires BidirectionalRange&lt;V&gt;;
    constexpr iterator operator--(int) requires BidirectionalRange&lt;V&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
      requires EqualityComparable&lt;iterator_t&lt;V&gt;&gt;;
    friend constexpr bool operator!=(const iterator&amp; x, const iterator&amp; y)
      requires EqualityComparable&lt;iterator_t&lt;V&gt;&gt;;
 
    friend constexpr iter_rvalue_reference_t&lt;iterator_t&lt;V&gt;&gt; iter_move(const iterator&amp; i)
      noexcept(noexcept(ranges::iter_move(i.current_)));
    friend constexpr void iter_swap(const iterator&amp; x, const iterator&amp; y)
      noexcept(noexcept(ranges::iter_swap(x.current_, y.current_)))
      requires IndirectlySwappable&lt;iterator_t&lt;V&gt;&gt;;
  };
}</pre></div> <h4 id="Class_std::ranges::filter_view::sentinel">Class <code>std::ranges::filter_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class V, class Pred&gt;
  class filter_view&lt;V, Pred&gt;::sentinel {
  private:
    sentinel_t&lt;V&gt; end_ = sentinel_t&lt;V&gt;();       // exposition only
  public:
    sentinel() = default;
    constexpr explicit sentinel(filter_view&amp; parent);
 
    constexpr sentinel_t&lt;V&gt; base() const;
 
    friend constexpr bool operator==(const iterator&amp; x, const sentinel&amp; y);
    friend constexpr bool operator==(const sentinel&amp; x, const iterator&amp; y);
    friend constexpr bool operator!=(const iterator&amp; x, const sentinel&amp; y);
    friend constexpr bool operator!=(const sentinel&amp; x, const iterator&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::transform_view">Class template <code>std::ranges::transform_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;InputRange V, CopyConstructible F&gt;
    requires View&lt;V&gt; &amp;&amp; is_object_v&lt;F&gt; &amp;&amp;
             RegularInvocable&lt;F&amp;, iter_reference_t&lt;iterator_t&lt;V&gt;&gt;&gt;
  class transform_view : public view_interface&lt;transform_view&lt;V, F&gt;&gt; {
  private:
    // class template transform_view​::​iterator
    template&lt;bool&gt; struct iterator;             // exposition only
    // class template transform_view​::​sentinel
    template&lt;bool&gt; struct sentinel;             // exposition only
 
    V base_ = V();                              // exposition only
    semiregular&lt;F&gt; fun_;                        // exposition only
 
  public:
    transform_view() = default;
    constexpr transform_view(V base, F fun);
    template&lt;InputRange R&gt;
      requires ViewableRange&lt;R&gt; &amp;&amp; Constructible&lt;V, all_view&lt;R&gt;&gt;
    constexpr transform_view(R&amp;&amp; r, F fun);
 
    constexpr V base() const;
 
    constexpr iterator&lt;false&gt; begin();
    constexpr iterator&lt;true&gt; begin() const
      requires Range&lt;const V&gt; &amp;&amp;
               RegularInvocable&lt;const F&amp;, iter_reference_t&lt;iterator_t&lt;const V&gt;&gt;&gt;;
 
    constexpr sentinel&lt;false&gt; end();
    constexpr iterator&lt;false&gt; end() requires CommonRange&lt;V&gt;;
    constexpr sentinel&lt;true&gt; end() const
      requires Range&lt;const V&gt; &amp;&amp;
               RegularInvocable&lt;const F&amp;, iter_reference_t&lt;iterator_t&lt;const V&gt;&gt;&gt;;
    constexpr iterator&lt;true&gt; end() const
      requires CommonRange&lt;const V&gt; &amp;&amp;
               RegularInvocable&lt;const F&amp;, iter_reference_t&lt;iterator_t&lt;const V&gt;&gt;&gt;;
 
    constexpr auto size() requires SizedRange&lt;V&gt; { return ranges::size(base_); }
    constexpr auto size() const requires SizedRange&lt;const V&gt;
    { return ranges::size(base_); }
  };
 
  template&lt;class R, class F&gt;
    transform_view(R&amp;&amp;, F) -&gt; transform_view&lt;all_view&lt;R&gt;, F&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::transform_view::iterator">Class template <code>std::ranges::transform_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class V, class F&gt;
  template&lt;bool Const&gt;
  class transform_view&lt;V, F&gt;::iterator {
  private:
    using Parent =                              // exposition only
      conditional_t&lt;Const, const transform_view, transform_view&gt;;
    using Base   =                              // exposition only
      conditional_t&lt;Const, const V, V&gt;;
    iterator_t&lt;Base&gt; current_ =                 // exposition only
      iterator_t&lt;Base&gt;();
    Parent* parent_ = nullptr;                  // exposition only
  public:
    using iterator_concept  = /* see definition */;
    using iterator_category = /* see definition */;
    using value_type        =
      remove_cvref_t&lt;invoke_result_t&lt;F&amp;, iter_reference_t&lt;iterator_t&lt;Base&gt;&gt;&gt;&gt;;
    using difference_type   = iter_difference_t&lt;iterator_t&lt;Base&gt;&gt;;
 
    iterator() = default;
    constexpr iterator(Parent&amp; parent, iterator_t&lt;Base&gt; current);
    constexpr iterator(iterator&lt;!Const&gt; i)
      requires Const &amp;&amp; ConvertibleTo&lt;iterator_t&lt;V&gt;, iterator_t&lt;Base&gt;&gt;;
 
    constexpr iterator_t&lt;Base&gt; base() const;
    constexpr decltype(auto) operator*() const
    { return invoke(*parent_-&gt;fun_, *current_); }
 
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires ForwardRange&lt;Base&gt;;
 
    constexpr iterator&amp; operator--() requires BidirectionalRange&lt;Base&gt;;
    constexpr iterator operator--(int) requires BidirectionalRange&lt;Base&gt;;
 
    constexpr iterator&amp; operator+=(difference_type n)
      requires RandomAccessRange&lt;Base&gt;;
    constexpr iterator&amp; operator-=(difference_type n)
      requires RandomAccessRange&lt;Base&gt;;
    constexpr decltype(auto) operator[](difference_type n) const
      requires RandomAccessRange&lt;Base&gt;
    { return invoke(*parent_-&gt;fun_, current_[n]); }
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
      requires EqualityComparable&lt;iterator_t&lt;Base&gt;&gt;;
    friend constexpr bool operator!=(const iterator&amp; x, const iterator&amp; y)
      requires EqualityComparable&lt;iterator_t&lt;Base&gt;&gt;;
 
    friend constexpr bool operator&lt;(const iterator&amp; x, const iterator&amp; y)
      requires RandomAccessRange&lt;Base&gt;;
    friend constexpr bool operator&gt;(const iterator&amp; x, const iterator&amp; y)
      requires RandomAccessRange&lt;Base&gt;;
    friend constexpr bool operator&lt;=(const iterator&amp; x, const iterator&amp; y)
      requires RandomAccessRange&lt;Base&gt;;
    friend constexpr bool operator&gt;=(const iterator&amp; x, const iterator&amp; y)
      requires RandomAccessRange&lt;Base&gt;;
 
    friend constexpr iterator operator+(iterator i, difference_type n)
      requires RandomAccessRange&lt;Base&gt;;
    friend constexpr iterator operator+(difference_type n, iterator i)
      requires RandomAccessRange&lt;Base&gt;;
 
    friend constexpr iterator operator-(iterator i, difference_type n)
      requires RandomAccessRange&lt;Base&gt;;
    friend constexpr difference_type operator-(const iterator&amp; x, const iterator&amp; y)
      requires RandomAccessRange&lt;Base&gt;;
 
    friend constexpr decltype(auto) iter_move(const iterator&amp; i)
      noexcept(noexcept(invoke(*i.parent_-&gt;fun_, *i.current_)))
    {
      if constexpr (is_lvalue_reference_v&lt;decltype(*i)&gt;)
        return std::move(*i);
      else
        return *i;
    }
 
    friend constexpr void iter_swap(const iterator&amp; x, const iterator&amp; y)
      noexcept(noexcept(ranges::iter_swap(x.current_, y.current_)))
      requires IndirectlySwappable&lt;iterator_t&lt;Base&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::transform_view::sentinel">Class template <code>std::ranges::transform_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class V, class F&gt;
  template&lt;bool Const&gt;
  class transform_view&lt;V, F&gt;::sentinel {
  private:
    using Parent =                                      // exposition only
      conditional_t&lt;Const, const transform_view, transform_view&gt;;
    using Base = conditional_t&lt;Const, const V, V&gt;;      // exposition only
    sentinel_t&lt;Base&gt; end_ = sentinel_t&lt;Base&gt;();         // exposition only
  public:
    sentinel() = default;
    constexpr explicit sentinel(sentinel_t&lt;Base&gt; end);
    constexpr sentinel(sentinel&lt;!Const&gt; i)
      requires Const &amp;&amp; ConvertibleTo&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;Base&gt;&gt;;
 
    constexpr sentinel_t&lt;Base&gt; base() const;
 
    friend constexpr bool operator==(const iterator&lt;Const&gt;&amp; x, const sentinel&amp; y);
    friend constexpr bool operator==(const sentinel&amp; x, const iterator&lt;Const&gt;&amp; y);
    friend constexpr bool operator!=(const iterator&lt;Const&gt;&amp; x, const sentinel&amp; y);
    friend constexpr bool operator!=(const sentinel&amp; x, const iterator&lt;Const&gt;&amp; y);
 
    friend constexpr iter_difference_t&lt;iterator_t&lt;Base&gt;&gt;
      operator-(const iterator&lt;Const&gt;&amp; x, const sentinel&amp; y)
        requires SizedSentinel&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;Base&gt;&gt;;
    friend constexpr iter_difference_t&lt;iterator_t&lt;Base&gt;&gt;
      operator-(const sentinel&amp; y, const iterator&lt;Const&gt;&amp; x)
        requires SizedSentinel&lt;sentinel_t&lt;Base&gt;, iterator_t&lt;Base&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::take_view">Class template <code>std::ranges::take_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;View V&gt;
  class take_view : public view_interface&lt;take_view&lt;V&gt;&gt; {
  private:
    V base_ = V();                                      // exposition only
    iter_difference_t&lt;iterator_t&lt;V&gt;&gt; count_ = 0;        // exposition only
    // class template take_­view​::​sentinel
    template&lt;bool&gt; struct sentinel;                     // exposition only
  public:
    take_view() = default;
    constexpr take_view(V base, iter_difference_t&lt;iterator_t&lt;V&gt;&gt; count);
    template&lt;ViewableRange R&gt;
      requires Constructible&lt;V, all_view&lt;R&gt;&gt;
    constexpr take_view(R&amp;&amp; r, iter_difference_t&lt;iterator_t&lt;V&gt;&gt; count);
 
    constexpr V base() const;
 
    constexpr auto begin() requires (!__SimpleView&lt;V&gt;) {
      if constexpr (SizedRange&lt;V&gt;) {
        if constexpr (RandomAccessRange&lt;V&gt;)
          return ranges::begin(base_);
        else
          return counted_iterator{ranges::begin(base_), size()};
      } else
        return counted_iterator{ranges::begin(base_), count_};
    }
 
    constexpr auto begin() const requires Range&lt;const V&gt; {
      if constexpr (SizedRange&lt;const V&gt;) {
        if constexpr (RandomAccessRange&lt;const V&gt;)
          return ranges::begin(base_);
        else
          return counted_iterator{ranges::begin(base_), size()};
      } else
        return counted_iterator{ranges::begin(base_), count_};
    }
 
    constexpr auto end() requires (!__SimpleView&lt;V&gt;) {
      if constexpr (SizedRange&lt;V&gt;) {
        if constexpr (RandomAccessRange&lt;V&gt;)
          return ranges::begin(base_) + size();
        else
          return default_sentinel;
      } else
        return sentinel&lt;false&gt;{ranges::end(base_)};
    }
 
    constexpr auto end() const requires Range&lt;const V&gt; {
      if constexpr (SizedRange&lt;const V&gt;) {
        if constexpr (RandomAccessRange&lt;const V&gt;)
          return ranges::begin(base_) + size();
        else
          return default_sentinel;
      } else
        return sentinel&lt;true&gt;{ranges::end(base_)};
    }
 
    constexpr auto size() requires SizedRange&lt;V&gt; {
      auto n = ranges::size(base_);
      return ranges::min(n, static_cast&lt;decltype(n)&gt;(count_));
    }
 
    constexpr auto size() const requires SizedRange&lt;const V&gt; {
      auto n = ranges::size(base_);
      return ranges::min(n, static_cast&lt;decltype(n)&gt;(count_));
    }
  };
 
  template&lt;Range R&gt;
    take_view(R&amp;&amp;, iter_difference_t&lt;iterator_t&lt;R&gt;&gt;)
      -&gt; take_view&lt;all_view&lt;R&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::take_view::sentinel">Class template <code>std::ranges::take_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class V&gt;
  template&lt;bool Const&gt;
  class take_view&lt;V&gt;::sentinel {
  private:
    using Base = conditional_t&lt;Const, const V, V&gt;;      // exposition only
    using CI = counted_iterator&lt;iterator_t&lt;Base&gt;&gt;;      // exposition only
    sentinel_t&lt;Base&gt; end_ = sentinel_t&lt;Base&gt;();         // exposition only
  public:
    sentinel() = default;
    constexpr explicit sentinel(sentinel_t&lt;Base&gt; end);
    constexpr sentinel(sentinel&lt;!Const&gt; s)
      requires Const &amp;&amp; ConvertibleTo&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;Base&gt;&gt;;
 
    constexpr sentinel_t&lt;Base&gt; base() const;
 
    friend constexpr bool operator==(const sentinel&amp; x, const CI&amp; y);
    friend constexpr bool operator==(const CI&amp; y, const sentinel&amp; x);
    friend constexpr bool operator!=(const sentinel&amp; x, const CI&amp; y);
    friend constexpr bool operator!=(const CI&amp; y, const sentinel&amp; x);
  };
}</pre></div> <h4 id="Class_template_std::ranges::join_view">Class template <code>std::ranges::join_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;InputRange V&gt;
    requires View&lt;V&gt; &amp;&amp; InputRange&lt;iter_reference_t&lt;iterator_t&lt;V&gt;&gt;&gt; &amp;&amp;
             (is_reference_v&lt;iter_reference_t&lt;iterator_t&lt;V&gt;&gt;&gt; ||
              View&lt;iter_value_t&lt;iterator_t&lt;V&gt;&gt;&gt;)
  class join_view : public view_interface&lt;join_view&lt;V&gt;&gt; {
  private:
    using InnerRng =                    // exposition only
      iter_reference_t&lt;iterator_t&lt;V&gt;&gt;;
    // class template join_­view​::​iterator
    template&lt;bool Const&gt;
      struct iterator;                  // exposition only
    // class template join_­view​::​sentinel
    template&lt;bool Const&gt;
      struct sentinel;                  // exposition only
 
    V base_ = V();                      // exposition only
    all_view&lt;InnerRng&gt; inner_ =         // exposition only, present only when
      all_view&lt;InnerRng&gt;();              // !is_reference_v&lt;InnerRng&gt;
  public:
    join_view() = default;
    constexpr explicit join_view(V base);
 
    template&lt;InputRange R&gt;
      requires ViewableRange&lt;R&gt; &amp;&amp; Constructible&lt;V, all_view&lt;R&gt;&gt;
    constexpr explicit join_view(R&amp;&amp; r);
 
    constexpr auto begin() {
      return iterator&lt;__SimpleView&lt;V&gt;&gt;{*this, ranges::begin(base_)};
    }
 
    constexpr auto begin() const
    requires InputRange&lt;const V&gt; &amp;&amp;
             is_reference_v&lt;iter_reference_t&lt;iterator_t&lt;const V&gt;&gt;&gt; {
      return iterator&lt;true&gt;{*this, ranges::begin(base_)};
    }
 
    constexpr auto end() {
      if constexpr (ForwardRange&lt;V&gt; &amp;&amp;
                    is_reference_v&lt;InnerRng&gt; &amp;&amp; ForwardRange&lt;InnerRng&gt; &amp;&amp;
                    CommonRange&lt;V&gt; &amp;&amp; CommonRange&lt;InnerRng&gt;)
        return iterator&lt;__SimpleView&lt;V&gt;&gt;{*this, ranges::end(base_)};
      else
        return sentinel&lt;__SimpleView&lt;V&gt;&gt;{*this};
    }
 
    constexpr auto end() const
    requires InputRange&lt;const V&gt; &amp;&amp;
             is_reference_v&lt;iter_reference_t&lt;iterator_t&lt;const V&gt;&gt;&gt; {
      if constexpr (ForwardRange&lt;const V&gt; &amp;&amp;
                    is_reference_v&lt;iter_reference_t&lt;iterator_t&lt;const V&gt;&gt;&gt; &amp;&amp;
                    ForwardRange&lt;iter_reference_t&lt;iterator_t&lt;const V&gt;&gt;&gt; &amp;&amp;
                    CommonRange&lt;const V&gt; &amp;&amp;
                    CommonRange&lt;iter_reference_t&lt;iterator_t&lt;const V&gt;&gt;&gt;)
        return iterator&lt;true&gt;{*this, ranges::end(base_)};
      else
        return sentinel&lt;true&gt;{*this};
    }
  };
 
  template&lt;class R&gt;
    explicit join_view(R&amp;&amp;) -&gt; join_view&lt;all_view&lt;R&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::join_view::iterator">Class template <code>std::ranges::join_view::iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
template&lt;class V&gt;
  template&lt;bool Const&gt;
  struct join_view&lt;V&gt;::iterator {
  private:
    using Parent =                                              // exposition only
      conditional_t&lt;Const, const join_view, join_view&gt;;
    using Base   = conditional_t&lt;Const, const V, V&gt;;            // exposition only
 
    static constexpr bool ref_is_glvalue =                      // exposition only
      is_reference_v&lt;iter_reference_t&lt;iterator_t&lt;Base&gt;&gt;&gt;;
 
    iterator_t&lt;Base&gt; outer_ = iterator_t&lt;Base&gt;();               // exposition only
    iterator_t&lt;iter_reference_t&lt;iterator_t&lt;Base&gt;&gt;&gt; inner_ =     // exposition only
      iterator_t&lt;iter_reference_t&lt;iterator_t&lt;Base&gt;&gt;&gt;();
    Parent* parent_ = nullptr;                                  // exposition only
 
    constexpr void satisfy();                                   // exposition only
  public:
    using iterator_concept  = /* see definition */;
    using iterator_category = /* see definition */;
    using value_type        =
      iter_value_t&lt;iterator_t&lt;iter_reference_t&lt;iterator_t&lt;Base&gt;&gt;&gt;&gt;;
    using difference_type   = /* see definition */;
 
    iterator() = default;
    constexpr iterator(Parent&amp; parent, iterator_t&lt;V&gt; outer);
    constexpr iterator(iterator&lt;!Const&gt; i)
      requires Const &amp;&amp;
               ConvertibleTo&lt;iterator_t&lt;V&gt;, iterator_t&lt;Base&gt;&gt; &amp;&amp;
               ConvertibleTo&lt;iterator_t&lt;InnerRng&gt;,
                             iterator_t&lt;iter_reference_t&lt;iterator_t&lt;Base&gt;&gt;&gt;&gt;;
 
    constexpr decltype(auto) operator*() const { return *inner_; }
 
    constexpr iterator_t&lt;Base&gt; operator-&gt;() const
      requires __HasArrow&lt;iterator_t&lt;Base&gt;&gt;;
 
    constexpr iterator&amp; operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int)
      requires ref_is_glvalue &amp;&amp; ForwardRange&lt;Base&gt; &amp;&amp;
               ForwardRange&lt;iter_reference_t&lt;iterator_t&lt;Base&gt;&gt;&gt;;
 
    constexpr iterator&amp; operator--()
      requires ref_is_glvalue &amp;&amp; BidirectionalRange&lt;Base&gt; &amp;&amp;
               BidirectionalRange&lt;iter_reference_t&lt;iterator_t&lt;Base&gt;&gt;&gt;;
 
    constexpr iterator operator--(int)
      requires ref_is_glvalue &amp;&amp; BidirectionalRange&lt;Base&gt; &amp;&amp;
               BidirectionalRange&lt;iter_reference_t&lt;iterator_t&lt;Base&gt;&gt;&gt;;
 
    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
      requires ref_is_glvalue &amp;&amp; EqualityComparable&lt;iterator_t&lt;Base&gt;&gt; &amp;&amp;
               EqualityComparable&lt;iterator_t&lt;iter_reference_t&lt;iterator_t&lt;Base&gt;&gt;&gt;&gt;;
 
    friend constexpr bool operator!=(const iterator&amp; x, const iterator&amp; y)
      requires ref_is_glvalue &amp;&amp; EqualityComparable&lt;iterator_t&lt;Base&gt;&gt; &amp;&amp;
               EqualityComparable&lt;iterator_t&lt;iter_reference_t&lt;iterator_t&lt;Base&gt;&gt;&gt;&gt;;
 
    friend constexpr decltype(auto) iter_move(const iterator&amp; i)
    noexcept(noexcept(ranges::iter_move(i.inner_))) {
      return ranges::iter_move(i.inner_);
    }
 
    friend constexpr void iter_swap(const iterator&amp; x, const iterator&amp; y)
      noexcept(noexcept(ranges::iter_swap(x.inner_, y.inner_)));
  };
}</pre></div> <h4 id="Class_template_std::ranges::join_view::sentinel">Class template <code>std::ranges::join_view::sentinel</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class V&gt;
  template&lt;bool Const&gt;
  struct join_view&lt;V&gt;::sentinel {
  private:
    using Parent =                                      // exposition only
      conditional_t&lt;Const, const join_view, join_view&gt;;
    using Base   = conditional_t&lt;Const, const V, V&gt;;    // exposition only
    sentinel_t&lt;Base&gt; end_ = sentinel_t&lt;Base&gt;();         // exposition only
  public:
    sentinel() = default;
 
    constexpr explicit sentinel(Parent&amp; parent);
    constexpr sentinel(sentinel&lt;!Const&gt; s)
      requires Const &amp;&amp; ConvertibleTo&lt;sentinel_t&lt;V&gt;, sentinel_t&lt;Base&gt;&gt;;
 
    friend constexpr bool operator==(const iterator&lt;Const&gt;&amp; x, const sentinel&amp; y);
    friend constexpr bool operator==(const sentinel&amp; x, const iterator&lt;Const&gt;&amp; y);
    friend constexpr bool operator!=(const iterator&lt;Const&gt;&amp; x, const sentinel&amp; y);
    friend constexpr bool operator!=(const sentinel&amp; x, const iterator&lt;Const&gt;&amp; y);
  };
}</pre></div> <h4 id="Class_template_std::ranges::split_.C2.ADview">Class template <code>std::ranges::split_­view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;auto&gt; struct __require_constant;     // exposition only
 
  template&lt;class R&gt;
  concept __TinyRange =                         // exposition only
    SizedRange&lt;R&gt; &amp;&amp;
    requires { typename __require_constant&lt;remove_reference_t&lt;R&gt;::size()&gt;; } &amp;&amp;
    (remove_reference_t&lt;R&gt;::size() &lt;= 1);
 
  template&lt;InputRange V, ForwardRange Pattern&gt;
    requires View&lt;V&gt; &amp;&amp; View&lt;Pattern&gt; &amp;&amp;
             IndirectlyComparable&lt;iterator_t&lt;V&gt;, iterator_t&lt;Pattern&gt;, ranges::equal_to&gt; &amp;&amp;
             (ForwardRange&lt;V&gt; || __TinyRange&lt;Pattern&gt;)
  class split_view : public view_interface&lt;split_view&lt;V, Pattern&gt;&gt; {
  private:
    V base_ = V();                              // exposition only
    Pattern pattern_ = Pattern();               // exposition only
    iterator_t&lt;V&gt; current_ = iterator_t&lt;V&gt;();   // exposition only, present only if 
                                                // !ForwardRange&lt;V&gt;
    // class template split_­view​::​outer_­iterator
    template&lt;bool&gt; struct outer_iterator;       // exposition only
    // class template split_­view​::​inner_­iterator
    template&lt;bool&gt; struct inner_iterator;       // exposition only
  public:
    split_view() = default;
    constexpr split_view(V base, Pattern pattern);
 
    template&lt;InputRange R, ForwardRange P&gt;
      requires Constructible&lt;V, all_view&lt;R&gt;&gt; &amp;&amp;
               Constructible&lt;Pattern, all_view&lt;P&gt;&gt;
    constexpr split_view(R&amp;&amp; r, P&amp;&amp; p);
 
    template&lt;InputRange R&gt;
      requires Constructible&lt;V, all_view&lt;R&gt;&gt; &amp;&amp;
               Constructible&lt;Pattern, single_view&lt;iter_value_t&lt;iterator_t&lt;R&gt;&gt;&gt;&gt;
    constexpr split_view(R&amp;&amp; r, iter_value_t&lt;iterator_t&lt;R&gt;&gt; e);
 
    constexpr auto begin() {
      if constexpr (ForwardRange&lt;V&gt;)
        return outer_iterator&lt;__SimpleView&lt;V&gt;&gt;{*this, ranges::begin(base_)};
      else {
        current_ = ranges::begin(base_);
        return outer_iterator&lt;false&gt;{*this};
      }
    }
 
    constexpr auto begin() const requires ForwardRange&lt;V&gt; &amp;&amp; ForwardRange&lt;const V&gt; {
      return outer_iterator&lt;true&gt;{*this, ranges::begin(base_)};
    }
 
    constexpr auto end() requires ForwardRange&lt;V&gt; &amp;&amp; CommonRange&lt;V&gt; {
      return outer_iterator&lt;__SimpleView&lt;V&gt;&gt;{*this, ranges::end(base_)};
    }
 
    constexpr auto end() const {
      if constexpr (ForwardRange&lt;V&gt; &amp;&amp; ForwardRange&lt;const V&gt; &amp;&amp; CommonRange&lt;const V&gt;)
        return outer_iterator&lt;true&gt;{*this, ranges::end(base_)};
      else
        return default_sentinel;
    }
  };
 
  template&lt;class R, class P&gt;
    split_view(R&amp;&amp;, P&amp;&amp;) -&gt; split_view&lt;all_view&lt;R&gt;, all_view&lt;P&gt;&gt;;
 
  template&lt;InputRange R&gt;
    split_view(R&amp;&amp;, iter_value_t&lt;iterator_t&lt;R&gt;&gt;)
      -&gt; split_view&lt;all_view&lt;R&gt;, single_view&lt;iter_value_t&lt;iterator_t&lt;R&gt;&gt;&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::split_view::outer_iterator">Class template <code>std::ranges::split_view::outer_iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class V, class Pattern&gt;
  template&lt;bool Const&gt;
  struct split_view&lt;V, Pattern&gt;::outer_iterator {
  private:
    using Parent =                              // exposition only
      conditional_t&lt;Const, const split_view, split_view&gt;;
    using Base   =                              // exposition only
      conditional_t&lt;Const, const V, V&gt;;
    Parent* parent_ = nullptr;                  // exposition only
    iterator_t&lt;Base&gt; current_ =                 // exposition only, present only
      iterator_t&lt;Base&gt;();                       // if V models ForwardRange
 
  public:
    using iterator_concept  =
      conditional_t&lt;ForwardRange&lt;Base&gt;, forward_iterator_tag, input_iterator_tag&gt;;
    using iterator_category = input_iterator_tag;
    struct value_type;
    using difference_type   = iter_difference_t&lt;iterator_t&lt;Base&gt;&gt;;
 
    outer_iterator() = default;
    constexpr explicit outer_iterator(Parent&amp; parent)
      requires (!ForwardRange&lt;Base&gt;);
    constexpr outer_iterator(Parent&amp; parent, iterator_t&lt;Base&gt; current)
      requires ForwardRange&lt;Base&gt;;
    constexpr outer_iterator(outer_iterator&lt;!Const&gt; i)
      requires Const &amp;&amp; ConvertibleTo&lt;iterator_t&lt;V&gt;, iterator_t&lt;const V&gt;&gt;;
 
    constexpr value_type operator*() const;
 
    constexpr outer_iterator&amp; operator++();
    constexpr decltype(auto) operator++(int) {
      if constexpr (ForwardRange&lt;Base&gt;) {
        auto tmp = *this;
        ++*this;
        return tmp;
      } else
        ++*this;
    }
 
    friend constexpr bool operator==(const outer_iterator&amp; x, const outer_iterator&amp; y)
      requires ForwardRange&lt;Base&gt;;
    friend constexpr bool operator!=(const outer_iterator&amp; x, const outer_iterator&amp; y)
      requires ForwardRange&lt;Base&gt;;
 
    friend constexpr bool operator==(const outer_iterator&amp; x, default_sentinel_t);
    friend constexpr bool operator==(default_sentinel_t, const outer_iterator&amp; x);
    friend constexpr bool operator!=(const outer_iterator&amp; x, default_sentinel_t y);
    friend constexpr bool operator!=(default_sentinel_t y, const outer_iterator&amp; x);
  };
}</pre></div> <h4 id="Class_std::ranges::split_view::outer_iterator::value_type">Class <code>std::ranges::split_view::outer_iterator::value_type</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class V, class Pattern&gt;
  template&lt;bool Const&gt;
  struct split_view&lt;V, Pattern&gt;::outer_iterator&lt;Const&gt;::value_type {
  private:
    outer_iterator i_ = outer_iterator();               // exposition only
  public:
    value_type() = default;
    constexpr explicit value_type(outer_iterator i);
 
    constexpr inner_iterator&lt;Const&gt; begin() const;
    constexpr default_sentinel_t end() const;
  };
}</pre></div> <h4 id="Class_template_std::ranges::split_view::inner_iterator">Class template <code>std::ranges::split_view::inner_iterator</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;class V, class Pattern&gt;
  template&lt;bool Const&gt;
  struct split_view&lt;V, Pattern&gt;::inner_iterator {
  private:
    using Base =
      conditional_t&lt;Const, const V, V&gt;;                 // exposition only
    outer_iterator&lt;Const&gt; i_ = outer_iterator&lt;Const&gt;(); // exposition only
    bool incremented_ = false;                          // exposition only
  public:
    using iterator_concept  = typename outer_iterator&lt;Const&gt;::iterator_concept;
    using iterator_category = /* see definition */;
    using value_type        = iter_value_t&lt;iterator_t&lt;Base&gt;&gt;;
    using difference_type   = iter_difference_t&lt;iterator_t&lt;Base&gt;&gt;;
 
    inner_iterator() = default;
    constexpr explicit inner_iterator(outer_iterator&lt;Const&gt; i);
 
    constexpr decltype(auto) operator*() const { return *i_.current; }
 
    constexpr inner_iterator&amp; operator++();
    constexpr decltype(auto) operator++(int) {
      if constexpr (ForwardRange&lt;V&gt;) {
        auto tmp = *this;
        ++*this;
        return tmp;
      } else
        ++*this;
    }
 
    friend constexpr bool operator==(const inner_iterator&amp; x, const inner_iterator&amp; y)
      requires ForwardRange&lt;Base&gt;;
    friend constexpr bool operator!=(const inner_iterator&amp; x, const inner_iterator&amp; y)
      requires ForwardRange&lt;Base&gt;;
 
    friend constexpr bool operator==(const inner_iterator&amp; x, default_sentinel_t);
    friend constexpr bool operator==(default_sentinel_t, const inner_iterator&amp; x);
    friend constexpr bool operator!=(const inner_iterator&amp; x, default_sentinel_t y);
    friend constexpr bool operator!=(default_sentinel_t y, const inner_iterator&amp; x);
 
    friend constexpr decltype(auto) iter_move(const inner_iterator&amp; i)
    noexcept(noexcept(ranges::iter_move(i.i_.current))) {
      return ranges::iter_move(i.i_.current);
    }
 
    friend constexpr void iter_swap(const inner_iterator&amp; x, const inner_iterator&amp; y)
      noexcept(noexcept(ranges::iter_swap(x.i_.current, y.i_.current)))
      requires IndirectlySwappable&lt;iterator_t&lt;Base&gt;&gt;;
  };
}</pre></div> <h4 id="Class_template_std::ranges::common_view">Class template <code>std::ranges::common_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;View V&gt;
    requires (!CommonRange&lt;V&gt;)
  class common_view : public view_interface&lt;common_view&lt;V&gt;&gt; {
  private:
    V base_ = V();  // exposition only
  public:
    common_view() = default;
 
    constexpr explicit common_view(V r);
 
    template&lt;ViewableRange R&gt;
      requires (!CommonRange&lt;R&gt; &amp;&amp; Constructible&lt;V, all_view&lt;R&gt;&gt;)
    constexpr explicit common_view(R&amp;&amp; r);
 
    constexpr V base() const;
 
    constexpr auto size() requires SizedRange&lt;V&gt; {
      return ranges::size(base_);
    }
    constexpr auto size() const requires SizedRange&lt;const V&gt; {
      return ranges::size(base_);
    }
 
    constexpr auto begin() {
      if constexpr (RandomAccessRange&lt;V&gt; &amp;&amp; SizedRange&lt;V&gt;)
        return ranges::begin(base_);
      else
        return common_iterator&lt;iterator_t&lt;V&gt;, sentinel_t&lt;V&gt;&gt;(ranges::begin(base_));
    }
 
    constexpr auto begin() const requires Range&lt;const V&gt; {
      if constexpr (RandomAccessRange&lt;const V&gt; &amp;&amp; SizedRange&lt;const V&gt;)
        return ranges::begin(base_);
      else
        return
          common_iterator&lt;iterator_t&lt;const V&gt;, sentinel_t&lt;const V&gt;&gt;(ranges::begin(base_));
    }
 
    constexpr auto end() {
      if constexpr (RandomAccessRange&lt;V&gt; &amp;&amp; SizedRange&lt;V&gt;)
        return ranges::begin(base_) + ranges::size(base_);
      else
        return common_iterator&lt;iterator_t&lt;V&gt;, sentinel_t&lt;V&gt;&gt;(ranges::end(base_));
    }
 
    constexpr auto end() const requires Range&lt;const V&gt; {
      if constexpr (RandomAccessRange&lt;const V&gt; &amp;&amp; SizedRange&lt;const V&gt;)
        return ranges::begin(base_) + ranges::size(base_);
      else
        return
          common_iterator&lt;iterator_t&lt;const V&gt;, sentinel_t&lt;const V&gt;&gt;(ranges::end(base_));
    }
  };
 
  template&lt;class R&gt;
    common_view(R&amp;&amp;) -&gt; common_view&lt;all_view&lt;R&gt;&gt;;
}</pre></div> <h4 id="Class_template_std::ranges::reverse_view">Class template <code>std::ranges::reverse_view</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::ranges {
  template&lt;View V&gt;
    requires BidirectionalRange&lt;V&gt;
  class reverse_view : public view_interface&lt;reverse_view&lt;V&gt;&gt; {
  private:
    V base_ = V();  // exposition only
  public:
    reverse_view() = default;
 
    constexpr explicit reverse_view(V r);
 
    template&lt;ViewableRange R&gt;
      requires BidirectionalRange&lt;R&gt; &amp;&amp; Constructible&lt;V, all_view&lt;R&gt;&gt;
    constexpr explicit reverse_view(R&amp;&amp; r);
 
    constexpr V base() const;
 
    constexpr reverse_iterator&lt;iterator_t&lt;V&gt;&gt; begin();
    constexpr reverse_iterator&lt;iterator_t&lt;V&gt;&gt; begin() requires CommonRange&lt;V&gt;;
    constexpr reverse_iterator&lt;iterator_t&lt;const V&gt;&gt; begin() const
      requires CommonRange&lt;const V&gt;;
 
    constexpr reverse_iterator&lt;iterator_t&lt;V&gt;&gt; end();
    constexpr reverse_iterator&lt;iterator_t&lt;const V&gt;&gt; end() const
      requires CommonRange&lt;const V&gt;;
 
    constexpr auto size() requires SizedRange&lt;V&gt; {
      return ranges::size(base_);
    }
    constexpr auto size() const requires SizedRange&lt;const V&gt; {
      return ranges::size(base_);
    }
  };
 
  template&lt;class R&gt;
    reverse_view(R&amp;&amp;) -&gt; reverse_view&lt;all_view&lt;R&gt;&gt;;
}</pre></div>          <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/header/ranges" class="_attribution-link">http://en.cppreference.com/w/cpp/header/ranges</a>
  </p>
</div>
