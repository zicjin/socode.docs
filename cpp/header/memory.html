   <h1 id="firstHeading" class="firstHeading">Standard library header &lt;memory&gt;</h1>            <p>This header is part of the <a href="../memory" title="cpp/memory">dynamic memory management</a> library.</p>
<table class="t-dsc-begin"> <tr> <td colspan="2"> <h3 id="Classes">  Classes</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Pointer_traits">  Pointer traits </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/pointer_traits" title="cpp/memory/pointer traits"> <span class="t-lines"><span>pointer_traits</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> provides information about pointer-like types <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Garbage_collector_support">  Garbage collector support </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/gc/pointer_safety" title="cpp/memory/gc/pointer safety"> <span class="t-lines"><span>pointer_safety</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> lists pointer safety models <br> <span class="t-mark">(enum)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Allocators">  Allocators </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/allocator" title="cpp/memory/allocator"> <span class="t-lines"><span>allocator</span></span></a></div> </td> <td> the default allocator <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/allocator_traits" title="cpp/memory/allocator traits"> <span class="t-lines"><span>allocator_traits</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> provides information about allocator types <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/allocator_arg_t" title="cpp/memory/allocator arg t"> <span class="t-lines"><span>allocator_arg_t</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> tag type used to select allocator-aware constructor overloads <br> <span class="t-mark">(class)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/allocator_arg" title="cpp/memory/allocator arg"> <span class="t-lines"><span>allocator_arg</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> an object of type <code><a href="../memory/allocator_arg_t" title="cpp/memory/allocator arg t">std::allocator_arg_t</a></code> used to select allocator-aware constructors <br> <span class="t-mark">(constant)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uses_allocator" title="cpp/memory/uses allocator"> <span class="t-lines"><span>uses_allocator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> checks if the specified type supports uses-allocator construction <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Uninitialized_storage">  Uninitialized storage </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/raw_storage_iterator" title="cpp/memory/raw storage iterator"> <span class="t-lines"><span>raw_storage_iterator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> an iterator that allows standard algorithms to store results in uninitialized memory <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Smart_pointers">  Smart pointers </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/unique_ptr" title="cpp/memory/unique ptr"> <span class="t-lines"><span>unique_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> smart pointer with unique object ownership semantics <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr" title="cpp/memory/shared ptr"> <span class="t-lines"><span>shared_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> smart pointer with shared object ownership semantics <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/weak_ptr" title="cpp/memory/weak ptr"> <span class="t-lines"><span>weak_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> weak reference to an object managed by <code><a href="../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code> <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/auto_ptr" title="cpp/memory/auto ptr"> <span class="t-lines"><span>auto_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx17">(removed in C++17)</span></span></span></div> </td> <td> smart pointer with strict object ownership semantics <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Helper_classes">  Helper classes </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/atomic2" title="cpp/memory/shared ptr/atomic2"> <span class="t-lines"><span>std::atomic<span class="t-dsc-small">&lt;std::shared_ptr&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> atomic shared pointer <br> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/weak_ptr/atomic2" title="cpp/memory/weak ptr/atomic2"> <span class="t-lines"><span>std::atomic<span class="t-dsc-small">&lt;std::weak_ptr&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> atomic weak pointer <br> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/owner_less" title="cpp/memory/owner less"> <span class="t-lines"><span>owner_less</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> provides mixed-type owner-based ordering of shared and weak pointers <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/enable_shared_from_this" title="cpp/memory/enable shared from this"> <span class="t-lines"><span>enable_shared_from_this</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> allows an object to create a <code>shared_ptr</code> referring to itself <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/bad_weak_ptr" title="cpp/memory/bad weak ptr"> <span class="t-lines"><span>bad_weak_ptr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> exception thrown when accessing a <code>weak_ptr</code> which refers to already destroyed object <br> <span class="t-mark">(class)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/default_delete" title="cpp/memory/default delete"> <span class="t-lines"><span>default_delete</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> default deleter for <code>unique_ptr</code> <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/unique_ptr/hash" title="cpp/memory/unique ptr/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::unique_ptr&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> hash support for <code><a href="../memory/unique_ptr" title="cpp/memory/unique ptr">std::unique_ptr</a></code> <br> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/hash" title="cpp/memory/shared ptr/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::shared_ptr&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> hash support for <code><a href="../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code> <br> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr> <td colspan="2"> <h3 id="Functions">  Functions</h3> </td>
</tr> <tr> <td colspan="2"> <h5 id="Miscellaneous">  Miscellaneous </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/to_address" title="cpp/memory/to address"> <span class="t-lines"><span>to_address</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> obtains a raw pointer from a pointer-like type <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/addressof" title="cpp/memory/addressof"> <span class="t-lines"><span>addressof</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> obtains actual address of an object, even if the <i>&amp;</i> operator is overloaded <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/align" title="cpp/memory/align"> <span class="t-lines"><span>align</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> aligns a pointer in a buffer <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/assume_aligned" title="cpp/memory/assume aligned"> <span class="t-lines"><span>assume_aligned</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> informs the compiler that a pointer is aligned <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Garbage_collector_support_2">  Garbage collector support </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/gc/declare_reachable" title="cpp/memory/gc/declare reachable"> <span class="t-lines"><span>declare_reachable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> declares that an object can not be recycled <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/gc/undeclare_reachable" title="cpp/memory/gc/undeclare reachable"> <span class="t-lines"><span>undeclare_reachable</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> declares that an object can be recycled <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/gc/declare_no_pointers" title="cpp/memory/gc/declare no pointers"> <span class="t-lines"><span>declare_no_pointers</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> declares that a memory area does not contain traceable pointers <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/gc/undeclare_no_pointers" title="cpp/memory/gc/undeclare no pointers"> <span class="t-lines"><span>undeclare_no_pointers</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> cancels the effect of <code><a href="../memory/gc/declare_no_pointers" title="cpp/memory/gc/declare no pointers">std::declare_no_pointers</a></code> <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/gc/get_pointer_safety" title="cpp/memory/gc/get pointer safety"> <span class="t-lines"><span>get_pointer_safety</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> returns the current pointer safety model <br> <span class="t-mark">(function)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Uninitialized_storage_2">  Uninitialized storage </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uninitialized_copy" title="cpp/memory/uninitialized copy"> <span class="t-lines"><span>uninitialized_copy</span></span></a></div> </td> <td> copies a range of objects to an uninitialized area of memory <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uninitialized_copy_n" title="cpp/memory/uninitialized copy n"> <span class="t-lines"><span>uninitialized_copy_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> copies a number of objects to an uninitialized area of memory <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uninitialized_fill" title="cpp/memory/uninitialized fill"> <span class="t-lines"><span>uninitialized_fill</span></span></a></div> </td> <td> copies an object to an uninitialized area of memory, defined by a range <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uninitialized_fill_n" title="cpp/memory/uninitialized fill n"> <span class="t-lines"><span>uninitialized_fill_n</span></span></a></div> </td> <td> copies an object to an uninitialized area of memory, defined by a start and a count <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uninitialized_move" title="cpp/memory/uninitialized move"> <span class="t-lines"><span>uninitialized_move</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> moves a range of objects to an uninitialized area of memory <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uninitialized_move_n" title="cpp/memory/uninitialized move n"> <span class="t-lines"><span>uninitialized_move_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> moves a number of objects to an uninitialized area of memory <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uninitialized_default_construct" title="cpp/memory/uninitialized default construct"> <span class="t-lines"><span>uninitialized_default_construct</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> constructs objects by <a href="../language/default_initialization" title="cpp/language/default initialization">default-initialization</a> in an uninitialized area of memory, defined by a range <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uninitialized_default_construct_n" title="cpp/memory/uninitialized default construct n"> <span class="t-lines"><span>uninitialized_default_construct_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> constructs objects by <a href="../language/default_initialization" title="cpp/language/default initialization">default-initialization</a> in an uninitialized area of memory, defined by a start and a count <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uninitialized_value_construct" title="cpp/memory/uninitialized value construct"> <span class="t-lines"><span>uninitialized_value_construct</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> constructs objects by <a href="../language/value_initialization" title="cpp/language/value initialization">value-initialization</a> in an uninitialized area of memory, defined by a range <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/uninitialized_value_construct_n" title="cpp/memory/uninitialized value construct n"> <span class="t-lines"><span>uninitialized_value_construct_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> constructs objects by <a href="../language/value_initialization" title="cpp/language/value initialization">value-initialization</a> in an uninitialized area of memory, defined by a start and a count <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/destroy_at" title="cpp/memory/destroy at"> <span class="t-lines"><span>destroy_at</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> destroys an object at a given address <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/destroy" title="cpp/memory/destroy"> <span class="t-lines"><span>destroy</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> destroys a range of objects <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/destroy_n" title="cpp/memory/destroy n"> <span class="t-lines"><span>destroy_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> destroys a number of objects in a range <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/get_temporary_buffer" title="cpp/memory/get temporary buffer"> <span class="t-lines"><span>get_temporary_buffer</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> obtains uninitialized storage <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/return_temporary_buffer" title="cpp/memory/return temporary buffer"> <span class="t-lines"><span>return_temporary_buffer</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> frees uninitialized storage <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Smart_pointer_non-member_operations">  Smart pointer non-member operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/unique_ptr/make_unique" title="cpp/memory/unique ptr/make unique"> <span class="t-lines"><span>make_unique</span><span>make_unique_default_init</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> creates a unique pointer that manages a new object <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/unique_ptr/operator_cmp" title="cpp/memory/unique ptr/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> compares to another <code>unique_ptr</code> or with <code>nullptr</code> <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/make_shared" title="cpp/memory/shared ptr/make shared"> <span class="t-lines"><span>make_shared</span><span>make_shared_default_init</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> creates a shared pointer that manages a new object <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/allocate_shared" title="cpp/memory/shared ptr/allocate shared"> <span class="t-lines"><span>allocate_shared</span><span>allocate_shared_default_init</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> creates a shared pointer that manages a new object allocated using an allocator <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/pointer_cast" title="cpp/memory/shared ptr/pointer cast"> <span class="t-lines"><span>static_pointer_cast</span><span>dynamic_pointer_cast</span><span>const_pointer_cast</span><span>reinterpret_pointer_cast</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> applies <a href="../language/static_cast" title="cpp/language/static cast"><code>static_cast</code></a>, <a href="../language/dynamic_cast" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a>, <a href="../language/const_cast" title="cpp/language/const cast"><code>const_cast</code></a>, or <a href="../language/reinterpret_cast" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a> to the stored pointer <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/get_deleter" title="cpp/memory/shared ptr/get deleter"> <span class="t-lines"><span>get_deleter</span></span></a></div> </td> <td> returns the deleter of specified type, if owned <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/operator_cmp" title="cpp/memory/shared ptr/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span><span>operator&lt;</span><span>operator&lt;=</span><span>operator&gt;</span><span>operator&gt;=</span></span></a></div> </td> <td> compares with another <code>shared_ptr</code> or with <code>nullptr</code> <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/operator_ltlt" title="cpp/memory/shared ptr/operator ltlt"> <span class="t-lines"><span>operator&lt;&lt;</span></span></a></div> </td> <td> outputs the value of the stored pointer to an output stream <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/unique_ptr/swap2" title="cpp/memory/unique ptr/swap2"> <span class="t-lines"><span>std::swap<span class="t-dsc-small">(std::unique_ptr)</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> specializes the <code><a href="../algorithm/swap" title="cpp/algorithm/swap">std::swap</a></code> algorithm <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/weak_ptr/swap2" title="cpp/memory/weak ptr/swap2"> <span class="t-lines"><span>std::swap<span class="t-dsc-small">(std::weak_ptr)</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> specializes the <code><a href="../algorithm/swap" title="cpp/algorithm/swap">std::swap</a></code> algorithm <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/swap2" title="cpp/memory/shared ptr/swap2"> <span class="t-lines"><span>std::swap<span class="t-dsc-small">(std::shared_ptr)</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> specializes the <code><a href="../algorithm/swap" title="cpp/algorithm/swap">std::swap</a></code> algorithm <br> <span class="t-mark">(function template)</span> </td>
</tr> </table> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/atomic" title="cpp/memory/shared ptr/atomic"> <span class="t-lines"><span>std::atomic_is_lock_free<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_load<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_load_explicit<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_store<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_store_explicit<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_exchange<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_exchange_explicit<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_compare_exchange_weak<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_compare_exchange_strong<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_compare_exchange_weak_explicit<span class="t-dsc-small">(std::shared_ptr)</span></span><span>std::atomic_compare_exchange_strong_explicit<span class="t-dsc-small">(std::shared_ptr)</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++20)</span></span></span></div> </td> <td> specializes atomic operations for <code><a href="../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code> <br> <span class="t-mark">(function template)</span> </td>
</tr> </table> <table class="t-dsc-begin"> <tr> <td colspan="2"> <h3 id="Niebloids">  Niebloids</h3> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr> <td colspan="2"> <h5 id="Uninitialized_storage_3">  Uninitialized storage </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/memory/ranges/uninitialized_copy&amp;action=edit&amp;redlink=1" class="new" title="cpp/memory/ranges/uninitialized copy（页面不存在）"> <span class="t-lines"><span>uninitialized_copy</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> copies a range of objects to an uninitialized area of memory <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/memory/ranges/uninitialized_copy_n&amp;action=edit&amp;redlink=1" class="new" title="cpp/memory/ranges/uninitialized copy n（页面不存在）"> <span class="t-lines"><span>uninitialized_copy_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> copies a number of objects to an uninitialized area of memory <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/memory/ranges/uninitialized_fill&amp;action=edit&amp;redlink=1" class="new" title="cpp/memory/ranges/uninitialized fill（页面不存在）"> <span class="t-lines"><span>uninitialized_fill</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> copies an object to an uninitialized area of memory, defined by a range <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/memory/ranges/uninitialized_fill_n&amp;action=edit&amp;redlink=1" class="new" title="cpp/memory/ranges/uninitialized fill n（页面不存在）"> <span class="t-lines"><span>uninitialized_fill_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> copies an object to an uninitialized area of memory, defined by a start and a count <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/memory/ranges/uninitialized_move&amp;action=edit&amp;redlink=1" class="new" title="cpp/memory/ranges/uninitialized move（页面不存在）"> <span class="t-lines"><span>uninitialized_move</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> moves a range of objects to an uninitialized area of memory <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/memory/ranges/uninitialized_move_n&amp;action=edit&amp;redlink=1" class="new" title="cpp/memory/ranges/uninitialized move n（页面不存在）"> <span class="t-lines"><span>uninitialized_move_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> moves a number of objects to an uninitialized area of memory <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/memory/ranges/uninitialized_default_construct&amp;action=edit&amp;redlink=1" class="new" title="cpp/memory/ranges/uninitialized default construct（页面不存在）"> <span class="t-lines"><span>uninitialized_default_construct</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> constructs objects by <a href="../language/default_initialization" title="cpp/language/default initialization">default-initialization</a> in an uninitialized area of memory, defined by a range <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/memory/ranges/uninitialized_default_construct_n&amp;action=edit&amp;redlink=1" class="new" title="cpp/memory/ranges/uninitialized default construct n（页面不存在）"> <span class="t-lines"><span>uninitialized_default_construct_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> constructs objects by <a href="../language/default_initialization" title="cpp/language/default initialization">default-initialization</a> in an uninitialized area of memory, defined by a start and count <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/memory/ranges/uninitialized_value_construct&amp;action=edit&amp;redlink=1" class="new" title="cpp/memory/ranges/uninitialized value construct（页面不存在）"> <span class="t-lines"><span>uninitialized_value_construct</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> constructs objects by <a href="../language/value_initialization" title="cpp/language/value initialization">value-initialization</a> in an uninitialized area of memory, defined by a range <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/memory/ranges/uninitialized_value_construct_n&amp;action=edit&amp;redlink=1" class="new" title="cpp/memory/ranges/uninitialized value construct n（页面不存在）"> <span class="t-lines"><span>uninitialized_value_construct_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> constructs objects by <a href="../language/value_initialization" title="cpp/language/value initialization">value-initialization</a> in an uninitialized area of memory, defined by a start and a count <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/memory/ranges/destroy_at&amp;action=edit&amp;redlink=1" class="new" title="cpp/memory/ranges/destroy at（页面不存在）"> <span class="t-lines"><span>destroy_at</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> destroys an object at a given address <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/memory/ranges/destroy&amp;action=edit&amp;redlink=1" class="new" title="cpp/memory/ranges/destroy（页面不存在）"> <span class="t-lines"><span>destroy</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> destroys a range of objects <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/memory/ranges/destroy_n&amp;action=edit&amp;redlink=1" class="new" title="cpp/memory/ranges/destroy n（页面不存在）"> <span class="t-lines"><span>destroy_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> destroys a number of objects in a range <br> <span class="t-mark">(niebloid)</span> </td>
</tr> </table> <h3 id="Synopsis">Synopsis</h3> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  // pointer traits
  template&lt;class Ptr&gt; struct pointer_traits;
  template&lt;class T&gt; struct pointer_traits&lt;T*&gt;;
 
  // pointer conversion
  template&lt;class T&gt;
    constexpr T* to_address(T* p) noexcept;
  template&lt;class Ptr&gt;
    auto to_address(const Ptr&amp; p) noexcept;
 
  // pointer safety
  enum class pointer_safety { relaxed, preferred, strict };
  void declare_reachable(void* p);
  template&lt;class T&gt;
    T* undeclare_reachable(T* p);
  void declare_no_pointers(char* p, size_t n);
  void undeclare_no_pointers(char* p, size_t n);
  pointer_safety get_pointer_safety() noexcept;
 
  // pointer alignment
  void* align(size_t alignment, size_t size, void*&amp; ptr, size_t&amp; space);
  template&lt;size_t N, class T&gt;
    [[nodiscard]] constexpr T* assume_aligned(T* ptr);
 
  // allocator argument tag
  struct allocator_arg_t { explicit allocator_arg_t() = default; };
  inline constexpr allocator_arg_t allocator_arg{};
 
  // uses_allocator
  template&lt;class T, class Alloc&gt; struct uses_allocator;
 
  // uses_allocator
  template&lt;class T, class Alloc&gt;
    inline constexpr bool uses_allocator_v = uses_allocator&lt;T, Alloc&gt;::value;
 
  // uses-allocator construction
  template&lt;class T, class Alloc, class... Args&gt;
    auto uses_allocator_construction_args(const Alloc&amp; alloc, Args&amp;&amp;... args)
      -&gt; /* see definition */;
  template&lt;class T, class Alloc, class Tuple1, class Tuple2&gt;
    auto uses_allocator_construction_args(const Alloc&amp; alloc, piecewise_construct_t,
                                          Tuple1&amp;&amp; x, Tuple2&amp;&amp; y)
      -&gt; /* see definition */;
  template&lt;class T, class Alloc&gt;
    auto uses_allocator_construction_args(const Alloc&amp; alloc) -&gt; /* see definition */;
  template&lt;class T, class Alloc, class U, class V&gt;
    auto uses_allocator_construction_args(const Alloc&amp; alloc, U&amp;&amp; u, V&amp;&amp; v)
      -&gt; /* see definition */;
  template&lt;class T, class Alloc, class U, class V&gt;
    auto uses_allocator_construction_args(const Alloc&amp; alloc, const pair&lt;U,V&gt;&amp; pr)
      -&gt; /* see definition */;
  template&lt;class T, class Alloc, class U, class V&gt;
    auto uses_allocator_construction_args(const Alloc&amp; alloc, pair&lt;U,V&gt;&amp;&amp; pr)
      -&gt; /* see definition */;
  template&lt;class T, class Alloc, class... Args&gt;
    T make_obj_using_allocator(const Alloc&amp; alloc, Args&amp;&amp;... args);
  template&lt;class T, class Alloc, class... Args&gt;
    T* uninitialized_construct_using_allocator(T* p, const Alloc&amp; alloc, Args&amp;&amp;... args);
 
  // allocator traits
  template&lt;class Alloc&gt; struct allocator_traits;
 
  // the default allocator
  template&lt;class T&gt; class allocator;
  template&lt;class T, class U&gt;
    bool operator==(const allocator&lt;T&gt;&amp;, const allocator&lt;U&gt;&amp;) noexcept;
  template&lt;class T, class U&gt;
    bool operator!=(const allocator&lt;T&gt;&amp;, const allocator&lt;U&gt;&amp;) noexcept;
 
  // specialized algorithms
  // special memory concepts
  template&lt;class I&gt;
    concept __NoThrowInputIterator = /* see definition */;   // exposition only
  template&lt;class I&gt;
    concept __NoThrowForwardIterator = /* see definition */; // exposition only
  template&lt;class S, class I&gt;
    concept __NoThrowSentinel = /* see definition */;        // exposition only
  template&lt;class R&gt;
    concept __NoThrowInputRange = /* see definition */;      // exposition only
  template&lt;class R&gt;
    concept __NoThrowForwardRange = /* see definition */;    // exposition only
 
  template&lt;class T&gt;
    constexpr T* addressof(T&amp; r) noexcept;
  template&lt;class T&gt;
    const T* addressof(const T&amp;&amp;) = delete;
  template&lt;class ForwardIt&gt;
    void uninitialized_default_construct(ForwardIt first, ForwardIt last);
  template&lt;class ExecutionPolicy, class ForwardIt&gt;
    void uninitialized_default_construct(ExecutionPolicy&amp;&amp; exec,
                                         ForwardIt first, ForwardIt last);
  template&lt;class ForwardIt, class Size&gt;
    ForwardIt uninitialized_default_construct_n(ForwardIt first, Size n);
  template&lt;class ExecutionPolicy, class ForwardIt, class Size&gt;
    ForwardIt uninitialized_default_construct_n(ExecutionPolicy&amp;&amp; exec,
                                                      ForwardIt first, Size n);
 
  namespace ranges {
    template&lt;__NoThrowForwardIterator I, __NoThrowSentinel&lt;I&gt; S&gt;
      requires DefaultConstructible&lt;iter_value_t&lt;I&gt;&gt;
        I uninitialized_default_construct(I first, S last);
    template&lt;__NoThrowForwardRange R&gt;
      requires DefaultConstructible&lt;iter_value_t&lt;iterator_t&lt;R&gt;&gt;&gt;
        safe_iterator_t&lt;R&gt; uninitialized_default_construct(R&amp;&amp; r);
 
    template&lt;__NoThrowForwardIterator I&gt;
      requires DefaultConstructible&lt;iter_value_t&lt;I&gt;&gt;
        I uninitialized_default_construct_n(I first, iter_difference_t&lt;I&gt; n);
  }
 
  template&lt;class ForwardIt&gt;
    void uninitialized_value_construct(ForwardIt first, ForwardIt last);
  template&lt;class ExecutionPolicy, class ForwardIt&gt;
    void uninitialized_value_construct(ExecutionPolicy&amp;&amp; exec,
                                       ForwardIt first, ForwardIt last);
  template&lt;class ForwardIt, class Size&gt;
    ForwardIt uninitialized_value_construct_n(ForwardIt first, Size n);
  template&lt;class ExecutionPolicy, class ForwardIt, class Size&gt;
    ForwardIt uninitialized_value_construct_n(ExecutionPolicy&amp;&amp; exec,
                                              ForwardIt first, Size n);
 
  namespace ranges {
    template&lt;__NoThrowForwardIterator I, __NoThrowSentinel&lt;I&gt; S&gt;
      requires DefaultConstructible&lt;iter_value_t&lt;I&gt;&gt;
        I uninitialized_value_construct(I first, S last);
    template&lt;__NoThrowForwardRange R&gt;
      requires DefaultConstructible&lt;iter_value_t&lt;iterator_t&lt;R&gt;&gt;&gt;
        safe_iterator_t&lt;R&gt; uninitialized_value_construct(R&amp;&amp; r);
 
    template&lt;__NoThrowForwardIterator I&gt;
      requires DefaultConstructible&lt;iter_value_t&lt;I&gt;&gt;
        I uninitialized_value_construct_n(I first, iter_difference_t&lt;I&gt; n);
  }
 
  template&lt;class InputIt, class ForwardIt&gt;
    ForwardIt uninitialized_copy(InputIt first, InputIt last, ForwardIt result);
  template&lt;class ExecutionPolicy, class InputIt, class ForwardIt&gt;
    ForwardIt uninitialized_copy(ExecutionPolicy&amp;&amp; exec,
                                 InputIt first, InputIt last, ForwardIt result);
  template&lt;class InputIt, class Size, class ForwardIt&gt;
    ForwardIt uninitialized_copy_n(InputIt first, Size n, ForwardIt result);
  template&lt;class ExecutionPolicy, class InputIt, class Size, class ForwardIt&gt;
    ForwardIt uninitialized_copy_n(ExecutionPolicy&amp;&amp; exec,
                                   InputIt first, Size n, ForwardIt result);
 
  namespace ranges {
    template&lt;class I, class O&gt;
    using uninitialized_copy_result = copy_result&lt;I, O&gt;;
    template&lt;InputIterator I, Sentinel&lt;I&gt; S1,
             __NoThrowForwardIterator O, __NoThrowSentinel&lt;O&gt; S2&gt;
      requires Constructible&lt;iter_value_t&lt;O&gt;, iter_reference_t&lt;I&gt;&gt;
        uninitialized_copy_result&lt;I, O&gt;
          uninitialized_copy(I ifirst, S1 ilast, O ofirst, S2 olast);
    template&lt;InputRange IR, __NoThrowForwardRange OR&gt;
      requires
        Constructible&lt;iter_value_t&lt;iterator_t&lt;OR&gt;&gt;, iter_reference_t&lt;iterator_t&lt;IR&gt;&gt;&gt;
        uninitialized_copy_result&lt;safe_iterator_t&lt;IR&gt;, safe_iterator_t&lt;OR&gt;&gt;
          uninitialized_copy(IR&amp;&amp; input_range, OR&amp;&amp; output_range);
 
    template&lt;class I, class O&gt;
      using uninitialized_copy_n_result = uninitialized_copy_result&lt;I, O&gt;;
    template&lt;InputIterator I, __NoThrowForwardIterator O, __NoThrowSentinel&lt;O&gt; S&gt;
      requires Constructible&lt;iter_value_t&lt;O&gt;, iter_reference_t&lt;I&gt;&gt;
        uninitialized_copy_n_result&lt;I, O&gt;
          uninitialized_copy_n(I ifirst, iter_difference_t&lt;I&gt; n, O ofirst, S olast);
  }
 
  template&lt;class InputIt, class ForwardIt&gt;
    ForwardIt uninitialized_move(InputIt first, InputIt last, ForwardIt result);
  template&lt;class ExecutionPolicy, class InputIt, class ForwardIt&gt;
    ForwardIt uninitialized_move(ExecutionPolicy&amp;&amp; exec,
                                 InputIt first, InputIt last, ForwardIt result);
  template&lt;class InputIt, class Size, class ForwardIt&gt;
    pair&lt;InputIt, ForwardIt&gt; uninitialized_move_n(InputIt first, Size n,
                                                  ForwardIt result);
  template&lt;class ExecutionPolicy, class InputIt, class Size, class ForwardIt&gt;
    pair&lt;InputIt, ForwardIt&gt; uninitialized_move_n(ExecutionPolicy&amp;&amp; exec,
                                                  InputIt first, Size n,
                                                  ForwardIt result);
 
  namespace ranges {
    template&lt;class I, class O&gt;
      using uninitialized_move_result = uninitialized_copy_result&lt;I, O&gt;;
    template&lt;InputIterator I, Sentinel&lt;I&gt; S1,
             __NoThrowForwardIterator O, __NoThrowSentinel&lt;O&gt; S2&gt;
      requires Constructible&lt;iter_value_t&lt;O&gt;, iter_rvalue_reference_t&lt;I&gt;&gt;
        uninitialized_move_result&lt;I, O&gt;
          uninitialized_move(I ifirst, S1 ilast, O ofirst, S2 olast);
    template&lt;InputRange IR, __NoThrowForwardRange OR&gt;
      requires Constructible&lt;iter_value_t&lt;iterator_t&lt;OR&gt;&gt;,
                             iter_rvalue_reference_t&lt;iterator_t&lt;IR&gt;&gt;&gt;
        uninitialized_move_result&lt;safe_iterator_t&lt;IR&gt;, safe_iterator_t&lt;OR&gt;&gt;
          uninitialized_move(IR&amp;&amp; input_range, OR&amp;&amp; output_range);
 
    template&lt;class I, class O&gt;
      using uninitialized_move_n_result = uninitialized_copy_result&lt;I, O&gt;;
    template&lt;InputIterator I,
             __NoThrowForwardIterator O, __NoThrowSentinel&lt;O&gt; S&gt;
      requires Constructible&lt;iter_value_t&lt;O&gt;, iter_rvalue_reference_t&lt;I&gt;&gt;
        uninitialized_move_n_result&lt;I, O&gt;
          uninitialized_move_n(I ifirst, iter_difference_t&lt;I&gt; n, O ofirst, S olast);
  }
 
  template&lt;class ForwardIt, class T&gt;
    void uninitialized_fill(ForwardIt first, ForwardIt last, const T&amp; x);
  template&lt;class ExecutionPolicy, class ForwardIt, class T&gt;
    void uninitialized_fill(ExecutionPolicy&amp;&amp; exec,
                            ForwardIt first, ForwardIt last, const T&amp; x);
  template&lt;class ForwardIt, class Size, class T&gt;
    ForwardIt uninitialized_fill_n(ForwardIt first, Size n, const T&amp; x);
  template&lt;class ExecutionPolicy, class ForwardIt, class Size, class T&gt;
    ForwardIt uninitialized_fill_n(ExecutionPolicy&amp;&amp; exec,
                                   ForwardIt first, Size n, const T&amp; x);
 
  namespace ranges {
    template&lt;__NoThrowForwardIterator I, __NoThrowSentinel&lt;I&gt; S, class T&gt;
      requires Constructible&lt;iter_value_t&lt;I&gt;, const T&amp;&gt;
        I uninitialized_fill(I first, S last, const T&amp; x);
    template&lt;__NoThrowForwardRange R, class T&gt;
      requires Constructible&lt;iter_value_t&lt;iterator_t&lt;R&gt;&gt;, const T&amp;&gt;
        safe_iterator_t&lt;R&gt; uninitialized_fill(R&amp;&amp; r, const T&amp; x);
 
    template&lt;__NoThrowForwardIterator I, class T&gt;
      requires Constructible&lt;iter_value_t&lt;I&gt;, const T&amp;&gt;
        I uninitialized_fill_n(I first, iter_difference_t&lt;I&gt; n, const T&amp; x);
  }
 
  template&lt;class T&gt;
    void destroy_at(T* location);
  template&lt;class ForwardIt&gt;
    void destroy(ForwardIt first, ForwardIt last);
  template&lt;class ExecutionPolicy, class ForwardIt&gt;
    void destroy(ExecutionPolicy&amp;&amp; exec,
                 ForwardIt first, ForwardIt last);
  template&lt;class ForwardIt, class Size&gt;
    ForwardIt destroy_n(ForwardIt first, Size n);
  template&lt;class ExecutionPolicy, class ForwardIt, class Size&gt;
    ForwardIt destroy_n(ExecutionPolicy&amp;&amp; exec,
                        ForwardIt first, Size n);
 
  namespace ranges {
    template&lt;Destructible T&gt;
      void destroy_at(T* location) noexcept;
 
    template&lt;__NoThrowInputIterator I, __NoThrowSentinel&lt;I&gt; S&gt;
      requires Destructible&lt;iter_value_t&lt;I&gt;&gt;
        I destroy(I first, S last) noexcept;
    template&lt;__NoThrowInputRange R&gt;
      requires Destructible&lt;iter_value_t&lt;iterator_t&lt;R&gt;&gt;
        safe_iterator_t&lt;R&gt; destroy(R&amp;&amp; r) noexcept;
 
    template&lt;__NoThrowInputIterator I&gt;
      requires Destructible&lt;iter_value_t&lt;I&gt;&gt;
        I destroy_n(I first, iter_difference_t&lt;I&gt; n) noexcept;
  }
 
  // class template unique_­ptr
  template&lt;class T&gt; struct default_delete;
  template&lt;class T&gt; struct default_delete&lt;T[]&gt;;
  template&lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr;
  template&lt;class T, class D&gt; class unique_ptr&lt;T[], D&gt;;
 
  template&lt;class T, class... Args&gt;
    unique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... args);                          // T is not array
  template&lt;class T&gt;
    unique_ptr&lt;T&gt; make_unique(size_t n);                                // T is U[]
  template&lt;class T, class... Args&gt;
    /* unspecified */ make_unique(Args&amp;&amp;...) = delete;                  // T is U[N]
 
  template&lt;class T&gt;
    unique_ptr&lt;T&gt; make_unique_default_init();                           // T is not array
  template&lt;class T&gt;
    unique_ptr&lt;T&gt; make_unique_default_init(size_t n);                   // T is U[]
  template&lt;class T, class... Args&gt;
    /* unspecified */ make_unique_default_init(Args&amp;&amp;...) = delete;     // T is U[N]
 
  template&lt;class T, class D&gt;
    void swap(unique_ptr&lt;T, D&gt;&amp; x, unique_ptr&lt;T, D&gt;&amp; y) noexcept;
 
  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator==(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator!=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator&lt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator&gt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator&lt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator&gt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
 
  template&lt;class T, class D&gt;
    bool operator==(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;
  template&lt;class T, class D&gt;
    bool operator==(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y) noexcept;
  template&lt;class T, class D&gt;
    bool operator!=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;
  template&lt;class T, class D&gt;
    bool operator!=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y) noexcept;
  template&lt;class T, class D&gt;
    bool operator&lt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template&lt;class T, class D&gt;
    bool operator&lt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
  template&lt;class T, class D&gt;
    bool operator&gt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template&lt;class T, class D&gt;
    bool operator&gt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
  template&lt;class T, class D&gt;
    bool operator&lt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template&lt;class T, class D&gt;
    bool operator&lt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
  template&lt;class T, class D&gt;
    bool operator&gt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);
  template&lt;class T, class D&gt;
    bool operator&gt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);
 
  template&lt;class E, class T, class Y, class D&gt;
    basic_ostream&lt;E, T&gt;&amp; operator&lt;&lt;(basic_ostream&lt;E, T&gt;&amp; os, const unique_ptr&lt;Y, D&gt;&amp; p);
 
  // class bad_weak_ptr
  class bad_weak_ptr;
 
  // class template shared_ptr
  template&lt;class T&gt; class shared_ptr;
 
  // shared_ptr creation
  template&lt;class T, class... Args&gt;
    shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);                          // T is not array
  template&lt;class T, class A, class... Args&gt;
    shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);          // T is not array
 
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; make_shared(size_t N);                                // T is U[]
  template&lt;class T, class A&gt;
    shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, size_t N);                // T is U[]
 
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; make_shared();                                        // T is U[N]
  template&lt;class T, class A&gt;
    shared_ptr&lt;T&gt; allocate_shared(const A&amp; a);                          // T is U[N]
 
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; make_shared(size_t N, const remove_extent_t&lt;T&gt;&amp; u);   // T is U[]
  template&lt;class T, class A&gt;
    shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, size_t N,
                                  const remove_extent_t&lt;T&gt;&amp; u);         // T is U[]
 
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; make_shared(const remove_extent_t&lt;T&gt;&amp; u);                 // T is U[N]
  template&lt;class T, class A&gt;
    shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, const remove_extent_t&lt;T&gt;&amp; u); // T is U[N]
 
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; make_shared_default_init();                           // T is not U[]
  template&lt;class T, class A&gt;
    shared_ptr&lt;T&gt; allocate_shared_default_init(const A&amp; a);             // T is not U[]
 
  template&lt;class T&gt;
    shared_ptr&lt;T&gt; make_shared_default_init(size_t N);                   // T is U[]
  template&lt;class T, class A&gt;
    shared_ptr&lt;T&gt; allocate_shared_default_init(const A&amp; a, size_t N);   // T is U[]
 
  // shared_ptr comparisons
  template&lt;class T, class U&gt;
    bool operator==(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator!=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&gt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;
 
  template&lt;class T&gt;
    bool operator==(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template&lt;class T&gt;
    bool operator==(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
  template&lt;class T&gt;
    bool operator!=(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template&lt;class T&gt;
    bool operator!=(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
  template&lt;class T&gt;
    bool operator&lt;(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template&lt;class T&gt;
    bool operator&lt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
  template&lt;class T&gt;
    bool operator&gt;(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template&lt;class T&gt;
    bool operator&gt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
  template&lt;class T&gt;
    bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template&lt;class T&gt;
    bool operator&lt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
  template&lt;class T&gt;
    bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;
  template&lt;class T&gt;
    bool operator&gt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;
 
  // shared_ptr specialized algorithms
  template&lt;class T&gt;
    void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp; b) noexcept;
 
  // shared_ptr casts
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; static_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; static_pointer_cast(shared_ptr&lt;U&gt;&amp;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; dynamic_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; dynamic_pointer_cast(shared_ptr&lt;U&gt;&amp;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; const_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; const_pointer_cast(shared_ptr&lt;U&gt;&amp;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; reinterpret_pointer_cast(const shared_ptr&lt;U&gt;&amp; r) noexcept;
  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; reinterpret_pointer_cast(shared_ptr&lt;U&gt;&amp;&amp; r) noexcept;
 
  // shared_ptr get_deleter
  template&lt;class D, class T&gt;
    D* get_deleter(const shared_ptr&lt;T&gt;&amp; p) noexcept;
 
  // shared_ptr I/O
  template&lt;class E, class T, class Y&gt;
    basic_ostream&lt;E, T&gt;&amp; operator&lt;&lt;(basic_ostream&lt;E, T&gt;&amp; os, const shared_ptr&lt;Y&gt;&amp; p);
 
  // class template weak_ptr
  template&lt;class T&gt; class weak_ptr;
 
  // weak_ptr specialized algorithms
  template&lt;class T&gt; void swap(weak_ptr&lt;T&gt;&amp; a, weak_ptr&lt;T&gt;&amp; b) noexcept;
 
  // class template owner_less
  template&lt;class T = void&gt; struct owner_less;
 
  // class template enable_shared_from_this
  template&lt;class T&gt; class enable_shared_from_this;
 
  // hash support
  template&lt;class T&gt; struct hash;
  template&lt;class T, class D&gt; struct hash&lt;unique_ptr&lt;T, D&gt;&gt;;
  template&lt;class T&gt; struct hash&lt;shared_ptr&lt;T&gt;&gt;;
 
  // atomic smart pointers
  template&lt;class T&gt; struct atomic;
  template&lt;class T&gt; struct atomic&lt;shared_ptr&lt;T&gt;&gt;;
  template&lt;class T&gt; struct atomic&lt;weak_ptr&lt;T&gt;&gt;;
 
  // shared_ptr atomic access
  template&lt;class T&gt;
  bool atomic_is_lock_free(const shared_ptr&lt;T&gt;* p);
  template&lt;class T&gt;
  shared_ptr&lt;T&gt; atomic_load(const shared_ptr&lt;T&gt;* p);
  template&lt;class T&gt;
  shared_ptr&lt;T&gt; atomic_load_explicit(const shared_ptr&lt;T&gt;* p, memory_order mo);
  template&lt;class T&gt;
  void atomic_store(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r);
  template&lt;class T&gt;
  void atomic_store_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r, memory_order mo);
  template&lt;class T&gt;
  shared_ptr&lt;T&gt; atomic_exchange(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r);
  template&lt;class T&gt;
  shared_ptr&lt;T&gt; atomic_exchange_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r,
                                         memory_order mo);
  template&lt;class T&gt;
  bool atomic_compare_exchange_weak(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w);
  template&lt;class T&gt;
  bool atomic_compare_exchange_strong(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w);
  template&lt;class T&gt;
  bool atomic_compare_exchange_weak_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v,
                                             shared_ptr&lt;T&gt; w, memory_order success,
                                             memory_order failure);
  template&lt;class T&gt;
  bool atomic_compare_exchange_strong_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v,
                                               shared_ptr&lt;T&gt; w, memory_order success, 
                                               memory_order failure);
}</pre></div> <h4 id="Helper_concepts">Helper concepts</h4> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class I&gt;
concept __NoThrowInputIterator = // exposition only
  InputIterator&lt;I&gt; &amp;&amp;
  is_lvalue_reference_v&lt;iter_reference_t&lt;I&gt;&gt; &amp;&amp;
  Same&lt;remove_cvref_t&lt;iter_reference_t&lt;I&gt;&gt;, iter_value_t&lt;I&gt;&gt;;
 
template&lt;class S, class I&gt;
concept __NoThrowSentinel = Sentinel&lt;S, I&gt;; // exposition only
 
template&lt;class R&gt;
concept __NoThrowInputRange = // exposition only
  Range&lt;R&gt; &amp;&amp;
  __NoThrowInputIterator&lt;iterator_t&lt;R&gt;&gt; &amp;&amp;
  __NoThrowSentinel&lt;sentinel_t&lt;R&gt;, iterator_t&lt;R&gt;&gt;;
 
template&lt;class I&gt;
concept __NoThrowForwardIterator = // exposition only
  __NoThrowInputIterator&lt;I&gt; &amp;&amp;
  ForwardIterator&lt;I&gt; &amp;&amp;
  __NoThrowSentinel&lt;I, I&gt;;
 
template&lt;class R&gt;
concept __NoThrowForwardRange = // exposition only
  __NoThrowInputRange&lt;R&gt; &amp;&amp;
  __NoThrowForwardIterator&lt;iterator_t&lt;R&gt;&gt;;</pre></div> <p>Note: These names are only for exposition, they are not part of the interface.</p>
<h4 id="Class_template_std::pointer_traits">Class template <code><a href="../memory/pointer_traits" title="cpp/memory/pointer traits">std::pointer_traits</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template &lt;class Ptr&gt; struct pointer_traits {
    using pointer = Ptr;
    using element_type = /* see definition */;
    using difference_type = /* see definition */;
    template &lt;class U&gt; using rebind = /* see definition */;
    static pointer pointer_to(/* see definition */ r);
  };
 
  template &lt;class T&gt; struct pointer_traits&lt;T*&gt; {
    using pointer = T*;
    using element_type = T;
    using difference_type = ptrdiff_t;
    template &lt;class U&gt; using rebind = U*;
    static constexpr pointer pointer_to(/* see definition */ r) noexcept;
  };
}</pre></div> <h4 id="Class_std::allocator_arg_t">Class <code><a href="../memory/allocator_arg_t" title="cpp/memory/allocator arg t">std::allocator_arg_t</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  struct allocator_arg_t { explicit allocator_arg_t() = default; };
  inline constexpr allocator_arg_t allocator_arg{};
}</pre></div> <h4 id="Class_template_std::allocator_traits">Class template <code><a href="../memory/allocator_traits" title="cpp/memory/allocator traits">std::allocator_traits</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class Alloc&gt; struct allocator_traits {
    using allocator_type     = Alloc;
 
    using value_type         = typename Alloc::value_type;
 
    using pointer            = /* see definition */;
    using const_pointer      = /* see definition */;
    using void_pointer       = /* see definition */;
    using const_void_pointer = /* see definition */;
 
    using difference_type    = /* see definition */;
    using size_type          = /* see definition */;
 
    using propagate_on_container_copy_assignment = /* see definition */;
    using propagate_on_container_move_assignment = /* see definition */;
    using propagate_on_container_swap            = /* see definition */;
    using is_always_equal                        = /* see definition */;
 
    template&lt;class T&gt; using rebind_alloc = /* see definition */;
    template&lt;class T&gt; using rebind_traits = allocator_traits&lt;rebind_alloc&lt;T&gt;&gt;;
 
    [[nodiscard]] static pointer allocate(Alloc&amp; a, size_type n);
    [[nodiscard]] static pointer allocate(Alloc&amp; a, size_type n, const_void_pointer hint);
 
    static void deallocate(Alloc&amp; a, pointer p, size_type n);
 
    template&lt;class T, class... Args&gt;
      static void construct(Alloc&amp; a, T* p, Args&amp;&amp;... args);
 
    template&lt;class T&gt;
      static void destroy(Alloc&amp; a, T* p);
 
    static size_type max_size(const Alloc&amp; a) noexcept;
 
    static Alloc select_on_container_copy_construction(const Alloc&amp; rhs);
  };
}</pre></div> <h4 id="Class_template_std::allocator">Class template <code><a href="../memory/allocator" title="cpp/memory/allocator">std::allocator</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T&gt; class allocator {
   public:
    using value_type                             = T;
    using size_type                              = size_t;
    using difference_type                        = ptrdiff_t;
    using propagate_on_container_move_assignment = true_type;
    using is_always_equal                        = true_type;
 
    constexpr allocator() noexcept;
    constexpr allocator(const allocator&amp;) noexcept;
    template&lt;class U&gt; constexpr allocator(const allocator&lt;U&gt;&amp;) noexcept;
    ~allocator();
    allocator&amp; operator=(const allocator&amp;) = default;
 
    [[nodiscard]] T* allocate(size_t n);
    void deallocate(T* p, size_t n);
  };
}</pre></div> <h4 id="Class_template_std::default_delete">Class template <code><a href="../memory/default_delete" title="cpp/memory/default delete">std::default_delete</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T&gt; struct default_delete {
    constexpr default_delete() noexcept = default;
    template&lt;class U&gt; default_delete(const default_delete&lt;U&gt;&amp;) noexcept;
    void operator()(T*) const;
  };
 
  template&lt;class T&gt; struct default_delete&lt;T[]&gt; {
    constexpr default_delete() noexcept = default;
    template&lt;class U&gt; default_delete(const default_delete&lt;U[]&gt;&amp;) noexcept;
    template&lt;class U&gt; void operator()(U* ptr) const;
  };
}</pre></div> <h4 id="Class_template_std::unique_ptr">Class template <code><a href="../memory/unique_ptr" title="cpp/memory/unique ptr">std::unique_ptr</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr {
  public:
    using pointer      = /* see definition */;
    using element_type = T;
    using deleter_type = D;
 
    // constructors
    constexpr unique_ptr() noexcept;
    explicit unique_ptr(pointer p) noexcept;
    unique_ptr(pointer p, /* see definition */ d1) noexcept;
    unique_ptr(pointer p, /* see definition */ d2) noexcept;
    unique_ptr(unique_ptr&amp;&amp; u) noexcept;
    constexpr unique_ptr(nullptr_t) noexcept;
    template&lt;class U, class E&gt;
      unique_ptr(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
 
    // destructor
    ~unique_ptr();
 
    // assignment
    unique_ptr&amp; operator=(unique_ptr&amp;&amp; u) noexcept;
    template&lt;class U, class E&gt;
      unique_ptr&amp; operator=(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
    unique_ptr&amp; operator=(nullptr_t) noexcept;
 
    // observers
    add_lvalue_reference_t&lt;T&gt; operator*() const;
    pointer operator-&gt;() const noexcept;
    pointer get() const noexcept;
    deleter_type&amp; get_deleter() noexcept;
    const deleter_type&amp; get_deleter() const noexcept;
    explicit operator bool() const noexcept;
 
    // modifiers
    pointer release() noexcept;
    void reset(pointer p = pointer()) noexcept;
    void swap(unique_ptr&amp; u) noexcept;
 
    // disable copy from lvalue
    unique_ptr(const unique_ptr&amp;) = delete;
    unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;
  };
 
  template&lt;class T, class D&gt; class unique_ptr&lt;T[], D&gt; {
  public:
    using pointer      = /* see definition */;
    using element_type = T;
    using deleter_type = D;
 
    // constructors
    constexpr unique_ptr() noexcept;
    template&lt;class U&gt; explicit unique_ptr(U p) noexcept;
    template&lt;class U&gt; unique_ptr(U p, /* see definition */ d) noexcept;
    template&lt;class U&gt; unique_ptr(U p, /* see definition */ d) noexcept;
    unique_ptr(unique_ptr&amp;&amp; u) noexcept;
    template&lt;class U, class E&gt;
      unique_ptr(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
    constexpr unique_ptr(nullptr_t) noexcept;
 
    // destructor
    ~unique_ptr();
 
    // assignment
    unique_ptr&amp; operator=(unique_ptr&amp;&amp; u) noexcept;
    template&lt;class U, class E&gt;
      unique_ptr&amp; operator=(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;
    unique_ptr&amp; operator=(nullptr_t) noexcept;
 
    // observers
    T&amp; operator[](size_t i) const;
    pointer get() const noexcept;
    deleter_type&amp; get_deleter() noexcept;
    const deleter_type&amp; get_deleter() const noexcept;
    explicit operator bool() const noexcept;
 
    // modifiers
    pointer release() noexcept;
    template&lt;class U&gt; void reset(U p) noexcept;
    void reset(nullptr_t = nullptr) noexcept;
    void swap(unique_ptr&amp; u) noexcept;
 
    // disable copy from lvalue
    unique_ptr(const unique_ptr&amp;) = delete;
    unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;
  };
}</pre></div> <h4 id="Class_std::bad_weak_ptr">Class <code><a href="../memory/bad_weak_ptr" title="cpp/memory/bad weak ptr">std::bad_weak_ptr</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  class bad_weak_ptr : public exception {
  public:
    bad_weak_ptr() noexcept;
  };
}</pre></div> <h4 id="Class_template_std::shared_ptr">Class template <code><a href="../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T&gt; class shared_ptr {
  public:
    using element_type = remove_extent_t&lt;T&gt;;
    using weak_type    = weak_ptr&lt;T&gt;;
 
    // constructors
    constexpr shared_ptr() noexcept;
    constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }
    template&lt;class Y&gt;
      explicit shared_ptr(Y* p);
    template&lt;class Y, class D&gt;
      shared_ptr(Y* p, D d);
    template&lt;class Y, class D, class A&gt;
      shared_ptr(Y* p, D d, A a);
    template&lt;class D&gt;
      shared_ptr(nullptr_t p, D d);
    template&lt;class D, class A&gt;
      shared_ptr(nullptr_t p, D d, A a);
    template&lt;class Y&gt;
      shared_ptr(const shared_ptr&lt;Y&gt;&amp; r, element_type* p) noexcept;
    template&lt;class Y&gt;
      shared_ptr(shared_ptr&lt;Y&gt;&amp;&amp; r, element_type* p) noexcept;
    shared_ptr(const shared_ptr&amp; r) noexcept;
    template&lt;class Y&gt;
      shared_ptr(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
    shared_ptr(shared_ptr&amp;&amp; r) noexcept;
    template&lt;class Y&gt;
      shared_ptr(shared_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
    template&lt;class Y&gt;
      explicit shared_ptr(const weak_ptr&lt;Y&gt;&amp; r);
    template&lt;class Y, class D&gt;
      shared_ptr(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
 
    // destructor
    ~shared_ptr();
 
    // assignment
    shared_ptr&amp; operator=(const shared_ptr&amp; r) noexcept;
    template&lt;class Y&gt;
      shared_ptr&amp; operator=(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
    shared_ptr&amp; operator=(shared_ptr&amp;&amp; r) noexcept;
    template&lt;class Y&gt;
      shared_ptr&amp; operator=(shared_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
    template&lt;class Y, class D&gt;
      shared_ptr&amp; operator=(unique_ptr&lt;Y, D&gt;&amp;&amp; r);
 
    // modifiers
    void swap(shared_ptr&amp; r) noexcept;
    void reset() noexcept;
    template&lt;class Y&gt;
      void reset(Y* p);
    template&lt;class Y, class D&gt;
      void reset(Y* p, D d);
    template&lt;class Y, class D, class A&gt;
      void reset(Y* p, D d, A a);
 
    // observers
    element_type* get() const noexcept;
    T&amp; operator*() const noexcept;
    T* operator-&gt;() const noexcept;
    element_type&amp; operator[](ptrdiff_t i) const;
    long use_count() const noexcept;
    explicit operator bool() const noexcept;
    template&lt;class U&gt;
      bool owner_before(const shared_ptr&lt;U&gt;&amp; b) const noexcept;
    template&lt;class U&gt;
      bool owner_before(const weak_ptr&lt;U&gt;&amp; b) const noexcept;
  };
 
  template&lt;class T&gt;
    shared_ptr(weak_ptr&lt;T&gt;) -&gt; shared_ptr&lt;T&gt;;
  template&lt;class T, class D&gt;
    shared_ptr(unique_ptr&lt;T, D&gt;) -&gt; shared_ptr&lt;T&gt;;
}</pre></div> <h4 id="Class_template_std::weak_ptr">Class template <code><a href="../memory/weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T&gt; class weak_ptr {
  public:
    using element_type = remove_extent_t&lt;T&gt;;
 
    // constructors
    constexpr weak_ptr() noexcept;
    template&lt;class Y&gt;
      weak_ptr(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
    weak_ptr(const weak_ptr&amp; r) noexcept;
    template&lt;class Y&gt;
      weak_ptr(const weak_ptr&lt;Y&gt;&amp; r) noexcept;
    weak_ptr(weak_ptr&amp;&amp; r) noexcept;
    template&lt;class Y&gt;
      weak_ptr(weak_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
 
    // destructor
    ~weak_ptr();
 
    // assignment
    weak_ptr&amp; operator=(const weak_ptr&amp; r) noexcept;
    template&lt;class Y&gt;
      weak_ptr&amp; operator=(const weak_ptr&lt;Y&gt;&amp; r) noexcept;
    template&lt;class Y&gt;
      weak_ptr&amp; operator=(const shared_ptr&lt;Y&gt;&amp; r) noexcept;
    weak_ptr&amp; operator=(weak_ptr&amp;&amp; r) noexcept;
    template&lt;class Y&gt;
      weak_ptr&amp; operator=(weak_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
 
    // modifiers
    void swap(weak_ptr&amp; r) noexcept;
    void reset() noexcept;
 
    // observers
    long use_count() const noexcept;
    bool expired() const noexcept;
    shared_ptr&lt;T&gt; lock() const noexcept;
    template&lt;class U&gt;
      bool owner_before(const shared_ptr&lt;U&gt;&amp; b) const noexcept;
    template&lt;class U&gt;
      bool owner_before(const weak_ptr&lt;U&gt;&amp; b) const noexcept;
  };
 
  template&lt;class T&gt;
    weak_ptr(shared_ptr&lt;T&gt;) -&gt; weak_ptr&lt;T&gt;;
}</pre></div> <h4 id="Class_template_std::owner_less">Class template <code><a href="../memory/owner_less" title="cpp/memory/owner less">std::owner_less</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T = void&gt; struct owner_less;
 
  template&lt;class T&gt; struct owner_less&lt;shared_ptr&lt;T&gt;&gt; {
    bool operator()(const shared_ptr&lt;T&gt;&amp;, const shared_ptr&lt;T&gt;&amp;) const noexcept;
    bool operator()(const shared_ptr&lt;T&gt;&amp;, const weak_ptr&lt;T&gt;&amp;) const noexcept;
    bool operator()(const weak_ptr&lt;T&gt;&amp;, const shared_ptr&lt;T&gt;&amp;) const noexcept;
  };
 
  template&lt;class T&gt; struct owner_less&lt;weak_ptr&lt;T&gt;&gt; {
    bool operator()(const weak_ptr&lt;T&gt;&amp;, const weak_ptr&lt;T&gt;&amp;) const noexcept;
    bool operator()(const shared_ptr&lt;T&gt;&amp;, const weak_ptr&lt;T&gt;&amp;) const noexcept;
    bool operator()(const weak_ptr&lt;T&gt;&amp;, const shared_ptr&lt;T&gt;&amp;) const noexcept;
  };
 
  template&lt;&gt; struct owner_less&lt;void&gt; {
    template&lt;class T, class U&gt;
      bool operator()(const shared_ptr&lt;T&gt;&amp;, const shared_ptr&lt;U&gt;&amp;) const noexcept;
    template&lt;class T, class U&gt;
      bool operator()(const shared_ptr&lt;T&gt;&amp;, const weak_ptr&lt;U&gt;&amp;) const noexcept;
    template&lt;class T, class U&gt;
      bool operator()(const weak_ptr&lt;T&gt;&amp;, const shared_ptr&lt;U&gt;&amp;) const noexcept;
    template&lt;class T, class U&gt;
      bool operator()(const weak_ptr&lt;T&gt;&amp;, const weak_ptr&lt;U&gt;&amp;) const noexcept;
 
    using is_transparent = /* unspecified */;
  };
}</pre></div> <h4 id="Class_template_std::enable_shared_from_this">Class template <code><a href="../memory/enable_shared_from_this" title="cpp/memory/enable shared from this">std::enable_shared_from_this</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T&gt; class enable_shared_from_this {
  protected:
    constexpr enable_shared_from_this() noexcept;
    enable_shared_from_this(const enable_shared_from_this&amp;) noexcept;
    enable_shared_from_this&amp; operator=(const enable_shared_from_this&amp;) noexcept;
    ~enable_shared_from_this();
 
  public:
    shared_ptr&lt;T&gt; shared_from_this();
    shared_ptr&lt;T const&gt; shared_from_this() const;
    weak_ptr&lt;T&gt; weak_from_this() noexcept;
    weak_ptr&lt;T const&gt; weak_from_this() const noexcept;
 
  private:
    mutable weak_ptr&lt;T&gt; weak_this;  // exposition only
  };
}</pre></div> <h4 id="Class_template_std::atomic.27s_specialization_for_std::shared_ptr">Class template <code><a href="../atomic/atomic" title="cpp/atomic/atomic">std::atomic</a></code>'s specialization for <code><a href="../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T&gt; struct atomic&lt;shared_ptr&lt;T&gt;&gt; {
    using value_type = shared_ptr&lt;T&gt;;
    static constexpr bool is_always_lock_free = /* implementation-defined */;
 
    bool is_lock_free() const noexcept;
    void store(shared_ptr&lt;T&gt; desired, memory_order order = memory_order::seq_cst) noexcept;
    shared_ptr&lt;T&gt; load(memory_order order = memory_order::seq_cst) const noexcept;
    operator shared_ptr&lt;T&gt;() const noexcept;
 
    shared_ptr&lt;T&gt; exchange(shared_ptr&lt;T&gt; desired,
                           memory_order order = memory_order::seq_cst) noexcept;
 
    bool compare_exchange_weak(shared_ptr&lt;T&gt;&amp; expected, shared_ptr&lt;T&gt; desired,
                               memory_order success, memory_order failure) noexcept;
    bool compare_exchange_strong(shared_ptr&lt;T&gt;&amp; expected, shared_ptr&lt;T&gt; desired,
                                 memory_order success, memory_order failure) noexcept;
 
    bool compare_exchange_weak(shared_ptr&lt;T&gt;&amp; expected, shared_ptr&lt;T&gt; desired,
                               memory_order order = memory_order::seq_cst) noexcept;
    bool compare_exchange_strong(shared_ptr&lt;T&gt;&amp; expected, shared_ptr&lt;T&gt; desired,
                                 memory_order order = memory_order::seq_cst) noexcept;
 
    constexpr atomic() noexcept = default;
    atomic(shared_ptr&lt;T&gt; desired) noexcept;
    atomic(const atomic&amp;) = delete;
    void operator=(const atomic&amp;) = delete;
    void operator=(shared_ptr&lt;T&gt; desired) noexcept;
 
  private:
    shared_ptr&lt;T&gt; p;            // exposition only
  };
}</pre></div> <h4 id="Class_template_std::atomic.27s_specialization_for_std::weak_ptr">Class template <code><a href="../atomic/atomic" title="cpp/atomic/atomic">std::atomic</a></code>'s specialization for <code><a href="../memory/weak_ptr" title="cpp/memory/weak ptr">std::weak_ptr</a></code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std {
  template&lt;class T&gt; struct atomic&lt;weak_ptr&lt;T&gt;&gt; {
    using value_type = weak_ptr&lt;T&gt;;
    static constexpr bool is_always_lock_free = /* implementation-defined */;
 
    bool is_lock_free() const noexcept;
    void store(weak_ptr&lt;T&gt; desired, memory_order order = memory_order::seq_cst) noexcept;
    weak_ptr&lt;T&gt; load(memory_order order = memory_order::seq_cst) const noexcept;
    operator weak_ptr&lt;T&gt;() const noexcept;
 
    weak_ptr&lt;T&gt; exchange(weak_ptr&lt;T&gt; desired,
                         memory_order order = memory_order::seq_cst) noexcept;
 
    bool compare_exchange_weak(weak_ptr&lt;T&gt;&amp; expected, weak_ptr&lt;T&gt; desired,
                               memory_order success, memory_order failure) noexcept;
    bool compare_exchange_strong(weak_ptr&lt;T&gt;&amp; expected, weak_ptr&lt;T&gt; desired,
                                 memory_order success, memory_order failure) noexcept;
 
    bool compare_exchange_weak(weak_ptr&lt;T&gt;&amp; expected, weak_ptr&lt;T&gt; desired,
                               memory_order order = memory_order::seq_cst) noexcept;
    bool compare_exchange_strong(weak_ptr&lt;T&gt;&amp; expected, weak_ptr&lt;T&gt; desired,
                                 memory_order order = memory_order::seq_cst) noexcept;
 
    constexpr atomic() noexcept = default;
    atomic(weak_ptr&lt;T&gt; desired) noexcept;
    atomic(const atomic&amp;) = delete;
    void operator=(const atomic&amp;) = delete;
    void operator=(weak_ptr&lt;T&gt; desired) noexcept;
 
  private:
    weak_ptr&lt;T&gt; p;              // exposition only
  };
}</pre></div>          <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/header/memory" class="_attribution-link">http://en.cppreference.com/w/cpp/header/memory</a>
  </p>
</div>
