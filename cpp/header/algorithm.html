   <h1 id="firstHeading" class="firstHeading">Standard library header &lt;algorithm&gt;</h1>            <p>This header is part of the <a href="../algorithm" title="cpp/algorithm">algorithm</a> library.</p>
<h3 id="Functions">Functions</h3> <table class="t-dsc-begin"> <tr> <td colspan="2"> <h5 id="Non-modifying_sequence_operations">  Non-modifying sequence operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/all_any_none_of" title="cpp/algorithm/all any none of"> <span class="t-lines"><span>all_of</span><span>any_of</span><span>none_of</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> checks if a predicate is <code>true</code> for all, any or none of the elements in a range <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/for_each" title="cpp/algorithm/for each"> <span class="t-lines"><span>for_each</span></span></a></div> </td> <td> applies a function to a range of elements <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/for_each_n" title="cpp/algorithm/for each n"> <span class="t-lines"><span>for_each_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> applies a function object to the first n elements of a sequence <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/count_if" title="cpp/algorithm/count"> <span class="t-lines"><span>count</span><span>count_if</span></span></a></div> </td> <td> returns the number of elements satisfying specific criteria <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/mismatch" title="cpp/algorithm/mismatch"> <span class="t-lines"><span>mismatch</span></span></a></div> </td> <td> finds the first position where two ranges differ <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/find_if_not" title="cpp/algorithm/find"> <span class="t-lines"><span>find</span><span>find_if</span><span>find_if_not</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> finds the first element satisfying specific criteria <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/find_end" title="cpp/algorithm/find end"> <span class="t-lines"><span>find_end</span></span></a></div> </td> <td> finds the last sequence of elements in a certain range <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/find_first_of" title="cpp/algorithm/find first of"> <span class="t-lines"><span>find_first_of</span></span></a></div> </td> <td> searches for any one of a set of elements <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/adjacent_find" title="cpp/algorithm/adjacent find"> <span class="t-lines"><span>adjacent_find</span></span></a></div> </td> <td> finds the first two adjacent items that are equal (or satisfy a given predicate) <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/search" title="cpp/algorithm/search"> <span class="t-lines"><span>search</span></span></a></div> </td> <td> searches for a range of elements <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/search_n" title="cpp/algorithm/search n"> <span class="t-lines"><span>search_n</span></span></a></div> </td> <td> searches a range for a number of consecutive copies of an element <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Modifying_sequence_operations">  Modifying sequence operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/copy" title="cpp/algorithm/copy"> <span class="t-lines"><span>copy</span><span>copy_if</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> copies a range of elements to a new location <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/copy_n" title="cpp/algorithm/copy n"> <span class="t-lines"><span>copy_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> copies a number of elements to a new location <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/copy_backward" title="cpp/algorithm/copy backward"> <span class="t-lines"><span>copy_backward</span></span></a></div> </td> <td> copies a range of elements in backwards order <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/move" title="cpp/algorithm/move"> <span class="t-lines"><span>move</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> moves a range of elements to a new location <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/move_backward" title="cpp/algorithm/move backward"> <span class="t-lines"><span>move_backward</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> moves a range of elements to a new location in backwards order <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/fill" title="cpp/algorithm/fill"> <span class="t-lines"><span>fill</span></span></a></div> </td> <td> copy-assigns the given value to every element in a range <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/fill_n" title="cpp/algorithm/fill n"> <span class="t-lines"><span>fill_n</span></span></a></div> </td> <td> copy-assigns the given value to N elements in a range <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/transform" title="cpp/algorithm/transform"> <span class="t-lines"><span>transform</span></span></a></div> </td> <td> applies a function to a range of elements <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/generate" title="cpp/algorithm/generate"> <span class="t-lines"><span>generate</span></span></a></div> </td> <td> assigns the results of successive function calls to every element in a range <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/generate_n" title="cpp/algorithm/generate n"> <span class="t-lines"><span>generate_n</span></span></a></div> </td> <td> assigns the results of successive function calls to N elements in a range <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/remove" title="cpp/algorithm/remove"> <span class="t-lines"><span>remove</span><span>remove_if</span></span></a></div> </td> <td> removes elements satisfying specific criteria <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/remove_copy" title="cpp/algorithm/remove copy"> <span class="t-lines"><span>remove_copy</span><span>remove_copy_if</span></span></a></div> </td> <td> copies a range of elements omitting those that satisfy specific criteria <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/replace" title="cpp/algorithm/replace"> <span class="t-lines"><span>replace</span><span>replace_if</span></span></a></div> </td> <td> replaces all values satisfying specific criteria with another value <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/replace_copy_if" title="cpp/algorithm/replace copy"> <span class="t-lines"><span>replace_copy</span><span>replace_copy_if</span></span></a></div> </td> <td> copies a range, replacing elements satisfying specific criteria with another value <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/swap" title="cpp/algorithm/swap"> <span class="t-lines"><span>swap</span></span></a></div> </td> <td> swaps the values of two objects <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/swap_ranges" title="cpp/algorithm/swap ranges"> <span class="t-lines"><span>swap_ranges</span></span></a></div> </td> <td> swaps two ranges of elements <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/iter_swap" title="cpp/algorithm/iter swap"> <span class="t-lines"><span>iter_swap</span></span></a></div> </td> <td> swaps the elements pointed to by two iterators <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/reverse" title="cpp/algorithm/reverse"> <span class="t-lines"><span>reverse</span></span></a></div> </td> <td> reverses the order of elements in a range <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/reverse_copy" title="cpp/algorithm/reverse copy"> <span class="t-lines"><span>reverse_copy</span></span></a></div> </td> <td> creates a copy of a range that is reversed <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/rotate" title="cpp/algorithm/rotate"> <span class="t-lines"><span>rotate</span></span></a></div> </td> <td> rotates the order of elements in a range <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/rotate_copy" title="cpp/algorithm/rotate copy"> <span class="t-lines"><span>rotate_copy</span></span></a></div> </td> <td> copies and rotate a range of elements <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/shift" title="cpp/algorithm/shift"> <span class="t-lines"><span>shift_left</span><span>shift_right</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> shifts elements in a range <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/random_shuffle" title="cpp/algorithm/random shuffle"> <span class="t-lines"><span>random_shuffle</span><span>shuffle</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> randomly re-orders elements in a range <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/sample" title="cpp/algorithm/sample"> <span class="t-lines"><span>sample</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> selects n random elements from a sequence <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/unique" title="cpp/algorithm/unique"> <span class="t-lines"><span>unique</span></span></a></div> </td> <td> removes consecutive duplicate elements in a range <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/unique_copy" title="cpp/algorithm/unique copy"> <span class="t-lines"><span>unique_copy</span></span></a></div> </td> <td> creates a copy of some range of elements that contains no consecutive duplicates <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Partitioning_operations">  Partitioning operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/is_partitioned" title="cpp/algorithm/is partitioned"> <span class="t-lines"><span>is_partitioned</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> determines if the range is partitioned by the given predicate <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/partition" title="cpp/algorithm/partition"> <span class="t-lines"><span>partition</span></span></a></div> </td> <td> divides a range of elements into two groups <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/partition_copy" title="cpp/algorithm/partition copy"> <span class="t-lines"><span>partition_copy</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> copies a range dividing the elements into two groups <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/stable_partition" title="cpp/algorithm/stable partition"> <span class="t-lines"><span>stable_partition</span></span></a></div> </td> <td> divides elements into two groups while preserving their relative order <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/partition_point" title="cpp/algorithm/partition point"> <span class="t-lines"><span>partition_point</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> locates the partition point of a partitioned range <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Sorting_operations">  Sorting operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/is_sorted" title="cpp/algorithm/is sorted"> <span class="t-lines"><span>is_sorted</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> checks whether a range is sorted into ascending order <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/is_sorted_until" title="cpp/algorithm/is sorted until"> <span class="t-lines"><span>is_sorted_until</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> finds the largest sorted subrange <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/sort" title="cpp/algorithm/sort"> <span class="t-lines"><span>sort</span></span></a></div> </td> <td> sorts a range into ascending order <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/partial_sort" title="cpp/algorithm/partial sort"> <span class="t-lines"><span>partial_sort</span></span></a></div> </td> <td> sorts the first N elements of a range <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/partial_sort_copy" title="cpp/algorithm/partial sort copy"> <span class="t-lines"><span>partial_sort_copy</span></span></a></div> </td> <td> copies and partially sorts a range of elements <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/stable_sort" title="cpp/algorithm/stable sort"> <span class="t-lines"><span>stable_sort</span></span></a></div> </td> <td> sorts a range of elements while preserving order between equal elements <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/nth_element" title="cpp/algorithm/nth element"> <span class="t-lines"><span>nth_element</span></span></a></div> </td> <td> partially sorts the given range making sure that it is partitioned by the given element <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Binary_search_operations_.28on_sorted_ranges.29">  Binary search operations (on sorted ranges) </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/lower_bound" title="cpp/algorithm/lower bound"> <span class="t-lines"><span>lower_bound</span></span></a></div> </td> <td> returns an iterator to the first element <i>not less</i> than the given value <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/upper_bound" title="cpp/algorithm/upper bound"> <span class="t-lines"><span>upper_bound</span></span></a></div> </td> <td> returns an iterator to the first element <i>greater</i> than a certain value <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/binary_search" title="cpp/algorithm/binary search"> <span class="t-lines"><span>binary_search</span></span></a></div> </td> <td> determines if an element exists in a certain range <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/equal_range" title="cpp/algorithm/equal range"> <span class="t-lines"><span>equal_range</span></span></a></div> </td> <td> returns range of elements matching a specific key <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Other_operations_on_sorted_ranges">  Other operations on sorted ranges </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/merge" title="cpp/algorithm/merge"> <span class="t-lines"><span>merge</span></span></a></div> </td> <td> merges two sorted ranges <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/inplace_merge" title="cpp/algorithm/inplace merge"> <span class="t-lines"><span>inplace_merge</span></span></a></div> </td> <td> merges two ordered ranges in-place <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Set_operations_.28on_sorted_ranges.29">  Set operations (on sorted ranges) </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/includes" title="cpp/algorithm/includes"> <span class="t-lines"><span>includes</span></span></a></div> </td> <td> returns true if one set is a subset of another <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/set_difference" title="cpp/algorithm/set difference"> <span class="t-lines"><span>set_difference</span></span></a></div> </td> <td> computes the difference between two sets <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/set_intersection" title="cpp/algorithm/set intersection"> <span class="t-lines"><span>set_intersection</span></span></a></div> </td> <td> computes the intersection of two sets <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/set_symmetric_difference" title="cpp/algorithm/set symmetric difference"> <span class="t-lines"><span>set_symmetric_difference</span></span></a></div> </td> <td> computes the symmetric difference between two sets <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/set_union" title="cpp/algorithm/set union"> <span class="t-lines"><span>set_union</span></span></a></div> </td> <td> computes the union of two sets <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Heap_operations">  Heap operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/is_heap" title="cpp/algorithm/is heap"> <span class="t-lines"><span>is_heap</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> checks if the given range is a max heap <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/is_heap_until" title="cpp/algorithm/is heap until"> <span class="t-lines"><span>is_heap_until</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> finds the largest subrange that is a max heap <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/make_heap" title="cpp/algorithm/make heap"> <span class="t-lines"><span>make_heap</span></span></a></div> </td> <td> creates a max heap out of a range of elements <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/push_heap" title="cpp/algorithm/push heap"> <span class="t-lines"><span>push_heap</span></span></a></div> </td> <td> adds an element to a max heap <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/pop_heap" title="cpp/algorithm/pop heap"> <span class="t-lines"><span>pop_heap</span></span></a></div> </td> <td> removes the largest element from a max heap <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/sort_heap" title="cpp/algorithm/sort heap"> <span class="t-lines"><span>sort_heap</span></span></a></div> </td> <td> turns a max heap into a range of elements sorted in ascending order <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Minimum.2Fmaximum_operations">  Minimum/maximum operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/max" title="cpp/algorithm/max"> <span class="t-lines"><span>max</span></span></a></div> </td> <td> returns the greater of the given values <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/max_element" title="cpp/algorithm/max element"> <span class="t-lines"><span>max_element</span></span></a></div> </td> <td> returns the largest element in a range <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/min" title="cpp/algorithm/min"> <span class="t-lines"><span>min</span></span></a></div> </td> <td> returns the smaller of the given values <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/min_element" title="cpp/algorithm/min element"> <span class="t-lines"><span>min_element</span></span></a></div> </td> <td> returns the smallest element in a range <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/minmax" title="cpp/algorithm/minmax"> <span class="t-lines"><span>minmax</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> returns the smaller and larger of two elements <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/minmax_element" title="cpp/algorithm/minmax element"> <span class="t-lines"><span>minmax_element</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> returns the smallest and the largest elements in a range <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/clamp" title="cpp/algorithm/clamp"> <span class="t-lines"><span>clamp</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> clamps a value between a pair of boundary values <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Comparison_operations">  Comparison operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/equal" title="cpp/algorithm/equal"> <span class="t-lines"><span>equal</span></span></a></div> </td> <td> determines if two sets of elements are the same <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/lexicographical_compare" title="cpp/algorithm/lexicographical compare"> <span class="t-lines"><span>lexicographical_compare</span></span></a></div> </td> <td> returns true if one range is lexicographically less than another <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/compare_3way" title="cpp/algorithm/compare 3way"> <span class="t-lines"><span>compare_3way</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> compares two values using three-way comparison <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/lexicographical_compare_3way" title="cpp/algorithm/lexicographical compare 3way"> <span class="t-lines"><span>lexicographical_compare_3way</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> compares two ranges using three-way comparison <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Permutation_operations">  Permutation operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/is_permutation" title="cpp/algorithm/is permutation"> <span class="t-lines"><span>is_permutation</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> determines if a sequence is a permutation of another sequence <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/next_permutation" title="cpp/algorithm/next permutation"> <span class="t-lines"><span>next_permutation</span></span></a></div> </td> <td> generates the next greater lexicographic permutation of a range of elements <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/prev_permutation" title="cpp/algorithm/prev permutation"> <span class="t-lines"><span>prev_permutation</span></span></a></div> </td> <td> generates the next smaller lexicographic permutation of a range of elements <br> <span class="t-mark">(function template)</span> </td>
</tr> </table> <h3 id="Niebloids">Niebloids</h3> <table class="t-dsc-begin"> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::ranges</code>  </th>
</tr> <tr> <td colspan="2"> <h5 id="Non-modifying_sequence_operations_2">  Non-modifying sequence operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../algorithm/ranges/all_any_none_of" title="cpp/algorithm/ranges/all any none of"> <span class="t-lines"><span>all_of</span><span>any_of</span><span>none_of</span></span></a></div> </td> <td> checks if a predicate is <code>true</code> for all, any or none of the elements in a range <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/for_each&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/for each（页面不存在）"> <span class="t-lines"><span>for_each</span></span></a></div> </td> <td> applies a function to a range of elements <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/count&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/count（页面不存在）"> <span class="t-lines"><span>count</span><span>count_if</span></span></a></div> </td> <td> returns the number of elements satisfying specific criteria <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/mismatch&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/mismatch（页面不存在）"> <span class="t-lines"><span>mismatch</span></span></a></div> </td> <td> finds the first position where two ranges differ <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/find&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/find（页面不存在）"> <span class="t-lines"><span>find</span><span>find_if</span><span>find_if_not</span></span></a></div> </td> <td> finds the first element satisfying specific criteria <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/find_end&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/find end（页面不存在）"> <span class="t-lines"><span>find_end</span></span></a></div> </td> <td> finds the last sequence of elements in a certain range <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/find_first_of&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/find first of（页面不存在）"> <span class="t-lines"><span>find_first_of</span></span></a></div> </td> <td> searches for any one of a set of elements <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/adjacent_find&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/adjacent find（页面不存在）"> <span class="t-lines"><span>adjacent_find</span></span></a></div> </td> <td> finds the first two adjacent items that are equal (or satisfy a given predicate) <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/search&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/search（页面不存在）"> <span class="t-lines"><span>search</span></span></a></div> </td> <td> searches for a range of elements <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/search_n&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/search n（页面不存在）"> <span class="t-lines"><span>search_n</span></span></a></div> </td> <td> searches for a number consecutive copies of an element in a range <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Modifying_sequence_operations_2">  Modifying sequence operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/copy&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/copy（页面不存在）"> <span class="t-lines"><span>copy</span><span>copy_if</span></span></a></div> </td> <td> copies a range of elements to a new location <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/copy_n&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/copy n（页面不存在）"> <span class="t-lines"><span>copy_n</span></span></a></div> </td> <td> copies a number of elements to a new location <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/copy_backward&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/copy backward（页面不存在）"> <span class="t-lines"><span>copy_backward</span></span></a></div> </td> <td> copies a range of elements in backwards order <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/move&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/move（页面不存在）"> <span class="t-lines"><span>move</span></span></a></div> </td> <td> moves a range of elements to a new location <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/move_backward&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/move backward（页面不存在）"> <span class="t-lines"><span>move_backward</span></span></a></div> </td> <td> moves a range of elements to a new location in backwards order <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/fill&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/fill（页面不存在）"> <span class="t-lines"><span>fill</span></span></a></div> </td> <td> assigns a range of elements a certain value <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/fill_n&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/fill n（页面不存在）"> <span class="t-lines"><span>fill_n</span></span></a></div> </td> <td> assigns a value to a number of elements <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/transform&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/transform（页面不存在）"> <span class="t-lines"><span>transform</span></span></a></div> </td> <td> applies a function to a range of elements <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/generate&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/generate（页面不存在）"> <span class="t-lines"><span>generate</span></span></a></div> </td> <td> saves the result of a function in a range <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/generate_n&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/generate n（页面不存在）"> <span class="t-lines"><span>generate_n</span></span></a></div> </td> <td> saves the result of N applications of a function <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/remove&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/remove（页面不存在）"> <span class="t-lines"><span>remove</span><span>remove_if</span></span></a></div> </td> <td> removes elements satisfying specific criteria <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/remove_copy&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/remove copy（页面不存在）"> <span class="t-lines"><span>remove_copy</span><span>remove_copy_if</span></span></a></div> </td> <td> copies a range of elements omitting those that satisfy specific criteria <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/replace&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/replace（页面不存在）"> <span class="t-lines"><span>replace</span><span>replace_if</span></span></a></div> </td> <td> replaces all values satisfying specific criteria with another value <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/replace_copy&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/replace copy（页面不存在）"> <span class="t-lines"><span>replace_copy</span><span>replace_copy_if</span></span></a></div> </td> <td> copies a range, replacing elements satisfying specific criteria with another value <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/swap_ranges&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/swap ranges（页面不存在）"> <span class="t-lines"><span>swap_ranges</span></span></a></div> </td> <td> swaps two ranges of elements <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/reverse&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/reverse（页面不存在）"> <span class="t-lines"><span>reverse</span></span></a></div> </td> <td> reverses the order of elements in a range <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/reverse_copy&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/reverse copy（页面不存在）"> <span class="t-lines"><span>reverse_copy</span></span></a></div> </td> <td> creates a copy of a range that is reversed <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/rotate&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/rotate（页面不存在）"> <span class="t-lines"><span>rotate</span></span></a></div> </td> <td> rotates the order of elements in a range <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/rotate_copy&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/rotate copy（页面不存在）"> <span class="t-lines"><span>rotate_copy</span></span></a></div> </td> <td> copies and rotate a range of elements <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/shuffle&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/shuffle（页面不存在）"> <span class="t-lines"><span>shuffle</span></span></a></div> </td> <td> randomly re-orders elements in a range <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/unique&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/unique（页面不存在）"> <span class="t-lines"><span>unique</span></span></a></div> </td> <td> removes consecutive duplicate elements in a range <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/unique_copy&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/unique copy（页面不存在）"> <span class="t-lines"><span>unique_copy</span></span></a></div> </td> <td> creates a copy of some range of elements that contains no consecutive duplicates <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Partitioning_operations_2">  Partitioning operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/is_partitioned&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/is partitioned（页面不存在）"> <span class="t-lines"><span>is_partitioned</span></span></a></div> </td> <td> determines if the range is partitioned by the given predicate <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/partition&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/partition（页面不存在）"> <span class="t-lines"><span>partition</span></span></a></div> </td> <td> divides a range of elements into two groups <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/partition_copy&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/partition copy（页面不存在）"> <span class="t-lines"><span>partition_copy</span></span></a></div> </td> <td> copies a range dividing the elements into two groups <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/stable_partition&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/stable partition（页面不存在）"> <span class="t-lines"><span>stable_partition</span></span></a></div> </td> <td> divides elements into two groups while preserving their relative order <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/partition_point&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/partition point（页面不存在）"> <span class="t-lines"><span>partition_point</span></span></a></div> </td> <td> locates the partition point of a partitioned range <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Sorting_operations_2">  Sorting operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/is_sorted&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/is sorted（页面不存在）"> <span class="t-lines"><span>is_sorted</span></span></a></div> </td> <td> checks whether a range is sorted into ascending order <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/is_sorted_until&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/is sorted until（页面不存在）"> <span class="t-lines"><span>is_sorted_until</span></span></a></div> </td> <td> finds the largest sorted subrange <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/sort&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/sort（页面不存在）"> <span class="t-lines"><span>sort</span></span></a></div> </td> <td> sorts a range into ascending order <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/partial_sort&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/partial sort（页面不存在）"> <span class="t-lines"><span>partial_sort</span></span></a></div> </td> <td> sorts the first N elements of a range <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/partial_sort_copy&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/partial sort copy（页面不存在）"> <span class="t-lines"><span>partial_sort_copy</span></span></a></div> </td> <td> copies and partially sorts a range of elements <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/stable_sort&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/stable sort（页面不存在）"> <span class="t-lines"><span>stable_sort</span></span></a></div> </td> <td> sorts a range of elements while preserving order between equal elements <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/nth_element&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/nth element（页面不存在）"> <span class="t-lines"><span>nth_element</span></span></a></div> </td> <td> partially sorts the given range making sure that it is partitioned by the given element <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Binary_search_operations_.28on_sorted_ranges.29_2">  Binary search operations (on sorted ranges) </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/lower_bound&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/lower bound（页面不存在）"> <span class="t-lines"><span>lower_bound</span></span></a></div> </td> <td> returns an iterator to the first element <i>not less</i> than the given value <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/upper_bound&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/upper bound（页面不存在）"> <span class="t-lines"><span>upper_bound</span></span></a></div> </td> <td> returns an iterator to the first element <i>greater</i> than a certain value <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/binary_search&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/binary search（页面不存在）"> <span class="t-lines"><span>binary_search</span></span></a></div> </td> <td> determines if an element exists in a certain range <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/equal_range&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/equal range（页面不存在）"> <span class="t-lines"><span>equal_range</span></span></a></div> </td> <td> returns range of elements matching a specific key <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Other_operations_on_sorted_ranges_2">  Other operations on sorted ranges </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/merge&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/merge（页面不存在）"> <span class="t-lines"><span>merge</span></span></a></div> </td> <td> merges two sorted ranges <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/inplace_merge&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/inplace merge（页面不存在）"> <span class="t-lines"><span>inplace_merge</span></span></a></div> </td> <td> merges two ordered ranges in-place <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Set_operations_.28on_sorted_ranges.29_2">  Set operations (on sorted ranges) </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/includes&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/includes（页面不存在）"> <span class="t-lines"><span>includes</span></span></a></div> </td> <td> returns true if one set is a subset of another <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/set_difference&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/set difference（页面不存在）"> <span class="t-lines"><span>set_difference</span></span></a></div> </td> <td> computes the difference between two sets <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/set_intersection&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/set intersection（页面不存在）"> <span class="t-lines"><span>set_intersection</span></span></a></div> </td> <td> computes the intersection of two sets <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/set_symmetric_difference&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/set symmetric difference（页面不存在）"> <span class="t-lines"><span>set_symmetric_difference</span></span></a></div> </td> <td> computes the symmetric difference between two sets <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/set_union&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/set union（页面不存在）"> <span class="t-lines"><span>set_union</span></span></a></div> </td> <td> computes the union of two sets <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Heap_operations_2">  Heap operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/is_heap&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/is heap（页面不存在）"> <span class="t-lines"><span>is_heap</span></span></a></div> </td> <td> checks if the given range is a max heap <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/is_heap_until&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/is heap until（页面不存在）"> <span class="t-lines"><span>is_heap_until</span></span></a></div> </td> <td> finds the largest subrange that is a max heap <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/make_heap&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/make heap（页面不存在）"> <span class="t-lines"><span>make_heap</span></span></a></div> </td> <td> creates a max heap out of a range of elements <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/push_heap&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/push heap（页面不存在）"> <span class="t-lines"><span>push_heap</span></span></a></div> </td> <td> adds an element to a max heap <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/pop_heap&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/pop heap（页面不存在）"> <span class="t-lines"><span>pop_heap</span></span></a></div> </td> <td> removes the largest element from a max heap <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/sort_heap&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/sort heap（页面不存在）"> <span class="t-lines"><span>sort_heap</span></span></a></div> </td> <td> turns a max heap into a range of elements sorted in ascending order <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Minimum.2Fmaximum_operations_2">  Minimum/maximum operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/max&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/max（页面不存在）"> <span class="t-lines"><span>max</span></span></a></div> </td> <td> returns the greater of the given values <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/max_element&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/max element（页面不存在）"> <span class="t-lines"><span>max_element</span></span></a></div> </td> <td> returns the largest element in a range <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/min&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/min（页面不存在）"> <span class="t-lines"><span>min</span></span></a></div> </td> <td> returns the smaller of the given values <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/min_element&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/min element（页面不存在）"> <span class="t-lines"><span>min_element</span></span></a></div> </td> <td> returns the smallest element in a range <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/minmax&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/minmax（页面不存在）"> <span class="t-lines"><span>minmax</span></span></a></div> </td> <td> returns the smaller and larger of two elements <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/minmax_element&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/minmax element（页面不存在）"> <span class="t-lines"><span>minmax_element</span></span></a></div> </td> <td> returns the smallest and the largest elements in a range <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Comparison_operations_2">  Comparison operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/equal&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/equal（页面不存在）"> <span class="t-lines"><span>equal</span></span></a></div> </td> <td> determines if two sets of elements are the same <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/lexicographical_compare&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/lexicographical compare（页面不存在）"> <span class="t-lines"><span>lexicographical_compare</span></span></a></div> </td> <td> returns true if one range is lexicographically less than another <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Permutation_operations_2">  Permutation operations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/is_permutation&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/is permutation（页面不存在）"> <span class="t-lines"><span>is_permutation</span></span></a></div> </td> <td> determines if a sequence is a permutation of another sequence <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/next_permutation&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/next permutation（页面不存在）"> <span class="t-lines"><span>next_permutation</span></span></a></div> </td> <td> generates the next greater lexicographic permutation of a range of elements <br> <span class="t-mark">(niebloid)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/prev_permutation&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/prev permutation（页面不存在）"> <span class="t-lines"><span>prev_permutation</span></span></a></div> </td> <td> generates the next smaller lexicographic permutation of a range of elements <br> <span class="t-mark">(niebloid)</span> </td>
</tr> </table> <h3 id="Synopsis">Synopsis</h3> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;initializer_list&gt;
 
namespace std {
  // non-modifying sequence operations:
  // all of:
  template&lt;class InputIt, class Pred&gt;
    constexpr bool all_of(InputIt first, InputIt last, Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIt, class Pred&gt;
    bool all_of(ExecutionPolicy&amp;&amp; exec,
                ForwardIt first, ForwardIt last, Pred pred);
 
  namespace ranges {
    template&lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr bool all_of(I first, S last, Pred pred, Proj proj = {});
    template&lt;InputRange R, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      constexpr bool all_of(R&amp;&amp; r, Pred pred, Proj proj = {});
  }
 
  // any of:
  template&lt;class InputIt, class Pred&gt;
    constexpr bool any_of(InputIt first, InputIt last, Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIt, class Pred&gt;
    bool any_of(ExecutionPolicy&amp;&amp; exec,
                ForwardIt first, ForwardIt last, Pred pred);
 
  namespace ranges {
    template&lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr bool any_of(I first, S last, Pred pred, Proj proj = {});
    template&lt;InputRange R, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      constexpr bool any_of(R&amp;&amp; r, Pred pred, Proj proj = {});
  }
 
  // none of:
  template&lt;class InputIt, class Pred&gt;
    constexpr bool none_of(InputIt first, InputIt last, Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIt, class Pred&gt;
    bool none_of(ExecutionPolicy&amp;&amp; exec,
                 ForwardIt first, ForwardIt last, Pred pred);
 
  namespace ranges {
    template&lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr bool none_of(I first, S last, Pred pred, Proj proj = {});
    template&lt;InputRange R, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      constexpr bool none_of(R&amp;&amp; r, Pred pred, Proj proj = {});
  }
 
  // for each:
  template&lt;class InputIt, class Function&gt;
    constexpr Function for_each(InputIt first, InputIt last, Function f);
  template&lt;class ExecutionPolicy, class ForwardIt, class Function&gt;
    void for_each(ExecutionPolicy&amp;&amp; exec,
                  ForwardIt first, ForwardIt last, Function f);
 
  namespace ranges {
    template&lt;class I, class F&gt;
    struct for_each_result {
      [[no_unique_address]] I in;
      [[no_unique_address]] F fun;
 
      template&lt;class I2, class F2&gt;
        requires ConvertibleTo&lt;const I&amp;, I2&gt; &amp;&amp; ConvertibleTo&lt;const F&amp;, F2&gt;
        operator for_each_result&lt;I2, F2&gt;() const &amp; {
          return {in, fun};
        }
 
      template&lt;class I2, class F2&gt;
        requires ConvertibleTo&lt;I, I2&gt; &amp;&amp; ConvertibleTo&lt;F, F2&gt;
        operator for_each_result&lt;I2, F2&gt;() &amp;&amp; {
          return {std::move(in), std::move(fun)};
        }
    };
 
    template&lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
             IndirectUnaryInvocable&lt;projected&lt;I, Proj&gt;&gt; Fun&gt;
      constexpr for_each_result&lt;I, Fun&gt;
        for_each(I first, S last, Fun f, Proj proj = {});
    template&lt;InputRange R, class Proj = identity,
             IndirectUnaryInvocable&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Fun&gt;
      constexpr for_each_result&lt;safe_iterator_t&lt;R&gt;, Fun&gt;
        for_each(R&amp;&amp; r, Fun f, Proj proj = {});
  }
 
  template&lt;class InputIt, class Size, class Function&gt;
    constexpr InputIt for_each_n(InputIt first, Size n, Function f);
  template&lt;class ExecutionPolicy, class ForwardIt, class Size, class Function&gt;
    ForwardIt for_each_n(ExecutionPolicy&amp;&amp; exec,
                         ForwardIt first, Size n, Function f);
 
  // find:
  template&lt;class InputIt, class T&gt;
    constexpr InputIt find(InputIt first, InputIt last,
                           const T&amp; value);
  template&lt;class ExecutionPolicy, class ForwardIt, class T&gt;
    ForwardIt find(ExecutionPolicy&amp;&amp; exec,
                   ForwardIt first, ForwardIt last, const T&amp; value);
  template&lt;class InputIt, class Pred&gt;
    constexpr InputIt find_if(InputIt first, InputIt last, Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIt, class Pred&gt;
    ForwardIt find_if(ExecutionPolicy&amp;&amp; exec,
                      ForwardIt first, ForwardIt last, Pred pred);
  template&lt;class InputIt, class Pred&gt;
    constexpr InputIt find_if_not(InputIt first, InputIt last, Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIt, class Pred&gt;
    ForwardIt find_if_not(ExecutionPolicy&amp;&amp; exec,
                          ForwardIt first, ForwardIt last, Pred pred);
 
  namespace ranges {
    template&lt;InputIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity&gt;
      requires IndirectRelation&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T*&gt;
      constexpr I find(I first, S last, const T&amp; value, Proj proj = {});
    template&lt;InputRange R, class T, class Proj = identity&gt;
      requires IndirectRelation&lt;ranges::equal_to, projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
      constexpr safe_iterator_t&lt;R&gt;
        find(R&amp;&amp; r, const T&amp; value, Proj proj = {});
    template&lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr I find_if(I first, S last, Pred pred, Proj proj = {});
    template&lt;InputRange R, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      constexpr safe_iterator_t&lt;R&gt;
        find_if(R&amp;&amp; r, Pred pred, Proj proj = {});
    template&lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr I find_if_not(I first, S last, Pred pred, Proj proj = {});
    template&lt;InputRange R, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      constexpr safe_iterator_t&lt;R&gt;
        find_if_not(R&amp;&amp; r, Pred pred, Proj proj = {});
  }
 
  // find end:
  template&lt;class ForwardIt1, class ForwardIt2&gt;
    constexpr ForwardIt1
      find_end(ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2);
  template&lt;class ForwardIt1, class ForwardIt2, class BinaryPred&gt;
    constexpr ForwardIt1
      find_end(ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2,
               BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2&gt;
    ForwardIt1
      find_end(ExecutionPolicy&amp;&amp; exec,
               ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2);
  template&lt;class ExecutionPolicy, class ForwardIt1,
           class ForwardIt2, class BinaryPred&gt;
    ForwardIt1
      find_end(ExecutionPolicy&amp;&amp; exec,
               ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2,
               BinaryPred pred);
 
  namespace ranges {
    template&lt;ForwardIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2, Sentinel&lt;I2&gt; S2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&gt;
      requires IndirectlyComparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
      constexpr subrange&lt;I1&gt;
        find_end(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                 Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;ForwardRange R1, ForwardRange R2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&gt;
      requires IndirectlyComparable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, Pred, Proj1, Proj2&gt;
      constexpr safe_subrange_t&lt;R1&gt;
        find_end(R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {},
                 Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  // find first:
  template&lt;class InputIt, class ForwardIt&gt;
    constexpr InputIt
      find_first_of(InputIt first1, InputIt last1, ForwardIt first2, ForwardIt last2);
  template&lt;class InputIt, class ForwardIt, class BinaryPred&gt;
    constexpr InputIt
      find_first_of(InputIt first1, InputIt last1, ForwardIt first2, ForwardIt last2,
                    BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2&gt;
    ForwardIt1
      find_first_of(ExecutionPolicy&amp;&amp; exec,
                    ForwardIt1 first1, ForwardIt1 last1,
                    ForwardIt2 first2, ForwardIt2 last2);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2, class BinaryPred&gt;
    ForwardIt1
      find_first_of(ExecutionPolicy&amp;&amp; exec,
                    ForwardIt1 first1, ForwardIt1 last1,
                    ForwardIt2 first2, ForwardIt2 last2,
                    BinaryPred pred);
 
  namespace ranges {
    template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2, Sentinel&lt;I2&gt; S2,
             class Proj1 = identity, class Proj2 = identity,
             IndirectRelation&lt;projected&lt;I1, Proj1&gt;,
                              projected&lt;I2, Proj2&gt;&gt; Pred = ranges::equal_to&gt;
      constexpr I1 find_first_of(I1 first1, S1 last1, I2 first2, S2 last2,
                                 Pred pred = {},
                                 Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;InputRange R1, ForwardRange R2,
             class Proj1 = identity, class Proj2 = identity,
             IndirectRelation&lt;projected&lt;iterator_t&lt;R1&gt;, Proj1&gt;,
                              projected&lt;iterator_t&lt;R2&gt;, Proj2&gt;&gt; Pred = ranges::equal_to&gt;
      constexpr safe_iterator_t&lt;R1&gt;
        find_first_of(R1&amp;&amp; r1, R2&amp;&amp; r2,
                      Pred pred = {},
                      Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  // adjacent find:
  template&lt;class ForwardIt&gt;
    constexpr ForwardIt
      adjacent_find(ForwardIt first, ForwardIt last);
  template&lt;class ForwardIt, class BinaryPred&gt;
    constexpr ForwardIt
      adjacent_find(ForwardIt first, ForwardIt last, BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIt&gt;
    ForwardIt
      adjacent_find(ExecutionPolicy&amp;&amp; exec,
                    ForwardIt first, ForwardIt last);
  template&lt;class ExecutionPolicy, class ForwardIt, class BinaryPred&gt;
    ForwardIt
      adjacent_find(ExecutionPolicy&amp;&amp; exec,
                    ForwardIt first, ForwardIt last, BinaryPred pred);
 
  namespace ranges {
    template&lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
             IndirectRelation&lt;projected&lt;I, Proj&gt;&gt; Pred = ranges::equal_to&gt;
      constexpr I adjacent_find(I first, S last, Pred pred = {},
                                Proj proj = {});
    template&lt;ForwardRange R, class Proj = identity,
             IndirectRelation&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred = ranges::equal_to&gt;
      constexpr safe_iterator_t&lt;R&gt;
        adjacent_find(R&amp;&amp; r, Pred pred = {}, Proj proj = {});
  }
 
  // count:
  template&lt;class InputIt, class T&gt;
    constexpr typename iterator_traits&lt;InputIt&gt;::difference_type
      count(InputIt first, InputIt last, const T&amp; value);
  template&lt;class ExecutionPolicy, class ForwardIt, class T&gt;
    typename iterator_traits&lt;ForwardIt&gt;::difference_type
      count(ExecutionPolicy&amp;&amp; exec,
            ForwardIt first, ForwardIt last, const T&amp; value);
  template&lt;class InputIt, class Pred&gt;
    constexpr typename iterator_traits&lt;InputIt&gt;::difference_type
      count_if(InputIt first, InputIt last, Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIt, class Pred&gt;
    typename iterator_traits&lt;ForwardIt&gt;::difference_type
      count_if(ExecutionPolicy&amp;&amp; exec,
               ForwardIt first, ForwardIt last, Pred pred);
 
  namespace ranges {
    template&lt;InputIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity&gt;
      requires IndirectRelation&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T*&gt;
      constexpr iter_difference_t&lt;I&gt;
        count(I first, S last, const T&amp; value, Proj proj = {});
    template&lt;InputRange R, class T, class Proj = identity&gt;
      requires IndirectRelation&lt;ranges::equal_to, projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
      constexpr iter_difference_t&lt;iterator_t&lt;R&gt;&gt;
        count(R&amp;&amp; r, const T&amp; value, Proj proj = {});
    template&lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr iter_difference_t&lt;I&gt;
        count_if(I first, S last, Pred pred, Proj proj = {});
    template&lt;InputRange R, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      constexpr iter_difference_t&lt;iterator_t&lt;R&gt;&gt;
        count_if(R&amp;&amp; r, Pred pred, Proj proj = {});
  }
 
  // mismatch:
  template&lt;class InputIt1, class InputIt2&gt;
    constexpr pair&lt;InputIt1, InputIt2&gt;
      mismatch(InputIt1 first1, InputIt1 last1, InputIt2 first2);
  template&lt;class InputIt1, class InputIt2, class BinaryPred&gt;
    constexpr pair&lt;InputIt1, InputIt2&gt;
      mismatch(InputIt1 first1, InputIt1 last1, InputIt2 first2, BinaryPred pred);
  template&lt;class InputIt1, class InputIt2&gt;
    constexpr pair&lt;InputIt1, InputIt2&gt;
      mismatch(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2);
  template&lt;class InputIt1, class InputIt2, class BinaryPred&gt;
    constexpr pair&lt;InputIt1, InputIt2&gt;
      mismatch(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
               BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2&gt;
    pair&lt;ForwardIt1, ForwardIt2&gt;
      mismatch(ExecutionPolicy&amp;&amp; exec,
               ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2,
           class BinaryPred&gt;
    pair&lt;ForwardIt1, ForwardIt2&gt;
      mismatch(ExecutionPolicy&amp;&amp; exec,
               ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2&gt;
    pair&lt;ForwardIt1, ForwardIt2&gt;
      mismatch(ExecutionPolicy&amp;&amp; exec,
               ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2, class BinaryPred&gt;
    pair&lt;ForwardIt1, ForwardIt2&gt;
      mismatch(ExecutionPolicy&amp;&amp; exec,
               ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2,
               BinaryPred pred);
 
  namespace ranges {
    template&lt;class I1, class I2&gt;
    struct mismatch_result {
      [[no_unique_address]] I1 in1;
      [[no_unique_address]] I2 in2;
 
      template&lt;class II1, class II2&gt;
        requires ConvertibleTo&lt;const I1&amp;, II1&gt; &amp;&amp; ConvertibleTo&lt;const I2&amp;, II2&gt;
        operator mismatch_result&lt;II1, II2&gt;() const &amp; {
          return {in1, in2};
        }
 
      template&lt;class II1, class II2&gt;
        requires ConvertibleTo&lt;I1, II1&gt; &amp;&amp; ConvertibleTo&lt;I2, II2&gt;
        operator mismatch_result&lt;II1, II2&gt;() &amp;&amp; {
          return {std::move(in1), std::move(in2)};
        }
    };
 
    template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
             class Proj1 = identity, class Proj2 = identity,
             IndirectRelation&lt;projected&lt;I1, Proj1&gt;,
                              projected&lt;I2, Proj2&gt;&gt; Pred = ranges::equal_to&gt;
      constexpr mismatch_result&lt;I1, I2&gt;
        mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                 Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;InputRange R1, InputRange R2,
             class Proj1 = identity, class Proj2 = identity,
             IndirectRelation&lt;projected&lt;iterator_t&lt;R1&gt;, Proj1&gt;,
                              projected&lt;iterator_t&lt;R2&gt;, Proj2&gt;&gt; Pred = ranges::equal_to&gt;
      constexpr mismatch_result&lt;safe_iterator_t&lt;R1&gt;, safe_iterator_t&lt;R2&gt;&gt;
        mismatch(R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {},
                 Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  // equal:
  template&lt;class InputIt1, class InputIt2&gt;
    constexpr bool equal(InputIt1 first1, InputIt1 last1, InputIt2 first2);
  template&lt;class InputIt1, class InputIt2, class BinaryPred&gt;
    constexpr bool equal(InputIt1 first1, InputIt1 last1, InputIt2 first2,
                         BinaryPred pred);
  template&lt;class InputIt1, class InputIt2&gt;
    constexpr bool equal(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2);
  template&lt;class InputIt1, class InputIt2, class BinaryPred&gt;
    constexpr bool equal(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
                         BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2&gt;
    bool equal(ExecutionPolicy&amp;&amp; exec,
               ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2, class BinaryPred&gt;
    bool equal(ExecutionPolicy&amp;&amp; exec,
               ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2&gt;
    bool equal(ExecutionPolicy&amp;&amp; exec,
               ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2, class BinaryPred&gt;
    bool equal(ExecutionPolicy&amp;&amp; exec,
               ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2,
               BinaryPred pred);
 
  namespace ranges {
    template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&gt;
      requires IndirectlyComparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
      constexpr bool equal(I1 first1, S1 last1, I2 first2, S2 last2,
                           Pred pred = {},
                           Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;InputRange R1, InputRange R2, class Pred = ranges::equal_to,
             class Proj1 = identity, class Proj2 = identity&gt;
      requires IndirectlyComparable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, Pred, Proj1, Proj2&gt;
      constexpr bool equal(R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {},
                           Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  // is permutation:
  template&lt;class ForwardIt1, class ForwardIt2&gt;
    constexpr bool is_permutation(ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2);
  template&lt;class ForwardIt1, class ForwardIt2, class BinaryPred&gt;
    constexpr bool is_permutation(ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2,
                                  BinaryPred pred);
  template&lt;class ForwardIt1, class ForwardIt2&gt;
    constexpr bool is_permutation(ForwardIt1 first1, ForwardIt1 last1,
                                  ForwardIt2 first2, ForwardIt2 last2);
  template&lt;class ForwardIt1, class ForwardIt2, class BinaryPred&gt;
    constexpr bool is_permutation(ForwardIt1 first1, ForwardIt1 last1,
                                  ForwardIt2 first2, ForwardIt2 last2,
                                  BinaryPred pred);
 
  namespace ranges {
    template&lt;ForwardIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2,
             Sentinel&lt;I2&gt; S2, class Pred = ranges::equal_to, class Proj1 = identity,
             class Proj2 = identity&gt;
      requires IndirectlyComparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
      constexpr bool is_permutation(I1 first1, S1 last1, I2 first2, S2 last2,
                                    Pred pred = {},
                                    Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;ForwardRange R1, ForwardRange R2, class Pred = ranges::equal_to,
             class Proj1 = identity, class Proj2 = identity&gt;
      requires IndirectlyComparable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, Pred, Proj1, Proj2&gt;
      constexpr bool is_permutation(R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {},
                                    Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  // search:
  template&lt;class ForwardIt1, class ForwardIt2&gt;
    constexpr ForwardIt1
      search(ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2);
  template&lt;class ForwardIt1, class ForwardIt2, class BinaryPred&gt;
    constexpr ForwardIt1
      search(ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2,
             BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2&gt;
    ForwardIt1
      search(ExecutionPolicy&amp;&amp; exec,
             ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2, class BinaryPred&gt;
    ForwardIt1
      search(ExecutionPolicy&amp;&amp; exec,
             ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2,
             BinaryPred pred);
 
  namespace ranges {
    template&lt;ForwardIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2,
             Sentinel&lt;I2&gt; S2, class Pred = ranges::equal_to,
             class Proj1 = identity, class Proj2 = identity&gt;
      requires IndirectlyComparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
      constexpr subrange&lt;I1&gt;
        search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
               Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;ForwardRange R1, ForwardRange R2, class Pred = ranges::equal_to,
             class Proj1 = identity, class Proj2 = identity&gt;
      requires IndirectlyComparable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, Pred, Proj1, Proj2&gt;
      constexpr safe_subrange_t&lt;R1&gt;
        search(R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {},
               Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  template&lt;class ForwardIt, class Size, class T&gt;
    constexpr ForwardIt
      search_n(ForwardIt first, ForwardIt last, Size count, const T&amp; value);
  template&lt;class ForwardIt, class Size, class T, class BinaryPred&gt;
    constexpr ForwardIt
      search_n(ForwardIt first, ForwardIt last,
               Size count, const T&amp; value, BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIt, class Size, class T&gt;
    ForwardIt
      search_n(ExecutionPolicy&amp;&amp; exec,
               ForwardIt first, ForwardIt last, Size count, const T&amp; value);
  template&lt;class ExecutionPolicy, class ForwardIt, class Size, class T, class BinaryPred&gt;
    ForwardIt
      search_n(ExecutionPolicy&amp;&amp; exec,
               ForwardIt first, ForwardIt last,
               Size count, const T&amp; value, BinaryPred pred);
 
  namespace ranges {
    template&lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T,
             class Pred = ranges::equal_to, class Proj = identity&gt;
      requires IndirectlyComparable&lt;I, const T*, Pred, Proj&gt;
      constexpr subrange&lt;I&gt;
        search_n(I first, S last, iter_difference_t&lt;I&gt; count,
                 const T&amp; value, Pred pred = {}, Proj proj = {});
    template&lt;ForwardRange R, class T, class Pred = ranges::equal_to,
             class Proj = identity&gt;
      requires IndirectlyComparable&lt;iterator_t&lt;R&gt;, const T*, Pred, Proj&gt;
      constexpr safe_subrange_t&lt;R&gt;
        search_n(R&amp;&amp; r, iter_difference_t&lt;iterator_t&lt;R&gt;&gt; count,
                 const T&amp; value, Pred pred = {}, Proj proj = {});
  }
 
  template&lt;class ForwardIt, class Searcher&gt;
    constexpr ForwardIt
      search(ForwardIt first, ForwardIt last, const Searcher&amp; searcher);
 
  // mutating sequence operations:
  // copy:
  template&lt;class InputIt, class OutputIt&gt;
    constexpr OutputIt copy(InputIt first, InputIt last, OutputIt result);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2&gt;
    ForwardIt2 copy(ExecutionPolicy&amp;&amp; exec,
                    ForwardIt1 first, ForwardIt1 last, ForwardIt2 result);
 
  namespace ranges {
    template&lt;class I, class O&gt;
    struct copy_result {
      [[no_unique_address]] I in;
      [[no_unique_address]] O out;
 
      template&lt;class I2, class O2&gt;
        requires ConvertibleTo&lt;const I&amp;, I2&gt; &amp;&amp; ConvertibleTo&lt;const O&amp;, O2&gt;
        operator copy_result&lt;I2, O2&gt;() const &amp; {
          return {in, out};
        }
 
      template&lt;class I2, class O2&gt;
        requires ConvertibleTo&lt;I, I2&gt; &amp;&amp; ConvertibleTo&lt;O, O2&gt;
        operator copy_result&lt;I2, O2&gt;() &amp;&amp; {
          return {std::move(in), std::move(out)};
        }
    };
 
    template&lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O&gt;
      requires IndirectlyCopyable&lt;I, O&gt;
      constexpr copy_result&lt;I, O&gt;
        copy(I first, S last, O result);
    template&lt;InputRange R, WeaklyIncrementable O&gt;
      requires IndirectlyCopyable&lt;iterator_t&lt;R&gt;, O&gt;
      constexpr copy_result&lt;safe_iterator_t&lt;R&gt;, O&gt;
        copy(R&amp;&amp; r, O result);
  }
 
  template&lt;class InputIt, class Size, class OutputIt&gt;
    constexpr OutputIt copy_n(InputIt first, Size n, OutputIt result);
  template&lt;class ExecutionPolicy, class ForwardIt1, class Size, class ForwardIt2&gt;
    ForwardIt2 copy_n(ExecutionPolicy&amp;&amp; exec,
                      ForwardIt1 first, Size n, ForwardIt2 result);
 
  namespace ranges {
    template&lt;class I, class O&gt;
    using copy_n_result = copy_result&lt;I, O&gt;;
 
    template&lt;InputIterator I, WeaklyIncrementable O&gt;
      requires IndirectlyCopyable&lt;I, O&gt;
      constexpr copy_n_result&lt;I, O&gt;
        copy_n(I first, iter_difference_t&lt;I&gt; n, O result);
  }
 
  template&lt;class InputIt, class OutputIt, class Pred&gt;
    constexpr OutputIt copy_if(InputIt first, InputIt last, OutputIt result, Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2, class Pred&gt;
    ForwardIt2 copy_if(ExecutionPolicy&amp;&amp; exec,
                       ForwardIt1 first, ForwardIt1 last, ForwardIt2 result, Pred pred);
 
  namespace ranges {
    template&lt;class I, class O&gt;
    using copy_if_result = copy_result&lt;I, O&gt;;
 
    template&lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      requires IndirectlyCopyable&lt;I, O&gt;
      constexpr copy_if_result&lt;I, O&gt;
        copy_if(I first, S last, O result, Pred pred, Proj proj = {});
    template&lt;InputRange R, WeaklyIncrementable O, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      requires IndirectlyCopyable&lt;iterator_t&lt;R&gt;, O&gt;
      constexpr copy_if_result&lt;safe_iterator_t&lt;R&gt;, O&gt;
        copy_if(R&amp;&amp; r, O result, Pred pred, Proj proj = {});
  }
 
  template&lt;class BidirectionalIt1, class BidirectionalIt2&gt;
    constexpr BidirectionalIt2
      copy_backward(BidirectionalIt1 first, BidirectionalIt1 last,
                    BidirectionalIt2 result);
 
  namespace ranges {
    template&lt;class I1, class I2&gt;
    using copy_backward_result = copy_result&lt;I1, I2&gt;;
 
    template&lt;BidirectionalIterator I1, Sentinel&lt;I1&gt; S1, BidirectionalIterator I2&gt;
      requires IndirectlyCopyable&lt;I1, I2&gt;
      constexpr copy_backward_result&lt;I1, I2&gt;
        copy_backward(I1 first, S1 last, I2 result);
    template&lt;BidirectionalRange R, BidirectionalIterator I&gt;
      requires IndirectlyCopyable&lt;iterator_t&lt;R&gt;, I&gt;
      constexpr copy_backward_result&lt;safe_iterator_t&lt;R&gt;, I&gt;
        copy_backward(R&amp;&amp; r, I result);
  }
 
  // move:
  template&lt;class InputIt, class OutputIt&gt;
    constexpr OutputIt move(InputIt first, InputIt last, OutputIt result);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2&gt;
    ForwardIt2 move(ExecutionPolicy&amp;&amp; exec,
                    ForwardIt1 first, ForwardIt1 last, ForwardIt2 result);
 
  namespace ranges {
    template&lt;class I, class O&gt;
    using move_result = copy_result&lt;I, O&gt;;
 
    template&lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O&gt;
      requires IndirectlyMovable&lt;I, O&gt;
      constexpr move_result&lt;I, O&gt;
        move(I first, S last, O result);
    template&lt;InputRange R, WeaklyIncrementable O&gt;
      requires IndirectlyMovable&lt;iterator_t&lt;R&gt;, O&gt;
      constexpr move_result&lt;safe_iterator_t&lt;R&gt;, O&gt;
        move(R&amp;&amp; r, O result);
  }
 
  template&lt;class BidirectionalIt1, class BidirectionalIt2&gt;
    constexpr BidirectionalIt2
      move_backward(BidirectionalIt1 first, BidirectionalIt1 last,
                    BidirectionalIt2 result);
 
  namespace ranges {
    template&lt;class I1, class I2&gt;
    using move_backward_result = copy_result&lt;I1, I2&gt;;
 
    template&lt;BidirectionalIterator I1, Sentinel&lt;I1&gt; S1, BidirectionalIterator I2&gt;
      requires IndirectlyMovable&lt;I1, I2&gt;
      constexpr move_backward_result&lt;I1, I2&gt;
        move_backward(I1 first, S1 last, I2 result);
    template&lt;BidirectionalRange R, BidirectionalIterator I&gt;
      requires IndirectlyMovable&lt;iterator_t&lt;R&gt;, I&gt;
      constexpr move_backward_result&lt;safe_iterator_t&lt;R&gt;, I&gt;
        move_backward(R&amp;&amp; r, I result);
  }
 
  // swap:
  template&lt;class ForwardIt1, class ForwardIt2&gt;
    constexpr ForwardIt2 swap_ranges(ForwardIt1 first1, ForwardIt1 last1,
                                     ForwardIt2 first2);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2&gt;
    ForwardIt2 swap_ranges(ExecutionPolicy&amp;&amp; exec,
                           ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2);
 
  namespace ranges {
    template&lt;class I1, class I2&gt;
    using swap_ranges_result = mismatch_result&lt;I1, I2&gt;;
 
    template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2&gt;
      requires IndirectlySwappable&lt;I1, I2&gt;
      constexpr swap_ranges_result&lt;I1, I2&gt;
        swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);
    template&lt;InputRange R1, InputRange R2&gt;
      requires IndirectlySwappable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;&gt;
      constexpr swap_ranges_result&lt;safe_iterator_t&lt;R1&gt;, safe_iterator_t&lt;R2&gt;&gt;
        swap_ranges(R1&amp;&amp; r1, R2&amp;&amp; r2);
  }
 
  template&lt;class ForwardIt1, class ForwardIt2&gt;
    constexpr void iter_swap(ForwardIt1 a, ForwardIt2 b);
 
  // transform:
  template&lt;class InputIt, class OutputIt, class UnaryOperation&gt;
    constexpr OutputIt
      transform(InputIt first1, InputIt last1, OutputIt result, UnaryOperation op);
  template&lt;class InputIt1, class InputIt2, class OutputIt, class BinaryOperation&gt;
    constexpr OutputIt
      transform(InputIt1 first1, InputIt1 last1, InputIt2 first2, OutputIt result,
                BinaryOperation binary_op);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2, class UnaryOperation&gt;
    ForwardIt2
      transform(ExecutionPolicy&amp;&amp; exec,
                ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 result, UnaryOperation op);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2,
           class ForwardIt, class BinaryOperation&gt;
    ForwardIt
      transform(ExecutionPolicy&amp;&amp; exec,
                ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt result,
                BinaryOperation binary_op);
 
  namespace ranges {
    template&lt;class I, class O&gt;
    using unary_transform_result = copy_result&lt;I, O&gt;;
 
    template&lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O,
             CopyConstructible F, class Proj = identity&gt;
      requires Writable&lt;O, indirect_result_t&lt;F&amp;, projected&lt;I, Proj&gt;&gt;&gt;
      constexpr unary_transform_result&lt;I, O&gt;
        transform(I first1, S last1, O result, F op, Proj proj = {});
    template&lt;InputRange R, WeaklyIncrementable O, CopyConstructible F,
             class Proj = identity&gt;
      requires Writable&lt;O, indirect_result_t&lt;F&amp;, projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt;&gt;
      constexpr unary_transform_result&lt;safe_iterator_t&lt;R&gt;, O&gt;
        transform(R&amp;&amp; r, O result, F op, Proj proj = {});
 
    template&lt;class I1, class I2, class O&gt;
    struct binary_transform_result {
      [[no_unique_address]] I1 in1;
      [[no_unique_address]] I2 in2;
      [[no_unique_address]] O  out;
 
      template&lt;class II1, class II2, class OO&gt;
        requires ConvertibleTo&lt;const I1&amp;, II1&gt; &amp;&amp;
          ConvertibleTo&lt;const I2&amp;, II2&gt; &amp;&amp; ConvertibleTo&lt;const O&amp;, OO&gt;
        operator binary_transform_result&lt;II1, II2, OO&gt;() const &amp; {
          return {in1, in2, out};
        }
 
      template&lt;class II1, class II2, class OO&gt;
        requires ConvertibleTo&lt;I1, II1&gt; &amp;&amp;
          ConvertibleTo&lt;I2, II2&gt; &amp;&amp; ConvertibleTo&lt;O, OO&gt;
        operator binary_transform_result&lt;II1, II2, OO&gt;() &amp;&amp; {
          return {std::move(in1), std::move(in2), std::move(out)};
        }
    };
 
    template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
             WeaklyIncrementable O, CopyConstructible F, class Proj1 = identity,
             class Proj2 = identity&gt;
      requires Writable&lt;O, indirect_result_t&lt;F&amp;, projected&lt;I1, Proj1&gt;,
                                             projected&lt;I2, Proj2&gt;&gt;&gt;
      constexpr binary_transform_result&lt;I1, I2, O&gt;
        transform(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                  F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;InputRange R1, InputRange R2, WeaklyIncrementable O,
             CopyConstructible F, class Proj1 = identity, class Proj2 = identity&gt;
      requires Writable&lt;O, indirect_result_t&lt;F&amp;, projected&lt;iterator_t&lt;R1&gt;, Proj1&gt;,
                                             projected&lt;iterator_t&lt;R2&gt;, Proj2&gt;&gt;&gt;
      constexpr binary_transform_result&lt;safe_iterator_t&lt;R1&gt;, safe_iterator_t&lt;R2&gt;, O&gt;
        transform(R1&amp;&amp; r1, R2&amp;&amp; r2, O result,
                  F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  // replace:
  template&lt;class ForwardIt, class T&gt;
    constexpr void replace(ForwardIt first, ForwardIt last,
                           const T&amp; old_value, const T&amp; new_value);
  template&lt;class ExecutionPolicy, class ForwardIt, class T&gt;
    void replace(ExecutionPolicy&amp;&amp; exec,
                 ForwardIt first, ForwardIt last,
                 const T&amp; old_value, const T&amp; new_value);
  template&lt;class ForwardIt, class Pred, class T&gt;
    constexpr void replace_if(ForwardIt first, ForwardIt last,
                              Pred pred, const T&amp; new_value);
  template&lt;class ExecutionPolicy, class ForwardIt, class Pred, class T&gt;
    void replace_if(ExecutionPolicy&amp;&amp; exec,
                    ForwardIt first, ForwardIt last,
                    Pred pred, const T&amp; new_value);
 
  namespace ranges {
    template&lt;InputIterator I, Sentinel&lt;I&gt; S, class T1, class T2, class Proj = identity&gt;
      requires Writable&lt;I, const T2&amp;&gt; &amp;&amp;
               IndirectRelation&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T1*&gt;
      constexpr I
        replace(I first, S last, const T1&amp; old_value, const T2&amp; new_value, Proj proj = {});
    template&lt;InputRange R, class T1, class T2, class Proj = identity&gt;
      requires Writable&lt;iterator_t&lt;R&gt;, const T2&amp;&gt; &amp;&amp;
               IndirectRelation&lt;ranges::equal_to, projected&lt;iterator_t&lt;R&gt;, Proj&gt;,
                 const T1*&gt;
      constexpr safe_iterator_t&lt;R&gt;
        replace(R&amp;&amp; r, const T1&amp; old_value, const T2&amp; new_value, Proj proj = {});
    template&lt;InputIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      requires Writable&lt;I, const T&amp;&gt;
      constexpr I replace_if(I first, S last,
                             Pred pred, const T&amp; new_value, Proj proj = {});
    template&lt;InputRange R, class T, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      requires Writable&lt;iterator_t&lt;R&gt;, const T&amp;&gt;
      constexpr safe_iterator_t&lt;R&gt;
        replace_if(R&amp;&amp; r, Pred pred, const T&amp; new_value, Proj proj = {});
  }
 
  template&lt;class InputIt, class OutputIt, class T&gt;
    constexpr OutputIt replace_copy(InputIt first, InputIt last, OutputIt result,
                                    const T&amp; old_value, const T&amp; new_value);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2, class T&gt;
    ForwardIt2 replace_copy(ExecutionPolicy&amp;&amp; exec,
                            ForwardIt1 first, ForwardIt1 last, ForwardIt2 result,
                            const T&amp; old_value, const T&amp; new_value);
  template&lt;class InputIt, class OutputIt, class Pred, class T&gt;
    constexpr OutputIt replace_copy_if(InputIt first, InputIt last, OutputIt result,
                                       Pred pred, const T&amp; new_value);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2, class Pred, class T&gt;
    ForwardIt2 replace_copy_if(ExecutionPolicy&amp;&amp; exec,
                               ForwardIt1 first, ForwardIt1 last, ForwardIt2 result,
                               Pred pred, const T&amp; new_value);
 
  namespace ranges {
    template&lt;class I, class O&gt;
    using replace_copy_result = copy_result&lt;I, O&gt;;
 
    template&lt;InputIterator I, Sentinel&lt;I&gt; S, class T1, class T2,
             OutputIterator&lt;const T2&amp;&gt; O, class Proj = identity&gt;
      requires IndirectlyCopyable&lt;I, O&gt; &amp;&amp;
               IndirectRelation&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T1*&gt;
      constexpr replace_copy_result&lt;I, O&gt;
        replace_copy(I first, S last, O result, const T1&amp; old_value, const T2&amp; new_value,
                     Proj proj = {});
    template&lt;InputRange R, class T1, class T2, OutputIterator&lt;const T2&amp;&gt; O,
             class Proj = identity&gt;
      requires IndirectlyCopyable&lt;iterator_t&lt;R&gt;, O&gt; &amp;&amp;
               IndirectRelation&lt;ranges::equal_to, projected&lt;iterator_t&lt;R&gt;, Proj&gt;,
                 const T1*&gt;
      constexpr replace_copy_result&lt;safe_iterator_t&lt;R&gt;, O&gt;
        replace_copy(R&amp;&amp; r, O result, const T1&amp; old_value, const T2&amp; new_value,
                     Proj proj = {});
 
    template&lt;class I, class O&gt;
    using replace_copy_if_result = copy_result&lt;I, O&gt;;
 
    template&lt;InputIterator I, Sentinel&lt;I&gt; S, class T, OutputIterator&lt;const T&amp;&gt; O,
             class Proj = identity, IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      requires IndirectlyCopyable&lt;I, O&gt;
      constexpr replace_copy_if_result&lt;I, O&gt;
        replace_copy_if(I first, S last, O result, Pred pred, const T&amp; new_value,
                        Proj proj = {});
    template&lt;InputRange R, class T, OutputIterator&lt;const T&amp;&gt; O, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      requires IndirectlyCopyable&lt;iterator_t&lt;R&gt;, O&gt;
      constexpr replace_copy_if_result&lt;safe_iterator_t&lt;R&gt;, O&gt;
        replace_copy_if(R&amp;&amp; r, O result, Pred pred, const T&amp; new_value,
                        Proj proj = {});
  }
 
  // fill:
  template&lt;class ForwardIt, class T&gt;
    constexpr void fill(ForwardIt first, ForwardIt last, const T&amp; value);
  template&lt;class ExecutionPolicy, class ForwardIt, class T&gt;
    void fill(ExecutionPolicy&amp;&amp; exec,
              ForwardIt first, ForwardIt last, const T&amp; value);
  template&lt;class OutputIt, class Size, class T&gt;
    constexpr OutputIt fill_n(OutputIt first, Size n, const T&amp; value);
  template&lt;class ExecutionPolicy, class ForwardIt, class Size, class T&gt;
    ForwardIt fill_n(ExecutionPolicy&amp;&amp; exec,
                     ForwardIt first, Size n, const T&amp; value);
 
  namespace ranges {
    template&lt;class T, OutputIterator&lt;const T&amp;&gt; O, Sentinel&lt;O&gt; S&gt;
      constexpr O fill(O first, S last, const T&amp; value);
    template&lt;class T, OutputRange&lt;const T&amp;&gt; R&gt;
      constexpr safe_iterator_t&lt;R&gt; fill(R&amp;&amp; r, const T&amp; value);
    template&lt;class T, OutputIterator&lt;const T&amp;&gt; O&gt;
      constexpr O fill_n(O first, iter_difference_t&lt;O&gt; n, const T&amp; value);
  }
 
  // generate:
  template&lt;class ForwardIt, class Generator&gt;
    constexpr void generate(ForwardIt first, ForwardIt last, Generator gen);
  template&lt;class ExecutionPolicy, class ForwardIt, class Generator&gt;
    void generate(ExecutionPolicy&amp;&amp; exec,
                  ForwardIt first, ForwardIt last, Generator gen);
  template&lt;class OutputIt, class Size, class Generator&gt;
    constexpr OutputIt generate_n(OutputIt first, Size n, Generator gen);
  template&lt;class ExecutionPolicy, class ForwardIt, class Size, class Generator&gt;
    ForwardIt generate_n(ExecutionPolicy&amp;&amp; exec,
                         ForwardIt first, Size n, Generator gen);
 
  namespace ranges {
    template&lt;Iterator O, Sentinel&lt;O&gt; S, CopyConstructible F&gt;
      requires Invocable&lt;F&amp;&gt; &amp;&amp; Writable&lt;O, invoke_result_t&lt;F&amp;&gt;&gt;
      constexpr O generate(O first, S last, F gen);
    template&lt;class R, CopyConstructible F&gt;
      requires Invocable&lt;F&amp;&gt; &amp;&amp; OutputRange&lt;R, invoke_result_t&lt;F&amp;&gt;&gt;
      constexpr safe_iterator_t&lt;R&gt; generate(R&amp;&amp; r, F gen);
    template&lt;Iterator O, CopyConstructible F&gt;
      requires Invocable&lt;F&amp;&gt; &amp;&amp; Writable&lt;O, invoke_result_t&lt;F&amp;&gt;&gt;
      constexpr O generate_n(O first, iter_difference_t&lt;O&gt; n, F gen);
  }
 
  // remove:
  template&lt;class ForwardIt, class T&gt;
    constexpr ForwardIt remove(ForwardIt first, ForwardIt last, const T&amp; value);
  template&lt;class ExecutionPolicy, class ForwardIt, class T&gt;
    ForwardIt remove(ExecutionPolicy&amp;&amp; exec,
                     ForwardIt first, ForwardIt last, const T&amp; value);
  template&lt;class ForwardIt, class Pred&gt;
    constexpr ForwardIt remove_if(ForwardIt first, ForwardIt last, Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIt, class Pred&gt;
    ForwardIt remove_if(ExecutionPolicy&amp;&amp; exec,
                        ForwardIt first, ForwardIt last, Pred pred);
 
  namespace ranges {
    template&lt;Permutable I, Sentinel&lt;I&gt; S, class T, class Proj = identity&gt;
      requires IndirectRelation&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T*&gt;
      constexpr I remove(I first, S last, const T&amp; value, Proj proj = {});
    template&lt;ForwardRange R, class T, class Proj = identity&gt;
      requires Permutable&lt;iterator_t&lt;R&gt;&gt; &amp;&amp;
               IndirectRelation&lt;ranges::equal_to, projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
      constexpr safe_iterator_t&lt;R&gt;
        remove(R&amp;&amp; r, const T&amp; value, Proj proj = {});
    template&lt;Permutable I, Sentinel&lt;I&gt; S, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr I remove_if(I first, S last, Pred pred, Proj proj = {});
    template&lt;ForwardRange R, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      requires Permutable&lt;iterator_t&lt;R&gt;&gt;
      constexpr safe_iterator_t&lt;R&gt;
        remove_if(R&amp;&amp; r, Pred pred, Proj proj = {});
  }
 
  template&lt;class InputIt, class OutputIt, class T&gt;
    constexpr OutputIt
      remove_copy(InputIt first, InputIt last, OutputIt result, const T&amp; value);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2, class T&gt;
    ForwardIt2
      remove_copy(ExecutionPolicy&amp;&amp; exec,
                  ForwardIt1 first, ForwardIt1 last, ForwardIt2 result, const T&amp; value);
  template&lt;class InputIt, class OutputIt, class Pred&gt;
    constexpr OutputIt
      remove_copy_if(InputIt first, InputIt last, OutputIt result, Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2, class Pred&gt;
    ForwardIt2
      remove_copy_if(ExecutionPolicy&amp;&amp; exec,
                     ForwardIt1 first, ForwardIt1 last, ForwardIt2 result, Pred pred);
 
  namespace ranges {
    template&lt;class I, class O&gt;
    using remove_copy_result = copy_result&lt;I, O&gt;;
 
    template&lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O, class T,
             class Proj = identity&gt;
      requires IndirectlyCopyable&lt;I, O&gt; &amp;&amp;
               IndirectRelation&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T*&gt;
      constexpr remove_copy_result&lt;I, O&gt;
        remove_copy(I first, S last, O result, const T&amp; value, Proj proj = {});
    template&lt;InputRange R, WeaklyIncrementable O, class T, class Proj = identity&gt;
      requires IndirectlyCopyable&lt;iterator_t&lt;R&gt;, O&gt; &amp;&amp;
               IndirectRelation&lt;ranges::equal_to, projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
      constexpr remove_copy_result&lt;safe_iterator_t&lt;R&gt;, O&gt;
        remove_copy(R&amp;&amp; r, O result, const T&amp; value, Proj proj = {});
 
    template&lt;class I, class O&gt;
    using remove_copy_if_result = copy_result&lt;I, O&gt;;
 
    template&lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O,
             class Proj = identity, IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      requires IndirectlyCopyable&lt;I, O&gt;
      constexpr remove_copy_if_result&lt;I, O&gt;
        remove_copy_if(I first, S last, O result, Pred pred, Proj proj = {});
    template&lt;InputRange R, WeaklyIncrementable O, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      requires IndirectlyCopyable&lt;iterator_t&lt;R&gt;, O&gt;
      constexpr remove_copy_if_result&lt;safe_iterator_t&lt;R&gt;, O&gt;
        remove_copy_if(R&amp;&amp; r, O result, Pred pred, Proj proj = {});
  }
 
  // unique:
  template&lt;class ForwardIt&gt;
    constexpr ForwardIt unique(ForwardIt first, ForwardIt last);
  template&lt;class ForwardIt, class BinaryPred&gt;
    constexpr ForwardIt unique(ForwardIt first, ForwardIt last, BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIt&gt;
    ForwardIt unique(ExecutionPolicy&amp;&amp; exec,
                     ForwardIt first, ForwardIt last);
  template&lt;class ExecutionPolicy, class ForwardIt, class BinaryPred&gt;
    ForwardIt unique(ExecutionPolicy&amp;&amp; exec,
                     ForwardIt first, ForwardIt last, BinaryPred pred);
 
  namespace ranges {
    template&lt;Permutable I, Sentinel&lt;I&gt; S, class Proj = identity,
             IndirectRelation&lt;projected&lt;I, Proj&gt;&gt; C = ranges::equal_to&gt;
      constexpr I unique(I first, S last, C comp = {}, Proj proj = {});
    template&lt;ForwardRange R, class Proj = identity,
             IndirectRelation&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; C = ranges::equal_to&gt;
      requires Permutable&lt;iterator_t&lt;R&gt;&gt;
      constexpr safe_iterator_t&lt;R&gt;
        unique(R&amp;&amp; r, C comp = {}, Proj proj = {});
  }
 
  template&lt;class InputIt, class OutputIt&gt;
    constexpr OutputIt
      unique_copy(InputIt first, InputIt last, OutputIt result);
  template&lt;class InputIt, class OutputIt, class BinaryPred&gt;
    constexpr OutputIt
      unique_copy(InputIt first, InputIt last, OutputIt result, BinaryPred pred);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2&gt;
    ForwardIt2
      unique_copy(ExecutionPolicy&amp;&amp; exec,
                  ForwardIt1 first, ForwardIt1 last, ForwardIt2 result);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2, class BinaryPred&gt;
    ForwardIt2
      unique_copy(ExecutionPolicy&amp;&amp; exec,
                  ForwardIt1 first, ForwardIt1 last, ForwardIt2 result, BinaryPred pred);
 
  namespace ranges {
    template&lt;class I, class O&gt;
    using unique_copy_result = copy_result&lt;I, O&gt;;
 
    template&lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O,
             class Proj = identity,
             IndirectRelation&lt;projected&lt;I, Proj&gt;&gt; C = ranges::equal_to&gt;
      requires IndirectlyCopyable&lt;I, O&gt; &amp;&amp;
               (ForwardIterator&lt;I&gt; ||
                (InputIterator&lt;O&gt; &amp;&amp; Same&lt;iter_value_t&lt;I&gt;, iter_value_t&lt;O&gt;&gt;) ||
                IndirectlyCopyableStorable&lt;I, O&gt;)
      constexpr unique_copy_result&lt;I, O&gt;
        unique_copy(I first, S last, O result, C comp = {}, Proj proj = {});
    template&lt;InputRange R, WeaklyIncrementable O, class Proj = identity,
             IndirectRelation&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; C = ranges::equal_to&gt;
      requires IndirectlyCopyable&lt;iterator_t&lt;R&gt;, O&gt; &amp;&amp;
               (ForwardIterator&lt;iterator_t&lt;R&gt;&gt; ||
                (InputIterator&lt;O&gt; &amp;&amp; Same&lt;iter_value_t&lt;iterator_t&lt;R&gt;&gt;, iter_value_t&lt;O&gt;&gt;) ||
                IndirectlyCopyableStorable&lt;iterator_t&lt;R&gt;, O&gt;)
      constexpr unique_copy_result&lt;safe_iterator_t&lt;R&gt;, O&gt;
        unique_copy(R&amp;&amp; r, O result, C comp = {}, Proj proj = {});
  }
 
  // reverse:
  template&lt;class BidirectionalIt&gt;
    constexpr void reverse(BidirectionalIt first, BidirectionalIt last);
  template&lt;class ExecutionPolicy, class BidirectionalIt&gt;
    void reverse(ExecutionPolicy&amp;&amp; exec,
                 BidirectionalIt first, BidirectionalIt last);
 
  namespace ranges {
    template&lt;BidirectionalIterator I, Sentinel&lt;I&gt; S&gt;
      requires Permutable&lt;I&gt;
      constexpr I reverse(I first, S last);
    template&lt;BidirectionalRange R&gt;
      requires Permutable&lt;iterator_t&lt;R&gt;&gt;
      constexpr safe_iterator_t&lt;R&gt; reverse(R&amp;&amp; r);
  }
 
  template&lt;class BidirectionalIt, class OutputIt&gt;
    constexpr OutputIt
      reverse_copy(BidirectionalIt first, BidirectionalIt last, OutputIt result);
  template&lt;class ExecutionPolicy, class BidirectionalIt, class ForwardIt&gt;
    ForwardIt
      reverse_copy(ExecutionPolicy&amp;&amp; exec,
                   BidirectionalIt first, BidirectionalIt last, ForwardIt result);
 
  namespace ranges {
    template&lt;class I, class O&gt;
    using reverse_copy_result = copy_result&lt;I, O&gt;;
 
    template&lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O&gt;
      requires IndirectlyCopyable&lt;I, O&gt;
      constexpr reverse_copy_result&lt;I, O&gt;
        reverse_copy(I first, S last, O result);
    template&lt;BidirectionalRange R, WeaklyIncrementable O&gt;
      requires IndirectlyCopyable&lt;iterator_t&lt;R&gt;, O&gt;
      constexpr reverse_copy_result&lt;safe_iterator_t&lt;R&gt;, O&gt;
        reverse_copy(R&amp;&amp; r, O result);
  }
 
  // rotate:
  template&lt;class ForwardIt&gt;
    constexpr ForwardIt rotate(ForwardIt first, ForwardIt middle, ForwardIt last);
  template&lt;class ExecutionPolicy, class ForwardIt&gt;
    ForwardIt rotate(ExecutionPolicy&amp;&amp; exec,
                     ForwardIt first, ForwardIt middle, ForwardIt last);
 
  namespace ranges {
    template&lt;Permutable I, Sentinel&lt;I&gt; S&gt;
      constexpr subrange&lt;I&gt; rotate(I first, I middle, S last);
    template&lt;ForwardRange R&gt;
      requires Permutable&lt;iterator_t&lt;R&gt;&gt;
      constexpr safe_subrange_t&lt;R&gt; rotate(R&amp;&amp; r, iterator_t&lt;R&gt; middle);
  }
 
  template&lt;class ForwardIt, class OutputIt&gt;
    constexpr OutputIt
      rotate_copy(ForwardIt first, ForwardIt middle, ForwardIt last, OutputIt result);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2&gt;
    ForwardIt2
      rotate_copy(ExecutionPolicy&amp;&amp; exec,
                  ForwardIt1 first, ForwardIt1 middle, ForwardIt1 last, ForwardIt2 result);
 
  namespace ranges {
    template&lt;class I, class O&gt;
    using rotate_copy_result = copy_result&lt;I, O&gt;;
 
    template&lt;ForwardIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O&gt;
      requires IndirectlyCopyable&lt;I, O&gt;
      constexpr rotate_copy_result&lt;I, O&gt;
        rotate_copy(I first, I middle, S last, O result);
    template&lt;ForwardRange R, WeaklyIncrementable O&gt;
      requires IndirectlyCopyable&lt;iterator_t&lt;R&gt;, O&gt;
      constexpr rotate_copy_result&lt;safe_iterator_t&lt;R&gt;, O&gt;
        rotate_copy(R&amp;&amp; r, iterator_t&lt;R&gt; middle, O result);
  }
 
  // sample:
  template&lt;class PopulationIt, class SampleIt,
           class Distance, class UniformRndBitGen&gt;
    SampleIt sample(PopulationIt first, PopulationIt last, SampleIt out, Distance n,
                    UniformRndBitGen&amp;&amp; g);
 
  // shuffle:
  template&lt;class RandomAccessIt, class UniformRndBitGen&gt;
    void shuffle(RandomAccessIt first, RandomAccessIt last, UniformRndBitGen&amp;&amp; g);
 
  namespace ranges {
    template&lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Gen&gt;
      requires Permutable&lt;I&gt; &amp;&amp;
               UniformRandomBitGenerator&lt;remove_reference_t&lt;Gen&gt;&gt; &amp;&amp;
               ConvertibleTo&lt;invoke_result_t&lt;Gen&amp;&gt;, iter_difference_t&lt;I&gt;&gt;
      I shuffle(I first, S last, Gen&amp;&amp; g);
    template&lt;RandomAccessRange R, class Gen&gt;
      requires Permutable&lt;iterator_t&lt;R&gt;&gt; &amp;&amp;
               UniformRandomBitGenerator&lt;remove_reference_t&lt;Gen&gt;&gt; &amp;&amp;
               ConvertibleTo&lt;invoke_result_t&lt;Gen&amp;&gt;, iter_difference_t&lt;iterator_t&lt;R&gt;&gt;&gt;
      safe_iterator_t&lt;R&gt; shuffle(R&amp;&amp; r, Gen&amp;&amp; g);
  }
 
  // shift:
  template&lt;class ForwardIt&gt;
    constexpr ForwardIt
      shift_left(ForwardIt first, ForwardIt last,
                 typename iterator_traits&lt;ForwardIt&gt;::difference_type n);
  template&lt;class ExecutionPolicy, class ForwardIt&gt;
    ForwardIt
      shift_left(ExecutionPolicy&amp;&amp; exec,
                 ForwardIt first, ForwardIt last,
                 typename iterator_traits&lt;ForwardIt&gt;::difference_type n);
  template&lt;class ForwardIt&gt;
    constexpr ForwardIt
      shift_right(ForwardIt first, ForwardIt last,
                  typename iterator_traits&lt;ForwardIt&gt;::difference_type n);
  template&lt;class ExecutionPolicy, class ForwardIt&gt;
    ForwardIt
      shift_right(ExecutionPolicy&amp;&amp; exec,
                  ForwardIt first, ForwardIt last,
                  typename iterator_traits&lt;ForwardIt&gt;::difference_type n);
 
  // sorting and related operations:
  // sorting:
  template&lt;class RandomAccessIt&gt;
    constexpr void sort(RandomAccessIt first, RandomAccessIt last);
  template&lt;class RandomAccessIt, class Compare&gt;
    constexpr void sort(RandomAccessIt first, RandomAccessIt last, Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIt&gt;
    void sort(ExecutionPolicy&amp;&amp; exec,
              RandomAccessIt first, RandomAccessIt last);
  template&lt;class ExecutionPolicy, class RandomAccessIt, class Compare&gt;
    void sort(ExecutionPolicy&amp;&amp; exec,
              RandomAccessIt first, RandomAccessIt last, Compare comp);
 
  namespace ranges {
    template&lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires Sortable&lt;I, Comp, Proj&gt;
      constexpr I
        sort(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;RandomAccessRange R, class Comp = ranges::less, class Proj = identity&gt;
      requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr safe_iterator_t&lt;R&gt;
        sort(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class RandomAccessIt&gt;
    void stable_sort(RandomAccessIt first, RandomAccessIt last);
  template&lt;class RandomAccessIt, class Compare&gt;
    void stable_sort(RandomAccessIt first, RandomAccessIt last, Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIt&gt;
    void stable_sort(ExecutionPolicy&amp;&amp; exec,
                     RandomAccessIt first, RandomAccessIt last);
  template&lt;class ExecutionPolicy, class RandomAccessIt, class Compare&gt;
    void stable_sort(ExecutionPolicy&amp;&amp; exec,
                     RandomAccessIt first, RandomAccessIt last, Compare comp);
 
  namespace ranges {
    template&lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires Sortable&lt;I, Comp, Proj&gt;
      I stable_sort(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;RandomAccessRange R, class Comp = ranges::less, class Proj = identity&gt;
      requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      safe_iterator_t&lt;R&gt;
        stable_sort(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class RandomAccessIt&gt;
    constexpr void partial_sort(RandomAccessIt first, RandomAccessIt middle,
                                RandomAccessIt last);
  template&lt;class RandomAccessIt, class Compare&gt;
    constexpr void partial_sort(RandomAccessIt first, RandomAccessIt middle,
                                RandomAccessIt last, Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIt&gt;
    void partial_sort(ExecutionPolicy&amp;&amp; exec,
                      RandomAccessIt first, RandomAccessIt middle, RandomAccessIt last);
  template&lt;class ExecutionPolicy, class RandomAccessIt, class Compare&gt;
    void partial_sort(ExecutionPolicy&amp;&amp; exec,
                      RandomAccessIt first, RandomAccessIt middle, RandomAccessIt last,
                      Compare comp);
 
  namespace ranges {
    template&lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires Sortable&lt;I, Comp, Proj&gt;
      constexpr I
        partial_sort(I first, I middle, S last, Comp comp = {}, Proj proj = {});
    template&lt;RandomAccessRange R, class Comp = ranges::less, class Proj = identity&gt;
      requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr safe_iterator_t&lt;R&gt;
        partial_sort(R&amp;&amp; r, iterator_t&lt;R&gt; middle, Comp comp = {},
                     Proj proj = {});
  }
 
  template&lt;class InputIt, class RandomAccessIt&gt;
    constexpr RandomAccessIt
      partial_sort_copy(InputIt first, InputIt last,
                        RandomAccessIt result_first, RandomAccessIt result_last);
  template&lt;class InputIt, class RandomAccessIt, class Compare&gt;
    constexpr RandomAccessIt
      partial_sort_copy(InputIt first, InputIt last,
                        RandomAccessIt result_first, RandomAccessIt result_last,
                        Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIt, class RandomAccessIt&gt;
    RandomAccessIt
      partial_sort_copy(ExecutionPolicy&amp;&amp; exec, 
                        ForwardIt first, ForwardIt last,
                        RandomAccessIt result_first, RandomAccessIt result_last);
  template&lt;class ExecutionPolicy, class ForwardIt, class RandomAccessIt, class Compare&gt;
    RandomAccessIt
      partial_sort_copy(ExecutionPolicy&amp;&amp; exec, 
                        ForwardIt first, ForwardIt last,
                        RandomAccessIt result_first, RandomAccessIt result_last,
                        Compare comp);
 
  namespace ranges {
    template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, RandomAccessIterator I2, Sentinel&lt;I2&gt; S2,
             class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&gt;
      requires IndirectlyCopyable&lt;I1, I2&gt; &amp;&amp; Sortable&lt;I2, Comp, Proj2&gt; &amp;&amp;
               IndirectStrictWeakOrder&lt;Comp, projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt;
      constexpr I2
        partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
                          Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;InputRange R1, RandomAccessRange R2, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity&gt;
      requires IndirectlyCopyable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;&gt; &amp;&amp;
               Sortable&lt;iterator_t&lt;R2&gt;, Comp, Proj2&gt; &amp;&amp;
               IndirectStrictWeakOrder&lt;Comp, projected&lt;iterator_t&lt;R1&gt;, Proj1&gt;,
                                       projected&lt;iterator_t&lt;R2&gt;, Proj2&gt;&gt;
      constexpr safe_iterator_t&lt;R2&gt;
        partial_sort_copy(R1&amp;&amp; r, R2&amp;&amp; result_r, Comp comp = {},
                          Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  template&lt;class ForwardIt&gt;
    constexpr bool is_sorted(ForwardIt first, ForwardIt last);
  template&lt;class ForwardIt, class Compare&gt;
    constexpr bool is_sorted(ForwardIt first, ForwardIt last, Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIt&gt;
    bool is_sorted(ExecutionPolicy&amp;&amp; exec,
                   ForwardIt first, ForwardIt last);
  template&lt;class ExecutionPolicy, class ForwardIt, class Compare&gt;
    bool is_sorted(ExecutionPolicy&amp;&amp; exec,
                   ForwardIt first, ForwardIt last, Compare comp);
 
  namespace ranges {
    template&lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr bool is_sorted(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;ForwardRange R, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr bool is_sorted(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class ForwardIt&gt;
    constexpr ForwardIt
      is_sorted_until(ForwardIt first, ForwardIt last);
  template&lt;class ForwardIt, class Compare&gt;
    constexpr ForwardIt
      is_sorted_until(ForwardIt first, ForwardIt last, Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIt&gt;
    ForwardIt
      is_sorted_until(ExecutionPolicy&amp;&amp; exec,
                      ForwardIt first, ForwardIt last);
  template&lt;class ExecutionPolicy, class ForwardIt, class Compare&gt;
    ForwardIt
      is_sorted_until(ExecutionPolicy&amp;&amp; exec,
                      ForwardIt first, ForwardIt last, Compare comp);
 
  namespace ranges {
    template&lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr I is_sorted_until(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;ForwardRange R, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr safe_iterator_t&lt;R&gt;
        is_sorted_until(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  // Nth element:
  template&lt;class RandomAccessIt&gt;
    constexpr void nth_element(RandomAccessIt first, RandomAccessIt nth,
                               RandomAccessIt last);
  template&lt;class RandomAccessIt, class Compare&gt;
    constexpr void nth_element(RandomAccessIt first, RandomAccessIt nth,
                               RandomAccessIt last, Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIt&gt;
    void nth_element(ExecutionPolicy&amp;&amp; exec,
                     RandomAccessIt first, RandomAccessIt nth,
                     RandomAccessIt last);
  template&lt;class ExecutionPolicy, class RandomAccessIt, class Compare&gt;
    void nth_element(ExecutionPolicy&amp;&amp; exec,
                     RandomAccessIt first, RandomAccessIt nth,
                     RandomAccessIt last, Compare comp);
 
  namespace ranges {
    template&lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires Sortable&lt;I, Comp, Proj&gt;
      constexpr I
        nth_element(I first, I nth, S last, Comp comp = {}, Proj proj = {});
    template&lt;RandomAccessRange R, class Comp = ranges::less, class Proj = identity&gt;
      requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr safe_iterator_t&lt;R&gt;
        nth_element(R&amp;&amp; r, iterator_t&lt;R&gt; nth, Comp comp = {}, Proj proj = {});
  }
 
  // binary search:
  template&lt;class ForwardIt, class T&gt;
    constexpr ForwardIt
      lower_bound(ForwardIt first, ForwardIt last, const T&amp; value);
  template&lt;class ForwardIt, class T, class Compare&gt;
    constexpr ForwardIt
      lower_bound(ForwardIt first, ForwardIt last, const T&amp; value, Compare comp);
 
  namespace ranges {
    template&lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
             IndirectStrictWeakOrder&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr I lower_bound(I first, S last, const T&amp; value, Comp comp = {},
                              Proj proj = {});
    template&lt;ForwardRange R, class T, class Proj = identity,
             IndirectStrictWeakOrder&lt;const T*, projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp =
               ranges::less&gt;
      constexpr safe_iterator_t&lt;R&gt;
        lower_bound(R&amp;&amp; r, const T&amp; value, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class ForwardIt, class T&gt;
    constexpr ForwardIt
      upper_bound(ForwardIt first, ForwardIt last, const T&amp; value);
  template&lt;class ForwardIt, class T, class Compare&gt;
    constexpr ForwardIt
      upper_bound(ForwardIt first, ForwardIt last, const T&amp; value, Compare comp);
 
  namespace ranges {
    template&lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
             IndirectStrictWeakOrder&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr I upper_bound(I first, S last,
                              const T&amp; value, Comp comp = {}, Proj proj = {});
    template&lt;ForwardRange R, class T, class Proj = identity,
             IndirectStrictWeakOrder&lt;const T*, projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp =
               ranges::less&gt;
      constexpr safe_iterator_t&lt;R&gt;
        upper_bound(R&amp;&amp; r, const T&amp; value, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class ForwardIt, class T&gt;
    constexpr pair&lt;ForwardIt, ForwardIt&gt;
      equal_range(ForwardIt first, ForwardIt last, const T&amp; value);
  template&lt;class ForwardIt, class T, class Compare&gt;
    constexpr pair&lt;ForwardIt, ForwardIt&gt;
      equal_range(ForwardIt first, ForwardIt last, const T&amp; value, Compare comp);
 
  namespace ranges {
    template&lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
             IndirectStrictWeakOrder&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr subrange&lt;I&gt;
        equal_range(I first, S last, const T&amp; value, Comp comp = {}, Proj proj = {});
    template&lt;ForwardRange R, class T, class Proj = identity,
             IndirectStrictWeakOrder&lt;const T*, projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp =
               ranges::less&gt;
      constexpr safe_subrange_t&lt;R&gt;
        equal_range(R&amp;&amp; r, const T&amp; value, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class ForwardIt, class T&gt;
    constexpr bool
      binary_search(ForwardIt first, ForwardIt last, const T&amp; value);
  template&lt;class ForwardIt, class T, class Compare&gt;
    constexpr bool
      binary_search(ForwardIt first, ForwardIt last, const T&amp; value, Compare comp);
 
  namespace ranges {
    template&lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
             IndirectStrictWeakOrder&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr bool binary_search(I first, S last, const T&amp; value, Comp comp = {},
                                   Proj proj = {});
    template&lt;ForwardRange R, class T, class Proj = identity,
             IndirectStrictWeakOrder&lt;const T*, projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp =
               ranges::less&gt;
      constexpr bool binary_search(R&amp;&amp; r, const T&amp; value, Comp comp = {},
                                   Proj proj = {});
  }
 
  // partitions:
  template&lt;class InputIt, class Pred&gt;
    constexpr bool is_partitioned(InputIt first, InputIt last, Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIt, class Pred&gt;
    bool is_partitioned(ExecutionPolicy&amp;&amp; exec,
                        ForwardIt first, ForwardIt last, Pred pred);
 
  namespace ranges {
    template&lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr bool is_partitioned(I first, S last, Pred pred, Proj proj = {});
    template&lt;InputRange R, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      constexpr bool is_partitioned(R&amp;&amp; r, Pred pred, Proj proj = {});
  }
 
  template&lt;class ForwardIt, class Pred&gt;
    constexpr ForwardIt partition(ForwardIt first, ForwardIt last, Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIt, class Pred&gt;
    ForwardIt partition(ExecutionPolicy&amp;&amp; exec,
                        ForwardIt first, ForwardIt last, Pred pred);
 
  namespace ranges {
    template&lt;Permutable I, Sentinel&lt;I&gt; S, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr I
        partition(I first, S last, Pred pred, Proj proj = {});
    template&lt;ForwardRange R, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      requires Permutable&lt;iterator_t&lt;R&gt;&gt;
      constexpr safe_iterator_t&lt;R&gt;
        partition(R&amp;&amp; r, Pred pred, Proj proj = {});
  }
 
  template&lt;class BidirectionalIt, class Pred&gt;
    BidirectionalIt stable_partition(BidirectionalIt first, BidirectionalIt last,
                                     Pred pred);
  template&lt;class ExecutionPolicy, class BidirectionalIt, class Pred&gt;
    BidirectionalIt stable_partition(ExecutionPolicy&amp;&amp; exec,
                                     BidirectionalIt first, BidirectionalIt last,
                                     Pred pred);
 
  namespace ranges {
    template&lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      requires Permutable&lt;I&gt;
      I stable_partition(I first, S last, Pred pred, Proj proj = {});
    template&lt;BidirectionalRange R, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      requires Permutable&lt;iterator_t&lt;R&gt;&gt;
      safe_iterator_t&lt;R&gt; stable_partition(R&amp;&amp; r, Pred pred, Proj proj = {});
  }
 
  template&lt;class InputIt, class OutputIt1, class OutputIt2, class Pred&gt;
    constexpr pair&lt;OutputIt1, OutputIt2&gt;
      partition_copy(InputIt first, InputIt last, OutputIt1 out_true, OutputIt2 out_false,
                     Pred pred);
  template&lt;class ExecutionPolicy, class ForwardIt, class ForwardIt1,
           class ForwardIt2, class Pred&gt;
    pair&lt;ForwardIt1, ForwardIt2&gt;
      partition_copy(ExecutionPolicy&amp;&amp; exec,
                     ForwardIt first, ForwardIt last,
                     ForwardIt1 out_true, ForwardIt2 out_false,
                     Pred pred);
 
  namespace ranges {
    template&lt;class I, class O1, class O2&gt;
    struct partition_copy_result {
      [[no_unique_address]] I  in;
      [[no_unique_address]] O1 out1;
      [[no_unique_address]] O2 out2;
 
      template&lt;class II, class OO1, class OO2&gt;
        requires ConvertibleTo&lt;const I&amp;, II&gt; &amp;&amp;
          ConvertibleTo&lt;const O1&amp;, OO1&gt; &amp;&amp; ConvertibleTo&lt;const O2&amp;, OO2&gt;
        operator partition_copy_result&lt;II, OO1, OO2&gt;() const &amp; {
          return {in, out1, out2};
        }
 
      template&lt;class II, class OO1, class OO2&gt;
        requires ConvertibleTo&lt;I, II&gt; &amp;&amp;
          ConvertibleTo&lt;O1, OO1&gt; &amp;&amp; ConvertibleTo&lt;O2, OO2&gt;
        operator partition_copy_result&lt;II, OO1, OO2&gt;() &amp;&amp; {
          return {std::move(in), std::move(out1), std::move(out2)};
        }
    };
 
    template&lt;InputIterator I, Sentinel&lt;I&gt; S,
             WeaklyIncrementable O1, WeaklyIncrementable O2,
             class Proj = identity, IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      requires IndirectlyCopyable&lt;I, O1&gt; &amp;&amp; IndirectlyCopyable&lt;I, O2&gt;
      constexpr partition_copy_result&lt;I, O1, O2&gt;
        partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred,
                       Proj proj = {});
    template&lt;InputRange R, WeaklyIncrementable O1, WeaklyIncrementable O2,
             class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      requires IndirectlyCopyable&lt;iterator_t&lt;R&gt;, O1&gt; &amp;&amp;
               IndirectlyCopyable&lt;iterator_t&lt;R&gt;, O2&gt;
      constexpr partition_copy_result&lt;safe_iterator_t&lt;R&gt;, O1, O2&gt;
        partition_copy(R&amp;&amp; r, O1 out_true, O2 out_false, Pred pred, Proj proj = {});
  }
 
  template&lt;class ForwardIt, class Pred&gt;
    constexpr ForwardIt
      partition_point(ForwardIt first, ForwardIt last, Pred pred);
 
  namespace ranges {
    template&lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
      constexpr I partition_point(I first, S last, Pred pred, Proj proj = {});
    template&lt;ForwardRange R, class Proj = identity,
             IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
      constexpr safe_iterator_t&lt;R&gt;
        partition_point(R&amp;&amp; r, Pred pred, Proj proj = {});
  }
 
  // merge:
  template&lt;class InputIt1, class InputIt2, class OutputIt&gt;
    constexpr OutputIt
      merge(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
            OutputIt result);
  template&lt;class InputIt1, class InputIt2, class OutputIt, class Compare&gt;
    constexpr OutputIt
      merge(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
            OutputIt result, Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2, class ForwardIt&gt;
    ForwardIt
      merge(ExecutionPolicy&amp;&amp; exec,
            ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2,
            ForwardIt result);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2,
           class ForwardIt, class Compare&gt;
    ForwardIt
      merge(ExecutionPolicy&amp;&amp; exec,
            ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2,
            ForwardIt result, Compare comp);
 
  namespace ranges {
    template&lt;class I1, class I2, class O&gt;
    using merge_result = binary_transform_result&lt;I1, I2, O&gt;;
 
    template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
             WeaklyIncrementable O, class Comp = ranges::less, class Proj1 = identity,
             class Proj2 = identity&gt;
      requires Mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
      constexpr merge_result&lt;I1, I2, O&gt;
        merge(I1 first1, S1 last1, I2 first2, S2 last2, O result,
              Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;InputRange R1, InputRange R2, WeaklyIncrementable O,
             class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&gt;
      requires Mergeable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, O, Comp, Proj1, Proj2&gt;
      constexpr merge_result&lt;safe_iterator_t&lt;R1&gt;, safe_iterator_t&lt;R2&gt;, O&gt;
        merge(R1&amp;&amp; r1, R2&amp;&amp; r2, O result,
              Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  template&lt;class BidirectionalIt&gt;
    void inplace_merge(BidirectionalIt first,
                       BidirectionalIt middle,
                       BidirectionalIt last);
  template&lt;class BidirectionalIt, class Compare&gt;
    void inplace_merge(BidirectionalIt first,
                       BidirectionalIt middle,
                       BidirectionalIt last, Compare comp);
  template&lt;class ExecutionPolicy, class BidirectionalIt&gt;
    void inplace_merge(ExecutionPolicy&amp;&amp; exec,
                       BidirectionalIt first,
                       BidirectionalIt middle,
                       BidirectionalIt last);
  template&lt;class ExecutionPolicy, class BidirectionalIt, class Compare&gt;
    void inplace_merge(ExecutionPolicy&amp;&amp; exec,
                       BidirectionalIt first,
                       BidirectionalIt middle,
                       BidirectionalIt last, Compare comp);
 
  namespace ranges {
    template&lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires Sortable&lt;I, Comp, Proj&gt;
      I inplace_merge(I first, I middle, S last, Comp comp = {}, Proj proj = {});
    template&lt;BidirectionalRange R, class Comp = ranges::less, class Proj = identity&gt;
      requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      safe_iterator_t&lt;R&gt;
        inplace_merge(R&amp;&amp; r, iterator_t&lt;R&gt; middle, Comp comp = {},
                      Proj proj = {});
  }
 
  // set operations:
  template&lt;class InputIt1, class InputIt2&gt;
    constexpr bool includes(InputIt1 first1, InputIt1 last1,
                            InputIt2 first2, InputIt2 last2);
  template&lt;class InputIt1, class InputIt2, class Compare&gt;
    constexpr bool includes(InputIt1 first1, InputIt1 last1,
                            InputIt2 first2, InputIt2 last2,
                            Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2&gt;
    bool includes(ExecutionPolicy&amp;&amp; exec,
                  ForwardIt1 first1, ForwardIt1 last1,
                  ForwardIt2 first2, ForwardIt2 last2);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2,
           class Compare&gt;
    bool includes(ExecutionPolicy&amp;&amp; exec,
                  ForwardIt1 first1, ForwardIt1 last1,
                  ForwardIt2 first2, ForwardIt2 last2,
                  Compare comp);
 
  namespace ranges {
    template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
             class Proj1 = identity, class Proj2 = identity,
             IndirectStrictWeakOrder&lt;projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt; Comp =
               ranges::less&gt;
      constexpr bool includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;InputRange R1, InputRange R2, class Proj1 = identity,
             class Proj2 = identity,
             IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;R1&gt;, Proj1&gt;,
                                     projected&lt;iterator_t&lt;R2&gt;, Proj2&gt;&gt; Comp = ranges::less&gt;
      constexpr bool includes(R1&amp;&amp; r1, R2&amp;&amp; r2, Comp comp = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  template&lt;class InputIt1, class InputIt2, class OutputIt&gt;
    constexpr OutputIt
      set_union(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
                OutputIt result);
  template&lt;class InputIt1, class InputIt2, class OutputIt, class Compare&gt;
    constexpr OutputIt
                set_union(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
                OutputIt result, Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2,
           class ForwardIt&gt;
    ForwardIt
      set_union(ExecutionPolicy&amp;&amp; exec,
                ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2,
                ForwardIt result);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2,
           class ForwardIt, class Compare&gt;
    ForwardIt
      set_union(ExecutionPolicy&amp;&amp; exec,
                ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2,
                ForwardIt result, Compare comp);
 
  namespace ranges {
    template&lt;class I1, class I2, class O&gt;
    using set_union_result = binary_transform_result&lt;I1, I2, O&gt;;
 
    template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
             WeaklyIncrementable O, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity&gt;
      requires Mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
      constexpr set_union_result&lt;I1, I2, O&gt;
        set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {},
                  Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;InputRange R1, InputRange R2, WeaklyIncrementable O,
             class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&gt;
      requires Mergeable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, O, Comp, Proj1, Proj2&gt;
      constexpr set_union_result&lt;safe_iterator_t&lt;R1&gt;, safe_iterator_t&lt;R2&gt;, O&gt;
        set_union(R1&amp;&amp; r1, R2&amp;&amp; r2, O result, Comp comp = {},
                  Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  template&lt;class InputIt1, class InputIt2, class OutputIt&gt;
    constexpr OutputIt
      set_intersection(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
                       OutputIt result);
  template&lt;class InputIt1, class InputIt2, class OutputIt, class Compare&gt;
    constexpr OutputIt
      set_intersection(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
                       OutputIt result, Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2,
           class ForwardIt&gt;
    ForwardIt
      set_intersection(ExecutionPolicy&amp;&amp; exec,
                       ForwardIt1 first1, ForwardIt1 last1,
                       ForwardIt2 first2, ForwardIt2 last2,
                       ForwardIt result);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2,
           class ForwardIt, class Compare&gt;
    ForwardIt
      set_intersection(ExecutionPolicy&amp;&amp; exec,
                       ForwardIt1 first1, ForwardIt1 last1,
                       ForwardIt2 first2, ForwardIt2 last2,
                       ForwardIt result, Compare comp);
 
  namespace ranges {
    template&lt;class I1, class I2, class O&gt;
    using set_intersection_result = binary_transform_result&lt;I1, I2, O&gt;;
 
    template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
             WeaklyIncrementable O, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity&gt;
      requires Mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
      constexpr set_intersection_result&lt;I1, I2, O&gt;
        set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                         Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;InputRange R1, InputRange R2, WeaklyIncrementable O,
             class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&gt;
      requires Mergeable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, O, Comp, Proj1, Proj2&gt;
      constexpr set_intersection_result&lt;safe_iterator_t&lt;R1&gt;, safe_iterator_t&lt;R2&gt;, O&gt;
        set_intersection(R1&amp;&amp; r1, R2&amp;&amp; r2, O result,
                         Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  template&lt;class InputIt1, class InputIt2, class OutputIt&gt;
    constexpr OutputIt
      set_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
                     OutputIt result);
  template&lt;class InputIt1, class InputIt2, class OutputIt, class Compare&gt;
    constexpr OutputIt
      set_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
                     OutputIt result, Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2,
           class ForwardIt&gt;
    ForwardIt
      set_difference(ExecutionPolicy&amp;&amp; exec,
                     ForwardIt1 first1, ForwardIt1 last1,
                     ForwardIt2 first2, ForwardIt2 last2,
                     ForwardIt result);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2,
           class ForwardIt, class Compare&gt;
    ForwardIt
      set_difference(ExecutionPolicy&amp;&amp; exec,
                     ForwardIt1 first1, ForwardIt1 last1,
                     ForwardIt2 first2, ForwardIt2 last2,
                     ForwardIt result, Compare comp);
 
  namespace ranges {
    template&lt;class I, class O&gt;
    using set_difference_result = copy_result&lt;I, O&gt;;
 
    template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
             WeaklyIncrementable O, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity&gt;
      requires Mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
      constexpr set_difference_result&lt;I1, O&gt;
        set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                       Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;InputRange R1, InputRange R2, WeaklyIncrementable O,
             class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&gt;
      requires Mergeable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, O, Comp, Proj1, Proj2&gt;
      constexpr set_difference_result&lt;safe_iterator_t&lt;R1&gt;, O&gt;
        set_difference(R1&amp;&amp; r1, R2&amp;&amp; r2, O result,
                       Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  template&lt;class InputIt1, class InputIt2, class OutputIt&gt;
    constexpr OutputIt
      set_symmetric_difference(InputIt1 first1, InputIt1 last1,
                               InputIt2 first2, InputIt2 last2,
                               OutputIt result);
  template&lt;class InputIt1, class InputIt2, class OutputIt, class Compare&gt;
    constexpr OutputIt
      set_symmetric_difference(InputIt1 first1, InputIt1 last1,
                               InputIt2 first2, InputIt2 last2,
                               OutputIt result, Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2,
           class ForwardIt&gt;
    ForwardIt
      set_symmetric_difference(ExecutionPolicy&amp;&amp; exec,
                               ForwardIt1 first1, ForwardIt1 last1,
                               ForwardIt2 first2, ForwardIt2 last2,
                               ForwardIt result);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2,
           class ForwardIt, class Compare&gt;
    ForwardIt
      set_symmetric_difference(ExecutionPolicy&amp;&amp; exec,
                               ForwardIt1 first1, ForwardIt1 last1,
                               ForwardIt2 first2, ForwardIt2 last2,
                               ForwardIt result, Compare comp);
 
  namespace ranges {
    template&lt;class I1, class I2, class O&gt;
    using set_symmetric_difference_result = binary_transform_result&lt;I1, I2, O&gt;;
 
    template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
             WeaklyIncrementable O, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity&gt;
      requires Mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
      constexpr set_symmetric_difference_result&lt;I1, I2, O&gt;
        set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                                 Comp comp = {}, Proj1 proj1 = {},
                                 Proj2 proj2 = {});
    template&lt;InputRange R1, InputRange R2, WeaklyIncrementable O,
             class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&gt;
      requires Mergeable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, O, Comp, Proj1, Proj2&gt;
      constexpr
        set_symmetric_difference_result&lt;safe_iterator_t&lt;R1&gt;, safe_iterator_t&lt;R2&gt;, O&gt;
        set_symmetric_difference(R1&amp;&amp; r1, R2&amp;&amp; r2, O result, Comp comp = {},
                                 Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  // heap operations:
  template&lt;class RandomAccessIt&gt;
    constexpr void push_heap(RandomAccessIt first, RandomAccessIt last);
  template&lt;class RandomAccessIt, class Compare&gt;
    constexpr void push_heap(RandomAccessIt first, RandomAccessIt last, Compare comp);
 
  namespace ranges {
    template&lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires Sortable&lt;I, Comp, Proj&gt;
      constexpr I
        push_heap(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;RandomAccessRange R, class Comp = ranges::less, class Proj = identity&gt;
      requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr safe_iterator_t&lt;R&gt;
        push_heap(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class RandomAccessIt&gt;
    constexpr void pop_heap(RandomAccessIt first, RandomAccessIt last);
  template&lt;class RandomAccessIt, class Compare&gt;
    constexpr void pop_heap(RandomAccessIt first, RandomAccessIt last, Compare comp);
 
  namespace ranges {
    template&lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires Sortable&lt;I, Comp, Proj&gt;
      constexpr I
        pop_heap(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;RandomAccessRange R, class Comp = ranges::less, class Proj = identity&gt;
      requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr safe_iterator_t&lt;R&gt;
        pop_heap(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class RandomAccessIt&gt;
    constexpr void make_heap(RandomAccessIt first, RandomAccessIt last);
  template&lt;class RandomAccessIt, class Compare&gt;
    constexpr void make_heap(RandomAccessIt first, RandomAccessIt last, Compare comp);
 
  namespace ranges {
    template&lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires Sortable&lt;I, Comp, Proj&gt;
      constexpr I
        make_heap(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;RandomAccessRange R, class Comp = ranges::less, class Proj = identity&gt;
      requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr safe_iterator_t&lt;R&gt;
        make_heap(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class RandomAccessIt&gt;
    constexpr void sort_heap(RandomAccessIt first, RandomAccessIt last);
  template&lt;class RandomAccessIt, class Compare&gt;
    constexpr void sort_heap(RandomAccessIt first, RandomAccessIt last, Compare comp);
 
  namespace ranges {
    template&lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires Sortable&lt;I, Comp, Proj&gt;
      constexpr I
        sort_heap(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;RandomAccessRange R, class Comp = ranges::less, class Proj = identity&gt;
      requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr safe_iterator_t&lt;R&gt;
        sort_heap(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class RandomAccessIt&gt;
    constexpr bool is_heap(RandomAccessIt first, RandomAccessIt last);
  template&lt;class RandomAccessIt, class Compare&gt;
    constexpr bool is_heap(RandomAccessIt first, RandomAccessIt last, Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIt&gt;
    bool is_heap(ExecutionPolicy&amp;&amp; exec,
                 RandomAccessIt first, RandomAccessIt last);
  template&lt;class ExecutionPolicy, class RandomAccessIt, class Compare&gt;
    bool is_heap(ExecutionPolicy&amp;&amp; exec,
                 RandomAccessIt first, RandomAccessIt last, Compare comp);
 
  namespace ranges {
    template&lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr bool is_heap(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;RandomAccessRange R, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr bool is_heap(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class RandomAccessIt&gt;
    constexpr RandomAccessIt
      is_heap_until(RandomAccessIt first, RandomAccessIt last);
  template&lt;class RandomAccessIt, class Compare&gt;
    constexpr RandomAccessIt
      is_heap_until(RandomAccessIt first, RandomAccessIt last, Compare comp);
  template&lt;class ExecutionPolicy, class RandomAccessIt&gt;
    RandomAccessIt
      is_heap_until(ExecutionPolicy&amp;&amp; exec,
                    RandomAccessIt first, RandomAccessIt last);
  template&lt;class ExecutionPolicy, class RandomAccessIt, class Compare&gt;
    RandomAccessIt
      is_heap_until(ExecutionPolicy&amp;&amp; exec,
                    RandomAccessIt first, RandomAccessIt last, Compare comp);
 
  namespace ranges {
    template&lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr I is_heap_until(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;RandomAccessRange R, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr safe_iterator_t&lt;R&gt;
        is_heap_until(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  // minimum and maximum:
  template&lt;class T&gt; constexpr const T&amp; min(const T&amp; a, const T&amp; b);
  template&lt;class T, class Compare&gt;
    constexpr const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);
  template&lt;class T&gt;
    constexpr T min(initializer_list&lt;T&gt; t);
  template&lt;class T, class Compare&gt;
    constexpr T min(initializer_list&lt;T&gt; t, Compare comp);
 
  namespace ranges {
    template&lt;class T, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr const T&amp; min(const T&amp; a, const T&amp; b, Comp comp = {}, Proj proj = {});
    template&lt;Copyable T, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr T min(initializer_list&lt;T&gt; r, Comp comp = {}, Proj proj = {});
    template&lt;InputRange R, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;
      requires IndirectlyCopyableStorable&lt;iterator_t&lt;R&gt;, iter_value_t&lt;iterator_t&lt;R&gt;&gt;*&gt;
      constexpr iter_value_t&lt;iterator_t&lt;R&gt;&gt;
        min(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class T&gt; constexpr const T&amp; max(const T&amp; a, const T&amp; b);
  template&lt;class T, class Compare&gt;
    constexpr const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);
  template&lt;class T&gt;
    constexpr T max(initializer_list&lt;T&gt; t);
  template&lt;class T, class Compare&gt;
    constexpr T max(initializer_list&lt;T&gt; t, Compare comp);
 
  namespace ranges {
    template&lt;class T, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr const T&amp; max(const T&amp; a, const T&amp; b, Comp comp = {}, Proj proj = {});
    template&lt;Copyable T, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr T max(initializer_list&lt;T&gt; r, Comp comp = {}, Proj proj = {});
    template&lt;InputRange R, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;
      requires IndirectlyCopyableStorable&lt;iterator_t&lt;R&gt;, iter_value_t&lt;iterator_t&lt;R&gt;&gt;*&gt;
      constexpr iter_value_t&lt;iterator_t&lt;R&gt;&gt;
        max(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class T&gt; constexpr pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b);
  template&lt;class T, class Compare&gt;
    constexpr pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b, Compare comp);
  template&lt;class T&gt;
    constexpr pair&lt;T, T&gt; minmax(initializer_list&lt;T&gt; t);
  template&lt;class T, class Compare&gt;
    constexpr pair&lt;T, T&gt; minmax(initializer_list&lt;T&gt; t, Compare comp);
 
  namespace ranges {
    template&lt;class T&gt;
    struct minmax_result {
      [[no_unique_address]] T min;
      [[no_unique_address]] T max;
 
      template&lt;class T2&gt;
        requires ConvertibleTo&lt;const T&amp;, T2&gt;
        operator minmax_result&lt;T2&gt;() const &amp; {
          return {min, max};
        }
 
      template&lt;class T2&gt;
        requires ConvertibleTo&lt;T, T2&gt;
        operator minmax_result&lt;T2&gt;() &amp;&amp; {
          return {std::move(min), std::move(max)};
        }
    };
 
    template&lt;class T, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr minmax_result&lt;const T&amp;&gt;
        minmax(const T&amp; a, const T&amp; b, Comp comp = {}, Proj proj = {});
    template&lt;Copyable T, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr minmax_result&lt;T&gt;
        minmax(initializer_list&lt;T&gt; r, Comp comp = {}, Proj proj = {});
    template&lt;InputRange R, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;
      requires IndirectlyCopyableStorable&lt;iterator_t&lt;R&gt;, iter_value_t&lt;iterator_t&lt;R&gt;&gt;*&gt;
      constexpr minmax_result&lt;iter_value_t&lt;iterator_t&lt;R&gt;&gt;&gt;
        minmax(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class ForwardIt&gt;
    constexpr ForwardIt min_element(ForwardIt first, ForwardIt last);
  template&lt;class ForwardIt, class Compare&gt;
    constexpr ForwardIt min_element(ForwardIt first, ForwardIt last,
                                          Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIt&gt;
    ForwardIt min_element(ExecutionPolicy&amp;&amp; exec,
                          ForwardIt first, ForwardIt last);
  template&lt;class ExecutionPolicy, class ForwardIt, class Compare&gt;
    ForwardIt min_element(ExecutionPolicy&amp;&amp; exec,
                          ForwardIt first, ForwardIt last, Compare comp);
 
  namespace ranges {
    template&lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr I min_element(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;ForwardRange R, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr safe_iterator_t&lt;R&gt;
        min_element(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class ForwardIt&gt;
    constexpr ForwardIt max_element(ForwardIt first, ForwardIt last);
  template&lt;class ForwardIt, class Compare&gt;
    constexpr ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIt&gt;
    ForwardIt max_element(ExecutionPolicy&amp;&amp; exec,
                          ForwardIt first, ForwardIt last);
  template&lt;class ExecutionPolicy, class ForwardIt, class Compare&gt;
    ForwardIt max_element(ExecutionPolicy&amp;&amp; exec,
                          ForwardIt first, ForwardIt last, Compare comp);
 
 namespace ranges {
    template&lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr I max_element(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;ForwardRange R, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr safe_iterator_t&lt;R&gt;
        max_element(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class ForwardIt&gt;
    constexpr pair&lt;ForwardIt, ForwardIt&gt;
      minmax_element(ForwardIt first, ForwardIt last);
  template&lt;class ForwardIt, class Compare&gt;
    constexpr pair&lt;ForwardIt, ForwardIt&gt;
      minmax_element(ForwardIt first, ForwardIt last, Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIt&gt;
    pair&lt;ForwardIt, ForwardIt&gt;
      minmax_element(ExecutionPolicy&amp;&amp; exec,
                     ForwardIt first, ForwardIt last);
  template&lt;class ExecutionPolicy, class ForwardIt, class Compare&gt;
    pair&lt;ForwardIt, ForwardIt&gt;
      minmax_element(ExecutionPolicy&amp;&amp; exec,
                     ForwardIt first, ForwardIt last, Compare comp);
 
  namespace ranges {
    template&lt;class I&gt;
    using minmax_element_result = minmax_result&lt;I&gt;;
 
    template&lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr minmax_element_result&lt;I&gt;
        minmax_element(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;ForwardRange R, class Proj = identity,
             IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;
      constexpr minmax_element_result&lt;safe_iterator_t&lt;R&gt;&gt;
        minmax_element(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  // bounded value:
  template&lt;class T&gt;
    constexpr const T&amp; clamp(const T&amp; v, const T&amp; lo, const T&amp; hi);
  template&lt;class T, class Compare&gt;
    constexpr const T&amp; clamp(const T&amp; v, const T&amp; lo, const T&amp; hi, Compare comp);
 
  // lexicographical comparison:
  template&lt;class InputIt1, class InputIt2&gt;
    constexpr bool
      lexicographical_compare(InputIt1 first1, InputIt1 last1,
                              InputIt2 first2, InputIt2 last2);
  template&lt;class InputIt1, class InputIt2, class Compare&gt;
    constexpr bool
      lexicographical_compare(InputIt1 first1, InputIt1 last1,
                              InputIt2 first2, InputIt2 last2,
                              Compare comp);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2&gt;
    bool
      lexicographical_compare(ExecutionPolicy&amp;&amp; exec,
                              ForwardIt1 first1, ForwardIt1 last1,
                              ForwardIt2 first2, ForwardIt2 last2);
  template&lt;class ExecutionPolicy, class ForwardIt1, class ForwardIt2,
           class Compare&gt;
    bool
      lexicographical_compare(ExecutionPolicy&amp;&amp; exec,
                              ForwardIt1 first1, ForwardIt1 last1,
                              ForwardIt2 first2, ForwardIt2 last2,
                              Compare comp);
 
  namespace ranges {
    template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
             class Proj1 = identity, class Proj2 = identity,
             IndirectStrictWeakOrder&lt;projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt; Comp =
               ranges::less&gt;
      constexpr bool
        lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2,
                                Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
    template&lt;InputRange R1, InputRange R2, class Proj1 = identity,
             class Proj2 = identity,
             IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;R1&gt;, Proj1&gt;,
                                     projected&lt;iterator_t&lt;R2&gt;, Proj2&gt;&gt; Comp = ranges::less&gt;
      constexpr bool
        lexicographical_compare(R1&amp;&amp; r1, R2&amp;&amp; r2, Comp comp = {},
                                Proj1 proj1 = {}, Proj2 proj2 = {});
  }
 
  // three-way comparison algorithms:
  template&lt;class T, class U&gt;
    constexpr auto compare_3way(const T&amp; a, const U&amp; b);
  template&lt;class InputIt1, class InputIt2, class Cmp&gt;
    constexpr auto
      lexicographical_compare_3way(InputIt1 b1, InputIt1 e1, InputIt2 b2, InputIt2 e2,
                                   Cmp comp)
        -&gt; common_comparison_category_t&lt;decltype(comp(*b1, *b2)), strong_ordering&gt;;
  template&lt;class InputIt1, class InputIt2&gt;
    constexpr auto
      lexicographical_compare_3way(InputIt1 b1, InputIt1 e1, InputIt2 b2, InputIt2 e2);
 
  // permutations:
  template&lt;class BidirectionalIt&gt;
    constexpr bool next_permutation(BidirectionalIt first, BidirectionalIt last);
  template&lt;class BidirectionalIt, class Compare&gt;
    constexpr bool next_permutation(BidirectionalIt first, BidirectionalIt last,
                                    Compare comp);
 
  namespace ranges {
    template&lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires Sortable&lt;I, Comp, Proj&gt;
      constexpr bool
        next_permutation(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;BidirectionalRange R, class Comp = ranges::less,
             class Proj = identity&gt;
      requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr bool
        next_permutation(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
 
  template&lt;class BidirectionalIt&gt;
    constexpr bool prev_permutation(BidirectionalIt first, BidirectionalIt last);
  template&lt;class BidirectionalIt, class Compare&gt;
    constexpr bool prev_permutation(BidirectionalIt first, BidirectionalIt last,
                                    Compare comp);
 
  namespace ranges {
    template&lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Comp = ranges::less,
             class Proj = identity&gt;
      requires Sortable&lt;I, Comp, Proj&gt;
      constexpr bool
        prev_permutation(I first, S last, Comp comp = {}, Proj proj = {});
    template&lt;BidirectionalRange R, class Comp = ranges::less,
             class Proj = identity&gt;
      requires Sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;
      constexpr bool
        prev_permutation(R&amp;&amp; r, Comp comp = {}, Proj proj = {});
  }
}</pre></div>          <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/header/algorithm" class="_attribution-link">http://en.cppreference.com/w/cpp/header/algorithm</a>
  </p>
</div>
