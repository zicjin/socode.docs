   <h1 id="firstHeading" class="firstHeading">C++ named requirements: NumericType</h1>            <p>Specifies that the type can be used as the template argument of <code><a href="../numeric/valarray" title="cpp/numeric/valarray">std::valarray</a></code>.</p>
<h3 id="Requirements"> Requirements </h3> <p>for a type <code>T</code> to be an NumericType:</p>
<ul>
<li> <code>T</code> cannot be a reference </li>
<li> <code>T</code> cannot be cv-qualified </li>
<li> If <code>T</code> is a class, it </li>
<ul>
<li> does not overload <code>operator&amp;</code> </li>
<li> has no pure virtual member functions (is not <a href="../language/abstract_class" title="cpp/language/abstract class">abstract</a>) </li>
<li> has a public <a href="../language/default_constructor" title="cpp/language/default constructor">default constructor</a> </li>
<li> has a public <a href="../language/copy_constructor" title="cpp/language/copy constructor">copy constructor</a> <code>T::T(const T&amp;)</code> </li>
<li> has a public <a href="../language/destructor" title="cpp/language/destructor">destructor</a> </li>
<li> has a public assignment operator <code>T&amp; T::operator=(const T&amp;)</code> or <code>T&amp; T::operator=(T)</code> </li>
<li> default constructor followed by assignment has the same effect as copy constructor </li>
<li> copy constructor with the value <code>T()</code> has the same effect as value-initialization </li>
<li> destructor followed by copy constructor has the same effect as assignment </li>
</ul>
<li> No operation on <code>T</code> may throw exceptions </li>
</ul>            <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/named_req/NumericType" class="_attribution-link">http://en.cppreference.com/w/cpp/named_req/NumericType</a>
  </p>
</div>
