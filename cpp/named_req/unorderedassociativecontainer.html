   <h1 id="firstHeading" class="firstHeading">C++ named requirements: UnorderedAssociativeContainer</h1>            <p>Unordered associative containers are <a href="container" title="cpp/named req/Container">Containers</a> that provide fast lookup of objects based on keys. Worst case complexity is linear but on average much faster for most of the operations.</p>
<p>Unordered associative containers are parametrized by <code>Key</code>; <code>Hash</code>, a <a href="hash" title="cpp/named req/Hash">Hash</a> function object which acts as hash function on <code>Key</code>; and <code>Pred</code>, a <a href="binarypredicate" title="cpp/named req/BinaryPredicate">BinaryPredicate</a> evaluating equivalence between <code>Key</code>s. <code><a href="../container/unordered_map"><span class="kw1290">std::<span class="me2">unordered_map</span></span></a></code> and <code><a href="../container/unordered_multimap"><span class="kw1292">std::<span class="me2">unordered_multimap</span></span></a></code> also have a mapped type <code>T</code> associated with the <code>Key</code>.</p>
<p>If two <code>Key</code>s are equal according to <code>Pred</code>, <code>Hash</code> must return the same value for both keys.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>If <code>Hash::transparent_key_equal</code> exists and names a type, then <code>Hash::transparent_key_equal::is_transparent</code> must be valid and name a type, and <code>Pred</code> must be either <code>Hash::transparent_key_equal</code>, or <code><a href="../utility/functional/equal_to"><span class="kw1034">std::<span class="me2">equal_to</span></span></a><span class="sy1">&lt;</span>Key<span class="sy1">&gt;</span></code> (the program is ill-formed otherwise).</p>
<p>When this is the case, member functions <code>find</code>, <code>contains</code>, <code>count</code>, and <code>equal_range</code> accept arguments of types other than <code>Key</code> and expect that <code>Hash</code> is callable with values of those types, and that <code>Hash::transparent_key_equal</code> is a transparent comparison function such as <code>std::equal_to&lt;&gt;</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p><code><a href="../container/unordered_map"><span class="kw1290">std::<span class="me2">unordered_map</span></span></a></code> and <code><a href="../container/unordered_set"><span class="kw1286">std::<span class="me2">unordered_set</span></span></a></code> can contain at most one element with a given key, <code><a href="../container/unordered_multiset"><span class="kw1288">std::<span class="me2">unordered_multiset</span></span></a></code> and <code><a href="../container/unordered_multimap"><span class="kw1292">std::<span class="me2">unordered_multimap</span></span></a></code> instead can have multiple elements with the same key (which must always be adjacent on iterations).</p>
<p>For <code><a href="../container/unordered_set"><span class="kw1286">std::<span class="me2">unordered_set</span></span></a></code> and <code><a href="../container/unordered_multiset"><span class="kw1288">std::<span class="me2">unordered_multiset</span></span></a></code> the value type is the same as the key type and both <code>iterator</code> and <code>const_iterator</code> are constant iterators. For <code><a href="../container/unordered_map"><span class="kw1290">std::<span class="me2">unordered_map</span></span></a></code> and <code><a href="../container/unordered_multimap"><span class="kw1292">std::<span class="me2">unordered_multimap</span></span></a></code> the value type is <code><a href="../utility/pair"><span class="kw1093">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">const</span> Key, T<span class="sy1">&gt;</span></code>.</p>
<p>Elements in an unordered associative container are organized into buckets, keys with the same hash will end up in the same bucket. The number of buckets is increased when the size of the container increases to keep the average number of elements in each bucket under a certain value.</p>
<p>Rehashing invalidates iterator and might cause the elements to be re-arranged in different buckets but it doesn't invalidate references to the elements.</p>
<p>Unordered associative containers meet the requirements of <a href="allocatorawarecontainer" title="cpp/named req/AllocatorAwareContainer">AllocatorAwareContainer</a>. For <code><a href="../container/unordered_map"><span class="kw1290">std::<span class="me2">unordered_map</span></span></a></code> and <code><a href="../container/unordered_multimap"><span class="kw1292">std::<span class="me2">unordered_multimap</span></span></a></code> the requirements of <code>value_type</code> in <a href="allocatorawarecontainer" title="cpp/named req/AllocatorAwareContainer">AllocatorAwareContainer</a> apply to <code>key_type</code> and <code>mapped_type</code> (not to <code>value_type</code>).</p>
<h3 id="Requirements">Requirements</h3> <table class="t-dsc-begin"> <tr> <td colspan="2"> <h3 id="Legend"> Legend</h3> </td>
</tr> <tr class="t-dsc"> <td> <code>X</code> </td> <td> Container type </td>
</tr> <tr class="t-dsc"> <td> <code>a</code> </td> <td> Object of type <code>X</code> </td>
</tr> <tr class="t-dsc"> <td> <code>b</code> </td> <td> <code>const</code> Object of type <code>X</code> </td>
</tr> <tr class="t-dsc"> <td> <code>a_uniq</code> </td> <td> Object in <code>X</code> when <code>X</code> supports unique keys </td>
</tr> <tr class="t-dsc"> <td> <code>a_eq</code> </td> <td> Object in <code>X</code> when <code>X</code> supports multiple equivalent keys </td>
</tr> <tr class="t-dsc"> <td> <code>i</code>, <code>j</code> </td> <td> <a href="inputiterator" title="cpp/named req/InputIterator">LegacyInputIterators</a> denoting a valid range </td>
</tr> <tr class="t-dsc"> <td> <code>p</code>, <code>q2</code> </td> <td> valid const_iterator to <code>a</code> </td>
</tr> <tr class="t-dsc"> <td> <code>q</code>, <code>q1</code> </td> <td> dereferenceable const_iterator to <code>a</code> denoting a valid range </td>
</tr> <tr class="t-dsc"> <td> <code>il</code> </td> <td> Object of <code><a href="../utility/initializer_list"><span class="kw955">std::<span class="me2">initializer_list</span></span></a><span class="sy1">&lt;</span>X<span class="sy4">::</span><span class="me2">value_type</span><span class="sy1">&gt;</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>t</code> </td> <td> Object of type <code>X::value_type</code> </td>
</tr> <tr class="t-dsc"> <td> <code>k</code> </td> <td> Object of type <code>X::key_type</code> </td>
</tr> <tr class="t-dsc"> <td> <code>hf</code> </td> <td> <code>const</code> Object of type <code>X::hasher</code> </td>
</tr> <tr class="t-dsc"> <td> <code>eq</code> </td> <td> <code>const</code> Object of type <code>X::key_equal</code> </td>
</tr> <tr class="t-dsc"> <td> <code>n</code> </td> <td> Value of type <code>X::size_type</code> </td>
</tr> <tr class="t-dsc"> <td> <code>z</code> </td> <td> Value of type <code>float</code> </td>
</tr> </table> <table class="wikitable"> <tr> <th>expression</th> <th>return type</th> <th>pre/requirements</th> <th>post/effects</th> <th>complexity </th>
</tr> <tr> <td><code>X::key_type</code></td> <td><code>Key</code></td> <td> </td> <td> </td> <td>compile time </td>
</tr> <tr> <td><code>X::mapped_type</code></td> <td><code>T</code></td> <td>
<code><a href="../container/unordered_map"><span class="kw1290">std::<span class="me2">unordered_map</span></span></a></code> and <code><a href="../container/unordered_multimap"><span class="kw1292">std::<span class="me2">unordered_multimap</span></span></a></code> only </td> <td> </td> <td>compile time </td>
</tr> <tr> <td><code>X::value_type</code></td> <td><code>Key</code></td> <td>
<code><a href="../container/unordered_set"><span class="kw1286">std::<span class="me2">unordered_set</span></span></a></code> and <code><a href="../container/unordered_multiset"><span class="kw1288">std::<span class="me2">unordered_multiset</span></span></a></code> only. <a href="eraseable" title="cpp/named req/Erasable">Erasable</a> in <code>X</code> </td> <td> </td> <td>compile time </td>
</tr> <tr> <td><code>X::value_type</code></td> <td><code><a href="../utility/pair"><span class="kw1093">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">const</span> Key, T<span class="sy1">&gt;</span></code></td> <td>
<code><a href="../container/unordered_map"><span class="kw1290">std::<span class="me2">unordered_map</span></span></a></code> and <code><a href="../container/unordered_multimap"><span class="kw1292">std::<span class="me2">unordered_multimap</span></span></a></code> only. <a href="eraseable" title="cpp/named req/Erasable">Erasable</a> in <code>X</code> </td> <td> </td> <td>compile time </td>
</tr> <tr> <td><code>X::hasher</code></td> <td><code>Hash</code></td> <td><a href="hash" title="cpp/named req/Hash">Hash</a></td> <td> </td> <td>compile time </td>
</tr> <tr> <td>
<code>X::key_equal</code> </td> <td> <table class="t-rev-begin">
<tr class="t-rev t-until-cxx20">
<td><code>Pred</code></td> <td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td>
</tr>
<tr class="t-rev t-since-cxx20">
<td>
<code>Hash::transparent_key_equal</code> if it's valid and names a type, <code>Pred</code> otherwise</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr>
</table> </td> <td>
<a href="binarypredicate" title="cpp/named req/BinaryPredicate">BinaryPredicate</a> taking two arguments of type <code>Key</code> and expressing an equivalence relation. </td> <td> </td> <td>compile time </td>
</tr> <tr> <td><code>X::local_iterator</code></td> <td>An <a href="iterator" title="cpp/named req/Iterator">LegacyIterator</a> whose category and types are the same as <code>X::iterator</code> </td> <td> </td> <td> Can be used to iterate through a single bucket </td> <td>compile time </td>
</tr> <tr> <td><code>X::const_local_iterator</code></td> <td>An <a href="iterator" title="cpp/named req/Iterator">LegacyIterator</a> whose category and types are the same as <code>X::const_iterator</code> </td> <td> </td> <td> Can be used to iterate through a single bucket </td> <td>compile time </td>
</tr> <tr> <td><code>X(n,hf,eq)</code></td> <td><code>X</code></td> <td>
<code>hasher</code> and <code>key_equal</code> <a href="copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a> </td> <td>Constructs an empty container with at least <code>n</code> buckets, using the given hash function and equality predicate</td> <td>linear in <code>n</code> </td>
</tr> <tr> <td><code>X(n,hf)</code></td> <td><code>X</code></td> <td>
<code>hasher</code> <a href="copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>, <code>key_equal</code> <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a> </td> <td>Constructs an empty container with at least <code>n</code> buckets, using the given hash function and <code>key_equal()</code> as equality predicate</td> <td>linear in <code>n</code> </td>
</tr> <tr> <td><code>X(n)</code></td> <td><code>X</code></td> <td>
<code>hasher</code> and <code>key_equal</code> <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a> </td> <td>Constructs an empty container with at least <code>n</code> buckets, using <code>hasher()</code> as hash function and <code>key_equal()</code> as equality predicate</td> <td>linear in <code>n</code> </td>
</tr> <tr> <td><code>X()</code></td> <td><code>X</code></td> <td>
<code>hasher</code> and <code>key_equal</code> <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a> </td> <td>Constructs an empty container with an unspecified number of buckets, using <code>hasher()</code> as hash function and <code>key_equal()</code> as equality predicate</td> <td>constant </td>
</tr> <tr> <td><code>X(i,j,n,hf,eq)</code></td> <td><code>X</code></td> <td>
<code>hasher</code> and <code>key_equal</code> <a href="copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>, <code>value_type</code> <a href="emplaceconstructible" title="cpp/named req/EmplaceConstructible">EmplaceConstructible</a> into <code>X</code> from <code>*i</code> </td> <td>Constructs an empty container with at least <code>n</code> buckets, using the given hash function and equality predicate, and inserts elements from [i,j) into it.</td> <td>average linear, worst quadratin (on the distance between <code>i</code> and <code>j</code>) </td>
</tr> <tr> <td><code>X(i,j,n,hf)</code></td> <td><code>X</code></td> <td>
<code>key_equal</code> <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>
</td> <td>As above, with <code>eq=key_equal()</code>
</td> <td>see above </td>
</tr> <tr> <td><code>X(i,j,n)</code></td> <td><code>X</code></td> <td>
<code>hasher</code> <a href="defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>
</td> <td>As above, with <code>hf=hasher()</code>
</td> <td>see above </td>
</tr> <tr> <td><code>X(i,j)</code></td> <td><code>X</code></td> <td> </td> <td>As above, with an unspecified number of buckets</td> <td>see above </td>
</tr> <tr> <td><code>X(il)</code></td> <td><code>X</code></td> <td> </td> <td><code>X(il.begin(),il.end()</code></td> <td>see above </td>
</tr> <tr> <td><code>X(il,n)</code></td> <td><code>X</code></td> <td> </td> <td><code>X(il.begin(),il.end(),n</code></td> <td>see above </td>
</tr> <tr> <td><code>X(il,n,hf)</code></td> <td><code>X</code></td> <td> </td> <td><code>X(il.begin(),il.end(),n,hf</code></td> <td>see above </td>
</tr> <tr> <td><code>X(il,n,hf,eq)</code></td> <td><code>X</code></td> <td> </td> <td><code>X(il.begin(),il.end(),n,hf,eq</code></td> <td>see above </td>
</tr> <tr> <td><code>X(b)</code></td> <td><code>X</code></td> <td> </td> <td>Copy constructors, also copies the hash function, predicate and maximum load factor</td> <td>average linear, worst quadratic (in <code>b.size()</code>) </td>
</tr> <tr> <td><code>a = b</code></td> <td><code>X&amp;</code></td> <td> </td> <td>Copy assignment, also copies the hash function, predicate and maximum load factor</td> <td>average linear, worst quadratic (in <code>b.size()</code>) </td>
</tr> <tr> <td><code>a = il</code></td> <td><code>X&amp;</code></td> <td>
<code>value_type</code> <a href="copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a> and <a href="copyinsertable" title="cpp/named req/CopyInsertable">CopyInsertable</a> into <code>X</code>
</td> <td> <code>a = X(il)</code>
</td> <td>see above </td>
</tr> </table>  <h3 id="Unordered_associative_containers_in_the_standard_library">Unordered associative containers in the standard library</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../container/unordered_set" title="cpp/container/unordered set"> <span class="t-lines"><span>unordered_set</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> collection of unique keys, hashed by keys <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_multiset" title="cpp/container/unordered multiset"> <span class="t-lines"><span>unordered_multiset</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> collection of keys, hashed by keys <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_map" title="cpp/container/unordered map"> <span class="t-lines"><span>unordered_map</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> collection of key-value pairs, hashed by keys, keys are unique <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/unordered_multimap" title="cpp/container/unordered multimap"> <span class="t-lines"><span>unordered_multimap</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> collection of key-value pairs, hashed by keys <br> <span class="t-mark">(class template)</span> </td>
</tr> </table>          <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/named_req/UnorderedAssociativeContainer" class="_attribution-link">http://en.cppreference.com/w/cpp/named_req/UnorderedAssociativeContainer</a>
  </p>
</div>
