    <h1 id="firstHeading" class="firstHeading">std::formatter</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../../header/format" title="cpp/header/format">&lt;format&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt;class T, class CharT = char&gt;
struct formatter;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>  </table> <p>The enabled specializations of <code>formatter</code> define formatting rules for a given type. Enabled specializations meet the <a href="../../named_req/formatter" title="cpp/named req/Formatter">Formatter</a> requirements. In particular, they define callables <code>parse</code> and <code>format</code>.</p>
<p>For all types <code>T</code> and <code>CharT</code> for which no specialization <code>std::formatter&lt;T, CharT&gt;</code> is enabled, that specialization is a complete type and is disabled.</p>
<p>Disabled specializations do not meet the <a href="../../named_req/formatter" title="cpp/named req/Formatter">Formatter</a> requirements, and the following are all <code>false</code>:</p>
<ul>
<li> <code><a href="../../types/is_default_constructible" title="cpp/types/is default constructible">std::is_default_constructible_v</a></code> </li>
<li> <code><a href="../../types/is_copy_constructible" title="cpp/types/is copy constructible">std::is_copy_constructible_v</a></code> </li>
<li> <code><a href="../../types/is_move_constructible" title="cpp/types/is move constructible">std::is_move_constructible_v</a></code> </li>
<li> <code><a href="../../types/is_copy_assignable" title="cpp/types/is copy assignable">std::is_copy_assignable_v</a></code> </li>
<li> <code><a href="../../types/is_move_assignable" title="cpp/types/is move assignable">std::is_move_assignable_v</a></code>. </li>
</ul>  <h3 id="Standard_specializations_for_basic_types_and_string_types"> Standard specializations for basic types and string types</h3> <p>In the following list, <code>CharT</code> is either <code>char</code> or <code>wchar_t</code>, <code>ArithmeticT</code> is any cv-unqualified arithmetic type other than <code>char</code>, <code>wchar_t</code>, <code>char8_t</code>, <code>char16_t</code>, or <code>char32_t</code>.</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">template&lt;&gt; struct formatter&lt;char, char&gt;;
template&lt;&gt; struct formatter&lt;char, wchar_t&gt;;
template&lt;&gt; struct formatter&lt;wchar_t, wchar_t&gt;;

template&lt;&gt; struct formatter&lt;CharT*, CharT&gt;;
template&lt;&gt; struct formatter&lt;const CharT*, CharT&gt;;
template&lt;std::size_t N&gt; struct formatter&lt;const CharT[N], CharT&gt;;
template&lt;class Traits, class Alloc&gt;
  struct formatter&lt;std::basic_string&lt;CharT, Traits, Alloc&gt;, CharT&gt;;
template&lt;class Traits&gt;
  struct formatter&lt;std::basic_string_view&lt;CharT, Traits&gt;, CharT&gt;;

template&lt;&gt; struct formatter&lt;ArithmeticT, CharT&gt;;

template&lt;&gt; struct formatter&lt;std::nullptr_t, CharT&gt;;
template&lt;&gt; struct formatter&lt;void*, CharT&gt;;
template&lt;&gt; struct formatter&lt;const void*, CharT&gt;;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>Formatters for other pointers and pointers to members are disabled.</p>
<p>Specializations such as <code>std::formatter&lt;wchar_t, char&gt;</code> and <code>std::formatter&lt;const char*, wchar_t&gt;</code> that would require encoding conversions are disabled.</p>
<h4 id="Standard_format_specification"> Standard format specification</h4> <p>For basic types and string types, the format specification is based on the <a rel="nofollow" class="external text" href="https://docs.python.org/3/library/string.html#formatspec">format specification in Python</a>.</p>
<p>The syntax of format specifications is:</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <span class="t-spar">fill-and-align</span><span class="t-mark">(optional)</span> <span class="t-spar">sign</span><span class="t-mark">(optional)</span> <code>#</code><span class="t-mark">(optional)</span> <code>0</code><span class="t-mark">(optional)</span> <span class="t-spar">width</span><span class="t-mark">(optional)</span> <span class="t-spar">precision</span><span class="t-mark">(optional)</span> <code>L</code><span class="t-mark">(optional)</span> <span class="t-spar">type</span><span class="t-mark">(optional)</span> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>The <span class="t-spar">sign</span>, <code>#</code> and <code>0</code> options are only valid when an integer or floating-point presentation type is used.</p>
<h5 id="fill_and_align"> fill and align</h5> <p><span class="t-spar">fill-and-align</span> is an optional <i>fill</i> character (which can be any character other than <code>{</code> or <code>}</code>), followed by one of the <i>align</i> options <code>&lt;</code>, <code>&gt;</code>, <code>^</code>. The meaning of <i>align</i> options is as follows:</p>
<ul>
<li> <code>&lt;</code>: Forces the field to be aligned to the start of the available space. This is the default when a non-integer non-floating-point presentation type is used. </li>
<li> <code>&gt;</code>: Forces the field to be aligned to the end of the available space. This is the default when an integer or floating-point presentation type is used. </li>
<li> <code>^</code>: Forces the field to be centered within the available space by inserting ⌊<span><span>n</span><span>/</span><span>2</span></span>⌋ characters before and ⌈<span><span>n</span><span>/</span><span>2</span></span>⌉ characters after the value, where n is the total number of fill characters to insert. </li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">char c = 120;
auto s0 = std::format("{:6}", 42);    // value of s0 is "    42"
auto s1 = std::format("{:6}", 'x');   // value of s1 is "x     "
auto s2 = std::format("{:*&lt;6}", 'x'); // value of s2 is "x*****"
auto s3 = std::format("{:*&gt;6}", 'x'); // value of s3 is "*****x"
auto s4 = std::format("{:*^6}", 'x'); // value of s4 is "**x***"
auto s5 = std::format("{:6d}", c);    // value of s5 is "   120"
auto s6 = std::format("{:6}", true);  // value of s6 is "true  "</pre></div> <h5 id="sign.2C_.23.2C_and_0"> sign, #, and 0</h5> <p>The <span class="t-spar">sign</span> option can be one of following:</p>
<ul>
<li> <code>+</code>: Indicates that a sign should be used for both non-negative and negative numbers. The <code>+</code> sign is inserted before the output value for non-negative numbers. </li>
<li> <code>-</code>: Indicates that a sign should be used for negative numbers only (this is the default behavior). </li>
<li> space: Indicates that a leading space should be used for non-negative numbers, and a minus sign for negative numbers. </li>
</ul> <p>Negative zero is treated as a negative number.</p>
<p>The <span class="t-spar">sign</span> option applies to floating-point infinity and NaN.</p>
<div class="cpp source-cpp"><pre data-language="cpp">double inf = std::numeric_limits&lt;double&gt;::infinity();
double nan = std::numeric_limits&lt;double&gt;::quiet_NaN();
auto s0 = std::format("{0:},{0:+},{0:-},{0: }", 1);   // value of s0 is "1,+1,1, 1"
auto s1 = std::format("{0:},{0:+},{0:-},{0: }", -1);  // value of s1 is "-1,-1,-1,-1"
auto s2 = std::format("{0:},{0:+},{0:-},{0: }", inf); // value of s2 is "inf,+inf,inf, inf"
auto s3 = std::format("{0:},{0:+},{0:-},{0: }", nan); // value of s3 is "nan,+nan,nan, nan"</pre></div> <p>The <code>#</code> option causes the <i>alternate form</i> to be used for the conversion.</p>
<ul>
<li> For integral types, when binary, octal, or hexadecimal presentation type is used, the alternate form inserts the prefix (<code>0b</code>, <code>0</code>, or <code>0x</code>) into the output value after the sign character (possibly space) if there is one, or add it before the output value otherwise. </li>
<li> For floating-point types, the alternate form causes the result of the conversion of finite values to always contain a decimal-point character, even if no digits follow it. Normally, a decimal-point character appears in the result of these conversions only if a digit follows it. In addition, for <code>g</code> and <code>G</code> conversions, trailing zeros are not removed from the result. </li>
</ul> <p>The <code>0</code> option pads the field with leading zeros (following any indication of sign or base) to the field width, except when applied to an infinity or NaN. If the <code>0</code> character and an <i>align</i> option both appear, the <code>0</code> character is ignored.</p>
<div class="cpp source-cpp"><pre data-language="cpp">char c = 120;
auto s1 = std::format("{:+06d}", c);   // value of s1 is "+00120"
auto s2 = std::format("{:#06x}", 0xa); // value of s2 is "0x000a"
auto s3 = std::format("{:&lt;06}", -42);  // value of s3 is "-42   "
                                       // (0 is ignored because of &lt; alignment)</pre></div> <h5 id="width_and_precision"> width and precision</h5> <p><span class="t-spar">width</span> is either a positive decimal number, or a nested replacement field (<code>{} </code> or <code>{</code><i>n</i><code>}</code>). If present, it specifies the minimum field width.</p>
<p><span class="t-spar">precision</span> is a dot (<code>.</code>) followed by either a non-negative decimal number or a nested replacement field. This field indicates the precision or maximum field size. It can only be used with floating-point and string types. For floating-point types, this field specifies the formatting precision. For string types, it provides an upper bound for the estimated width (see below) of the prefix of the string to be copied to the output. For a string in a Unicode encoding, the text to be copied to the output is the longest prefix of whole extended grapheme clusters whose estimated width is no greater than the precision.</p>
<p>If a nested replacement field is used for <span class="t-spar">width</span> or <span class="t-spar">precision</span>, and the corresponding argument is not of integral type, or is negative, or is zero for <span class="t-spar">width</span>, an exception of type <code><a href="format_error" title="cpp/utility/format/format error">std::format_error</a></code> is thrown.</p>
<div class="cpp source-cpp"><pre data-language="cpp">float pi = 3.14f;
auto s1 = std::format("{:10f}", pi);           // s1 = "  3.140000" (width = 10)
auto s2 = std::format("{:{}f}", pi, 10);       // s2 = "  3.140000" (width = 10)
auto s3 = std::format("{:.5f}", pi);           // s3 = "3.14000" (precision = 5)
auto s4 = std::format("{:.{}f}", pi, 5);       // s4 = "3.14000" (precision = 5)
auto s5 = std::format("{:10.5f}", pi);         // s5 = "   3.14000"
                                               // (width = 10, precision = 5)
auto s6 = std::format("{:{}.{}f}", pi, 10, 5); // s6 = "   3.14000"
                                               // (width = 10, precision = 5)
 
auto b1 = std::format("{:{}f}", pi, 10.0);     // throws: width is not of integral type 
auto b2 = std::format("{:{}f}", pi, -10);      // throws: width is negative
auto b3 = std::format("{:.{}f}", pi, 5.0);     // throws: precision is not of integral type</pre></div> <p>For string types, the width is defined as the estimated number of column positions appropriate for displaying it in a terminal.</p>
<p>For the purpose of width computation, a string is assumed to be in a implementation-defined encoding. The method of width computation is unspecified, but for a string in a Unicode encoding, implementation should estimate the width of the string as the sum of estimated widths of the first code points in its extended grapheme clusters. The estimated width of a Unicode code point is 2 if the code point is within the following range, or 1 if it isn't:</p>
<ul>
<li> U+1100 - U+115F </li>
<li> U+2329 - U+232A </li>
<li> U+2E80 - U+303E </li>
<li> U+3040 - U+A4CF </li>
<li> U+AC00 - U+D7A3 </li>
<li> U+F900 - U+FAFF </li>
<li> U+FE10 - U+FE19 </li>
<li> U+FE30 - U+FE6F </li>
<li> U+FF00 - U+FF60 </li>
<li> U+FFE0 - U+FFE6 </li>
<li> U+1F300 - U+1F64F </li>
<li> U+1F900 - U+1F9FF </li>
<li> U+20000 - U+2FFFD </li>
<li> U+30000 - U+3FFFD </li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">auto s1 = std::format("{:.^5s}",   "🐱");      // s1 = ".🐱.."
auto s2 = std::format("{:.5s}",    "🐱🐱🐱");  // s2 = "🐱🐱"
auto s3 = std::format("{:.&lt;5.5s}", "🐱🐱🐱");  // s3 = "🐱🐱."</pre></div> <h5 id="L_.28locale-specific_formatting.29"> L (locale-specific formatting)</h5> <p>The <code>L</code> option causes the locale-specific form to be used. This option is only valid for arithmetic types.</p>
<ul>
<li> For integral types, the locale-specific form inserts the appropriate digit group separator characters according to the context's locale. </li>
<li> For floating-point types, the locale-specific form inserts the appropriate digit group and radix separator characters according to the context's locale. </li>
<li> For the textual representation of <code>bool</code>, the locale-specific form uses the appropriate string as if obtained with <code><a href="../../locale/numpunct/truefalsename" title="cpp/locale/numpunct/truefalsename">std::numpunct::truename</a></code> or <code><a href="../../locale/numpunct/truefalsename" title="cpp/locale/numpunct/truefalsename">std::numpunct::falsename</a></code>. </li>
</ul> <h5 id="type"> type</h5> <p>The <span class="t-spar">type</span> option determines how the data should be presented.</p>
<p>The available string presentation types are:</p>
<ul><li> none, <code>s</code>: Copies the string to the output. </li></ul> <p>The available integer presentation types for integral types other than <code>char</code>, <code>wchar_t</code>, and <code>bool</code> are:</p>
<ul>
<li> <code>b</code>: Binary format. Produces the output as if by calling <code><a href="http://en.cppreference.com/w/cpp/utility/to_chars"><span class="kw2640">std::<span class="me2">to_chars</span></span></a><span class="br0">(</span>first, last, value, <span class="nu0">2</span><span class="br0">)</span></code>. The base prefix is <code>0b</code>. </li>
<li> <code>B</code>: same as <code>b</code>, except that the base prefix is <code>0B</code>. </li>
<li> <code>c</code>: Copies the character <code>static_cast&lt;CharT&gt;(value)</code> to the output, where <code>CharT</code> is the character type of the format string. Throws <code><a href="format_error" title="cpp/utility/format/format error">std::format_error</a></code> if value is not in the range of representable values for <code>CharT</code>. </li>
<li> <code>d</code>: Decimal format. Produces the output as if by calling <code><a href="http://en.cppreference.com/w/cpp/utility/to_chars"><span class="kw2640">std::<span class="me2">to_chars</span></span></a><span class="br0">(</span>first, last, value<span class="br0">)</span></code>. </li>
<li> <code>o</code>: Octal format. Produces the output as if by calling <code><a href="http://en.cppreference.com/w/cpp/utility/to_chars"><span class="kw2640">std::<span class="me2">to_chars</span></span></a><span class="br0">(</span>first, last, value, <span class="nu0">8</span><span class="br0">)</span></code>. The base prefix is <code>0</code> if the corresponding argument value is nonzero and is empty otherwise. </li>
<li> <code>x</code>: Hex format. Produces the output as if by calling <code><a href="http://en.cppreference.com/w/cpp/utility/to_chars"><span class="kw2640">std::<span class="me2">to_chars</span></span></a><span class="br0">(</span>first, last, value, <span class="nu0">16</span><span class="br0">)</span></code>. The base prefix is <code>0x</code>. </li>
<li> <code>X</code>: same as <code>x</code>, except that it uses uppercase letters for digits above 9 and the base prefix is <code>0X</code>. </li>
<li> none: same as <code>d</code>. </li>
</ul> <p>The available <code>char</code> and <code>wchar_t</code> presentation types are:</p>
<ul>
<li> none, <code>c</code>: Copies the character to the output. </li>
<li> <code>b</code>, <code>B</code>, <code>d</code>, <code>o</code>, <code>x</code>, <code>X</code>: Uses integer presentation types. </li>
</ul> <p>The available <code>bool</code> presentation types are:</p>
<ul>
<li> none, <code>s</code>: Copies textual representation (<code>true</code> or <code>false</code>, or the locale-specific form) to the output. </li>
<li> <code>b</code>, <code>B</code>, <code>c</code>, <code>d</code>, <code>o</code>, <code>x</code>, <code>X</code>: Uses integer presentation types with the value <code>static_cast&lt;unsigned char&gt;(value)</code>. </li>
</ul> <p>The available floating-point presentation types are:</p>
<ul>
<li> <code>a</code>: If <i>precision</i> is specified, produces the output as if by calling <a href="../to_chars" title="cpp/utility/to chars"><code>std::to_chars(first, last, value, std::chars_format::hex, precision)</code></a> where <code>precision</code> is the specified precision; otherwise, the output is produced as if by calling <a href="../to_chars" title="cpp/utility/to chars"><code>std::to_chars(first, last, value, std::chars_format::hex)</code></a>. </li>
<li> <code>A</code>: same as <code>a</code>, except that it uses uppercase letters for digits above 9 and uses <code>P</code> to indicate the exponent. </li>
<li> <code>e</code>: Produces the output as if by calling <a href="../to_chars" title="cpp/utility/to chars"><code>std::to_chars(first, last, value, std::chars_format::scientific, precision)</code></a> where <code>precision</code> is the specified precision, or 6 if precision is not specified. </li>
<li> <code>E</code>: same as <code>e</code>, except that it uses <code>E</code> to indicate the exponent. </li>
<li> <code>f</code>, <code>F</code>: Produces the output as if by calling <a href="../to_chars" title="cpp/utility/to chars"><code>std::to_chars(first, last, value, std::chars_format::fixed, precision)</code></a> where <code>precision</code> is the specified precision, or 6 if precision is not specified. </li>
<li> <code>g</code>: Produces the output as if by calling <a href="../to_chars" title="cpp/utility/to chars"><code>std::to_chars(first, last, value, std::chars_format::general, precision)</code></a> where <code>precision</code> is the specified precision, or 6 if precision is not specified. </li>
<li> <code>G</code>: same as <code>g</code>, except that it uses <code>E</code> to indicate the exponent. </li>
<li> none: If <i>precision</i> is specified, produces the output as if by calling <a href="../to_chars" title="cpp/utility/to chars"><code>std::to_chars(first, last, value, std::chars_format::general, precision)</code></a> where <code>precision</code> is the specified precision; otherwise, the output is produced as if by calling <a href="../to_chars" title="cpp/utility/to chars"><code>std::to_chars(first, last, value)</code></a>. </li>
</ul> <p>For lower-case presentation types, infinity and NaN are formatted as <code>inf</code> and <code>nan</code>, respectively. For upper-case presentation types, infinity and NaN are formatted as <code>INF</code> and <code>NAN</code>, respectively.</p>
<p>The available pointer presentation types (also used for <code>std::nullptr_t</code>) are:</p>
<ul><li> none, <code>p</code>: If <code><a href="../../types/integer" title="cpp/types/integer">std::uintptr_t</a></code> is defined, produces the output as if by calling <code><a href="http://en.cppreference.com/w/cpp/utility/to_chars"><span class="kw2640">std::<span class="me2">to_chars</span></span></a><span class="br0">(</span>first, last, <span class="kw1">reinterpret_cast</span><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/types/integer"><span class="kw139">std::<span class="me2">uintptr_t</span></span></a><span class="sy1">&gt;</span><span class="br0">(</span>value<span class="br0">)</span>, <span class="nu0">16</span><span class="br0">)</span></code> with the prefix <code>0x</code> added to the output; otherwise, the output is implementation-defined. </li></ul> <h3 id="Standard_specializations_for_library_types"> Standard specializations for library types</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../../chrono/duration/formatter" title="cpp/chrono/duration/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::duration&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>duration</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/system_clock/formatter" title="cpp/chrono/system clock/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::sys_time&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>sys_time</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/utc_clock/formatter" title="cpp/chrono/utc clock/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::utc_time&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>utc_time</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/tai_clock/formatter" title="cpp/chrono/tai clock/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::tai_time&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>tai_time</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/gps_clock/formatter" title="cpp/chrono/gps clock/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::gps_time&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>gps_time</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/file_clock/formatter" title="cpp/chrono/file clock/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::file_time&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>file_time</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/local_t/formatter" title="cpp/chrono/local t/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::local_time&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>local_time</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/day/formatter" title="cpp/chrono/day/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::day&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>day</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/month/formatter" title="cpp/chrono/month/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::month&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>month</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/year/formatter" title="cpp/chrono/year/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::year&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>year</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/weekday/formatter" title="cpp/chrono/weekday/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::weekday&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>weekday</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/weekday_indexed/formatter" title="cpp/chrono/weekday indexed/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::weekday_indexed&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>weekday_indexed</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/weekday_last/formatter" title="cpp/chrono/weekday last/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::weekday_last&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>weekday_last</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/month_day/formatter" title="cpp/chrono/month day/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::month_day&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>month_day</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/month_day_last/formatter" title="cpp/chrono/month day last/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::month_day_last&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>month_day_last</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/month_weekday/formatter" title="cpp/chrono/month weekday/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::month_weekday&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>month_weekday</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/month_weekday_last/formatter" title="cpp/chrono/month weekday last/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::month_weekday_last&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>month_weekday_last</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/year_month/formatter" title="cpp/chrono/year month/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::year_month&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>year_month</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/year_month_day/formatter" title="cpp/chrono/year month day/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::year_month_day&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>year_month_day</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/year_month_day_last/formatter" title="cpp/chrono/year month day last/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::year_month_day_last&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>year_month_day_last</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/year_month_weekday/formatter" title="cpp/chrono/year month weekday/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::year_month_weekday&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>year_month_weekday</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/year_month_weekday_last/formatter" title="cpp/chrono/year month weekday last/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::year_month_weekday_last&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>year_month_weekday_last</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/hh_mm_ss/formatter" title="cpp/chrono/hh mm ss/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::hh_mm_ss&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>hh_mm_ss</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/sys_info/formatter" title="cpp/chrono/sys info/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::sys_info&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>sys_info</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/local_info/formatter" title="cpp/chrono/local info/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::local_info&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>local_info</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../../chrono/zoned_time/formatter" title="cpp/chrono/zoned time/formatter"> <span class="t-lines"><span>std::formatter<span class="t-dsc-small">&lt;std::chrono::zoned_time&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> specialization of <code>std::formatter</code> that formats a <code>zoned_time</code> according to the provided format <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> </table> <h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;format&gt;
#include &lt;iostream&gt;
 
// A wrapper for type T
template&lt;class T&gt;
struct Box {
    T value;
};
 
// The wrapper Box&lt;T&gt; can be formatted using the format specification of the wrapped value
template&lt;class T, class CharT&gt;
struct std::formatter&lt;Box&lt;T&gt;, CharT&gt; : std::formatter&lt;T, CharT&gt; {
    // parse() is inherited from the base class
 
    // Define format() by calling the base class implementation with the wrapped value
    template&lt;class FormatContext&gt;
    auto format(Box&lt;T&gt; t, FormatContext&amp; fc) const {
        return std::formatter&lt;T, CharT&gt;::format(t.value, fc);
    }
};
 
int main() {
    Box&lt;int&gt; v = { 42 };
    std::cout &lt;&lt; std::format("{:#x}", v);
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">0x2a</pre></div> </div> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="basic_format_context" title="cpp/utility/format/basic format context"> <span class="t-lines"><span>basic_format_context</span><span>format_context</span><span>wformat_context</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> formatting state, including all formatting arguments and the output iterator <br> <span class="t-mark">(class template)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/utility/format/formatter" class="_attribution-link">https://en.cppreference.com/w/cpp/utility/format/formatter</a>
  </p>
</div>
