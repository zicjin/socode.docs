   <h1 id="firstHeading" class="firstHeading">std::hash</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/functional" title="cpp/header/functional">&lt;functional&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class Key &gt;
struct hash;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr>  </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>Each specialization of this template is either <i>enabled</i> ("untainted") or <i>disabled</i> ("poisoned"). For every type <code>Key</code> for which neither the library nor the user provides an enabled specialization <code>std::hash&lt;Key&gt;</code>, that specialization exists and is disabled. Disabled specializations do not satisfy <a href="../named_req/hash" title="cpp/named req/Hash">Hash</a>, do not satisfy <a href="../named_req/functionobject" title="cpp/named req/FunctionObject">FunctionObject</a>, and <code><a href="../types/is_default_constructible" title="cpp/types/is default constructible">std::is_default_constructible_v</a></code>, <code><a href="../types/is_copy_constructible" title="cpp/types/is copy constructible">std::is_copy_constructible_v</a></code>, <code><a href="../types/is_move_constructible" title="cpp/types/is move constructible">std::is_move_constructible_v</a></code>, <code><a href="../types/is_copy_assignable" title="cpp/types/is copy assignable">std::is_copy_assignable_v</a></code>, <code><a href="../types/is_move_assignable" title="cpp/types/is move assignable">std::is_move_assignable_v</a></code> are all <code>false</code>. In other words, they exist, but cannot be used.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <p>The <span class="t-rev-inl t-since-cxx17"><span><i>enabled</i> specializations of the</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> hash template defines a function object that implements a <a href="https://en.wikipedia.org/wiki/Hash_function" class="extiw" title="enwiki:Hash function">hash function</a>. Instances of this function object satisfy <a href="../named_req/hash" title="cpp/named req/Hash">Hash</a>. In particular, they define an <code>operator() const</code> that:</p>
<p>1. Accepts a single parameter of type <code>Key</code>.</p>
<p>2. Returns a value of type <code><a href="../types/size_t"><span class="kw100">std::<span class="me2">size_t</span></span></a></code> that represents the hash value of the parameter.</p>
<p>3. Does not throw exceptions when called.</p>
<p>4. For two parameters <code>k1</code> and <code>k2</code> that are equal, <code>std::hash&lt;Key&gt;()(k1) == std::hash&lt;Key&gt;()(k2)</code>.</p>
<p>5. For two different parameters <code>k1</code> and <code>k2</code> that are not equal, the probability that <code>std::hash&lt;Key&gt;()(k1) == std::hash&lt;Key&gt;()(k2)</code> should be very small, approaching <code><span class="nu16">1.0</span><span class="sy2">/</span><a href="../types/numeric_limits"><span class="kw344">std::<span class="me2">numeric_limits</span></span></a><span class="sy1">&lt;</span><a href="../types/size_t"><span class="kw100">std::<span class="me2">size_t</span></span></a><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">max</span><span class="br0">(</span><span class="br0">)</span></code>.</p>
<p>All explicit and partial specializations of <code>hash</code> provided by the standard library are <a href="../named_req/defaultconstructible" title="cpp/named req/DefaultConstructible">DefaultConstructible</a>, <a href="../named_req/copyassignable" title="cpp/named req/CopyAssignable">CopyAssignable</a>, <a href="../named_req/swappable" title="cpp/named req/Swappable">Swappable</a> and <a href="../named_req/destructible" title="cpp/named req/Destructible">Destructible</a>. User-provided specializations of <code>hash</code> also must meet those requirements.</p>
<p>The unordered associative containers <code><a href="../container/unordered_set" title="cpp/container/unordered set">std::unordered_set</a></code>, <code><a href="../container/unordered_multiset" title="cpp/container/unordered multiset">std::unordered_multiset</a></code>, <code><a href="../container/unordered_map" title="cpp/container/unordered map">std::unordered_map</a></code>, <code><a href="../container/unordered_multimap" title="cpp/container/unordered multimap">std::unordered_multimap</a></code> use specializations of the template <code>std::hash</code> as the default hash function.</p>
<h3 id="Notes">Notes</h3> <p>The actual hash functions are implementation-dependent and are not required to fulfill any other quality criteria except those specified above. Notably, some implementations use trivial (identity) hash functions which map an integer to itself. In other words, these hash functions are designed to work with unordered associative containers, but not as cryptographic hashes, for example.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td>Hash functions are only required to produce the same result for the same input within a single execution of a program; this allows salted hashes that prevent collision denial-of-service attacks.</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <p>There is no specialization for C strings. <code>std::hash&lt;const char*&gt;</code> produces a hash of the value of the pointer (the memory address), it does not examine the contents of any character array.</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <h3 id="Member_types"> Member types</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Member type </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> <code>argument_type</code><span class="t-mark">(deprecated in C++17)</span> </td> <td> <code>Key</code> </td>
</tr> <tr class="t-dsc"> <td> <code>result_type</code><span class="t-mark">(deprecated in C++17)</span> </td> <td> <code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code> </td>
</tr> </table> </td> <td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td>
</tr> </table> <h3 id="Member_functions">Member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="hash/hash" title="cpp/utility/hash/hash"> <span class="t-lines"><span>(constructor)</span></span></a></div> </td> <td> constructs a hash function object <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="hash/operator()" title="cpp/utility/hash/operator()"> <span class="t-lines"><span>operator()</span></span></a></div> </td> <td> calculate the hash of the argument <br> <span class="t-mark">(public member function)</span> </td>
</tr> </table> <h3 id="Standard_specializations_for_basic_types">Standard specializations for basic types</h3> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/functional" title="cpp/header/functional">&lt;functional&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">template&lt;&gt; struct hash&lt;bool&gt;;
template&lt;&gt; struct hash&lt;char&gt;;
template&lt;&gt; struct hash&lt;signed char&gt;;
template&lt;&gt; struct hash&lt;unsigned char&gt;;
template&lt;&gt; struct hash&lt;char16_t&gt;;
template&lt;&gt; struct hash&lt;char32_t&gt;;
template&lt;&gt; struct hash&lt;wchar_t&gt;;
template&lt;&gt; struct hash&lt;short&gt;;
template&lt;&gt; struct hash&lt;unsigned short&gt;;
template&lt;&gt; struct hash&lt;int&gt;;
template&lt;&gt; struct hash&lt;unsigned int&gt;;
template&lt;&gt; struct hash&lt;long&gt;;
template&lt;&gt; struct hash&lt;long long&gt;;
template&lt;&gt; struct hash&lt;unsigned long&gt;;
template&lt;&gt; struct hash&lt;unsigned long long&gt;;
template&lt;&gt; struct hash&lt;float&gt;;
template&lt;&gt; struct hash&lt;double&gt;;
template&lt;&gt; struct hash&lt;long double&gt;;
template&lt; class T &gt; struct hash&lt;T*&gt;;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>In addition to the above, the standard library provides specializations for all (scoped and unscoped) enumeration types. These may be (but are not required to be) implemented as <code>std<span class="sy4">::</span><span class="me2">hash</span><span class="sy1">&lt;</span><a href="../types/underlying_type"><span class="kw633">std::<span class="me2">underlying_type</span></span></a><span class="sy1">&lt;</span>Enum<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">type</span><span class="sy1">&gt;</span></code>).</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <p>Each standard library header that declares the template <code>std::hash</code> provides enabled specializations of <code>std::hash</code> for <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code> and all cv-unqualified arithmetic types (including any extended integer types), all enumeration types, and all pointer types.</p>
<p>All member functions of all standard library specializations of this template are <code>noexcept</code> except for the member functions of <a href="optional/hash" title="cpp/utility/optional/hash"><code>std::hash&lt;std::optional&gt;</code></a>, <a href="variant/hash" title="cpp/utility/variant/hash"><code>std::hash&lt;std::variant&gt;</code></a>, and <a href="../memory/unique_ptr/hash" title="cpp/memory/unique ptr/hash"><code>std::hash&lt;std::unique_ptr&gt;</code></a></p>
</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <h3 id="Standard_specializations_for_library_types">Standard specializations for library types</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/hash" title="cpp/string/basic string/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::string&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::u8string&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::u16string&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::u32string&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::wstring&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::pmr::string&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::pmr::u8string&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::pmr::u16string&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::pmr::u32string&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::pmr::wstring&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> hash support for strings <br> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../error/error_code/hash" title="cpp/error/error code/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::error_code&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> hash support for <code><a href="../error/error_code" title="cpp/error/error code">std::error_code</a></code> <br> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="bitset/hash" title="cpp/utility/bitset/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::bitset&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> hash support for <code><a href="bitset" title="cpp/utility/bitset">std::bitset</a></code> <br> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/unique_ptr/hash" title="cpp/memory/unique ptr/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::unique_ptr&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> hash support for <code><a href="../memory/unique_ptr" title="cpp/memory/unique ptr">std::unique_ptr</a></code> <br> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../memory/shared_ptr/hash" title="cpp/memory/shared ptr/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::shared_ptr&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> hash support for <code><a href="../memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></code> <br> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../types/type_index/hash" title="cpp/types/type index/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::type_index&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> hash support for <code><a href="../types/type_index" title="cpp/types/type index">std::type_index</a></code> <br> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../container/vector_bool/hash" title="cpp/container/vector bool/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::vector&lt;bool&gt;&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> hash support for <code><a href="../container/vector"><span class="kw1265">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">bool</span><span class="sy1">&gt;</span></code> <br> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../thread/thread/id/hash" title="cpp/thread/thread/id/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::thread::id&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> hash support for <code><a href="../thread/thread/id" title="cpp/thread/thread/id">std::thread::id</a></code> <br> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="optional/hash" title="cpp/utility/optional/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::optional&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> specializes the <code>std::hash</code> algorithm <br> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="variant/hash" title="cpp/utility/variant/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::variant&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> specializes the <code>std::hash</code> algorithm <br> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string_view/hash" title="cpp/string/basic string view/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::string_view&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::wstring_view&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::u8string_view&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::u16string_view&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::u32string_view&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> hash support for string views <br> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../error/error_condition/hash" title="cpp/error/error condition/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::error_condition&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> hash support for <code><a href="../error/error_condition" title="cpp/error/error condition">std::error_condition</a></code> <br> <span class="t-mark">(class template specialization)</span> </td>
</tr> </table> <p>Note: additional specializations for <code>std::pair</code> and the standard container types, as well as utility functions to compose hashes are available in <a rel="nofollow" class="external text" href="http://www.boost.org/doc/libs/release/doc/html/hash/reference.html">boost.hash</a>.</p>
<h3 id="Example">Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;functional&gt;
#include &lt;string&gt;
#include &lt;unordered_set&gt;
 
struct S {
    std::string first_name;
    std::string last_name;
};
bool operator==(const S&amp; lhs, const S&amp; rhs) {
    return lhs.first_name == rhs.first_name &amp;&amp; lhs.last_name == rhs.last_name;
}
 
// custom hash can be a standalone function object:
struct MyHash
{
    std::size_t operator()(S const&amp; s) const noexcept
    {
        std::size_t h1 = std::hash&lt;std::string&gt;{}(s.first_name);
        std::size_t h2 = std::hash&lt;std::string&gt;{}(s.last_name);
        return h1 ^ (h2 &lt;&lt; 1); // or use boost::hash_combine (see Discussion)
    }
};
 
// custom specialization of std::hash can be injected in namespace std
namespace std
{
    template&lt;&gt; struct hash&lt;S&gt;
    {
        typedef S argument_type;
        typedef std::size_t result_type;
        result_type operator()(argument_type const&amp; s) const noexcept
        {
            result_type const h1 ( std::hash&lt;std::string&gt;{}(s.first_name) );
            result_type const h2 ( std::hash&lt;std::string&gt;{}(s.last_name) );
            return h1 ^ (h2 &lt;&lt; 1); // or use boost::hash_combine (see Discussion)
        }
    };
}
 
int main()
{
 
    std::string str = "Meet the new boss...";
    std::size_t str_hash = std::hash&lt;std::string&gt;{}(str);
    std::cout &lt;&lt; "hash(" &lt;&lt; std::quoted(str) &lt;&lt; ") = " &lt;&lt; str_hash &lt;&lt; '\n';
 
    S obj = { "Hubert", "Farnsworth"};
    // using the standalone function object
    std::cout &lt;&lt; "hash(" &lt;&lt; std::quoted(obj.first_name) &lt;&lt; ',' 
               &lt;&lt; std::quoted(obj.last_name) &lt;&lt; ") = "
               &lt;&lt; MyHash{}(obj) &lt;&lt; " (using MyHash)\n                           or "
               &lt;&lt; std::hash&lt;S&gt;{}(obj) &lt;&lt; " (using injected std::hash&lt;S&gt; specialization)\n";
 
    // custom hash makes it possible to use custom types in unordered containers
    // The example will use the injected std::hash&lt;S&gt; specialization above,
    // to use MyHash instead, pass it as a second template argument
    std::unordered_set&lt;S&gt; names = {obj, {"Bender", "Rodriguez"}, {"Turanga", "Leela"} };
    for(auto&amp; s: names)
        std::cout &lt;&lt; std::quoted(s.first_name) &lt;&lt; ' ' &lt;&lt; std::quoted(s.last_name) &lt;&lt; '\n';
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">hash("Meet the new boss...") = 1861821886482076440
hash("Hubert","Farnsworth") = 17622465712001802105 (using MyHash)
                           or 17622465712001802105 (using injected std::hash&lt;S&gt; specialization) 
"Turanga" "Leela"
"Bender" "Rodriguez"
"Hubert" "Farnsworth"</pre></div> </div>          <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/utility/hash" class="_attribution-link">http://en.cppreference.com/w/cpp/utility/hash</a>
  </p>
</div>
