    <h1 id="firstHeading" class="firstHeading">std::apply</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/tuple" title="cpp/header/tuple">&lt;tuple&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">template &lt;class F, class Tuple&gt;
constexpr decltype(auto) apply(F&amp;&amp; f, Tuple&amp;&amp; t);</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  </table> <p>Invoke the <a href="../named_req/callable" title="cpp/named req/Callable">Callable</a> object <code>f</code> with a tuple of arguments.</p>
<h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> f </td> <td> - </td> <td> <a href="../named_req/callable" title="cpp/named req/Callable">Callable</a> object to be invoked </td>
</tr> <tr class="t-par"> <td> t </td> <td> - </td> <td> tuple whose elements to be used as arguments to <code>f</code> </td>
</tr>
</table> <h3 id="Return_value"> Return value</h3> <p>The value returned by <code>f</code>.</p>
<h3 id="Notes">  Notes </h3> <p>The tuple need not be <code><a href="tuple" title="cpp/utility/tuple">std::tuple</a></code>, and instead may be anything that supports <code><a href="variant/get" title="cpp/utility/variant/get">std::get</a></code> and <code>std::tuple_size</code>; in particular, <code><a href="../container/array" title="cpp/container/array">std::array</a></code> and <code><a href="pair" title="cpp/utility/pair">std::pair</a></code> may be used.</p>
<p><a href="../feature_test#Library_features" title="cpp/feature test">Feature testing</a> macro: <a href="feature_test" title="cpp/utility/feature test"><code>__cpp_lib_apply</code></a>.</p>
<h3 id="Possible_implementation"> Possible implementation</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">namespace detail {
template &lt;class F, class Tuple, std::size_t... I&gt;
constexpr decltype(auto) apply_impl(F&amp;&amp; f, Tuple&amp;&amp; t, std::index_sequence&lt;I...&gt;)
{
    // This implementation is valid since C++20 (via P1065R2)
    // In C++17, a constexpr counterpart of std::invoke is actually needed here
    return std::invoke(std::forward&lt;F&gt;(f), std::get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...);
}
}  // namespace detail
 
template &lt;class F, class Tuple&gt;
constexpr decltype(auto) apply(F&amp;&amp; f, Tuple&amp;&amp; t)
{
    return detail::apply_impl(
        std::forward&lt;F&gt;(f), std::forward&lt;Tuple&gt;(t),
        std::make_index_sequence&lt;std::tuple_size_v&lt;std::remove_reference_t&lt;Tuple&gt;&gt;&gt;{});
}</pre></div> </td>
</tr>
</table> <h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;tuple&gt;
#include &lt;utility&gt;
 
int add(int first, int second) { return first + second; }
 
template&lt;typename T&gt;
T add_generic(T first, T second) { return first + second; }
 
auto add_lambda = [](auto first, auto second) { return first + second; };
 
template&lt;typename... Ts&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, std::tuple&lt;Ts...&gt; const&amp; theTuple)
{
    std::apply
    (
        [&amp;os](Ts const&amp;... tupleArgs)
        {
            os &lt;&lt; '[';
            std::size_t n{0};
            ((os &lt;&lt; tupleArgs &lt;&lt; (++n != sizeof...(Ts) ? ", " : "")), ...);
            os &lt;&lt; ']';
        }, theTuple
    );
    return os;
}
 
int main()
{
    // OK
    std::cout &lt;&lt; std::apply(add, std::pair(1, 2)) &lt;&lt; '\n';
 
    // Error: can't deduce the function type
    // std::cout &lt;&lt; std::apply(add_generic, std::make_pair(2.0f, 3.0f)) &lt;&lt; '\n'; 
 
    // OK
    std::cout &lt;&lt; std::apply(add_lambda, std::pair(2.0f, 3.0f)) &lt;&lt; '\n'; 
 
    // advanced example
    std::tuple myTuple(25, "Hello", 9.31f, 'c');
    std::cout &lt;&lt; myTuple &lt;&lt; '\n';
 
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">3
5
[25, Hello, 9.31, c]</pre></div> </div> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="tuple/make_tuple" title="cpp/utility/tuple/make tuple"> <span class="t-lines"><span>make_tuple</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> creates a <code>tuple</code> object of the type defined by the argument types <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="tuple/forward_as_tuple" title="cpp/utility/tuple/forward as tuple"> <span class="t-lines"><span>forward_as_tuple</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> creates a <code>tuple</code> of <a href="../language/reference#Forwarding_references" title="cpp/language/reference">forwarding references</a> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="make_from_tuple" title="cpp/utility/make from tuple"> <span class="t-lines"><span>make_from_tuple</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> Construct an object with a tuple of arguments <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="functional/invoke" title="cpp/utility/functional/invoke"> <span class="t-lines"><span>invoke</span><span>invoke_r</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span><span><span class="t-mark-rev t-since-cxx23">(C++23)</span></span></span></div> </td> <td> invokes any <a href="../named_req/callable" title="cpp/named req/Callable">Callable</a> object with given arguments <span class="t-rev-inl t-since-cxx23"><span>and possibility to specify return type</span> <span><span class="t-mark-rev t-since-cxx23">(since C++23)</span></span></span> <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/utility/apply" class="_attribution-link">https://en.cppreference.com/w/cpp/utility/apply</a>
  </p>
</div>
