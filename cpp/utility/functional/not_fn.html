    <h1 id="firstHeading" class="firstHeading">std::not_fn</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../../header/functional" title="cpp/header/functional">&lt;functional&gt;</a></code> </th> <th> </th> <th> </th> </tr>   <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td> <pre data-language="cpp">template&lt; class F&gt;
/*unspecified*/ not_fn( F&amp;&amp; f );</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> <br><span class="t-mark-rev t-until-cxx20">(until C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt; class F&gt;
constexpr /*unspecified*/ not_fn( F&amp;&amp; f );</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>   </table> <p>Creates a forwarding call wrapper that returns the negation of the callable object it holds.</p>
<h3 id="Parameters">  Parameters </h3> <table class="t-par-begin"> <tr class="t-par"> <td> f </td> <td> - </td> <td> the object from which the <a href="../../named_req/callable" title="cpp/named req/Callable">Callable</a> object held by the wrapper is constructed </td>
</tr> <tr class="t-par-hitem"> <td colspan="3"> Type requirements </td>
</tr> <tr class="t-par-req"> <td colspan="3"> -<code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">std::<span class="me2">decay_t</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span></code> must meet the requirements of <a href="../../named_req/callable" title="cpp/named req/Callable">Callable</a> and <a href="../../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>. </td>
</tr> <tr class="t-par-req"> <td colspan="3"> -<code><a href="http://en.cppreference.com/w/cpp/types/is_constructible"><span class="kw527">std::<span class="me2">is_constructible_v</span></span></a><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">std::<span class="me2">decay_t</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span>, F<span class="sy1">&gt;</span></code> is required to be true </td>
</tr>
</table> <h3 id="Return_value"> Return value</h3> <p>A function object of unspecified type T. It has the following members:</p>
<h2 id="std::not_fn_return_type">  std::not_fn <i>return type</i> </h2> <h4 id="Member_objects"> Member objects</h4> <p>The return type of <code>std::not_fn</code> holds a member object of type <code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">std::<span class="me2">decay_t</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span></code>.</p>
<h4 id="Constructors"> Constructors</h4> <table class="t-dcl-begin">  <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td> <pre data-language="cpp">explicit T(F&amp;&amp; f); // exposition only</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> <br><span class="t-mark-rev t-until-cxx20">(until C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">explicit constexpr T(F&amp;&amp; f); // exposition only</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>  <tr class="t-dcl"> <td> <pre data-language="cpp">T(T&amp;&amp; f) = default;
T(const T&amp; f) = default;</pre>
</td> <td> (2) </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <div class="t-li1">
<span class="t-li">1)</span> The constructor direct-non-list-initializes the member object (of type <code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">std::<span class="me2">decay_t</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span></code>) from <code><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span><span class="br0">(</span>f<span class="br0">)</span></code>. Throws any exception thrown by the constructor selected</div> <div class="t-li1">
<span class="t-li">2)</span> Because <code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">std::<span class="me2">decay_t</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span></code> is required to be <a href="../../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>, the returned call wrapper is always <a href="../../named_req/moveconstructible" title="cpp/named req/MoveConstructible">MoveConstructible</a>, and is <a href="../../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a> if <code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">std::<span class="me2">decay_t</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span></code> is <a href="../../named_req/copyconstructible" title="cpp/named req/CopyConstructible">CopyConstructible</a>.</div> <h4 id="Member_function_operator.28.29"> Member function <code>operator()</code>
</h4> <table class="t-dcl-begin">  <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td> <pre data-language="cpp">template&lt;class... Args&gt; auto operator()(Args&amp;&amp;... args) &amp;
-&gt; decltype(
    !std::declval&lt;std::invoke_result_t&lt;std::decay_t&lt;F&gt;&amp;, Args...&gt;&gt;());
template&lt;class... Args&gt; auto operator()(Args&amp;&amp;... args) const&amp;
-&gt; decltype(
    !std::declval&lt;std::invoke_result_t&lt;std::decay_t&lt;F&gt; const&amp;, Args...&gt;&gt;());</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> <br><span class="t-mark-rev t-until-cxx20">(until C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) &amp;
   noexcept(/*see below*/)
-&gt; decltype(
    !std::declval&lt;std::invoke_result_t&lt;std::decay_t&lt;F&gt;&amp;, Args...&gt;&gt;());
template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) const&amp;
   noexcept(/*see below*/)
-&gt; decltype(
    !std::declval&lt;std::invoke_result_t&lt;std::decay_t&lt;F&gt; const&amp;, Args...&gt;&gt;());</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>   <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td> <pre data-language="cpp">template&lt;class... Args&gt; auto operator()(Args&amp;&amp;... args) &amp;&amp;
-&gt; decltype(
    !std::declval&lt;std::invoke_result_t&lt;std::decay_t&lt;F&gt;, Args...&gt;&gt;());
template&lt;class... Args&gt; auto operator()(Args&amp;&amp;... args) const&amp;&amp;
-&gt; decltype(
    !std::declval&lt;std::invoke_result_t&lt;std::decay_t&lt;F&gt; const, Args...&gt;&gt;());</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> <br><span class="t-mark-rev t-until-cxx20">(until C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) &amp;&amp;
   noexcept(/*see below*/)
-&gt; decltype(
    !std::declval&lt;std::invoke_result_t&lt;std::decay_t&lt;F&gt;, Args...&gt;&gt;());
template&lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) const&amp;&amp;
   noexcept(/*see below*/)
-&gt; decltype(
    !std::declval&lt;std::invoke_result_t&lt;std::decay_t&lt;F&gt; const, Args...&gt;&gt;());</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>   </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17 t-until-cxx20">
<td> <span class="t-li">1)</span> Equivalent to <code><span class="kw1">return</span> <span class="sy3">!</span><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1062">std::<span class="me2">invoke</span></span></a><span class="br0">(</span>fd, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...<span class="br0">)</span><span class="sy4">;</span></code> <span class="t-li">2)</span> Equivalent to <code><span class="kw1">return</span> <span class="sy3">!</span><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1062">std::<span class="me2">invoke</span></span></a><span class="br0">(</span>std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>fd<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...<span class="br0">)</span><span class="sy4">;</span></code> </td> <td>
<span class="t-mark-rev t-since-cxx17">(since C++17)</span><br><span class="t-mark-rev t-until-cxx20">(until C++20)</span>
</td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <span class="t-li">1)</span> Expression-equivalent to <code><span class="sy3">!</span><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1062">std::<span class="me2">invoke</span></span></a><span class="br0">(</span>fd, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...<span class="br0">)</span></code> <span class="t-li">2)</span> Expression-equivalent to <code><span class="sy3">!</span><a href="http://en.cppreference.com/w/cpp/utility/functional/invoke"><span class="kw1062">std::<span class="me2">invoke</span></span></a><span class="br0">(</span>std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>fd<span class="br0">)</span>, <a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1119">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...<span class="br0">)</span></code> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p>where <code>fd</code> is the member object of type <code><a href="http://en.cppreference.com/w/cpp/types/decay"><span class="kw631">std::<span class="me2">decay_t</span></span></a><span class="sy1">&lt;</span>F<span class="sy1">&gt;</span></code></p>
<h3 id="Expression-equivalent"> Expression-equivalent</h3> <p>Expression <code>e</code> is <i>expression-equivalent</i> to expression <code>f</code>, if.</p>
<ul>
<li>
<code>e</code> and <code>f</code> have the same effects, and </li>
<li>either both are <a href="../../language/constant_expression" title="cpp/language/constant expression">constant subexpressions</a> or else neither is a constant subexpression, and </li>
<li>either both are <a href="../../language/noexcept_spec" title="cpp/language/noexcept spec">potentially-throwing</a> or else neither is potentially-throwing (i.e. <code>noexcept(e) == noexcept(f)</code>). </li>
</ul>  <h3 id="Exceptions">  Exceptions </h3> <p>Throws no exceptions, unless the construction of <code>fd</code> throws.</p>
<h3 id="Possible_implementation">  Possible implementation </h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">namespace detail {
    template&lt;class F&gt;
    struct not_fn_t {
        F f;
        template&lt;class... Args&gt;
        constexpr auto operator()(Args&amp;&amp;... args) &amp;
            noexcept(noexcept(!std::invoke(f, std::forward&lt;Args&gt;(args)...)))
            -&gt; decltype(!std::invoke(f, std::forward&lt;Args&gt;(args)...))
        {
            return !std::invoke(f, std::forward&lt;Args&gt;(args)...);
        }
 
        template&lt;class... Args&gt;
        constexpr auto operator()(Args&amp;&amp;... args) const&amp;
            noexcept(noexcept(!std::invoke(f, std::forward&lt;Args&gt;(args)...)))
            -&gt; decltype(!std::invoke(f, std::forward&lt;Args&gt;(args)...))
        {
            return !std::invoke(f, std::forward&lt;Args&gt;(args)...);
        }
 
        template&lt;class... Args&gt;
        constexpr auto operator()(Args&amp;&amp;... args) &amp;&amp;
            noexcept(noexcept(!std::invoke(std::move(f), std::forward&lt;Args&gt;(args)...)))
            -&gt; decltype(!std::invoke(std::move(f), std::forward&lt;Args&gt;(args)...))
        {
            return !std::invoke(std::move(f), std::forward&lt;Args&gt;(args)...);
        }
 
        template&lt;class... Args&gt;
        constexpr auto operator()(Args&amp;&amp;... args) const&amp;&amp;
            noexcept(noexcept(!std::invoke(std::move(f), std::forward&lt;Args&gt;(args)...)))
            -&gt; decltype(!std::invoke(std::move(f), std::forward&lt;Args&gt;(args)...))
        {
            return !std::invoke(std::move(f), std::forward&lt;Args&gt;(args)...);
        }
    };
}
 
template&lt;class F&gt;
constexpr detail::not_fn_t&lt;std::decay_t&lt;F&gt;&gt; not_fn(F&amp;&amp; f)
{
    return { std::forward&lt;F&gt;(f) };
}</pre></div> </td>
</tr>
</table> <h3 id="Notes">  Notes </h3> <p><code>not_fn</code> is intended to replace the C++03-era negators <code><a href="not1" title="cpp/utility/functional/not1">std::not1</a></code> and <code><a href="not2" title="cpp/utility/functional/not2">std::not2</a></code>.</p>
<p><a href="../../feature_test#Library_features" title="cpp/feature test">Feature testing</a> macro: <a href="../feature_test" title="cpp/utility/feature test"><code>__cpp_lib_not_fn</code></a>.</p>
<h3 id="Example">  Example </h3>  <h3 id="See_also">  See also </h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="not1" title="cpp/utility/functional/not1"> <span class="t-lines"><span>not1</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> constructs custom <code><a href="unary_negate" title="cpp/utility/functional/unary negate">std::unary_negate</a></code> object <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="not2" title="cpp/utility/functional/not2"> <span class="t-lines"><span>not2</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> constructs custom <code><a href="binary_negate" title="cpp/utility/functional/binary negate">std::binary_negate</a></code> object <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/utility/functional/not_fn" class="_attribution-link">https://en.cppreference.com/w/cpp/utility/functional/not_fn</a>
  </p>
</div>
