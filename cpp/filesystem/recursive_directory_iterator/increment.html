   <h1 id="firstHeading" class="firstHeading">std::filesystem::recursive_directory_iterator::operator++, std::filesystem::recursive_directory_iterator::increment</h1>            <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">recursive_directory_iterator&amp; operator++();</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">recursive_directory_iterator&amp; increment( std::error_code&amp; ec );</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  </table> <p>Advances the iterator to the next entry. Invalidates all copies of the previous value of <code>*this</code>.</p>
<p>If there are no more entries left in the currently iterated directory, the iteration is resumed over the parent directory. The process is repeated if the parent directory has no sibling entries that can to be iterated on. If the parent of the directory hierarchy that has been recursively iterated on is reached (there are no candidate entries at <code>depth() == 0)</code>, <code>*this</code> is set to an end iterator.</p>
<p>Otherwise, if <code>*this</code> refers to a directory, it is iterated into if the following conditions are met:</p>
<ul>
<li> <code><a href="disable_recursion_pending" title="cpp/filesystem/recursive directory iterator/disable recursion pending">disable_recursion_pending()</a></code> has not been called before this increment, i.e. <code>recursion_pending() == true</code>. </li>
<li> The directory is not a symlink or following symlinks is enabled, i.e., at least one of the following is true: <ul>
<li>
<code>!is_symlink((*this)-&gt;symlink_status())</code>. </li>
<li>
<code>(options() &amp; directory_options::follow_directory_symlink) != directory_options::none)</code> </li>
</ul> </li>
</ul> <h3 id="Parameters">Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> ec </td> <td> - </td> <td> error code to store the error status to </td>
</tr>
</table> <h3 id="Return_value">Return value</h3> <p><code>*this</code>.</p>
<h3 id="Exceptions">Exceptions</h3> <p>The overload that does not take a <code><a href="../../error/error_code"><span class="kw872">std::<span class="me2">error_code</span></span></a><span class="sy3">&amp;</span></code> parameter throws <a href="../filesystem_error" title="cpp/filesystem/filesystem error"><code>filesystem_error</code></a> on underlying OS API errors, constructed with the OS error code as the error code argument. The overload taking a <code><a href="../../error/error_code"><span class="kw872">std::<span class="me2">error_code</span></span></a><span class="sy3">&amp;</span></code> parameter sets it to the OS API error code if an OS API call fails, and executes <code>ec.clear()</code> if no errors occur. Any overload not marked <code>noexcept</code> may throw <code><a href="../../memory/new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code> if memory allocation fails.</p>
<h3 id="Defect_reports">Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue3013">LWG 3013</a> </td> <td> C++17 </td> <td> <code>error_code</code> overload marked noexcept but can allocate memory </td> <td> noexcept removed </td>
</tr>
</table>          <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/filesystem/recursive_directory_iterator/increment" class="_attribution-link">http://en.cppreference.com/w/cpp/filesystem/recursive_directory_iterator/increment</a>
  </p>
</div>
