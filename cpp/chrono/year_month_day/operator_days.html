   <h1 id="firstHeading" class="firstHeading">std::chrono::year_month_day::operator sys_days, std::chrono::year_month_day::operator local_days</h1>            <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">constexpr operator std::chrono::sys_days() const noexcept;</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">explicit constexpr operator std::chrono::local_days() const noexcept;</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>  </table> <p>Converts <code>*this</code> to a <code><a href="../time_point" title="cpp/chrono/time point">std::chrono::time_point</a></code> representing the same date as this <code>year_month_day</code>.</p>
<div class="t-li1">
<span class="t-li">1)</span> If <code>ok()</code> is true, the return value holds a count of days from the <code><a href="../system_clock" title="cpp/chrono/system clock">std::chrono::system_clock</a></code> epoch (1970-01-01) to <code>*this</code>. The result is negative if <code>*this</code> represent a date prior to it.</div> <div class="t-li1">
 Otherwise, if the stored year and month are valid (<code>year().ok() &amp;&amp; month().ok()</code> is <code>true</code>), then the returned value is <code>sys_days(year()/month()/1d) + (day() - 1d)</code>. </div> <div class="t-li1">
 Otherwise (if <code>year().ok() &amp;&amp; month().ok()</code> is <code>false</code>), the return value is unspecified.</div> <div class="t-li1">
 A <code>sys_days</code> in the range <code><span class="br0">[</span><a href="../duration"><span class="kw995">std::<span class="me2">chrono</span><span class="sy4">::</span><span class="me2">days</span></span></a><span class="br0">{</span><span class="sy2">-</span><span class="nu0">12687428</span><span class="br0">}</span>, <a href="../duration"><span class="kw995">std::<span class="me2">chrono</span><span class="sy4">::</span><span class="me2">days</span></span></a><span class="br0">{</span><span class="nu0">11248737</span><span class="br0">}</span><span class="br0">]</span></code>, when converted to <code>year_month_day</code> and back, yields the same value.</div> <div class="t-li1">
<span class="t-li">2)</span> Same as <span class="t-v">(1)</span> but returns <code>local_days</code> instead. Equivalent to <code>return local_days(sys_days(*this).time_since_epoch());</code>.</div> <h3 id="Notes"> Notes </h3> <p>Converting to <code>sys_days</code> and back can be used to normalize a <code>year_month_day</code> that contains an invalid day but a valid year and month:</p>
<div class="cpp source-cpp"><pre data-language="cpp">using namespace std::chrono;
auto ymd = 2017y/January/0;
ymd = sys_days{ymd};
// ymd is now 2016y/December/31</pre></div> <p>Normalizing the year and month can be done by adding (or subtracting) zero <code>std::chrono::months</code>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">using namespace std::chrono;
constexpr year_month_day normalize(year_month_day ymd){
    ymd += months{0}; // normalizes year and month
    return sys_days{ymd}; // normalizes day
}
static_assert(normalize(2017y/33/59) == 2019y/10/29);</pre></div> <h3 id="Example"> Example </h3>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/chrono/year_month_day/operator_days" class="_attribution-link">http://en.cppreference.com/w/cpp/chrono/year_month_day/operator_days</a>
  </p>
</div>
