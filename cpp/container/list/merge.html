   <h1 id="firstHeading" class="firstHeading">std::list&lt;T,Allocator&gt;::merge</h1>             <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx98"> <td> <pre data-language="cpp">void merge( list&amp; other );</pre>
</td> <td> (1) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">void merge( list&amp;&amp; other );</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx98"> <td> <pre data-language="cpp">template &lt;class Compare&gt; 
void merge( list&amp; other, Compare comp );</pre>
</td> <td> (2) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template &lt;class Compare&gt; 
void merge( list&amp;&amp; other, Compare comp );</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr>  </table> <p>Merges two sorted lists into one. The lists should be sorted into ascending order.</p>
<p>No elements are copied. The container <code>other</code> becomes empty after the operation. The function does nothing if <code>other</code> refers to the same object as <code>*this</code>. If <code>get_allocator() != other.get_allocator()</code>, the behavior is undefined. No iterators or references become invalidated, except that the iterators of moved elements now refer into <code>*this</code>, not into <code>other</code>. The first version uses <code>operator&lt;</code> to compare the elements, the second version uses the given comparison function <code>comp</code>.</p>
<p>This operation is stable: for equivalent elements in the two lists, the elements from <code>*this</code> shall always precede the elements from <code>other</code>, and the order of equivalent elements of <code>*this</code> and <code>other</code> does not change.</p>
<h3 id="Parameters">Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> other </td> <td> - </td> <td> another container to merge </td>
</tr> <tr class="t-par"> <td> comp </td> <td> - </td> <td> comparison function object (i.e. an object that satisfies the requirements of <a href="../../named_req/compare" title="cpp/named req/Compare">Compare</a>) which returns ​<code>true</code> if the first argument is <i>less</i> than (i.e. is ordered <i>before</i>) the second. <br> <p>The signature of the comparison function should be equivalent to the following:</p>
<p><span class="t-cc"><code> bool cmp(const Type1 &amp;a, const Type2 &amp;b);</code></span></p>
<p>While the signature does not need to have <code>const &amp;</code>, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) <code>Type1</code> and <code>Type2</code> regardless of <a href="../../language/value_category" title="cpp/language/value category">value category</a> (thus, <code>Type1 &amp;</code> is not allowed<span class="t-rev-inl t-since-cxx11"><span>, nor is <code>Type1</code> unless for <code>Type1</code> a move is equivalent to a copy</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>).<br> The types <code>Type1</code> and <code>Type2</code> must be such that an object of type <code>list&lt;T,Allocator&gt;::const_iterator</code> can be dereferenced and then implicitly converted to both of them. ​</p>
</td>
</tr>
</table> <h3 id="Return_value">Return value</h3> <p>(none).</p>
<h3 id="Exceptions">Exceptions</h3> <p>If an exception is thrown, this function has no effect (strong exception guarantee), except if the exception comes from the comparison function.</p>
<h3 id="Complexity">Complexity</h3> <p>at most <code><a href="../../iterator/distance"><span class="kw669">std::<span class="me2">distance</span></span></a><span class="br0">(</span>begin<span class="br0">(</span><span class="br0">)</span>, end<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="sy2">+</span> <a href="../../iterator/distance"><span class="kw669">std::<span class="me2">distance</span></span></a><span class="br0">(</span>other.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, other.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="sy2">-</span> <span class="nu0">1</span></code> comparisons.</p>
<h3 id="Example">Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;list&gt;
 
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; ostr, const std::list&lt;int&gt;&amp; list)
{
    for (auto &amp;i : list) {
        ostr &lt;&lt; " " &lt;&lt; i;
    }
    return ostr;
}
 
int main()
{
    std::list&lt;int&gt; list1 = { 5,9,0,1,3 };
    std::list&lt;int&gt; list2 = { 8,7,2,6,4 };
 
    list1.sort();
    list2.sort();
    std::cout &lt;&lt; "list1:  " &lt;&lt; list1 &lt;&lt; "\n";
    std::cout &lt;&lt; "list2:  " &lt;&lt; list2 &lt;&lt; "\n";
    list1.merge(list2);
    std::cout &lt;&lt; "merged: " &lt;&lt; list1 &lt;&lt; "\n";
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">list1:   0 1 3 5 9
list2:   2 4 6 7 8
merged:  0 1 2 3 4 5 6 7 8 9</pre></div> </div> <h3 id="See_also">See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="splice" title="cpp/container/list/splice"> <span class="t-lines"><span>splice</span></span></a></div> </td> <td> moves elements from another <code>list</code> <br> <span class="t-mark">(public member function)</span> </td>
</tr> </table>          <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/container/list/merge" class="_attribution-link">http://en.cppreference.com/w/cpp/container/list/merge</a>
  </p>
</div>
