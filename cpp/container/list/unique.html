    <h1 id="firstHeading" class="firstHeading">std::list&lt;T,Allocator&gt;::unique</h1>             <table class="t-dcl-begin">  <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx98 t-until-cxx20"> <td> <pre data-language="cpp">void unique();</pre>
</td>  <td> <span class="t-mark-rev t-until-cxx20">(until C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">size_type unique();</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>   <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx98 t-until-cxx20"> <td> <pre data-language="cpp">template&lt; class BinaryPredicate &gt;
void unique( BinaryPredicate p );</pre>
</td>  <td> <span class="t-mark-rev t-until-cxx20">(until C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt; class BinaryPredicate &gt;
size_type unique( BinaryPredicate p );</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>   </table> <p>Removes all <i>consecutive</i> duplicate elements from the container. Only the first element in each group of equal elements is left. The behavior is undefined if the selected comparator does not establish an equivalence relation.</p>
<div class="t-li1">
<span class="t-li">1)</span> Uses <code>operator==</code> to compare the elements.</div> <div class="t-li1">
<span class="t-li">2)</span> Uses the given binary predicate <code>p</code> to compare the elements.</div>  <h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> p </td> <td> - </td> <td> binary predicate which returns ​<code>true</code> if the elements should be treated as equal. <br> <p>The signature of the predicate function should be equivalent to the following:</p>
<p><span class="t-cc"><code> bool pred(const Type1 &amp;a, const Type2 &amp;b);</code></span></p>
<p>While the signature does not need to have <code>const &amp;</code>, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) <code>Type1</code> and <code>Type2</code> regardless of <a href="../../language/value_category" title="cpp/language/value category">value category</a> (thus, <code>Type1 &amp;</code> is not allowed<span class="t-rev-inl t-since-cxx11"><span>, nor is <code>Type1</code> unless for <code>Type1</code> a move is equivalent to a copy</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>).<br> The types <code>Type1</code> and <code>Type2</code> must be such that an object of type <code>list&lt;T,Allocator&gt;::const_iterator</code> can be dereferenced and then implicitly converted to both of them. ​</p>
</td>
</tr>
</table> <h3 id="Return_value"> Return value</h3> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p>(none).</p>
</td> <td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p>The number of elements removed.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <h3 id="Complexity"> Complexity</h3> <p>Exactly <code>size() - 1</code> comparisons of the elements, if the container is not empty. Otherwise, no comparison is performed.</p>
<h3 id="Notes"> Notes</h3> <p><a href="../../feature_test#Library_features" title="cpp/feature test">Feature testing</a> macro: <a href="../../utility/feature_test" title="cpp/utility/feature test"><code>__cpp_lib_list_remove_return_type</code></a>.</p>
<h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;list&gt;
 
auto print = [](auto remark, auto const&amp; container) {
  std::cout &lt;&lt; remark;
  for (auto const&amp; val : container)
    std::cout &lt;&lt; ' ' &lt;&lt; val;
  std::cout &lt;&lt; '\n';
};
 
int main()
{
  std::list&lt;int&gt; c = {1, 2, 2, 3, 3, 2, 1, 1, 2};
  print("Before unique():", c);
  const auto count1 = c.unique();
  print("After unique(): ", c);
  std::cout &lt;&lt; count1 &lt;&lt; " elements were removed\n";
 
  c = {1, 2, 12, 23, 3, 2, 51, 1, 2, 2};
  print("Before unique(pred):", c);
  const auto count2 = c.unique([mod=10](int x, int y) {
      return (x % mod) == (y % mod);
  });
  print("After unique(pred): ", c);
  std::cout &lt;&lt; count2 &lt;&lt; " elements were removed\n";
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">Before unique(): 1 2 2 3 3 2 1 1 2
After unique():  1 2 3 2 1 2
3 elements were removed
Before unique(pred): 1 2 12 23 3 2 51 1 2 2
After unique(pred):  1 2 23 2 51 2
4 elements were removed</pre></div> </div> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../../algorithm/unique" title="cpp/algorithm/unique"> <span class="t-lines"><span>unique</span></span></a></div> </td> <td> removes consecutive duplicate elements in a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/container/list/unique" class="_attribution-link">https://en.cppreference.com/w/cpp/container/list/unique</a>
  </p>
</div>
