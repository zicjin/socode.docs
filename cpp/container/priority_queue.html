    <h1 id="firstHeading" class="firstHeading">std::priority_queue</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/queue" title="cpp/header/queue">&lt;queue&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">template&lt;
    class T,
    class Container = std::vector&lt;T&gt;,
    class Compare = std::less&lt;typename Container::value_type&gt;
&gt; class priority_queue;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>A priority queue is a container adaptor that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction.</p>
<p>A user-provided <code>Compare</code> can be supplied to change the ordering, e.g. using <code><a href="http://en.cppreference.com/w/cpp/utility/functional/greater"><span class="kw1042">std::<span class="me2">greater</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span></code> would cause the smallest element to appear as the <code><a href="priority_queue/top" title="cpp/container/priority queue/top">top()</a></code>.</p>
<p>Working with a <code>priority_queue</code> is similar to managing a <a href="../algorithm/make_heap" title="cpp/algorithm/make heap"> heap</a> in some random access container, with the benefit of not being able to accidentally invalidate the heap.</p>
<h3 id="Template_parameters"> Template parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> T </td> <td> - </td> <td> The type of the stored elements. <span class="t-rev-inl t-since-cxx17"><span>The behavior is undefined if <code>T</code> is not the same type as <code>Container::value_type</code>.</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> </td>
</tr> <tr class="t-par"> <td> Container </td> <td> - </td> <td> The type of the underlying container to use to store the elements. The container must satisfy the requirements of <a href="../named_req/sequencecontainer" title="cpp/named req/SequenceContainer">SequenceContainer</a>, and its iterators must satisfy the requirements of <a href="../named_req/randomaccessiterator" title="cpp/named req/RandomAccessIterator">LegacyRandomAccessIterator</a>. Additionally, it must provide the following functions with the usual semantics: <ul>
<li> <code>front()</code> </li>
<li> <code>push_back()</code> </li>
<li> <code>pop_back()</code> </li>
</ul> <p>The standard containers <code><a href="vector" title="cpp/container/vector">std::vector</a></code> and <code><a href="deque" title="cpp/container/deque">std::deque</a></code> satisfy these requirements.</p>
</td>
</tr> <tr class="t-par"> <td> Compare </td> <td> - </td> <td> A <a href="../named_req/compare" title="cpp/named req/Compare">Compare</a> type providing a strict weak ordering. <p>Note that the <a href="../named_req/compare" title="cpp/named req/Compare">Compare</a> parameter is defined such that it returns <code>true</code> if its first argument comes <i>before</i> its second argument in a weak ordering. But because the priority queue outputs largest elements first, the elements that "come before" are actually output last. That is, the front of the queue contains the "last" element according to the weak ordering imposed by <a href="../named_req/compare" title="cpp/named req/Compare">Compare</a>.</p>
</td>
</tr>
</table> <h3 id="Member_types"> Member types</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Member type </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> <code>container_type</code> </td> <td> <code>Container</code>  </td>
</tr> <tr class="t-dsc"> <td> <code>value_compare</code> </td> <td> <code>Compare</code> </td>
</tr> <tr class="t-dsc"> <td> <code>value_type</code> </td> <td> <code>Container::value_type</code>  </td>
</tr> <tr class="t-dsc"> <td> <code>size_type</code> </td> <td> <code>Container::size_type</code>  </td>
</tr> <tr class="t-dsc"> <td> <code>reference</code> </td> <td> <code>Container::reference</code>  </td>
</tr> <tr class="t-dsc"> <td> <code>const_reference</code> </td> <td> <code>Container::const_reference</code>  </td>
</tr> </table> <h3 id="Member_functions"> Member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="priority_queue/priority_queue" title="cpp/container/priority queue/priority queue"> <span class="t-lines"><span>(constructor)</span></span></a></div> </td> <td> constructs the <code>priority_queue</code> <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="priority_queue/~priority_queue" title="cpp/container/priority queue/~priority queue"> <span class="t-lines"><span>(destructor)</span></span></a></div> </td> <td> destructs the <code>priority_queue</code> <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="priority_queue/operator=" title="cpp/container/priority queue/operator="> <span class="t-lines"><span>operator=</span></span></a></div> </td> <td> assigns values to the container adaptor <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Element_access">  Element access </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="priority_queue/top" title="cpp/container/priority queue/top"> <span class="t-lines"><span>top</span></span></a></div> </td> <td> accesses the top element <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Capacity">  Capacity </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="priority_queue/empty" title="cpp/container/priority queue/empty"> <span class="t-lines"><span>empty</span></span></a></div> </td> <td> checks whether the underlying container is empty <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="priority_queue/size" title="cpp/container/priority queue/size"> <span class="t-lines"><span>size</span></span></a></div> </td> <td> returns the number of elements <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Modifiers">  Modifiers </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="priority_queue/push" title="cpp/container/priority queue/push"> <span class="t-lines"><span>push</span></span></a></div> </td> <td> inserts element and sorts the underlying container <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="priority_queue/emplace" title="cpp/container/priority queue/emplace"> <span class="t-lines"><span>emplace</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> constructs element in-place and sorts the underlying container <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="priority_queue/pop" title="cpp/container/priority queue/pop"> <span class="t-lines"><span>pop</span></span></a></div> </td> <td> removes the top element <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="priority_queue/swap" title="cpp/container/priority queue/swap"> <span class="t-lines"><span>swap</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> swaps the contents <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Member_objects">  Member objects</h3> </td>
</tr> <tr class="t-dsc"> <td> <div><span class="t-lines"><span><span class="t-dsc-small">Container</span> c</span></span></div> </td> <td> the underlying container <br> <span class="t-mark">(protected member object)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><span class="t-lines"><span><span class="t-dsc-small">Compare</span> comp</span></span></div> </td> <td> the comparison function object <br> <span class="t-mark">(protected member object)</span> </td>
</tr> </table> <h3 id="Non-member_functions"> Non-member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="priority_queue/swap2" title="cpp/container/priority queue/swap2"> <span class="t-lines"><span>std::swap<span class="t-dsc-small">(std::priority_queue)</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> specializes the <code><a href="../algorithm/swap" title="cpp/algorithm/swap">std::swap</a></code> algorithm <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table> <h3 id="Helper_classes"> Helper classes</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="priority_queue/uses_allocator" title="cpp/container/priority queue/uses allocator"> <span class="t-lines"><span>std::uses_allocator<span class="t-dsc-small">&lt;std::priority_queue&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> specializes the <code><a href="../memory/uses_allocator" title="cpp/memory/uses allocator">std::uses_allocator</a></code> type trait <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> </table> <h3 id="Deduction_guides_.28since_C.2B.2B17.29"> <a href="priority_queue/deduction_guides" title="cpp/container/priority queue/deduction guides">Deduction guides</a> <span class="t-mark-rev t-since-cxx17">(since C++17)</span>
</h3> <h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;functional&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
 
template&lt;typename T&gt;
void print_queue(T q) { // NB: pass by value so the print uses a copy
    while(!q.empty()) {
        std::cout &lt;&lt; q.top() &lt;&lt; ' ';
        q.pop();
    }
    std::cout &lt;&lt; '\n';
}
 
int main() {
    std::priority_queue&lt;int&gt; q;
 
    const auto data = {1,8,5,6,3,4,0,9,7,2};
 
    for(int n : data)
        q.push(n);
 
    print_queue(q);
 
    std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt;
        q2(data.begin(), data.end());
 
    print_queue(q2);
 
    // Using lambda to compare elements.
    auto cmp = [](int left, int right) { return (left ^ 1) &lt; (right ^ 1); };
    std::priority_queue&lt;int, std::vector&lt;int&gt;, decltype(cmp)&gt; q3(cmp);
 
    for(int n : data)
        q3.push(n);
 
    print_queue(q3);
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">9 8 7 6 5 4 3 2 1 0 
0 1 2 3 4 5 6 7 8 9 
8 9 6 7 4 5 2 3 0 1</pre></div> </div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2684">LWG 2684</a> </td> <td> C++98 </td> <td> <code>priority_queue</code> takes a comparator but lacked member typedef for it </td> <td> added </td>
</tr>
</table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/container/priority_queue" class="_attribution-link">https://en.cppreference.com/w/cpp/container/priority_queue</a>
  </p>
</div>
