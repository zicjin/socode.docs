   <h1 id="firstHeading" class="firstHeading">std::unordered_map&lt;Key,T,Hash,KeyEqual,Allocator&gt;::equal_range</h1>             <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">std::pair&lt;iterator,iterator&gt; equal_range( const Key&amp; key );</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">std::pair&lt;iterator,iterator&gt; equal_range( const Key&amp; key, std::size_t hash );</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">std::pair&lt;const_iterator,const_iterator&gt; equal_range( const Key&amp; key ) const;</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">std::pair&lt;const_iterator,const_iterator&gt; equal_range( const Key&amp; key,
                                                      std::size_t hash ) const;</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt; class K &gt;
std::pair&lt;iterator,iterator&gt; equal_range( const K&amp; x );</pre>
</td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt; class K &gt;
std::pair&lt;iterator,iterator&gt; equal_range( const K&amp; x, std::size_t hash );</pre>
</td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt; class K &gt;
std::pair&lt;const_iterator,const_iterator&gt; equal_range( const K&amp; x ) const;</pre>
</td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt; class K &gt;
std::pair&lt;const_iterator,const_iterator&gt; equal_range( const K&amp; x, 
                                                      std::size_t hash ) const;</pre>
</td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>  </table> <div class="t-li1">
<span class="t-li">1,2)</span> Returns a range containing all elements with key <code>key</code> in the container. The range is defined by two iterators, the first pointing to the first element of the wanted range and the second pointing past the last element of the range.</div> <div class="t-li1">
<span class="t-li">3,4)</span> Returns a range containing all elements in the container with key equivalent to <code>x</code>. This overload only participates in overload resolution if the qualified-id <code>Hash::transparent_key_equal</code> is valid and denotes a type. This assumes that such Hash is callable with both K and Key type, and that its key_equal is transparent, which, together, allows calling this function without constructing an instance of <code>Key</code>.</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>If present, the <code>hash</code> parameter may be used to pass a pre-computed hash value as an optimization. The behavior is undefined if invoking <code><a href="hash_function" title="cpp/container/unordered map/hash function">hash_function()</a></code> on the key passed do not produce the same value as <code>hash</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <h3 id="Parameters">Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> key </td> <td> - </td> <td> key value to compare the elements to </td>
</tr> <tr class="t-par"> <td> x </td> <td> - </td> <td> a value of any type that can be transparently compared with a key </td>
</tr> <tr class="t-par"> <td> hash </td> <td> - </td> <td> the hash value of the key </td>
</tr>
</table> <h3 id="Return_value">Return value</h3> <p><code><a href="../../utility/pair" title="cpp/utility/pair">std::pair</a></code> containing a pair of iterators defining the wanted range. If there are no such elements, past-the-end (see <code><a href="end" title="cpp/container/unordered map/end">end()</a></code>) iterators are returned as both elements of the pair.</p>
<h3 id="Complexity">Complexity</h3> <p>Average case linear in the number of elements with the key <code>key</code>, worst case linear in the size of the container.</p>
<h3 id="Example">Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
 
int main()
{  
    std::unordered_map&lt;int,char&gt; map = {{1,'a'},{1,'b'},{1,'d'},{2,'b'}};
    auto range = map.equal_range(1);
    for (auto it = range.first; it != range.second; ++it) {
        std::cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; it-&gt;second &lt;&lt; '\n';
    }
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">1 a</pre></div> </div> <h3 id="See_also">See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="find" title="cpp/container/unordered map/find"> <span class="t-lines"><span>find</span></span></a></div> </td> <td> finds element with specific key <br> <span class="t-mark">(public member function)</span> </td>
</tr> </table>          <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/container/unordered_map/equal_range" class="_attribution-link">http://en.cppreference.com/w/cpp/container/unordered_map/equal_range</a>
  </p>
</div>
