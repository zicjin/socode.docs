    <h1 id="firstHeading" class="firstHeading">std::unordered_map&lt;Key,T,Hash,KeyEqual,Allocator&gt;::try_emplace</h1>             <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">template&lt; class... Args &gt;
pair&lt;iterator, bool&gt; try_emplace( const Key&amp; k, Args&amp;&amp;... args );</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">template&lt; class... Args &gt;
pair&lt;iterator, bool&gt; try_emplace( Key&amp;&amp; k, Args&amp;&amp;... args );</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">template&lt; class... Args &gt;
iterator try_emplace( const_iterator hint, const Key&amp; k, Args&amp;&amp;... args );</pre>
</td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">template&lt; class... Args &gt;
iterator try_emplace( const_iterator hint, Key&amp;&amp; k, Args&amp;&amp;... args );</pre>
</td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  </table> <p>Inserts a new element into the container with key <code>k</code> and value constructed with <code>args</code>, if there is no element with the key in the container.</p>
<div class="t-li1">
<span class="t-li">1)</span> If a key equivalent to <code>k</code> already exists in the container, does nothing. Otherwise, behaves like <a href="emplace" title="cpp/container/unordered map/emplace"><code>emplace</code></a> except that the element is constructed as<br><code>value_type<span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/utility/piecewise_construct"><span class="kw1109">std::<span class="me2">piecewise_construct</span></span></a>,<br> <p><a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">std::<span class="me2">forward_as_tuple</span></span></a><span class="br0">(</span>k<span class="br0">)</span>,<br>  <a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">std::<span class="me2">forward_as_tuple</span></span></a>.</p>
<span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...<span class="br0">)</span><span class="br0">)</span></code>
</div> <div class="t-li1">
<span class="t-li">2)</span> If a key equivalent to <code>k</code> already exists in the container, does nothing. Otherwise, behaves like <a href="emplace" title="cpp/container/unordered map/emplace"><code>emplace</code></a> except that the element is constructed as<br><code>value_type<span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/utility/piecewise_construct"><span class="kw1109">std::<span class="me2">piecewise_construct</span></span></a>,<br> <p><a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">std::<span class="me2">forward_as_tuple</span></span></a><span class="br0">(</span>std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>k<span class="br0">)</span><span class="br0">)</span>,<br>  <a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">std::<span class="me2">forward_as_tuple</span></span></a>.</p>
<span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...<span class="br0">)</span><span class="br0">)</span></code>
</div> <div class="t-li1">
<span class="t-li">3)</span> If a key equivalent to <code>k</code> already exists in the container, does nothing. Otherwise, behaves like <a href="emplace_hint" title="cpp/container/unordered map/emplace hint"><code>emplace_hint</code></a> except that the element is constructed as<br><code>value_type<span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/utility/piecewise_construct"><span class="kw1109">std::<span class="me2">piecewise_construct</span></span></a>,<br> <p><a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">std::<span class="me2">forward_as_tuple</span></span></a><span class="br0">(</span>k<span class="br0">)</span>,<br>  <a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">std::<span class="me2">forward_as_tuple</span></span></a>.</p>
<span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...<span class="br0">)</span><span class="br0">)</span></code>
</div> <div class="t-li1">
<span class="t-li">4)</span> If a key equivalent to <code>k</code> already exists in the container, does nothing. Otherwise, behaves like <a href="emplace_hint" title="cpp/container/unordered map/emplace hint"><code>emplace_hint</code></a> except that the element is constructed as<br><code>value_type<span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/utility/piecewise_construct"><span class="kw1109">std::<span class="me2">piecewise_construct</span></span></a>,<br> <p><a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">std::<span class="me2">forward_as_tuple</span></span></a><span class="br0">(</span>std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>k<span class="br0">)</span><span class="br0">)</span>,<br>  <a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple"><span class="kw1117">std::<span class="me2">forward_as_tuple</span></span></a>.</p>
<span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...<span class="br0">)</span><span class="br0">)</span></code>
</div> <p>If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than <code>max_load_factor()*bucket_count()</code>.</p>
<h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> k </td> <td> - </td> <td> the key used both to look up and to insert if not found </td>
</tr> <tr class="t-par"> <td> hint </td> <td> - </td> <td> iterator to the position before which the new element will be inserted </td>
</tr> <tr class="t-par"> <td> args </td> <td> - </td> <td> arguments to forward to the constructor of the element </td>
</tr>
</table> <h3 id="Return_value"> Return value</h3> <div class="t-li1">
<span class="t-li">1,2)</span> Same as for <a href="emplace" title="cpp/container/unordered map/emplace"><code>emplace</code></a>
</div> <div class="t-li1">
<span class="t-li">3,4)</span> Same as for <a href="emplace_hint" title="cpp/container/unordered map/emplace hint"><code>emplace_hint</code></a>
</div> <h3 id="Complexity"> Complexity</h3> <div class="t-li1">
<span class="t-li">1,2)</span> Same as for <a href="emplace" title="cpp/container/unordered map/emplace"><code>emplace</code></a>
</div> <div class="t-li1">
<span class="t-li">3,4)</span> Same as for <a href="emplace_hint" title="cpp/container/unordered map/emplace hint"><code>emplace_hint</code></a>
</div> <h3 id="Notes"> Notes</h3> <p>Unlike <a href="insert" title="cpp/container/unordered map/insert"><code>insert</code></a> or <a href="emplace" title="cpp/container/unordered map/emplace"><code>emplace</code></a>, these functions do not move from rvalue arguments if the insertion does not happen, which makes it easy to manipulate maps whose values are move-only types, such as <code><a href="http://en.cppreference.com/w/cpp/container/unordered_map"><span class="kw1296">std::<span class="me2">unordered_map</span></span></a><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/string/basic_string"><span class="kw1233">std::<span class="me2">string</span></span></a>, <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr"><span class="kw734">std::<span class="me2">unique_ptr</span></span></a><span class="sy1">&lt;</span>foo<span class="sy1">&gt;&gt;</span></code>. In addition, <code>try_emplace</code> treats the key and the arguments to the <code>mapped_type</code> separately, unlike <a href="emplace" title="cpp/container/unordered map/emplace"><code>emplace</code></a>, which requires the arguments to construct a <code>value_type</code> (that is, a <code><a href="../../utility/pair" title="cpp/utility/pair">std::pair</a></code>).</p>
<p><a href="../../feature_test#Library_features" title="cpp/feature test">Feature testing</a> macro: <a href="../../utility/feature_test" title="cpp/utility/feature test"><code>__cpp_lib_unordered_map_try_emplace</code></a>.</p>
<h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;string&gt;
 
#include &lt;unordered_map&gt;
 
auto print_node = [](const auto &amp;node) {
    std::cout &lt;&lt; "[" &lt;&lt; node.first &lt;&lt; "] = " &lt;&lt; node.second &lt;&lt; '\n';
};
 
auto print_result = [](auto const &amp;pair) {
    std::cout &lt;&lt; (pair.second ? "inserted: " : "ignored:  ");
    print_node(*pair.first);
};
 
int main()
{
    using namespace std::literals;
    std::unordered_map&lt;std::string, std::string&gt; m;
 
    print_result( m.try_emplace("a", "a"s) );
    print_result( m.try_emplace("b", "abcd") );
    print_result( m.try_emplace("c", 10, 'c') );
    print_result( m.try_emplace("c", "Won't be inserted") );
 
    for (const auto &amp;p : m) { print_node(p); }
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">inserted: [a] = a
inserted: [b] = abcd
inserted: [c] = cccccccccc
ignored:  [c] = cccccccccc
[a] = a
[b] = abcd
[c] = cccccccccc</pre></div> </div> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="emplace" title="cpp/container/unordered map/emplace"> <span class="t-lines"><span>emplace</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> constructs element in-place <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="emplace_hint" title="cpp/container/unordered map/emplace hint"> <span class="t-lines"><span>emplace_hint</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> constructs elements in-place using a hint <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="insert" title="cpp/container/unordered map/insert"> <span class="t-lines"><span>insert</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> inserts elements <span class="t-rev-inl t-since-cxx17"><span>or nodes</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> <br> <span class="t-mark">(public member function)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/container/unordered_map/try_emplace" class="_attribution-link">https://en.cppreference.com/w/cpp/container/unordered_map/try_emplace</a>
  </p>
</div>
