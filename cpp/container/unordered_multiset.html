   <h1 id="firstHeading" class="firstHeading">std::unordered_multiset</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/unordered_set" title="cpp/header/unordered set">&lt;unordered_set&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt;
    class Key,
    class Hash = std::hash&lt;Key&gt;,
    class KeyEqual = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt;
&gt; class unordered_multiset;</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">namespace pmr {
    template &lt;class Key,
              class Hash = std::hash&lt;Key&gt;,
              class Pred = std::equal_to&lt;Key&gt;&gt;
    using unordered_multiset = std::unordered_multiset&lt;Key, Hash, Pred,
                                   std::pmr::polymorphic_allocator&lt;Key&gt;&gt;
}</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  </table> <p>Unordered multiset is an associative container that contains set of possibly non-unique objects of type Key. Search, insertion, and removal have average constant-time complexity.</p>
<p>Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its value. This allows fast access to individual elements, since once hash is computed, it refers to the exact bucket the element is placed into.</p>
<p>The iteration order of this container is not required to be stable (so, for example, <code><a href="../algorithm/equal" title="cpp/algorithm/equal">std::equal</a></code> cannot be used to compare two <code>std::unordered_multiset</code>s), except that every group of elements whose keys compare <i>equivalent</i> (compare equal with <code><a href="unordered_multiset/key_eq" title="cpp/container/unordered multiset/key eq">key_eq()</a></code> as the comparator) forms a contiguous subrange in the iteration order, also accessible with <code><a href="unordered_multiset/equal_range" title="cpp/container/unordered multiset/equal range">equal_range()</a></code>.</p>
<p><code>std::unordered_multiset</code> meets the requirements of <a href="../named_req/container" title="cpp/named req/Container">Container</a>, <a href="../named_req/allocatorawarecontainer" title="cpp/named req/AllocatorAwareContainer">AllocatorAwareContainer</a>, <a href="../named_req/unorderedassociativecontainer" title="cpp/named req/UnorderedAssociativeContainer">UnorderedAssociativeContainer</a>.</p>
<h3 id="Member_types">Member types</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Member type </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> <code>key_type</code> </td> <td> <code>Key</code> </td>
</tr> <tr class="t-dsc"> <td> <code>value_type</code> </td> <td> <code>Key</code> </td>
</tr> <tr class="t-dsc"> <td> <code>size_type</code> </td> <td> Unsigned integer type (usually <code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code>) </td>
</tr> <tr class="t-dsc"> <td> <code>difference_type</code> </td> <td> Signed integer type (usually <code><a href="../types/ptrdiff_t" title="cpp/types/ptrdiff t">std::ptrdiff_t</a></code>) </td>
</tr> <tr class="t-dsc"> <td> <code>hasher</code> </td> <td> <code>Hash</code> </td>
</tr> <tr class="t-dsc"> <td> <code>key_equal</code> </td> <td> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td><code>KeyEqual</code></td> <td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td>
<code>Hash::transparent_key_equal</code> if defined and names a type, otherwise <code>KeyEqual</code>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> </td>
</tr> <tr class="t-dsc"> <td> <code>allocator_type</code> </td> <td> <code>Allocator</code> </td>
</tr> <tr class="t-dsc"> <td> <code>reference</code> </td> <td> <code>value_type&amp;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>const_reference</code> </td> <td> <code>const value_type&amp;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>pointer</code> </td> <td> <code><a href="../memory/allocator_traits"><span class="kw696">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>Allocator<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">pointer</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>const_pointer</code> </td> <td> <code><a href="../memory/allocator_traits"><span class="kw696">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>Allocator<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_pointer</span></code> </td>
</tr> <tr class="t-dsc"> <td> <code>iterator</code> </td> <td> Constant <a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a> </td>
</tr> <tr class="t-dsc"> <td> <code>const_iterator</code> </td> <td> Constant <a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a> </td>
</tr> <tr class="t-dsc"> <td> <code>local_iterator</code> </td> <td> An iterator type whose category, value, difference, pointer and<br> reference types are the same as <code>iterator</code>. This iterator<br> can be used to iterate through a single bucket but not across buckets</td>
</tr> <tr class="t-dsc"> <td> <code>const_local_iterator</code> </td> <td> An iterator type whose category, value, difference, pointer and<br> reference types are the same as <code>const_iterator</code>. This iterator<br> can be used to iterate through a single bucket but not across buckets</td>
</tr> <tr class="t-dsc"> <td> <code>node_type</code><span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> <td> a specialization of <a href="node_handle" title="cpp/container/node handle">node handle</a> representing a container node </td>
</tr> </table> <h3 id="Member_functions">Member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/unordered_multiset" title="cpp/container/unordered multiset/unordered multiset"> <span class="t-lines"><span>(constructor)</span></span></a></div> </td> <td> constructs the <code>unordered_multiset</code> <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/~unordered_multiset" title="cpp/container/unordered multiset/~unordered multiset"> <span class="t-lines"><span>(destructor)</span></span></a></div> </td> <td> destructs the <code>unordered_multiset</code> <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/operator=" title="cpp/container/unordered multiset/operator="> <span class="t-lines"><span>operator=</span></span></a></div> </td> <td> assigns values to the container <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/get_allocator" title="cpp/container/unordered multiset/get allocator"> <span class="t-lines"><span>get_allocator</span></span></a></div> </td> <td> returns the associated allocator <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Iterators">  Iterators </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/begin" title="cpp/container/unordered multiset/begin"> <span class="t-lines"><span>begin</span><span> cbegin</span></span></a></div>
 </td> <td> returns an iterator to the beginning <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/end" title="cpp/container/unordered multiset/end"> <span class="t-lines"><span>end </span><span>cend</span></span></a></div>
 </td> <td> returns an iterator to the end <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Capacity">  Capacity </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/empty" title="cpp/container/unordered multiset/empty"> <span class="t-lines"><span>empty</span></span></a></div> </td> <td> checks whether the container is empty <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/size" title="cpp/container/unordered multiset/size"> <span class="t-lines"><span>size</span></span></a></div> </td> <td> returns the number of elements <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/max_size" title="cpp/container/unordered multiset/max size"> <span class="t-lines"><span>max_size</span></span></a></div> </td> <td> returns the maximum possible number of elements <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Modifiers">  Modifiers </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/clear" title="cpp/container/unordered multiset/clear"> <span class="t-lines"><span>clear</span></span></a></div> </td> <td> clears the contents <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/insert" title="cpp/container/unordered multiset/insert"> <span class="t-lines"><span>insert</span></span></a></div> </td> <td> inserts elements <span class="t-rev-inl t-since-cxx17"><span>or nodes</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/emplace" title="cpp/container/unordered multiset/emplace"> <span class="t-lines"><span>emplace</span></span></a></div> </td> <td> constructs element in-place <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/emplace_hint" title="cpp/container/unordered multiset/emplace hint"> <span class="t-lines"><span>emplace_hint</span></span></a></div> </td> <td> constructs elements in-place using a hint <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/erase" title="cpp/container/unordered multiset/erase"> <span class="t-lines"><span>erase</span></span></a></div> </td> <td> erases elements <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/swap" title="cpp/container/unordered multiset/swap"> <span class="t-lines"><span>swap</span></span></a></div> </td> <td> swaps the contents <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/extract" title="cpp/container/unordered multiset/extract"> <span class="t-lines"><span>extract</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> extracts nodes from the container <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/merge" title="cpp/container/unordered multiset/merge"> <span class="t-lines"><span>merge</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> splices nodes from another container <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Lookup">  Lookup </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/count" title="cpp/container/unordered multiset/count"> <span class="t-lines"><span>count</span></span></a></div> </td> <td> returns the number of elements matching specific key <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/find" title="cpp/container/unordered multiset/find"> <span class="t-lines"><span>find</span></span></a></div> </td> <td> finds element with specific key <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/contains" title="cpp/container/unordered multiset/contains"> <span class="t-lines"><span>contains</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> checks if the container contains element with specific key <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/equal_range" title="cpp/container/unordered multiset/equal range"> <span class="t-lines"><span>equal_range</span></span></a></div> </td> <td> returns range of elements matching a specific key <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Bucket_interface">  Bucket interface </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/begin2" title="cpp/container/unordered multiset/begin2"> <span class="t-lines"><span>begin<span class="t-dsc-small">(size_type)</span></span><span> cbegin<span class="t-dsc-small">(size_type)</span></span></span></a></div> </td> <td> returns an iterator to the beginning of the specified bucket <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/end2" title="cpp/container/unordered multiset/end2"> <span class="t-lines"><span>end<span class="t-dsc-small">(size_type)</span></span><span> cend<span class="t-dsc-small">(size_type)</span></span></span></a></div> </td> <td> returns an iterator to the end of the specified bucket <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/bucket_count" title="cpp/container/unordered multiset/bucket count"> <span class="t-lines"><span>bucket_count</span></span></a></div> </td> <td> returns the number of buckets <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/max_bucket_count" title="cpp/container/unordered multiset/max bucket count"> <span class="t-lines"><span>max_bucket_count</span></span></a></div> </td> <td> returns the maximum number of buckets <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/bucket_size" title="cpp/container/unordered multiset/bucket size"> <span class="t-lines"><span>bucket_size</span></span></a></div> </td> <td> returns the number of elements in specific bucket <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/bucket" title="cpp/container/unordered multiset/bucket"> <span class="t-lines"><span>bucket</span></span></a></div> </td> <td> returns the bucket for specific key <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Hash_policy">  Hash policy </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/load_factor" title="cpp/container/unordered multiset/load factor"> <span class="t-lines"><span>load_factor</span></span></a></div> </td> <td> returns average number of elements per bucket <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/max_load_factor" title="cpp/container/unordered multiset/max load factor"> <span class="t-lines"><span>max_load_factor</span></span></a></div> </td> <td> manages maximum average number of elements per bucket <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/rehash" title="cpp/container/unordered multiset/rehash"> <span class="t-lines"><span>rehash</span></span></a></div> </td> <td> reserves at least the specified number of buckets.<br>This regenerates the hash table. <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/reserve" title="cpp/container/unordered multiset/reserve"> <span class="t-lines"><span>reserve</span></span></a></div> </td> <td> reserves space for at least the specified number of elements.<br>This regenerates the hash table. <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr> <td colspan="2"> <h5 id="Observers">  Observers </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/hash_function" title="cpp/container/unordered multiset/hash function"> <span class="t-lines"><span>hash_function</span></span></a></div> </td> <td> returns function used to hash the keys <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/key_eq" title="cpp/container/unordered multiset/key eq"> <span class="t-lines"><span>key_eq</span></span></a></div> </td> <td> returns the function used to compare keys for equality <br> <span class="t-mark">(public member function)</span> </td>
</tr> </table> <h3 id="Non-member_functions">Non-member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/operator_cmp" title="cpp/container/unordered multiset/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> compares the values in the unordered_multiset <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/swap2" title="cpp/container/unordered multiset/swap2"> <span class="t-lines"><span>std::swap<span class="t-dsc-small">(std::unordered_multiset)</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> specializes the <code><a href="../algorithm/swap" title="cpp/algorithm/swap">std::swap</a></code> algorithm <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unordered_multiset/erase_if" title="cpp/container/unordered multiset/erase if"> <span class="t-lines"><span>erase_if<span class="t-dsc-small">(std::unordered_multiset)</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> Erases all elements satisfying specific criteria <br> <span class="t-mark">(function template)</span> </td>
</tr> </table> <h3 id="Deduction_guides.28since_C.2B.2B17.29">
<a href="unordered_multiset/deduction_guides" title="cpp/container/unordered multiset/deduction guides">Deduction guides</a><span class="t-mark-rev t-since-cxx17">(since C++17)</span>
</h3> <h3 id="Notes">Notes</h3> <p>The member types <code>iterator</code> and <code>const_iterator</code> may be aliases to the same type. Since <code>iterator</code> is convertible to <code>const_iterator</code>, <code>const_iterator</code> should be used in function parameter lists to avoid violations of the One Definition Rule.</p>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/container/unordered_multiset" class="_attribution-link">http://en.cppreference.com/w/cpp/container/unordered_multiset</a>
  </p>
</div>
