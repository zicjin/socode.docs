   <h1 id="firstHeading" class="firstHeading">Template parameters and template arguments</h1>            <p>Every <a href="templates" title="cpp/language/templates">template</a> is parametrized by one or more template parameters, indicated in the <span class="t-spar">parameter-list</span> of the template declaration syntax:</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>template</code> <code>&lt;</code> <span class="t-spar">parameter-list</span> <code>&gt;</code> <span class="t-spar">declaration</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>Each parameter in <span class="t-spar">parameter-list</span> may be:</p>
<ul>
<li> a non-type template parameter; </li>
<li> a type template parameter; </li>
<li> a template template parameter. </li>
</ul> <h4 id="Non-type_template_parameter">Non-type template parameter</h4> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">type</span> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">type</span> <span class="t-spar">name</span><span class="t-mark">(optional)</span> <code>= </code> <span class="t-spar">default</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">type</span> <code>...</code> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">placeholder</span> <span class="t-spar">name</span> </td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> A non-type template parameter with an optional name.</div> <div class="t-li1">
<span class="t-li">2)</span> A non-type template parameter with an optional name and a default value.</div> <div class="t-li1">
<span class="t-li">3)</span> A non-type template <a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a> with an optional name.</div> <div class="t-li1">
<span class="t-li">4)</span> A non-type template parameter with a placeholder type. <span class="t-spar">placeholder</span> may be any type that includes the placeholder <a href="auto" title="cpp/language/auto"><code>auto</code></a> (such as plain <code>auto</code>, <code>auto **</code> or <code>auto &amp;</code>)<span class="t-rev-inl t-since-cxx20"><span>, a <a href="deduction_guide" title="cpp/language/class template argument deduction">placeholder for a deduced class type</a></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>, or <code>decltype(auto)</code>.</div> <p><span class="t-spar">type</span> is one of the following types (optionally cv-qualified, the qualifiers are ignored):</p>
<ul><li> <a href="reference#lvalue_references" title="cpp/language/reference">lvalue reference type</a> (to object or to function); </li></ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <ul>
<li> <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code> <span class="t-mark-rev t-since-cxx11">(since C++11)</span>; </li>
<li> an <a href="type-id" title="cpp/language/type">integral type</a>; </li>
<li> a <a href="pointer" title="cpp/language/pointer">pointer type</a> (to object or to function); </li>
<li> a <a href="pointer#Pointers_to_members" title="cpp/language/pointer">pointer to member type</a> (to member object or to member function); </li>
<li> an <a href="enum" title="cpp/language/enum">enumeration type</a>. </li>
</ul> </td> <td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <ul><li> a type that </li></ul> <dl>
<dd>
<ul>
<li> satisfies <a href="../named_req/literaltype" title="cpp/named req/LiteralType">LiteralType</a>, and </li>
<li> has <i>strong structural equality</i> (see below). </li>
</ul> </dd>
<dd>This includes <a href="type-id" title="cpp/language/type">integral types</a>, <a href="pointer" title="cpp/language/pointer">pointer types</a>, <a href="pointer#Pointers_to_members" title="cpp/language/pointer">pointer to member type</a>, <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code>, as well as enumeration types with no custom <code>operator&lt;=&gt;</code> overload, but excludes floating-point types. </dd>
</dl> <p>A type has <i>strong structural equality</i> if, for a glvalue <code>x</code> of type <code>const T</code>,</p>
<ul>
<li> if <code>T</code> is a non-class type </li>
<ul><li> <code>x &lt;=&gt; x</code> is a valid expression of type <code>std::strong_ordering</code> or <code>std::strong_equality</code>; </li></ul>
<li> if <code>T</code> is a class type </li>
<ul>
<li> <code>operator==</code> is defined as defaulted in the definition of <code>T</code>, and </li>
<li> <code>x==x</code> is well-formed when contextually converted to bool, and </li>
<li> all of <code>T</code>'s base class subobjects and non-static data members have strong structural equality, recursively, and </li>
<li> <code>T</code> has no mutable or volatile subobjects. </li>
</ul>
</ul>    </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p>Array and function types may be written in a template declaration, but they are automatically replaced by pointer to object and pointer to function as appropriate.</p>
<p>When the name of a non-type template parameter is used in an expression within the body of the class template, it is an unmodifiable <a href="value_category" title="cpp/language/value category">prvalue</a> unless its type was an lvalue reference type<span class="t-rev-inl t-since-cxx20"><span>, or unless its type is a class type</span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>.</p>
<p>A template parameter of the form <code>class Foo</code> is not an unnamed non-type template parameter of type <code>Foo</code>, even if otherwise <code>class Foo</code> is an <a href="elaborated_type_specifier" title="cpp/language/elaborated type specifier">elaborated type specifier</a> and <code>class Foo x;</code> declares <code>x</code> to be of type <code>Foo</code>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>The type of a non-type template parameter may be deduced if it includes a placeholder type (<code>auto</code><span class="t-rev-inl t-since-cxx20"><span>, a placeholder for a deduced class type</span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>, or <code>decltype(auto)</code>). The deduction is performed as if by deducing the type of the variable <code>x</code> in the invented declaration <code>T x = template-argument;</code>, where <code>T</code> is the declared type of the template parameter. If the deduced type is not permitted for a non-type template parameter, the program is ill-formed.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;auto n&gt; struct B { /* ... */ };
B&lt;5&gt; b1;   // OK: non-type template parameter type is int
B&lt;'a'&gt; b2; // OK: non-type template parameter type is char
B&lt;2.5&gt; b3; // error: non-type template parameter type cannot be double</pre></div> <p>For non-type template parameter packs whose type uses a placeholder type, the type is independently deduced for each template argument and need not match:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;auto...&gt; struct C {};
C&lt;'C', 0, 2L, nullptr&gt; x; // OK</pre></div> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>An <a href="name" title="cpp/language/identifiers">identifier</a> that names a non-type template parameter of class type <code>T</code> denotes a static storage duration object of type <code>const T</code>, called a <i>template parameter object</i>, whose value is that of the corresponding template argument after it has been converted to the type of the template parameter. All such template parameters in the program of the same type with the same value denote the same template parameter object.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct A { friend bool operator==(const A&amp;, const A&amp;) = default; };
template&lt;A a&gt; void f() {
    &amp;a; // OK
    const A&amp; ra = a, &amp;rb = a; // Both bound to the same template parameter object
    assert(&amp;ra == &amp;rb); // passes
}</pre></div> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <h4 id="Type_template_parameter">Type template parameter</h4> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">type-parameter-key</span> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">type-parameter-key</span> <span class="t-spar">name</span><span class="t-mark">(optional)</span> <code>= </code> <span class="t-spar">default</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">type-parameter-key</span> <code>...</code> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">type-constraint</span> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">type-constraint</span> <span class="t-spar">name</span><span class="t-mark">(optional)</span> <code>=</code> <span class="t-spar">default</span> </td> <td> (5) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">type-constraint</span> <code>...</code> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (6) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr> 
</table> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">type-constraint</span> </td> <td> - </td> <td> either the name of a <a href="constraints" title="cpp/language/constraints">concept</a> or the name of a concept followed by a list of template arguments (in angle brackets). Either way, the concept name may be optionally qualified </td>
</tr>
</table> <p><span class="t-spar">type-parameter-key</span> is either <code>typename</code> or <code>class</code>. There is no difference between these keywords in a type template parameter declaration.</p>
<div class="t-li1">
<span class="t-li">1)</span> A type template parameter without a default. <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt;
class My_vector { /* ... */ };</pre></div>
</div> <div class="t-li1">
<span class="t-li">2)</span> A type template parameter with a default. <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T = void&gt;
struct My_op_functor { /* ... */ };</pre></div>
</div> <div class="t-li1">
<span class="t-li">3)</span> A type template <a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a>. <div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename... Ts&gt;
class My_tuple { /* ... */ };</pre></div>
</div> <p>The name of the parameter is optional:</p>
<div class="cpp source-cpp"><pre data-language="cpp">// Declarations of the templates shown above:
template&lt;class&gt; class My_vector;
template&lt;class = void&gt; struct My_op_functor;
template&lt;typename...&gt; class My_tuple;</pre></div> <p>In the body of the template declaration, the name of a type parameter is a typedef-name which aliases the type supplied when the template is instantiated.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>Each constrained parameter <code>P</code> whose <span class="t-spar">type-constraint</span> is Q designating the concept <code>C</code> introduces a <a href="constraints" title="cpp/language/constraints">constraint-expression</a> <code>E</code> according to the following rules:</p>
<ul>
<li> if <code>Q</code> is <code>C</code> (without an argument list), </li>
<ul>
<li> if <code>P</code> is not a parameter pack, <code>E</code> is simply <code>C&lt;P&gt;</code> </li>
<li> otherwise, <code>P</code> is a parameter pack, <code>E</code> is a fold-expression <code>(C&lt;P&gt; &amp;&amp; ...)</code> </li>
</ul>
<li> if <code>Q</code> is <code>C&lt;A1,A2...,AN&gt;</code>, then <code>E</code> is <code>C&lt;P,A1,A2,...AN&gt;</code> or <code>(C&lt;P,A1,A2,...AN&gt; &amp;&amp; ...)</code>, respectively. </li>
</ul>   <div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt; concept C1 = true;
template&lt;typename... Ts&gt; concept C2 = true; // variadic concept
template&lt;typename T, typename U&gt; concept C3 = true;
 
template&lt;C1 T&gt; struct s1;         // constraint-expression is C1&lt;T&gt;
template&lt;C1... T&gt; struct s2;      // constraint-expression is (C1&lt;T&gt; &amp;&amp; ...)
template&lt;C2... T&gt; struct s3;      // constraint-expression is (C2&lt;T&gt; &amp;&amp; ...)
template&lt;C3&lt;int&gt; T&gt; struct s4;    // constraint-expression is C3&lt;T, int&gt;
template&lt;C3&lt;int&gt;... T&gt; struct s5; // constraint-expression is (C3&lt;T, int&gt; &amp;&amp; ...)</pre></div> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <h4 id="Template_template_parameter">Template template parameter</h4> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>template</code> <code>&lt;</code> <span class="t-spar">parameter-list</span> <code>&gt;</code> <code>typename<span class="t-mark-rev t-since-cxx17">(C++17)</span>|class</code> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>template</code> <code>&lt;</code> <span class="t-spar">parameter-list</span> <code>&gt;</code> <code>typename<span class="t-mark-rev t-since-cxx17">(C++17)</span>|class</code> <span class="t-spar">name</span><span class="t-mark">(optional)</span> <code>=</code> <span class="t-spar">default</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>template</code> <code>&lt;</code> <span class="t-spar">parameter-list</span> <code>&gt;</code> <code>typename<span class="t-mark-rev t-since-cxx17">(C++17)</span>|class</code> <code>...</code> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> A template template parameter with an optional name.</div> <div class="t-li1">
<span class="t-li">2)</span> A template template parameter with an optional name and a default.</div> <div class="t-li1">
<span class="t-li">3)</span> A template template <a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a> with an optional name.</div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <p>Unlike type template parameter declaration, template template parameter declaration can only use the keyword <code>class</code> and not <code>typename</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> </table> <p>In the body of the template declaration, the name of this parameter is a template-name (and needs arguments to be instantiated).</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt; class my_array {};
 
// two type template parameters and one template template parameter:
template&lt;typename K, typename V, template&lt;typename&gt; typename C = my_array&gt;
class Map
{
    C&lt;K&gt; key;
    C&lt;V&gt; value;
};</pre></div> <h3 id="Template_arguments">Template arguments</h3> <p>In order for a template to be instantiated, every template parameter (type, non-type, or template) must be replaced by a corresponding template argument. For <a href="class_template" title="cpp/language/class template">class templates</a>, the arguments are either explicitly provided<span class="t-rev-inl t-since-cxx17"><span>, <a href="deduction_guide" title="cpp/language/class template argument deduction">deduced from the initializer</a>, </span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> or defaulted. For <a href="function_template" title="cpp/language/function template">function templates</a>, the arguments are explicitly provided, <a href="template_argument_deduction" title="cpp/language/template argument deduction">deduced from the context</a>, or defaulted.</p>
<p>If an argument can be interpreted as both a <a href="type-id" title="cpp/language/type-id" class="mw-redirect">type-id</a> and an expression, it is always interpreted as a type-id, even if the corresponding template parameter is non-type:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt; void f(); // #1
template&lt;int I&gt; void f(); // #2
void g() {
    f&lt;int()&gt;(); // "int()" is both a type and an expression,
                // calls #1 because it is interpreted as a type
}</pre></div> <h4 id="Template_non-type_arguments">Template non-type arguments</h4> <p>The following limitations apply when instantiating templates that have non-type template parameters:</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <ul>
<li> For integral and arithmetic types, the template argument provided during instantiation must be a <a href="constant_expression" title="cpp/language/constant expression">converted constant expression</a> of the template parameter's type (so certain implicit conversion applies). </li>
<li> For pointers to objects, the template arguments have to designate the address of a complete object with static <a href="storage_duration" title="cpp/language/storage duration">storage duration</a> and a <a href="storage_duration#Linkage" title="cpp/language/storage duration">linkage</a> (either internal or external), or a constant expression that evaluates to the appropriate null pointer or <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code> value. </li>
<li> For pointers to functions, the valid arguments are pointers to functions with linkage (or constant expressions that evaluate to null pointer values). </li>
<li> For lvalue reference parameters, the argument provided at instantiation cannot be a temporary, an unnamed lvalue, or a named lvalue with no linkage (in other words, the argument must have linkage). </li>
<li> For pointers to members, the argument has to be a pointer to member expressed as <code>&amp;Class::Member</code> or a constant expression that evaluates to null pointer or <code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code> value. </li>
</ul> <p>In particular, this implies that string literals, addresses of array elements, and addresses of non-static members cannot be used as template arguments to instantiate templates whose corresponding non-type template parameters are pointers to objects.</p>
</td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <p>The template argument that can be used with a non-type template parameter can be any <a href="constant_expression" title="cpp/language/constant expression">converted constant expression</a> of the type of the template parameter.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;const int* pci&gt; struct X {};
int ai[10];
X&lt;ai&gt; xi;  // ok: array to pointer conversion and cv-qualification conversion
 
struct Y {};
template&lt;const Y&amp; b&gt; struct Z {};
Y y;
Z&lt;y&gt; z;  // ok: no conversion
 
template&lt;int (&amp;pa)[5]&gt; struct W {};
int b[5];
W&lt;b&gt; w; // ok: no conversion
 
void f(char);
void f(int);
template&lt;void (*pf)(int)&gt; struct A {};
A&lt;&amp;f&gt; a; // ok: overload resolution selects f(int)</pre></div> <p>The only exceptions are that non-type template parameters of <i>reference</i> or <i>pointer</i> type <span class="t-rev-inl t-since-cxx20"><span>and non-static data members of reference or pointer type in a non-type template parameter of class type and its subobjects</span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> cannot refer to/be the address of.</p>
<ul>
<li> a subobject (including non-static class member, base subobject, or array element); </li>
<li> a temporary object (including one created during <a href="reference_initialization" title="cpp/language/reference initialization">reference initialization</a>); </li>
<li> a <a href="string_literal" title="cpp/language/string literal">string literal</a>; </li>
<li> the result of <a href="typeid" title="cpp/language/typeid">typeid</a>; </li>
<li> or the predefined variable <code>__func__</code>. </li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T, const char* p&gt; class X {};
X&lt;int, "Studebaker"&gt; x1; // error: string literal as template-argument
 
template&lt;int* p&gt; class X {};
int a[10];
struct S
{
    int m;
    static int s;
} s;
X&lt;&amp;a[2]&gt; x3;  // error: address of array element
X&lt;&amp;s.m&gt; x4;   // error: address of non-static member
X&lt;&amp;s.s&gt; x5;   // ok: address of static member
X&lt;&amp;S::s&gt; x6;  // ok: address of static member
 
template&lt;const int&amp; CRI&gt; struct B {};
B&lt;1&gt; b2;     // error: temporary would be required for template argument
int c = 1;
B&lt;c&gt; b1;     // ok</pre></div> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <h4 id="Template_type_arguments">Template type arguments</h4> <p>A template argument for a type template parameter must be a <a href="type-id#Type_naming" title="cpp/language/type">type-id</a>, which may name an incomplete type:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt; class X {}; // class template
 
struct A; // incomplete type
typedef struct {} B; // type alias to an unnamed type
 
int main()
{
    X&lt;A&gt; x1; // ok: 'A' names a type
    X&lt;A*&gt; x2; // ok: 'A*' names a type
    X&lt;B&gt; x3; // ok: 'B' names a type
}</pre></div> <h4 id="Template_template_arguments">Template template arguments</h4> <p>A template argument for a template template parameter must be an <a href="name#In_expressions" title="cpp/language/identifiers">id-expression</a> which names a class template or a template alias.</p>
<p>When the argument is a class template, only the primary template is considered when matching the parameter. The partial specializations, if any, are only considered when a specialization based on this template template parameter happens to be instantiated.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt; class A { int x; }; // primary template
template&lt;class T&gt; class A&lt;T*&gt; { long x; }; // partial specialization
 
// class template with a template template parameter V
template&lt;template&lt;typename&gt; class V&gt; class C
{
    V&lt;int&gt; y; // uses the primary template
    V&lt;int*&gt; z; // uses the partial specialization
};
 
C&lt;A&gt; c; // c.y.x has type int, c.z.x has type long</pre></div> <p>To match a template template argument <code>A</code> to a template template parameter <code>P</code>, <span class="t-rev-inl t-until-cxx17"><span>each of the template parameters of <code>A</code> must match corresponding template parameters of <code>P</code> exactly</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span> <code>P</code> must be at least as specialized as <code>A</code></span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>. If <code>P</code>'s parameter list includes a <a href="parameter_pack" title="cpp/language/parameter pack">parameter pack</a>, zero or more template parameters (or parameter packs) from <code>A</code>'s template parameter list are matched by it.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt; struct eval; // primary template 
 
template&lt;template&lt;typename, typename...&gt; class TT, typename T1, typename... Rest&gt;
struct eval&lt;TT&lt;T1, Rest...&gt;&gt; {}; // partial specialization of eval
 
template&lt;typename T1&gt; struct A;
template&lt;typename T1, typename T2&gt; struct B;
template&lt;int N&gt; struct C;
template&lt;typename T1, int N&gt; struct D;
template&lt;typename T1, typename T2, int N = 17&gt; struct E;
 
eval&lt;A&lt;int&gt;&gt; eA; // ok: matches partial specialization of eval
eval&lt;B&lt;int, float&gt;&gt; eB; // ok: matches partial specialization of eval
eval&lt;C&lt;17&gt;&gt; eC; // error: C does not match TT in partial specialization because
                // TT's first parameter is a type template parameter,
                // while 17 does not name a type
eval&lt;D&lt;int, 17&gt;&gt; eD; // error: D does not match TT in partial specialization
                     // because TT's second parameter is a type parameter pack,
                     // while 17 does not name a type
eval&lt;E&lt;int, float&gt;&gt; eE; // error: E does not match TT in partial specialization
                        // because E's third (default) parameter is a non-type</pre></div> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt; class A { /* ... */ };
template&lt;class T, class U = T&gt; class B { /* ... */ };
template &lt;class ...Types&gt; class C { /* ... */ };
 
template&lt;template&lt;class&gt; class P&gt; class X { /* ... */ };
X&lt;A&gt; xa; // OK
X&lt;B&gt; xb; // OK in C++17 after CWG 150
         // Error earlier: not an exact match
X&lt;C&gt; xc; // OK in C++17 after CWG 150
         // Error earlier: not an exact match
 
template&lt;template&lt;class ...&gt; class Q&gt; class Y { /* ... */ };
Y&lt;A&gt; ya; // OK
Y&lt;B&gt; yb; // OK
Y&lt;C&gt; yc; // OK
 
template&lt;auto n&gt; class D { /* ... */ }; // note: C++17
template&lt;template&lt;int&gt; class R&gt; class Z { /* ... */ };
Z&lt;D&gt; zd; // OK
 
template &lt;int&gt; struct SI { /* ... */ };
template &lt;template &lt;auto&gt; class&gt; void FA();  // note: C++17
FA&lt;SI&gt;();  // Error</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>Formally, a template template-parameter <code>P</code> is at least as specialized as a template template argument <code>A</code> if, given the following rewrite to two function templates, the function template corresponding to <code>P</code> is at least as specialized as the function template corresponding to <code>A</code> according to the partial ordering rules for <a href="function_template" title="cpp/language/function template">function templates</a>. Given an invented class template <code>X </code> with the template parameter list of <code>A</code> (including default arguments):</p>
<ul>
<li> Each of the two function templates has the same template parameters, respectively, as <code>P</code> or <code>A</code>. </li>
<li> Each function template has a single function parameter whose type is a specialization of <code>X</code> with template arguments corresponding to the template parameters from the respective function template where, for each template parameter <code>PP</code> in the template parameter list of the function template, a corresponding template argument <code>AA</code> is formed. If <code>PP</code> declares a parameter pack, then <code>AA</code> is the pack expansion <code>PP...</code>; otherwise, <code>AA</code> is the id-expression <code>PP</code>. </li>
</ul> <p>If the rewrite produces an invalid type, then <code>P</code> is not at least as specialized as <code>A</code>.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <h4 id="Default_template_arguments">Default template arguments</h4> <p>Default template arguments are specified in the parameter lists after the <code>=</code> sign. Defaults can be specified for any kind of template parameter (type, non-type, or template), but not to parameter packs.</p>
<p>If the default is specified for a template parameter of a primary class template <span class="t-rev-inl t-since-cxx14"><span>, primary variable template, </span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span>or alias template, each subsequent template parameter must have a default argument, except the very last one may be a template parameter pack. In a function template, there are no restrictions on the parameters that follow a default, and a parameter pack may be followed by more type parameters only if they have defaults or can be deduced from the function arguments.</p>
<p>Default parameters are not allowed.</p>
<ul>
<li> in the out-of-class definition of a member of a <a href="class_template" title="cpp/language/class template">class template</a> (they have to be provided in the declaration inside the class body). Note that <a href="member_template" title="cpp/language/member template">member templates</a> of non-template classes can use default parameters in their out-of-class definitions (see <a rel="nofollow" class="external text" href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53856">GCC bug 53856</a>) </li>
<li> in <a href="friend#Template_friends" title="cpp/language/friend">friend class template</a> declarations </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <ul><li> in any <a href="function_template" title="cpp/language/function template">function template</a> declaration or definition </li></ul> </td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>On a friend function template declaration, default template arguments are allowed only if the declaration is a definition, and no other declarations of this function appear in this translation unit.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <p>Default template arguments that appear in the declarations and the definition are merged similarly to default function arguments:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T1, typename T2 = int&gt; class A;
template&lt;typename T1 = int, typename T2&gt; class A;
// the above is the same as the following:
template&lt;typename T1 = int, typename T2 = int&gt; class A;</pre></div> <p>But the same parameter cannot be given default arguments twice in the same scope.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T = int&gt; class X;
template&lt;typename T = int&gt; class X {}; // error</pre></div> <p>The template parameter lists of template template parameters can have their own default arguments, which are only in effect where the template template parameter itself is in scope:</p>
<div class="cpp source-cpp"><pre data-language="cpp">// class template, with a type template parameter with a default
template&lt;typename T = float&gt; struct B {};
 
// template template parameter T has a parameter list, which 
// consists of one type template parameter with a default
template&lt;template&lt;typename = float&gt; typename T&gt; struct A
{
    void f();
    void g();
};
 
// out-of-body member function template definitions
template&lt;template&lt;typename TT&gt; class T&gt;
void A&lt;T&gt;::f()
{
    T&lt;&gt; t; // error: TT has no default in scope
}
template&lt;template&lt;typename TT = char&gt; class T&gt;
void A&lt;T&gt;::g()
{
    T&lt;&gt; t; // ok: t is T&lt;char&gt;
}</pre></div> <p><a href="access" title="cpp/language/access">Member access</a> for the names used in a default template parameter is checked at the declaration, not at the point of use:</p>
<div class="cpp source-cpp"><pre data-language="cpp">class B {};
 
template&lt;typename T&gt; class C
{
    protected:
        typedef T TT;
};
 
template&lt;typename U, typename V = typename U::TT&gt; class D: public U {};
 
D&lt;C&lt;B&gt;&gt;* d; // error: C::TT is protected</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>The default template argument is implicitly instantiated when the value of that default argument is needed, except if the template is used to name a function:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T, typename U = int&gt; struct S { };
S&lt;bool&gt;* p; // The default argument for U is instantiated at this point
            // the type of p is S&lt;bool, int&gt;*</pre></div> </td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <h3 id="Examples">Examples</h3> <h4 id="Non-type_template_parameters">Non-type template parameters</h4> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
// simple non-type template parameter
template&lt;int N&gt;
struct S { int a[N]; };
 
template&lt;const char*&gt;
struct S2 {};
 
// complicated non-type example
template
&lt;
    char c, // integral type
    int (&amp;ra)[5], // lvalue reference to object (of array type)
    int (*pf)(int), // pointer to function
    int (S&lt;10&gt;::*a)[10] // pointer to member object (of type int[10])
&gt; struct Complicated
{
    // calls the function selected at compile time
    // and stores the result in the array selected at compile time
    void foo(char base)
    {
        ra[4] = pf(c - base);
    }
};
 
S2&lt;"fail"&gt; s2; // error: string literal cannot be used
char okay[] = "okay"; // static object with linkage
S2&lt; &amp;okay[0] &gt; s2; // error: array element has no linkage
S2&lt;okay&gt; s2; // works
 
int a[5];
int f(int n) { return n; }
 
int main()
{
    S&lt;10&gt; s; // s.a is an array of 10 int
    s.a[9] = 4;
 
    Complicated&lt;'2', a, f, &amp;S&lt;10&gt;::a&gt; c;
    c.foo('0');
 
    std::cout &lt;&lt; s.a[9] &lt;&lt; a[4] &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">42</pre></div> </div>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/template_parameters" class="_attribution-link">http://en.cppreference.com/w/cpp/language/template_parameters</a>
  </p>
</div>
