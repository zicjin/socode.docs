   <h1 id="firstHeading" class="firstHeading">Enumeration declaration</h1>            <p>An <i>enumeration</i> is a distinct type whose value is restricted to a range of values (see below for details), which may include several explicitly named constants ("<i>enumerators</i>"). The values of the constants are values of an integral type known as the <i>underlying type</i> of the enumeration.</p>
<p>An enumeration is defined by <i>enum-specifier</i>, which appears in <span class="t-spar">decl-specifier-seq</span> of the <a href="declarations" title="cpp/language/declarations">declaration</a> syntax. The <i>enum-specifier</i> has the following syntax:</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">enum-key</span> <span class="t-spar">attr</span><span class="t-mark">(optional)</span> <span class="t-spar">identifier</span><span class="t-mark">(optional)</span> <span class="t-spar">enum-base</span><span class="t-mark">(optional)</span><span class="t-mark-rev t-since-cxx11">(C++11)</span> <code>{ </code> <span class="t-spar">enumerator-list</span><span class="t-mark">(optional)</span> <code>} </code> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">enum-key</span> <span class="t-spar">attr</span><span class="t-mark">(optional)</span> <span class="t-spar">nested-name-specifier</span><span class="t-mark">(optional)</span> <span class="t-spar">identifier</span> <span class="t-spar">enum-base</span><span class="t-mark">(optional)</span> <code>; </code> </td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> Definition of an enumeration type.</div> <div class="t-li1">
<span class="t-li">2)</span> <i>Opaque enum declaration</i>: defines the enumeration type but not its enumerators: after this declaration, the type is a complete type and its size is known. <span class="t-rev-inl t-since-cxx14"><span> Note: an <a href="template_specialization" title="cpp/language/template specialization">explicit specialization declaration</a> of a scoped enumeration member of a class template is the only case where <span class="t-spar">nested-name-specifier</span> appears before <span class="t-spar">identifier</span> </span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span>
</div> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">enum-key</span> </td> <td> - </td> <td> one of <code>enum</code>, <code>enum class</code><span class="t-mark-rev t-since-cxx11">(since C++11)</span>, or <code>enum struct</code><span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">attr</span><span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> - </td> <td> optional sequence of any number of <a href="attributes" title="cpp/language/attributes">attributes</a> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">identifier</span> </td> <td> - </td> <td> the name of the enumeration that's being declared. If present, and if this declaration is a re-declaration, it may be preceded by <span class="t-spar">nested-name-specifier</span><span class="t-mark-rev t-since-cxx11">(since C++11)</span>: sequence of names and scope-resolution operators <code>::</code>, ending with scope-resolution operator. The name can be omitted only in unscoped enumeration declarations </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">enum-base</span><span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> - </td> <td> colon (<code>:</code>), followed by a <span class="t-spar">type-specifier-seq</span> that names an integral type (if it is cv-qualified, qualifications are ignored) that will serve as the fixed underlying type for this enumeration type </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">enumerator-list</span> </td> <td> - </td> <td> comma-separated list of enumerator definitions, each of which is either simply an <span class="t-spar">identifier</span>, which becomes the name of the enumerator, or an identifier with an initializer: <span class="t-spar">identifier</span> <code>=</code> <span class="t-spar">constexpr</span>. <span class="t-rev-inl t-since-cxx17"><span>In either case, the <span class="t-spar">identifier</span> can be directly followed by an optional <a href="attributes" title="cpp/language/attributes">attribute specifier sequence</a>.</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> </td>
</tr>
</table> <p>There are two distinct kinds of enumerations: <i>unscoped enumeration</i> (declared with the <span class="t-spar">enum-key</span> <code>enum</code>) and <i>scoped enumeration</i> (declared with the <span class="t-spar">enum-key</span> <code>enum class</code> or <code>enum struct</code>).</p>
<h3 id="Unscoped_enumeration">Unscoped enumeration</h3> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>enum</code> <span class="t-spar">name</span> <code>{</code> <span class="t-spar">enumerator</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code> <span class="t-spar">enumerator</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code> ... <code>} </code> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>enum</code> <span class="t-spar">name</span> <code>:</code> <span class="t-spar">type</span> <code>{</code> <span class="t-spar">enumerator</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code> <span class="t-spar">enumerator</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code> ... <code>} </code> </td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>enum</code> <span class="t-spar">name</span> <code>:</code> <span class="t-spar">type</span> <code>; </code> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> Declares an unscoped enumeration type whose underlying type is not fixed (in this case, the underlying type is an implementation-defined integral type that can represent all enumerator values; this type is not larger than <code>int</code> unless the value of an enumerator cannot fit in an <code>int</code> or <code>unsigned int</code>. If the enumerator-list is empty, the underlying type is as if the enumeration had a single enumerator with value 0).</div> <div class="t-li1">
<span class="t-li">2)</span> Declares an unscoped enumeration type whose underlying type is fixed.</div> <div class="t-li1">
<span class="t-li">3)</span> Opaque enum declaration for an unscoped enumeration must specify the underlying type.</div> <p>Each <span class="t-spar">enumerator</span> becomes a named constant of the enumeration's type (that is, <span class="t-spar">name</span>), visible in the enclosing scope, and can be used whenever constants are required.</p>
<div class="cpp source-cpp"><pre data-language="cpp">enum Color { red, green, blue };
Color r = red;
switch(r)
{
    case red  : std::cout &lt;&lt; "red\n";   break;
    case green: std::cout &lt;&lt; "green\n"; break;
    case blue : std::cout &lt;&lt; "blue\n";  break;
}</pre></div> <p>Each enumerator is associated with a value of the underlying type. When initializers are provided in the <span class="t-spar">enumerator-list</span>, the values of enumerators are defined by those initializers. If the first enumerator does not have an initializer, the associated value is zero. For any other enumerator whose definition does not have an initializer, the associated value is the value of the previous enumerator plus one.</p>
<div class="cpp source-cpp"><pre data-language="cpp">enum Foo { a, b, c = 10, d, e = 1, f, g = f + c };
//a = 0, b = 1, c = 10, d = 11, e = 1, f = 2, g = 12</pre></div> <p>Values of unscoped enumeration type are <a href="implicit_cast" title="cpp/language/implicit cast" class="mw-redirect">implicitly-convertible</a> to integral types. If the underlying type is not fixed, the value is convertible to the first type from the following list able to hold their entire value range: <code>int</code>, <code>unsigned int</code>, <code>long</code>, <code>unsigned long</code>, <code>long long</code>, or <code>unsigned long long</code>. If the underlying type is fixed, the values can be converted to their promoted underlying type.</p>
<div class="cpp source-cpp"><pre data-language="cpp">enum color { red, yellow, green = 20, blue };
color col = red;
int n = blue; // n == 21</pre></div> <p>Values of integer, floating-point, and enumeration types can be converted by <a href="static_cast" title="cpp/language/static cast"><code>static_cast</code></a> or <a href="explicit_cast" title="cpp/language/explicit cast">explicit cast</a>, to any enumeration type. If the underlying type is not fixed, the result is <span class="t-rev-inl t-until-cxx17"><span>unspecified</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span>undefined behavior</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> if the source value (first converted to the enumeration's underlying type if floating-point) is out of range (the range is all values possible for the smallest bit field large enough to hold all enumerators of the target enumeration). Otherwise, the result is the same as the result of <a href="implicit_cast" title="cpp/language/implicit cast" class="mw-redirect">implicit conversion</a> to the underlying type.</p>
<p>Note that the value after such conversion may not necessarily equal any of the named enumerators defined for the enumeration.</p>
<div class="cpp source-cpp"><pre data-language="cpp">enum access_t { read = 1, write = 2, exec = 4 }; // enumerators: 1, 2, 4 range: 0..7
access_t rw = static_cast&lt;access_t&gt;(3);
assert(rw &amp; read &amp;&amp; rw &amp; write);
 
access_t x = static_cast&lt;access_t&gt;(8.0); // undefined behavior since C++17
access_t y = static_cast&lt;access_t&gt;(8); // undefined behavior since C++17
 
enum foo { a = 0, b = UINT_MAX }; // range: [0, UINT_MAX]
foo x= foo(-1); // undefined behavior since C++17, even if foo's underlying type is unsigned int</pre></div> <p>The <span class="t-spar">name</span> of an unscoped enumeration may be omitted: such declaration only introduces the enumerators into the enclosing scope:</p>
<div class="cpp source-cpp"><pre data-language="cpp">enum { a, b, c = 0, d = a + 2 }; // defines a = 0, b = 1, c = 0, d = 2</pre></div> <p>When an unscoped enumeration is a class member, its enumerators may be accessed using class member access operators <code>.</code> and <code>-&gt;</code>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct X
{
    enum direction { left = 'l', right = 'r' };
};
X x;
X* p = &amp;x;
 
int a = X::direction::left; // allowed only in C++11 and later
int b = X::left;
int c = x.left;
int d = p-&gt;left;</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <h3 id="Scoped_enumerations"> Scoped enumerations</h3> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>enum</code> <code>struct|class</code> <span class="t-spar">name</span> <code>{</code> <span class="t-spar">enumerator</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code> <span class="t-spar">enumerator</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code> ... <code>} </code> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>enum</code> <code>struct|class</code> <span class="t-spar">name</span> <code>:</code> <span class="t-spar">type</span> <code>{</code> <span class="t-spar">enumerator</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code> <span class="t-spar">enumerator</span> <code>=</code> <span class="t-spar">constexpr</span> <code>,</code> ... <code>} </code> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>enum</code> <code>struct|class</code> <span class="t-spar">name</span> <code>; </code> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>enum</code> <code>struct|class</code> <span class="t-spar">name</span> <code>:</code> <span class="t-spar">type</span> <code>; </code> </td> <td> (4) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <span class="t-li">1)</span> declares a scoped enumeration type whose underlying type is <code>int</code> (the keywords <code>class</code> and <code>struct</code> are exactly equivalent) <span class="t-li">2)</span> declares a scoped enumeration type whose underlying type is <span class="t-spar">type</span> <span class="t-li">3)</span> opaque enum declaration for a scoped enumeration whose underlying type is <code>int</code> <span class="t-li">4)</span> opaque enum declaration for a scoped enumeration whose underlying type is <span class="t-spar">type</span> <p>Each <span class="t-spar">enumerator</span> becomes a named constant of the enumeration's type (that is, <span class="t-spar">name</span>), which is contained within the scope of the enumeration, and can be accessed using scope resolution operator. There are no implicit conversions from the values of a scoped enumerator to integral types, although <a href="static_cast" title="cpp/language/static cast">static_cast</a> may be used to obtain the numeric value of the enumerator.</p>
<div class="cpp source-cpp"><pre data-language="cpp">enum class Color { red, green = 20, blue };
Color r = Color::blue;
switch(r)
{
    case Color::red  : std::cout &lt;&lt; "red\n";   break;
    case Color::green: std::cout &lt;&lt; "green\n"; break;
    case Color::blue : std::cout &lt;&lt; "blue\n";  break;
}
// int n = r; // error: no scoped enum to int conversion
int n = static_cast&lt;int&gt;(r); // OK, n = 21</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>Both scoped enumeration types and unscoped enumeration types whose underlying type is fixed can be initialized from an integer without a cast, using <a href="list_initialization" title="cpp/language/list initialization">list initialization</a>, if all of the following is true:</p>
<ul>
<li> the initialization is direct-list-initialization </li>
<li> the initializer list has only a single element </li>
<li> the enumeration is either scoped or unscoped with underlying type fixed </li>
<li> the conversion is non-narrowing </li>
</ul> <p>This makes it possible to introduce new integer types (e.g. SafeInt) that enjoy the same existing calling conventions as their underlying integer types, even on ABIs that penalize passing/returning structures by value.</p>
<div class="cpp source-cpp"><pre data-language="cpp">enum byte : unsigned char {}; // byte is a new integer type
byte b { 42 }; // OK as of C++17 (direct-list-initialization)
byte c = { 42 }; // error
byte d = byte{ 42 }; // OK as of C++17; same value as b
byte e { -1 }; // error
 
struct A { byte b; };
A a1 = { { 42 } }; // error
A a2 = { byte{ 42 } }; // OK as of C++17
 
void f(byte);
f({ 42 }); // error
 
enum class Handle : std::uint32_t { Invalid = 0 };
Handle h { 42 }; // OK as of C++17</pre></div> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <h3 id="Example">Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
// enum that takes 16 bits
enum smallenum: int16_t
{
    a,
    b,
    c
};
 
 
// color may be red (value 0), yellow (value 1), green (value 20), or blue (value 21)
enum color
{
    red,
    yellow,
    green = 20,
    blue
};
 
// altitude may be altitude::high or altitude::low
enum class altitude: char
{ 
     high='h',
     low='l', // C++11 allows the extra comma
}; 
 
// the constant d is 0, the constant e is 1, the constant f is 3
enum
{
    d,
    e,
    f = e + 2
};
 
//enumeration types (both scoped and unscoped) can have overloaded operators
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, color c)
{
    switch(c)
    {
        case red   : os &lt;&lt; "red";    break;
        case yellow: os &lt;&lt; "yellow"; break;
        case green : os &lt;&lt; "green";  break;
        case blue  : os &lt;&lt; "blue";   break;
        default    : os.setstate(std::ios_base::failbit);
    }
    return os;
}
 
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, altitude al)
{
    return os &lt;&lt; static_cast&lt;char&gt;(al);
}
 
int main()
{
    color col = red;
    altitude a;
    a = altitude::low;
 
    std::cout &lt;&lt; "col = " &lt;&lt; col &lt;&lt; '\n'
              &lt;&lt; "a = "   &lt;&lt; a   &lt;&lt; '\n'
              &lt;&lt; "f = "   &lt;&lt; f   &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">col = red
a = l
f = 3</pre></div> </div> <h3 id="Defect_reports">Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/cwg1638">CWG 1638</a> </td> <td> C++14 </td> <td> grammar of opaque enum declaration prohibited use for template specializations </td> <td> nested-name-specifier permitted </td>
</tr>
</table> <h3 id="See_also">See also</h3>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/enum" class="_attribution-link">http://en.cppreference.com/w/cpp/language/enum</a>
  </p>
</div>
