   <h1 id="firstHeading" class="firstHeading">Fundamental types</h1>            <p><small>(See also <a href="type-id" title="cpp/language/type">type</a> for type system overview and <a href="../types" title="cpp/types"> the list of type-related utilities</a> that are provided by the C++ library)</small>.</p>
<h3 id="Void_type">Void type</h3> <code>void</code> - type with an empty set of values. It is an <a href="incomplete_type" title="cpp/language/incomplete type" class="mw-redirect">incomplete type</a> that cannot be completed (consequently, objects of type <code>void</code> are disallowed). There are no <a href="array" title="cpp/language/array">arrays</a> of <code>void</code>, nor <a href="reference" title="cpp/language/reference">references</a> to <code>void</code>. However, <a href="pointer#Pointers_to_void" title="cpp/language/pointer">pointers to <code>void</code></a> and <a href="function" title="cpp/language/function">functions</a> returning type <code>void</code> (<i>procedures</i> in other languages) are permitted.  <h3 id="std::nullptr_t"><code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code></h3> <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/cstddef" title="cpp/header/cstddef">&lt;cstddef&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">typedef decltype(nullptr) nullptr_t;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr>  </table> <p><code><a href="../types/nullptr_t" title="cpp/types/nullptr t">std::nullptr_t</a></code> is the type of the null pointer literal, <a href="nullptr" title="cpp/language/nullptr"><code>nullptr</code></a>. It is a distinct type that is not itself a pointer type or a pointer to member type.</p>
<h3 id="Boolean_type">Boolean type</h3> <code>bool</code> - type, capable of holding one of the two values: <a href="bool_literal" title="cpp/language/bool literal"><code>true</code></a> or <a href="bool_literal" title="cpp/language/bool literal"><code>false</code></a>. The value of <code>sizeof(bool)</code> is implementation defined and might differ from 1.  <h3 id="Integer_types">Integer types</h3> <code>int</code> - basic integer type. The keyword <code>int</code> may be omitted if any of the modifiers listed below are used. If no length modifiers are present, it's guaranteed to have a width of at least 16 bits. However, on 32/64 bit systems it is almost exclusively guaranteed to have width of at least 32 bits (see below).  <h4 id="Modifiers">Modifiers</h4> <p>Modifies the integer type. Can be mixed in any order. Only one of each group can be present in type name.</p>
<p><b>Signedness</b>.</p>
<dl>
<dd>
<code>signed</code> - target type will have signed representation (this is the default if omitted) </dd>
<dd>
<code>unsigned</code> - target type will have unsigned representation </dd>
</dl> <p><b>Size</b>.</p>
<dl>
<dd>
<code>short</code> - target type will be optimized for space and will have width of at least 16 bits. </dd>
<dd>
<code>long</code> - target type will have width of at least 32 bits. </dd>
</dl> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <code>long long</code> - target type will have width of at least 64 bits.  </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <p>Note: as with all type specifiers, any order is permitted: <code>unsigned long long int</code> and <code>long int unsigned long</code> name the same type.</p>
<h4 id="Properties">Properties</h4> <p>The following table summarizes all available integer types and their properties:</p>
<table class="wikitable"> <tr> <th rowspan="2"> Type specifier </th> <th rowspan="2"> Equivalent type </th> <th colspan="5"> Width in bits by data model </th>
</tr> <tr> <th> C++ standard </th> <th> LP32 </th> <th> ILP32 </th> <th> LLP64 </th> <th> LP64 </th>
</tr> <tr> <td> <code>short</code> </td> <td rowspan="4"> <code>short int</code> </td> <td rowspan="6"> at least<br> <b>16</b> </td> <td rowspan="6"> <b>16</b> </td> <td rowspan="6"> <b>16</b> </td> <td rowspan="6"> <b>16</b> </td> <td rowspan="6"> <b>16</b> </td>
</tr> <tr> <td> <code>short int</code> </td>
</tr> <tr> <td> <code>signed short</code> </td>
</tr> <tr> <td> <code>signed short int</code> </td>
</tr> <tr> <td> <code>unsigned short</code> </td> <td rowspan="2"> <code>unsigned short int</code> </td>
</tr> <tr> <td> <code>unsigned short int</code> </td>
</tr> <tr> <td> <code>int</code> </td> <td rowspan="3"> <code>int</code> </td> <td rowspan="5"> at least<br> <b>16</b> </td> <td rowspan="5"> <b>16</b> </td> <td rowspan="5"> <b>32</b> </td> <td rowspan="5"> <b>32</b> </td> <td rowspan="5"> <b>32</b> </td>
</tr> <tr> <td> <code>signed</code> </td>
</tr> <tr> <td> <code>signed int</code> </td>
</tr> <tr> <td> <code>unsigned</code> </td> <td rowspan="2"> <code>unsigned int</code> </td>
</tr> <tr> <td> <code>unsigned int</code> </td>
</tr> <tr> <td> <code>long</code> </td> <td rowspan="4"> <code>long int</code> </td> <td rowspan="6"> at least<br> <b>32</b> </td> <td rowspan="6"> <b>32</b> </td> <td rowspan="6"> <b>32</b> </td> <td rowspan="6"> <b>32</b> </td> <td rowspan="6"> <b>64</b> </td>
</tr> <tr> <td> <code>long int</code> </td>
</tr> <tr> <td> <code>signed long</code> </td>
</tr> <tr> <td> <code>signed long int</code> </td>
</tr> <tr> <td> <code>unsigned long</code> </td> <td rowspan="2"> <code>unsigned long int</code> </td>
</tr> <tr> <td> <code>unsigned long int</code> </td>
</tr> <tr> <td> <code>long long</code> </td> <td rowspan="4"> <code>long long int</code> <br> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td rowspan="6"> at least<br> <b>64</b> </td> <td rowspan="6"> <b>64</b> </td> <td rowspan="6"> <b>64</b> </td> <td rowspan="6"> <b>64</b> </td> <td rowspan="6"> <b>64</b> </td>
</tr> <tr> <td> <code>long long int</code> </td>
</tr> <tr> <td> <code>signed long long</code> </td>
</tr> <tr> <td> <code>signed long long int</code> </td>
</tr> <tr> <td> <code>unsigned long long</code> </td> <td rowspan="2"> <code>unsigned long long int</code> <br> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td>
</tr> <tr> <td> <code>unsigned long long int</code> </td>
</tr>
</table> <p>Note: integer arithmetic is defined differently for the signed and unsigned integer types. See <a href="operator_arithmetic" title="cpp/language/operator arithmetic">arithmetic operators</a>, in particular <a href="operator_arithmetic#Overflows" title="cpp/language/operator arithmetic">integer overflows</a>.</p>
<p><code><a href="../types/size_t"><span class="kw100">std::<span class="me2">size_t</span></span></a></code> is the unsigned integer type of the result of the <code>sizeof</code> operator <span class="t-rev-inl t-since-cxx11"><span>as well as the <code>sizeof...</code> operator and the <code>alignof</code> operator</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>.</p>
<p><span class="t-rev-inl t-since-cxx11"><span>See also <a href="../types/integer" title="cpp/types/integer">Fixed width integer types</a>.</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>.</p>
<h4 id="Data_models">Data models</h4> <p>The choices made by each implementation about the sizes of the fundamental types are collectively known as <i>data model</i>. Four data models found wide acceptance:</p>
<p>32 bit systems:</p>
<ul>
<li>
<b>LP32</b> or <b>2/4/4</b> (int is 16-bit, long and pointer are 32-bit) </li>
<ul><li> Win16 API </li></ul>
<li>
<b>ILP32</b> or <b>4/4/4</b> (int, long, and pointer are 32-bit); </li>
<ul>
<li> Win32 API </li>
<li> Unix and Unix-like systems (Linux, Mac OS X) </li>
</ul>
</ul>     <p>64 bit systems:</p>
<ul>
<li> <b>LLP64</b> or <b>4/4/8</b> (int and long are 32-bit, pointer is 64-bit) </li>
<ul><li> Win64 API </li></ul>
<li> <b>LP64</b> or <b>4/8/8</b> (int is 32-bit, long and pointer are 64-bit) </li>
<ul><li> Unix and Unix-like systems (Linux, Mac OS X) </li></ul>
</ul>     <p>Other models are very rare. For example, <b>ILP64</b> (<b>8/8/8</b>: int, long, and pointer are 64-bit) only appeared in some early 64-bit Unix systems (e.g. Unicos on Cray).</p>
<h3 id="Character_types">Character types</h3> <dl>
<dd>
<code>signed char</code> - type for signed character representation. </dd>
<dd>
<code>unsigned char</code> - type for unsigned character representation. Also used to inspect <a href="objects" title="cpp/language/object">object representations</a> (raw memory). </dd>
<dd>
<code>char</code> - type for character representation which can be most efficiently processed on the target system (has the same representation and alignment as either <code>signed char</code> or <code>unsigned char</code>, but is always a distinct type). <a href="../string/multibyte" title="cpp/string/multibyte">Multibyte characters strings</a> use this type to represent code units. <span class="t-rev-inl t-since-cxx14"><span>The character types are large enough to represent any UTF-8 eight-bit code unit</span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span>. The signedness of <code>char</code> depends on the compiler and the target platform: the defaults for ARM and PowerPC are typically unsigned, the defaults for x86 and x64 are typically signed. </dd>
<dd>
<code>wchar_t</code> - type for wide character representation (see <a href="../string/wide" title="cpp/string/wide">wide strings</a>). Required to be large enough to represent any supported character code point (32 bits on systems that support Unicode. A notable exception is Windows, where wchar_t is 16 bits and holds UTF-16 code units) It has the same size, signedness, and alignment as one of the integer types, but is a distinct type. </dd>
</dl> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <dl>
<dd>
<code>char16_t</code> - type for UTF-16 character representation, required to be large enough to represent any UTF-16 code unit (16 bits). It has the same size, signedness, and alignment as <code><a href="../types/integer" title="cpp/types/integer">std::uint_least16_t</a></code>, but is a distinct type. </dd>
<dd>
<code>char32_t</code> - type for UTF-32 character representation, required to be large enough to represent any UTF-32 code unit (32 bits). It has the same size, signedness, and alignment as <code><a href="../types/integer" title="cpp/types/integer">std::uint_least32_t</a></code>, but is a distinct type. </dd>
</dl> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <code>char8_t</code> - type for UTF-8 character representation, required to be large enough to represent any UTF-8 code unit (8 bits). It has the same size, signedness, and alignment as <code>unsigned char</code> (and. therefore, the same size and alignment as <code>char</code> and <code>signed char</code>), but is a distinct type.  </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p>Besides the minimal bit counts, the C++ Standard guarantees that  <code>1 == sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)</code>.</p>
<p>Note: this allows the extreme case in which <a href="https://en.wikipedia.org/wiki/Byte" class="extiw" title="enwiki:Byte">bytes</a> are sized 64 bits, all types (including <code>char</code>) are 64 bits wide, and <code>sizeof</code> returns 1 for every type.</p>
<h3 id="Floating_point_types">Floating point types</h3> <code>float</code> - single precision floating point type. Usually IEEE-754 32 bit floating point type  <code>double</code> - double precision floating point type. Usually IEEE-754 64 bit floating point type  <code>long double</code> - extended precision floating point type. Does not necessarily map to types mandated by IEEE-754. Usually 80-bit x87 floating point type on x86 and x86-64 architectures.  <h4 id="Properties_2">Properties</h4> <p>Floating-point types may support <a href="../types/numeric_limits" title="cpp/types/numeric limits">special values</a>:</p>
<ul>
<li> <i>infinity</i> (positive and negative), see <code><a href="../numeric/math/infinity" title="cpp/numeric/math/INFINITY">INFINITY</a></code> </li>
<li> the <i>negative zero</i>, <code>-0.0</code>. It compares equal to the positive zero, but is meaningful in some arithmetic operations, e.g. <code><span class="nu16">1.0</span><span class="sy2">/</span><span class="nu16">0.0</span> <span class="sy1">==</span> <a href="../numeric/math/infinity"><span class="kw1374">INFINITY</span></a></code>, but <code><span class="nu16">1.0</span><span class="sy2">/-</span><span class="nu16">0.0</span> <span class="sy1">==</span> <span class="sy2">-</span><a href="../numeric/math/infinity"><span class="kw1374">INFINITY</span></a></code>), and for some mathematical functions, e.g. <a href="../numeric/complex/sqrt" title="cpp/numeric/complex/sqrt"><code>sqrt(std::complex)</code></a> </li>
<li> <i>not-a-number</i> (NaN), which does not compare equal with anything (including itself). Multiple bit patterns represent NaNs, see <code><a href="../numeric/math/nan.2" title="cpp/numeric/math/nan">std::nan</a></code>, <code><a href="../numeric/math/nan" title="cpp/numeric/math/NAN">NAN</a></code>. Note that C++ takes no special notice of signalling NaNs other than detecting their support by <code><a href="../types/numeric_limits/has_signaling_nan" title="cpp/types/numeric limits/has signaling NaN">std::numeric_limits::has_signaling_NaN</a></code>, and treats all NaNs as quiet. </li>
</ul> <p>Real floating-point numbers may be used with <a href="operator_arithmetic" title="cpp/language/operator arithmetic">arithmetic operators</a> + - / * and various mathematical functions from <a href="../numeric/math" title="cpp/numeric/math">cmath</a>. Both built-in operators and library functions may raise floating-point exceptions and set <code><a href="../error/errno" title="cpp/error/errno">errno</a></code> as described in <a href="../numeric/math/math_errhandling" title="cpp/numeric/math/math errhandling"><code>math_errhandling</code></a>.</p>
<p>Floating-point expressions may have greater range and precision than indicated by their types, see <code><a href="../types/climits/flt_eval_method" title="cpp/types/climits/FLT EVAL METHOD">FLT_EVAL_METHOD</a></code>. Floating-point expressions may also be <i>contracted</i>, that is, calculated as if all intermediate values have infinite range and precision, see <a href="../preprocessor/impl#.23pragma_STDC" title="cpp/preprocessor/impl">#pragma STDC FP_CONTRACT</a>.</p>
<p>Some operations on floating-point numbers are affected by and modify the state of <a href="../numeric/fenv" title="cpp/numeric/fenv">the floating-point environment</a> (most notably, the rounding direction).</p>
<p><a href="implicit_cast" title="cpp/language/implicit conversion">Implicit conversions</a> are defined between real floating types and integer types.</p>
<p>See <a href="../types/climits#Limits_of_floating_point_types" title="cpp/types/climits">Limits of floating point types</a> and <a href="../types/numeric_limits" title="cpp/types/numeric limits">std::numeric_limits</a> for additional details, limits, and properties of the floating-point types.</p>
<h3 id="Range_of_values">Range of values</h3> <p>The following table provides a reference for the limits of common numeric representations.</p>
<p>Prior to C++20, the C++ Standard allowed any signed integer representation, and the minimum guaranteed range of N-bit signed integers was from -(2<span class="t-su">N-1<br></span>-1) to +2<span class="t-su">N-1<br></span>-1 (e.g. <b>-127</b> to <b>127</b> for a signed 8-bit type), which corresponds to the limits of <a href="https://en.wikipedia.org/wiki/One's_complement" class="extiw" title="enwiki:One's complement">one's complement</a> or <a href="https://en.wikipedia.org/wiki/Signed_number_representations#Sign-and-magnitude_method" class="extiw" title="enwiki:Signed number representations">sign-and-magnitude</a>.</p>
<p>However, all C++ compilers use <a href="https://en.wikipedia.org/wiki/Two's_complement" class="extiw" title="enwiki:Two's complement">two's complement</a> representation, and as of C++20, it is the only representation allowed by the standard, with the guaranteed range from -2<span class="t-su">N-1<br></span> to +2<span class="t-su">N-1<br></span>-1 (e.g. <b>-128</b> to <b>127</b> for a signed 8-bit type).</p>
<table class="wikitable"> <tr> <th rowspan="2"> Type </th> <th rowspan="2"> Size in bits </th> <th rowspan="2"> Format </th> <th colspan="2"> Value range </th>
</tr> <tr> <th> Approximate </th> <th> Exact </th>
</tr> <tr> <th rowspan="4"> character </th> <td rowspan="2"> 8 </td> <td> signed </td> <td> </td> <td> <b>-128</b> to <b>127</b> </td>
</tr> <tr> <td> unsigned </td> <td> </td> <td> <b>0</b> to <b>255</b> </td>
</tr> <tr> <td> 16 </td> <td> unsigned </td> <td> </td> <td> <b>0</b> to <b>65535</b> </td>
</tr> <tr> <td> 32 </td> <td> unsigned </td> <td> </td> <td> <b>0</b> to <b>1114111</b> (<b>0x10ffff</b>) </td>
</tr> <tr> <th rowspan="6"> integer </th> <td rowspan="2"> 16 </td> <td> signed </td> <td> <b>± 3.27 · 10<sup>4</sup></b> </td> <td> <b>-32768</b> to <b>32767</b> </td>
</tr> <tr> <td> unsigned </td> <td> <b>0</b> to <b>6.55 · 10<sup>4</sup></b> </td> <td> <b>0</b> to <b>65535</b> </td>
</tr> <tr> <td rowspan="2"> 32 </td> <td> signed </td> <td> <b>± 2.14 · 10<sup>9</sup></b> </td> <td> <b>-2,147,483,648</b> to <b>2,147,483,647</b> </td>
</tr> <tr> <td> unsigned </td> <td> <b>0</b> to <b>4.29 · 10<sup>9</sup></b> </td> <td> <b>0</b> to <b>4,294,967,295</b> </td>
</tr> <tr> <td rowspan="2"> 64 </td> <td> signed </td> <td> <b>± 9.22 · 10<sup>18</sup></b> </td> <td> <b>-9,223,372,036,854,775,808</b> to <b>9,223,372,036,854,775,807</b> </td>
</tr> <tr> <td> unsigned </td> <td> <b>0</b> to <b>1.84 · 10<sup>19</sup></b> </td> <td> <b>0</b> to <b>18,446,744,073,709,551,615</b> </td>
</tr> <tr> <th rowspan="2"> floating<br> point </th> <td> 32 </td> <td> <a href="https://en.wikipedia.org/wiki/IEEE-754" class="extiw" title="enwiki:IEEE-754">IEEE-754</a> </td> <td> <ul>
<li>min subnormal:<br><b>± 1.401,298,4 · 10<sup>-45</sup></b> </li>
<li>min normal:<br><b>± 1.175,494,3 · 10<sup>-38</sup></b> </li>
<li>max:<br><b>± 3.402,823,4 · 10<sup>38</sup></b> </li>
</ul>  </td> <td> <ul>
<li>min subnormal:<br><b>±0x1p-149</b> </li>
<li>min normal:<br><b>±0x1p-126</b> </li>
<li>max:<br><b>±0x1.fffffep+127</b> </li>
</ul>  </td>
</tr> <tr> <td> 64 </td> <td> <a href="https://en.wikipedia.org/wiki/IEEE-754" class="extiw" title="enwiki:IEEE-754">IEEE-754</a> </td> <td>  <ul>
<li>min subnormal:<br><b>± 4.940,656,458,412 · 10<sup>-324</sup></b> </li>
<li>min normal:<br><b>± 2.225,073,858,507,201,4 · 10<sup>-308</sup></b> </li>
<li>max:<br><b>± 1.797,693,134,862,315,7 · 10<sup>308</sup></b> </li>
</ul>  </td> <td>  <ul>
<li>min subnormal:<br><b>±0x1p-1074</b> </li>
<li>min normal:<br><b>±0x1p-1022</b> </li>
<li>max:<br><b>±0x1.fffffffffffffp+1023</b> </li>
</ul>  </td>
</tr>
</table> <p><br> Note: actual (as opposed to guaranteed minimal) limits on the values representable by these types are available in <a href="../types/climits" title="cpp/types/climits">&lt;climits&gt;, &lt;cfloat&gt;</a> and <code><a href="../types/numeric_limits" title="cpp/types/numeric limits">std::numeric_limits</a></code>.</p>
<h3 id="Keywords">Keywords</h3> <p><a href="../keyword/void" title="cpp/keyword/void"><code>void</code></a>, <a href="../keyword/bool" title="cpp/keyword/bool"><code>bool</code></a>, <a href="../keyword/true" title="cpp/keyword/true"><code>true</code></a>, <a href="../keyword/false" title="cpp/keyword/false"><code>false</code></a>, <a href="../keyword/char" title="cpp/keyword/char"><code>char</code></a>, <a href="../keyword/wchar_t" title="cpp/keyword/wchar t"><code>wchar_t</code></a>, <a href="../keyword/char8_t" title="cpp/keyword/char8 t"><code>char8_t</code></a>, <a href="../keyword/char16_t" title="cpp/keyword/char16 t"><code>char16_t</code></a>, <a href="../keyword/char32_t" title="cpp/keyword/char32 t"><code>char32_t</code></a>, <a href="../keyword/int" title="cpp/keyword/int"><code>int</code></a>, <a href="../keyword/short" title="cpp/keyword/short"><code>short</code></a>, <a href="../keyword/long" title="cpp/keyword/long"><code>long</code></a>, <a href="../keyword/signed" title="cpp/keyword/signed"><code>signed</code></a>, <a href="../keyword/unsigned" title="cpp/keyword/unsigned"><code>unsigned</code></a>, <a href="../keyword/float" title="cpp/keyword/float"><code>float</code></a>, <a href="../keyword/double" title="cpp/keyword/double"><code>double</code></a>.</p>
<h3 id="See_also">See also</h3> <ul>
<li> <a href="type-id" title="cpp/language/type"> the C++ type system overview</a> </li>
<li> <a href="cv" title="cpp/language/cv"> const-volatility (cv) specifiers and qualifiers</a> </li>
<li> <a href="storage_duration" title="cpp/language/storage duration"> storage duration specifiers</a> </li>
</ul>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/types" class="_attribution-link">http://en.cppreference.com/w/cpp/language/types</a>
  </p>
</div>
