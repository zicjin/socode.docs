    <h1 id="firstHeading" class="firstHeading">Aggregate initialization</h1>            <p>Initializes an aggregate from braced-init-list.</p>
<h3 id="Syntax"> Syntax</h3> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">T</span> <span class="t-spar">object</span> <code>=</code> <code>{</code><span class="t-spar">arg1, arg2, ...</span><code>}</code><code>;</code> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">T</span> <span class="t-spar">object</span> <code>{</code><span class="t-spar">arg1, arg2, ...</span> <code>}</code><code>;</code> </td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">T</span> <span class="t-spar">object</span> <code>=</code> <code>{</code> <code>.</code><span class="t-spar">designator</span> <code>=</code> <span class="t-spar">arg1</span> <code>,</code> <code>.</code><span class="t-spar">designator</span> <code>{</code> <span class="t-spar">arg2</span> <code>}</code> ... <code>}</code><code>;</code> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">T</span> <span class="t-spar">object</span> <code>{</code> <code>.</code><span class="t-spar">designator</span> <code>=</code> <span class="t-spar">arg1</span> <code>,</code> <code>.</code><span class="t-spar">designator</span> <code>{</code> <span class="t-spar">arg2</span> <code>}</code> ... <code>}</code><code>;</code> </td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">T</span> <span class="t-spar">object</span> <code>(</code><span class="t-spar">arg1, arg2, ...</span><code>)</code><code>;</code> </td> <td> (5) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr> 
</table> <h3 id="Explanation"> Explanation</h3> <p>Aggregate initialization initializes <i>aggregates</i>. <span class="t-rev-inl t-since-cxx11"><span>It is a form of <a href="list_initialization" title="cpp/language/list initialization">list-initialization</a></span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span><span class="t-rev-inl t-since-cxx20"><span> or <a href="direct_initialization" title="cpp/language/direct initialization">direct initialization</a></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>.</p>
<p>An aggregate is one of the following types:</p>
<ul>
<li> array type </li>
<li> class type (typically, <code>struct</code> or <code>union</code>), that has </li>
<ul><li> no private or protected <span class="t-rev-inl t-since-cxx17"><span>direct </span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>non-static data members </li></ul>
</ul>  <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <ul><li> no user-declared constructors </li></ul> </td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx11 t-until-cxx20">
<td> <ul><li> no <a href="function#User-provided_functions" title="cpp/language/function">user-provided</a>, <a href="using_declaration#Inheriting_constructors" title="cpp/language/using declaration">inherited</a>, or <a href="explicit" title="cpp/language/explicit">explicit</a> constructors </li></ul> </td> <td>
<span class="t-mark-rev t-since-cxx11">(since C++11)</span><br><span class="t-mark-rev t-until-cxx20">(until C++20)</span>
</td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <ul><li> no user-declared or inherited constructors </li></ul> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <ul>
<li> no <span class="t-rev-inl t-since-cxx17"><span>virtual, private, or protected</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> base classes </li>
<li> no virtual member functions </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11 t-until-cxx14">
<td> <ul><li> no <a href="data_members#Member_initialization" title="cpp/language/data members">default member initializers</a> </li></ul> </td> <td>
<span class="t-mark-rev t-since-cxx11">(since C++11)</span><br><span class="t-mark-rev t-until-cxx14">(until C++14)</span>
</td>
</tr> </table> <p>The effects of aggregate initialization are:</p>
<ul>
<li> Each <span class="t-rev-inl t-since-cxx17"><span>direct public base,</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> array element, or non-static class member, in order of array subscript/appearance in the class definition, is <a href="copy_initialization" title="cpp/language/copy initialization">copy-initialized</a> from the corresponding clause of the initializer list. </li>
<li> If the initializer clause is an expression, implicit conversions are allowed as per copy-initialization<span class="t-rev-inl t-since-cxx11"><span>, except that, for <a href="list_initialization" title="cpp/language/list initialization">list-initialization</a> form, narrowing conversions are prohibited</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>. </li>
<li> If the initializer clause is a nested braced-init-list (which is not an expression), the corresponding array element/class member<span class="t-rev-inl t-since-cxx17"><span>/public base</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> is <a href="list_initialization" title="cpp/language/list initialization">list-initialized</a> from that clause: aggregate initialization is recursive. </li>
<li> If the object is an array of unknown size, and the supplied brace-enclosed initializer list has <code>n</code> clauses, the size of the array is <code>n</code>. (Note that the object in this case cannot be a non-static data member: a member must have complete type.) </li>
<li> Static data members and unnamed bit-fields are skipped during aggregate initialization. </li>
<li> If the number of initializer clauses exceeds the number of members <span class="t-rev-inl t-since-cxx17"><span>and bases</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> to initialize, the program is ill-formed. </li>
</ul>      <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <ul><li> If the number of initializer clauses is less than the number of members or initializer list is completely empty, the remaining members are <a href="value_initialization" title="cpp/language/value initialization">value-initialized</a>. If a member of a reference type is one of these remaining members, the program is ill-formed. </li></ul> </td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <ul><li> If the number of initializer clauses is less than the number of members <span class="t-rev-inl t-since-cxx17"><span>and bases</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> or initializer list is completely empty, the remaining members <span class="t-rev-inl t-since-cxx17"><span>and bases</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> are <span class="t-rev-inl t-since-cxx14"><span>initialized by their <a href="data_members#Member_initialization" title="cpp/language/data members">default member initializers</a>, if provided in the class definition, and otherwise</span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span> copy-initialized from empty lists, in accordance with the usual <a href="list_initialization" title="cpp/language/list initialization">list-initialization</a> rules (which performs value-initialization for non-class types and non-aggregate classes with default constructors, and aggregate initialization for aggregates). If a member of a reference type is one of these remaining members, the program is ill-formed. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <ul><li> When a union is initialized by aggregate initialization, only its first non-static data member is initialized. </li></ul> <p>The braces around the nested initializer lists may be elided (omitted), in which case as many initializer clauses as necessary are used to initialize every member or element of the corresponding subaggregate, and the subsequent initializer clauses are used to initialize the following members of the object. However, if the object has a sub-aggregate without any members (an empty struct, or a struct holding only static members), brace elision is not allowed, and an empty nested list <code>{}</code> must be used.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <h3 id="Designated_initializers"> Designated initializers</h3> <p>The syntax forms <span class="t-v">(3,4)</span> are known as designated initializers: each <span class="t-spar">designator</span> must name a direct non-static data member of T, and all <span class="t-spar">designator</span>s used in the expression must appear in the same order as the data members of T.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct A { int x; int y; int z; };
 
A a{.y = 2, .x = 1}; // error; designator order does not match declaration order
A b{.x = 1, .z = 2}; // ok, b.y initialized to 0</pre></div> <p>Each direct non-static data member named by the designated initializer is initialized from the corresponding brace-or-equals initializer that follows the designator. Narrowing conversions are prohibited.</p>
<p>Designated initializer can be used to initialize a <a href="union" title="cpp/language/union">union</a> into the state other than the first. Only one initializer may be provided for a union.</p>
<div class="cpp source-cpp"><pre data-language="cpp">union u { int a; const char* b; };
 
u f = {.b = "asdf"};         // OK, active member of the union is b
u g = {.a = 1, .b = "asdf"}; // Error, only one initializer may be provided</pre></div> <p>For a non-union aggregate, elements for which a designated initializer is not provided are initialized the same as described above for when the number of initializer clauses is less than the number of members (default member initializers where provided, empty list-initialization otherwise):</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct A
{
    string str;
    int n = 42;
    int m = -1;
};
 
A{.m = 21} // Initializes str with {}, which calls the default constructor
           // then initializes n with = 42
           // then initializes m with = 21</pre></div> <p>If the aggregate that is initialized with a designated initializer clause has an anonymous union member, the corresponding designated initializer must name one of the members of that anonymous union.</p>
<p>Note: out-of-order designated initialization, nested designated initialization, mixing of designated initializers and regular initializers, and designated initialization of arrays are all supported in the <a href="https://en.cppreference.com/w/c/language/struct_initialization" title="c/language/struct initialization">C programming language</a>, but are not allowed in C++.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct A { int x, y; };
struct B { struct A a; };
 
struct A a = {.y = 1, .x = 2}; // valid C, invalid C++ (out of order)
int arr[3] = {[1] = 5};        // valid C, invalid C++ (array)
struct B b = {.a.x = 0};       // valid C, invalid C++ (nested)
struct A a = {.x = 1, 2};      // valid C, invalid C++ (mixed)</pre></div> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <h3 id="Character_arrays"> Character arrays</h3> <p>Arrays of ordinary character types (<code>char</code>, <code>signed char</code>, <code>unsigned char</code>)<span class="t-rev-inl t-since-cxx20"><span>, <code>char8_t</code></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>, <code>char16_t</code>, <code>char32_t</code></span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>, or <code>wchar_t</code> can be initialized from ordinary <a href="string_literal" title="cpp/language/string literal">string literals</a><span class="t-rev-inl t-since-cxx20"><span>, UTF-8 string literals</span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>, UTF-16 string literals, UTF-32 string literals</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>, or wide string literals, respectively, optionally enclosed in braces. Successive characters of the string literal (which includes the implicit terminating null character) initialize the elements of the array. If the size of the array is specified and it is larger than the number of characters in the string literal, the remaining characters are zero-initialized.</p>
<div class="cpp source-cpp"><pre data-language="cpp">char a[] = "abc";
// equivalent to char a[4] = {'a', 'b', 'c', '\0'};
 
//  unsigned char b[3] = "abc"; // Error: initializer string too long
unsigned char b[5]{"abc"};
// equivalent to unsigned char b[5] = {'a', 'b', 'c', '\0', '\0'};
 
wchar_t c[] = {L"кошка"}; // optional braces
// equivalent to wchar_t c[6] = {L'к', L'о', L'ш', L'к', L'а', L'\0'};</pre></div> <h3 id="Notes"> Notes</h3> <p>An aggregate class or array may include non-aggregate <span class="t-rev-inl t-since-cxx17"><span>public bases</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>, members, or elements, which are initialized as described above (e.g. copy-initialization from the corresponding initializer clause).</p>
<p>Until C++11, narrowing conversions were permitted in aggregate initialization, but they are no longer allowed, except that, as of C++20, narrowing conversions are allowed when aggregate initialization uses parentheses rather than braces.</p>
<p>Until C++11, aggregate initialization could only be used in variable definition, and could not be used in a <a href="constructor" title="cpp/language/constructor">constructor initializer list</a>, a <a href="new" title="cpp/language/new">new-expression</a>, or temporary object creation due to syntax restrictions.</p>
<p>In C, character array of size one less than the size of the string literal may be initialized from a string literal; the resulting array is not null-terminated. This is not allowed in C++.</p>
<h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;string&gt;
#include &lt;array&gt;
#include &lt;cstdio&gt;
 
struct S
{
    int x;
 
    struct Foo
    {
        int i;
        int j;
        int a[3];
    } b;
};
 
int main()
{
    S s1 = {1, {2, 3, {4, 5, 6}}};
    S s2 = {1, 2, 3, 4, 5, 6};  // same, but with brace elision
    S s3{1, {2, 3, {4, 5, 6}}}; // same, using direct-list-initialization syntax
    S s4{1, 2, 3, 4, 5, 6}; // error until CWG 1270:
                            // brace elision only allowed with equals sign
 
    int ar[] = {1, 2, 3}; // ar is int[3]
    int ab[] (1, 2, 3);   // (C++20) ab is int[3]
//  char cr[3] = {'a', 'b', 'c', 'd'}; // too many initializer clauses
    char cr[3] = {'a'}; // array initialized as {'a', '\0', '\0'}
 
    int ar2d1[2][2] = {{1, 2}, {3, 4}}; // fully-braced 2D array: {1, 2}
                                        //                        {3, 4}
    int ar2d2[2][2] = {1, 2, 3, 4}; // brace elision: {1, 2}
                                    //                {3, 4}
    int ar2d3[2][2] = {{1}, {2}};   // only first column: {1, 0}
                                    //                    {2, 0}
 
    std::array&lt;int, 3&gt; std_ar2{{1, 2, 3}};  // std::array is an aggregate
    std::array&lt;int, 3&gt; std_ar1 = {1, 2, 3}; // brace-elision okay
 
//  int ai[] = {1, 2.0}; // narrowing conversion from double to int:
                         // error in C++11, okay in C++03
 
    std::string ars[] = {std::string("one"), // copy-initialization
                         "two",              // conversion, then copy-initialization
                         {'t', 'h', 'r', 'e', 'e'}}; // list-initialization
    union U
    {
        int a;
        const char* b;
    };
    U u1 = {1};         // OK, first member of the union
//  U u2 = {0, "asdf"}; // error: too many initializers for union
//  U u3 = {"asdf"};    // error: invalid conversion to int
 
    [](auto...) { std::puts("Garbage unused variables... Done."); }
    (
        s1, s2, s3, s4, ar, ab, cr, ar2d1, ar2d2, ar2d3, std_ar2, std_ar1, u1
    );
}
 
// aggregate
struct base1 { int b1, b2 = 42; };
 
// non-aggregate
struct base2
{
    base2() : b3(42) {}
 
    int b3;
};
 
// aggregate in C++17
struct derived : base1, base2 { int d; };
 
derived d1{{1, 2}, {}, 4}; // d1.b1 = 1, d1.b2 = 2,  d1.b3 = 42, d1.d = 4
derived d2{{}, {}, 4};     // d2.b1 = 0, d2.b2 = 42, d2.b3 = 42, d2.d = 4</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">Garbage unused variables... Done.</pre></div> </div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/737.html">CWG 737</a> </td> <td> C++98 </td> <td> when a character array is initialized with a string literal<br>having fewer characters than the array size, the character<br>elements after the trailing <code>'\0'</code> was uninitialized </td> <td> they are zero-initialized </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1270.html">CWG 1270</a> </td> <td> C++11 </td> <td> brace elision was only allowed to be used in copy-list-initialization </td> <td> allowed elsewhere </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1518.html">CWG 1518</a> </td> <td> C++11 </td> <td> a class that declares an explicit default constructor or<br>has inherited constructors should could be an aggregate </td> <td> it is not an aggregate </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <ul>
<li> <a href="copy_elision" title="cpp/language/copy elision">copy elision</a> </li>
<li> <a href="initialization" title="cpp/language/initialization">initialization</a> <ul>
<li> <a href="constant_initialization" title="cpp/language/constant initialization">constant initialization</a> </li>
<li> <a href="list_initialization" title="cpp/language/list initialization">list initialization</a> </li>
<li> <a href="reference_initialization" title="cpp/language/reference initialization">reference initialization</a> </li>
<li> <a href="value_initialization" title="cpp/language/value initialization">value initialization</a> </li>
<li> <a href="zero_initialization" title="cpp/language/zero initialization">zero initialization</a> </li>
</ul> </li>
</ul> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/struct_initialization" title="c/language/struct initialization">C documentation</a></span> for <span class=""><span>Struct and union initialization</span></span> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization" class="_attribution-link">https://en.cppreference.com/w/cpp/language/aggregate_initialization</a>
  </p>
</div>
