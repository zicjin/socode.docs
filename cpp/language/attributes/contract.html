   <h1 id="firstHeading" class="firstHeading">C++ attribute: expects, ensures, assert <span class="t-mark-rev t-since-cxx20">(C++20)</span>
</h1>            <p>Specifies preconditions, postconditions, and assertions for functions.</p>
<h3 id="Syntax">Syntax</h3> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>[[</code> <code>expects</code> <span class="t-spar">contract-level</span><span class="t-mark">(optional)</span> <code>:</code> <span class="t-spar">expression</span> <code>]]</code> </td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>[[</code> <code>ensures</code> <span class="t-spar">contract-level</span><span class="t-mark">(optional)</span> <span class="t-spar">identifier</span><span class="t-mark">(optional)</span> <code>:</code> <span class="t-spar">expression</span> <code>]]</code> </td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>[[</code> <code>assert</code> <span class="t-spar">contract-level</span><span class="t-mark">(optional)</span> <code>:</code> <span class="t-spar">expression</span> <code>]]</code> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr> 
</table> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">contract-level</span> </td> <td> - </td> <td> one of <code>default</code>, <code>audit</code>, or <code>axiom</code>; the default is <code>default</code> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">identifier</span> </td> <td> - </td> <td> an identifier that is taken to denote the return value of the function; any ambiguity on whether something is a <span class="t-spar">contract-level</span> or an <span class="t-spar">identifier</span> is resolved in favor of it being a <span class="t-spar">contract-level</span> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">expression</span> </td> <td> - </td> <td> an expression, <a href="../implicit_cast#Contextual_conversions" title="cpp/language/implicit cast" class="mw-redirect">contextually converted to <code>bool</code></a>, that specifies the predicate of the contract; its top-level operator may not be an assignment or comma operator </td>
</tr>
</table> <h3 id="Explanation"> Explanation </h3> <div class="t-li1">
<span class="t-li">1)</span> Defines a <i>precondition</i>, i.e., the function's expectation of its arguments and/or the state of other objects upon entry into the function. This attribute may be applied to the function type in a function declaration. A precondition is checked by evaluating its predicate immediately before starting evaluation of the function body (including the member initializer list of a constructor). Multiple preconditions of the same function are checked in lexical order. </div> <div class="t-li1">
<span class="t-li">2)</span> Defines a <i>postcondition</i>, i.e., a condition that a function should ensure for the return value and/or the state of objects upon exit from the function. This attribute may be applied to the function type in a function declaration. The <span class="t-spar">identifier</span>, if present, represents the glvalue result or the prvalue result object of the function, as applicable. A postcondition is checked by evaluating its predicate immediately before returning control to the caller of the function (after the lifetime of local variables and temporaries have ended). Multiple postconditions of the same function are checked in lexical order.</div> <div class="t-li1">
<span class="t-li">3)</span> Defines an <i>assertion</i>, i.e., a condition that should be satisfied where it appears in a function body. This attribute may be applied to a <a href="../statements#Expression_statements" title="cpp/language/statements">null statement</a>. An assertion is checked by evaluating its predicate as part of the evaluation of the null statement it applies to.</div> <p>The <span class="t-spar">expression</span> in a contract attribute, contextually converted to <code>bool</code>, is called its <i>predicate</i>. Evaluation of the predicate must not have any side effects other than modification of non-volatile objects whose lifetimes begin and end within that evaluation; otherwise the behavior is undefined. If the evaluation of a predicate exits via an exception, <code><a href="../../error/terminate" title="cpp/error/terminate">std::terminate</a></code> is called.</p>
<p>During constant expression evaluation, only predicates of checked contracts are evaluated. In all other contexts, it is unspecified whether the predicate of a contract that is not checked is evaluated; the behavior is undefined if it would evaluate to <code>false</code>.</p>
<h4 id="Contract_conditions"> Contract conditions </h4> <p>Preconditions and postconditions are collectively called <i>contract conditions</i>. These attributes may be applied to the function type in a function declaration:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int f(int i) [[expects: i &gt; 0]] [[ensures audit x: x &lt; 1]]; 
 
int (*fp)(int i) [[expects: i &gt; 0]]; // error: not a function declaration</pre></div> <p>The first declaration of a function must specify all contract conditions (if any) of the function. Subsequent redeclarations must either specify no contract conditions or the same list of contract conditions; no diagnostic is required if corresponding conditions will always evaluate to the same value. If the same function is declared in two different translation units, the list of contract conditions shall be the same; no diagnostic is required.</p>
<p>Two lists of contract conditions are the same if they contain the same contract conditions in the same order. Two contract conditions are the same if they are the same kind of contract condition and have the same <span class="t-spar">contract-level</span> and the same predicate. Two predicates are the same if they would satisfy the <a href="../definition#One_Definition_Rule" title="cpp/language/definition">one-definition rule</a> were they to appear in function definitions, except for the renaming of function and template parameters and return value identifiers (if any).</p>
<div class="cpp source-cpp"><pre data-language="cpp">int f(int i) [[expects: i &gt; 0]];
int f(int);                       // OK, redeclaration
int f(int j) [[expects: j &gt; 0]];  // OK, redeclaration
int f(int k) [[expects: k &gt; 1]];  // ill-formed
int f(int l) [[expects: 0 &lt; l]];  // ill-formed, no diagnostic required</pre></div> <p>If a friend declaration is the first declaration of the function in a translation unit and has a contract condition, that declaration must be a definition and must be the only declaration of the function in the translation unit:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct C {
   bool ok() const;
   friend void f(const C&amp; c) [[ensures: c.ok()]]; // error, not a definition
   friend void g(C c) [[expects: c.ok()]] { } // OK
};
void g(C c); // error</pre></div> <p>The predicate of a contract condition has the same semantic restrictions as if it appeared as the first <a href="../statements#Expression_statements" title="cpp/language/statements">expression statement</a> in the body of the function it applies to.</p>
<p>If a postcondition <a href="../definition#ODR-use" title="cpp/language/definition">odr-uses</a> a parameter in its predicate and the function body modifies the value of that parameter directly or indirectly, the behavior is undefined.</p>
<div class="cpp source-cpp"><pre data-language="cpp">int f(int x) [[ensures r: r == x]]
{
  return ++x; // undefined behavior
}
int g(int* p) [[ensures: p != nullptr]]
{
  *p = 42; // OK, p is not modified
}
 
bool meow(const int&amp;) { return true; }
 
void h(int x) [[ensures: meow(x)]] 
{
  ++x;  // undefined behavior
}
 
void i(int&amp; x) [[ensures: meow(x)]]
{
  ++x;  // OK; the "value" of a reference is its referent and cannot be modified
}</pre></div> <p>For templated functions with deduced return types, the return value may be named in a postcondition without additional restrictions (except that the name of the return value is treated as having a <a href="../dependent_name#Type-dependent_expressions" title="cpp/language/dependent name">dependent type</a>). For the non-templated functions with deduced return types, naming the return value is prohibited in declarations (but allowed in the definitions):</p>
<div class="cpp source-cpp"><pre data-language="cpp">auto h(int x) [[ensures res: true]]; // error: return value with deduced type
                                     // on a non-template function declaration</pre></div> <h4 id="Build_level_and_violation_handling"> Build level and violation handling </h4> <p>A program may be translated with one of three <i>build levels</i>:</p>
<ul>
<li> <i>off</i>: no contract checking is performed. </li>
<li> <i>default</i> (default if no build level is selected): checking is performed for contracts whose <span class="t-spar">contract-level</span> is <code>default</code>. </li>
<li> <i>audit</i>: checking is performed for contracts whose <span class="t-spar">contract-level</span> is <code>default</code> or <code>audit</code>. </li>
</ul> <p>The mechanism for selecting the build level is implementation-defined. Combining translation units that were translated at different build levels is conditionally-supported.</p>
<p>The <i>violation handler</i> for a program is a function of type <code><span class="kw4">void</span> <span class="br0">(</span><span class="kw4">const</span> <a href="../../error/contract_violation"><span class="kw2748">std::<span class="me2">contract_violation</span></span></a> <span class="sy3">&amp;</span><span class="br0">)</span></code> (optionally <code>noexcept</code>), specified in an implementation-defined manner. It is invoked when the predicate of a checked contract evaluates to <code>false</code>.</p>
<ul>
<li> If a precondition is violated, the source location reflected in the <code>std::contract_violation</code> argument is implementation-defined. </li>
<li> If a postcondition is violated, the source location reflected in the <code>std::contract_violation</code> argument is the source location of the function definition. </li>
<li> If an assertion is violated, the source location reflected in the <code>std::contract_violation</code> argument is the source location of the statement to which the assertion is applied. </li>
</ul> <p>The value of the <code>std::contract_violation</code> argument passed to the violation handler is otherwise implementation-defined.</p>
<p>If a violation handler exits by throwing an exception and a contract is violated on a call to a function with a non-throwing exception specification, <code><a href="../../error/terminate" title="cpp/error/terminate">std::terminate</a></code> is called:</p>
<div class="cpp source-cpp"><pre data-language="cpp"> 
void f(int x) noexcept [[expects: x &gt; 0]];
void g() {
    f(0); // terminate if the violation handler throws
}</pre></div> <p>A program may be translated with one of two <i>violation continuation modes</i>:</p>
<ul>
<li> <i>off</i> (default if no continuation mode is selected): after the execution of the violation handler completes, <code><a href="../../error/terminate" title="cpp/error/terminate">std::terminate</a></code> is called; </li>
<li> <i>on</i>: after the execution of the violation handler completes, execution continues normally. </li>
</ul> <p>Implementations are encouraged to not provide any programmatic way to query, set, or modify the build level or to set or modify the violation handler.</p>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/attributes/contract" class="_attribution-link">http://en.cppreference.com/w/cpp/language/attributes/contract</a>
  </p>
</div>
