    <h1 id="firstHeading" class="firstHeading">Explicit type conversion</h1>            <p>Converts between types using a combination of explicit and implicit conversions.</p>
<h3 id="Syntax"> Syntax</h3> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>(</code> <span class="t-spar">new-type</span> <code>) </code> <span class="t-spar">expression</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">new-type</span> <code>(</code> <span class="t-spar">expression</span> <code>)</code> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">new-type</span> <code>(</code> <span class="t-spar">arg1, arg2, ...</span> <code>)</code> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">new-type</span> <code>(</code> <code>)</code> </td> <td> (4) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">new-type</span> <code>{</code> <span class="t-spar">arg1, arg2, ...</span><span class="t-mark">(optional)</span> <code>}</code> </td> <td> (5) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">template-name</span> <code>(</code> <span class="t-spar">arg1, arg2, ...</span><span class="t-mark">(optional)</span> <code>) </code> </td> <td> (6) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">template-name</span> <code>{</code> <span class="t-spar">arg1, arg2, ...</span><span class="t-mark">(optional)</span> <code>}</code> </td> <td> (7) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>auto</code> <code>(</code> <span class="t-spar">expression</span> <code>)</code> </td> <td> (8) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>auto</code> <code>{</code> <span class="t-spar">expression</span> <code>}</code> </td> <td> (9) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td>
</tr> 
</table> <p>Returns a value of type <span class="t-spar">new-type</span>.</p>
<h3 id="Explanation"> Explanation</h3> <div class="t-li1">
<span class="t-li">1)</span> When the <i>C-style cast expression</i> is encountered, the compiler attempts to interpret it as the following cast expressions, in this order:</div> <div class="t-li2">
<span class="t-li">a)</span> <code><a href="const_cast" title="cpp/language/const cast">const_cast</a>&lt;<span class="t-spar">new-type</span>&gt;(<span class="t-spar">expression</span>)</code>;</div> <div class="t-li2">
<span class="t-li">b)</span> <code><a href="static_cast" title="cpp/language/static cast">static_cast</a>&lt;<span class="t-spar">new-type</span>&gt;(<span class="t-spar">expression</span>)</code>, with extensions: pointer or reference to a <a href="derived_class" title="cpp/language/derived class">derived class</a> is additionally allowed to be cast to pointer or reference to unambiguous base class (and vice versa) even if the base class is <a href="access" title="cpp/language/access">inaccessible</a> (that is, this cast ignores the private inheritance specifier). Same applies to casting <a href="pointer" title="cpp/language/pointer">pointer to member</a> to pointer to member of unambiguous non-virtual base;</div> <div class="t-li2">
<span class="t-li">c)</span> <code>static_cast</code> (with extensions) followed by <code>const_cast</code>;</div> <div class="t-li2">
<span class="t-li">d)</span> <code><a href="reinterpret_cast" title="cpp/language/reinterpret cast">reinterpret_cast</a>&lt;<span class="t-spar">new-type</span>&gt;(<span class="t-spar">expression</span>)</code>;</div> <div class="t-li2">
<span class="t-li">e)</span> <code>reinterpret_cast</code> followed by <code>const_cast</code>.</div> <div class="t-li1">
 The first choice that satisfies the requirements of the respective cast operator is selected, even if it cannot be compiled (see example). If the cast can be interpreted in more than one way as <code>static_cast</code> followed by a <code>const_cast</code>, it cannot be compiled.</div> <div class="t-li1">
 In addition, C-style cast notation is allowed to cast from, to, and between pointers to incomplete class type. If both <span class="t-spar">expression</span> and <span class="t-spar">new-type</span> are pointers to incomplete class types, it's unspecified whether <code>static_cast</code> or <code>reinterpret_cast</code> gets selected.</div> <div class="t-li1">
<span class="t-li">2)</span> The <i>functional cast expression</i> consists of a simple type specifier or a typedef specifier (in other words, a single-word type name: <code>unsigned int(expression)</code> or <code>int*(expression)</code> are not valid), followed by a single expression in parentheses. This cast expression is exactly equivalent to the corresponding C-style cast expression.</div> <div class="t-li1">
<span class="t-li">3)</span> If there are more than one expression <span class="t-rev-inl t-since-cxx11"><span>or <a href="list_initialization" title="cpp/language/list initialization">braced-init-list</a></span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> in parentheses, <span class="t-spar">new-type</span> must be a class with a suitably declared <a href="constructor" title="cpp/language/constructor">constructor</a>. This expression is a prvalue of type <span class="t-spar">new-type</span> <span class="t-rev-inl t-until-cxx17"><span>designating a temporary</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span>whose result object is</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> <a href="direct_initialization" title="cpp/language/direct initialization">direct-initialized</a> with <span class="t-spar">expression-list</span>.</div> <div class="t-li1">
<span class="t-li">4)</span> If <span class="t-spar">new-type</span> names a non-array complete object type, this expression is an prvalue of type <span class="t-spar">new-type</span>, <span class="t-rev-inl t-until-cxx17"><span>designating a temporary</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span>whose result object is (possibly with added cv-qualifiers)</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> of that type. If <span class="t-spar">new-type</span> is an object type, the object is <a href="value_initialization" title="cpp/language/value initialization">value-initialized</a>. If <span class="t-spar">new-type</span> is (possibly <a href="cv" title="cpp/language/cv">cv-qualified</a>) <code>void</code>, the expression is a <code>void</code> prvalue <span class="t-rev-inl t-since-cxx17"><span>without a result object</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>.</div> <div class="t-li1">
<span class="t-li">5)</span> A single-word type name followed by a <i>braced-init-list</i> is a prvalue of the specified type <span class="t-rev-inl t-until-cxx17"><span>designating a temporary</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span>whose result object is</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> <a href="list_initialization" title="cpp/language/list initialization">direct-list-initialized</a> with the specified <i>braced-init-list</i>. If <span class="t-spar">new-type</span> is (possibly <a href="cv" title="cpp/language/cv">cv-qualified</a>) <code>void</code>, the expression is a <code>void</code> prvalue <span class="t-rev-inl t-since-cxx17"><span>without a result object</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>. <span class="t-rev-inl t-until-cxx20"><span> This is the only cast expression that can create an <a href="array#Array_rvalues" title="cpp/language/array">array prvalue</a>.</span> <span><span class="t-mark-rev t-until-cxx20">(until C++20)</span></span></span>
</div> <div class="t-li1">
<span class="t-li">6,7)</span> Same as <span class="t-v">(2-5)</span>, except first performs <a href="class_template_argument_deduction" title="cpp/language/class template argument deduction">class template argument deduction</a>.</div> <div class="t-li1">
<span class="t-li">8,9)</span> The <a href="auto" title="cpp/language/auto"><code>auto</code></a> specifier is replaced with the deduced type of the invented variable <code>x</code> declared with <code>auto x(expression);</code> (which is never interpreted as a function declaration) or <code>auto x{expression};</code> respectively. The result is always a prvalue of an object type.</div> <p>As with all cast expressions, the result is:</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <ul>
<li> an lvalue if <span class="t-spar">new-type</span> is a reference type; </li>
<li> an rvalue otherwise. </li>
</ul> </td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <ul>
<li> an lvalue if <span class="t-spar">new-type</span> is an lvalue reference type or an rvalue reference to function type; </li>
<li> an xvalue if <span class="t-spar">new-type</span> is an rvalue reference to object type; </li>
<li> a prvalue otherwise. </li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">double f = 3.14;
unsigned int n1 = (unsigned int)f; // C-style cast
unsigned int n2 = unsigned(f);     // functional cast
 
class C1;
class C2;
C2* foo(C1* p)
{
    return (C2*)p; // casts incomplete type to incomplete type
}
 
// In this example, C-style cast is interpreted as static_cast
// even though it would work as reinterpret_cast
struct A {};
struct I1 : A {};
struct I2 : A {};
struct D : I1, I2 {};
 
int main()
{
    D* d = nullptr;
//  A* a = (A*)d;                   // compile-time error
    A* a = reinterpret_cast&lt;A*&gt;(d); // this compiles
}</pre></div> </div> <h3 id="References"> References</h3>  <ul>
<li> C++20 standard (ISO/IEC 14882:2020): </li>
<ul>
<li> 7.6.1.4 Explicit type conversion (functional notation) [expr.type.conv] </li>
<li> 7.6.3 Explicit type conversion (cast notation) [expr.cast] </li>
</ul>
<li> C++17 standard (ISO/IEC 14882:2017): </li>
<ul>
<li> 8.2.3 Explicit type conversion (functional notation) [expr.type.conv] </li>
<li> 8.4 Explicit type conversion (cast notation) [expr.cast] </li>
</ul>
<li> C++14 standard (ISO/IEC 14882:2014): </li>
<ul>
<li> 5.2.3 Explicit type conversion (functional notation) [expr.type.conv] </li>
<li> 5.4 Explicit type conversion (cast notation) [expr.cast] </li>
</ul>
<li> C++11 standard (ISO/IEC 14882:2011): </li>
<ul>
<li> 5.2.3 Explicit type conversion (functional notation) [expr.type.conv] </li>
<li> 5.4 Explicit type conversion (cast notation) [expr.cast] </li>
</ul>
<li> C++03 standard (ISO/IEC 14882:2003): </li>
<ul>
<li> 5.2.3 Explicit type conversion (functional notation) [expr.type.conv] </li>
<li> 5.4 Explicit type conversion (cast notation) [expr.cast] </li>
</ul>
<li> C++98 standard (ISO/IEC 14882:1998): </li>
<ul>
<li> 5.2.3 Explicit type conversion (functional notation) [expr.type.conv] </li>
<li> 5.4 Explicit type conversion (cast notation) [expr.cast] </li>
</ul>
</ul>                             <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <a href="const_cast" title="cpp/language/const cast"> <code>const_cast</code> conversion </a> </td> <td> adds or removes const </td>
</tr> <tr class="t-dsc"> <td> <a href="static_cast" title="cpp/language/static cast"> <code>static_cast</code> conversion </a> </td> <td> performs basic conversions </td>
</tr> <tr class="t-dsc"> <td> <a href="dynamic_cast" title="cpp/language/dynamic cast"> <code>dynamic_cast</code> conversion </a> </td> <td> performs checked polymorphic conversions </td>
</tr> <tr class="t-dsc"> <td> <a href="reinterpret_cast" title="cpp/language/reinterpret cast"> <code>reinterpret_cast</code> conversion </a> </td> <td> performs general low-level conversions </td>
</tr> <tr class="t-dsc"> <td> <a href="implicit_cast" title="cpp/language/implicit cast" class="mw-redirect"> standard conversions </a> </td> <td> implicit conversions from one type to another </td>
</tr> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/cast" title="c/language/cast">C documentation</a></span> for <span class=""><span>cast operator</span></span> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/explicit_cast" class="_attribution-link">https://en.cppreference.com/w/cpp/language/explicit_cast</a>
  </p>
</div>
