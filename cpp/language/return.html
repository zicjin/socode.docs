   <h1 id="firstHeading" class="firstHeading">return statement</h1>            <p>Terminates the current function and returns the specified value (if any) to its caller.</p>
<h3 id="Syntax">Syntax</h3> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">attr</span><span class="t-mark">(optional)</span> <code>return</code> <span class="t-spar">expression</span><span class="t-mark">(optional)</span> <code>;</code> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">attr</span><span class="t-mark">(optional)</span> <code>return</code> <span class="t-spar">braced-init-list</span> <code>;</code> </td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">attr</span><span class="t-mark">(optional)</span> <code>co_return</code> <span class="t-spar">expression</span><span class="t-mark">(optional)</span> <code>;</code> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">attr</span><span class="t-mark">(optional)</span> <code>co_return</code> <span class="t-spar">braced-init-list</span> <code>;</code> </td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr> 
</table> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">attr</span><span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> - </td> <td> optional sequence of any number of <a href="attributes" title="cpp/language/attributes">attributes</a> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">expression</span> </td> <td> - </td> <td> <a href="expressions" title="cpp/language/expressions">expression</a>, convertible to the function return type </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">braced-init-list</span> </td> <td> - </td> <td> brace-enclosed list of initializers and other braced-init-lists </td>
</tr>
</table> <h3 id="Explanation">Explanation</h3> <div class="t-li1">
<span class="t-li">1)</span> Evaluates the <span class="t-spar">expression</span>, terminates the current function and returns the result of the <span class="t-spar">expression</span> to the caller, after <a href="implicit_cast" title="cpp/language/implicit cast" class="mw-redirect">implicit conversion</a> to the function return type. The <span class="t-spar">expression</span> is optional in functions whose return type is (possibly cv-qualified) <code>void</code>, and disallowed in constructors and in destructors.</div> <div class="t-li1">
<span class="t-li">2)</span> Uses <a href="list_initialization" title="cpp/language/list initialization">copy-list-initialization</a> to construct the return value of the function.</div> <div class="t-li1">
<span class="t-li">3,4)</span> In a coroutine, the keyword <code>co_return</code> must be used instead of <code>return</code> for the final suspension point (see <a href="coroutines" title="cpp/language/coroutines">coroutines</a> for details).</div> <h3 id="Notes">Notes</h3> <p>If control reaches the end of a function with the return type <code>void</code> (possibly cv-qualified), end of a constructor, end of a destructor, or the end of a <a href="function-try-block" title="cpp/language/function-try-block">function-try-block</a> for a function with the return type (possibly cv-qualified) <code>void</code> without encountering a return statement, <code>return;</code> is executed.</p>
<p>If control reaches the end of the <a href="main_function" title="cpp/language/main function">main function</a>, <code>return 0;</code> is executed.</p>
<p>Flowing off the end of a value-returning function (except <code>main</code>) without a return statement is undefined behavior.</p>
<p>In a function returning <code>void</code>, the return statement with <span class="t-spar">expression</span> can be used, if the expression type is <code>void</code>.</p>
<p>Returning by value may involve construction and copy/move of a temporary object, unless <a href="copy_elision" title="cpp/language/copy elision">copy elision</a> is used. Specifically, the conditions for copy/move are as follows:</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>If <span class="t-spar">expression</span> is an lvalue expression that is the (possibly parenthesized) name of an automatic storage duration object declared in the body or as a parameter of the innermost enclosing function or lambda expression, then <a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a> to select the constructor to use for initialization of the returned value <span class="t-rev-inl t-since-cxx20"><span>or, for <code>co_return</code>, to select the overload of <code>promise.return_value()</code></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> is performed <i>twice</i>: first as if <span class="t-spar">expression</span> were an rvalue expression (thus it may select the move constructor), and if no suitable conversion is available, or if the type of the first parameter of the selected constructor is not an rvalue reference to the object's type (possibly cv-qualified), overload resolution is performed a second time, with <span class="t-spar">expression</span> considered as an lvalue (so it may select the copy constructor taking a reference to non-const).</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx14">
<td> <p>The copy-initialization of the result of the function call is <a href="eval_order" title="cpp/language/eval order">sequenced-before</a> the destruction of all temporaries at the end of <span class="t-spar">expression</span>, which, in turn, is <i>sequenced-before</i> the destruction of local variables of the block enclosing the return statement.</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <p>If <span class="t-spar">expression</span> is a prvalue, the result object is initialized directly by that expression. This does not involve a copy or move constructor when the types match (see <a href="copy_elision" title="cpp/language/copy elision">copy elision</a>).</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <h3 id="Keywords">Keywords</h3> <p><a href="../keyword/return" title="cpp/keyword/return"><code>return</code></a>, <a href="../keyword/co_return" title="cpp/keyword/co return"><code>co_return</code></a>.</p>
<h3 id="Example">Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
 
void fa(int i)
{
    if (i == 2)
         return;
    std::cout &lt;&lt; i &lt;&lt; '\n';
} // implied return;
 
int fb(int i)
{
    if (i &gt; 4)
         return 4;
    std::cout &lt;&lt; i &lt;&lt; '\n';
    return 2;
}
 
std::pair&lt;std::string, int&gt; fc(const char* p, int x)
{
    return {p, x};
}
 
void fd()
{
    return fa(10); // fa(10) is a void expression
}
 
int main()
{
    fa(2); // returns, does nothing when i==2
    fa(1); // prints its argument, then returns
    int i = fb(5); // returns 4
    i = fb(i); // prints its argument, returns 2
    std::cout &lt;&lt; i &lt;&lt; '\n'
              &lt;&lt; fc("Hello", 7).second &lt;&lt; '\n';
    fd();
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">1
4
2
7
10</pre></div> </div> <h3 id="Defect_reports">Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/cwg1579">CWG 1579</a> </td> <td> C++11 </td> <td> return by converting move constructor was not allowed </td> <td> converting move constructor look up enabled </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/cwg1885">CWG 1885</a> </td> <td> C++14 </td> <td> sequencing of the destruction of automatic variables was not explicit </td> <td> sequencing rules added </td>
</tr>
</table> <h3 id="See_also">See also</h3>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/return" class="_attribution-link">http://en.cppreference.com/w/cpp/language/return</a>
  </p>
</div>
