   <h1 id="firstHeading" class="firstHeading">Lifetime</h1>            <p>Every <a href="objects" title="cpp/language/object">object</a> and <a href="reference" title="cpp/language/reference">reference</a> has a <i>lifetime</i>, which is a runtime property: for any object or reference, there is a point of execution of a program when its lifetime begins, and there is a moment when it ends.</p>
<ul>
<li> For any object of class or aggregate types if it, or any of its subobjects, is initialized by anything other than the <a href="default_constructor#Trivial_default_constructor" title="cpp/language/default constructor">trivial default constructor</a>, lifetime begins when initialization ends. </li>
<li> For any object of class types whose <a href="destructor#Trivial_destructor" title="cpp/language/destructor">destructor</a> is not trivial, lifetime ends when the execution of the destructor begins. </li>
<li> Lifetime of a member of a <a href="union" title="cpp/language/union">union</a> begins when that member is made active </li>
<li> For all other objects (class objects initialized by a trivial default constructor, non-class objects, arrays of those, etc.), lifetime begins when the properly-aligned storage for the object is allocated and ends when the storage is deallocated or reused by another object. </li>
</ul> <p>Lifetime of an object is equal to or is nested within the lifetime of its storage, see <a href="storage_duration" title="cpp/language/storage duration">storage duration</a>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx14">
<td> <p>Lifetime of a <a href="reference" title="cpp/language/reference">reference</a> is exactly its storage duration.</p>
</td> <td><span class="t-mark-rev t-until-cxx14">(until C++14)</span></td>
</tr>
<tr class="t-rev t-since-cxx14">
<td> <p>The lifetime of a <a href="reference" title="cpp/language/reference">reference</a> begins when its initialization is complete and ends as if it were a scalar object.</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <p>Note: the lifetime of the referred object may end before the end of the lifetime of the reference, which makes <a href="reference#Dangling_references" title="cpp/language/reference">dangling references</a> possible.</p>
<p>Lifetimes of member objects and base subobjects begin and end following <a href="constructor#Initialization_order" title="cpp/language/initializer list">class initialization order</a>.</p>
<h3 id="Temporary_object_lifetime">Temporary object lifetime</h3> <p>Temporary objects are created <span class="t-rev-inl t-since-cxx17"><span>when a prvalue is <a href="implicit_cast#Temporary_materialization" title="cpp/language/implicit conversion">materialized</a> so that it can be used as a glvalue, which occurs</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> in the following situations:</p>
<ul><li> <a href="reference_initialization" title="cpp/language/reference initialization">binding a reference to a prvalue</a> </li></ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <ul>
<li> returning a prvalue from a function </li>
<li> <a href="expressions#Conversions" title="cpp/language/expressions">conversion</a> that creates a prvalue (<a href="explicit_cast" title="cpp/language/explicit cast">including</a> <code>T(a,b,c)</code> and <code>T{}</code>) </li>
<li> <span class="t-rev-inl t-since-cxx11"><span> <a href="lambda" title="cpp/language/lambda">lambda expression</a>,</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> </li>
<li> <a href="copy_initialization" title="cpp/language/copy initialization">copy-initialization</a> that requires conversion of the initializer, </li>
<li> <span class="t-rev-inl t-since-cxx11"><span><a href="list_initialization" title="cpp/language/list initialization">list-initialization</a> that constructs an <code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code>,</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> </li>
<li> <a href="reference_initialization" title="cpp/language/reference initialization">reference-initialization</a> to a different but convertible type or to a bitfield. </li>
</ul> </td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <ul>
<li> when <a href="list_initialization" title="cpp/language/list initialization">initializing</a> an object of type <code><a href="../utility/initializer_list"><span class="kw955">std::<span class="me2">initializer_list</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span></code> from a braced-init-list </li>
<li> when performing <a href="operator_member_access#Built-in_member_access_operators" title="cpp/language/operator member access">member access</a> on a class prvalue </li>
<li> when performing an <a href="array#Array-to-pointer_decay" title="cpp/language/array">array-to-pointer</a> conversion or <a href="operator_member_access#Built-in_subscript_operator" title="cpp/language/operator member access">subscripting</a> on an array prvalue </li>
<li> for unevaluated operands in <a href="sizeof" title="cpp/language/sizeof">sizeof</a> and <a href="typeid" title="cpp/language/typeid">typeid</a> </li>
<li> when a prvalue appears as a <a href="expressions#Discarded-value_expressions" title="cpp/language/expressions">discarded-value expression</a> </li>
<li> if supported by the implementation, when passing or returning an object of trivially-copyable type in a <a href="operator_other#Built-in_function_call_operator" title="cpp/language/operator other">function call expression</a> (this models passing structs in CPU registers) </li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>The materialization of a temporary object is generally delayed as long as possible in order to avoid creating unnecessary temporary object: see <a href="copy_elision" title="cpp/language/copy elision">copy elision</a>.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <p>All temporary objects are destroyed as the last step in evaluating the full-expression that (lexically) contains the point where they were created, and if multiple temporary objects were created, they are destroyed in the order opposite to the order of creation. This is true even if that evaluation ends in throwing an exception.</p>
<p>There are two exceptions from that:</p>
<ul><li> The lifetime of a temporary object may be extended by binding to a const lvalue reference <span class="t-rev-inl t-since-cxx11"><span>or to an rvalue reference</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>, see <a href="reference_initialization#Lifetime_of_a_temporary" title="cpp/language/reference initialization">reference initialization</a> for details. </li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li> The lifetime of a temporary object created when evaluating the default arguments of a default constructor used to initialize an element of an array ends before the next element of the array begins initialization.</li></ul>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Storage_reuse">Storage reuse</h3> <p>A program is not required to call the destructor of an object to end its lifetime if the object is <a href="destructor#Trivial_destructor" title="cpp/language/destructor">trivially-destructible</a> or if the program does not rely on the side effects of the destructor. However, if a program ends the lifetime of an non-trivial object explicitly, it must ensure that a new object of the same type is constructed in-place (e.g. via placement new) before the destructor may be called implicitly, i.e. due to scope exit or exception for automatic objects, due to thread exit for thread-local objects, or due to program exit for static objects; otherwise the behavior is undefined.</p>
<div class="cpp source-cpp"><pre data-language="cpp">class T {}; // trivial
struct B {
    ~B() {} // non-trivial
};
void x() {
    long long n; // automatic, trivial
    new (&amp;n) double(3.14); // reuse with a different type okay
} // okay
void h() {
    B b; // automatic non-trivially destructible
    b.~B(); // end lifetime (not required, since no side-effects)
    new (&amp;b) T; // wrong type: okay until the destructor is called
} // destructor is called: undefined behavior</pre></div> <p>It is undefined behavior to reuse storage that is or was occupied by a const complete object of static, thread-local, or automatic storage duration because such objects may be stored in read-only memory.</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct B {
    B(); // non-trivial
    ~B(); // non-trivial
};
const B b; // const static
void h() {
    b.~B(); // end the lifetime of b
    new (const_cast&lt;B*&gt;(&amp;b)) const B; // undefined behavior: attempted reuse of a const
}</pre></div> <p>If a new object is created at the address that was occupied by another object, then all pointers, references, and the name of the original object will automatically refer to the new object and, once the lifetime of the new object begins, can be used to manipulate the new object, but only if the following conditions are satisfied:</p>
<ul>
<li> the storage for the new object exactly overlays the storage location which the original object occupied </li>
<li> the new object is of the same type as the original object (ignoring the top-level cv-qualifiers) </li>
<li> the type of the original object is not const-qualified </li>
<li> if the original object had class type, it does not contain any non-static data member whose type is const-qualified or a reference type </li>
<li> the original object was a most derived object of type T and the new object is a most derived object of type T (that is, they are not base class subobjects). </li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">struct C {
  int i;
  void f();
  const C&amp; operator=( const C&amp; );
};
const C&amp; C::operator=( const C&amp; other) {
  if ( this != &amp;other ) {
    this-&gt;~C();          // lifetime of *this ends
    new (this) C(other); // new object of type C created
    f();                 // well-defined
  }
  return *this;
}
C c1;
C c2;
c1 = c2; // well-defined
c1.f();  // well-defined; c1 refers to a new object of type C</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>If the conditions listed above are not met, a valid pointer to the new object may still be obtained by applying the pointer optimization barrier <a href="../utility/launder" title="cpp/utility/launder"><code>std::launder</code></a>.</p>
<p>Similarly, if an object is created in the storage of a class member or array element, the created object is only a subobject (member or element) of the original object's containing object if:</p>
<ul>
<li> the lifetime of the containing object has begun and not ended </li>
<li> the storage for the new object exactly overlays the storage of the original object </li>
<li> the new object is of the same type as the original object (ignoring cv-qualification). </li>
</ul> <p>Otherwise (such as if the subobject contains a reference member or a const subobject), the name of the original subobject cannot be used to access the new object without <code><a href="../utility/launder" title="cpp/utility/launder">std::launder</a></code>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct X { const int n; };
union U { X x; float f; };
void tong() {
  U u = { { 1 } };
  u.f = 5.f;                          // OK, creates new subobject of 'u'
  X *p = new (&amp;u.x) X {2};            // OK, creates new subobject of 'u'
  assert(p-&gt;n == 2);                  // OK
  assert(*std::launder(&amp;u.x.n) == 2); // OK
  assert(u.x.n == 2);                 // undefined: 'u.x' does not name the new subobject
}</pre></div> <p>As a special case, objects can be created in arrays of <code>unsigned char</code> or <a href="../types/byte" title="cpp/types/byte"><code>std::byte</code></a> (in which case it is said that the array <i>provides storage</i> for the object) if.</p>
<ul>
<li> the lifetime of the array has begun and not ended </li>
<li> the storage for the new object fits entirely within the array </li>
<li> there is no smaller array object that satisfies these constraints. </li>
</ul> <p>If that portion of the array previously provided storage for another object, the lifetime of that object ends because its storage was reused, however the lifetime of the array itself does not end (its storage is not considered to have been reused).</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename ...T&gt;
struct AlignedUnion {
  alignas(T...) unsigned char data[max(sizeof(T)...)];
};
int f() {
  AlignedUnion&lt;int, char&gt; au;
  int *p = new (au.data) int;     // OK, au.data provides storage
  char *c = new (au.data) char(); // OK, ends lifetime of *p
  char *d = new (au.data + 1) char();
  return *c + *d; // OK
}</pre></div> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <h3 id="Access_outside_of_lifetime">Access outside of lifetime</h3> <p>Before the lifetime of an object has started but after the storage which the object will occupy has been allocated or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, the following uses of the glvalue expression that identifies that object are undefined:</p>
<ol>
<li> Lvalue to rvalue conversion (e.g. function call to a function that takes a value). </li>
<li> Access to a non-static data member or a call to a non-static member function. </li>
<li> Binding a reference to a virtual base class subobject. </li>
<li> <code>dynamic_cast</code> or <code>typeid</code> expressions. </li>
</ol> <p>The above rules apply to pointers as well (binding a reference to virtual base is replaced by implicit conversion to a pointer to virtual base), with two additional rules:</p>
<ol>
<li> <a href="static_cast" title="cpp/language/static cast"><code>static_cast</code></a> of a pointer to storage without an object is only allowed when casting to (possibly cv-qualified) <code>void*</code>. </li>
<li> Pointers to storage without an object that were cast to possibly cv-qualified <code>void*</code> can only be <a href="static_cast" title="cpp/language/static cast"><code>static_cast</code></a> to pointers to possibly cv-qualified <code>char</code>, possibly cv-qualified <code>unsigned char</code>, or possibly cv-qualified <a href="../types/byte" title="cpp/types/byte"><code>std::byte</code></a>. </li>
</ol> <p>During construction and destruction, other restrictions apply, see <a href="virtual#During_construction_and_destruction" title="cpp/language/virtual">virtual function calls during construction and destruction</a>.</p>
<h3 id="Notes">Notes</h3> <p>The difference in the end of lifetime rules between non-class objects (end of storage duration) and class objects (reverse order of construction) matters in the following example:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct A {
  int* p;
  ~A() { std::cout &lt;&lt; *p; } // Well-defined and prints 123 because n outlives a
                            // would be undefined behavior if n did not outlive a
};
void f() {
  A a;
  int n = 123; // if n did not outlive a, this could have been optimized out (dead store)
  a.p = &amp;n;
}</pre></div> <p>At least one major implementation does not implement these rules and instead optimizes out the store to <code>n</code>. The lifetime rules are under reconsideration as <a rel="nofollow" class="external text" href="https://wg21.link/CWG2256">core issue 2256</a>.</p>
<h3 id="Defect_reports">Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/cwg2012">CWG 2012</a> </td> <td> C++14 </td> <td> lifetime of references was specified to match storage duration, requiring that<br>extern references are alive before their initializers run </td> <td> lifetime begins at initialization </td>
</tr>
</table> <h3 id="See_also">See also</h3>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/lifetime" class="_attribution-link">http://en.cppreference.com/w/cpp/language/lifetime</a>
  </p>
</div>
