   <h1 id="firstHeading" class="firstHeading">list initialization <span class="t-mark-rev t-since-cxx11">(since C++11)</span>
</h1>            <p>Initializes an object from braced-init-list.</p>
<h3 id="Syntax">Syntax</h3> <h4 id="direct-list-initialization">direct-list-initialization</h4> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">T</span> <span class="t-spar">object</span> <code>{ </code> <span class="t-spar">arg1, arg2, ...</span> <code>};</code> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">T</span> <code>{ </code> <span class="t-spar">arg1, arg2, ...</span> <code>}</code> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>new</code> <span class="t-spar">T</span> <code>{ </code> <span class="t-spar">arg1, arg2, ...</span> <code>}</code> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">Class</span> <code>{</code> <span class="t-spar">T</span> <span class="t-spar">member</span> <code>{ </code><span class="t-spar">arg1, arg2, ...</span> <code>}; };</code> </td> <td> (4) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">Class</span><code>::</code><span class="t-spar">Class</span><code>() : </code><span class="t-spar">member</span><code>{</code><span class="t-spar">arg1, arg2, ...</span><code>} {...</code> </td> <td> (5) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <h4 id="copy-list-initialization">copy-list-initialization</h4> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">T</span> <span class="t-spar">object</span> <code>= {</code><span class="t-spar">arg1, arg2, ...</span><code>};</code> </td> <td> (6) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">function</span><code>( { </code> <span class="t-spar">arg1, arg2, ...</span> <code>} )</code> </td> <td> (7) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>return { </code> <span class="t-spar">arg1, arg2, ...</span> <code>} ;</code> </td> <td> (8) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">object</span><code>[ { </code> <span class="t-spar">arg1, arg2, ...</span> <code>} ]</code> </td> <td> (9) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">object</span> <code>= </code> <code>{ </code> <span class="t-spar">arg1, arg2, ...</span> <code>}</code> </td> <td> (10) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">U</span><code>( { </code> <span class="t-spar">arg1, arg2, ...</span> <code>} )</code> </td> <td> (11) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">Class</span> <code>{</code> <span class="t-spar">T</span> <span class="t-spar">member</span> <code>=</code> <code>{ </code><span class="t-spar">arg1, arg2, ...</span> <code>}; };</code> </td> <td> (12) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>List initialization is performed in the following situations:</p>
<ul><li> direct-list-initialization (both explicit and non-explicit constructors are considered) </li></ul> <div class="t-li1">
<span class="t-li">1)</span> initialization of a named variable with a <i>braced-init-list</i> (that is, a possibly empty brace-enclosed list of expressions or nested braced-init-lists)</div> <div class="t-li1">
<span class="t-li">2)</span> initialization of an unnamed temporary with a <i>braced-init-list</i>
</div> <div class="t-li1">
<span class="t-li">3)</span> initialization of an object with dynamic storage duration with a <a href="new" title="cpp/language/new">new-expression</a>, where the initializer is a brace-init-list</div> <div class="t-li1">
<span class="t-li">4)</span> in a non-static <a href="data_members#Member_initialization" title="cpp/language/data members">data member initializer</a> that does not use the equals sign</div> <div class="t-li1">
<span class="t-li">5)</span> in a <a href="constructor" title="cpp/language/initializer list">member initializer list</a> of a constructor if <i>braced-init-list</i> is used</div> <ul><li> copy-list-initialization (both explicit and non-explicit constructors are considered, but only non-explicit constructors may be called) </li></ul> <div class="t-li1">
<span class="t-li">6)</span> initialization of a named variable with a <i>braced-init-list</i> after an equals sign</div> <div class="t-li1">
<span class="t-li">7)</span> in a function call expression, with <i>braced-init-list</i> used as an argument and list-initialization initializes the function parameter</div> <div class="t-li1">
<span class="t-li">8)</span> in a <code>return</code> statement with braced-init-list used as the return expression and list-initialization initializes the returned object</div> <div class="t-li1">
<span class="t-li">9)</span> in a <a href="operator_member_access#Built-in_subscript_operator" title="cpp/language/operator member access">subscript expression</a> with a user-defined <code>operator[]</code>, where list-initialization initializes the parameter of the overloaded operator</div> <div class="t-li1">
<span class="t-li">10)</span> in an <a href="operator_assignment" title="cpp/language/operator assignment">assignment expression</a>, where list-initialization initializes the parameter of the overloaded operator</div> <div class="t-li1">
<span class="t-li">11)</span> <a href="explicit_cast" title="cpp/language/explicit cast">functional cast expression</a> or other constructor invocations, where <i>braced-init-list</i> is used in place of a constructor argument. Copy-list-initialization initializes the constructor's parameter (note; the type U in this example is not the type that's being list-initialized; U's constructor's parameter is)</div> <div class="t-li1">
<span class="t-li">12)</span> in a non-static <a href="data_members#Member_initialization" title="cpp/language/data members">data member initializer</a> that uses the equals sign</div> <h3 id="Explanation">Explanation</h3> <p>The effects of list initialization of an object of type <code>T</code> are:</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <ul>
<li> If <code>T</code> is an aggregate type and the initializer list has a single element of the same or derived type (possibly cv-qualified), the object is initialized from that element (by <a href="copy_initialization" title="cpp/language/copy initialization">copy-initialization</a> for copy-list-initialization, or by <a href="direct_initialization" title="cpp/language/direct initialization">direct-initialization</a> for direct-list-initialization). </li>
<li> Otherwise, if <code>T</code> is a character array and the initializer list has a single element that is an appropriately-typed string literal, the array is <a href="aggregate_initialization#Character_arrays" title="cpp/language/aggregate initialization">initialized from the string literal as usual</a>. </li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx14">
<td> <ul>
<li> If the braced-init-list is empty and <code>T</code> is a class type with a default constructor, <a href="value_initialization" title="cpp/language/value initialization">value-initialization</a> is performed. </li>
<li> Otherwise, if <code>T</code> is an <a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate type</a>, <a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate initialization</a> is performed. </li>
</ul>  </td> <td><span class="t-mark-rev t-until-cxx14">(until C++14)</span></td>
</tr> <tr class="t-rev t-since-cxx14">
<td> <ul>
<li> If <code>T</code> is an <a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate type</a>, <a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate initialization</a> is performed. </li>
<li> Otherwise, If the braced-init-list is empty and <code>T</code> is a class type with a default constructor, <a href="value_initialization" title="cpp/language/value initialization">value-initialization</a> is performed. </li>
</ul>  </td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <ul>
<li> Otherwise, if <code>T</code> is a specialization of <code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code>, the <code>T</code> object is direct-initialized or copy-initialized, depending on context, from <span class="t-rev-inl t-until-cxx17"><span>a prvalue of the same type initialized from</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span> the braced-init-list. </li>
<li> Otherwise, the constructors of <code>T</code> are considered, in two phases: </li>
<ul>
<li> All constructors that take <code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code> as the only argument, or as the first argument if the remaining arguments have default values, are examined, and matched by <a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a> against a single argument of type <code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code> </li>
<li> If the previous stage does not produce a match, all constructors of <code>T</code> participate in <a href="overload_resolution#Implicit_conversion_sequence_in_list-initialization" title="cpp/language/overload resolution">overload resolution</a> against the set of arguments that consists of the elements of the braced-init-list, with the restriction that only non-narrowing conversions are allowed. If this stage produces an explicit constructor as the best match for a copy-list-initialization, compilation fails (note, in simple copy-initialization, explicit constructors are not considered at all). </li>
</ul>
</ul>    <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul><li> Otherwise, if <code>T</code> is a <a href="enum" title="cpp/language/enum">enumeration type</a> that is either scoped or unscoped with fixed underlying type, and if the braced-init-list has only one initializer, and if the conversion from the initializer to the underlying type is non-narrowing, and if the initialization is direct-list-initialization, then the enumeration is initialized with the result of converting the initializer to its underlying type. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <ul>
<li> Otherwise (if <code>T</code> is not a class type), if the braced-init-list has only one element and either <code>T</code> isn't a reference type or is a reference type that is compatible with the type of the element, <code>T</code> is <a href="direct_initialization" title="cpp/language/direct initialization">direct-initialized</a> (in direct-list-initialization) or <a href="copy_initialization" title="cpp/language/copy initialization">copy-initialized</a> (in copy-list-initialization), except that narrowing conversions are not allowed. </li>
<li> Otherwise, if <code>T</code> is a reference type that isn't compatible with the type of the element, a temporary of the referenced type is list-initialized, and the reference is bound to that temporary. (this fails if the reference is a non-const lvalue reference) </li>
<li> Otherwise, if the braced-init-list has no elements, <code>T</code> is <a href="value_initialization" title="cpp/language/value initialization">value-initialized</a>. </li>
</ul>   <h3 id="Narrowing_conversions">Narrowing conversions</h3> <p>list-initialization limits the allowed <a href="implicit_cast" title="cpp/language/implicit cast" class="mw-redirect">implicit conversions</a> by prohibiting the following:</p>
<ul>
<li> conversion from a floating-point type to an integer type </li>
<li> conversion from a <code>long double</code> to <code>double</code> or to <code>float</code> and conversion from <code>double</code> to <code>float</code>, except where the source is a <a href="constant_expression" title="cpp/language/constant expression">constant expression</a> and overflow does not occur </li>
<li> conversion from an integer type to a floating-point type, except where the source is a constant expression whose value can be stored exactly in the target type </li>
<li> conversion from integer or unscoped enumeration type to integer type that cannot represent all values of the original, except where source is a constant expression whose value can be stored exactly in the target type </li>
</ul>    <h3 id="Notes">Notes</h3> <p>Every initializer clause is <a href="eval_order" title="cpp/language/eval order">sequenced before</a> any initializer clause that follows it in the braced-init-list. This is in contrast with the arguments of a <a href="operator_other#Built-in_function_call_operator" title="cpp/language/operator other">function call expression</a>, which are <a href="eval_order" title="cpp/language/eval order">unsequenced</a>.</p>
<p>A braced-init-list is not an expression and therefore has no type, e.g. <code>decltype({1,2})</code> is ill-formed. Having no type implies that template type deduction cannot deduce a type that matches a braced-init-list, so given the declaration <code>template&lt;class T&gt; void f(T);</code> the expression <code>f({1,2,3})</code> is ill-formed. However, the template parameter can otherwise be deduced, as is the case for <code><a href="../container/vector"><span class="kw1266">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> v<span class="br0">(</span><a href="../iterator/istream_iterator"><span class="kw664">std::<span class="me2">istream_iterator</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="br0">(</span><a href="../io/cin"><span class="kw1753">std::<span class="me2">cin</span></span></a><span class="br0">)</span>, <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span></code>, where the iterator type is deduced by the first argument but also used in the second parameter position. A special exception is made for <a href="template_argument_deduction#Other_contexts" title="cpp/language/template argument deduction">type deduction using the keyword <code>auto</code> </a>, which deduces any braced-init-list as <code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code>.</p>
<p>Also because braced-init-list has no type, <a href="overload_resolution#Implicit_conversion_sequence_in_list-initialization" title="cpp/language/overload resolution">special rules for overload resolution</a> apply when it is used as an argument to an overloaded function call.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>Aggregates copy/move initialize directly from single-element braced-init-lists of the same type, but non-aggregates consider initializer_list constructors first:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct X {
    X() = default;
    X(const X&amp;) = default;
};
 
struct Q {
    Q() = default;
    Q(Q const&amp;) = default;
    Q(std::initializer_list&lt;Q&gt;) {}
};
 
int main() {
  X x;
  X x2 = X { x }; // copy-constructor (not aggregate initialization)
  Q q;
  Q q2 = Q { q }; // initializer-list constructor (not copy constructor)
}</pre></div> </td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <h3 id="Example">Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;string&gt;
 
struct Foo {
    std::vector&lt;int&gt; mem = {1,2,3}; // list-initialization of a non-static member
    std::vector&lt;int&gt; mem2;
    Foo() : mem2{-1, -2, -3} {} // list-initialization of a member in constructor
};
 
std::pair&lt;std::string, std::string&gt; f(std::pair&lt;std::string, std::string&gt; p)
{
    return {p.second, p.first}; // list-initialization in return statement
}
 
int main()
{
    int n0{};     // value-initialization (to zero)
    int n1{1};    // direct-list-initialization
    std::string s1{'a', 'b', 'c', 'd'}; // initializer-list constructor call
    std::string s2{s1, 2, 2};           // regular constructor call
    std::string s3{0x61, 'a'}; // initializer-list ctor is preferred to (int, char)
 
    int n2 = {1}; // copy-list-initialization
    double d = double{1.2}; // list-initialization of a temporary, then copy-init
 
    std::map&lt;int, std::string&gt; m = { // nested list-initialization
           {1, "a"},
           {2, {'a', 'b', 'c'} },
           {3, s1}
    };
 
    std::cout &lt;&lt; f({"hello", "world"}).first // list-initialization in function call
              &lt;&lt; '\n';
 
    const int (&amp;ar)[2] = {1,2}; // binds a lvalue reference to a temporary array
    int&amp;&amp; r1 = {1}; // binds a rvalue reference to a temporary int
//  int&amp; r2 = {2}; // error: cannot bind rvalue to a non-const lvalue ref
 
//  int bad{1.0}; // error: narrowing conversion
    unsigned char uc1{10}; // okay
//  unsigned char uc2{-1}; // error: narrowing conversion
 
    Foo f;
 
    std::cout &lt;&lt; n0 &lt;&lt; ' ' &lt;&lt; n1 &lt;&lt; ' ' &lt;&lt; n2 &lt;&lt; '\n'
              &lt;&lt; s1 &lt;&lt; ' ' &lt;&lt; s2 &lt;&lt; ' ' &lt;&lt; s3 &lt;&lt; '\n';
    for(auto p: m)
        std::cout &lt;&lt; p.first &lt;&lt; ' ' &lt;&lt; p.second &lt;&lt; '\n';
    for(auto n: f.mem)
        std::cout &lt;&lt; n &lt;&lt; ' ';
    for(auto n: f.mem2)
        std::cout &lt;&lt; n &lt;&lt; ' ';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">world
0 1 1
abcd cd aa
1 a
2 abc
3 abcd
1 2 3 -1 -2 -3</pre></div> </div> <h3 id="Defect_reports">Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/cwg1467">CWG 1467</a> </td> <td> C++14 </td> <td> same-type initialization of aggregates and char arrays was prohibited </td> <td> same-type initialization allowed </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/cwg1467">CWG 1467</a> </td> <td> C++14 </td> <td> std::initializer_list constructors had priority over copy constructors for single-element lists </td> <td> single-element lists initialize directly </td>
</tr>
</table> <h3 id="See_also">See also</h3> <ul>
<li> <a href="default_initialization" title="cpp/language/default initialization">default initialization</a> </li>
<li> <a href="direct_initialization" title="cpp/language/direct initialization">direct initialization</a> </li>
<li> <a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate initialization</a> </li>
<li> <a href="copy_initialization" title="cpp/language/copy initialization">copy initialization</a> </li>
</ul>          <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/list_initialization" class="_attribution-link">http://en.cppreference.com/w/cpp/language/list_initialization</a>
  </p>
</div>
