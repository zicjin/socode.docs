    <h1 id="firstHeading" class="firstHeading">List-initialization <span class="t-mark-rev t-since-cxx11">(since C++11)</span>
</h1>            <p>Initializes an object from <span class="t-spar">braced-init-list</span>.</p>
<h3 id="Syntax"> Syntax</h3> <h4 id="Direct-list-initialization"> Direct-list-initialization</h4> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">T</span> <span class="t-spar">object</span> <code>{ </code> <span class="t-spar">arg1, arg2, ...</span> <code>};</code> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">T</span> <code>{ </code> <span class="t-spar">arg1, arg2, ...</span> <code>}</code> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>new</code> <span class="t-spar">T</span> <code>{ </code> <span class="t-spar">arg1, arg2, ...</span> <code>}</code> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">Class</span> <code>{</code> <span class="t-spar">T</span> <span class="t-spar">member</span> <code>{ </code><span class="t-spar">arg1, arg2, ...</span> <code>}; };</code> </td> <td> (4) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">Class</span><code>::</code><span class="t-spar">Class</span><code>() : </code><span class="t-spar">member</span><code>{</code><span class="t-spar">arg1, arg2, ...</span><code>} {...</code> </td> <td> (5) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <h4 id="Copy-list-initialization"> Copy-list-initialization</h4> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">T</span> <span class="t-spar">object</span> <code>= {</code><span class="t-spar">arg1, arg2, ...</span><code>};</code> </td> <td> (6) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">function</span><code>( { </code> <span class="t-spar">arg1, arg2, ...</span> <code>} )</code> </td> <td> (7) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>return { </code> <span class="t-spar">arg1, arg2, ...</span> <code>} ;</code> </td> <td> (8) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">object</span><code>[ { </code> <span class="t-spar">arg1, arg2, ...</span> <code>} ]</code> </td> <td> (9) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">object</span> <code>= </code> <code>{ </code> <span class="t-spar">arg1, arg2, ...</span> <code>}</code> </td> <td> (10) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">U</span><code>( { </code> <span class="t-spar">arg1, arg2, ...</span> <code>} )</code> </td> <td> (11) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">Class</span> <code>{</code> <span class="t-spar">T</span> <span class="t-spar">member</span> <code>=</code> <code>{ </code><span class="t-spar">arg1, arg2, ...</span> <code>}; };</code> </td> <td> (12) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>List initialization is performed in the following situations:</p>
<ul><li> direct-list-initialization (both explicit and non-explicit constructors are considered) </li></ul> <div class="t-li1">
<span class="t-li">1)</span> initialization of a named variable with a <span class="t-spar">braced-init-list</span> (that is, a possibly empty brace-enclosed list of expressions or nested braced-init-lists)</div> <div class="t-li1">
<span class="t-li">2)</span> initialization of an unnamed temporary with a <span class="t-spar">braced-init-list</span>
</div> <div class="t-li1">
<span class="t-li">3)</span> initialization of an object with dynamic storage duration with a <a href="new" title="cpp/language/new">new-expression</a>, where the initializer is a <span class="t-spar">braced-init-list</span>
</div> <div class="t-li1">
<span class="t-li">4)</span> in a non-static <a href="data_members#Member_initialization" title="cpp/language/data members">data member initializer</a> that does not use the equals sign</div> <div class="t-li1">
<span class="t-li">5)</span> in a <a href="initializer_list" title="cpp/language/initializer list" class="mw-redirect">member initializer list</a> of a constructor if <span class="t-spar">braced-init-list</span> is used</div> <ul><li> copy-list-initialization (both explicit and non-explicit constructors are considered, but only non-explicit constructors may be called) </li></ul> <div class="t-li1">
<span class="t-li">6)</span> initialization of a named variable with a <span class="t-spar">braced-init-list</span> after an equals sign</div> <div class="t-li1">
<span class="t-li">7)</span> in a function call expression, with <span class="t-spar">braced-init-list</span> used as an argument and list-initialization initializes the function parameter</div> <div class="t-li1">
<span class="t-li">8)</span> in a <code>return</code> statement with <span class="t-spar">braced-init-list</span> used as the return expression and list-initialization initializes the returned object</div> <div class="t-li1">
<span class="t-li">9)</span> in a <a href="operator_member_access#Built-in_subscript_operator" title="cpp/language/operator member access">subscript expression</a> with a user-defined <code>operator[]</code>, where list-initialization initializes the parameter of the overloaded operator</div> <div class="t-li1">
<span class="t-li">10)</span> in an <a href="operator_assignment" title="cpp/language/operator assignment">assignment expression</a>, where list-initialization initializes the parameter of the overloaded operator</div> <div class="t-li1">
<span class="t-li">11)</span> <a href="explicit_cast" title="cpp/language/explicit cast">functional cast expression</a> or other constructor invocations, where <span class="t-spar">braced-init-list</span> is used in place of a constructor argument. Copy-list-initialization initializes the constructor's parameter (note; the type U in this example is not the type that's being list-initialized; U's constructor's parameter is)</div> <div class="t-li1">
<span class="t-li">12)</span> in a non-static <a href="data_members#Member_initialization" title="cpp/language/data members">data member initializer</a> that uses the equals sign</div> <h3 id="Explanation"> Explanation</h3> <p>The effects of list-initialization of an object of type <code>T</code> are:</p>
<ul>
<li> If <code>T</code> is an aggregate class and the <span class="t-spar">braced-init-list</span> has a single element of the same or derived type (possibly cv-qualified), the object is initialized from that element (by <a href="copy_initialization" title="cpp/language/copy initialization">copy-initialization</a> for copy-list-initialization, or by <a href="direct_initialization" title="cpp/language/direct initialization">direct-initialization</a> for direct-list-initialization). </li>
<li> Otherwise, if <code>T</code> is a character array and the <span class="t-spar">braced-init-list</span> has a single element that is an appropriately-typed string literal, the array is <a href="aggregate_initialization#Character_arrays" title="cpp/language/aggregate initialization">initialized from the string literal as usual</a>. </li>
<li> Otherwise, if <code>T</code> is an <a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate type</a>, <a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate initialization</a> is performed. </li>
<li> Otherwise, if the <span class="t-spar">braced-init-list</span> is empty and <code>T</code> is a class type with a default constructor, <a href="value_initialization" title="cpp/language/value initialization">value-initialization</a> is performed. </li>
<li> Otherwise, if <code>T</code> is a specialization of <code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code>, the <code>T</code> object is direct-initialized or copy-initialized, depending on context, from <span class="t-rev-inl t-until-cxx17"><span>a prvalue of the same type initialized from</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span> the <span class="t-spar">braced-init-list</span>. </li>
<li> Otherwise, the constructors of <code>T</code> are considered, in two phases: </li>
<ul>
<li> All constructors that take <code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code> as the only argument, or as the first argument if the remaining arguments have default values, are examined, and matched by <a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a> against a single argument of type <code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code> </li>
<li> If the previous stage does not produce a match, all constructors of <code>T</code> participate in <a href="overload_resolution#Implicit_conversion_sequence_in_list-initialization" title="cpp/language/overload resolution">overload resolution</a> against the set of arguments that consists of the elements of the <span class="t-spar">braced-init-list</span>, with the restriction that only non-narrowing conversions are allowed. If this stage produces an explicit constructor as the best match for a copy-list-initialization, compilation fails (note, in simple copy-initialization, explicit constructors are not considered at all). </li>
</ul>
</ul>       <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul><li> Otherwise, if： <ul>
<li> <code>T</code> is an <a href="enum" title="cpp/language/enum">enumeration type</a> that with fixed underlying type <code>U</code> (which is <code>int</code> if the enumeration is scoped and its underlying type is not manually specified), and </li>
<li> the initialization is direct-list-initialization, and </li>
<li> the <span class="t-spar">braced-init-list</span> has only one initializer <code>v</code> that is implicitly convertible to <code>U</code>, and </li>
<li> the conversion from <code>v</code> to <code>U</code> is non-narrowing, </li>
</ul> </li></ul>  then the enumeration is initialized with the result of converting <code>v</code> to <code>U</code>.  </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <ul>
<li> Otherwise (if <code>T</code> is not a class type), if the <span class="t-spar">braced-init-list</span> has only one element and either <code>T</code> is not a reference type or is a reference type whose referenced type is same as or is a base class of the type of the element, <code>T</code> is <a href="direct_initialization" title="cpp/language/direct initialization">direct-initialized</a> (in direct-list-initialization) or <a href="copy_initialization" title="cpp/language/copy initialization">copy-initialized</a> (in copy-list-initialization), except that narrowing conversions are not allowed. </li>
<li> Otherwise, if <code>T</code> is a reference type that is not compatible with the type of the element, a temporary of the referenced type<span class="t-rev-inl t-since-cxx20"><span> or its corresponding array type of known bound</span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> is list-initialized, and the reference is bound to that temporary. (this fails if the reference is a non-const lvalue reference) </li>
</ul>   <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td>  If the referenced type is an array type of unknown bound <code>U[]</code>, the type of the temporary is <code>U[N]</code>, as if it is defined as <code>U temp[]/*init-list*/;</code>, where <code>/*init-list*/</code> is the <span class="t-spar">braced-init-list</span>.  </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <ul><li> Otherwise, if the <span class="t-spar">braced-init-list</span> has no elements, <code>T</code> is <a href="value_initialization" title="cpp/language/value initialization">value-initialized</a>. </li></ul> <h3 id="Narrowing_conversions"> Narrowing conversions</h3> <p>List-initialization limits the allowed <a href="implicit_conversion" title="cpp/language/implicit conversion">implicit conversions</a> by prohibiting the following:</p>
<ul>
<li> conversion from a floating-point type to an integer type </li>
<li> conversion from a <code>long double</code> to <code>double</code> or to <code>float</code> and conversion from <code>double</code> to <code>float</code>, except where the source is a <a href="constant_expression" title="cpp/language/constant expression">constant expression</a> and overflow does not occur </li>
<li> conversion from an integer type to a floating-point type, except where the source is a constant expression whose value can be stored exactly in the target type </li>
<li> conversion from integer or unscoped enumeration type to integer type that cannot represent all values of the original, except where source is a constant expression whose value can be stored exactly in the target type </li>
<li> conversion from a pointer type or pointer-to-member type to <code>bool</code> </li>
</ul>     <h3 id="Notes"> Notes</h3> <p>Every initializer clause is <a href="eval_order" title="cpp/language/eval order">sequenced before</a> any initializer clause that follows it in the <span class="t-spar">braced-init-list</span>. This is in contrast with the arguments of a <a href="operator_other#Built-in_function_call_operator" title="cpp/language/operator other">function call expression</a>, which are <span class="t-rev-inl t-until-cxx17"><span><a href="eval_order" title="cpp/language/eval order">unsequenced</a></span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span><a href="eval_order" title="cpp/language/eval order">indeterminately sequenced</a></span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>.</p>
<p>A <span class="t-spar">braced-init-list</span> is not an expression and therefore has no type, e.g. <code>decltype({1,2})</code> is ill-formed. Having no type implies that template type deduction cannot deduce a type that matches a <span class="t-spar">braced-init-list</span>, so given the declaration <code>template&lt;class T&gt; void f(T);</code> the expression <code>f({1,2,3})</code> is ill-formed. However, the template parameter can otherwise be deduced, as is the case for <code><a href="http://en.cppreference.com/w/cpp/container/vector"><span class="kw1272">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> v<span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/iterator/istream_iterator"><span class="kw670">std::<span class="me2">istream_iterator</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/io/cin"><span class="kw1760">std::<span class="me2">cin</span></span></a><span class="br0">)</span>, <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span></code>, where the iterator type is deduced by the first argument but also used in the second parameter position. A special exception is made for <a href="template_argument_deduction#Other_contexts" title="cpp/language/template argument deduction">type deduction using the keyword <code>auto</code> </a>, which deduces any <span class="t-spar">braced-init-list</span> as <code><a href="../utility/initializer_list" title="cpp/utility/initializer list">std::initializer_list</a></code> in copy-list-initialization.</p>
<p>Also because a <span class="t-spar">braced-init-list</span> has no type, <a href="overload_resolution#Implicit_conversion_sequence_in_list-initialization" title="cpp/language/overload resolution">special rules for overload resolution</a> apply when it is used as an argument to an overloaded function call. Aggregates copy/move initialize directly from single-element <span class="t-spar">braced-init-list</span> of the same type, but non-aggregates consider initializer_list constructors first:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct X {}; // aggregate
 
struct Q     // non-aggregate
{
    Q() = default;
    Q(Q const&amp;) = default;
    Q(std::initializer_list&lt;Q&gt;) {}
};
 
int main()
{
    X x;
    X x2 = X{x}; // copy-constructor (not aggregate initialization)
 
    Q q;
    Q q2 = Q{q}; // initializer-list constructor (not copy constructor)
}</pre></div> <p>Some compilers (e.g., gcc 10) only consider conversion from a pointer or a pointer-to-member to <code>bool</code> narrowing in C++20 mode.</p>
<h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;string&gt;
 
struct Foo
{
    std::vector&lt;int&gt; mem = {1, 2, 3}; // list-initialization of a non-static member
    std::vector&lt;int&gt; mem2;
 
    Foo() : mem2{-1, -2, -3} {} // list-initialization of a member in constructor
};
 
std::pair&lt;std::string, std::string&gt; f(std::pair&lt;std::string, std::string&gt; p)
{
    return {p.second, p.first}; // list-initialization in return statement
}
 
int main()
{
    int n0{};  // value-initialization (to zero)
    int n1{1}; // direct-list-initialization
 
    std::string s1{'a', 'b', 'c', 'd'}; // initializer-list constructor call
    std::string s2{s1, 2, 2};           // regular constructor call
    std::string s3{0x61, 'a'}; // initializer-list ctor is preferred to (int, char)
 
    int n2 = {1}; // copy-list-initialization
    double d = double{1.2}; // list-initialization of a prvalue, then copy-init
    auto s4 = std::string{"HelloWorld"}; // same as above, no temporary created since C++17
 
    std::map&lt;int, std::string&gt; m = // nested list-initialization
    {
        {1, "a"},
        {2, {'a', 'b', 'c'}},
        {3, s1}
    };
 
    std::cout &lt;&lt; f({"hello", "world"}).first // list-initialization in function call
              &lt;&lt; '\n';
 
    const int (&amp;ar)[2] = {1, 2}; // binds a lvalue reference to a temporary array
    int&amp;&amp; r1 = {1}; // binds a rvalue reference to a temporary int
//  int&amp; r2 = {2}; // error: cannot bind rvalue to a non-const lvalue ref
 
//  int bad{1.0}; // error: narrowing conversion
    unsigned char uc1{10}; // okay
//  unsigned char uc2{-1}; // error: narrowing conversion
 
    Foo f;
 
    std::cout &lt;&lt; n0 &lt;&lt; ' ' &lt;&lt; n1 &lt;&lt; ' ' &lt;&lt; n2 &lt;&lt; '\n'
              &lt;&lt; s1 &lt;&lt; ' ' &lt;&lt; s2 &lt;&lt; ' ' &lt;&lt; s3 &lt;&lt; '\n';
    for(auto p: m)
        std::cout &lt;&lt; p.first &lt;&lt; ' ' &lt;&lt; p.second &lt;&lt; '\n';
    for(auto n: f.mem)
        std::cout &lt;&lt; n &lt;&lt; ' ';
    for(auto n: f.mem2)
        std::cout &lt;&lt; n &lt;&lt; ' ';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">world
0 1 1
abcd cd aa
1 a
2 abc
3 abcd
1 2 3 -1 -2 -3</pre></div> </div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1288.html">CWG 1288</a> </td> <td> C++11 </td> <td> list-initializing a reference with a single-element<br><span class="t-spar">braced-init-list</span> always bound the reference to a temporary </td> <td> bind to that<br>element if valid </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1324.html">CWG 1324</a> </td> <td> C++11 </td> <td> initialization considered first for initialization from <code>{}</code> </td> <td> aggregate initialization<br>considered first </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1467.html">CWG 1467</a> </td> <td> C++11 </td> <td> same-type initialization of aggregates and character<br>arrays was prohibited; initializer-list constructors had<br>priority over copy constructors for single-element lists </td> <td> same-type initialization<br>allowed; single-element<br>lists initialize directly </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1494.html">CWG 1494</a> </td> <td> C++11 </td> <td> when list-initializing a reference with an element of an<br>incompatible type, it was unspecified whether the temporary<br>created is direct-list-initialized or copy-list-initialized </td> <td> it depends on the<br>kind of initialization<br>for the reference </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2137.html">CWG 2137</a> </td> <td> C++11 </td> <td> initializer-list constructors lost to copy<br>constructors when list-initializing X from <code>{X}</code> </td> <td> non-aggregates consider<br>initializer-lists first </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2374.html">CWG 2374</a> </td> <td> C++17 </td> <td> direct-list-initialization of an enum allowed too many source types </td> <td> restricted </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://wg21.link/P1957R2">P1957R2</a> </td> <td> C++11 </td> <td> conversion from a pointer/pointer-to-member to <code>bool</code> was not narrowing </td> <td> made narrowing </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <ul>
<li> <a href="constructor" title="cpp/language/constructor">constructor</a> </li>
<li> <a href="converting_constructor" title="cpp/language/converting constructor">converting constructor</a> </li>
<li> <a href="copy_assignment" title="cpp/language/copy assignment">copy assignment</a> </li>
<li> <a href="copy_constructor" title="cpp/language/copy constructor">copy constructor</a> </li>
<li> <a href="copy_elision" title="cpp/language/copy elision">copy elision</a> </li>
<li> <a href="default_constructor" title="cpp/language/default constructor">default constructor</a> </li>
<li> <a href="explicit" title="cpp/language/explicit"><code>explicit</code></a> </li>
<li> <a href="initialization" title="cpp/language/initialization">initialization</a> <ul>
<li> <a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate initialization</a> </li>
<li> <a href="constant_initialization" title="cpp/language/constant initialization">constant initialization</a> </li>
<li> <a href="copy_initialization" title="cpp/language/copy initialization">copy initialization</a> </li>
<li> <a href="direct_initialization" title="cpp/language/direct initialization">direct initialization</a> </li>
<li> <a href="reference_initialization" title="cpp/language/reference initialization">reference initialization</a> </li>
<li> <a href="value_initialization" title="cpp/language/value initialization">value initialization</a> </li>
<li> <a href="zero_initialization" title="cpp/language/zero initialization">zero initialization</a> </li>
</ul> </li>
<li> <a href="move_assignment" title="cpp/language/move assignment">move assignment</a> </li>
<li> <a href="move_constructor" title="cpp/language/move constructor">move constructor</a> </li>
<li> <a href="new" title="cpp/language/new"><code>new</code></a> </li>
</ul>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/list_initialization" class="_attribution-link">https://en.cppreference.com/w/cpp/language/list_initialization</a>
  </p>
</div>
