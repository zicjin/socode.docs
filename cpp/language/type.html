    <h1 id="firstHeading" class="firstHeading">Type</h1>            <p><a href="object" title="cpp/language/object">Objects</a>, <a href="reference" title="cpp/language/reference">references</a>, <a href="functions" title="cpp/language/functions">functions</a> including <a href="template_specialization" title="cpp/language/template specialization">function template specializations</a>, and <a href="expressions" title="cpp/language/expressions">expressions</a> have a property called <i>type</i>, which both restricts the operations that are permitted for those entities and provides semantic meaning to the otherwise generic sequences of bits.</p>
<h3 id="Type_classification"> Type classification</h3> <p>The C++ type system consists of the following types:</p>
<ul>
<li> <a href="types" title="cpp/language/types">fundamental types</a> (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_fundamental"><span class="kw490">std::<span class="me2">is_fundamental</span></span></a></code>): </li>
<ul><li> the type <code>void</code> (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_void"><span class="kw456">std::<span class="me2">is_void</span></span></a></code>); </li></ul>
</ul>  <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul><li> the type <code><a href="http://en.cppreference.com/w/cpp/types/nullptr_t"><span class="kw108">std::<span class="me2">nullptr_t</span></span></a></code> (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_null_pointer"><span class="kw458">std::<span class="me2">is_null_pointer</span></span></a></code>); </li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <ul>
<li> arithmetic types (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_arithmetic"><span class="kw488">std::<span class="me2">is_arithmetic</span></span></a></code>): </li>
<li> floating-point types (<code>float</code>, <code>double</code>, <code>long double</code> and their <a href="cv" title="cpp/language/cv">cv-qualified versions</a>) (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_floating_point"><span class="kw464">std::<span class="me2">is_floating_point</span></span></a></code>); </li>
<li> integral types (including <a href="cv" title="cpp/language/cv">cv-qualified versions</a>, see also <code><a href="http://en.cppreference.com/w/cpp/types/is_integral"><span class="kw462">std::<span class="me2">is_integral</span></span></a></code>): </li>
<li> the type <code>bool</code>; </li>
<li> character types: </li>
<li> narrow character types: </li>
<ul><li> ordinary character types (<code>char</code>, <code>signed char</code>, <code>unsigned char</code>) </li></ul>
</ul>         <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <ul><li> the type <code>char8_t</code> </li></ul>     </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <ul>
<li> wide character types (<span class="t-rev-inl t-since-cxx11"><span><code>char16_t</code>, <code>char32_t</code>, </span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span><code>wchar_t</code>); </li>
<li> signed integer types (<code>short int</code>, <code>int</code>, <code>long int</code>, <code>long long int</code>); </li>
<li> unsigned integer types (<code>unsigned short int</code>, <code>unsigned int</code>, <code>unsigned long int</code>, <code>unsigned long long int</code>); </li>
<li> compound types (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_compound"><span class="kw496">std::<span class="me2">is_compound</span></span></a></code>): </li>
<li> <a href="reference" title="cpp/language/reference">reference types</a> (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_reference"><span class="kw486">std::<span class="me2">is_reference</span></span></a></code>): </li>
<li> <a href="reference#Lvalue_references" title="cpp/language/reference">lvalue reference types</a> (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_lvalue_reference"><span class="kw470">std::<span class="me2">is_lvalue_reference</span></span></a></code>): </li>
<ul>
<li> lvalue reference to object types; </li>
<li> lvalue reference to function types; </li>
</ul>
<li> <a href="reference#Rvalue_references" title="cpp/language/reference">rvalue reference types</a> (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_rvalue_reference"><span class="kw472">std::<span class="me2">is_rvalue_reference</span></span></a></code>): </li>
<ul>
<li> rvalue reference to object types; </li>
<li> rvalue reference to function types; </li>
</ul>
<li> <a href="pointer#Pointers" title="cpp/language/pointer">pointer types</a> (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_pointer"><span class="kw468">std::<span class="me2">is_pointer</span></span></a></code>): </li>
<ul>
<li> <a href="pointer#Pointers_to_objects" title="cpp/language/pointer">pointer-to-object types</a>; </li>
<li> <a href="pointer#Pointers_to_functions" title="cpp/language/pointer">pointer-to-function types</a>; </li>
</ul>
<li> <a href="pointer#Pointers_to_members" title="cpp/language/pointer">pointer-to-member types</a> (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_member_pointer"><span class="kw498">std::<span class="me2">is_member_pointer</span></span></a></code>): </li>
<ul>
<li> <a href="pointer#Pointers_to_data_members" title="cpp/language/pointer">pointer-to-data-member</a> types (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_member_object_pointer"><span class="kw474">std::<span class="me2">is_member_object_pointer</span></span></a></code>); </li>
<li> <a href="pointer#Pointers_to_member_functions" title="cpp/language/pointer">pointer-to-member-function</a> types (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_member_function_pointer"><span class="kw476">std::<span class="me2">is_member_function_pointer</span></span></a></code>); </li>
</ul>
<li> <a href="array" title="cpp/language/array">array types</a> (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_array"><span class="kw466">std::<span class="me2">is_array</span></span></a></code>); </li>
<li> <a href="function" title="cpp/language/function">function types</a> (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_function"><span class="kw484">std::<span class="me2">is_function</span></span></a></code>); </li>
<li> <a href="enum" title="cpp/language/enum">enumeration types</a> (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_enum"><span class="kw478">std::<span class="me2">is_enum</span></span></a></code>); </li>
<ul>
<li> <a href="enum#Unscoped_enumerations" title="cpp/language/enum">unscoped enumeration types</a>; </li>
<li> <a href="enum#Scoped_enumerations" title="cpp/language/enum">scoped enumeration types</a> (see also <code>std::is_scoped_enum</code>); </li>
</ul>
<li> <a href="class" title="cpp/language/class">class types</a>: </li>
<ul>
<li> non-union types (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_class"><span class="kw482">std::<span class="me2">is_class</span></span></a></code>); </li>
<li> <a href="union" title="cpp/language/union">union types</a> (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_union"><span class="kw480">std::<span class="me2">is_union</span></span></a></code>). </li>
</ul>
</ul>                     <p>For every type other than reference and function, the type system supports three additional <a href="cv" title="cpp/language/cv">cv-qualified versions</a> of that type (<code>const</code>, <code>volatile</code>, and <code>const volatile</code>).</p>
<p>Types are grouped in various categories based on their properties:</p>
<ul>
<li> object types are (possibly cv-qualified) types that are not function types, reference types, or the type <code>void</code> (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_object"><span class="kw492">std::<span class="me2">is_object</span></span></a></code>); </li>
<li> scalar types are (possibly cv-qualified) object types that are not array types or class types (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_scalar"><span class="kw494">std::<span class="me2">is_scalar</span></span></a></code>); </li>
<li> trivial types (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_trivial"><span class="kw504">std::<span class="me2">is_trivial</span></span></a></code>), POD types (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_pod"><span class="kw510">std::<span class="me2">is_pod</span></span></a></code>), literal types (see also <code><a href="http://en.cppreference.com/w/cpp/types/is_literal_type"><span class="kw512">std::<span class="me2">is_literal_type</span></span></a></code>), and other categories listed in the <a href="../types" title="cpp/types">the type traits library</a> or as <a href="../named_req" title="cpp/named req">named type requirements</a>. </li>
</ul> <h3 id="Type_naming"> Type naming</h3> <p>A <a href="name" title="cpp/language/name" class="mw-redirect">name</a> can be declared to refer to a type by means of:</p>
<ul>
<li> <a href="class" title="cpp/language/class">class</a> declaration; </li>
<li> <a href="union" title="cpp/language/union">union</a> declaration; </li>
<li> <a href="enum" title="cpp/language/enum">enum</a> declaration; </li>
<li> <a href="typedef" title="cpp/language/typedef">typedef</a> declaration; </li>
<li> <a href="type_alias" title="cpp/language/type alias">type alias</a> declaration. </li>
</ul> <p>Types that do not have names often need to be referred to in C++ programs; the syntax for that is known as <i>type-id</i>. The syntax of the type-id that names type T is exactly the syntax of a <a href="declarations" title="cpp/language/declarations">declaration</a> of a variable or function of type T, with the identifier omitted, except that <i>decl-specifier-seq</i> of the declaration grammar is constrained to <i>type-specifier-seq</i>, and that new types may be defined only if the type-id appears on the right-hand side of a non-template type alias declaration.</p>
<div class="cpp source-cpp"><pre data-language="cpp">int* p;               // declaration of a pointer to int
static_cast&lt;int*&gt;(p); // type-id is "int*"
 
int a[3];   // declaration of an array of 3 int
new int[3]; // type-id is "int[3]" (called new-type-id)
 
int (*(*x[2])())[3];      // declaration of an array of 2 pointers to functions
                          // returning pointer to array of 3 int
new (int (*(*[2])())[3]); // type-id is "int (*(*[2])())[3]"
 
void f(int);                    // declaration of a function taking int and returning void
std::function&lt;void(int)&gt; x = f; // type template parameter is a type-id "void(int)"
std::function&lt;auto(int) -&gt; void&gt; y = f; // same
 
std::vector&lt;int&gt; v;       // declaration of a vector of int
sizeof(std::vector&lt;int&gt;); // type-id is "std::vector&lt;int&gt;"
 
struct { int x; } b;         // creates a new type and declares an object b of that type
sizeof(struct { int x; });   // error: cannot define new types in a sizeof expression
using t = struct { int x; }; // creates a new type and declares t as an alias of that type
 
sizeof(static int); // error: storage class specifiers not part of type-specifier-seq
std::function&lt;inline void(int)&gt; f; // error: neither are function specifiers</pre></div> <p>The <i>declarator</i> part of the declaration grammar with the name removed is referred to as <i>abstract-declarator</i>.</p>
<p><i>Type-id</i> may be used in the following situations:</p>
<ul>
<li> to specify the target type in <a href="expressions#Conversions" title="cpp/language/expressions">cast expressions</a>; </li>
<li> as arguments to <a href="sizeof" title="cpp/language/sizeof">sizeof</a>, <a href="alignof" title="cpp/language/alignof">alignof</a>, <a href="alignas" title="cpp/language/alignas">alignas</a>, <a href="new" title="cpp/language/new">new</a>, and <a href="typeid" title="cpp/language/typeid">typeid</a>; </li>
<li> on the right-hand side of a <a href="type_alias" title="cpp/language/type alias">type alias</a> declaration; </li>
<li> as the trailing return type of a <a href="function" title="cpp/language/function">function</a> declaration; </li>
<li> as the default argument of a <a href="template_parameters#Type_template_parameter" title="cpp/language/template parameters">template type parameter</a>; </li>
<li> as the template argument for a <a href="template_parameters#Template_type_arguments" title="cpp/language/template parameters">template type parameter</a>; </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <ul><li> in <a href="except_spec" title="cpp/language/except spec">dynamic exception specification</a>. </li></ul> </td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> </table> <p><i>Type-id</i> can be used with some modifications in the following situations:</p>
<ul>
<li> in the parameter list of a <a href="function#Parameter_list" title="cpp/language/function">function</a> (when the parameter name is omitted), type-id uses <i>decl-specifier-seq</i> instead of <i>type-specifier-seq</i> (in particular, some storage class specifiers are allowed); </li>
<li> in the name of a <a href="cast_operator" title="cpp/language/cast operator">user-defined conversion function</a>, the abstract declarator cannot include function or array operators. </li>
</ul>   <h3 id="Elaborated_type_specifier"> Elaborated type specifier</h3> <p>Elaborated type specifiers may be used to refer to a previously-declared class name (class, struct, or union) or to a previously-declared enum name even if the name was <a href="lookup" title="cpp/language/lookup">hidden by a non-type declaration</a>. They may also be used to declare new class names.</p>
<p>See <a href="elaborated_type_specifier" title="cpp/language/elaborated type specifier">elaborated type specifier</a> for details.</p>
<h3 id="Static_type"> Static type</h3> <p>The type of an expression that results from the compile-time analysis of the program is known as the <i>static type</i> of the expression. The static type does not change while the program is executing.</p>
<h3 id="Dynamic_type"> Dynamic type</h3> <p>If some <a href="value_category" title="cpp/language/value category">glvalue expression</a> refers to a <a href="object" title="cpp/language/object">polymorphic object</a>, the type of its most derived object is known as the dynamic type.</p>
<div class="cpp source-cpp"><pre data-language="cpp">// given
struct B { virtual ~B() {} }; // polymorphic type
struct D: B {};               // polymorphic type
 
D d; // most-derived object
B* ptr = &amp;d;
 
// the static type of (*ptr) is B
// the dynamic type of (*ptr) is D</pre></div> <p>For prvalue expressions, the dynamic type is always the same as the static type.</p>
<h3 id="Incomplete_type"> Incomplete type</h3> <p>The following types are <i>incomplete types</i>:</p>
<ul>
<li> the type <code>void</code> (possibly <a href="cv" title="cpp/language/cv">cv</a>-qualified); </li>
<li> <i>incompletely-defined object types</i>: <ul>
<li> class type that has been declared (e.g. by <a href="class#Forward_declaration" title="cpp/language/class">forward declaration</a>) but not defined; </li>
<li> <a href="array#Arrays_of_unknown_bound" title="cpp/language/array">array of unknown bound</a>; </li>
<li> array of elements of incomplete type; </li>
<li> <a href="enum" title="cpp/language/enum">enumeration type</a> from the point of declaration until its underlying type is determined. </li>
</ul> </li>
</ul> <p>All other types are complete.</p>
<p><br> Any of the following contexts requires type <code>T</code> to be complete:</p>
<ul>
<li> <a href="function" title="cpp/language/function">definition</a> of or call to a function with return type <code>T</code> or argument type <code>T</code>; </li>
<li> <a href="definition" title="cpp/language/definition">definition</a> of an object of type <code>T</code>; </li>
<li> declaration of a <a href="data_members" title="cpp/language/data members">non-static class data member</a> of type <code>T</code>; </li>
<li> <a href="new" title="cpp/language/new">new-expression</a> for an object of type <code>T</code> or an array whose element type is <code>T</code>; </li>
<li> <a href="implicit_cast#Lvalue_to_rvalue_conversion" title="cpp/language/implicit cast" class="mw-redirect">lvalue-to-rvalue conversion</a> applied to a glvalue of type <code>T</code>; </li>
<li> an <a href="implicit_cast" title="cpp/language/implicit cast" class="mw-redirect">implicit</a> or <a href="explicit_cast" title="cpp/language/explicit cast">explicit</a> conversion to type <code>T</code>; </li>
<li> a <a href="implicit_cast" title="cpp/language/implicit cast" class="mw-redirect">standard conversion</a>, <a href="dynamic_cast" title="cpp/language/dynamic cast">dynamic_cast</a>, or <a href="static_cast" title="cpp/language/static cast">static_cast</a> to type <code>T*</code> or <code>T&amp;</code>, except when converting from the <a href="pointer#Null_pointers" title="cpp/language/pointer">null pointer constant</a> or from a <a href="pointer#Pointers_to_void" title="cpp/language/pointer">pointer to possibly cv-qualified void</a>; </li>
<li> <a href="operator_member_access" title="cpp/language/operator member access">class member access operator</a> applied to an expression of type <code>T</code>; </li>
<li> <a href="typeid" title="cpp/language/typeid">typeid</a>, <a href="sizeof" title="cpp/language/sizeof">sizeof</a>, or <a href="alignof" title="cpp/language/alignof">alignof</a> operator applied to type <code>T</code>; </li>
<li> <a href="operator_arithmetic" title="cpp/language/operator arithmetic">arithmetic operator</a> applied to a pointer to <code>T</code>; </li>
<li> definition of a class with base class <code>T</code>; </li>
<li> assignment to an lvalue of type <code>T</code>; </li>
<li> a <a href="try_catch" title="cpp/language/try catch">catch-clause</a> for an exception of type <code>T</code>, <code>T&amp;</code>, or <code>T*</code>. </li>
</ul> <p>(In general, when the size and layout of <code>T</code> must be known.).</p>
<p>If any of these situations occur in a translation unit, the definition of the type must appear in the same translation unit. Otherwise, it is not required.</p>
<p><br> An incompletely-defined object type can be completed:</p>
<ul><li> A class type (such as <code>class X</code>) might be incomplete at one point in a translation unit and complete later on; the type <code>class X</code> is the same type at both points: </li></ul> <div class="cpp source-cpp"><pre data-language="cpp">struct X;            // X is an incomplete type
extern X* xp;        // xp is a pointer to an incomplete type
 
void foo()
{
    xp++;            // ill-formed: X is incomplete
}
 
struct X { int i; }; // now X is a complete type
X x;
 
void bar()
{
    xp = &amp;x;         // OK: type is “pointer to X”
    xp++;            // OK: X is complete
}</pre></div> <ul>
<li> The declared type of an array object might be an array of incomplete class type and therefore incomplete; if the class type is completed later on in the translation unit, the array type becomes complete; the array type at those two points is the same type. </li>
<li> The declared type of an array object might be an array of unknown bound and therefore be incomplete at one point in a translation unit and complete later on; the array types at those two points ("array of unknown bound of <code>T</code>" and "array of <code>N</code> <code>T</code>") are different types. </li>
</ul>  <p>The type of a pointer to array of unknown bound, or to a type defined by a <code>typedef</code> declaration to be an array of unknown bound, cannot be completed.</p>
<div class="cpp source-cpp"><pre data-language="cpp">extern int arr[];   // the type of arr is incomplete
typedef int UNKA[]; // UNKA is an incomplete type
 
UNKA* arrp;         // arrp is a pointer to an incomplete type
UNKA** arrpp;
 
void foo()
{
    arrp++;         // error: incomplete type
    arrpp++;        // OK: sizeof UNKA* is known
}
 
int arr[10];        // now the type of arr is complete
 
void bar()
{
    arrp = &amp;arr;    // error: different types
    arrp++;         // error: UNKA can’t be completed
}</pre></div> <h3 id="Defect_Reports"> Defect Reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/328.html">CWG 328</a> </td> <td> C++98 </td> <td> class members of incomplete type were not prohibited<br> if an object of the class type was never created </td> <td> non-static class data members<br>need to be complete </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/977.html">CWG 977</a> </td> <td> C++98 </td> <td> the point when an enumeration type becomes<br>complete in its definition was unclear </td> <td> the type is complete once the<br>underlying type is determined </td>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1362.html">CWG 1362</a> </td> <td> C++98 </td> <td> user-defined conversions to type <code>T*</code> or <code>T&amp;</code> required <code>T</code> to be complete </td> <td> not required </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/type" title="c/language/type">C documentation</a></span> for <span class=""><span>Type</span></span> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/type" class="_attribution-link">https://en.cppreference.com/w/cpp/language/type</a>
  </p>
</div>
