   <h1 id="firstHeading" class="firstHeading">Move assignment operator</h1>            <p>A move assignment operator of class <code>T</code> is a non-template <a href="member_functions" title="cpp/language/member functions">non-static member function</a> with the name <code>operator=</code> that takes exactly one parameter of type <code>T&amp;&amp;</code>, <code>const T&amp;&amp;</code>, <code>volatile T&amp;&amp;</code>, or <code>const volatile T&amp;&amp;</code>.</p>
<h3 id="Syntax">Syntax</h3> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">class_name</span> <code>&amp;</code> <span class="t-spar">class_name</span> <code>:: operator=</code> ( <span class="t-spar">class_name</span> <code>&amp;&amp;</code> ) </td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">class_name</span> <code>&amp;</code> <span class="t-spar">class_name</span> <code>:: operator=</code> ( <span class="t-spar">class_name</span> <code>&amp;&amp;</code> ) = <code>default;</code> </td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">class_name</span> <code>&amp;</code> <span class="t-spar">class_name</span> <code>:: operator=</code> ( <span class="t-spar">class_name</span> <code>&amp;&amp;</code> ) = <code>delete;</code> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> 
</table> <h3 id="Explanation">Explanation</h3> <ol>
<li> Typical declaration of a move assignment operator. </li>
<li> Forcing a move assignment operator to be generated by the compiler. </li>
<li> Avoiding implicit move assignment. </li>
</ol> <p>The move assignment operator is called whenever it is selected by <a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>, e.g. when an object appears on the left-hand side of an assignment expression, where the right-hand side is an rvalue of the same or implicitly convertible type.</p>
<p>Move assignment operators typically "steal" the resources held by the argument (e.g. pointers to dynamically-allocated objects, file descriptors, TCP sockets, I/O streams, running threads, etc.), rather than make copies of them, and leave the argument in some valid but otherwise indeterminate state. For example, move-assigning from a <code><a href="../string/basic_string" title="cpp/string/basic string">std::string</a></code> or from a <code><a href="../container/vector" title="cpp/container/vector">std::vector</a></code> may result in the argument being left empty. This is not, however, a guarantee. A move assignment is less, not more restrictively defined than ordinary assignment; where ordinary assignment must leave two copies of data at completion, move assignment is required to leave only one.</p>
<h3 id="Implicitly-declared_move_assignment_operator">Implicitly-declared move assignment operator</h3> <p>If no user-defined move assignment operators are provided for a class type (<code>struct</code>, <code>class</code>, or <code>union</code>), and all of the following is true:</p>
<ul>
<li> there are no user-declared copy constructors; </li>
<li> there are no user-declared move constructors; </li>
<li> there are no user-declared copy assignment operators; </li>
<li> there are no user-declared destructors; </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx14">
<td> <ul><li> the implicitly-declared move assignment operator would not be defined as deleted, </li></ul> </td> <td><span class="t-mark-rev t-until-cxx14">(until C++14)</span></td>
</tr> </table> <p>then the compiler will declare a move assignment operator as an <code>inline public</code> member of its class with the signature <code>T&amp; T::operator=(T&amp;&amp;)</code>.</p>
<p>A class can have multiple move assignment operators, e.g. both <code>T&amp; T::operator=(const T&amp;&amp;)</code> and <code>T&amp; T::operator=(T&amp;&amp;)</code>. If some user-defined move assignment operators are present, the user may still force the generation of the implicitly declared move assignment operator with the keyword <code>default</code>.</p>
<p>The implicitly-declared (or defaulted on its first declaration) move assignment operator has an exception specification as described in <span class="t-rev-inl t-until-cxx17"><span><a href="except_spec" title="cpp/language/except spec">dynamic exception specification</a></span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span><a href="noexcept_spec" title="cpp/language/noexcept spec">exception specification</a></span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>.</p>
<p>Because some assignment operator (move or copy) is always declared for any class, the base class assignment operator is always hidden. If a using-declaration is used to bring in the assignment operator from the base class, and its argument type could be the same as the argument type of the implicit assignment operator of the derived class, the using-declaration is also hidden by the implicit declaration.</p>
<h3 id="Deleted_implicitly-declared_move_assignment_operator">Deleted implicitly-declared move assignment operator</h3> <p>The implicitly-declared or defaulted move assignment operator for class <code>T</code> is defined as <i>deleted</i> if any of the following is true:</p>
<ul>
<li> <code>T</code> has a non-static data member that is <code>const</code>; </li>
<li> <code>T</code> has a non-static data member of a reference type; </li>
<li> <code>T</code> has a non-static data member that cannot be move-assigned (has deleted, inaccessible, or ambiguous move assignment operator); </li>
<li> <code>T</code> has direct or virtual base class that cannot be move-assigned (has deleted, inaccessible, or ambiguous move assignment operator); </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx14">
<td> <ul>
<li> <code>T</code> has a non-static data member or a direct or virtual base without a move assignment operator that is not trivially copyable; </li>
<li> <code>T</code> has a direct or indirect virtual base class. </li>
</ul> </td> <td><span class="t-mark-rev t-until-cxx14">(until C++14)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>A deleted implicitly-declared move assignment operator is ignored by <a href="overload_resolution" title="cpp/language/overload resolution">overload resolution</a>.</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <h3 id="Trivial_move_assignment_operator">Trivial move assignment operator</h3> <p>The move assignment operator for class <code>T</code> is trivial if all of the following is true:</p>
<ul>
<li> It is not user-provided (meaning, it is implicitly-defined or defaulted); </li>
<li> <code>T</code> has no virtual member functions; </li>
<li> <code>T</code> has no virtual base classes; </li>
<li> the move assignment operator selected for every direct base of <code>T</code> is trivial; </li>
<li> the move assignment operator selected for every non-static class type (or array of class type) member of <code>T</code> is trivial; </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <ul><li> <code>T</code> has no non-static data members of <a href="cv" title="cpp/language/cv">volatile</a>-qualified type. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <p>A trivial move assignment operator performs the same action as the trivial copy assignment operator, that is, makes a copy of the object representation as if by <code><a href="../string/byte/memmove" title="cpp/string/byte/memmove">std::memmove</a></code>. All data types compatible with the C language (POD types) are trivially move-assignable.</p>
<h3 id="Implicitly-defined_move_assignment_operator">Implicitly-defined move assignment operator</h3> <p>If the implicitly-declared move assignment operator is neither deleted nor trivial, it is defined (that is, a function body is generated and compiled) by the compiler if <a href="definition#ODR-use" title="cpp/language/definition">odr-used</a>.</p>
<p>For <code>union</code> types, the implicitly-defined move assignment operator copies the object representation (as by <code><a href="../string/byte/memmove" title="cpp/string/byte/memmove">std::memmove</a></code>).</p>
<p>For non-union class types (<code>class</code> and <code>struct</code>), the move assignment operator performs full member-wise move assignment of the object's direct bases and immediate non-static members, in their declaration order, using built-in assignment for the scalars, memberwise move-assignment for arrays, and move assignment operator for class types (called non-virtually).</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>As with copy assignment, it is unspecified whether virtual base class subobjects that are accessible through more than one path in the inheritance lattice, are assigned more than once by the implicitly-defined move assignment operator:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct V
{
    V&amp; operator=(V&amp;&amp; other) {
        // this may be called once or twice
        // if called twice, 'other' is the just-moved-from V subobject
        return *this;
    }
};
struct A : virtual V { }; // operator= calls V::operator=
struct B : virtual V { }; // operator= calls V::operator=
struct C : B, A { };      // operator= calls B::operator=, then A::operator=
                          // but they may only called V::operator= once
 
int main()
{
  C c1, c2;
  c2 = std::move(c1);
}</pre></div> </td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <h3 id="Notes">Notes</h3> <p>If both copy and move assignment operators are provided, overload resolution selects the move assignment if the argument is an <a href="value_category" title="cpp/language/value category"><i>rvalue</i></a> (either a <a href="value_category" title="cpp/language/value category"><i>prvalue</i></a> such as a nameless temporary or an <a href="value_category" title="cpp/language/value category"><i>xvalue</i></a> such as the result of <code>std::move</code>), and selects the copy assignment if the argument is an <a href="value_category" title="cpp/language/value category"><i>lvalue</i></a> (named object or a function/operator returning lvalue reference). If only the copy assignment is provided, all argument categories select it (as long as it takes its argument by value or as reference to const, since rvalues can bind to const references), which makes copy assignment the fallback for move assignment, when move is unavailable.</p>
<p>It is unspecified whether virtual base class subobjects that are accessible through more than one path in the inheritance lattice, are assigned more than once by the implicitly-defined move assignment operator (same applies to <a href="as_operator" title="cpp/language/copy assignment">copy assignment</a>).</p>
<p>See <a href="operators#Assignment_operator" title="cpp/language/operators">assignment operator overloading</a> for additional detail on the expected behavior of a user-defined move-assignment operator.</p>
<h3 id="Example">Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;
 
struct A
{
    std::string s;
    A() : s("test") { }
    A(const A&amp; o) : s(o.s) { std::cout &lt;&lt; "move failed!\n"; }
    A(A&amp;&amp; o) : s(std::move(o.s)) { }
    A&amp; operator=(const A&amp; other)
    {
         s = other.s;
         std::cout &lt;&lt; "copy assigned\n";
         return *this;
    }
    A&amp; operator=(A&amp;&amp; other)
    {
         s = std::move(other.s);
         std::cout &lt;&lt; "move assigned\n";
         return *this;
    }
};
 
A f(A a) { return a; }
 
struct B : A
{
     std::string s2; 
     int n;
     // implicit move assignment operator B&amp; B::operator=(B&amp;&amp;)
     // calls A's move assignment operator
     // calls s2's move assignment operator
     // and makes a bitwise copy of n
};
 
struct C : B
{
    ~C() { } // destructor prevents implicit move assignment
};
 
struct D : B
{
    D() { }
    ~D() { } // destructor would prevent implicit move assignment
    D&amp; operator=(D&amp;&amp;) = default; // force a move assignment anyway 
};
 
int main()
{
    A a1, a2;
    std::cout &lt;&lt; "Trying to move-assign A from rvalue temporary\n";
    a1 = f(A()); // move-assignment from rvalue temporary
    std::cout &lt;&lt; "Trying to move-assign A from xvalue\n";
    a2 = std::move(a1); // move-assignment from xvalue
 
    std::cout &lt;&lt; "Trying to move-assign B\n";
    B b1, b2;
    std::cout &lt;&lt; "Before move, b1.s = \"" &lt;&lt; b1.s &lt;&lt; "\"\n";
    b2 = std::move(b1); // calls implicit move assignment
    std::cout &lt;&lt; "After move, b1.s = \"" &lt;&lt; b1.s &lt;&lt; "\"\n";
 
    std::cout &lt;&lt; "Trying to move-assign C\n";
    C c1, c2;
    c2 = std::move(c1); // calls the copy assignment operator
 
    std::cout &lt;&lt; "Trying to move-assign D\n";
    D d1, d2;
    d2 = std::move(d1);
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">Trying to move-assign A from rvalue temporary
move assigned
Trying to move-assign A from xvalue
move assigned
Trying to move-assign B
Before move, b1.s = "test"
move assigned
After move, b1.s = "" 
Trying to move-assign C
copy assigned
Trying to move-assign D
move assigned</pre></div> </div>          <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/move_operator" class="_attribution-link">http://en.cppreference.com/w/cpp/language/move_operator</a>
  </p>
</div>
