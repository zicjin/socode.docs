   <h1 id="firstHeading" class="firstHeading">std::allocator</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/memory" title="cpp/header/memory">&lt;memory&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">template&lt; class T &gt;
struct allocator;</pre>
</td> <td> (1) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-until-cxx20"> <td> <pre data-language="cpp">template&lt;&gt;
struct allocator&lt;void&gt;;</pre>
</td> <td> (2) </td> <td> <span class="t-mark">(deprecated in C++17)</span> <br><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span> </td> </tr>  </table> <p>The <code>std::allocator</code> class template is the default <a href="../named_req/allocator" title="cpp/named req/Allocator">Allocator</a> used by all standard library containers if no user-specified allocator is provided. The default allocator is stateless, that is, all instances of the given allocator are interchangeable, compare equal and can deallocate memory allocated by any other instance of the same allocator type.</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p>The explicit specialization for <code>void</code> lacks the member typedefs <code>reference</code>, <code>const_reference</code>, <code>size_type</code> and <code>difference_type</code>. This specialization declares no member functions.</p>
</td> <td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> All custom allocators also must be stateless. </td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> Custom allocators may contain state. Each container or another allocator-aware object stores an instance of the supplied allocator and controls allocator replacement through <code><a href="allocator_traits" title="cpp/memory/allocator traits">std::allocator_traits</a></code>. </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> The default allocator satisfies <a href="../named_req/allocator#Allocator_completeness_requirements" title="cpp/named req/Allocator">allocator completeness requirements</a>. </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <h3 id="Member_types">Member types</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Type </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> <code>value_type</code> </td> <td> <code>T</code> </td>
</tr> <tr class="t-dsc"> <td> <code>pointer</code> <span class="t-mark">(deprecated in C++17)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span> </td> <td> <code>T*</code> </td>
</tr> <tr class="t-dsc"> <td> <code>const_pointer</code> <span class="t-mark">(deprecated in C++17)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span> </td> <td> <code>const T*</code> </td>
</tr> <tr class="t-dsc"> <td> <code>reference</code> <span class="t-mark">(deprecated in C++17)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span> </td> <td> <code>T&amp;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>const_reference</code> <span class="t-mark">(deprecated in C++17)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span> </td> <td> <code>const T&amp;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>size_type</code> </td> <td> <code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code> </td>
</tr> <tr class="t-dsc"> <td> <code>difference_type</code> </td> <td> <code><a href="../types/ptrdiff_t" title="cpp/types/ptrdiff t">std::ptrdiff_t</a></code> </td>
</tr> <tr class="t-dsc"> <td> <code>propagate_on_container_move_assignment</code><span class="t-mark-rev t-since-cxx14">(C++14)</span> </td> <td> <code><a href="../types/integral_constant"><span class="kw645">std::<span class="me2">true_type</span></span></a></code> </td>
</tr> <tr class="t-dsc"> <td> <code>rebind</code> <span class="t-mark">(deprecated in C++17)</span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span> </td> <td> <code>template&lt; class U &gt; struct rebind { typedef allocator&lt;U&gt; other; };</code> </td>
</tr> <tr class="t-dsc"> <td> <code>is_always_equal</code><span class="t-mark-rev t-since-cxx17">(C++17)</span> </td> <td> <code><a href="../types/integral_constant"><span class="kw645">std::<span class="me2">true_type</span></span></a></code> </td>
</tr> </table> <h3 id="Member_functions">Member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="allocator/allocator" title="cpp/memory/allocator/allocator"> <span class="t-lines"><span>(constructor)</span></span></a></div> </td> <td> creates a new allocator instance <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="allocator/~allocator" title="cpp/memory/allocator/~allocator"> <span class="t-lines"><span>(destructor)</span></span></a></div> </td> <td> destructs an allocator instance <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="allocator/address" title="cpp/memory/allocator/address"> <span class="t-lines"><span>address</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> obtains the address of an object, even if <code>operator&amp;</code> is overloaded <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="allocator/allocate" title="cpp/memory/allocator/allocate"> <span class="t-lines"><span>allocate</span></span></a></div> </td> <td> allocates uninitialized storage <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="allocator/deallocate" title="cpp/memory/allocator/deallocate"> <span class="t-lines"><span>deallocate</span></span></a></div> </td> <td> deallocates storage <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="allocator/max_size" title="cpp/memory/allocator/max size"> <span class="t-lines"><span>max_size</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> returns the largest supported allocation size <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="allocator/construct" title="cpp/memory/allocator/construct"> <span class="t-lines"><span>construct</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> constructs an object in allocated storage <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="allocator/destroy" title="cpp/memory/allocator/destroy"> <span class="t-lines"><span>destroy</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> destructs an object in allocated storage <br> <span class="t-mark">(public member function)</span> </td>
</tr> </table> <h3 id="Non-member_functions">Non-member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="allocator/operator_cmp" title="cpp/memory/allocator/operator cmp"> <span class="t-lines"><span>operator==</span><span>operator!=</span></span></a></div> </td> <td> compares two allocator instances <br> <span class="t-mark">(public member function)</span> </td>
</tr> </table> <h3 id="Notes">Notes</h3> <p>The member template class <code>rebind</code> provides a way to obtain an allocator for a different type. For example,</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <code>std::list&lt;T, A&gt;</code> allocates nodes of some internal type <code>Node&lt;T&gt;</code>, using the allocator <code>A::rebind&lt;Node&lt;T&gt;&gt;::other</code> </td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <code>std::list&lt;T, A&gt;</code> allocates nodes of some internal type <code>Node&lt;T&gt;</code>, using the allocator <code><a href="allocator_traits"><span class="kw695">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>A<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">rebind_alloc</span><span class="sy1">&lt;</span>Node<span class="sy1">&lt;</span>T<span class="sy1">&gt;&gt;</span></code>, which is implemented in terms of <code>A::rebind&lt;Node&lt;T&gt;&gt;::other</code> if A is an <code>std::allocator</code> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Example">Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;memory&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
 
int main()
{
    std::allocator&lt;int&gt; a1;   // default allocator for ints
    int* a = a1.allocate(1);  // space for one int
    a1.construct(a, 7);       // construct the int
    std::cout &lt;&lt; a[0] &lt;&lt; '\n';
    a1.deallocate(a, 1);      // deallocate space for one int
 
    // default allocator for strings
    std::allocator&lt;std::string&gt; a2;
 
    // same, but obtained by rebinding from the type of a1
    decltype(a1)::rebind&lt;std::string&gt;::other a2_1;
 
    // same, but obtained by rebinding from the type of a1 via allocator_traits
    std::allocator_traits&lt;decltype(a1)&gt;::rebind_alloc&lt;std::string&gt; a2_2;
 
    std::string* s = a2.allocate(2); // space for 2 strings
 
    a2.construct(s, "foo");
    a2.construct(s + 1, "bar");
 
    std::cout &lt;&lt; s[0] &lt;&lt; ' ' &lt;&lt; s[1] &lt;&lt; '\n';
 
    a2.destroy(s);
    a2.destroy(s + 1);
    a2.deallocate(s, 2);
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">7
foo bar</pre></div> </div> <h3 id="See_also">See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="allocator_traits" title="cpp/memory/allocator traits"> <span class="t-lines"><span>allocator_traits</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> provides information about allocator types <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="scoped_allocator_adaptor" title="cpp/memory/scoped allocator adaptor"> <span class="t-lines"><span>scoped_allocator_adaptor</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> implements multi-level allocator for multi-level containers <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="uses_allocator" title="cpp/memory/uses allocator"> <span class="t-lines"><span>uses_allocator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> checks if the specified type supports uses-allocator construction <br> <span class="t-mark">(class template)</span> </td>
</tr> </table>          <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/memory/allocator" class="_attribution-link">http://en.cppreference.com/w/cpp/memory/allocator</a>
  </p>
</div>
