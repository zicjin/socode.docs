   <h1 id="firstHeading" class="firstHeading">std::pointer_traits</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/memory" title="cpp/header/memory">&lt;memory&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class Ptr &gt; struct pointer_traits;</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class T &gt; struct pointer_traits&lt;T*&gt;;</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr>  </table> <p>The <code>pointer_traits</code> class template provides the standardized way to access certain properties of pointer-like types (<a href="../named_req/allocator#Fancy_pointers" title="cpp/named req/Allocator">fancy pointers</a>, such as <a rel="nofollow" class="external text" href="http://www.boost.org/doc/libs/release/doc/html/interprocess/offset_ptr.html">boost::interprocess::offset_ptr</a>). The standard template <code><a href="allocator_traits" title="cpp/memory/allocator traits">std::allocator_traits</a></code> relies on <code>pointer_traits</code> to determine the defaults for various typedefs required by <a href="../named_req/allocator" title="cpp/named req/Allocator">Allocator</a>.</p>
<p>1) The non-specialized <code>pointer_traits</code> declares the following types:</p>
<div class="t-member"> <h3 id="Member_types">Member types</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Type </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> <code>pointer</code> </td> <td> <code>Ptr</code> </td>
</tr> <tr class="t-dsc"> <td> <code>element_type</code> </td> <td> <code>Ptr::element_type</code> if present. Otherwise <code>T</code> if <code>Ptr</code> is a template instantiation <code>Template&lt;T, Args...&gt;</code> </td>
</tr> <tr class="t-dsc"> <td> <code>difference_type</code> </td> <td> <code>Ptr::difference_type</code> if present, otherwise <code><a href="../types/ptrdiff_t" title="cpp/types/ptrdiff t">std::ptrdiff_t</a></code> </td>
</tr> </table> <h3 id="Member_alias_templates">Member alias templates</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Template </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> template &lt;class U&gt; using rebind </td> <td> <code>Ptr::rebind&lt;U&gt;</code> if exists, otherwise <code>Template&lt;U, Args...&gt;</code> if <code>Ptr</code> is a template instantiation <code>Template&lt;T, Args...&gt;</code> </td>
</tr> </table> <h3 id="Member_functions">Member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="pointer_traits/pointer_to" title="cpp/memory/pointer traits/pointer to"> <span class="t-lines"><span>pointer_to</span></span></a></div>
<div><span class="t-lines"><span><span class="t-cmark">[static]</span></span></span></div> </td> <td> obtains a dereferenceable pointer to its argument <br> <span class="t-mark">(public static member function)</span> </td>
</tr> </table> </div> <p>2) A specialization is provided for pointer types, <code>T*</code>, which declares the following types.</p>
<div class="t-member"> <h3 id="Member_types_2">Member types</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Type </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> <code>pointer</code> </td> <td> <code>T*</code> </td>
</tr> <tr class="t-dsc"> <td> <code>element_type</code> </td> <td> <code>T</code> </td>
</tr> <tr class="t-dsc"> <td> <code>difference_type</code> </td> <td> <code><a href="../types/ptrdiff_t" title="cpp/types/ptrdiff t">std::ptrdiff_t</a></code> </td>
</tr> </table> <h3 id="Member_alias_templates_2">Member alias templates</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Template </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> template&lt; class U &gt; using rebind </td> <td> <code>U*</code> </td>
</tr> </table> <h3 id="Member_functions_2">Member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="pointer_traits/pointer_to" title="cpp/memory/pointer traits/pointer to"> <span class="t-lines"><span>pointer_to</span></span></a></div>
<div><span class="t-lines"><span><span class="t-cmark">[static]</span></span></span></div> </td> <td> obtains a dereferenceable pointer to its argument <br> <span class="t-mark">(public static member function)</span> </td>
</tr> </table> </div> <p>3) A specialization for user-defined fancy pointer types may define an additional static member function.</p>
<div class="t-member"> <h3 id="Optional_Member_functions">Optional Member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="pointer_traits/to_address" title="cpp/memory/pointer traits/to address"> <span class="t-lines"><span>to_address</span></span></a></div>
<div><span class="t-lines"><span><span class="t-cmark">[static]</span> <span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> obtains a raw pointer from a fancy pointer (inverse of pointer_to) <br> <span class="t-mark">(public static member function)</span> </td>
</tr> </table> </div> <h3 id="Notes">Notes</h3> <p>The rebind member template alias makes it possible, given a pointer-like type that points to T, to obtain the same pointer-like type that points to U. For example,</p>
<div class="cpp source-cpp"><pre data-language="cpp">using another_pointer = std::pointer_traits&lt;std::shared_ptr&lt;int&gt;&gt;::rebind&lt;double&gt;;
static_assert(std::is_same&lt;another_pointer, std::shared_ptr&lt;double&gt;&gt;::value);</pre></div> <h3 id="Example">Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;memory&gt;
#include &lt;iostream&gt;
 
template &lt;class Ptr&gt;
struct BlockList
{
   // Predefine a memory block 
   struct block;
 
   // Define a pointer to a memory block from the kind of pointer Ptr s
   // If Ptr is any kind of T*, block_ptr_t is block*
   // If Ptr is smart_ptr&lt;T&gt;, block_ptr_t is smart_ptr&lt;block&gt;
   using block_ptr_t = typename std::pointer_traits&lt;Ptr&gt;::template rebind&lt;block&gt;;
 
   struct block
   {
      std::size_t size;
      block_ptr_t next_block;
   }; 
 
   block_ptr_t free_blocks;
}; 
 
int main()
{
    BlockList&lt;int*&gt; bl1;
    // The type of bl1.free_blocks is block*
 
    BlockList&lt;std::shared_ptr&lt;char&gt;&gt; bl2;
    // The type of bl2.free_blocks is std::shared_ptr&lt;block&gt;
    std::cout &lt;&lt; bl2.free_blocks.use_count() &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">​0​</pre></div> </div> <h3 id="See_also">See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="allocator_traits" title="cpp/memory/allocator traits"> <span class="t-lines"><span>allocator_traits</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> provides information about allocator types <br> <span class="t-mark">(class template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="addressof" title="cpp/memory/addressof"> <span class="t-lines"><span>addressof</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> obtains actual address of an object, even if the <i>&amp;</i> operator is overloaded <br> <span class="t-mark">(function template)</span> </td>
</tr> </table>          <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/memory/pointer_traits" class="_attribution-link">http://en.cppreference.com/w/cpp/memory/pointer_traits</a>
  </p>
</div>
