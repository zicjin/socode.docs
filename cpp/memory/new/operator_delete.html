   <h1 id="firstHeading" class="firstHeading">operator delete, operator delete[]</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../../header/new" title="cpp/header/new">&lt;new&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl-h"> <td> replaceable usual deallocation functions</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void operator delete  ( void* ptr );</pre>
</td> <td> (1) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void operator delete[]( void* ptr );</pre>
</td> <td> (2) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void operator delete  ( void* ptr, std::align_val_t al );</pre>
</td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void operator delete[]( void* ptr, std::align_val_t al );</pre>
</td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx14"> <td> <pre data-language="cpp">void operator delete  ( void* ptr, std::size_t sz );</pre>
</td> <td> (5) </td> <td> <span class="t-mark-rev t-since-cxx14">(since C++14)</span> </td> </tr> <tr class="t-dcl t-since-cxx14"> <td> <pre data-language="cpp">void operator delete[]( void* ptr, std::size_t sz );</pre>
</td> <td> (6) </td> <td> <span class="t-mark-rev t-since-cxx14">(since C++14)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void operator delete  ( void* ptr, std::size_t sz, std::align_val_t al );</pre>
</td> <td> (7) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void operator delete[]( void* ptr, std::size_t sz, std::align_val_t al );</pre>
</td> <td> (8) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl-h"> <td> replaceable placement deallocation functions</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void operator delete  ( void* ptr, const std::nothrow_t&amp; tag );</pre>
</td> <td> (9) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void operator delete[]( void* ptr, const std::nothrow_t&amp; tag );</pre>
</td> <td> (10) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void operator delete  ( void* ptr,
                        std::align_val_t al, const std::nothrow_t&amp; tag );</pre>
</td> <td> (11) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void operator delete[]( void* ptr, 
                        std::align_val_t al, const std::nothrow_t&amp; tag );</pre>
</td> <td> (12) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl-h"> <td> non-allocating placement deallocation functions</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void operator delete  ( void* ptr, void* place );</pre>
</td> <td> (13) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void operator delete[]( void* ptr, void* place );</pre>
</td> <td> (14) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl-h"> <td> user-defined placement deallocation functions</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void operator delete  ( void* ptr, args... );</pre>
</td> <td> (15) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void operator delete[]( void* ptr, args... );</pre>
</td> <td> (16) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl-h"> <td> class-specific usual deallocation functions</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void T::operator delete  ( void* ptr );</pre>
</td> <td> (17) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void T::operator delete[]( void* ptr );</pre>
</td> <td> (18) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void T::operator delete  ( void* ptr, std::align_val_t al );</pre>
</td> <td> (19) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void T::operator delete[]( void* ptr, std::align_val_t al );</pre>
</td> <td> (20) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void T::operator delete  ( void* ptr, std::size_t sz );</pre>
</td> <td> (21) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void T::operator delete[]( void* ptr, std::size_t sz );</pre>
</td> <td> (22) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void T::operator delete  ( void* ptr, std::size_t sz, std::align_val_t al );</pre>
</td> <td> (23) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">void T::operator delete[]( void* ptr, std::size_t sz, std::align_val_t al );</pre>
</td> <td> (24) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl-h"> <td> class-specific placement deallocation functions</td> <td></td> <td></td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void T::operator delete  ( void* ptr, args... );</pre>
</td> <td> (25) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void T::operator delete[]( void* ptr, args... );</pre>
</td> <td> (26) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl-h"> <td> class-specific destroying deallocation functions</td> <td></td> <td></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">void T::operator delete(T* ptr, std::destroying_delete_t);</pre>
</td> <td> (27) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">void T::operator delete(T* ptr, std::destroying_delete_t,  std::align_val_t);</pre>
</td> <td> (28) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">void T::operator delete(T* ptr, std::destroying_delete_t, std::size_t);</pre>
</td> <td> (29) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">void T::operator delete(T* ptr, std::destroying_delete_t,
                                         std::size_t, std::align_val_t);</pre>
</td> <td> (30) </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>  </table> <p>Deallocates storage previously allocated by a matching <code><a href="operator_new" title="cpp/memory/new/operator new">operator new</a></code>. These deallocation functions are called by <a href="../../language/delete" title="cpp/language/delete">delete-expressions</a> and by <a href="../../language/new" title="cpp/language/new">new-expressions</a> to deallocate memory after destructing (or failing to construct) objects with dynamic storage duration. They may also be called using regular function call syntax.</p>
<div class="t-li1">
<span class="t-li">1)</span> Called by <a href="../../language/delete" title="cpp/language/delete">delete-expressions</a> to deallocate storage previously allocated for a single object. The behavior of the standard library implementation of this function is undefined unless <code>ptr</code> is a null pointer or is a pointer previously obtained from the standard library implementation of <code><a href="operator_new"><span class="kw683">operator new</span></a><span class="br0">(</span>size_t<span class="br0">)</span></code> or <code><a href="operator_new"><span class="kw683">operator new</span></a><span class="br0">(</span>size_t, <a href="nothrow_t"><span class="kw689">std::<span class="me2">nothrow_t</span></span></a><span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">2)</span> Called by <a href="../../language/delete" title="cpp/language/delete">delete[]-expressions</a> to deallocate storage previously allocated for an array of objects. The behavior of the standard library implementation of this function is undefined unless <code>ptr</code> is a null pointer or is a pointer previously obtained from the standard library implementation of <code><a href="operator_new"><span class="kw683">operator new</span></a><span class="br0">[</span><span class="br0">]</span><span class="br0">(</span>size_t<span class="br0">)</span></code> or <code><a href="operator_new"><span class="kw683">operator new</span></a><span class="br0">[</span><span class="br0">]</span><span class="br0">(</span>size_t, <a href="nothrow_t"><span class="kw689">std::<span class="me2">nothrow_t</span></span></a><span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">3,4)</span> Same as <span class="t-v">(1,2)</span>, except called if the alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>
</div> <div class="t-li1">
<span class="t-li">5-6)</span> Called instead of <span class="t-v">(1-2)</span> if a user-defined replacement is provided, except that it's unspecified whether <span class="t-v">(1-2)</span> or <span class="t-v">(5-6)</span> is called when deleting objects of incomplete type and arrays of non-class and trivially-destructible class types. A memory allocator can use the given size to be more efficient. The standard library implementations are identical to <span class="t-v">(1-2)</span>.</div> <div class="t-li1">
<span class="t-li">7-8)</span> Same as <span class="t-v">(5-6)</span>, except called if the alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>
</div> <div class="t-li1">
<span class="t-li">9)</span> Called by the non-throwing single-object <a href="../../language/new" title="cpp/language/new">new-expressions</a> if a constructor of the object throws an exception. The standard library implementation behaves the same as <span class="t-v">(1)</span>
</div> <div class="t-li1">
<span class="t-li">10)</span> Called by the non-throwing array <a href="../../language/new" title="cpp/language/new">new[]-expressions</a> if a constructor of any object throws an exception (after executing the destructors of all objects in the array that were successfully constructed). The standard library implementation behaves the same as <span class="t-v">(2)</span>
</div> <div class="t-li1">
<span class="t-li">11,12)</span> Same as <span class="t-v">(9,10)</span>, except called if the alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>
</div> <div class="t-li1">
<span class="t-li">13)</span> Called by the standard single-object <a href="../../language/new" title="cpp/language/new">placement new</a> expression if the object's constructor throws an exception. The standard library implementation of this function does nothing.</div> <div class="t-li1">
<span class="t-li">14)</span> Called by the standard array form of the <a href="../../language/new" title="cpp/language/new">placement new</a> expression if any of the objects' constructors throws an exception (after executing the destructors of all objects that were constructed successfully). The standard library implementation of this function does nothing. </div> <div class="t-li1">
<span class="t-li">15)</span> If defined, called by the custom single-object <a href="../../language/new" title="cpp/language/new">placement new</a> expression with the matching signature if the object's constructor throws an exception. If a class-specific version <span class="t-v">(25)</span> is defined, it is called in preference to <span class="t-v">(9)</span>. If neither <span class="t-v">(25)</span> nor <span class="t-v">(15)</span> is provided by the user, no deallocation function is called. </div> <div class="t-li1">
<span class="t-li">16)</span> If defined, called by the custom array form of <a href="../../language/new" title="cpp/language/new">placement new[] </a> expression with the matching signature if any of the objects' constructors throws an exception (after executing the destructors for all objects that were constructed successfully). If a class-specific version <span class="t-v">(16)</span> is defined, it is called in preference to <span class="t-v">(10)</span>. If neither <span class="t-v">(26)</span> nor <span class="t-v">(16)</span> is provided by the user, no deallocation function is called</div> <div class="t-li1">
<span class="t-li">17)</span> If defined, called by the usual single-object <a href="../../language/delete" title="cpp/language/delete">delete-expressions</a> if deallocating an object of type T.</div> <div class="t-li1">
<span class="t-li">18)</span> If defined, called by the usual array <a href="../../language/delete" title="cpp/language/delete">delete[]-expressions</a> if deallocating an array of objects of type T.</div> <div class="t-li1">
<span class="t-li">19,20)</span> If defined, called in preference to <span class="t-v">(17,18)</span> if the alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>.</div> <div class="t-li1">
<span class="t-li">21)</span> If defined, and if <span class="t-v">(17)</span> is not defined, called by the usual single-object <a href="../../language/delete" title="cpp/language/delete">delete-expressions</a> if deallocating an object of type T.</div> <div class="t-li1">
<span class="t-li">22)</span> If defined, and if <span class="t-v">(18)</span> is not defined, called by the usual array <a href="../../language/delete" title="cpp/language/delete">delete[]-expressions</a> if deallocating an array of objects of type T.</div> <div class="t-li1">
<span class="t-li">23,24)</span> If defined, and if <span class="t-v">(19,20)</span> are not defined, called in preference to allocator-unaware members if the alignment requirement exceeds <code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code>.</div> <div class="t-li1">
<span class="t-li">25)</span> If defined, called by the custom single-object <a href="../../language/new" title="cpp/language/new">placement new</a> expression with the matching signature if the object's constructor throws an exception. If this function is not provided, and a matching <span class="t-v">(15)</span> is not provided either, no deallocation function is called.</div> <div class="t-li1">
<span class="t-li">26)</span> If defined, called by the custom array form of <a href="../../language/new" title="cpp/language/new">placement new[] </a> expression with the matching signature if any of the objects' constructors throws an exception (after executing the destructors for all objects that were constructed successfully). If this function is not provided, and a matching <span class="t-v">(16)</span> is not provided either, no deallocation function is called.</div> <div class="t-li1">
<span class="t-li">27-30)</span> If defined, <a href="../../language/delete" title="cpp/language/delete">delete-expressions</a> does not execute the destructor for *p before placing a call to <code>operator delete</code>. Instead, direct invocation of the destructor such as by <code>p-&gt;~T();</code> becomes the responsibility of this user-defined operator delete.</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>See <a href="../../language/delete" title="cpp/language/delete">delete-expression</a> for exact details on the overload resolution rules between alignment-aware and alignment-unaware overloads of usual (non-placement) deallocation functions.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <p>In all cases, if <code>ptr</code> is a null pointer, the standard library deallocation functions do nothing. If the pointer passed to the standard library deallocation function was not obtained from the corresponding standard library allocation function, the behavior is undefined.</p>
<p>After the standard library deallocation function returns, all pointers referring to any part of the deallocated storage become invalid.</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx14">
<td> <p>Any use of a pointer that became invalid in this manner, even copying the pointer value into another variable, is undefined behavior.</p>
</td> <td><span class="t-mark-rev t-until-cxx14">(until C++14)</span></td>
</tr> <tr class="t-rev t-since-cxx14">
<td> <p>Indirection through a pointer that became invalid in this manner and passing it to a deallocation function (double-delete) is undefined behavior. Any other use is implementation-defined.</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <h3 id="Parameters">Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> ptr </td> <td> - </td> <td> pointer to a memory block to deallocate or a null pointer </td>
</tr> <tr class="t-par"> <td> sz </td> <td> - </td> <td> the size that was passed to the matching allocation function </td>
</tr> <tr class="t-par"> <td> place </td> <td> - </td> <td> pointer used as the placement parameter in the matching placement new </td>
</tr> <tr class="t-par"> <td> tag </td> <td> - </td> <td> overload disambiguation tag matching the tag used by non-throwing operator new </td>
</tr> <tr class="t-par"> <td> al </td> <td> - </td> <td> alignment of the object or array element that was allocated </td>
</tr> <tr class="t-par"> <td> args </td> <td> - </td> <td> arbitrary parameters matching a placement allocation function (may include <code><a href="../../types/size_t" title="cpp/types/size t">std::size_t</a></code> and <code><a href="align_val_t" title="cpp/memory/new/align val t">std::align_val_t</a></code>) </td>
</tr>
</table> <h3 id="Return_value">Return value</h3> <p>(none).</p>
<h3 id="Exceptions">Exceptions</h3> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> (none)</td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <a href="../../language/noexcept_spec" title="cpp/language/noexcept spec"><code>noexcept</code></a> specification: <div class="t-noexcept-box"><span class="t-cc"><code>noexcept</code></span></div> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Global_replacements">Global replacements</h3> <p>The replaceable deallocation functions <span class="t-v">(1-10)</span> are implicitly declared in each translation unit even if the <code>&lt;new&gt;</code> header is not included. These functions are <i>replaceable</i>: a user-provided non-member function with the same signature defined anywhere in the program, in any source file, replaces the corresponding implicit version for the entire program. Its declaration does not need to be visible.</p>
<p>The behavior is undefined if more than one replacement is provided in the program or if a replacement is defined with the <code>inline</code> specifier, the program is ill-formed if a replacement is defined in namespace other than global namespace, or if it is defined as a static non-member function at global scope.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>The standard library implementations of the nothrow versions <span class="t-v">(9,10)</span> directly call the corresponding throwing versions <span class="t-v">(1,2)</span>. The standard library implementations of the size-aware deallocation functions <span class="t-v">(5-8)</span> directly call the corresponding size-unaware deallocation functions <span class="t-v">(1-4)</span>. The standard library implementations of size-unaware throwing array forms <span class="t-v">(2,4)</span> directly calls the corresponding single-object forms <span class="t-v">(1,3)</span>.</p>
<p>Thus, replacing the throwing single object deallocation functions <span class="t-v">(1,3)</span> is sufficient to handle all deallocations.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
// replacement of a minimal set of functions:
void* operator new(std::size_t sz) {
    std::printf("global op new called, size = %zu\n",sz);
    return std::malloc(sz);
}
void operator delete(void* ptr) noexcept
{
    std::puts("global op delete called");
    std::free(ptr);
}
int main() {
     int* p1 = new int;
     delete p1;
 
     int* p2 = new int[10]; // guaranteed to call the replacement in C++11
     delete[] p2;
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">global op new called, size = 4
global op delete called
global op new called, size = 40
global op delete called</pre></div> </div> <p>Overloads of <code>operator delete</code> and <code>operator delete[]</code> with additional user-defined parameters ("placement forms", <span class="t-v">(15,16)</span>) may be declared at global scope as usual, and are called by the matching placement forms of <i>new-expressions</i> if a constructor of the object that is being allocated throws an exception.</p>
<p>The standard library placement forms of operator delete <span class="t-v">(13,14)</span> cannot be replaced and can only be customized if the placement new-expression did not use the <code>::new</code> syntax, by providing a class-specific placement delete <span class="t-v">(25,26)</span> with matching signature: <code>void T::operator delete(void*, void*)</code> or <code>void T::operator delete[](void*, void*)</code>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> All deallocation functions are <code>noexcept(true)</code> unless specified otherwise in the declaration.</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Class-specific_overloads">Class-specific overloads</h3> <p>Deallocation functions <span class="t-v">(17-24)</span> may be defined as static member functions of a class. These deallocation functions, if provided, are called by <a href="../../language/delete" title="cpp/language/delete">delete-expressions</a> when deleting objects <span class="t-v">(17,19,21)</span> and arrays <span class="t-v">(18,20,22)</span> of this class, unless the delete expression used the form <code>::delete</code> which bypasses class-scope lookup. The keyword <code>static</code> is optional for these function declarations: whether the keyword is used or not, the deallocation function is always a static member function.</p>
<p>The delete expression looks for appropriate deallocation function's name starting from the class scope (array form looks in the scope of the array element class) and proceeds to the global scope if no members are found as usual. Note, that as per <a href="../../language/lookup" title="cpp/language/lookup">name lookup rules</a>, any deallocation functions declared in class scope hides all global deallocation functions.</p>
<p>If the static type of the object that is being deleted differs from its dynamic type (such as when deleting a <a href="../../language/objects" title="cpp/language/object">polymorphic</a> object through a pointer to base), and if the destructor in the static type is virtual, the single object form of delete begins lookup of the deallocation function's name starting from the point of definition of the final overrider of its virtual destructor. Regardless of which deallocation function would be executed at run time, the statically visible version of operator delete must be accessible in order to compile. In other cases, when deleting an array through a pointer to base, or when deleting through pointer to base with non-virtual destructor, the behavior is undefined.</p>
<p>If the single-argument overload <span class="t-v">(17,18)</span> is not provided, but the size-aware overload taking <code>std::size_t</code> as the second parameter <span class="t-v">(21,22)</span> is provided, the size-aware form is called for normal deallocation, and the C++ runtime passes the size of the object to be deallocated as the second argument. If both forms are defined, the size-unaware version is called.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
// sized class-specific deallocation functions
struct X {
    static void operator delete(void* ptr, std::size_t sz)
    {
        std::cout &lt;&lt; "custom delete for size " &lt;&lt; sz &lt;&lt; '\n';
        ::operator delete(ptr);
    }
    static void operator delete[](void* ptr, std::size_t sz)
    {
        std::cout &lt;&lt; "custom delete for size " &lt;&lt; sz &lt;&lt; '\n';
        ::operator delete(ptr);
    }
};
int main() {
     X* p1 = new X;
     delete p1;
     X* p2 = new X[10];
     delete[] p2;
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">custom delete for size 1
custom delete for size 18</pre></div> </div> <p>Overloads of <code>operator delete</code> and <code>operator delete[]</code> with additional user-defined parameters ("placement forms", <span class="t-v">(25,26)</span>) may also be defined as class members. When the failed placement new expression looks for the corresponding placement delete function to call, it begins lookup at class scope before examining the global scope, and looks for the function with the signature matching the placement new:</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;stdexcept&gt;
#include &lt;iostream&gt;
struct X {
    X() { throw std::runtime_error(""); }
    // custom placement new
    static void* operator new(std::size_t sz, bool b) {
        std::cout &lt;&lt; "custom placement new called, b = " &lt;&lt; b &lt;&lt; '\n';
        return ::operator new(sz);
    }
    // custom placement delete
    static void operator delete(void* ptr, bool b)
    {
        std::cout &lt;&lt; "custom placement delete called, b = " &lt;&lt; b &lt;&lt; '\n';
        ::operator delete(ptr);
    }
};
int main() {
   try {
     X* p1 = new (true) X;
   } catch(const std::exception&amp;) { }
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">custom placement new called, b = 1
custom placement delete called, b = 1</pre></div> </div> <p>If class-level <code>operator delete</code> is a template function, it must have the return type of <code>void</code>, the first argument <code>void*</code>, and it must have two or more parameters. In other words, only placement forms can be templates. The specialization of the template operator delete is chosen with <a href="../../language/template_argument_deduction" title="cpp/language/template argument deduction">template argument deduction</a>.</p>
<h3 id="Notes">Notes</h3> <p>The call to the class-specific <code>T::operator delete</code> on a polymorphic class is the only case where a static member function is called through dynamic dispatch.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>The following functions are required to be thread-safe:</p>
<ul>
<li> The library versions of <a href="operator_new" title="cpp/memory/new/operator new"><code>operator new</code></a> and <strong class="selflink"><code>operator delete</code></strong> </li>
<li> User replacement versions of global <a href="operator_new" title="cpp/memory/new/operator new"><code>operator new</code></a> and <strong class="selflink"><code>operator delete</code></strong> </li>
<li> <code><a href="../c/calloc" title="cpp/memory/c/calloc">std::calloc</a></code>, <code><a href="../c/malloc" title="cpp/memory/c/malloc">std::malloc</a></code>, <code><a href="../c/realloc" title="cpp/memory/c/realloc">std::realloc</a></code><span class="t-rev-inl t-since-cxx17"><span>, <code><a href="../c/aligned_alloc" title="cpp/memory/c/aligned alloc">std::aligned_alloc</a></code></span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>, <code><a href="../c/free" title="cpp/memory/c/free">std::free</a></code> </li>
</ul> <p>Calls to these functions that allocate or deallocate a particular unit of storage occur in a single total order, and each such deallocation call <a href="../../atomic/memory_order" title="cpp/atomic/memory order">happens-before</a> the next allocation (if any) in this order.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Defect_reports">Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2458">LWG 2458</a> </td> <td> C++14 </td> <td> overloads taking (void*,size_t,const nothrow_t&amp;) were specified, but could never be called </td> <td> spurious overloads removed </td>
</tr>
</table> <h3 id="See_also">See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="operator_new" title="cpp/memory/new/operator new"> <span class="t-lines"><span>operator new</span><span>operator new[]</span></span></a></div> </td> <td> allocation functions <br> <span class="t-mark">(function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../return_temporary_buffer" title="cpp/memory/return temporary buffer"> <span class="t-lines"><span>return_temporary_buffer</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark">(deprecated in C++17)</span></span><span><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span></span></span></div> </td> <td> frees uninitialized storage <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../c/free" title="cpp/memory/c/free"> <span class="t-lines"><span>free</span></span></a></div> </td> <td> deallocates memory <br> <span class="t-mark">(function)</span> </td>
</tr> </table>          <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/memory/new/operator_delete" class="_attribution-link">http://en.cppreference.com/w/cpp/memory/new/operator_delete</a>
  </p>
</div>
