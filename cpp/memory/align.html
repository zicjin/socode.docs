   <h1 id="firstHeading" class="firstHeading">std::align</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/memory" title="cpp/header/memory">&lt;memory&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">void* align( std::size_t alignment,
             std::size_t size,
             void*&amp; ptr,
             std::size_t&amp; space );</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr>  </table> <p>Given a pointer <span class="t-spar">ptr</span> to a buffer of size <span class="t-spar">space</span>, returns a pointer aligned by the specified <span class="t-spar">alignment</span> for <span class="t-spar">size</span> number of bytes and decreases <span class="t-spar">space</span> argument by the number of bytes used for alignment. The first aligned address is returned.</p>
<p>The function modifies the pointer only if it would be possible to fit the wanted number of bytes aligned by the given alignment into the buffer. If the buffer is too small, the function does nothing and returns <code>nullptr</code>.</p>
<p>The behavior is undefined if <span class="t-spar">alignment</span> is not a power of two.</p>
<h3 id="Parameters">Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> alignment </td> <td> - </td> <td> the desired alignment </td>
</tr> <tr class="t-par"> <td> size </td> <td> - </td> <td> the size of the storage to be aligned </td>
</tr> <tr class="t-par"> <td> ptr </td> <td> - </td> <td> pointer to contiguous storage of at least <code>space</code> bytes </td>
</tr> <tr class="t-par"> <td> space </td> <td> - </td> <td> the size of the buffer in which to operate </td>
</tr>
</table> <h3 id="Return_value">Return value</h3> <p>The adjusted value of <code>ptr</code>, or null pointer value if the space provided is too small.</p>
<h3 id="Example">Example</h3> <div class="t-example">
<p>demonstrates the use of std::align to place objects of different type in memory.</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
 
template &lt;std::size_t N&gt;
struct MyAllocator
{
    char data[N];
    void* p;
    std::size_t sz;
    MyAllocator() : p(data), sz(N) {}
    template &lt;typename T&gt;
    T* aligned_alloc(std::size_t a = alignof(T))
    {
        if (std::align(a, sizeof(T), p, sz))
        {
            T* result = reinterpret_cast&lt;T*&gt;(p);
            p = (char*)p + sizeof(T);
            sz -= sizeof(T);
            return result;
        }
        return nullptr;
    }
};
 
int main()
{
    MyAllocator&lt;64&gt; a;
 
    // allocate a char
    char* p1 = a.aligned_alloc&lt;char&gt;();
    if (p1)
        *p1 = 'a';
    std::cout &lt;&lt; "allocated a char at " &lt;&lt; (void*)p1 &lt;&lt; '\n';
 
    // allocate an int
    int* p2 = a.aligned_alloc&lt;int&gt;();
    if (p2)
        *p2 = 1;
    std::cout &lt;&lt; "allocated an int at " &lt;&lt; (void*)p2 &lt;&lt; '\n';
 
    // allocate an int, aligned at 32-byte boundary
    int* p3 = a.aligned_alloc&lt;int&gt;(32);
    if (p3)
        *p3 = 2;
    std::cout &lt;&lt; "allocated an int at " &lt;&lt; (void*)p3 &lt;&lt; " (32 byte alignment)\n";
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">allocated a char at 0x2ff21a08
allocated an int at 0x2ff21a0c
allocated an int at 0x2ff21a20 (32 byte alignment)</pre></div> </div> <h3 id="Defect_reports"> Defect reports </h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2377">LWG 2377</a> </td> <td> C++11 </td> <td> <code>alignment</code> required to be a fundamental or supported extended alignment value </td> <td> only need to be a power of two </td>
</tr>
</table> <h3 id="See_also">See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <a href="../language/alignof" title="cpp/language/alignof"> alignof operator </a> </td> <td> queries alignment requirements of a type <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> <tr class="t-dsc"> <td> <a href="../language/alignas" title="cpp/language/alignas"> alignas specifier </a> </td> <td> specifies that the storage for the variable should be aligned by specific amount <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../types/aligned_storage" title="cpp/types/aligned storage"> <span class="t-lines"><span>aligned_storage</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> defines the type suitable for use as uninitialized storage for types of given size <br> <span class="t-mark">(class template)</span> </td>
</tr> </table>          <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/memory/align" class="_attribution-link">http://en.cppreference.com/w/cpp/memory/align</a>
  </p>
</div>
