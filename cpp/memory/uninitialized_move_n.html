   <h1 id="firstHeading" class="firstHeading">std::uninitialized_move_n</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/memory" title="cpp/header/memory">&lt;memory&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">template&lt; class InputIt, class Size, class ForwardIt &gt;
std::pair&lt;InputIt, ForwardIt&gt; uninitialized_move_n( InputIt first, Size count,
                                                    ForwardIt d_first );</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">template&lt; class ExecutionPolicy, class InputIt, class Size, class ForwardIt &gt;
std::pair&lt;InputIt, ForwardIt&gt; uninitialized_move_n( ExecutionPolicy&amp;&amp; policy,
                                                    InputIt first, Size count,
                                                    ForwardIt d_first );</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  </table> <div class="t-li1">
<span class="t-li">1)</span> Moves <code>count</code> elements from a range beginning at <code>first</code> to an uninitialized memory area beginning at <code>d_first</code> as if by <div class="cpp source-cpp"><pre data-language="cpp">for ( ; n &gt; 0; ++d_first, (void) ++first, --n)
   ::new (static_cast&lt;void*&gt;(std::addressof(*d_first)))
      typename std::iterator_traits&lt;ForwardIt&gt;::value_type(std::move(*first));</pre></div>
</div> <div class="t-li1">
 If an exception is thrown during the initialization, some objects in the source range are left in a valid but unspecified state, and the objects already constructed are destroyed in an unspecified order. </div> <div class="t-li1">
<span class="t-li">2)</span> Same as <span class="t-v">(1)</span>, but executed according to <code>policy</code>. This overload does not participate in overload resolution unless <code><a href="../algorithm/is_execution_policy"><span class="kw1560">std::<span class="me2">is_execution_policy_v</span></span></a><span class="sy1">&lt;</span><a href="../types/decay"><span class="kw625">std::<span class="me2">decay_t</span></span></a><span class="sy1">&lt;</span>ExecutionPolicy<span class="sy1">&gt;&gt;</span></code> is true</div> <h3 id="Parameters">Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> first </td> <td> - </td> <td> the beginning of the range of the elements to move </td>
</tr> <tr class="t-par"> <td> d_first </td> <td> - </td> <td> the beginning of the destination range </td>
</tr> <tr class="t-par"> <td> policy </td> <td> - </td> <td> the execution policy to use. See <a href="../algorithm/execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">execution policy</a> for details. </td>
</tr> <tr class="t-par-hitem"> <td colspan="3"> Type requirements </td>
</tr> <tr class="t-par-req"> <td colspan="3"> -<code>InputIt</code> must meet the requirements of <a href="../named_req/inputiterator" title="cpp/named req/InputIterator">LegacyInputIterator</a>. </td>
</tr> <tr class="t-par-req"> <td colspan="3"> -<code>ForwardIt</code> must meet the requirements of <a href="../named_req/forwarditerator" title="cpp/named req/ForwardIterator">LegacyForwardIterator</a>. </td>
</tr> <tr class="t-par-req"> <td colspan="3"> -No increment, assignment, comparison, or indirection through valid instances of <code>ForwardIt</code> may throw exceptions. </td>
</tr>
</table> <h3 id="Return_value">Return value</h3> <p>A pair whose first element is an iterator to the element past the last element moved in the source range, and whose second element is an iterator to the element past the last element moved in the destination range.</p>
<h3 id="Complexity">Complexity</h3> <p>Linear in <code>count</code>.</p>
<h3 id="Exceptions">Exceptions</h3> <p>The overload with a template parameter named <code>ExecutionPolicy</code> reports errors as follows:</p>
<ul>
<li> If execution of a function invoked as part of the algorithm throws an exception and <code>ExecutionPolicy</code> is one of the <a href="../algorithm/execution_policy_tag_t" title="cpp/algorithm/execution policy tag t">standard policies</a>, <code><a href="../error/terminate" title="cpp/error/terminate">std::terminate</a></code> is called. For any other <code>ExecutionPolicy</code>, the behavior is implementation-defined. </li>
<li> If the algorithm fails to allocate memory, <code><a href="new/bad_alloc" title="cpp/memory/new/bad alloc">std::bad_alloc</a></code> is thrown. </li>
</ul> <h3 id="Possible_implementation">Possible implementation</h3> <table class="eq-fun-cpp-table"> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class InputIt, class Size, class ForwardIt&gt;
std::pair&lt;InputIt, ForwardIt&gt; uninitialized_move_n(InputIt first, Size count, ForwardIt d_first)
{
    typedef typename std::iterator_traits&lt;ForwardIt&gt;::value_type Value;
    ForwardIt current = d_first;
    try {
        for (; count &gt; 0; ++first, (void) ++current, --count) {
            ::new (static_cast&lt;void*&gt;(std::addressof(*current))) Value(std::move(*first));
        }
    } catch (...) {
        for (; d_first != current; ++d_first) {
            d_first-&gt;~Value();
        }
        throw;
    }
    return {first, current};
}</pre></div> </td>
</tr>
</table> <h3 id="Example">Example</h3>  <h3 id="See_also">See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="uninitialized_move" title="cpp/memory/uninitialized move"> <span class="t-lines"><span>uninitialized_move</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div> </td> <td> moves a range of objects to an uninitialized area of memory <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="uninitialized_copy_n" title="cpp/memory/uninitialized copy n"> <span class="t-lines"><span>uninitialized_copy_n</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> copies a number of objects to an uninitialized area of memory <br> <span class="t-mark">(function template)</span> </td>
</tr> </table>          <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/memory/uninitialized_move_n" class="_attribution-link">http://en.cppreference.com/w/cpp/memory/uninitialized_move_n</a>
  </p>
</div>
