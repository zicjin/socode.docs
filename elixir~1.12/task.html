<h1> Task   </h1> <section id="moduledoc"> <p>Conveniences for spawning and awaiting tasks.</p>
<p>Tasks are processes meant to execute one particular action throughout their lifetime, often with little or no communication with other processes. The most common use case for tasks is to convert sequential code into concurrent code by computing a value asynchronously:</p>
<pre data-language="elixir">task = Task.async(fn -&gt; do_some_work() end)
res = do_some_other_work()
res + Task.await(task)</pre>
<p>Tasks spawned with <code class="inline">async</code> can be awaited on by their caller process (and only their caller) as shown in the example above. They are implemented by spawning a process that sends a message to the caller once the given computation is performed.</p>
<p>Besides <a href="#async/1"><code class="inline">async/1</code></a> and <a href="#await/2"><code class="inline">await/2</code></a>, tasks can also be started as part of a supervision tree and dynamically spawned on remote nodes. We will explore these scenarios next.</p>
<h2 id="module-async-and-await" class="section-heading">  async and await </h2> <p>One of the common uses of tasks is to convert sequential code into concurrent code with <a href="#async/1"><code class="inline">Task.async/1</code></a> while keeping its semantics. When invoked, a new process will be created, linked and monitored by the caller. Once the task action finishes, a message will be sent to the caller with the result.</p>
<p><a href="#await/2"><code class="inline">Task.await/2</code></a> is used to read the message sent by the task.</p>
<p>There are two important things to consider when using <code class="inline">async</code>:</p>
<ol>
<li><p>If you are using async tasks, you <strong>must await</strong> a reply as they are <em>always</em> sent. If you are not expecting a reply, consider using <a href="#start_link/1"><code class="inline">Task.start_link/1</code></a> detailed below.</p></li>
<li>
<p>async tasks link the caller and the spawned process. This means that, if the caller crashes, the task will crash too and vice-versa. This is on purpose: if the process meant to receive the result no longer exists, there is no purpose in completing the computation.</p>
<p>If this is not desired, you will want to use supervised tasks, described next.</p>
</li>
</ol>
<h2 id="module-dynamically-supervised-tasks" class="section-heading">  Dynamically supervised tasks </h2> <p>The <a href="task.supervisor"><code class="inline">Task.Supervisor</code></a> module allows developers to dynamically create multiple supervised tasks.</p>
<p>A short example is:</p>
<pre data-language="elixir">{:ok, pid} = Task.Supervisor.start_link()

task =
  Task.Supervisor.async(pid, fn -&gt;
    # Do something
  end)

Task.await(task)</pre>
<p>However, in the majority of cases, you want to add the task supervisor to your supervision tree:</p>
<pre data-language="elixir">Supervisor.start_link([
  {Task.Supervisor, name: MyApp.TaskSupervisor}
], strategy: :one_for_one)</pre>
<p>And now you can use async/await once again passig the name of the supervisor isntead of the pid:</p>
<pre data-language="elixir">Task.Supervisor.async(MyApp.TaskSupervisor, fn -&gt;
  # Do something
end)
|&gt; Task.await()</pre>
<p>We encourage developers to rely on supervised tasks as much as possible. Supervised tasks enable a huge variety of patterns which allows you explicit control on how to handle the results, errors, and timeouts. Here is a summary:</p>
<ul>
<li><p>Use <a href="task.supervisor#start_child/2"><code class="inline">Task.Supervisor.start_child/2</code></a> to start a fire-and-forget task and you don't care about its results nor about if it completes successfully</p></li>
<li><p>Use <a href="task.supervisor#async/2"><code class="inline">Task.Supervisor.async/2</code></a> + <a href="#await/2"><code class="inline">Task.await/2</code></a> allows you to execute tasks concurrently and retrieve its result. If the task fails, the caller will also fail</p></li>
<li><p>Use <a href="task.supervisor#async_nolink/2"><code class="inline">Task.Supervisor.async_nolink/2</code></a> + <a href="#yield/2"><code class="inline">Task.yield/2</code></a> + <a href="#shutdown/2"><code class="inline">Task.shutdown/2</code></a> allows you to execute tasks concurrently and retrieve their results or the reason they failed within a given time frame. If the task fails, the caller won't fail: you will receive the error reason either on <code class="inline">yield</code> or <code class="inline">shutdown</code></p></li>
</ul>
<p>See the <a href="task.supervisor"><code class="inline">Task.Supervisor</code></a> module for details on the supported operations.</p>
<h3 id="module-distributed-tasks" class="section-heading">  Distributed tasks </h3> <p>Since Elixir provides a <a href="task.supervisor"><code class="inline">Task.Supervisor</code></a>, it is easy to use one to dynamically start tasks across nodes:</p>
<pre data-language="elixir"># On the remote node
Task.Supervisor.start_link(name: MyApp.DistSupervisor)

# On the client
supervisor = {MyApp.DistSupervisor, :remote@local}
Task.Supervisor.async(supervisor, MyMod, :my_fun, [arg1, arg2, arg3])</pre>
<p>Note that, when working with distributed tasks, one should use the <a href="task.supervisor#async/4"><code class="inline">Task.Supervisor.async/4</code></a> function that expects explicit module, function, and arguments, instead of <a href="task.supervisor#async/2"><code class="inline">Task.Supervisor.async/2</code></a> that works with anonymous functions. That's because anonymous functions expect the same module version to exist on all involved nodes. Check the <a href="agent"><code class="inline">Agent</code></a> module documentation for more information on distributed processes as the limitations described there apply to the whole ecosystem.</p>
<h2 id="module-statically-supervised-tasks" class="section-heading">  Statically supervised tasks </h2> <p>The <a href="task#content"><code class="inline">Task</code></a> module implements the <a href="#child_spec/1"><code class="inline">child_spec/1</code></a> function, which allows it to be started directly under a regular <a href="supervisor"><code class="inline">Supervisor</code></a> - instead of a <a href="task.supervisor"><code class="inline">Task.Supervisor</code></a> - by passing a tuple with a function to run:</p>
<pre data-language="elixir">Supervisor.start_link([
  {Task, fn -&gt; :some_work end}
], strategy: :one_for_one)</pre>
<p>This is often useful when you need to execute some steps while setting up your supervision tree. For example: to warm up caches, log the initialization status, etc.</p>
<p>If you don't want to put the Task code directly under the <a href="supervisor"><code class="inline">Supervisor</code></a>, you can wrap the <a href="task#content"><code class="inline">Task</code></a> in its own module, similar to how you would do with a <a href="genserver"><code class="inline">GenServer</code></a> or an <a href="agent"><code class="inline">Agent</code></a>:</p>
<pre data-language="elixir">defmodule MyTask do
  use Task

  def start_link(arg) do
    Task.start_link(__MODULE__, :run, [arg])
  end

  def run(arg) do
    # ...
  end
end</pre>
<p>And then passing it to the supervisor:</p>
<pre data-language="elixir">Supervisor.start_link([
  {MyTask, arg}
], strategy: :one_for_one)</pre>
<p>Since these tasks are supervised and not directly linked to the caller, they cannot be awaited on. By default, the functions <code class="inline">Task.start</code> and <code class="inline">Task.start_link</code> are for fire-and-forget tasks, where you don't care about the results or if it completes successfully or not.</p>
<p><code class="inline">use Task</code> defines a <a href="#child_spec/1"><code class="inline">child_spec/1</code></a> function, allowing the defined module to be put under a supervision tree. The generated <a href="#child_spec/1"><code class="inline">child_spec/1</code></a> can be customized with the following options:</p>
<ul>
<li>
<code class="inline">:id</code> - the child specification identifier, defaults to the current module</li>
<li>
<code class="inline">:restart</code> - when the child should be restarted, defaults to <code class="inline">:temporary</code>
</li>
<li>
<code class="inline">:shutdown</code> - how to shut down the child, either immediately or by giving it time to shut down</li>
</ul>
<p>Opposite to <a href="genserver"><code class="inline">GenServer</code></a>, <a href="agent"><code class="inline">Agent</code></a> and <a href="supervisor"><code class="inline">Supervisor</code></a>, a Task has a default <code class="inline">:restart</code> of <code class="inline">:temporary</code>. This means the task will not be restarted even if it crashes. If you desire the task to be restarted for non-successful exits, do:</p>
<pre data-language="elixir">use Task, restart: :transient</pre>
<p>If you want the task to always be restarted:</p>
<pre data-language="elixir">use Task, restart: :permanent</pre>
<p>See the "Child specification" section in the <a href="supervisor"><code class="inline">Supervisor</code></a> module for more detailed information. The <code class="inline">@doc</code> annotation immediately preceding <code class="inline">use Task</code> will be attached to the generated <a href="#child_spec/1"><code class="inline">child_spec/1</code></a> function.</p>
<h2 id="module-ancestor-and-caller-tracking" class="section-heading">  Ancestor and Caller Tracking </h2> <p>Whenever you start a new process, Elixir annotates the parent of that process through the <code class="inline">$ancestors</code> key in the process dictionary. This is often used to track the hierarchy inside a supervision tree.</p>
<p>For example, we recommend developers to always start tasks under a supervisor. This provides more visibility and allows you to control how those tasks are terminated when a node shuts down. That might look something like <code class="inline">Task.Supervisor.start_child(MySupervisor, task_specification)</code>. This means that, although your code is the one who invokes the task, the actual ancestor of the task is the supervisor, as the supervisor is the one effectively starting it.</p>
<p>To track the relationship between your code and the task, we use the <code class="inline">$callers</code> key in the process dictionary. Therefore, assuming the <a href="task.supervisor"><code class="inline">Task.Supervisor</code></a> call above, we have:</p>
<pre data-language="elixir">[your code] -- calls --&gt; [supervisor] ---- spawns --&gt; [task]</pre>
<p>Which means we store the following relationships:</p>
<pre data-language="elixir">[your code]              [supervisor] &lt;-- ancestor -- [task]
    ^                                                  |
    |--------------------- caller ---------------------|</pre>
<p>The list of callers of the current process can be retrieved from the Process dictionary with <code class="inline">Process.get(:"$callers")</code>. This will return either <code class="inline">nil</code> or a list <code class="inline">[pid_n, ..., pid2, pid1]</code> with at least one entry Where <code class="inline">pid_n</code> is the PID that called the current process, <code class="inline">pid2</code> called <code class="inline">pid_n</code>, and <code class="inline">pid2</code> was called by <code class="inline">pid1</code>.</p>
<p>If a task crashes, the callers field is included as part of the log message metadata under the <code class="inline">:callers</code> key.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt> <dd class="summary-synopsis"><p>The Task type.</p></dd> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#__struct__/0">%Task{}</a> </dt> <dd class="summary-synopsis"><p>The Task struct.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#async/1">async(fun)</a> </dt> <dd class="summary-synopsis"><p>Starts a task that must be awaited on.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#async/3">async(module, function_name, args)</a> </dt> <dd class="summary-synopsis"><p>Starts a task that must be awaited on.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#async_stream/3">async_stream(enumerable, fun, options \\ [])</a> </dt> <dd class="summary-synopsis"><p>Returns a stream that runs the given function <code class="inline">fun</code> concurrently on each element in <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#async_stream/5">async_stream(enumerable, module, function_name, args, options \\ [])</a> </dt> <dd class="summary-synopsis"><p>Returns a stream where the given function (<code class="inline">module</code> and <code class="inline">function_name</code>) is mapped concurrently on each element in <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#await/2">await(task, timeout \\ 5000)</a> </dt> <dd class="summary-synopsis"><p>Awaits a task reply and returns it.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#await_many/2">await_many(tasks, timeout \\ 5000)</a> </dt> <dd class="summary-synopsis"><p>Awaits replies from multiple tasks and returns them.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#child_spec/1">child_spec(arg)</a> </dt> <dd class="summary-synopsis"><p>Returns a specification to start a task under a supervisor.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#shutdown/2">shutdown(task, shutdown \\ 5000)</a> </dt> <dd class="summary-synopsis"><p>Unlinks and shuts down the task, and then checks for a reply.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#start/1">start(fun)</a> </dt> <dd class="summary-synopsis"><p>Starts a task.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#start/3">start(module, function_name, args)</a> </dt> <dd class="summary-synopsis"><p>Starts a task.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#start_link/1">start_link(fun)</a> </dt> <dd class="summary-synopsis"><p>Starts a task as part of a supervision tree with the given <code class="inline">fun</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#start_link/3">start_link(module, function, args)</a> </dt> <dd class="summary-synopsis"><p>Starts a task as part of a supervision tree with the given <code class="inline">module</code>, <code class="inline">function</code>, and <code class="inline">args</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#yield/2">yield(task, timeout \\ 5000)</a> </dt> <dd class="summary-synopsis"><p>Temporarily blocks the current process waiting for a task reply.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#yield_many/2">yield_many(tasks, timeout \\ 5000)</a> </dt> <dd class="summary-synopsis"><p>Yields to multiple tasks in the given time interval.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/task.ex#L243" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">t() :: %Task{owner: pid() | nil, pid: pid() | nil, ref: reference() | nil}</pre> </div> <p>The Task type.</p>
<p>See <code class="inline">%Task{}</code> for information about each field of the structure.</p> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="__struct__/0">%Task{}<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/task.ex#L236" class="source">Source</a>
</h3> <section class="docstring"> <p>The Task struct.</p>
<p>It contains these fields:</p>
<ul>
<li><p><code class="inline">:pid</code> - the PID of the task process; <code class="inline">nil</code> if the task does not use a task process</p></li>
<li><p><code class="inline">:ref</code> - the task monitor reference</p></li>
<li><p><code class="inline">:owner</code> - the PID of the process that started the task</p></li>
</ul> </section> </section> <section class="detail"> <h3 class="detail-header" id="async/1">async(fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/task.ex#L424" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">async((() -&gt; any())) :: t()</pre> </div> <p>Starts a task that must be awaited on.</p>
<p><code class="inline">fun</code> must be a zero-arity anonymous function. This function spawns a process that is linked to and monitored by the caller process. A <a href="task#content"><code class="inline">Task</code></a> struct is returned containing the relevant information. Developers must eventually call <a href="#await/2"><code class="inline">Task.await/2</code></a> or <a href="#yield/2"><code class="inline">Task.yield/2</code></a> followed by <a href="#shutdown/2"><code class="inline">Task.shutdown/2</code></a> on the returned task.</p>
<p>Read the <a href="task#content"><code class="inline">Task</code></a> module documentation for more information about the general usage of async tasks.</p>
<h4 id="async/1-linking" class="section-heading">  Linking </h4> <p>This function spawns a process that is linked to and monitored by the caller process. The linking part is important because it aborts the task if the parent process dies. It also guarantees the code before async/await has the same properties after you add the async call. For example, imagine you have this:</p>
<pre data-language="elixir">x = heavy_fun()
y = some_fun()
x + y</pre>
<p>Now you want to make the <code class="inline">heavy_fun()</code> async:</p>
<pre data-language="elixir">x = Task.async(&amp;heavy_fun/0)
y = some_fun()
Task.await(x) + y</pre>
<p>As before, if <code class="inline">heavy_fun/0</code> fails, the whole computation will fail, including the parent process. If you don't want the task to fail then you must change the <code class="inline">heavy_fun/0</code> code in the same way you would achieve it if you didn't have the async call. For example, to either return <code class="inline">{:ok, val} | :error</code> results or, in more extreme cases, by using <code class="inline">try/rescue</code>. In other words, an asynchronous task should be thought of as an extension of a process rather than a mechanism to isolate it from all errors.</p>
<p>If you don't want to link the caller to the task, then you must use a supervised task with <a href="task.supervisor"><code class="inline">Task.Supervisor</code></a> and call <a href="task.supervisor#async_nolink/2"><code class="inline">Task.Supervisor.async_nolink/2</code></a>.</p>
<p>In any case, avoid any of the following:</p>
<ul>
<li>
<p>Setting <code class="inline">:trap_exit</code> to <code class="inline">true</code> - trapping exits should be used only in special circumstances as it would make your process immune to not only exits from the task but from any other processes.</p>
<p>Moreover, even when trapping exits, calling <code class="inline">await</code> will still exit if the task has terminated without sending its result back.</p>
</li>
<li><p>Unlinking the task process started with <code class="inline">async</code>/<code class="inline">await</code>. If you unlink the processes and the task does not belong to any supervisor, you may leave dangling tasks in case the parent dies.</p></li>
</ul> </section> </section> <section class="detail"> <h3 class="detail-header" id="async/3">async(module, function_name, args)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/task.ex#L435" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">async(module(), atom(), [term()]) :: t()</pre> </div> <p>Starts a task that must be awaited on.</p>
<p>Similar to <a href="#async/1"><code class="inline">async/1</code></a> except the function to be started is specified by the given <code class="inline">module</code>, <code class="inline">function_name</code>, and <code class="inline">args</code>.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="async_stream/3">async_stream(enumerable, fun, options \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/task.ex#L575" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">async_stream(Enumerable.t(), (term() -&gt; term()), keyword()) :: Enumerable.t()</pre> </div> <p>Returns a stream that runs the given function <code class="inline">fun</code> concurrently on each element in <code class="inline">enumerable</code>.</p>
<p>Works the same as <a href="#async_stream/5"><code class="inline">async_stream/5</code></a> but with an anonymous function instead of a module-function-arguments tuple. <code class="inline">fun</code> must be a one-arity anonymous function.</p>
<p>Each <code class="inline">enumerable</code> element is passed as argument to the given function <code class="inline">fun</code> and processed by its own task. The tasks will be linked to the current process, similarly to <a href="#async/1"><code class="inline">async/1</code></a>.</p>
<h4 id="async_stream/3-example" class="section-heading">  Example </h4> <p>Count the code points in each string asynchronously, then add the counts together using reduce.</p>
<pre data-language="elixir">iex&gt; strings = ["long string", "longer string", "there are many of these"]
iex&gt; stream = Task.async_stream(strings, fn text -&gt; text |&gt; String.codepoints() |&gt; Enum.count() end)
iex&gt; Enum.reduce(stream, 0, fn {:ok, num}, acc -&gt; num + acc end)
47</pre>
<p>See <a href="#async_stream/5"><code class="inline">async_stream/5</code></a> for discussion, options, and more examples.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="async_stream/5">async_stream(enumerable, module, function_name, args, options \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/task.ex#L546" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">async_stream(Enumerable.t(), module(), atom(), [term()], keyword()) ::
  Enumerable.t()</pre> </div> <p>Returns a stream where the given function (<code class="inline">module</code> and <code class="inline">function_name</code>) is mapped concurrently on each element in <code class="inline">enumerable</code>.</p>
<p>Each element of <code class="inline">enumerable</code> will be prepended to the given <code class="inline">args</code> and processed by its own task. The tasks will be linked to an intermediate process that is then linked to the current process. This means a failure in a task terminates the current process and a failure in the current process terminates all tasks.</p>
<p>When streamed, each task will emit <code class="inline">{:ok, value}</code> upon successful completion or <code class="inline">{:exit, reason}</code> if the caller is trapping exits. The order of results depends on the value of the <code class="inline">:ordered</code> option.</p>
<p>The level of concurrency and the time tasks are allowed to run can be controlled via options (see the "Options" section below).</p>
<p>Consider using <a href="task.supervisor#async_stream/6"><code class="inline">Task.Supervisor.async_stream/6</code></a> to start tasks under a supervisor. If you find yourself trapping exits to handle exits inside the async stream, consider using <a href="task.supervisor#async_stream_nolink/6"><code class="inline">Task.Supervisor.async_stream_nolink/6</code></a> to start tasks that are not linked to the calling process.</p>
<h4 id="async_stream/5-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:max_concurrency</code> - sets the maximum number of tasks to run at the same time. Defaults to <a href="system#schedulers_online/0"><code class="inline">System.schedulers_online/0</code></a>.</p></li>
<li><p><code class="inline">:ordered</code> - whether the results should be returned in the same order as the input stream. When the output is ordered, Elixir may need to buffer results to emit them in the original order. Setting this option to false disables the need to buffer at the cost of removing ordering. This is also useful when you're using the tasks only for the side effects. Note that regardless of what <code class="inline">:ordered</code> is set to, the tasks will process asynchronously. If you need to process elements in order, consider using <a href="enum#map/2"><code class="inline">Enum.map/2</code></a> or <a href="enum#each/2"><code class="inline">Enum.each/2</code></a> instead. Defaults to <code class="inline">true</code>.</p></li>
<li><p><code class="inline">:timeout</code> - the maximum amount of time (in milliseconds or <code class="inline">:infinity</code>) each task is allowed to execute for. Defaults to <code class="inline">5000</code>.</p></li>
<li>
<p><code class="inline">:on_timeout</code> - what to do when a task times out. The possible values are:</p>
<ul>
<li>
<code class="inline">:exit</code> (default) - the process that spawned the tasks exits.</li>
<li>
<code class="inline">:kill_task</code> - the task that timed out is killed. The value emitted for that task is <code class="inline">{:exit, :timeout}</code>.</li>
</ul>
</li>
</ul>
<h4 id="async_stream/5-example" class="section-heading">  Example </h4> <p>Let's build a stream and then enumerate it:</p>
<pre data-language="elixir">stream = Task.async_stream(collection, Mod, :expensive_fun, [])
Enum.to_list(stream)</pre>
<p>The concurrency can be increased or decreased using the <code class="inline">:max_concurrency</code> option. For example, if the tasks are IO heavy, the value can be increased:</p>
<pre data-language="elixir">max_concurrency = System.schedulers_online() * 2
stream = Task.async_stream(collection, Mod, :expensive_fun, [], max_concurrency: max_concurrency)
Enum.to_list(stream)</pre>
<p>If you do not care about the results of the computation, you can run the stream with <a href="stream#run/1"><code class="inline">Stream.run/1</code></a>. Also set <code class="inline">ordered: false</code>, as you don't care about the order of the results either:</p>
<pre data-language="elixir">stream = Task.async_stream(collection, Mod, :expensive_fun, [], ordered: false)
Stream.run(stream)</pre>
<h4 id="async_stream/5-attention-async-take" class="section-heading">  Attention: async + take </h4> <p>Given items in an async stream are processed concurrently, doing <code class="inline">async_stream</code> followed by <a href="enum#take/2"><code class="inline">Enum.take/2</code></a> may cause more items than requested to be processed. Let's see an example:</p>
<pre data-language="elixir">1..100
|&gt; Task.async_stream(fn i -&gt;
  Process.sleep(100)
  IO.puts(to_string(i))
end)
|&gt; Enum.take(10)</pre>
<p>For a machine with 8 cores, the above will process 16 items instead of 10. The reason is that <a href="#async_stream/5"><code class="inline">async_stream/5</code></a> always have 8 elements processing at once. So by the time <a href="enum"><code class="inline">Enum</code></a> says it got all elements it needed, there are still 6 elements left to be processed.</p>
<p>The solution here is to use <a href="stream#take/2"><code class="inline">Stream.take/2</code></a> instead of <a href="enum#take/2"><code class="inline">Enum.take/2</code></a> to filter elements before-hand:</p>
<pre data-language="elixir">1..100
|&gt; Stream.take(10)
|&gt; Task.async_stream(fn i -&gt;
  Process.sleep(100)
  IO.puts(to_string(i))
end)
|&gt; Enum.to_list()</pre>
<p>If for some reason you cannot take the elements before hand, you can use <code class="inline">:max_concurrency</code> to limit how many elements may be over processed at the cost of reducing concurrency.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="await/2">await(task, timeout \\ 5000)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/task.ex#L711" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">await(t(), timeout()) :: term()</pre> </div> <p>Awaits a task reply and returns it.</p>
<p>In case the task process dies, the current process will exit with the same reason as the task.</p>
<p>A timeout, in milliseconds or <code class="inline">:infinity</code>, can be given with a default value of <code class="inline">5000</code>. If the timeout is exceeded, then the current process will exit. If the task process is linked to the current process which is the case when a task is started with <code class="inline">async</code>, then the task process will also exit. If the task process is trapping exits or not linked to the current process, then it will continue to run.</p>
<p>This function assumes the task's monitor is still active or the monitor's <code class="inline">:DOWN</code> message is in the message queue. If it has been demonitored, or the message already received, this function will wait for the duration of the timeout awaiting the message.</p>
<p>This function can only be called once for any given task. If you want to be able to check multiple times if a long-running task has finished its computation, use <a href="#yield/2"><code class="inline">yield/2</code></a> instead.</p>
<h4 id="await/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; task = Task.async(fn -&gt; 1 + 1 end)
iex&gt; Task.await(task)
2</pre>
<h4 id="await/2-compatibility-with-otp-behaviours" class="section-heading">  Compatibility with OTP behaviours </h4> <p>It is not recommended to <code class="inline">await</code> a long-running task inside an OTP behaviour such as <a href="genserver"><code class="inline">GenServer</code></a>. Instead, you should match on the message coming from a task inside your <a href="genserver#c:handle_info/2"><code class="inline">GenServer.handle_info/2</code></a> callback.</p>
<p>A GenServer will receive two messages on <code class="inline">handle_info/2</code>:</p>
<ul>
<li><p><code class="inline">{ref, result}</code> - the reply message where <code class="inline">ref</code> is the monitor reference returned by the <code class="inline">task.ref</code> and <code class="inline">result</code> is the task result</p></li>
<li><p><code class="inline">{:DOWN, ref, :process, pid, reason}</code> - since all tasks are also monitored, you will also receive the <code class="inline">:DOWN</code> message delivered by <a href="process#monitor/1"><code class="inline">Process.monitor/1</code></a>. If you receive the <code class="inline">:DOWN</code> message without a a reply, it means the task crashed</p></li>
</ul>
<p>Another consideration to have in mind is that tasks started by <a href="#async/1"><code class="inline">Task.async/1</code></a> are always linked to their callers and you may not want the GenServer to crash if the task crashes. Therefore, it is preferable to instead use <a href="task.supervisor#async_nolink/3"><code class="inline">Task.Supervisor.async_nolink/3</code></a> inside OTP behaviours. For completeness, here is an example of a GenServer that start tasks and handles their results:</p>
<pre data-language="elixir">defmodule GenServerTaskExample do
  use GenServer

  def start_link(opts) do
    GenServer.start_link(__MODULE__, :ok, opts)
  end

  def init(_opts) do
    # We will keep all running tasks in a map
    {:ok, %{tasks: %{}}}
  end

  # Imagine we invoke a task from the GenServer to access a URL...
  def handle_call(:some_message, _from, state) do
    url = ...
    task = Task.Supervisor.async_nolink(MyApp.TaskSupervisor, fn -&gt; fetch_url(url) end)

    # After we start the task, we store its reference and the url it is fetching
    state = put_in(state.tasks[task.ref], url)

    {:reply, :ok, state}
  end

  # If the task succeeds...
  def handle_info({ref, result}, state) do
    # The task succeed so we can cancel the monitoring and discard the DOWN message
    Process.demonitor(ref, [:flush])

    {url, state} = pop_in(state.tasks[ref])
    IO.puts "Got #{inspect(result)} for URL #{inspect url}"
    {:noreply, state}
  end

  # If the task fails...
  def handle_info({:DOWN, ref, _, _, reason}, state) do
    {url, state} = pop_in(state.tasks[ref])
    IO.puts "URL #{inspect url} failed with reason #{inspect(reason)}"
    {:noreply, state}
  end
end</pre>
<p>With the server defined, you will want to start the task supervisor above and the GenServer in your supervision tree:</p>
<pre data-language="elixir">children = [
  {Task.Supervisor, name: MyApp.TaskSupervisor},
  {GenServerTaskExample, name: MyApp.GenServerTaskExample}
]

Supervisor.start_link(children, strategy: :one_for_one)</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="await_many/2">await_many(tasks, timeout \\ 5000)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/task.ex#L772" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">await_many([t()], timeout()) :: [term()]</pre> </div> <p>Awaits replies from multiple tasks and returns them.</p>
<p>This function receives a list of tasks and waits for their replies in the given time interval. It returns a list of the results, in the same order as the tasks supplied in the <code class="inline">tasks</code> input argument.</p>
<p>If any of the task processes dies, the current process will exit with the same reason as that task.</p>
<p>A timeout, in milliseconds or <code class="inline">:infinity</code>, can be given with a default value of <code class="inline">5000</code>. If the timeout is exceeded, then the current process will exit. Any task processes that are linked to the current process (which is the case when a task is started with <code class="inline">async</code>) will also exit. Any task processes that are trapping exits or not linked to the current process will continue to run.</p>
<p>This function assumes the tasks' monitors are still active or the monitors' <code class="inline">:DOWN</code> message is in the message queue. If any tasks have been demonitored, or the message already received, this function will wait for the duration of the timeout.</p>
<p>This function can only be called once for any given task. If you want to be able to check multiple times if a long-running task has finished its computation, use <a href="#yield_many/2"><code class="inline">yield_many/2</code></a> instead.</p>
<h4 id="await_many/2-compatibility-with-otp-behaviours" class="section-heading">  Compatibility with OTP behaviours </h4> <p>It is not recommended to <code class="inline">await</code> long-running tasks inside an OTP behaviour such as <a href="genserver"><code class="inline">GenServer</code></a>. See <a href="#await/2"><code class="inline">await/2</code></a> for more information.</p>
<h4 id="await_many/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; tasks = [
...&gt;   Task.async(fn -&gt; 1 + 1 end),
...&gt;   Task.async(fn -&gt; 2 + 3 end)
...&gt; ]
iex&gt; Task.await_many(tasks)
[2, 5]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="child_spec/1">child_spec(arg)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/task.ex#L263" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">child_spec(term()) :: Supervisor.child_spec()</pre> </div> <p>Returns a specification to start a task under a supervisor.</p>
<p><code class="inline">arg</code> is passed as the argument to <a href="#start_link/1"><code class="inline">Task.start_link/1</code></a> in the <code class="inline">:start</code> field of the spec.</p>
<p>For more information, see the <a href="supervisor"><code class="inline">Supervisor</code></a> module, the <a href="supervisor#child_spec/2"><code class="inline">Supervisor.child_spec/2</code></a> function and the <a href="supervisor#t:child_spec/0"><code class="inline">Supervisor.child_spec/0</code></a> type.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="shutdown/2">shutdown(task, shutdown \\ 5000)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/task.ex#L1051" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">shutdown(t(), timeout() | :brutal_kill) :: {:ok, term()} | {:exit, term()} | nil</pre> </div> <p>Unlinks and shuts down the task, and then checks for a reply.</p>
<p>Returns <code class="inline">{:ok, reply}</code> if the reply is received while shutting down the task, <code class="inline">{:exit, reason}</code> if the task died, otherwise <code class="inline">nil</code>.</p>
<p>The second argument is either a timeout or <code class="inline">:brutal_kill</code>. In case of a timeout, a <code class="inline">:shutdown</code> exit signal is sent to the task process and if it does not exit within the timeout, it is killed. With <code class="inline">:brutal_kill</code> the task is killed straight away. In case the task terminates abnormally (possibly killed by another process), this function will exit with the same reason.</p>
<p>It is not required to call this function when terminating the caller, unless exiting with reason <code class="inline">:normal</code> or if the task is trapping exits. If the caller is exiting with a reason other than <code class="inline">:normal</code> and the task is not trapping exits, the caller's exit signal will stop the task. The caller can exit with reason <code class="inline">:shutdown</code> to shut down all of its linked processes, including tasks, that are not trapping exits without generating any log messages.</p>
<p>If a task's monitor has already been demonitored or received and there is not a response waiting in the message queue this function will return <code class="inline">{:exit, :noproc}</code> as the result or exit reason can not be determined.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="start/1">start(fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/task.ex#L340" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">start((() -&gt; any())) :: {:ok, pid()}</pre> </div> <p>Starts a task.</p>
<p><code class="inline">fun</code> must be a zero-arity anonymous function.</p>
<p>This should only used when the task is used for side-effects (like I/O) and you have no interest on its results nor if it completes successfully.</p>
<p>If the current node is shutdown, the node will terminate even if the task was not completed. For this reason, we recommend to use <a href="task.supervisor#start_child/2"><code class="inline">Task.Supervisor.start_child/2</code></a> instead, which allows you to control the shutdown time via the <code class="inline">:shutdown</code> option.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="start/3">start(module, function_name, args)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/task.ex#L357" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">start(module(), atom(), [term()]) :: {:ok, pid()}</pre> </div> <p>Starts a task.</p>
<p>This should only used when the task is used for side-effects (like I/O) and you have no interest on its results nor if it completes successfully.</p>
<p>If the current node is shutdown, the node will terminate even if the task was not completed. For this reason, we recommend to use <a href="task.supervisor#start_child/2"><code class="inline">Task.Supervisor.start_child/2</code></a> instead, which allows you to control the shutdown time via the <code class="inline">:shutdown</code> option.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="start_link/1">start_link(fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/task.ex#L308" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">start_link((() -&gt; any())) :: {:ok, pid()}</pre> </div> <p>Starts a task as part of a supervision tree with the given <code class="inline">fun</code>.</p>
<p><code class="inline">fun</code> must be a zero-arity anonymous function.</p>
<p>This is used to start a statically supervised task under a supervision tree.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="start_link/3">start_link(module, function, args)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/task.ex#L319" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">start_link(module(), atom(), [term()]) :: {:ok, pid()}</pre> </div> <p>Starts a task as part of a supervision tree with the given <code class="inline">module</code>, <code class="inline">function</code>, and <code class="inline">args</code>.</p>
<p>This is used to start a statically supervised task under a supervision tree.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="yield/2">yield(task, timeout \\ 5000)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/task.ex#L898" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">yield(t(), timeout()) :: {:ok, term()} | {:exit, term()} | nil</pre> </div> <p>Temporarily blocks the current process waiting for a task reply.</p>
<p>Returns <code class="inline">{:ok, reply}</code> if the reply is received, <code class="inline">nil</code> if no reply has arrived, or <code class="inline">{:exit, reason}</code> if the task has already exited. Keep in mind that normally a task failure also causes the process owning the task to exit. Therefore this function can return <code class="inline">{:exit, reason}</code> only if</p>
<ul>
<li>the task process exited with the reason <code class="inline">:normal</code>
</li>
<li>it isn't linked to the caller</li>
<li>the caller is trapping exits</li>
</ul>
<p>A timeout, in milliseconds or <code class="inline">:infinity</code>, can be given with a default value of <code class="inline">5000</code>. If the time runs out before a message from the task is received, this function will return <code class="inline">nil</code> and the monitor will remain active. Therefore <a href="#yield/2"><code class="inline">yield/2</code></a> can be called multiple times on the same task.</p>
<p>This function assumes the task's monitor is still active or the monitor's <code class="inline">:DOWN</code> message is in the message queue. If it has been demonitored or the message already received, this function will wait for the duration of the timeout awaiting the message.</p>
<p>If you intend to shut the task down if it has not responded within <code class="inline">timeout</code> milliseconds, you should chain this together with <a href="#shutdown/1"><code class="inline">shutdown/1</code></a>, like so:</p>
<pre data-language="elixir">case Task.yield(task, timeout) || Task.shutdown(task) do
  {:ok, result} -&gt;
    result

  nil -&gt;
    Logger.warn("Failed to get a result in #{timeout}ms")
    nil
end</pre>
<p>That ensures that if the task completes after the <code class="inline">timeout</code> but before <a href="#shutdown/1"><code class="inline">shutdown/1</code></a> has been called, you will still get the result, since <a href="#shutdown/1"><code class="inline">shutdown/1</code></a> is designed to handle this case and return the result.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="yield_many/2">yield_many(tasks, timeout \\ 5000)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/task.ex#L980" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">yield_many([t()], timeout()) :: [{t(), {:ok, term()} | {:exit, term()} | nil}]</pre> </div> <p>Yields to multiple tasks in the given time interval.</p>
<p>This function receives a list of tasks and waits for their replies in the given time interval. It returns a list of two-element tuples, with the task as the first element and the yielded result as the second. The tasks in the returned list will be in the same order as the tasks supplied in the <code class="inline">tasks</code> input argument.</p>
<p>Similarly to <a href="#yield/2"><code class="inline">yield/2</code></a>, each task's result will be</p>
<ul>
<li>
<code class="inline">{:ok, term}</code> if the task has successfully reported its result back in the given time interval</li>
<li>
<code class="inline">{:exit, reason}</code> if the task has died</li>
<li>
<code class="inline">nil</code> if the task keeps running past the timeout</li>
</ul>
<p>A timeout, in milliseconds or <code class="inline">:infinity</code>, can be given with a default value of <code class="inline">5000</code>.</p>
<p>Check <a href="#yield/2"><code class="inline">yield/2</code></a> for more information.</p>
<h4 id="yield_many/2-example" class="section-heading">  Example </h4> <p><a href="#yield_many/2"><code class="inline">Task.yield_many/2</code></a> allows developers to spawn multiple tasks and retrieve the results received in a given timeframe. If we combine it with <a href="#shutdown/2"><code class="inline">Task.shutdown/2</code></a>, it allows us to gather those results and cancel the tasks that have not replied in time.</p>
<p>Let's see an example.</p>
<pre data-language="elixir">tasks =
  for i &lt;- 1..10 do
    Task.async(fn -&gt;
      Process.sleep(i * 1000)
      i
    end)
  end

tasks_with_results = Task.yield_many(tasks, 5000)

results =
  Enum.map(tasks_with_results, fn {task, res} -&gt;
    # Shut down the tasks that did not reply nor exit
    res || Task.shutdown(task, :brutal_kill)
  end)

# Here we are matching only on {:ok, value} and
# ignoring {:exit, _} (crashed tasks) and `nil` (no replies)
for {:ok, value} &lt;- results do
  IO.inspect(value)
end</pre>
<p>In the example above, we create tasks that sleep from 1 up to 10 seconds and return the number of seconds they slept for. If you execute the code all at once, you should see 1 up to 5 printed, as those were the tasks that have replied in the given time. All other tasks will have been shut down using the <a href="#shutdown/2"><code class="inline">Task.shutdown/2</code></a> call.</p> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/elixir/1.12.0/Task.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.12.0/Task.html</a>
  </p>
</div>
