<h1> Mix.Project   </h1> <section id="moduledoc"> <p>Defines and manipulates Mix projects.</p>
<p>A Mix project is defined by calling <code class="inline">use Mix.Project</code> in a module, usually placed in <code class="inline">mix.exs</code>:</p>
<pre data-language="elixir">defmodule MyApp.MixProject do
  use Mix.Project

  def project do
    [
      app: :my_app,
      version: "1.0.0"
    ]
  end
end</pre>
<h2 id="module-configuration" class="section-heading">  Configuration </h2> <p>In order to configure Mix, the module that <code class="inline">use</code>s <a href="mix.project#content"><code class="inline">Mix.Project</code></a> should export a <code class="inline">project/0</code> function that returns a keyword list representing configuration for the project.</p>
<p>This configuration can be read using <a href="#config/0"><code class="inline">Mix.Project.config/0</code></a>. Note that <a href="#config/0"><code class="inline">config/0</code></a> won't fail if a project is not defined; this allows many Mix tasks to work without a project.</p>
<p>If a task requires a project to be defined or needs to access a special function within the project, the task can call <a href="#get!/0"><code class="inline">Mix.Project.get!/0</code></a> which fails with <a href="mix.noprojecterror"><code class="inline">Mix.NoProjectError</code></a> in the case a project is not defined.</p>
<p>There isn't a comprehensive list of all the options that can be returned by <code class="inline">project/0</code> since many Mix tasks define their own options that they read from this configuration. For example, look at the "Configuration" section in the documentation for the <a href="mix.tasks.compile"><code class="inline">Mix.Tasks.Compile</code></a> task.</p>
<p>These are a few options that are not used by just one Mix task (and will thus be documented here):</p>
<ul>
<li><p><code class="inline">:build_per_environment</code> - if <code class="inline">true</code>, builds will be <em>per-environment</em>. If <code class="inline">false</code>, builds will go in <code class="inline">_build/shared</code> regardless of the Mix environment. Defaults to <code class="inline">true</code>.</p></li>
<li><p><code class="inline">:aliases</code> - a list of task aliases. For more information, check out the "Aliases" section in the documentation for the <a href="mix"><code class="inline">Mix</code></a> module. Defaults to <code class="inline">[]</code>.</p></li>
<li><p><code class="inline">:config_path</code> - a string representing the path of the main config file. See <a href="#config_files/0"><code class="inline">config_files/0</code></a> for more information. Defaults to <code class="inline">"config/config.exs"</code>.</p></li>
<li><p><code class="inline">:default_task</code> - a string representing the default task to be run by <code class="inline">mix</code> when no task is specified. Defaults to <code class="inline">"run"</code>.</p></li>
<li><p><code class="inline">:deps</code> - a list of dependencies of this project. Refer to the documentation for the <a href="mix.tasks.deps"><code class="inline">Mix.Tasks.Deps</code></a> task for more information. Defaults to <code class="inline">[]</code>.</p></li>
<li><p><code class="inline">:deps_path</code> - directory where dependencies are stored. Also see <a href="#deps_path/1"><code class="inline">deps_path/1</code></a>. Defaults to <code class="inline">"deps"</code>.</p></li>
<li><p><code class="inline">:lockfile</code> - the name of the lockfile used by the <code class="inline">mix deps.*</code> family of tasks. Defaults to <code class="inline">"mix.lock"</code>.</p></li>
<li><p><code class="inline">:preferred_cli_env</code> - a keyword list of <code class="inline">{task, env}</code> tuples where <code class="inline">task</code> is the task name as an atom (for example, <code class="inline">:"deps.get"</code>) and <code class="inline">env</code> is the preferred environment (for example, <code class="inline">:test</code>). This option overrides what is specified by the tasks with the <code class="inline">@preferred_cli_env</code> attribute (see the docs for <a href="mix.task"><code class="inline">Mix.Task</code></a>). Defaults to <code class="inline">[]</code>.</p></li>
<li><p><code class="inline">:preferred_cli_target</code> - a keyword list of <code class="inline">{task, target}</code> tuples where <code class="inline">task</code> is the task name as an atom (for example, <code class="inline">:test</code>) and <code class="inline">target</code> is the preferred target (for example, <code class="inline">:host</code>). Defaults to <code class="inline">[]</code>.</p></li>
</ul>
<p>For more options, keep an eye on the documentation for single Mix tasks; good examples are the <a href="mix.tasks.compile"><code class="inline">Mix.Tasks.Compile</code></a> task and all the specific compiler tasks (such as <a href="mix.tasks.compile.elixir"><code class="inline">Mix.Tasks.Compile.Elixir</code></a> or <a href="mix.tasks.compile.erlang"><code class="inline">Mix.Tasks.Compile.Erlang</code></a>).</p>
<p>Note that sometimes the same configuration option is mentioned in the documentation for different tasks; this is just because it's common for many tasks to read and use the same configuration option (for example, <code class="inline">:erlc_paths</code> is used by <a href="mix.tasks.compile.erlang"><code class="inline">mix compile.erlang</code></a>, <a href="mix.tasks.compile.yecc"><code class="inline">mix compile.yecc</code></a>, and other tasks).</p>
<h2 id="module-erlang-projects" class="section-heading">  Erlang projects </h2> <p>Mix can be used to manage Erlang projects that don't have any Elixir code. To ensure Mix tasks work correctly for an Erlang project, <code class="inline">language: :erlang</code> has to be part of the configuration returned by <code class="inline">project/0</code>. This setting also makes sure Elixir is not added as a dependency to the generated <code class="inline">.app</code> file or to the escript generated with <a href="mix.tasks.escript.build"><code class="inline">mix escript.build</code></a>, and so on.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#app_path/1">app_path(config \\ config())</a> </dt> <dd class="summary-synopsis"><p>Returns the application path inside the build.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#apps_paths/1">apps_paths(config \\ config())</a> </dt> <dd class="summary-synopsis"><p>Returns a map with the umbrella child applications paths.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#build_path/1">build_path(config \\ config())</a> </dt> <dd class="summary-synopsis"><p>Returns the build path for the given project.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#build_structure/2">build_structure(config \\ config(), opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Builds the project structure for the given application.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#clear_deps_cache/0">clear_deps_cache()</a> </dt> <dd class="summary-synopsis"><p>Clears the dependency for the current environment.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#compile_path/1">compile_path(config \\ config())</a> </dt> <dd class="summary-synopsis"><p>Returns the paths the given project compiles to.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#config/0">config()</a> </dt> <dd class="summary-synopsis"><p>Returns the project configuration.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#config_files/0">config_files()</a> </dt> <dd class="summary-synopsis"><p>Returns a list of project configuration files for this project.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#config_mtime/0">config_mtime()</a> </dt> <dd class="summary-synopsis"><p>Returns the latest modification time from config files.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#consolidation_path/1">consolidation_path(config \\ config())</a> </dt> <dd class="summary-synopsis"><p>Returns the path where protocol consolidations are stored.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#deps_apps/0">deps_apps()</a> </dt> <dd class="summary-synopsis"><p>Returns all dependencies app names.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#deps_path/1">deps_path(config \\ config())</a> </dt> <dd class="summary-synopsis"><p>Returns the path where dependencies are stored for the given project.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#deps_paths/1">deps_paths(opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Returns the full path of all dependencies as a map.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#deps_scms/1">deps_scms(opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Returns the SCMs of all dependencies as a map.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#ensure_structure/2">ensure_structure(config \\ config(), opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Ensures the project structure for the given project exists.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get/0">get()</a> </dt> <dd class="summary-synopsis"><p>Retrieves the current project if there is one.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get!/0">get!()</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#get/0"><code class="inline">get/0</code></a>, but raises an exception if there is no current project.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#in_project/4">in_project(app, path, post_config \\ [], fun)</a> </dt> <dd class="summary-synopsis"><p>Runs the given <code class="inline">fun</code> inside the given project.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#load_paths/1">load_paths(config \\ config())</a> <span class="deprecated" title="Use Mix.Project.compile_path/1 instead">deprecated</span> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#manifest_path/1">manifest_path(config \\ config())</a> </dt> <dd class="summary-synopsis"><p>Returns the path where manifests are stored.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#umbrella?/1">umbrella?(config \\ config())</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">config</code> is the configuration for an umbrella project.</p></dd> </div> </dl> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail">  <h3 class="detail-header" id="app_path/1">app_path(config \\ config())<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/project.ex#L596" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">app_path(keyword()) :: Path.t()</pre> </div> <p>Returns the application path inside the build.</p>
<p>The returned path will be expanded.</p>
<h4 id="app_path/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Mix.Project.app_path()
#=&gt; "/path/to/project/_build/shared/lib/app"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="apps_paths/1">apps_paths(config \\ config())<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/project.ex#L264" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">apps_paths(keyword()) :: %{optional(atom()) =&gt; Path.t()} | nil</pre> </div> <p>Returns a map with the umbrella child applications paths.</p>
<p>These paths are based on the <code class="inline">:apps_path</code> and <code class="inline">:apps</code> configurations.</p>
<p>If the given project configuration identifies an umbrella project, the return value is a map of <code class="inline">app =&gt; path</code> where <code class="inline">app</code> is a child app of the umbrella and <code class="inline">path</code> is its path relative to the root of the umbrella project.</p>
<p>If the given project configuration does not identify an umbrella project, <code class="inline">nil</code> is returned.</p>
<h4 id="apps_paths/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Mix.Project.apps_paths()
#=&gt; %{my_app1: "apps/my_app1", my_app2: "apps/my_app2"}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="build_path/1">build_path(config \\ config())<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/project.ex#L525" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">build_path(keyword()) :: Path.t()</pre> </div> <p>Returns the build path for the given project.</p>
<p>If no configuration is given, the one for the current project is used.</p>
<p>The returned path will be expanded.</p>
<h4 id="build_path/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Mix.Project.build_path()
#=&gt; "/path/to/project/_build/shared"</pre>
<p>If <code class="inline">:build_per_environment</code> is set to <code class="inline">true</code>, it will create a new build per environment:</p>
<pre data-language="elixir">Mix.env()
#=&gt; :dev
Mix.Project.build_path()
#=&gt; "/path/to/project/_build/dev"</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="build_structure/2">build_structure(config \\ config(), opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/project.ex#L673" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">build_structure(keyword(), keyword()) :: :ok</pre> </div> <p>Builds the project structure for the given application.</p>
<h4 id="build_structure/2-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:symlink_ebin</code> - symlink ebin instead of copying it</li></ul> </section> </section> <section class="detail"> <h3 class="detail-header" id="clear_deps_cache/0">clear_deps_cache()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/project.ex#L498" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">clear_deps_cache() :: :ok</pre> </div> <p>Clears the dependency for the current environment.</p>
<p>Useful when dependencies need to be reloaded due to change of global state.</p>
<p>For example, Nerves uses this function to force all dependencies to be reloaded after it updates the system environment. It goes roughly like this:</p>
<ol>
<li>Nerves fetches all dependencies and looks for the system specific deps</li>
<li>Once the system specific dep is found, it loads it alongside env vars</li>
<li>Nerves then clears the cache, forcing dependencies to be loaded again</li>
<li>Dependencies are loaded again, now with an updated env environment</li>
</ol> </section> </section> <section class="detail">  <h3 class="detail-header" id="compile_path/1">compile_path(config \\ config())<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/project.ex#L628" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">compile_path(keyword()) :: Path.t()</pre> </div> <p>Returns the paths the given project compiles to.</p>
<p>If no configuration is given, the one for the current project will be used.</p>
<p>The returned path will be expanded.</p>
<h4 id="compile_path/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Mix.Project.compile_path()
#=&gt; "/path/to/project/_build/dev/lib/app/ebin"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="config/0">config()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/project.ex#L196" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">config() :: keyword()</pre> </div> <p>Returns the project configuration.</p>
<p>If there is no project defined, it still returns a keyword list with default values. This allows many Mix tasks to work without the need for an underlying project.</p>
<p>Note this configuration is cached once the project is pushed onto the stack. Calling it multiple times won't cause it to be recomputed.</p>
<p>Do not use <a href="#config/0"><code class="inline">Mix.Project.config/0</code></a> to find the runtime configuration. Use it only to configure aspects of your project (like compilation directories) and not your application runtime.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="config_files/0">config_files()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/project.ex#L214" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">config_files() :: [Path.t()]</pre> </div> <p>Returns a list of project configuration files for this project.</p>
<p>This function is usually used in compilation tasks to trigger a full recompilation whenever such configuration files change.</p>
<p>It returns the <code class="inline">mix.exs</code> file, the lock manifest, and all config files in the <code class="inline">config</code> directory that do not start with a leading period (for example, <code class="inline">.my_config.exs</code>).</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="config_mtime/0">config_mtime()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/project.ex#L227" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">config_mtime() :: posix_mtime when posix_mtime: integer()</pre> </div> <p>Returns the latest modification time from config files.</p>
<p>This function is usually used in compilation tasks to trigger a full recompilation whenever such configuration files change. For this reason, the mtime is cached to avoid file system lookups.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="consolidation_path/1">consolidation_path(config \\ config())<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/project.ex#L649" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">consolidation_path(keyword()) :: Path.t()</pre> </div> <p>Returns the path where protocol consolidations are stored.</p>
<p>The returned path will be expanded.</p>
<h4 id="consolidation_path/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Mix.Project.consolidation_path()
#=&gt; "/path/to/project/_build/dev/lib/my_app/consolidated"</pre>
<p>Inside umbrellas:</p>
<pre data-language="elixir">Mix.Project.consolidation_path()
#=&gt; "/path/to/project/_build/dev/consolidated"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="deps_apps/0">deps_apps()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/project.ex#L393" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">deps_apps() :: [atom()]</pre> </div> <p>Returns all dependencies app names.</p>
<p>The order they are returned is guaranteed to be sorted for proper dependency resolution. For example, if A depends on B, then B will listed before A.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="deps_path/1">deps_path(config \\ config())<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/project.ex#L379" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">deps_path(keyword()) :: Path.t()</pre> </div> <p>Returns the path where dependencies are stored for the given project.</p>
<p>If no configuration is given, the one for the current project is used.</p>
<p>The returned path will be expanded.</p>
<h4 id="deps_path/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Mix.Project.deps_path()
#=&gt; "/path/to/project/deps"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="deps_paths/1">deps_paths(opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/project.ex#L438" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">deps_paths(keyword()) :: %{optional(atom()) =&gt; Path.t()}</pre> </div> <p>Returns the full path of all dependencies as a map.</p>
<h4 id="deps_paths/1-options" class="section-heading">  Options </h4> <ul>
<li>
<code class="inline">:depth</code> - only returns dependencies to the depth level, a depth of 1 will only return top-level dependencies</li>
<li>
<code class="inline">:parents</code> - starts the dependency traversal from the given parents instead of the application root</li>
</ul>
<h4 id="deps_paths/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Mix.Project.deps_paths()
#=&gt; %{foo: "deps/foo", bar: "custom/path/dep"}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="deps_scms/1">deps_scms(opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/project.ex#L417" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">deps_scms(keyword()) :: %{optional(atom()) =&gt; Mix.SCM.t()}</pre> </div> <p>Returns the SCMs of all dependencies as a map.</p>
<p>See <a href="mix.scm"><code class="inline">Mix.SCM</code></a> module documentation to learn more about SCMs.</p>
<h4 id="deps_scms/1-options" class="section-heading">  Options </h4> <ul>
<li>
<code class="inline">:depth</code> - only returns dependencies to the depth level, a depth of 1 will only return top-level dependencies</li>
<li>
<code class="inline">:parents</code> - starts the dependency traversal from the given parents instead of the application root</li>
</ul>
<h4 id="deps_scms/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Mix.Project.deps_scms()
#=&gt; %{foo: Mix.SCM.Path, bar: Mix.SCM.Git}</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="ensure_structure/2">ensure_structure(config \\ config(), opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/project.ex#L715" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">ensure_structure(keyword(), keyword()) :: :ok</pre> </div> <p>Ensures the project structure for the given project exists.</p>
<p>In case it does exist, it is a no-op. Otherwise, it is built.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="get/0">get()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/project.ex#L159" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">get() :: module() | nil</pre> </div> <p>Retrieves the current project if there is one.</p>
<p>If there is no current project, <code class="inline">nil</code> is returned. This may happen in cases there is no <code class="inline">mix.exs</code> in the current directory.</p>
<p>If you expect a project to be defined, i.e., it is a requirement of the current task, you should call <a href="#get!/0"><code class="inline">get!/0</code></a> instead.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="get!/0">get!()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/project.ex#L176" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">get!() :: module()</pre> </div> <p>Same as <a href="#get/0"><code class="inline">get/0</code></a>, but raises an exception if there is no current project.</p>
<p>This is usually called by tasks that need additional functions on the project to be defined. Since such tasks usually depend on a project being defined, this function raises a <a href="mix.noprojecterror"><code class="inline">Mix.NoProjectError</code></a> exception in case no project is available.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="in_project/4">in_project(app, path, post_config \\ [], fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/project.ex#L340" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">in_project(atom(), Path.t(), keyword(), (module() -&gt; result)) :: result
when result: term()</pre> </div> <p>Runs the given <code class="inline">fun</code> inside the given project.</p>
<p>This function changes the current working directory and loads the project at the given directory onto the project stack.</p>
<p>A <code class="inline">post_config</code> can be passed that will be merged into the project configuration.</p>
<p><code class="inline">fun</code> is called with the module name of the given <a href="mix.project#content"><code class="inline">Mix.Project</code></a>. The return value of this function is the return value of <code class="inline">fun</code>.</p>
<h4 id="in_project/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Mix.Project.in_project(:my_app, "/path/to/my_app", fn module -&gt;
  "Mix project is: #{inspect(module)}"
end)
#=&gt; "Mix project is: MyApp.MixProject"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="load_paths/1">load_paths(config \\ config())<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/project.ex#L724" class="source">Source</a>
</h3> <div class="deprecated"> This function is deprecated. Use Mix.Project.compile_path/1 instead. </div>  </section> <section class="detail">  <h3 class="detail-header" id="manifest_path/1">manifest_path(config \\ config())<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/project.ex#L572" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">manifest_path(keyword()) :: Path.t()</pre> </div> <p>Returns the path where manifests are stored.</p>
<p>By default they are stored in the app path inside the build directory. Umbrella applications have the manifest path set to the root of the build directory. Directories may be changed in future releases.</p>
<p>The returned path will be expanded.</p>
<h4 id="manifest_path/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Mix.Project.manifest_path()
#=&gt; "/path/to/project/_build/shared/lib/app/.mix"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="umbrella?/1">umbrella?(config \\ config())<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/project.ex#L240" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">umbrella?(keyword()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">config</code> is the configuration for an umbrella project.</p>
<p>When called with no arguments, tells whether the current project is an umbrella project.</p> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/mix/1.12.0/Mix.Project.html" class="_attribution-link" target="_blank">https://hexdocs.pm/mix/1.12.0/Mix.Project.html</a>
  </p>
</div>
