<h1> Code   </h1> <section id="moduledoc"> <p>Utilities for managing code compilation, code evaluation, and code loading.</p>
<p>This module complements Erlang's <a href="https://erlang.org/doc/man/code.html"><code class="inline">:code</code> module</a> to add behaviour which is specific to Elixir. Almost all of the functions in this module have global side effects on the behaviour of Elixir.</p>
<h2 id="module-working-with-files" class="section-heading">  Working with files </h2> <p>This module contains three functions for compiling and evaluating files. Here is a summary of them and their behaviour:</p>
<ul>
<li><p><a href="#require_file/2"><code class="inline">require_file/2</code></a> - compiles a file and tracks its name. It does not compile the file again if it has been previously required.</p></li>
<li><p><a href="#compile_file/2"><code class="inline">compile_file/2</code></a> - compiles a file without tracking its name. Compiles the file multiple times when invoked multiple times.</p></li>
<li><p><a href="#eval_file/2"><code class="inline">eval_file/2</code></a> - evaluates the file contents without tracking its name. It returns the result of the last expression in the file, instead of the modules defined in it. Evaluated files do not trigger the compilation tracers described in the next section.</p></li>
</ul>
<p>In a nutshell, the first must be used when you want to keep track of the files handled by the system, to avoid the same file from being compiled multiple times. This is common in scripts.</p>
<p><a href="#compile_file/2"><code class="inline">compile_file/2</code></a> must be used when you are interested in the modules defined in a file, without tracking. <a href="#eval_file/2"><code class="inline">eval_file/2</code></a> should be used when you are interested in the result of evaluating the file rather than the modules it defines.</p>
<h2 id="module-code-loading-on-the-erlang-vm" class="section-heading">  Code loading on the Erlang VM </h2> <p>Erlang has two modes to load code: interactive and embedded.</p>
<p>By default, the Erlang VM runs in interactive mode, where modules are loaded as needed. In embedded mode the opposite happens, as all modules need to be loaded upfront or explicitly.</p>
<p>You can use <a href="#ensure_loaded/1"><code class="inline">ensure_loaded/1</code></a> (as well as <code class="inline">ensure_lodead?/1</code> and <code class="inline">ensure_lodead!/1</code>) to check if a module is loaded before using it and act.</p>
<h2 id="module-ensure_compiled-1-and-ensure_compiled-1" class="section-heading">  <a href="#ensure_compiled/1"><code class="inline">ensure_compiled/1</code></a> and <a href="#ensure_compiled!/1"><code class="inline">ensure_compiled!/1</code></a> </h2> <p>Elixir also includes <a href="#ensure_compiled/1"><code class="inline">ensure_compiled/1</code></a> and <a href="#ensure_compiled!/1"><code class="inline">ensure_compiled!/1</code></a> functions that are a superset of <a href="#ensure_loaded/1"><code class="inline">ensure_loaded/1</code></a>.</p>
<p>Since Elixir's compilation happens in parallel, in some situations you may need to use a module that was not yet compiled, therefore it can't even be loaded.</p>
<p>When invoked, <a href="#ensure_compiled/1"><code class="inline">ensure_compiled/1</code></a> and <a href="#ensure_compiled!/1"><code class="inline">ensure_compiled!/1</code></a> halt the compilation of the caller until the module becomes available. Note the distinction between <a href="#ensure_compiled/1"><code class="inline">ensure_compiled/1</code></a> and <a href="#ensure_compiled!/1"><code class="inline">ensure_compiled!/1</code></a> is important: if you are using <a href="#ensure_compiled!/1"><code class="inline">ensure_compiled!/1</code></a>, you are indicating to the compiler that you can only continue if said module is available.</p>
<p>If you are using <a href="#ensure_compiled/1"><code class="inline">Code.ensure_compiled/1</code></a>, you are implying you may continue without the module and therefore Elixir may return <code class="inline">{:error, :unavailable}</code> for cases where the module is not yet available (but may be available later on).</p>
<p>For those reasons, developers must typically use <a href="#ensure_compiled!/1"><code class="inline">Code.ensure_compiled!/1</code></a>. In particular, do not do this:</p>
<pre data-language="elixir">case Code.ensure_compiled(module) do
  {:module, _} -&gt; module
  {:error, _} -&gt; raise ...
end</pre>
<p>Finally, note you only need <a href="#ensure_compiled!/1"><code class="inline">ensure_compiled!/1</code></a> to check for modules being defined within the same project. It does not apply to modules from dependencies as dependencies are always compiled upfront.</p>
<p>In most cases, <a href="#ensure_loaded/1"><code class="inline">ensure_loaded/1</code></a> is enough. <a href="#ensure_compiled!/1"><code class="inline">ensure_compiled!/1</code></a> must be used in rare cases, usually involving macros that need to invoke a module for callback information. The use of <a href="#ensure_compiled/1"><code class="inline">ensure_compiled/1</code></a> is even less likely.</p>
<h2 id="module-compilation-tracers" class="section-heading">  Compilation tracers </h2> <p>Elixir supports compilation tracers, which allows modules to observe constructs handled by the Elixir compiler when compiling files. A tracer is a module that implements the <code class="inline">trace/2</code> function. The function receives the event name as first argument and <a href="macro.env"><code class="inline">Macro.Env</code></a> as second and it must return <code class="inline">:ok</code>. It is very important for a tracer to do as little work as possible synchronously and dispatch the bulk of the work to a separate process. <strong>Slow tracers will slow down compilation</strong>.</p>
<p>You can configure your list of tracers via <a href="#put_compiler_option/2"><code class="inline">put_compiler_option/2</code></a>. The following events are available to tracers:</p>
<ul>
<li><p><code class="inline">:start</code> - (since v1.11.0) invoked whenever the compiler starts to trace a new lexical context, such as a new file. Keep in mind the compiler runs in parallel, so multiple files may invoke <code class="inline">:start</code> and run at the same time. The value of the <code class="inline">lexical_tracker</code> of the macro environment, albeit opaque, can be used to uniquely identify the environment.</p></li>
<li><p><code class="inline">:stop</code> - (since v1.11.0) invoked whenever the compiler stops tracing a new lexical context, such as a new file.</p></li>
<li><p><code class="inline">{:import, meta, module, opts}</code> - traced whenever <code class="inline">module</code> is imported. <code class="inline">meta</code> is the import AST metadata and <code class="inline">opts</code> are the import options.</p></li>
<li><p><code class="inline">{:imported_function, meta, module, name, arity}</code> and <code class="inline">{:imported_macro, meta, module, name, arity}</code> - traced whenever an imported function or macro is invoked. <code class="inline">meta</code> is the call AST metadata, <code class="inline">module</code> is the module the import is from, followed by the <code class="inline">name</code> and <code class="inline">arity</code> of the imported function/macro.</p></li>
<li><p><code class="inline">{:alias, meta, alias, as, opts}</code> - traced whenever <code class="inline">alias</code> is aliased to <code class="inline">as</code>. <code class="inline">meta</code> is the alias AST metadata and <code class="inline">opts</code> are the alias options.</p></li>
<li><p><code class="inline">{:alias_expansion, meta, as, alias}</code> traced whenever there is an alias expansion for a previously defined <code class="inline">alias</code>, i.e. when the user writes <code class="inline">as</code> which is expanded to <code class="inline">alias</code>. <code class="inline">meta</code> is the alias expansion AST metadata.</p></li>
<li><p><code class="inline">{:alias_reference, meta, module}</code> - traced whenever there is an alias in the code, i.e. whenever the user writes <code class="inline">MyModule.Foo.Bar</code> in the code, regardless if it was expanded or not.</p></li>
<li><p><code class="inline">{:require, meta, module, opts}</code> - traced whenever <code class="inline">module</code> is required. <code class="inline">meta</code> is the require AST metadata and <code class="inline">opts</code> are the require options.</p></li>
<li><p><code class="inline">{:struct_expansion, meta, module, keys}</code> - traced whenever <code class="inline">module</code>'s struct is expanded. <code class="inline">meta</code> is the struct AST metadata and <code class="inline">keys</code> are the keys being used by expansion</p></li>
<li><p><code class="inline">{:remote_function, meta, module, name, arity}</code> and <code class="inline">{:remote_macro, meta, module, name, arity}</code> - traced whenever a remote function or macro is referenced. <code class="inline">meta</code> is the call AST metadata, <code class="inline">module</code> is the invoked module, followed by the <code class="inline">name</code> and <code class="inline">arity</code>.</p></li>
<li><p><code class="inline">{:local_function, meta, name, arity}</code> and <code class="inline">{:local_macro, meta, name, arity}</code> - traced whenever a local function or macro is referenced. <code class="inline">meta</code> is the call AST metadata, followed by the <code class="inline">name</code> and <code class="inline">arity</code>.</p></li>
<li><p><code class="inline">{:compile_env, app, path, return}</code> - traced whenever <a href="application#compile_env/3"><code class="inline">Application.compile_env/3</code></a> or <a href="application#compile_env!/2"><code class="inline">Application.compile_env!/2</code></a> are called. <code class="inline">app</code> is an atom, <code class="inline">path</code> is a list of keys to traverse in the application environment and <code class="inline">return</code> is either <code class="inline">{:ok, value}</code> or <code class="inline">:error</code>.</p></li>
</ul>
<p>The <code class="inline">:tracers</code> compiler option can be combined with the <code class="inline">:parser_options</code> compiler option to enrich the metadata of the traced events above.</p>
<p>New events may be added at any time in the future, therefore it is advised for the <code class="inline">trace/2</code> function to have a "catch-all" clause.</p>
<p>Below is an example tracer that prints all remote function invocations:</p>
<pre data-language="elixir">defmodule MyTracer do
  def trace({:remote_function, _meta, module, name, arity}, env) do
    IO.puts "#{env.file}:#{env.line} #{inspect(module)}.#{name}/#{arity}"
    :ok
  end

  def trace(_event, _env) do
    :ok
  end
end</pre> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:binding/0">binding()</a> </dt> <dd class="summary-synopsis"><p>A list with all variable bindings.</p></dd> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#append_path/1">append_path(path)</a> </dt> <dd class="summary-synopsis"><p>Appends a path to the end of the Erlang VM code path list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#available_compiler_options/0">available_compiler_options()</a> </dt> <dd class="summary-synopsis"><p>Returns a list with all available compiler options.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#can_await_module_compilation?/0">can_await_module_compilation?()</a> </dt> <dd class="summary-synopsis"><p>Returns true if the current process can await for module compilation.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#compile_file/2">compile_file(file, relative_to \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Compiles the given file.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#compile_quoted/2">compile_quoted(quoted, file \\ "nofile")</a> </dt> <dd class="summary-synopsis"><p>Compiles the quoted expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#compile_string/2">compile_string(string, file \\ "nofile")</a> </dt> <dd class="summary-synopsis"><p>Compiles the given string.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#compiler_options/0">compiler_options()</a> </dt> <dd class="summary-synopsis"><p>Gets all compilation options from the code server.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#compiler_options/1">compiler_options(opts)</a> </dt> <dd class="summary-synopsis"><p>Stores all given compilation options.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#cursor_context/2">cursor_context(string, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Receives a string and returns the cursor context.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete_path/1">delete_path(path)</a> </dt> <dd class="summary-synopsis"><p>Deletes a path from the Erlang VM code path list. This is the list of directories the Erlang VM uses for finding module code.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#ensure_compiled/1">ensure_compiled(module)</a> </dt> <dd class="summary-synopsis"><p>Similar to <a href="#ensure_compiled!/1"><code class="inline">ensure_compiled!/1</code></a> but indicates you can continue without said module.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#ensure_compiled!/1">ensure_compiled!(module)</a> </dt> <dd class="summary-synopsis"><p>Ensures the given module is compiled and loaded.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#ensure_loaded/1">ensure_loaded(module)</a> </dt> <dd class="summary-synopsis"><p>Ensures the given module is loaded.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#ensure_loaded!/1">ensure_loaded!(module)</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#ensure_loaded/1"><code class="inline">ensure_loaded/1</code></a> but raises if the module cannot be loaded.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#ensure_loaded?/1">ensure_loaded?(module)</a> </dt> <dd class="summary-synopsis"><p>Ensures the given module is loaded.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#eval_file/2">eval_file(file, relative_to \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Evals the given file.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#eval_quoted/3">eval_quoted(quoted, binding \\ [], opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Evaluates the quoted contents.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#eval_string/3">eval_string(string, binding \\ [], opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Evaluates the contents given by <code class="inline">string</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#fetch_docs/1">fetch_docs(module_or_path)</a> </dt> <dd class="summary-synopsis"><p>Returns the docs for the given module or path to <code class="inline">.beam</code> file.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#format_file!/2">format_file!(file, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Formats a file.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#format_string!/2">format_string!(string, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Formats the given code <code class="inline">string</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_compiler_option/1">get_compiler_option(key)</a> </dt> <dd class="summary-synopsis"><p>Returns the value of a given compiler option.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_docs/2">get_docs(module, kind)</a> <span class="deprecated" title="Code.get_docs/2 always returns nil as its outdated documentation is no longer stored on BEAM files. Use Code.fetch_docs/1 instead">deprecated</span> </dt> <dd class="summary-synopsis"><p>Deprecated function to retrieve old documentation format.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#prepend_path/1">prepend_path(path)</a> </dt> <dd class="summary-synopsis"><p>Prepends a path to the beginning of the Erlang VM code path list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#purge_compiler_modules/0">purge_compiler_modules()</a> </dt> <dd class="summary-synopsis"><p>Purge compiler modules.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_compiler_option/2">put_compiler_option(key, value)</a> </dt> <dd class="summary-synopsis"><p>Stores a compilation option.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#require_file/2">require_file(file, relative_to \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Requires the given <code class="inline">file</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#required_files/0">required_files()</a> </dt> <dd class="summary-synopsis"><p>Lists all required files.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#string_to_quoted/2">string_to_quoted(string, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Converts the given string to its quoted form.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#string_to_quoted!/2">string_to_quoted!(string, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Converts the given string to its quoted form.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#unrequire_files/1">unrequire_files(files)</a> </dt> <dd class="summary-synopsis"><p>Removes files from the required files list.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:binding/0">binding()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L173" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">binding() :: [{atom() | tuple(), any()}]</pre> </div> <p>A list with all variable bindings.</p>
<p>The binding keys are usually atoms, but they may be a tuple for variables defined in a different context.</p> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="append_path/1">append_path(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L513" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">append_path(Path.t()) :: true | {:error, :bad_directory}</pre> </div> <p>Appends a path to the end of the Erlang VM code path list.</p>
<p>This is the list of directories the Erlang VM uses for finding module code.</p>
<p>The path is expanded with <a href="path#expand/1"><code class="inline">Path.expand/1</code></a> before being appended. If this path does not exist, an error is returned.</p>
<h4 id="append_path/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Code.append_path(".")
#=&gt; true

Code.append_path("/does_not_exist")
#=&gt; {:error, :bad_directory}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="available_compiler_options/0">available_compiler_options()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1336" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">available_compiler_options() :: [atom()]</pre> </div> <p>Returns a list with all available compiler options.</p>
<p>For a description of all options, see <a href="#put_compiler_option/2"><code class="inline">put_compiler_option/2</code></a>.</p>
<h4 id="available_compiler_options/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Code.available_compiler_options()
#=&gt; [:docs, :debug_info, ...]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="can_await_module_compilation?/0">can_await_module_compilation?()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1656" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">can_await_module_compilation?() :: boolean()</pre> </div> <p>Returns true if the current process can await for module compilation.</p>
<p>When compiling Elixir code via <a href="kernel.parallelcompiler"><code class="inline">Kernel.ParallelCompiler</code></a>, which is used by Mix and <code class="inline">elixirc</code>, calling a module that has not yet been compiled will block the caller until the module becomes available. Executing Elixir scripts, such as passing a filename to <code class="inline">elixir</code>, does not await.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="compile_file/2">compile_file(file, relative_to \\ nil)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1501" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">compile_file(binary(), nil | binary()) :: [{module(), binary()}]</pre> </div> <p>Compiles the given file.</p>
<p>Accepts <code class="inline">relative_to</code> as an argument to tell where the file is located.</p>
<p>Returns a list of tuples where the first element is the module name and the second one is its bytecode (as a binary). Opposite to <a href="#require_file/2"><code class="inline">require_file/2</code></a>, it does not track the filename of the compiled file.</p>
<p>If you would like to get the result of evaluating file rather than the modules defined in it, see <a href="#eval_file/2"><code class="inline">eval_file/2</code></a>.</p>
<p>For compiling many files concurrently, see <a href="kernel.parallelcompiler#compile/2"><code class="inline">Kernel.ParallelCompiler.compile/2</code></a>.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="compile_quoted/2">compile_quoted(quoted, file \\ "nofile")<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1480" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">compile_quoted(Macro.t(), binary()) :: [{module(), binary()}]</pre> </div> <p>Compiles the quoted expression.</p>
<p>Returns a list of tuples where the first element is the module name and the second one is its bytecode (as a binary). A <code class="inline">file</code> can be given as second argument which will be used for reporting warnings and errors.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="compile_string/2">compile_string(string, file \\ "nofile")<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1466" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">compile_string(List.Chars.t(), binary()) :: [{module(), binary()}]</pre> </div> <p>Compiles the given string.</p>
<p>Returns a list of tuples where the first element is the module name and the second one is its bytecode (as a binary). A <code class="inline">file</code> can be given as second argument which will be used for reporting warnings and errors.</p>
<p><strong>Warning</strong>: <code class="inline">string</code> can be any Elixir code and code can be executed with the same privileges as the Erlang VM: this means that such code could compromise the machine (for example by executing system commands). Don't use <a href="#compile_string/2"><code class="inline">compile_string/2</code></a> with untrusted input (such as strings coming from the network).</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="compiler_options/0">compiler_options()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1280" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">compiler_options() :: map()</pre> </div> <p>Gets all compilation options from the code server.</p>
<p>To get individual options, see <a href="#get_compiler_option/1"><code class="inline">get_compiler_option/1</code></a>. For a description of all options, see <a href="#put_compiler_option/2"><code class="inline">put_compiler_option/2</code></a>.</p>
<h4 id="compiler_options/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Code.compiler_options()
#=&gt; %{debug_info: true, docs: true, ...}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="compiler_options/1">compiler_options(opts)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1299" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">compiler_options(Enumerable.t()) :: %{optional(atom()) =&gt; boolean()}</pre> </div> <p>Stores all given compilation options.</p>
<p>To store individual options, see <a href="#put_compiler_option/2"><code class="inline">put_compiler_option/2</code></a>. For a description of all options, see <a href="#put_compiler_option/2"><code class="inline">put_compiler_option/2</code></a>.</p>
<h4 id="compiler_options/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Code.compiler_options()
#=&gt; %{debug_info: true, docs: true, ...}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="cursor_context/2">cursor_context(string, opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L307" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">cursor_context(List.Chars.t(), keyword()) ::
  {:alias, charlist()}
  | {:dot, inside_dot, charlist()}
  | {:dot_arity, inside_dot, charlist()}
  | {:dot_call, inside_dot, charlist()}
  | :expr
  | {:local_or_var, charlist()}
  | {:local_arity, charlist()}
  | {:local_call, charlist()}
  | {:module_attribute, charlist()}
  | :none
  | {:unquoted_atom, charlist()}
when inside_dot:
       {:alias, charlist()}
       | {:dot, inside_dot, charlist()}
       | {:module_attribute, charlist()}
       | {:unquoted_atom, charlist()}
       | {:var, charlist()}</pre> </div> <p>Receives a string and returns the cursor context.</p>
<p>This function receives a string with incomplete Elixir code, representing a cursor position, and based on the string, it provides contextual information about said position. The return of this function can then be used to provide tips, suggestions, and autocompletion functionality.</p>
<p>This function provides a best-effort detection and may not be accurate under certain circumstances. See the "Limitations" section below.</p>
<p>Consider adding a catch-all clause when handling the return type of this function as new cursor information may be added in future releases.</p>
<h4 id="cursor_context/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Code.cursor_context("")
:expr

iex&gt; Code.cursor_context("hello_wor")
{:local_or_var, 'hello_wor'}</pre>
<h4 id="cursor_context/2-return-values" class="section-heading">  Return values </h4> <ul>
<li><p><code class="inline">{:alias, charlist}</code> - the context is an alias, potentially a nested one, such as <code class="inline">Hello.Wor</code> or <code class="inline">HelloWor</code></p></li>
<li><p><code class="inline">{:dot, inside_dot, charlist}</code> - the context is a dot where <code class="inline">inside_dot</code> is either a <code class="inline">{:var, charlist}</code>, <code class="inline">{:alias, charlist}</code>, <code class="inline">{:module_attribute, charlist}</code>, <code class="inline">{:unquoted_atom, charlist}</code> or a <code class="inline">dot</code> itself. If a var is given, this may either be a remote call or a map field access. Examples are <code class="inline">Hello.wor</code>, <code class="inline">:hello.wor</code>, <code class="inline">hello.wor</code>, <code class="inline">Hello.nested.wor</code>, <code class="inline">hello.nested.wor</code>, and <code class="inline">@hello.world</code></p></li>
<li><p><code class="inline">{:dot_arity, inside_dot, charlist}</code> - the context is a dot arity where <code class="inline">inside_dot</code> is either a <code class="inline">{:var, charlist}</code>, <code class="inline">{:alias, charlist}</code>, <code class="inline">{:module_attribute, charlist}</code>, <code class="inline">{:unquoted_atom, charlist}</code> or a <code class="inline">dot</code> itself. If a var is given, it must be a remote arity. Examples are <code class="inline">Hello.world/</code>, <code class="inline">:hello.world/</code>, <code class="inline">hello.world/2</code>, and <code class="inline">@hello.world/2</code></p></li>
<li><p><code class="inline">{:dot_call, inside_dot, charlist}</code> - the context is a dot call. This means parentheses or space have been added after the expression. where <code class="inline">inside_dot</code> is either a <code class="inline">{:var, charlist}</code>, <code class="inline">{:alias, charlist}</code>, <code class="inline">{:module_attribute, charlist}</code>, <code class="inline">{:unquoted_atom, charlist}</code> or a <code class="inline">dot</code> itself. If a var is given, it must be a remote call. Examples are <code class="inline">Hello.world(</code>, <code class="inline">:hello.world(</code>, <code class="inline">Hello.world</code>, <code class="inline">hello.world(</code>, <code class="inline">hello.world</code>, and <code class="inline">@hello.world(</code></p></li>
<li><p><code class="inline">:expr</code> - may be any expression. Autocompletion may suggest an alias, local or var</p></li>
<li><p><code class="inline">{:local_or_var, charlist}</code> - the context is a variable or a local (import or local) call, such as <code class="inline">hello_wor</code></p></li>
<li><p><code class="inline">{:local_arity, charlist}</code> - the context is a local (import or local) call, such as <code class="inline">hello_world/</code></p></li>
<li><p><code class="inline">{:local_call, charlist}</code> - the context is a local (import or local) call, such as <code class="inline">hello_world(</code> and <code class="inline">hello_world</code></p></li>
<li><p><code class="inline">{:module_attribute, charlist}</code> - the context is a module attribute, such as <code class="inline">@hello_wor</code></p></li>
<li><p><code class="inline">:none</code> - no context possible</p></li>
<li><p><code class="inline">:unquoted_atom</code> - the context is an unquoted atom. This can be either previous atoms or all available <code class="inline">:erlang</code> modules</p></li>
</ul>
<h4 id="cursor_context/2-limitations" class="section-heading">  Limitations </h4> <ul>
<li>There is no context for operators</li>
<li>The current algorithm only considers the last line of the input</li>
<li>Context does not yet track strings, sigils, etc.</li>
<li>Arguments of functions calls are not currently recognized</li>
</ul> </section> </section> <section class="detail"> <h3 class="detail-header" id="delete_path/1">delete_path(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L558" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">delete_path(Path.t()) :: boolean()</pre> </div> <p>Deletes a path from the Erlang VM code path list. This is the list of directories the Erlang VM uses for finding module code.</p>
<p>The path is expanded with <a href="path#expand/1"><code class="inline">Path.expand/1</code></a> before being deleted. If the path does not exist, this function returns <code class="inline">false</code>.</p>
<h4 id="delete_path/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Code.prepend_path(".")
Code.delete_path(".")
#=&gt; true

Code.delete_path("/does_not_exist")
#=&gt; false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="ensure_compiled/1">ensure_compiled(module)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1592" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">ensure_compiled(module()) ::
  {:module, module()}
  | {:error, :embedded | :badfile | :nofile | :on_load_failure | :unavailable}</pre> </div> <p>Similar to <a href="#ensure_compiled!/1"><code class="inline">ensure_compiled!/1</code></a> but indicates you can continue without said module.</p>
<p>While <a href="#ensure_compiled!/1"><code class="inline">ensure_compiled!/1</code></a> indicates to the Elixir compiler you can only continue when said module is available, this function indicates you may continue compilation without said module.</p>
<p>If it succeeds in loading the module, it returns <code class="inline">{:module, module}</code>. If not, returns <code class="inline">{:error, reason}</code> with the error reason. If the module being checked is currently in a compiler deadlock, this function returns <code class="inline">{:error, :unavailable}</code>. Unavailable doesn't necessarily mean the module doesn't exist, just that it is not currently available, but it (or may not) become available in the future.</p>
<p>Therefore, if you can only continue if the module is available, use <a href="#ensure_compiled!/1"><code class="inline">ensure_compiled!/1</code></a> instead. In particular, do not do this:</p>
<pre data-language="elixir">case Code.ensure_compiled(module) do
  {:module, _} -&gt; module
  {:error, _} -&gt; raise ...
end</pre>
<p>See the module documentation for more information on code loading.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="ensure_compiled!/1">ensure_compiled!(module)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1616" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">ensure_compiled!(module()) :: module()</pre> </div> <p>Ensures the given module is compiled and loaded.</p>
<p>If the module is already loaded, it works as no-op. If the module was not compiled yet, <a href="#ensure_compiled!/1"><code class="inline">ensure_compiled!/1</code></a> halts the compilation of the caller until the module given to <a href="#ensure_compiled!/1"><code class="inline">ensure_compiled!/1</code></a> becomes available or all files for the current project have been compiled. If compilation finishes and the module is not available or is in a deadlock, an error is raised.</p>
<p>Given this function halts compilation, use it carefully. In particular, avoid using it to guess which modules are in the system. Overuse of this function can also lead to deadlocks, where two modules check at the same time if the other is compiled. This returns a specific unavailable error code, where we cannot successfully verify a module is available or not.</p>
<p>See the module documentation for more information on code loading.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="ensure_loaded/1">ensure_loaded(module)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1528" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">ensure_loaded(module()) ::
  {:module, module()}
  | {:error, :embedded | :badfile | :nofile | :on_load_failure}</pre> </div> <p>Ensures the given module is loaded.</p>
<p>If the module is already loaded, this works as no-op. If the module was not yet loaded, it tries to load it.</p>
<p>If it succeeds in loading the module, it returns <code class="inline">{:module, module}</code>. If not, returns <code class="inline">{:error, reason}</code> with the error reason.</p>
<p>See the module documentation for more information on code loading.</p>
<h4 id="ensure_loaded/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Code.ensure_loaded(Atom)
{:module, Atom}

iex&gt; Code.ensure_loaded(DoesNotExist)
{:error, :nofile}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="ensure_loaded!/1">ensure_loaded!(module)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1554" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">ensure_loaded!(module()) :: module()</pre> </div> <p>Same as <a href="#ensure_loaded/1"><code class="inline">ensure_loaded/1</code></a> but raises if the module cannot be loaded.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="ensure_loaded?/1">ensure_loaded?(module)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1546" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">ensure_loaded?(module()) :: boolean()</pre> </div> <p>Ensures the given module is loaded.</p>
<p>Similar to <a href="#ensure_loaded/1"><code class="inline">ensure_loaded/1</code></a>, but returns <code class="inline">true</code> if the module is already loaded or was successfully loaded. Returns <code class="inline">false</code> otherwise.</p>
<h4 id="ensure_loaded?/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Code.ensure_loaded?(Atom)
true</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="eval_file/2">eval_file(file, relative_to \\ nil)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1205" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">eval_file(binary(), nil | binary()) :: {term(), binding()}</pre> </div> <p>Evals the given file.</p>
<p>Accepts <code class="inline">relative_to</code> as an argument to tell where the file is located.</p>
<p>While <a href="#require_file/2"><code class="inline">require_file/2</code></a> and <a href="#compile_file/2"><code class="inline">compile_file/2</code></a> return the loaded modules and their bytecode, <a href="#eval_file/2"><code class="inline">eval_file/2</code></a> simply evaluates the file contents and returns the evaluation result and its binding (exactly the same return value as <a href="#eval_string/3"><code class="inline">eval_string/3</code></a>).</p> </section> </section> <section class="detail">   <h3 class="detail-header" id="eval_quoted/3">eval_quoted(quoted, binding \\ [], opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1027" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">eval_quoted(Macro.t(), binding(), Macro.Env.t() | keyword()) ::
  {term(), binding()}</pre> </div> <p>Evaluates the quoted contents.</p>
<p><strong>Warning</strong>: Calling this function inside a macro is considered bad practice as it will attempt to evaluate runtime values at compile time. Macro arguments are typically transformed by unquoting them into the returned quoted expressions (instead of evaluated).</p>
<p>See <a href="#eval_string/3"><code class="inline">eval_string/3</code></a> for a description of <code class="inline">binding</code> and options.</p>
<h4 id="eval_quoted/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; contents = quote(do: var!(a) + var!(b))
iex&gt; {result, binding} = Code.eval_quoted(contents, [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)
iex&gt; result
3
iex&gt; Enum.sort(binding)
[a: 1, b: 2]</pre>
<p>For convenience, you can pass <a href="kernel.specialforms#__ENV__/0"><code class="inline">__ENV__/0</code></a> as the <code class="inline">opts</code> argument and all options will be automatically extracted from the current environment:</p>
<pre data-language="elixir">iex&gt; contents = quote(do: var!(a) + var!(b))
iex&gt; {result, binding} = Code.eval_quoted(contents, [a: 1, b: 2], __ENV__)
iex&gt; result
3
iex&gt; Enum.sort(binding)
[a: 1, b: 2]</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="eval_string/3">eval_string(string, binding \\ [], opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L642" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">eval_string(List.Chars.t(), binding(), Macro.Env.t() | keyword()) ::
  {term(), binding()}</pre> </div> <p>Evaluates the contents given by <code class="inline">string</code>.</p>
<p>The <code class="inline">binding</code> argument is a list of variable bindings. The <code class="inline">opts</code> argument is a keyword list of environment options.</p>
<p><strong>Warning</strong>: <code class="inline">string</code> can be any Elixir code and will be executed with the same privileges as the Erlang VM: this means that such code could compromise the machine (for example by executing system commands). Don't use <a href="#eval_string/3"><code class="inline">eval_string/3</code></a> with untrusted input (such as strings coming from the network).</p>
<h4 id="eval_string/3-options" class="section-heading">  Options </h4> <p>Options can be:</p>
<ul>
<li><p><code class="inline">:file</code> - the file to be considered in the evaluation</p></li>
<li><p><code class="inline">:line</code> - the line on which the script starts</p></li>
</ul>
<p>Additionally, the following scope values can be configured:</p>
<ul>
<li><p><code class="inline">:aliases</code> - a list of tuples with the alias and its target</p></li>
<li><p><code class="inline">:requires</code> - a list of modules required</p></li>
<li><p><code class="inline">:functions</code> - a list of tuples where the first element is a module and the second a list of imported function names and arity; the list of function names and arity must be sorted</p></li>
<li><p><code class="inline">:macros</code> - a list of tuples where the first element is a module and the second a list of imported macro names and arity; the list of function names and arity must be sorted</p></li>
</ul>
<p>Note that setting any of the values above overrides Elixir's default values. For example, setting <code class="inline">:requires</code> to <code class="inline">[]</code> will no longer automatically require the <a href="kernel"><code class="inline">Kernel</code></a> module. In the same way setting <code class="inline">:macros</code> will no longer auto-import <a href="kernel"><code class="inline">Kernel</code></a> macros like <a href="kernel#if/2"><code class="inline">Kernel.if/2</code></a>, <a href="kernel.specialforms#case/2"><code class="inline">Kernel.SpecialForms.case/2</code></a>, and so on.</p>
<p>Returns a tuple of the form <code class="inline">{value, binding}</code>, where <code class="inline">value</code> is the value returned from evaluating <code class="inline">string</code>. If an error occurs while evaluating <code class="inline">string</code> an exception will be raised.</p>
<p><code class="inline">binding</code> is a list with all variable bindings after evaluating <code class="inline">string</code>. The binding keys are usually atoms, but they may be a tuple for variables defined in a different context.</p>
<h4 id="eval_string/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; {result, binding} = Code.eval_string("a + b", [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)
iex&gt; result
3
iex&gt; Enum.sort(binding)
[a: 1, b: 2]

iex&gt; {result, binding} = Code.eval_string("c = a + b", [a: 1, b: 2], __ENV__)
iex&gt; result
3
iex&gt; Enum.sort(binding)
[a: 1, b: 2, c: 3]

iex&gt; {result, binding} = Code.eval_string("a = a + b", [a: 1, b: 2])
iex&gt; result
3
iex&gt; Enum.sort(binding)
[a: 3, b: 2]</pre>
<p>For convenience, you can pass <a href="kernel.specialforms#__ENV__/0"><code class="inline">__ENV__/0</code></a> as the <code class="inline">opts</code> argument and all imports, requires and aliases defined in the current environment will be automatically carried over:</p>
<pre data-language="elixir">iex&gt; {result, binding} = Code.eval_string("a + b", [a: 1, b: 2], __ENV__)
iex&gt; result
3
iex&gt; Enum.sort(binding)
[a: 1, b: 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="fetch_docs/1">fetch_docs(module_or_path)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1704" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">fetch_docs(module() | String.t()) ::
  {:docs_v1, annotation, beam_language, format, module_doc :: doc_content,
   metadata, docs :: [doc_element]}
  | {:error, :module_not_found | :chunk_not_found | {:invalid_chunk, binary()}}
when annotation: :erl_anno.anno(),
     beam_language: :elixir | :erlang | atom(),
     doc_content: %{optional(binary()) =&gt; binary()} | :none | :hidden,
     doc_element:
       {{kind :: atom(), function_name :: atom(), arity()}, annotation,
        signature, doc_content, metadata},
     format: binary(),
     signature: [binary()],
     metadata: map()</pre> </div> <p>Returns the docs for the given module or path to <code class="inline">.beam</code> file.</p>
<p>When given a module name, it finds its BEAM code and reads the docs from it.</p>
<p>When given a path to a <code class="inline">.beam</code> file, it will load the docs directly from that file.</p>
<p>It returns the term stored in the documentation chunk in the format defined by <a href="https://erlang.org/eep/eeps/eep-0048.html">EEP 48</a> or <code class="inline">{:error, reason}</code> if the chunk is not available.</p>
<h4 id="fetch_docs/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Module documentation of an existing module
iex&gt; {:docs_v1, _, :elixir, _, %{"en" =&gt; module_doc}, _, _} = Code.fetch_docs(Atom)
iex&gt; module_doc |&gt; String.split("\n") |&gt; Enum.at(0)
"Atoms are constants whose values are their own name."

# A module that doesn't exist
iex&gt; Code.fetch_docs(ModuleNotGood)
{:error, :module_not_found}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="format_file!/2">format_file!(file, opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L990" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">format_file!(binary(), keyword()) :: iodata()</pre> </div> <p>Formats a file.</p>
<p>See <a href="#format_string!/2"><code class="inline">format_string!/2</code></a> for more information on code formatting and available options.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="format_string!/2">format_string!(string, opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L976" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">format_string!(binary(), keyword()) :: iodata()</pre> </div> <p>Formats the given code <code class="inline">string</code>.</p>
<p>The formatter receives a string representing Elixir code and returns iodata representing the formatted code according to pre-defined rules.</p>
<h4 id="format_string!/2-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:file</code> - the file which contains the string, used for error reporting</p></li>
<li><p><code class="inline">:line</code> - the line the string starts, used for error reporting</p></li>
<li><p><code class="inline">:line_length</code> - the line length to aim for when formatting the document. Defaults to 98. Note this value is used as guideline but there are situations where it is not enforced. See the "Line length" section below for more information</p></li>
<li><p><code class="inline">:locals_without_parens</code> - a keyword list of name and arity pairs that should be kept without parens whenever possible. The arity may be the atom <code class="inline">:*</code>, which implies all arities of that name. The formatter already includes a list of functions and this option augments this list.</p></li>
<li><p><code class="inline">:force_do_end_blocks</code> (since v1.9.0) - when <code class="inline">true</code>, converts all inline usages of <code class="inline">do: ...</code>, <code class="inline">else: ...</code> and friends into <code class="inline">do/end</code> blocks. Defaults to <code class="inline">false</code>. Note that this option is convergent: once you set it to <code class="inline">true</code>, <strong>all keywords</strong> will be converted. If you set it to <code class="inline">false</code> later on, <code class="inline">do/end</code> blocks won't be converted back to keywords.</p></li>
</ul>
<h4 id="format_string!/2-design-principles" class="section-heading">  Design principles </h4> <p>The formatter was designed under three principles.</p>
<p>First, the formatter never changes the semantics of the code by default. This means the input AST and the output AST are equivalent.</p>
<p>The second principle is to provide as little configuration as possible. This eases the formatter adoption by removing contention points while making sure a single style is followed consistently by the community as a whole.</p>
<p>The formatter does not hard code names. The formatter will not behave specially because a function is named <code class="inline">defmodule</code>, <code class="inline">def</code>, or the like. This principle mirrors Elixir's goal of being an extensible language where developers can extend the language with new constructs as if they were part of the language. When it is absolutely necessary to change behaviour based on the name, this behaviour should be configurable, such as the <code class="inline">:locals_without_parens</code> option.</p>
<h4 id="format_string!/2-running-the-formatter" class="section-heading">  Running the formatter </h4> <p>The formatter attempts to fit the most it can on a single line and introduces line breaks wherever possible when it cannot.</p>
<p>In some cases, this may lead to undesired formatting. Therefore, <strong>some code generated by the formatter may not be aesthetically pleasing and may require explicit intervention from the developer</strong>. That's why we do not recommend to run the formatter blindly in an existing codebase. Instead you should format and sanity check each formatted file.</p>
<p>For example, the formatter may break a long function definition over multiple clauses:</p>
<pre data-language="elixir">def my_function(
  %User{name: name, age: age, ...},
  arg1,
  arg2
) do
  ...
end</pre>
<p>While the code above is completely valid, you may prefer to match on the struct variables inside the function body in order to keep the definition on a single line:</p>
<pre data-language="elixir">def my_function(%User{} = user, arg1, arg2) do
  %{name: name, age: age, ...} = user
  ...
end</pre>
<p>In some situations, you can use the fact the formatter does not generate elegant code as a hint for refactoring. Take this code:</p>
<pre data-language="elixir">def board?(board_id, %User{} = user, available_permissions, required_permissions) do
  Tracker.OrganizationMembers.user_in_organization?(user.id, board.organization_id) and
    required_permissions == Enum.to_list(MapSet.intersection(MapSet.new(required_permissions), MapSet.new(available_permissions)))
end</pre>
<p>The code above has very long lines and running the formatter is not going to address this issue. In fact, the formatter may make it more obvious that you have complex expressions:</p>
<pre data-language="elixir">def board?(board_id, %User{} = user, available_permissions, required_permissions) do
  Tracker.OrganizationMembers.user_in_organization?(user.id, board.organization_id) and
    required_permissions ==
      Enum.to_list(
        MapSet.intersection(
          MapSet.new(required_permissions),
          MapSet.new(available_permissions)
        )
      )
end</pre>
<p>Take such cases as a suggestion that your code should be refactored:</p>
<pre data-language="elixir">def board?(board_id, %User{} = user, available_permissions, required_permissions) do
  Tracker.OrganizationMembers.user_in_organization?(user.id, board.organization_id) and
    matching_permissions?(required_permissions, available_permissions)
end

defp matching_permissions?(required_permissions, available_permissions) do
  intersection =
    required_permissions
    |&gt; MapSet.new()
    |&gt; MapSet.intersection(MapSet.new(available_permissions))
    |&gt; Enum.to_list()

  required_permissions == intersection
end</pre>
<p>To sum it up: since the formatter cannot change the semantics of your code, sometimes it is necessary to tweak or refactor the code to get optimal formatting. To help better understand how to control the formatter, we describe in the next sections the cases where the formatter keeps the user encoding and how to control multiline expressions.</p>
<h4 id="format_string!/2-line-length" class="section-heading">  Line length </h4> <p>Another point about the formatter is that the <code class="inline">:line_length</code> configuration is a guideline. In many cases, it is not possible for the formatter to break your code apart, which means it will go over the line length. For example, if you have a long string:</p>
<pre data-language="elixir">"this is a very long string that will go over the line length"</pre>
<p>The formatter doesn't know how to break it apart without changing the code underlying syntax representation, so it is up to you to step in:</p>
<pre data-language="elixir">"this is a very long string " &lt;&gt;
   "that will go over the line length"</pre>
<p>The string concatenation makes the code fit on a single line and also gives more options to the formatter.</p>
<p>This may also appear in do/end blocks, where the <code class="inline">do</code> keyword (or <code class="inline">-&gt;</code>) may go over the line lenth because there is no opportunity for the formatter to introduce a line break in a readable way. For example, if you do:</p>
<pre data-language="elixir">case very_long_expression() do</pre>
<p>And only the <code class="inline">do</code> keyword is above the line length, Elixir <strong>will not</strong> emit this:</p>
<pre data-language="elixir">case very_long_expression()
do</pre>
<p>So it prefers to not touch the line at all and leave <code class="inline">do</code> above the line limit.</p>
<h4 id="format_string!/2-keeping-user-s-formatting" class="section-heading">  Keeping user's formatting </h4> <p>The formatter respects the input format in some cases. Those are listed below:</p>
<ul>
<li><p>Insignificant digits in numbers are kept as is. The formatter however always inserts underscores for decimal numbers with more than 5 digits and converts hexadecimal digits to uppercase</p></li>
<li><p>Strings, charlists, atoms and sigils are kept as is. No character is automatically escaped or unescaped. The choice of delimiter is also respected from the input</p></li>
<li>
<p>Newlines inside blocks are kept as in the input except for:</p>
<ol><li>expressions that take multiple lines will always have an empty line before and after and 2) empty lines are always squeezed together into a single empty line</li></ol>
</li>
<li><p>The choice between <code class="inline">:do</code> keyword and <code class="inline">do/end</code> blocks is left to the user</p></li>
<li><p>Lists, tuples, bitstrings, maps, structs and function calls will be broken into multiple lines if they are followed by a newline in the opening bracket and preceded by a new line in the closing bracket</p></li>
<li><p>Newlines before certain operators (such as the pipeline operators) and before other operators (such as comparison operators)</p></li>
</ul>
<p>The behaviours above are not guaranteed. We may remove or add new rules in the future. The goal of documenting them is to provide better understanding on what to expect from the formatter.</p>
<h3 id="format_string!/2-multi-line-lists-maps-tuples-and-the-like" class="section-heading">  Multi-line lists, maps, tuples, and the like </h3> <p>You can force lists, tuples, bitstrings, maps, structs and function calls to have one entry per line by adding a newline after the opening bracket and a new line before the closing bracket lines. For example:</p>
<pre data-language="elixir">[
  foo,
  bar
]</pre>
<p>If there are no newlines around the brackets, then the formatter will try to fit everything on a single line, such that the snippet below</p>
<pre data-language="elixir">[foo,
 bar]</pre>
<p>will be formatted as</p>
<pre data-language="elixir">[foo, bar]</pre>
<p>You can also force function calls and keywords to be rendered on multiple lines by having each entry on its own line:</p>
<pre data-language="elixir">defstruct name: nil,
          age: 0</pre>
<p>The code above will be kept with one keyword entry per line by the formatter. To avoid that, just squash everything into a single line.</p>
<h3 id="format_string!/2-parens-and-no-parens-in-function-calls" class="section-heading">  Parens and no parens in function calls </h3> <p>Elixir has two syntaxes for function calls. With parens and no parens. By default, Elixir will add parens to all calls except for:</p>
<ol>
<li>calls that have do/end blocks</li>
<li>local calls without parens where the name and arity of the local call is also listed under <code class="inline">:locals_without_parens</code> (except for calls with arity 0, where the compiler always require parens)</li>
</ol>
<p>The choice of parens and no parens also affects indentation. When a function call with parens doesn't fit on the same line, the formatter introduces a newline around parens and indents the arguments with two spaces:</p>
<pre data-language="elixir">some_call(
  arg1,
  arg2,
  arg3
)</pre>
<p>On the other hand, function calls without parens are always indented by the function call length itself, like this:</p>
<pre data-language="elixir">some_call arg1,
          arg2,
          arg3</pre>
<p>If the last argument is a data structure, such as maps and lists, and the beginning of the data structure fits on the same line as the function call, then no indentation happens, this allows code like this:</p>
<pre data-language="elixir">Enum.reduce(some_collection, initial_value, fn element, acc -&gt;
  # code
end)

some_function_without_parens %{
  foo: :bar,
  baz: :bat
}</pre>
<h4 id="format_string!/2-code-comments" class="section-heading">  Code comments </h4> <p>The formatter also handles code comments in a way to guarantee a space is always added between the beginning of the comment (#) and the next character.</p>
<p>The formatter also extracts all trailing comments to their previous line. For example, the code below</p>
<pre data-language="elixir">hello #world</pre>
<p>will be rewritten to</p>
<pre data-language="elixir"># world
hello</pre>
<p>Because code comments are handled apart from the code representation (AST), there are some situations where code comments are seen as ambiguous by the code formatter. For example, the comment in the anonymous function below</p>
<pre data-language="elixir">fn
  arg1 -&gt;
    body1
    # comment

  arg2 -&gt;
    body2
end</pre>
<p>and in this one</p>
<pre data-language="elixir">fn
  arg1 -&gt;
    body1

  # comment
  arg2 -&gt;
    body2
end</pre>
<p>are considered equivalent (the nesting is discarded alongside most of user formatting). In such cases, the code formatter will always format to the latter.</p>
<h4 id="format_string!/2-newlines" class="section-heading">  Newlines </h4> <p>The formatter converts all newlines in code from <code class="inline">\r\n</code> to <code class="inline">\n</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_compiler_option/1">get_compiler_option(key)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1320" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">get_compiler_option(atom()) :: term()</pre> </div> <p>Returns the value of a given compiler option.</p>
<p>For a description of all options, see <a href="#put_compiler_option/2"><code class="inline">put_compiler_option/2</code></a>.</p>
<h4 id="get_compiler_option/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Code.get_compiler_option(:debug_info)
#=&gt; true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_docs/2">get_docs(module, kind)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1786" class="source">Source</a>
</h3> <div class="deprecated"> This function is deprecated. Code.get_docs/2 always returns nil as its outdated documentation is no longer stored on BEAM files. Use Code.fetch_docs/1 instead. </div> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">get_docs(module(), :moduledoc | :docs | :callback_docs | :type_docs | :all) ::
  nil</pre> </div> <p>Deprecated function to retrieve old documentation format.</p>
<p>Elixir v1.7 adopts <a href="https://erlang.org/eep/eeps/eep-0048.html">EEP 48</a> which is a new documentation format meant to be shared across all BEAM languages. The old format, used by <a href="#get_docs/2"><code class="inline">Code.get_docs/2</code></a>, is no longer available, and therefore this function always returns <code class="inline">nil</code>. Use <a href="#fetch_docs/1"><code class="inline">Code.fetch_docs/1</code></a> instead.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="prepend_path/1">prepend_path(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L536" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">prepend_path(Path.t()) :: true | {:error, :bad_directory}</pre> </div> <p>Prepends a path to the beginning of the Erlang VM code path list.</p>
<p>This is the list of directories the Erlang VM uses for finding module code.</p>
<p>The path is expanded with <a href="path#expand/1"><code class="inline">Path.expand/1</code></a> before being prepended. If this path does not exist, an error is returned.</p>
<h4 id="prepend_path/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Code.prepend_path(".")
#=&gt; true

Code.prepend_path("/does_not_exist")
#=&gt; {:error, :bad_directory}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="purge_compiler_modules/0">purge_compiler_modules()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1447" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">purge_compiler_modules() :: {:ok, non_neg_integer()}</pre> </div> <p>Purge compiler modules.</p>
<p>The compiler utilizes temporary modules to compile code. For example, <code class="inline">elixir_compiler_1</code>, <code class="inline">elixir_compiler_2</code>, and so on. In case the compiled code stores references to anonymous functions or similar, the Elixir compiler may be unable to reclaim those modules, keeping an unnecessary amount of code in memory and eventually leading to modules such as <code class="inline">elixir_compiler_12345</code>.</p>
<p>This function purges all modules currently kept by the compiler, allowing old compiler module names to be reused. If there are any processes running any code from such modules, they will be terminated too.</p>
<p>It returns <code class="inline">{:ok, number_of_modules_purged}</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_compiler_option/2">put_compiler_option(key, value)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1388" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">put_compiler_option(atom(), term()) :: :ok</pre> </div> <p>Stores a compilation option.</p>
<p>These options are global since they are stored by Elixir's code server.</p>
<p>Available options are:</p>
<ul>
<li><p><code class="inline">:docs</code> - when <code class="inline">true</code>, retain documentation in the compiled module. Defaults to <code class="inline">true</code>.</p></li>
<li><p><code class="inline">:debug_info</code> - when <code class="inline">true</code>, retain debug information in the compiled module. This allows a developer to reconstruct the original source code. Defaults to <code class="inline">true</code>.</p></li>
<li><p><code class="inline">:ignore_module_conflict</code> - when <code class="inline">true</code>, override modules that were already defined without raising errors. Defaults to <code class="inline">false</code>.</p></li>
<li><p><code class="inline">:relative_paths</code> - when <code class="inline">true</code>, use relative paths in quoted nodes, warnings and errors generated by the compiler. Note disabling this option won't affect runtime warnings and errors. Defaults to <code class="inline">true</code>.</p></li>
<li><p><code class="inline">:warnings_as_errors</code> - causes compilation to fail when warnings are generated. Defaults to <code class="inline">false</code>.</p></li>
<li><p><code class="inline">:no_warn_undefined</code> (since v1.10.0) - list of modules and <code class="inline">{Mod, fun, arity}</code> tuples that will not emit warnings that the module or function does not exist at compilation time. Pass atom <code class="inline">:all</code> to skip warning for all undefined functions. This can be useful when doing dynamic compilation. Defaults to <code class="inline">[]</code>.</p></li>
<li><p><code class="inline">:tracers</code> (since v1.10.0) - a list of tracers (modules) to be used during compilation. See the module docs for more information. Defaults to <code class="inline">[]</code>.</p></li>
<li><p><code class="inline">:parser_options</code> (since v1.10.0) - a keyword list of options to be given to the parser when compiling files. It accepts the same options as <a href="#string_to_quoted/2"><code class="inline">string_to_quoted/2</code></a> (except by the options that change the AST itself). This can be used in combination with the tracer to retrieve localized information about events happening during compilation. Defaults to <code class="inline">[]</code>.</p></li>
</ul>
<p>It always returns <code class="inline">:ok</code>. Raises an error for invalid options.</p>
<h4 id="put_compiler_option/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Code.put_compiler_option(:debug_info, true)
#=&gt; :ok</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="require_file/2">require_file(file, relative_to \\ nil)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1253" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">require_file(binary(), nil | binary()) :: [{module(), binary()}] | nil</pre> </div> <p>Requires the given <code class="inline">file</code>.</p>
<p>Accepts <code class="inline">relative_to</code> as an argument to tell where the file is located. If the file was already required, <a href="#require_file/2"><code class="inline">require_file/2</code></a> doesn't do anything and returns <code class="inline">nil</code>.</p>
<p>Note that if <a href="#require_file/2"><code class="inline">require_file/2</code></a> is invoked by different processes concurrently, the first process to invoke <a href="#require_file/2"><code class="inline">require_file/2</code></a> acquires a lock and the remaining ones will block until the file is available. This means that if <a href="#require_file/2"><code class="inline">require_file/2</code></a> is called more than once with a given file, that file will be compiled only once. The first process to call <a href="#require_file/2"><code class="inline">require_file/2</code></a> will get the list of loaded modules, others will get <code class="inline">nil</code>.</p>
<p>See <a href="#compile_file/2"><code class="inline">compile_file/2</code></a> if you would like to compile a file without tracking its filenames. Finally, if you would like to get the result of evaluating a file rather than the modules defined in it, see <a href="#eval_file/2"><code class="inline">eval_file/2</code></a>.</p>
<h4 id="require_file/2-examples" class="section-heading">  Examples </h4> <p>If the file has not been required, it returns the list of modules:</p>
<pre data-language="elixir">modules = Code.require_file("eex_test.exs", "../eex/test")
List.first(modules)
#=&gt; {EExTest.Compiled, &lt;&lt;70, 79, 82, 49, ...&gt;&gt;}</pre>
<p>If the file has been required, it returns <code class="inline">nil</code>:</p>
<pre data-language="elixir">Code.require_file("eex_test.exs", "../eex/test")
#=&gt; nil</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="required_files/0">required_files()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L199" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">required_files() :: [binary()]</pre> </div> <p>Lists all required files.</p>
<h4 id="required_files/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Code.require_file("../eex/test/eex_test.exs")
List.first(Code.required_files()) =~ "eex_test.exs"
#=&gt; true</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="string_to_quoted/2">string_to_quoted(string, opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1163" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">string_to_quoted(List.Chars.t(), keyword()) ::
  {:ok, Macro.t()} | {:error, {location :: keyword(), term(), term()}}</pre> </div> <p>Converts the given string to its quoted form.</p>
<p>Returns <code class="inline">{:ok, quoted_form}</code> if it succeeds, <code class="inline">{:error, {line, error, token}}</code> otherwise.</p>
<h4 id="string_to_quoted/2-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:file</code> - the filename to be reported in case of parsing errors. Defaults to "nofile".</p></li>
<li><p><code class="inline">:line</code> - the starting line of the string being parsed. Defaults to 1.</p></li>
<li><p><code class="inline">:column</code> - (since v1.11.0) the starting column of the string being parsed. Defaults to 1.</p></li>
<li><p><code class="inline">:columns</code> - when <code class="inline">true</code>, attach a <code class="inline">:column</code> key to the quoted metadata. Defaults to <code class="inline">false</code>.</p></li>
<li><p><code class="inline">:existing_atoms_only</code> - when <code class="inline">true</code>, raises an error when non-existing atoms are found by the tokenizer. Defaults to <code class="inline">false</code>.</p></li>
<li><p><code class="inline">:token_metadata</code> (since v1.10.0) - when <code class="inline">true</code>, includes token-related metadata in the expression AST, such as metadata for <code class="inline">do</code> and <code class="inline">end</code> tokens, for closing tokens, end of expressions, as well as delimiters for sigils. See <a href="macro#t:metadata/0"><code class="inline">Macro.metadata/0</code></a>. Defaults to <code class="inline">false</code>.</p></li>
<li><p><code class="inline">:literal_encoder</code> (since v1.10.0) - how to encode literals in the AST. It must be a function that receives two arguments, the literal and its metadata, and it must return <code class="inline">{:ok, ast :: Macro.t}</code> or <code class="inline">{:error, reason :: binary}</code>. If you return anything than the literal itself as the <code class="inline">term</code>, then the AST is no longer valid. This option may still useful for textual analysis of the source code.</p></li>
<li><p><code class="inline">:static_atoms_encoder</code> - the static atom encoder function, see "The <code class="inline">:static_atoms_encoder</code> function" section below. Note this option overrides the <code class="inline">:existing_atoms_only</code> behaviour for static atoms but <code class="inline">:existing_atoms_only</code> is still used for dynamic atoms, such as atoms with interpolations.</p></li>
<li><p><code class="inline">:warn_on_unnecessary_quotes</code> - when <code class="inline">false</code>, does not warn when atoms, keywords or calls have unnecessary quotes on them. Defaults to <code class="inline">true</code>.</p></li>
</ul>
<h4 id="string_to_quoted/2-macro-to_string-2" class="section-heading">  <a href="macro#to_string/2"><code class="inline">Macro.to_string/2</code></a> </h4> <p>The opposite of converting a string to its quoted form is <a href="macro#to_string/2"><code class="inline">Macro.to_string/2</code></a>, which converts a quoted form to a string/binary representation.</p>
<h4 id="string_to_quoted/2-the-static_atoms_encoder-function" class="section-heading">  The <code class="inline">:static_atoms_encoder</code> function </h4> <p>When <code class="inline">static_atoms_encoder: &amp;my_encoder/2</code> is passed as an argument, <code class="inline">my_encoder/2</code> is called every time the tokenizer needs to create a "static" atom. Static atoms are atoms in the AST that function as aliases, remote calls, local calls, variable names, regular atoms and keyword lists.</p>
<p>The encoder function will receive the atom name (as a binary) and a keyword list with the current file, line and column. It must return <code class="inline">{:ok, token :: term} | {:error, reason :: binary}</code>.</p>
<p>The encoder function is supposed to create an atom from the given string. To produce a valid AST, it is required to return <code class="inline">{:ok, term}</code>, where <code class="inline">term</code> is an atom. It is possible to return something other than an atom, however, in that case the AST is no longer "valid" in that it cannot be used to compile or evaluate Elixir code. A use case for this is if you want to use the Elixir parser in a user-facing situation, but you don't want to exhaust the atom table.</p>
<p>The atom encoder is not called for <em>all</em> atoms that are present in the AST. It won't be invoked for the following atoms:</p>
<ul>
<li><p>operators (<code class="inline">:+</code>, <code class="inline">:-</code>, and so on)</p></li>
<li><p>syntax keywords (<code class="inline">fn</code>, <code class="inline">do</code>, <code class="inline">else</code>, and so on)</p></li>
<li><p>atoms containing interpolation (<code class="inline">:"#{1 + 1} is two"</code>), as these atoms are constructed at runtime.</p></li>
</ul> </section> </section> <section class="detail">  <h3 class="detail-header" id="string_to_quoted!/2">string_to_quoted!(string, opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L1188" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">string_to_quoted!(List.Chars.t(), keyword()) :: Macro.t()</pre> </div> <p>Converts the given string to its quoted form.</p>
<p>It returns the ast if it succeeds, raises an exception otherwise. The exception is a <a href="tokenmissingerror"><code class="inline">TokenMissingError</code></a> in case a token is missing (usually because the expression is incomplete), <a href="syntaxerror"><code class="inline">SyntaxError</code></a> otherwise.</p>
<p>Check <a href="#string_to_quoted/2"><code class="inline">string_to_quoted/2</code></a> for options information.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="unrequire_files/1">unrequire_files(files)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/code.ex#L484" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">unrequire_files([binary()]) :: :ok</pre> </div> <p>Removes files from the required files list.</p>
<p>The modules defined in the file are not removed; calling this function only removes them from the list, allowing them to be required again.</p>
<h4 id="unrequire_files/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Require EEx test code
Code.require_file("../eex/test/eex_test.exs")

# Now unrequire all files
Code.unrequire_files(Code.required_files())

# Note that modules are still available
function_exported?(EExTest.Compiled, :before_compile, 0)
#=&gt; true</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/elixir/1.12.0/Code.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.12.0/Code.html</a>
  </p>
</div>
