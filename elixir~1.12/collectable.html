<h1> Collectable <small>protocol</small>   </h1> <section id="moduledoc"> <p>A protocol to traverse data structures.</p>
<p>The <a href="enum#into/2"><code class="inline">Enum.into/2</code></a> function uses this protocol to insert an enumerable into a collection:</p>
<pre data-language="elixir">iex&gt; Enum.into([a: 1, b: 2], %{})
%{a: 1, b: 2}</pre>
<h2 id="module-why-collectable" class="section-heading">  Why Collectable? </h2> <p>The <a href="enumerable"><code class="inline">Enumerable</code></a> protocol is useful to take values out of a collection. In order to support a wide range of values, the functions provided by the <a href="enumerable"><code class="inline">Enumerable</code></a> protocol do not keep shape. For example, passing a map to <a href="enum#map/2"><code class="inline">Enum.map/2</code></a> always returns a list.</p>
<p>This design is intentional. <a href="enumerable"><code class="inline">Enumerable</code></a> was designed to support infinite collections, resources and other structures with fixed shape. For example, it doesn't make sense to insert values into a range, as it has a fixed shape where just the range limits are stored.</p>
<p>The <a href="collectable#content"><code class="inline">Collectable</code></a> module was designed to fill the gap left by the <a href="enumerable"><code class="inline">Enumerable</code></a> protocol. <a href="#into/1"><code class="inline">Collectable.into/1</code></a> can be seen as the opposite of <a href="enumerable#reduce/3"><code class="inline">Enumerable.reduce/3</code></a>. If the functions in <a href="enumerable"><code class="inline">Enumerable</code></a> are about taking values out, then <a href="#into/1"><code class="inline">Collectable.into/1</code></a> is about collecting those values into a structure.</p>
<h2 id="module-examples" class="section-heading">  Examples </h2> <p>To show how to manually use the <a href="collectable#content"><code class="inline">Collectable</code></a> protocol, let's play with a simplified implementation for <a href="mapset"><code class="inline">MapSet</code></a>.</p>
<pre data-language="elixir">iex&gt; {initial_acc, collector_fun} = Collectable.into(MapSet.new())
iex&gt; updated_acc = Enum.reduce([1, 2, 3], initial_acc, fn elem, acc -&gt;
...&gt;   collector_fun.(acc, {:cont, elem})
...&gt; end)
iex&gt; collector_fun.(updated_acc, :done)
#MapSet&lt;[1, 2, 3]&gt;</pre>
<p>To show how the protocol can be implemented, we can again look at the simplified implementation for <a href="mapset"><code class="inline">MapSet</code></a>. In this implementation "collecting" elements simply means inserting them in the set through <a href="mapset#put/2"><code class="inline">MapSet.put/2</code></a>.</p>
<pre data-language="elixir">defimpl Collectable, for: MapSet do
  def into(map_set) do
    collector_fun = fn
      map_set_acc, {:cont, elem} -&gt;
        MapSet.put(map_set_acc, elem)

      map_set_acc, :done -&gt;
        map_set_acc

      _map_set_acc, :halt -&gt;
        :ok
    end

    initial_acc = map_set

    {initial_acc, collector_fun}
  end
end</pre>
<p>So now we can call <a href="enum#into/2"><code class="inline">Enum.into/2</code></a>:</p>
<pre data-language="elixir">iex&gt; Enum.into([1, 2, 3], MapSet.new())
#MapSet&lt;[1, 2, 3]&gt;</pre> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:command/0">command()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#into/1">into(collectable)</a> </dt> <dd class="summary-synopsis"><p>Returns an initial accumulator and a "collector" function.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:command/0">command()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/collectable.ex#L70" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">command() :: {:cont, term()} | :done | :halt</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/collectable.ex#L1" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">t() :: term()</pre> </div> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="into/1">into(collectable)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/collectable.ex#L92" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">into(t()) ::
  {initial_acc :: term(), collector :: (term(), command() -&gt; t() | term())}</pre> </div> <p>Returns an initial accumulator and a "collector" function.</p>
<p>Receives a <code class="inline">collectable</code> which can be used as the initial accumulator that will be passed to the function.</p>
<p>The collector function receives a term and a command and injects the term into the collectable accumulator on every <code class="inline">{:cont, term}</code> command.</p>
<p><code class="inline">:done</code> is passed as a command when no further values will be injected. This is useful when there's a need to close resources or normalizing values. A collectable must be returned when the command is <code class="inline">:done</code>.</p>
<p>If injection is suddenly interrupted, <code class="inline">:halt</code> is passed and the function can return any value as it won't be used.</p>
<p>For examples on how to use the <a href="collectable#content"><code class="inline">Collectable</code></a> protocol and <a href="#into/1"><code class="inline">into/1</code></a> see the module documentation.</p> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/elixir/1.12.0/Collectable.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.12.0/Collectable.html</a>
  </p>
</div>
