<h1> Keyword   </h1> <section id="moduledoc"> <p>A keyword list is a list that consists exclusively of two-element tuples.</p>
<p>The first element of these tuples is known as the <em>key</em>, and it must be an atom. The second element, known as the <em>value</em>, can be any term.</p>
<p>Keywords are mostly used to work with optional values.</p>
<h2 id="module-examples" class="section-heading">  Examples </h2> <p>For example, the following is a keyword list:</p>
<pre data-language="elixir">[{:exit_on_close, true}, {:active, :once}, {:packet_size, 1024}]</pre>
<p>Elixir provides a special and more concise syntax for keyword lists that looks like this:</p>
<pre data-language="elixir">[exit_on_close: true, active: :once, packet_size: 1024]</pre>
<p>The two syntaxes are completely equivalent. Like atoms, keyword lists keys must be composed of Unicode characters such as letters, numbers, underscore, and <code class="inline">@</code>. If the keyword has a character that does not belong to the category above, such as spaces, you can wrap it in quotes:</p>
<pre data-language="elixir">iex&gt; ["exit on close": true]
["exit on close": true]</pre>
<p>Wrapping a keyword in quotes does not make it a string. Keyword lists keys are always atoms. If you use quotes around the key when quoting is not necessary, Elixir will warn.</p>
<h2 id="module-duplicate-keys-and-ordering" class="section-heading">  Duplicate keys and ordering </h2> <p>A keyword may have duplicated keys so it is not strictly a key-value data type. However most of the functions in this module behave exactly as a key-value so they work similarly to the functions you would find in the <a href="map"><code class="inline">Map</code></a> module. For example, <a href="#get/3"><code class="inline">Keyword.get/3</code></a> will get the first entry matching the given key, regardless if duplicated entries exist. Similarly, <a href="#put/3"><code class="inline">Keyword.put/3</code></a> and <a href="#delete/2"><code class="inline">Keyword.delete/2</code></a> ensure all duplicated entries for a given key are removed when invoked. Note, however, that keyword list operations need to traverse the whole list in order to find keys, so these operations are slower than their map counterparts.</p>
<p>A handful of functions exist to handle duplicated keys, for example, <a href="#get_values/2"><code class="inline">get_values/2</code></a> returns all values for a given key and <a href="#delete_first/2"><code class="inline">delete_first/2</code></a> deletes just one of the existing entries.</p>
<p>Even though lists preserve the user ordering, the functions in <a href="keyword#content"><code class="inline">Keyword</code></a> do not guarantee any ordering. For example, if you invoke <code class="inline">Keyword.put(opts, new_key, new_value)</code>, there is no guarantee to where <code class="inline">new_key</code> will be added (to the front, to the end, or anywhere else).</p>
<p>Given ordering is not guaranteed, it is not recommended to pattern match on keyword lists either. For example, a function such as:</p>
<pre data-language="elixir">def my_function([some_key: value, another_key: another_value])</pre>
<p>will match</p>
<pre data-language="elixir">my_function([some_key: :foo, another_key: :bar])</pre>
<p>but it won't match</p>
<pre data-language="elixir">my_function([another_key: :bar, some_key: :foo])</pre>
<p>Most of the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list.</p>
<h2 id="module-call-syntax" class="section-heading">  Call syntax </h2> <p>When keyword lists are passed as the last argument to a function, the square brackets around the keyword list can be omitted. For example, the keyword list syntax:</p>
<pre data-language="elixir">String.split("1-0", "-", [trim: true, parts: 2])</pre>
<p>can be written without the enclosing brackets whenever it is the last argument of a function call:</p>
<pre data-language="elixir">String.split("1-0", "-", trim: true, parts: 2)</pre>
<p>Since tuples, lists, maps, and others are treated the same as function calls in Elixir syntax, this property is also available to them:</p>
<pre data-language="elixir">iex&gt; {1, 2, foo: :bar}
{1, 2, [{:foo, :bar}]}

iex&gt; [1, 2, foo: :bar]
[1, 2, {:foo, :bar}]

iex&gt; %{1 =&gt; 2, foo: :bar}
%{1 =&gt; 2, :foo =&gt; :bar}</pre> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:key/0">key()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/1">t(value)</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:value/0">value()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#delete/2">delete(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Deletes the entries in the keyword list for a specific <code class="inline">key</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete_first/2">delete_first(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Deletes the first entry in the keyword list for a specific <code class="inline">key</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#drop/2">drop(keywords, keys)</a> </dt> <dd class="summary-synopsis"><p>Drops the given keys from the keyword list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#equal?/2">equal?(left, right)</a> </dt> <dd class="summary-synopsis"><p>Checks if two keywords are equal.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#fetch/2">fetch(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Fetches the value for a specific <code class="inline">key</code> and returns it in a tuple.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#fetch!/2">fetch!(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Fetches the value for specific <code class="inline">key</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get/3">get(keywords, key, default \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Gets the value for a specific <code class="inline">key</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_and_update/3">get_and_update(keywords, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Gets the value from <code class="inline">key</code> and updates it, all in one pass.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_and_update!/3">get_and_update!(keywords, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Gets the value from <code class="inline">key</code> and updates it. Raises if there is no <code class="inline">key</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_lazy/3">get_lazy(keywords, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Gets the value for a specific <code class="inline">key</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_values/2">get_values(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Gets all values for a specific <code class="inline">key</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#has_key?/2">has_key?(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Returns whether a given <code class="inline">key</code> exists in the given <code class="inline">keywords</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#keys/1">keys(keywords)</a> </dt> <dd class="summary-synopsis"><p>Returns all keys from the keyword list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#keyword?/1">keyword?(term)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a keyword list; otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#merge/2">merge(keywords1, keywords2)</a> </dt> <dd class="summary-synopsis"><p>Merges two keyword lists into one.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#merge/3">merge(keywords1, keywords2, fun)</a> </dt> <dd class="summary-synopsis"><p>Merges two keyword lists into one.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#new/0">new()</a> </dt> <dd class="summary-synopsis"><p>Returns an empty keyword list, i.e. an empty list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#new/1">new(pairs)</a> </dt> <dd class="summary-synopsis"><p>Creates a keyword list from an enumerable.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#new/2">new(pairs, transform)</a> </dt> <dd class="summary-synopsis"><p>Creates a keyword list from an enumerable via the transformation function.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#pop/3">pop(keywords, key, default \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Returns the first value for <code class="inline">key</code> and removes all associated entries in the keyword list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#pop!/2">pop!(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Returns the first value for <code class="inline">key</code> and removes all associated entries in the keyword list, raising if <code class="inline">key</code> is not present.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#pop_first/3">pop_first(keywords, key, default \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Returns and removes the first value associated with <code class="inline">key</code> in the keyword list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#pop_lazy/3">pop_lazy(keywords, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Lazily returns and removes all values associated with <code class="inline">key</code> in the keyword list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#pop_values/2">pop_values(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Returns all values for <code class="inline">key</code> and removes all associated entries in the keyword list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put/3">put(keywords, key, value)</a> </dt> <dd class="summary-synopsis"><p>Puts the given <code class="inline">value</code> under <code class="inline">key</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_new/3">put_new(keywords, key, value)</a> </dt> <dd class="summary-synopsis"><p>Puts the given <code class="inline">value</code> under <code class="inline">key</code> unless the entry <code class="inline">key</code> already exists.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_new_lazy/3">put_new_lazy(keywords, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Evaluates <code class="inline">fun</code> and puts the result under <code class="inline">key</code> in keyword list unless <code class="inline">key</code> is already present.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#replace/3">replace(keywords, key, value)</a> </dt> <dd class="summary-synopsis"><p>Puts a value under <code class="inline">key</code> only if the <code class="inline">key</code> already exists in <code class="inline">keywords</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#replace!/3">replace!(keywords, key, value)</a> </dt> <dd class="summary-synopsis"><p>Puts a value under <code class="inline">key</code> only if the <code class="inline">key</code> already exists in <code class="inline">keywords</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#split/2">split(keywords, keys)</a> </dt> <dd class="summary-synopsis"><p>Takes all entries corresponding to the given keys and extracts them into a separate keyword list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#take/2">take(keywords, keys)</a> </dt> <dd class="summary-synopsis"><p>Takes all entries corresponding to the given keys and returns them in a new keyword list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_list/1">to_list(keyword)</a> </dt> <dd class="summary-synopsis"><p>Returns the keyword list itself.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#update/4">update(keywords, key, default, fun)</a> </dt> <dd class="summary-synopsis"><p>Updates the <code class="inline">key</code> in <code class="inline">keywords</code> with the given function.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#update!/3">update!(keywords, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Updates the <code class="inline">key</code> with the given function.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#values/1">values(keywords)</a> </dt> <dd class="summary-synopsis"><p>Returns all values from the keyword list.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:key/0">key()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L101" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">key() :: atom()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L104" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">t() :: [{key(), value()}]</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:t/1">t(value)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L105" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">t(value) :: [{key(), value}]</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:value/0">value()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L102" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">value() :: any()</pre> </div> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="delete/2">delete(keywords, key)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L539" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">delete(t(), key()) :: t()</pre> </div> <p>Deletes the entries in the keyword list for a specific <code class="inline">key</code>.</p>
<p>If the <code class="inline">key</code> does not exist, returns the keyword list unchanged. Use <a href="#delete_first/2"><code class="inline">delete_first/2</code></a> to delete just the first entry in case of duplicated keys.</p>
<h4 id="delete/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.delete([a: 1, b: 2], :a)
[b: 2]
iex&gt; Keyword.delete([a: 1, b: 2, a: 3], :a)
[b: 2]
iex&gt; Keyword.delete([b: 2], :a)
[b: 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="delete_first/2">delete_first(keywords, key)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L564" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">delete_first(t(), key()) :: t()</pre> </div> <p>Deletes the first entry in the keyword list for a specific <code class="inline">key</code>.</p>
<p>If the <code class="inline">key</code> does not exist, returns the keyword list unchanged.</p>
<h4 id="delete_first/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.delete_first([a: 1, b: 2, a: 3], :a)
[b: 2, a: 3]
iex&gt; Keyword.delete_first([b: 2], :a)
[b: 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="drop/2">drop(keywords, keys)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L1015" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">drop(t(), [key()]) :: t()</pre> </div> <p>Drops the given keys from the keyword list.</p>
<p>Duplicated keys are preserved in the new keyword list.</p>
<h4 id="drop/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.drop([a: 1, b: 2, c: 3], [:b, :d])
[a: 1, c: 3]
iex&gt; Keyword.drop([a: 1, b: 2, b: 3, c: 3, a: 5], [:b, :d])
[a: 1, c: 3, a: 5]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="equal?/2">equal?(left, right)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L743" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">equal?(t(), t()) :: boolean()</pre> </div> <p>Checks if two keywords are equal.</p>
<p>Two keywords are considered to be equal if they contain the same keys and those keys contain the same values.</p>
<h4 id="equal?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.equal?([a: 1, b: 2], [b: 2, a: 1])
true
iex&gt; Keyword.equal?([a: 1, b: 2], [b: 1, a: 2])
false
iex&gt; Keyword.equal?([a: 1, b: 2, a: 3], [b: 2, a: 3, a: 1])
true</pre>
<p>Comparison between values is done with <code class="inline">===/3</code>, which means integers are not equivalent to floats:</p>
<pre data-language="elixir">iex&gt; Keyword.equal?([a: 1.0], [a: 1])
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="fetch/2">fetch(keywords, key)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L396" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">fetch(t(), key()) :: {:ok, value()} | :error</pre> </div> <p>Fetches the value for a specific <code class="inline">key</code> and returns it in a tuple.</p>
<p>If the <code class="inline">key</code> does not exist, returns <code class="inline">:error</code>.</p>
<h4 id="fetch/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.fetch([a: 1], :a)
{:ok, 1}
iex&gt; Keyword.fetch([a: 1], :b)
:error</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="fetch!/2">fetch!(keywords, key)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L417" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">fetch!(t(), key()) :: value()</pre> </div> <p>Fetches the value for specific <code class="inline">key</code>.</p>
<p>If <code class="inline">key</code> does not exist, a <a href="keyerror"><code class="inline">KeyError</code></a> is raised.</p>
<h4 id="fetch!/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.fetch!([a: 1], :a)
1
iex&gt; Keyword.fetch!([a: 1], :b)
** (KeyError) key :b not found in: [a: 1]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="get/3">get(keywords, key, default \\ nil)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L218" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">get(t(), key(), value()) :: value()</pre> </div> <p>Gets the value for a specific <code class="inline">key</code>.</p>
<p>If <code class="inline">key</code> does not exist, return the default value (<code class="inline">nil</code> if no default value).</p>
<p>If duplicated entries exist, the first one is returned. Use <a href="#get_values/2"><code class="inline">get_values/2</code></a> to retrieve all entries.</p>
<h4 id="get/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.get([], :a)
nil
iex&gt; Keyword.get([a: 1], :a)
1
iex&gt; Keyword.get([a: 1], :b)
nil
iex&gt; Keyword.get([a: 1], :b, 3)
3</pre>
<p>With duplicated keys:</p>
<pre data-language="elixir">iex&gt; Keyword.get([a: 1, a: 2], :a, 3)
1
iex&gt; Keyword.get([a: 1, a: 2], :b, 3)
3</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_and_update/3">get_and_update(keywords, key, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L293" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">get_and_update(
  t(),
  key(),
  (value() | nil -&gt; {current_value, new_value :: value()} | :pop)
) :: {current_value, new_keywords :: t()}
when current_value: value()</pre> </div> <p>Gets the value from <code class="inline">key</code> and updates it, all in one pass.</p>
<p>This <code class="inline">fun</code> argument receives the value of <code class="inline">key</code> (or <code class="inline">nil</code> if <code class="inline">key</code> is not present) and must return a two-element tuple: the current value (the retrieved value, which can be operated on before being returned) and the new value to be stored under <code class="inline">key</code>. The <code class="inline">fun</code> may also return <code class="inline">:pop</code>, implying the current value shall be removed from the keyword list and returned.</p>
<p>The returned value is a tuple with the current value returned by <code class="inline">fun</code> and a new keyword list with the updated value under <code class="inline">key</code>.</p>
<h4 id="get_and_update/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.get_and_update([a: 1], :a, fn current_value -&gt;
...&gt;   {current_value, "new value!"}
...&gt; end)
{1, [a: "new value!"]}

iex&gt; Keyword.get_and_update([a: 1], :b, fn current_value -&gt;
...&gt;   {current_value, "new value!"}
...&gt; end)
{nil, [b: "new value!", a: 1]}

iex&gt; Keyword.get_and_update([a: 1], :a, fn _ -&gt; :pop end)
{1, []}

iex&gt; Keyword.get_and_update([a: 1], :b, fn _ -&gt; :pop end)
{nil, [a: 1]}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_and_update!/3">get_and_update!(keywords, key, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L357" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">get_and_update!(
  t(),
  key(),
  (value() | nil -&gt; {current_value, new_value :: value()} | :pop)
) :: {current_value, new_keywords :: t()}
when current_value: value()</pre> </div> <p>Gets the value from <code class="inline">key</code> and updates it. Raises if there is no <code class="inline">key</code>.</p>
<p>This <code class="inline">fun</code> argument receives the value of <code class="inline">key</code> and must return a two-element tuple: the current value (the retrieved value, which can be operated on before being returned) and the new value to be stored under <code class="inline">key</code>.</p>
<p>The returned value is a tuple with the current value returned by <code class="inline">fun</code> and a new keyword list with the updated value under <code class="inline">key</code>.</p>
<h4 id="get_and_update!/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.get_and_update!([a: 1], :a, fn current_value -&gt;
...&gt;   {current_value, "new value!"}
...&gt; end)
{1, [a: "new value!"]}

iex&gt; Keyword.get_and_update!([a: 1], :b, fn current_value -&gt;
...&gt;   {current_value, "new value!"}
...&gt; end)
** (KeyError) key :b not found in: [a: 1]

iex&gt; Keyword.get_and_update!([a: 1], :a, fn _ -&gt;
...&gt;   :pop
...&gt; end)
{1, []}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_lazy/3">get_lazy(keywords, key, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L250" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">get_lazy(t(), key(), (() -&gt; value())) :: value()</pre> </div> <p>Gets the value for a specific <code class="inline">key</code>.</p>
<p>If <code class="inline">key</code> does not exist, lazily evaluates <code class="inline">fun</code> and returns its result.</p>
<p>This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again.</p>
<p>If duplicated entries exist, the first one is returned. Use <a href="#get_values/2"><code class="inline">get_values/2</code></a> to retrieve all entries.</p>
<h4 id="get_lazy/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; keyword = [a: 1]
iex&gt; fun = fn -&gt;
...&gt;   # some expensive operation here
...&gt;   13
...&gt; end
iex&gt; Keyword.get_lazy(keyword, :a, fun)
1
iex&gt; Keyword.get_lazy(keyword, :b, fun)
13</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_values/2">get_values(keywords, key)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L438" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">get_values(t(), key()) :: [value()]</pre> </div> <p>Gets all values for a specific <code class="inline">key</code>.</p>
<h4 id="get_values/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.get_values([], :a)
[]
iex&gt; Keyword.get_values([a: 1], :a)
[1]
iex&gt; Keyword.get_values([a: 1, a: 2], :a)
[1, 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="has_key?/2">has_key?(keywords, key)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L869" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">has_key?(t(), key()) :: boolean()</pre> </div> <p>Returns whether a given <code class="inline">key</code> exists in the given <code class="inline">keywords</code>.</p>
<h4 id="has_key?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.has_key?([a: 1], :a)
true
iex&gt; Keyword.has_key?([a: 1], :b)
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="keys/1">keys(keywords)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L464" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">keys(t()) :: [key()]</pre> </div> <p>Returns all keys from the keyword list.</p>
<p>Duplicated keys appear duplicated in the final list of keys.</p>
<h4 id="keys/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.keys(a: 1, b: 2)
[:a, :b]

iex&gt; Keyword.keys(a: 1, b: 2, a: 3)
[:a, :b, :a]

iex&gt; Keyword.keys([{:a, 1}, {"b", 2}, {:c, 3}])
** (ArgumentError) expected a keyword list, but an entry in the list is not a two-element tuple with an atom as its first element, got: {"b", 2}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="keyword?/1">keyword?(term)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L127" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">keyword?(term()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a keyword list; otherwise returns <code class="inline">false</code>.</p>
<h4 id="keyword?/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.keyword?([])
true
iex&gt; Keyword.keyword?(a: 1)
true
iex&gt; Keyword.keyword?([{Foo, 1}])
true
iex&gt; Keyword.keyword?([{}])
false
iex&gt; Keyword.keyword?([:key])
false
iex&gt; Keyword.keyword?(%{})
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="merge/2">merge(keywords1, keywords2)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L768" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">merge(t(), t()) :: t()</pre> </div> <p>Merges two keyword lists into one.</p>
<p>All keys, including duplicated keys, given in <code class="inline">keywords2</code> will be added to <code class="inline">keywords1</code>, overriding any existing one.</p>
<p>There are no guarantees about the order of keys in the returned keyword.</p>
<h4 id="merge/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.merge([a: 1, b: 2], [a: 3, d: 4])
[b: 2, a: 3, d: 4]

iex&gt; Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5])
[b: 2, a: 3, d: 4, a: 5]

iex&gt; Keyword.merge([a: 1], [2, 3])
** (ArgumentError) expected a keyword list as the second argument, got: [2, 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="merge/3">merge(keywords1, keywords2, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L826" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">merge(t(), t(), (key(), value(), value() -&gt; value())) :: t()</pre> </div> <p>Merges two keyword lists into one.</p>
<p>All keys, including duplicated keys, given in <code class="inline">keywords2</code> will be added to <code class="inline">keywords1</code>. The given function will be invoked to solve conflicts.</p>
<p>If <code class="inline">keywords2</code> has duplicate keys, the given function will be invoked for each matching pair in <code class="inline">keywords1</code>.</p>
<p>There are no guarantees about the order of keys in the returned keyword.</p>
<h4 id="merge/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn _k, v1, v2 -&gt;
...&gt;   v1 + v2
...&gt; end)
[b: 2, a: 4, d: 4]

iex&gt; Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5], fn :a, v1, v2 -&gt;
...&gt;   v1 + v2
...&gt; end)
[b: 2, a: 4, d: 4, a: 5]

iex&gt; Keyword.merge([a: 1, b: 2, a: 3], [a: 3, d: 4, a: 5], fn :a, v1, v2 -&gt;
...&gt;   v1 + v2
...&gt; end)
[b: 2, a: 4, d: 4, a: 8]

iex&gt; Keyword.merge([a: 1, b: 2], [:a, :b], fn :a, v1, v2 -&gt;
...&gt;   v1 + v2
...&gt; end)
** (ArgumentError) expected a keyword list as the second argument, got: [:a, :b]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="new/0">new()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L143" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">new() :: []</pre> </div> <p>Returns an empty keyword list, i.e. an empty list.</p>
<h4 id="new/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.new()
[]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="new/1">new(pairs)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L162" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">new(Enum.t()) :: t()</pre> </div> <p>Creates a keyword list from an enumerable.</p>
<p>Duplicated entries are removed, the latest one prevails. Unlike <code class="inline">Enum.into(enumerable, [])</code>, <code class="inline">Keyword.new(enumerable)</code> guarantees the keys are unique.</p>
<h4 id="new/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.new([{:b, 1}, {:a, 2}])
[b: 1, a: 2]

iex&gt; Keyword.new([{:a, 1}, {:a, 2}, {:a, 3}])
[a: 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="new/2">new(pairs, transform)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L180" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">new(Enum.t(), (term() -&gt; {key(), value()})) :: t()</pre> </div> <p>Creates a keyword list from an enumerable via the transformation function.</p>
<p>Duplicated entries are removed, the latest one prevails. Unlike <code class="inline">Enum.into(enumerable, [], fun)</code>, <code class="inline">Keyword.new(enumerable, fun)</code> guarantees the keys are unique.</p>
<h4 id="new/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.new([:a, :b], fn x -&gt; {x, x} end)
[a: :a, b: :b]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="pop/3">pop(keywords, key, default \\ nil)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L1043" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">pop(t(), key(), value()) :: {value(), t()}</pre> </div> <p>Returns the first value for <code class="inline">key</code> and removes all associated entries in the keyword list.</p>
<p>It returns a tuple where the first element is the first value for <code class="inline">key</code> and the second element is a keyword list with all entries associated with <code class="inline">key</code> removed. If the <code class="inline">key</code> is not present in the keyword list, <code class="inline">{default, keyword_list}</code> is returned.</p>
<p>If you don't want to remove all the entries associated with <code class="inline">key</code> use <a href="#pop_first/3"><code class="inline">pop_first/3</code></a> instead, that function will remove only the first entry.</p>
<h4 id="pop/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.pop([a: 1], :a)
{1, []}
iex&gt; Keyword.pop([a: 1], :b)
{nil, [a: 1]}
iex&gt; Keyword.pop([a: 1], :b, 3)
{3, [a: 1]}
iex&gt; Keyword.pop([a: 1, a: 2], :a)
{1, []}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="pop!/2">pop!(keywords, key)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L1069" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">pop!(t(), key()) :: {value(), t()}</pre> </div> <p>Returns the first value for <code class="inline">key</code> and removes all associated entries in the keyword list, raising if <code class="inline">key</code> is not present.</p>
<p>This function behaves like <a href="#pop/3"><code class="inline">pop/3</code></a>, but raises in cases the <code class="inline">key</code> is not present in the given <code class="inline">keywords</code>.</p>
<h4 id="pop!/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.pop!([a: 1], :a)
{1, []}
iex&gt; Keyword.pop!([a: 1, a: 2], :a)
{1, []}
iex&gt; Keyword.pop!([a: 1], :b)
** (KeyError) key :b not found in: [a: 1]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="pop_first/3">pop_first(keywords, key, default \\ nil)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L1164" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">pop_first(t(), key(), value()) :: {value(), t()}</pre> </div> <p>Returns and removes the first value associated with <code class="inline">key</code> in the keyword list.</p>
<p>Duplicated keys are not removed.</p>
<h4 id="pop_first/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.pop_first([a: 1], :a)
{1, []}
iex&gt; Keyword.pop_first([a: 1], :b)
{nil, [a: 1]}
iex&gt; Keyword.pop_first([a: 1], :b, 3)
{3, [a: 1]}
iex&gt; Keyword.pop_first([a: 1, a: 2], :a)
{1, [a: 2]}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="pop_lazy/3">pop_lazy(keywords, key, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L1135" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">pop_lazy(t(), key(), (() -&gt; value())) :: {value(), t()}</pre> </div> <p>Lazily returns and removes all values associated with <code class="inline">key</code> in the keyword list.</p>
<p>This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again.</p>
<p>All duplicated keys are removed. See <a href="#pop_first/3"><code class="inline">pop_first/3</code></a> for removing only the first entry.</p>
<h4 id="pop_lazy/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; keyword = [a: 1]
iex&gt; fun = fn -&gt;
...&gt;   # some expensive operation here
...&gt;   13
...&gt; end
iex&gt; Keyword.pop_lazy(keyword, :a, fun)
{1, []}
iex&gt; Keyword.pop_lazy(keyword, :b, fun)
{13, [a: 1]}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="pop_values/2">pop_values(keywords, key)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L1099" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">pop_values(t(), key()) :: {[value()], t()}</pre> </div> <p>Returns all values for <code class="inline">key</code> and removes all associated entries in the keyword list.</p>
<p>It returns a tuple where the first element is a list of values for <code class="inline">key</code> and the second element is a keyword list with all entries associated with <code class="inline">key</code> removed. If the <code class="inline">key</code> is not present in the keyword list, <code class="inline">{[], keyword_list}</code> is returned.</p>
<p>If you don't want to remove all the entries associated with <code class="inline">key</code> use <a href="#pop_first/3"><code class="inline">pop_first/3</code></a> instead, that function will remove only the first entry.</p>
<h4 id="pop_values/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.pop_values([a: 1], :a)
{[1], []}
iex&gt; Keyword.pop_values([a: 1], :b)
{[], [a: 1]}
iex&gt; Keyword.pop_values([a: 1, a: 2], :a)
{[1, 2], []}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put/3">put(keywords, key, value)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L600" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">put(t(), key(), value()) :: t()</pre> </div> <p>Puts the given <code class="inline">value</code> under <code class="inline">key</code>.</p>
<p>If a previous value is already stored, all entries are removed and the value is overridden.</p>
<h4 id="put/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.put([a: 1], :b, 2)
[b: 2, a: 1]
iex&gt; Keyword.put([a: 1, b: 2], :a, 3)
[a: 3, b: 2]
iex&gt; Keyword.put([a: 1, b: 2, a: 4], :a, 3)
[a: 3, b: 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_new/3">put_new(keywords, key, value)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L646" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">put_new(t(), key(), value()) :: t()</pre> </div> <p>Puts the given <code class="inline">value</code> under <code class="inline">key</code> unless the entry <code class="inline">key</code> already exists.</p>
<h4 id="put_new/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.put_new([a: 1], :b, 2)
[b: 2, a: 1]
iex&gt; Keyword.put_new([a: 1, b: 2], :a, 3)
[a: 1, b: 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_new_lazy/3">put_new_lazy(keywords, key, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L625" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">put_new_lazy(t(), key(), (() -&gt; value())) :: t()</pre> </div> <p>Evaluates <code class="inline">fun</code> and puts the result under <code class="inline">key</code> in keyword list unless <code class="inline">key</code> is already present.</p>
<p>This is useful if the value is very expensive to calculate or generally difficult to setup and teardown again.</p>
<h4 id="put_new_lazy/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; keyword = [a: 1]
iex&gt; fun = fn -&gt;
...&gt;   # some expensive operation here
...&gt;   3
...&gt; end
iex&gt; Keyword.put_new_lazy(keyword, :a, fun)
[a: 1]
iex&gt; Keyword.put_new_lazy(keyword, :b, fun)
[b: 3, a: 1]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="replace/3">replace(keywords, key, value)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L670" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">replace(t(), key(), value()) :: t()</pre> </div> <p>Puts a value under <code class="inline">key</code> only if the <code class="inline">key</code> already exists in <code class="inline">keywords</code>.</p>
<p>In the case a value is stored multiple times in the keyword list, later occurrences are removed.</p>
<h4 id="replace/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.replace([a: 1, b: 2, a: 4], :a, 3)
[a: 3, b: 2]

iex&gt; Keyword.replace([a: 1], :b, 2)
[a: 1]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="replace!/3">replace!(keywords, key, value)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L704" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">replace!(t(), key(), value()) :: t()</pre> </div> <p>Puts a value under <code class="inline">key</code> only if the <code class="inline">key</code> already exists in <code class="inline">keywords</code>.</p>
<p>If <code class="inline">key</code> is not present in <code class="inline">keywords</code>, a <a href="keyerror"><code class="inline">KeyError</code></a> exception is raised.</p>
<h4 id="replace!/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.replace!([a: 1, b: 2, a: 3], :a, :new)
[a: :new, b: 2]
iex&gt; Keyword.replace!([a: 1, b: 2, c: 3, b: 4], :b, :new)
[a: 1, b: :new, c: 3]

iex&gt; Keyword.replace!([a: 1], :b, 2)
** (KeyError) key :b not found in: [a: 1]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="split/2">split(keywords, keys)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L969" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">split(t(), [key()]) :: {t(), t()}</pre> </div> <p>Takes all entries corresponding to the given keys and extracts them into a separate keyword list.</p>
<p>Returns a tuple with the new list and the old list with removed keys.</p>
<p>Keys for which there are no entries in the keyword list are ignored.</p>
<p>Entries with duplicated keys end up in the same keyword list.</p>
<h4 id="split/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.split([a: 1, b: 2, c: 3], [:a, :c, :e])
{[a: 1, c: 3], [b: 2]}
iex&gt; Keyword.split([a: 1, b: 2, c: 3, a: 4], [:a, :c, :e])
{[a: 1, c: 3, a: 4], [b: 2]}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="take/2">take(keywords, keys)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L997" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">take(t(), [key()]) :: t()</pre> </div> <p>Takes all entries corresponding to the given keys and returns them in a new keyword list.</p>
<p>Duplicated keys are preserved in the new keyword list.</p>
<h4 id="take/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.take([a: 1, b: 2, c: 3], [:a, :c, :e])
[a: 1, c: 3]
iex&gt; Keyword.take([a: 1, b: 2, c: 3, a: 5], [:a, :c, :e])
[a: 1, c: 3, a: 5]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_list/1">to_list(keyword)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L1181" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_list(t()) :: t()</pre> </div> <p>Returns the keyword list itself.</p>
<h4 id="to_list/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.to_list(a: 1)
[a: 1]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="update/4">update(keywords, key, default, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L933" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">update(
  t(),
  key(),
  default :: value(),
  (existing_value :: value() -&gt; new_value :: value())
) :: t()</pre> </div> <p>Updates the <code class="inline">key</code> in <code class="inline">keywords</code> with the given function.</p>
<p>If the <code class="inline">key</code> does not exist, it inserts the given <code class="inline">default</code> value.</p>
<p>If there are duplicated keys, they are all removed and only the first one is updated.</p>
<p>The default value will not be passed through the update function.</p>
<h4 id="update/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.update([a: 1], :a, 13, fn existing_value -&gt; existing_value * 2 end)
[a: 2]

iex&gt; Keyword.update([a: 1, a: 2], :a, 13, fn existing_value -&gt; existing_value * 2 end)
[a: 2]

iex&gt; Keyword.update([a: 1], :b, 11, fn existing_value -&gt; existing_value * 2 end)
[a: 1, b: 11]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="update!/3">update!(keywords, key, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L893" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">update!(t(), key(), (current_value :: value() -&gt; new_value :: value())) :: t()</pre> </div> <p>Updates the <code class="inline">key</code> with the given function.</p>
<p>If the <code class="inline">key</code> does not exist, raises <a href="keyerror"><code class="inline">KeyError</code></a>.</p>
<p>If there are duplicated keys, they are all removed and only the first one is updated.</p>
<h4 id="update!/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.update!([a: 1, b: 2, a: 3], :a, &amp;(&amp;1 * 2))
[a: 2, b: 2]
iex&gt; Keyword.update!([a: 1, b: 2, c: 3], :b, &amp;(&amp;1 * 2))
[a: 1, b: 4, c: 3]

iex&gt; Keyword.update!([a: 1], :b, &amp;(&amp;1 * 2))
** (KeyError) key :b not found in: [a: 1]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="values/1">values(keywords)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/keyword.ex#L495" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">values(t()) :: [value()]</pre> </div> <p>Returns all values from the keyword list.</p>
<p>Values from duplicated keys will be kept in the final list of values.</p>
<h4 id="values/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.values(a: 1, b: 2)
[1, 2]
iex&gt; Keyword.values(a: 1, b: 2, a: 3)
[1, 2, 3]</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/elixir/1.12.0/Keyword.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.12.0/Keyword.html</a>
  </p>
</div>
