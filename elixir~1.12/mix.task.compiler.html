<h1> Mix.Task.Compiler <small>behaviour</small>   </h1> <section id="moduledoc"> <p>This module defines the behaviour for a Mix task that does compilation.</p>
<p>A Mix compiler task can be defined by simply using <a href="mix.task.compiler#content"><code class="inline">Mix.Task.Compiler</code></a> in a module whose name starts with <code class="inline">Mix.Tasks.Compile.</code> and defining the <a href="#c:run/1"><code class="inline">run/1</code></a> function:</p>
<pre data-language="elixir">defmodule Mix.Tasks.Compile.MyLanguage do
  use Mix.Task.Compiler

  def run(_args) do
    :ok
  end
end</pre>
<p>The <a href="#c:run/1"><code class="inline">run/1</code></a> function returns an atom indicating the status of the compilation, and optionally can also return a list of "diagnostics" such as warnings or compilation errors. Doing this enables code editors to display issues inline without having to analyze the command-line output.</p>
<p>If the compiler uses manifest files to track stale sources, it should define <code class="inline">manifests/0</code>, and if it writes any output to disk it should also define <code class="inline">clean/0</code>.</p>
<p>A compiler supports the same attributes for configuration and documentation as a regular Mix task. See <a href="mix.task"><code class="inline">Mix.Task</code></a> for more information.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:status/0">status()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#after_compiler/2">after_compiler(name, fun)</a> </dt> <dd class="summary-synopsis"><p>Adds a callback that runs after a given compiler.</p></dd> </div> </dl> <h2> Callbacks </h2>
<dl class="summary-callbacks summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#c:clean/0">clean()</a> </dt> <dd class="summary-synopsis"><p>Removes build artifacts and manifests.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:manifests/0">manifests()</a> </dt> <dd class="summary-synopsis"><p>Lists manifest files for the compiler.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:run/1">run(list)</a> </dt> <dd class="summary-synopsis"><p>Receives command-line arguments and performs compilation. If it produces errors, warnings, or any other diagnostic information, it should return a tuple with the status and a list of diagnostics.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:status/0">status()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/task.compiler.ex#L81" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">status() :: :ok | :noop | :error</pre> </div> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="after_compiler/2">after_compiler(name, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/task.compiler.ex#L112" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">after_compiler(
  atom(),
  ({status(), [Mix.Task.Compiler.Diagnostic.t()]} -&gt;
     {status(), [Mix.Task.Compiler.Diagnostic.t()]})
) :: :ok</pre> </div> <p>Adds a callback that runs after a given compiler.</p>
<p>The callback is invoked after the compiler runs and it receives a tuple with current status and the list of diagnostic. It must return the updated status and diagnostics.</p> </section> </section> </div> </section> <section id="callbacks" class="details-list"> <h1 class="section-heading">  Callbacks </h1> <div class="callbacks-list"> <section class="detail"> <h3 class="detail-header" id="c:clean/0">clean()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/task.compiler.ex#L98" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">clean() :: any()</pre> </div> <p>Removes build artifacts and manifests.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:manifests/0">manifests()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/task.compiler.ex#L93" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">manifests() :: [Path.t()]</pre> </div> <p>Lists manifest files for the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:run/1">run(list)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/mix/lib/mix/task.compiler.ex#L88" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">run([binary()]) :: status() | {status(), [Mix.Task.Compiler.Diagnostic.t()]}</pre> </div> <p>Receives command-line arguments and performs compilation. If it produces errors, warnings, or any other diagnostic information, it should return a tuple with the status and a list of diagnostics.</p> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/mix/1.12.0/Mix.Task.Compiler.html" class="_attribution-link" target="_blank">https://hexdocs.pm/mix/1.12.0/Mix.Task.Compiler.html</a>
  </p>
</div>
