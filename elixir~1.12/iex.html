<h1> IEx   </h1> <section id="moduledoc"> <p>Elixir's interactive shell.</p>
<p>Some of the functionalities described here will not be available depending on your terminal. In particular, if you get a message saying that the smart terminal could not be run, some of the features described here won't work.</p>
<h2 id="module-helpers" class="section-heading">  Helpers </h2> <p>IEx provides a bunch of helpers. They can be accessed by typing <code class="inline">h()</code> into the shell or as a documentation for the <a href="iex.helpers"><code class="inline">IEx.Helpers</code></a> module.</p>
<h2 id="module-autocomplete" class="section-heading">  Autocomplete </h2> <p>To discover a module's public functions or other modules, type the module name followed by a dot, then press tab to trigger autocomplete. For example:</p>
<pre data-language="elixir">Enum.</pre>
<p>A module may export functions that are not meant to be used directly: these functions won't be autocompleted by IEx. IEx will not autocomplete functions annotated with <code class="inline">@doc false</code>, <code class="inline">@impl true</code>, or functions that aren't explicitly documented and where the function name is in the form of <code class="inline">__foo__</code>.</p>
<p>Autocomplete may not be available on some Windows shells. You may need to pass the <code class="inline">--werl</code> option when starting IEx, as in <code class="inline">iex --werl</code> for it to work. <code class="inline">--werl</code> may be permanently enabled by setting the <code class="inline">IEX_WITH_WERL</code> environment variable.</p>
<h2 id="module-coloring" class="section-heading">  Coloring </h2> <p>Coloring is enabled by default on most Unix terminals. They are also available on Windows consoles from Windows 10, although it must be explicitly enabled for the current user in the registry by running the following command:</p>
<pre data-language="elixir">reg add HKCU\Console /v VirtualTerminalLevel /t REG_DWORD /d 1</pre>
<p>After running the command above, you must restart your current console.</p>
<h2 id="module-shell-history" class="section-heading">  Shell history </h2> <p>It is possible to get shell history by passing some options that enable it in the VM. This can be done on a per-need basis when starting IEx:</p>
<pre data-language="elixir">iex --erl "-kernel shell_history enabled"</pre>
<p>If you would rather enable it on your system as a whole, you can use the <code class="inline">ERL_AFLAGS</code> environment variable and make sure that it is set accordingly on your terminal/shell configuration.</p>
<p>On Unix-like / Bash:</p>
<pre data-language="elixir">export ERL_AFLAGS="-kernel shell_history enabled"</pre>
<p>On Windows:</p>
<pre data-language="elixir">set ERL_AFLAGS "-kernel shell_history enabled"</pre>
<p>On Windows 10 / PowerShell:</p>
<pre data-language="elixir">$env:ERL_AFLAGS = "-kernel shell_history enabled"</pre>
<h2 id="module-expressions-in-iex" class="section-heading">  Expressions in IEx </h2> <p>As an interactive shell, IEx evaluates expressions. This has some interesting consequences that are worth discussing.</p>
<p>The first one is that the code is truly evaluated and not compiled. This means that any benchmarking done in the shell is going to have skewed results. So never run any profiling nor benchmarks in the shell.</p>
<p>Second, IEx allows you to break an expression into many lines, since this is common in Elixir. For example:</p>
<pre data-language="elixir">iex(1)&gt; "ab
...(1)&gt; c"
"ab\nc"</pre>
<p>In the example above, the shell will be expecting more input until it finds the closing quote. Sometimes it is not obvious which character the shell is expecting, and the user may find themselves trapped in the state of incomplete expression with no ability to terminate it other than by exiting the shell.</p>
<p>For such cases, there is a special break-trigger (<code class="inline">#iex:break</code>) that when encountered on a line by itself will force the shell to break out of any pending expression and return to its normal state:</p>
<pre data-language="elixir">iex(1)&gt; ["ab
...(1)&gt; c"
...(1)&gt; "
...(1)&gt; ]
...(1)&gt; #iex:break
** (TokenMissingError) iex:1: incomplete expression</pre>
<h2 id="module-pasting-multiline-expressions-into-iex" class="section-heading">  Pasting multiline expressions into IEx </h2> <p>IEx evaluates its input line by line in an eager fashion. If at the end of a line the code seen so far is a complete expression, IEx will evaluate it at that point.</p>
<pre data-language="elixir">iex(1)&gt; [1, [2], 3]
[1, [2], 3]</pre>
<p>To prevent this behaviour breaking valid code where the subsequent line begins with a binary operator, such as <a href="https://hexdocs.pm/elixir/1.12/Kernel.html#%7C%3E/2"><code class="inline">|&gt;/2</code></a> or <a href="https://hexdocs.pm/elixir/1.12/Kernel.html#++/2"><code class="inline">++/2</code></a> , IEx automatically treats such lines as if they were prepended with <a href="iex.helpers#v/0"><code class="inline">IEx.Helpers.v/0</code></a>, which returns the value of the previous expression, if available.</p>
<pre data-language="elixir">iex(1)&gt; [1, [2], 3]
[1, [2], 3]
iex(2)&gt; |&gt; List.flatten()
[1, 2, 3]</pre>
<p>The above is equivalent to:</p>
<pre data-language="elixir">iex(1)&gt; [1, [2], 3]
[1, [2], 3]
iex(2)&gt; v() |&gt; List.flatten()
[1, 2, 3]</pre>
<p>If there are no previous expressions in the history, the pipe operator will fail:</p>
<pre data-language="elixir">iex(1)&gt; |&gt; List.flatten()
** (RuntimeError) v(-1) is out of bounds</pre>
<p>Note however the above does not work for <a href="https://hexdocs.pm/elixir/1.12/Kernel.html#+/2"><code class="inline">+/2</code></a> and <a href="https://hexdocs.pm/elixir/1.12/Kernel.html#-/2"><code class="inline">-/2</code></a>, as they are ambiguous with the unary <a href="https://hexdocs.pm/elixir/1.12/Kernel.html#+/1"><code class="inline">+/1</code></a> and <a href="https://hexdocs.pm/elixir/1.12/Kernel.html#-/1"><code class="inline">-/1</code></a>:</p>
<pre data-language="elixir">iex(1)&gt; 1
1
iex(2)&gt; + 2
2</pre>
<h2 id="module-the-break-menu" class="section-heading">  The BREAK menu </h2> <p>Inside IEx, hitting <code class="inline">Ctrl+C</code> will open up the <code class="inline">BREAK</code> menu. In this menu you can quit the shell, see process and ETS tables information and much more.</p>
<h2 id="module-exiting-the-shell" class="section-heading">  Exiting the shell </h2> <p>There are a few ways to quit the IEx shell:</p>
<ul>
<li>via the <code class="inline">BREAK</code> menu (available via <code class="inline">Ctrl+C</code>) by typing <code class="inline">q</code>, pressing enter</li>
<li>by hitting <code class="inline">Ctrl+C</code>, <code class="inline">Ctrl+C</code>
</li>
<li>by hitting <code class="inline">Ctrl+\</code>
</li>
</ul>
<p>If you are connected to remote shell, it remains alive after disconnection.</p>
<h2 id="module-prying-and-breakpoints" class="section-heading">  Prying and breakpoints </h2> <p>IEx also has the ability to set breakpoints on Elixir code and "pry" into running processes. This allows the developer to have an IEx session run inside a given function.</p>
<p><a href="#pry/0"><code class="inline">IEx.pry/0</code></a> can be used when you are able to modify the source code directly and recompile it:</p>
<pre data-language="elixir">def my_fun(arg1, arg2) do
  require IEx; IEx.pry()
  ... implementation ...
end</pre>
<p>When the code is executed, it will ask you for permission to be introspected.</p>
<p>Alternatively, you can use <a href="#break!/4"><code class="inline">IEx.break!/4</code></a> to setup a breakpoint on a given module, function and arity you have no control of. While <a href="#break!/4"><code class="inline">IEx.break!/4</code></a> is more flexible, it does not contain information about imports and aliases from the source code.</p>
<h2 id="module-the-user-switch-command" class="section-heading">  The User switch command </h2> <p>Besides the <code class="inline">BREAK</code> menu, one can type <code class="inline">Ctrl+G</code> to get to the <code class="inline">User switch command</code> menu. When reached, you can type <code class="inline">h</code> to get more information.</p>
<p>In this menu, developers are able to start new shells and alternate between them. Let's give it a try:</p>
<pre data-language="elixir">User switch command
 --&gt; s 'Elixir.IEx'
 --&gt; c</pre>
<p>The command above will start a new shell and connect to it. Create a new variable called <code class="inline">hello</code> and assign some value to it:</p>
<pre data-language="elixir">hello = :world</pre>
<p>Now, let's roll back to the first shell:</p>
<pre data-language="elixir">User switch command
 --&gt; c 1</pre>
<p>Now, try to access the <code class="inline">hello</code> variable again:</p>
<pre data-language="elixir">hello
** (UndefinedFunctionError) undefined function hello/0</pre>
<p>The command above fails because we have switched shells. Since shells are isolated from each other, you can't access the variables defined in one shell from the other one.</p>
<p>The <code class="inline">User switch command</code> can also be used to terminate an existing session, for example when the evaluator gets stuck in an infinite loop or when you are stuck typing an expression:</p>
<pre data-language="elixir">User switch command
 --&gt; i
 --&gt; c</pre>
<p>The <code class="inline">User switch command</code> menu also allows developers to connect to remote shells using the <code class="inline">r</code> command. A topic which we will discuss next.</p>
<h2 id="module-remote-shells" class="section-heading">  Remote shells </h2> <p>IEx allows you to connect to another node in two fashions. First of all, we can only connect to a shell if we give names both to the current shell and the shell we want to connect to.</p>
<p>Let's give it a try. First, start a new shell:</p>
<pre data-language="elixir">$ iex --sname foo
iex(foo@HOST)1&gt;</pre>
<p>The string between the parentheses in the prompt is the name of your node. We can retrieve it by calling the <a href="https://hexdocs.pm/elixir/1.12/Kernel.html#node/0"><code class="inline">node/0</code></a> function:</p>
<pre data-language="elixir">iex(foo@HOST)1&gt; node()
:"foo@HOST"
iex(foo@HOST)2&gt; Node.alive?()
true</pre>
<p>For fun, let's define a simple module in this shell too:</p>
<pre data-language="elixir">iex(foo@HOST)3&gt; defmodule Hello do
...(foo@HOST)3&gt;   def world, do: "it works!"
...(foo@HOST)3&gt; end</pre>
<p>Now, let's start another shell, giving it a name as well:</p>
<pre data-language="elixir">$ iex --sname bar
iex(bar@HOST)1&gt;</pre>
<p>If we try to dispatch to <code class="inline">Hello.world</code>, it won't be available as it was defined only in the other shell:</p>
<pre data-language="elixir">iex(bar@HOST)1&gt; Hello.world()
** (UndefinedFunctionError) undefined function Hello.world/0</pre>
<p>However, we can connect to the other shell remotely. Open up the <code class="inline">User switch command</code> prompt (Ctrl+G) and type:</p>
<pre data-language="elixir">User switch command
 --&gt; r 'foo@HOST' 'Elixir.IEx'
 --&gt; c</pre>
<p>Now we are connected into the remote node, as the prompt shows us, and we can access the information and modules defined over there:</p>
<pre data-language="elixir">iex(foo@HOST)1&gt; Hello.world()
"it works!"</pre>
<p>In fact, connecting to remote shells is so common that we provide a shortcut via the command line as well:</p>
<pre data-language="elixir">$ iex --sname baz --remsh foo@HOST</pre>
<p>Where "remsh" means "remote shell". In general, Elixir supports:</p>
<ul>
<li>remsh from an Elixir node to an Elixir node</li>
<li>remsh from a plain Erlang node to an Elixir node (through the ^G menu)</li>
<li>remsh from an Elixir node to a plain Erlang node (and get an <code class="inline">erl</code> shell there)</li>
</ul>
<p>Connecting an Elixir shell to a remote node without Elixir is <strong>not</strong> supported.</p>
<h2 id="module-the-iex-exs-file" class="section-heading">  The .iex.exs file </h2> <p>When starting, IEx looks for a local <code class="inline">.iex.exs</code> file (located in the current working directory), then a global one (located at <code class="inline">~/.iex.exs</code>) and loads the first one it finds (if any). Note the location of the <code class="inline">.iex.exs</code> files, both in the current directory and the global one, are taken relative to the user that started the application, not to the user that is connecting to the node in case of remote IEx connections.</p>
<p>The code in the loaded <code class="inline">.iex.exs</code> file is evaluated in the shell's context. For instance, any modules that are loaded or variables that are bound in the <code class="inline">.iex.exs</code> file will be available in the shell after it has booted.</p>
<p>Take the following <code class="inline">.iex.exs</code> file:</p>
<pre data-language="elixir"># Load another ".iex.exs" file
import_file("~/.iex.exs")

# Import some module from lib that may not yet have been defined
import_if_available(MyApp.Mod)

# Print something before the shell starts
IO.puts("hello world")

# Bind a variable that'll be accessible in the shell
value = 13</pre>
<p>Running IEx in the directory where the above <code class="inline">.iex.exs</code> file is located results in:</p>
<pre data-language="elixir">$ iex
Erlang/OTP 22 [...]

hello world
Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&gt; value
13</pre>
<p>It is possible to load another file by supplying the <code class="inline">--dot-iex</code> option to IEx. See <code class="inline">iex --help</code>.</p>
<h2 id="module-configuring-the-shell" class="section-heading">  Configuring the shell </h2> <p>There are a number of customization options provided by IEx. Take a look at the docs for the <a href="#configure/1"><code class="inline">IEx.configure/1</code></a> function by typing <code class="inline">h IEx.configure/1</code>.</p>
<p>Those options can be configured in your project configuration file or globally by calling <a href="#configure/1"><code class="inline">IEx.configure/1</code></a> from your <code class="inline">~/.iex.exs</code> file. For example:</p>
<pre data-language="elixir"># .iex.exs
IEx.configure(inspect: [limit: 3])</pre>
<p>Now run the shell:</p>
<pre data-language="elixir">$ iex
Erlang/OTP 22 [...]

Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&gt; [1, 2, 3, 4, 5]
[1, 2, 3, ...]</pre> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#after_spawn/0">after_spawn()</a> </dt> <dd class="summary-synopsis"><p>Returns registered <code class="inline">after_spawn</code> callbacks.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#after_spawn/1">after_spawn(fun)</a> </dt> <dd class="summary-synopsis"><p>Registers a function to be invoked after the IEx process is spawned.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#break!/2">break!(ast, stops \\ 1)</a> </dt> <dd class="summary-synopsis"><p>Macro-based shortcut for <a href="#break!/4"><code class="inline">IEx.break!/4</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#break!/4">break!(module, function, arity, stops \\ 1)</a> </dt> <dd class="summary-synopsis"><p>Sets up a breakpoint in <code class="inline">module</code>, <code class="inline">function</code> and <code class="inline">arity</code> with the given number of <code class="inline">stops</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#color/2">color(color, string)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">string</code> escaped using the specified <code class="inline">color</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#configuration/0">configuration()</a> </dt> <dd class="summary-synopsis"><p>Returns IEx configuration.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#configure/1">configure(options)</a> </dt> <dd class="summary-synopsis"><p>Configures IEx.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#inspect_opts/0">inspect_opts()</a> </dt> <dd class="summary-synopsis"><p>Returns the options used for inspecting.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#pry/0">pry()</a> </dt> <dd class="summary-synopsis"><p>Pries into the process environment.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#started?/0">started?()</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if IEx was started, <code class="inline">false</code> otherwise.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#width/0">width()</a> </dt> <dd class="summary-synopsis"><p>Returns the IEx width for printing.</p></dd> </div> </dl> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="after_spawn/0">after_spawn()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/iex/lib/iex.ex#L495" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">after_spawn() :: [(... -&gt; any())]</pre> </div> <p>Returns registered <code class="inline">after_spawn</code> callbacks.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="after_spawn/1">after_spawn(fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/iex/lib/iex.ex#L487" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">after_spawn((... -&gt; any())) :: :ok</pre> </div> <p>Registers a function to be invoked after the IEx process is spawned.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="break!/2">break!(ast, stops \\ 1)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/iex/lib/iex.ex#L642" class="source">Source</a>
</h3> <section class="docstring"> <p>Macro-based shortcut for <a href="#break!/4"><code class="inline">IEx.break!/4</code></a>.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="break!/4">break!(module, function, arity, stops \\ 1)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/iex/lib/iex.ex#L808" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">break!(module(), atom(), arity(), non_neg_integer()) :: IEx.Pry.id()</pre> </div> <p>Sets up a breakpoint in <code class="inline">module</code>, <code class="inline">function</code> and <code class="inline">arity</code> with the given number of <code class="inline">stops</code>.</p>
<p>This function will instrument the given module and load a new version in memory with breakpoints at the given function and arity. If the module is recompiled, all breakpoints are lost.</p>
<p>When a breakpoint is reached, IEx will ask if you want to <code class="inline">pry</code> the given function and arity. In other words, this works similar to <a href="#pry/0"><code class="inline">IEx.pry/0</code></a> as the running process becomes the evaluator of IEx commands and is temporarily changed to have a custom group leader. However, differently from <a href="#pry/0"><code class="inline">IEx.pry/0</code></a>, aliases and imports from the source code won't be available in the shell.</p>
<p>IEx helpers includes many conveniences related to breakpoints. Below they are listed with the full module, such as <a href="iex.helpers#breaks/0"><code class="inline">IEx.Helpers.breaks/0</code></a>, but remember it can be called directly as <code class="inline">breaks()</code> inside IEx. They are:</p>
<ul>
<li>
<a href="iex.helpers#break!/2"><code class="inline">IEx.Helpers.break!/2</code></a> - sets up a breakpoint for a given <code class="inline">Mod.fun/arity</code>
</li>
<li>
<a href="iex.helpers#break!/4"><code class="inline">IEx.Helpers.break!/4</code></a> - sets up a breakpoint for the given module, function, arity</li>
<li>
<a href="iex.helpers#breaks/0"><code class="inline">IEx.Helpers.breaks/0</code></a> - prints all breakpoints and their IDs</li>
<li>
<a href="iex.helpers#continue/0"><code class="inline">IEx.Helpers.continue/0</code></a> - continues until the next breakpoint in the same shell</li>
<li>
<a href="iex.helpers#open/0"><code class="inline">IEx.Helpers.open/0</code></a> - opens editor on the current breakpoint</li>
<li>
<a href="iex.helpers#remove_breaks/0"><code class="inline">IEx.Helpers.remove_breaks/0</code></a> - removes all breakpoints in all modules</li>
<li>
<a href="iex.helpers#remove_breaks/1"><code class="inline">IEx.Helpers.remove_breaks/1</code></a> - removes all breakpoints in a given module</li>
<li>
<a href="iex.helpers#reset_break/1"><code class="inline">IEx.Helpers.reset_break/1</code></a> - sets the number of stops on the given ID to zero</li>
<li>
<a href="iex.helpers#reset_break/3"><code class="inline">IEx.Helpers.reset_break/3</code></a> - sets the number of stops on the given module, function, arity to zero</li>
<li>
<a href="iex.helpers#respawn/0"><code class="inline">IEx.Helpers.respawn/0</code></a> - starts a new shell (breakpoints will ask for permission once more)</li>
<li>
<a href="iex.helpers#whereami/1"><code class="inline">IEx.Helpers.whereami/1</code></a> - shows the current location</li>
</ul>
<p>By default, the number of stops in a breakpoint is 1. Any follow-up call won't stop the code execution unless another breakpoint is set.</p>
<p>Alternatively, the number of stops can be increased by passing the <code class="inline">stops</code> argument. <a href="iex.helpers#reset_break/1"><code class="inline">IEx.Helpers.reset_break/1</code></a> and <a href="iex.helpers#reset_break/3"><code class="inline">IEx.Helpers.reset_break/3</code></a> can be used to reset the number back to zero. Note the module remains "instrumented" even after all stops on all breakpoints are consumed. You can remove the instrumentation in a given module by calling <a href="iex.helpers#remove_breaks/1"><code class="inline">IEx.Helpers.remove_breaks/1</code></a> and on all modules by calling <a href="iex.helpers#remove_breaks/0"><code class="inline">IEx.Helpers.remove_breaks/0</code></a>.</p>
<p>To exit a breakpoint, the developer can either invoke <code class="inline">continue()</code>, which will block the shell until the next breakpoint is found or the process terminates, or invoke <code class="inline">respawn()</code>, which starts a new IEx shell, freeing up the pried one.</p>
<h4 id="break!/4-examples" class="section-heading">  Examples </h4> <p>The examples below will use <code class="inline">break!</code>, assuming that you are setting a breakpoint directly from your IEx shell. But you can set up a break from anywhere by using the fully qualified name <code class="inline">IEx.break!</code>.</p>
<p>The following sets up a breakpoint on <a href="https://hexdocs.pm/elixir/1.12/URI.html#decode_query/2"><code class="inline">URI.decode_query/2</code></a>:</p>
<pre data-language="elixir">break! URI, :decode_query, 2</pre>
<p>This call will setup a breakpoint that stops once. To set a breakpoint that will stop 10 times:</p>
<pre data-language="elixir">break! URI, :decode_query, 2, 10</pre>
<p><a href="#break!/2"><code class="inline">IEx.break!/2</code></a> is a convenience macro that allows breakpoints to be given in the <code class="inline">Mod.fun/arity</code> format:</p>
<pre data-language="elixir">break! URI.decode_query/2</pre>
<p>Or to set a breakpoint that will stop 10 times:</p>
<pre data-language="elixir">break! URI.decode_query/2, 10</pre>
<p>This function returns the breakpoint ID and will raise if there is an error setting up the breakpoint.</p>
<h4 id="break!/4-patterns-and-guards" class="section-heading">  Patterns and guards </h4> <p><a href="#break!/2"><code class="inline">IEx.break!/2</code></a> allows patterns to be given, triggering the breakpoint only in some occasions. For example, to trigger the breakpoint only when the first argument is the "foo=bar" string:</p>
<pre data-language="elixir">break! URI.decode_query("foo=bar", _)</pre>
<p>Or to trigger it whenever the second argument is a map with more than one element:</p>
<pre data-language="elixir">break! URI.decode_query(_, map) when map_size(map) &gt; 0</pre>
<p>Only a single break point can be set per function. So if you call <code class="inline">IEx.break!</code> multiple times with different patterns, only the last pattern is kept.</p>
<p>Note that, while patterns may be given to macros, remember that macros receive ASTs as arguments, and not values. For example, if you try to break on a macro with the following pattern:</p>
<pre data-language="elixir">break! MyModule.some_macro(pid) when pid == self()</pre>
<p>This breakpoint will never be reached, because a macro never receives a PID. Even if you call the macro as <code class="inline">MyModule.some_macro(self())</code>, the macro will receive the AST representing the <code class="inline">self()</code> call, and not the PID itself.</p>
<h4 id="break!/4-breaks-and-mix-test" class="section-heading">  Breaks and <a href="https://hexdocs.pm/mix/1.12/Mix.Tasks.Test.html"><code class="inline">mix test</code></a> </h4> <p>To use <a href="#break!/4"><code class="inline">IEx.break!/4</code></a> during tests, you need to run <code class="inline">mix</code> inside the <code class="inline">iex</code> command and pass the <code class="inline">--trace</code> to <a href="https://hexdocs.pm/mix/1.12/Mix.Tasks.Test.html"><code class="inline">mix test</code></a> to avoid running into timeouts:</p>
<pre data-language="elixir">iex -S mix test --trace
iex -S mix test path/to/file:line --trace</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="color/2">color(color, string)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/iex/lib/iex.ex#L513" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">color(atom(), iodata()) :: iodata()</pre> </div> <p>Returns <code class="inline">string</code> escaped using the specified <code class="inline">color</code>.</p>
<p>ANSI escapes in <code class="inline">string</code> are not processed in any way.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="configuration/0">configuration()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/iex/lib/iex.ex#L479" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">configuration() :: keyword()</pre> </div> <p>Returns IEx configuration.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="configure/1">configure(options)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/iex/lib/iex.ex#L471" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">configure(keyword()) :: :ok</pre> </div> <p>Configures IEx.</p>
<p>The supported options are:</p>
<ul>
<li><code class="inline">:colors</code></li>
<li><code class="inline">:inspect</code></li>
<li><code class="inline">:width</code></li>
<li><code class="inline">:history_size</code></li>
<li><code class="inline">:default_prompt</code></li>
<li><code class="inline">:continuation_prompt</code></li>
<li><code class="inline">:alive_prompt</code></li>
<li><code class="inline">:alive_continuation_prompt</code></li>
<li><code class="inline">:parser</code></li>
</ul>
<p>They are discussed individually in the sections below.</p>
<h4 id="configure/1-colors" class="section-heading">  Colors </h4> <p>A keyword list that encapsulates all color settings used by the shell. See documentation for the <a href="https://hexdocs.pm/elixir/1.12/IO.ANSI.html"><code class="inline">IO.ANSI</code></a> module for the list of supported colors and attributes.</p>
<p>List of supported keys in the keyword list:</p>
<ul>
<li>
<code class="inline">:enabled</code> - boolean value that allows for switching the coloring on and off</li>
<li>
<code class="inline">:eval_result</code> - color for an expression's resulting value</li>
<li>
<code class="inline">:eval_info</code> - ... various informational messages</li>
<li>
<code class="inline">:eval_error</code> - ... error messages</li>
<li>
<code class="inline">:eval_interrupt</code> - ... interrupt messages</li>
<li>
<code class="inline">:stack_info</code> - ... the stacktrace color</li>
<li>
<code class="inline">:blame_diff</code> - ... when blaming source with no match</li>
<li>
<code class="inline">:ls_directory</code> - ... for directory entries (ls helper)</li>
<li>
<code class="inline">:ls_device</code> - ... device entries (ls helper)</li>
</ul>
<p>When printing documentation, IEx will convert the Markdown documentation to ANSI as well. Colors for this can be configured via:</p>
<ul>
<li>
<code class="inline">:doc_code</code> - the attributes for code blocks (cyan, bright)</li>
<li>
<code class="inline">:doc_inline_code</code> - inline code (cyan)</li>
<li>
<code class="inline">:doc_headings</code> - h1 and h2 (yellow, bright)</li>
<li>
<code class="inline">:doc_title</code> - the overall heading for the output (reverse, yellow, bright)</li>
<li>
<code class="inline">:doc_bold</code> - (bright)</li>
<li>
<code class="inline">:doc_underline</code> - (underline)</li>
</ul>
<p>IEx will also color inspected expressions using the <code class="inline">:syntax_colors</code> option. Such can be disabled with:</p>
<pre data-language="elixir">IEx.configure(colors: [syntax_colors: false])</pre>
<p>You can also configure the syntax colors, however, as desired:</p>
<pre data-language="elixir">IEx.configure(colors: [syntax_colors: [atom: :red]])</pre>
<p>Configuration for most built-in data types are supported: <code class="inline">:atom</code>, <code class="inline">:string</code>, <code class="inline">:binary</code>, <code class="inline">:list</code>, <code class="inline">:number</code>, <code class="inline">:boolean</code>, <code class="inline">:nil</code>, and others. The default is:</p>
<pre data-language="elixir">[number: :magenta, atom: :cyan, string: :green,
 boolean: :magenta, nil: :magenta]</pre>
<h4 id="configure/1-inspect" class="section-heading">  Inspect </h4> <p>A keyword list containing inspect options used by the shell when printing results of expression evaluation. Default to pretty formatting with a limit of 50 entries.</p>
<p>To show all entries, configure the limit to <code class="inline">:infinity</code>:</p>
<pre data-language="elixir">IEx.configure(inspect: [limit: :infinity])</pre>
<p>See <a href="https://hexdocs.pm/elixir/1.12/Inspect.Opts.html"><code class="inline">Inspect.Opts</code></a> for the full list of options.</p>
<h4 id="configure/1-width" class="section-heading">  Width </h4> <p>An integer indicating the maximum number of columns to use in output. The default value is 80 columns. The actual output width is the minimum of this number and result of <code class="inline">:io.columns</code>. This way you can configure IEx to be your largest screen size and it should always take up the full width of your current terminal screen.</p>
<h4 id="configure/1-history-size" class="section-heading">  History size </h4> <p>Number of expressions and their results to keep in the history. The value is an integer. When it is negative, the history is unlimited.</p>
<h4 id="configure/1-prompt" class="section-heading">  Prompt </h4> <p>This is an option determining the prompt displayed to the user when awaiting input.</p>
<p>The value is a keyword list with two possible keys representing prompt types:</p>
<ul>
<li><p><code class="inline">:default_prompt</code> - used when <a href="https://hexdocs.pm/elixir/1.12/Node.html#alive?/0"><code class="inline">Node.alive?/0</code></a> returns <code class="inline">false</code></p></li>
<li><p><code class="inline">:continuation_prompt</code> - used when <a href="https://hexdocs.pm/elixir/1.12/Node.html#alive?/0"><code class="inline">Node.alive?/0</code></a> returns <code class="inline">false</code> and more input is expected</p></li>
<li><p><code class="inline">:alive_prompt</code> - used when <a href="https://hexdocs.pm/elixir/1.12/Node.html#alive?/0"><code class="inline">Node.alive?/0</code></a> returns <code class="inline">true</code></p></li>
<li><p><code class="inline">:alive_continuation_prompt</code> - used when <a href="https://hexdocs.pm/elixir/1.12/Node.html#alive?/0"><code class="inline">Node.alive?/0</code></a> returns <code class="inline">true</code> and more input is expected</p></li>
</ul>
<p>The following values in the prompt string will be replaced appropriately:</p>
<ul>
<li>
<code class="inline">%counter</code> - the index of the history</li>
<li>
<code class="inline">%prefix</code> - a prefix given by <a href="iex.server"><code class="inline">IEx.Server</code></a>
</li>
<li>
<code class="inline">%node</code> - the name of the local node</li>
</ul>
<h4 id="configure/1-parser" class="section-heading">  Parser </h4> <p>This is an option determining the parser to use for IEx.</p>
<p>The parser is a "mfargs", which is a tuple with three elements: the module name, the function name, and extra arguments to be appended. The parser receives at least three arguments, the current input as a string, the parsing options as a keyword list, and the buffer as a string. It must return <code class="inline">{:ok, expr, buffer}</code> or <code class="inline">{:incomplete, buffer}</code>.</p>
<p>If the parser raises, the buffer is reset to an empty string.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="inspect_opts/0">inspect_opts()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/iex/lib/iex.ex#L537" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">inspect_opts() :: keyword()</pre> </div> <p>Returns the options used for inspecting.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="pry/0">pry()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/iex/lib/iex.ex#L632" class="source">Source</a>
</h3> <section class="docstring"> <p>Pries into the process environment.</p>
<p>This is useful for debugging a particular chunk of code when executed by a particular process. The process becomes the evaluator of IEx commands and is temporarily changed to have a custom group leader. Those values are reverted by calling <a href="iex.helpers#respawn/0"><code class="inline">IEx.Helpers.respawn/0</code></a>, which starts a new IEx shell, freeing up the pried one.</p>
<p>When a process is pried, all code runs inside IEx and has access to all imports and aliases from the original code. However, the code is evaluated and therefore cannot access private functions of the module being pried. Module functions still need to be accessed via <code class="inline">Mod.fun(args)</code>.</p>
<p>Alternatively, you can use <a href="#break!/4"><code class="inline">IEx.break!/4</code></a> to setup a breakpoint on a given module, function and arity you have no control of. While <a href="#break!/4"><code class="inline">IEx.break!/4</code></a> is more flexible, it does not contain information about imports and aliases from the source code.</p>
<h4 id="pry/0-examples" class="section-heading">  Examples </h4> <p>Let's suppose you want to investigate what is happening with some particular function. By invoking <a href="#pry/0"><code class="inline">IEx.pry/0</code></a> from the function, IEx will allow you to access its binding (variables), verify its lexical information and access the process information. Let's see an example:</p>
<pre data-language="elixir">import Enum, only: [map: 2]

defmodule Adder do
  def add(a, b) do
    c = a + b
    require IEx; IEx.pry()
  end
end</pre>
<p>When invoking <code class="inline">Adder.add(1, 2)</code>, you will receive a message in your shell to pry the given environment. By allowing it, the shell will be reset and you gain access to all variables and the lexical scope from above:</p>
<pre data-language="elixir">pry(1)&gt; map([a, b, c], &amp;IO.inspect(&amp;1))
1
2
3</pre>
<p>Keep in mind that <a href="#pry/0"><code class="inline">IEx.pry/0</code></a> runs in the caller process, blocking the caller during the evaluation cycle. The caller process can be freed by calling <a href="iex.helpers#respawn/0"><code class="inline">respawn/0</code></a>, which starts a new IEx evaluation cycle, letting this one go:</p>
<pre data-language="elixir">pry(2)&gt; respawn()
true

Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)</pre>
<p>Setting variables or importing modules in IEx does not affect the caller's environment. However, sending and receiving messages will change the process state.</p>
<h4 id="pry/0-pry-and-macros" class="section-heading">  Pry and macros </h4> <p>When setting up Pry inside a code defined by macros, such as:</p>
<pre data-language="elixir">defmacro __using__(_) do
  quote do
    def add(a, b) do
      c = a + b
      require IEx; IEx.pry()
    end
  end
end</pre>
<p>The variables defined inside <code class="inline">quote</code> won't be available during prying due to the hygiene mechanism in quoted expressions. The hygiene mechanism changes the variable names in quoted expressions so they don't collide with variables defined by the users of the macros. Therefore the original names are not available.</p>
<h4 id="pry/0-pry-and-mix-test" class="section-heading">  Pry and <a href="https://hexdocs.pm/mix/1.12/Mix.Tasks.Test.html"><code class="inline">mix test</code></a> </h4> <p>To use <a href="#pry/0"><code class="inline">IEx.pry/0</code></a> during tests, you need to run <code class="inline">mix</code> inside the <code class="inline">iex</code> command and pass the <code class="inline">--trace</code> to <a href="https://hexdocs.pm/mix/1.12/Mix.Tasks.Test.html"><code class="inline">mix test</code></a> to avoid running into timeouts:</p>
<pre data-language="elixir">iex -S mix test --trace
iex -S mix test path/to/file:line --trace</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="started?/0">started?()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/iex/lib/iex.ex#L503" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">started?() :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if IEx was started, <code class="inline">false</code> otherwise.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="width/0">width()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/iex/lib/iex.ex#L529" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">width() :: pos_integer()</pre> </div> <p>Returns the IEx width for printing.</p>
<p>Used by helpers and it has a default maximum cap of 80 chars.</p> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/iex/1.12.0/IEx.html" class="_attribution-link" target="_blank">https://hexdocs.pm/iex/1.12.0/IEx.html</a>
  </p>
</div>
