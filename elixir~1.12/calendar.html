<h1> Calendar <small>behaviour</small>   </h1> <section id="moduledoc"> <p>This module defines the responsibilities for working with calendars, dates, times and datetimes in Elixir.</p>
<p>Currently it defines types and the minimal implementation for a calendar behaviour in Elixir. The goal of the Calendar features in Elixir is to provide a base for interoperability instead of full-featured datetime API.</p>
<p>For the actual date, time and datetime structures, see <a href="date"><code class="inline">Date</code></a>, <a href="time"><code class="inline">Time</code></a>, <a href="naivedatetime"><code class="inline">NaiveDateTime</code></a> and <a href="datetime"><code class="inline">DateTime</code></a>.</p>
<p>Note designations for year, month, day, and the like, are overspecified (i.e. an integer instead of <code class="inline">1..12</code> for months) because different calendars may have a different number of days per month, months per year and so on.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:calendar/0">calendar()</a> </dt> <dd class="summary-synopsis"><p>A calendar implementation</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:date/0">date()</a> </dt> <dd class="summary-synopsis"><p>Any map/struct that contains the date fields</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:datetime/0">datetime()</a> </dt> <dd class="summary-synopsis"><p>Any map/struct that contains the datetime fields</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:day/0">day()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:day_fraction/0">day_fraction()</a> </dt> <dd class="summary-synopsis"><p>The internal time format is used when converting between calendars.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:day_of_era/0">day_of_era()</a> </dt> <dd class="summary-synopsis"><p>A tuple representing the <code class="inline">day</code> and the <code class="inline">era</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:day_of_week/0">day_of_week()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:era/0">era()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:hour/0">hour()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:iso_days/0">iso_days()</a> </dt> <dd class="summary-synopsis"><p>The internal date format that is used when converting between calendars.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:microsecond/0">microsecond()</a> </dt> <dd class="summary-synopsis"><p>Microseconds with stored precision.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:minute/0">minute()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:month/0">month()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:naive_datetime/0">naive_datetime()</a> </dt> <dd class="summary-synopsis"><p>Any map/struct that contains the naive_datetime fields</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:second/0">second()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:std_offset/0">std_offset()</a> </dt> <dd class="summary-synopsis"><p>The time zone standard offset in seconds (typically not zero in summer times).</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:time/0">time()</a> </dt> <dd class="summary-synopsis"><p>Any map/struct that contains the time fields</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:time_zone/0">time_zone()</a> </dt> <dd class="summary-synopsis"><p>The time zone ID according to the IANA tz database (for example, Europe/Zurich)</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:time_zone_database/0">time_zone_database()</a> </dt> <dd class="summary-synopsis"><p>Specifies the time zone database for calendar operations.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:utc_offset/0">utc_offset()</a> </dt> <dd class="summary-synopsis"><p>The time zone UTC offset in seconds for standard time.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:week/0">week()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:year/0">year()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:zone_abbr/0">zone_abbr()</a> </dt> <dd class="summary-synopsis"><p>The time zone abbreviation (for example, CET or CEST or BST, and such)</p></dd> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#compatible_calendars?/2">compatible_calendars?(calendar, calendar)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if two calendars have the same moment of starting a new day, <code class="inline">false</code> otherwise.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_time_zone_database/0">get_time_zone_database()</a> </dt> <dd class="summary-synopsis"><p>Gets the current time zone database.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_time_zone_database/1">put_time_zone_database(database)</a> </dt> <dd class="summary-synopsis"><p>Sets the current time zone database.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#strftime/3">strftime(date_or_time_or_datetime, string_format, user_options \\ [])</a> </dt> <dd class="summary-synopsis"><p>Formats received datetime into a string.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#truncate/2">truncate(microsecond_tuple, atom)</a> </dt> <dd class="summary-synopsis"><p>Returns a microsecond tuple truncated to a given precision (<code class="inline">:microsecond</code>, <code class="inline">:millisecond</code> or <code class="inline">:second</code>).</p></dd> </div> </dl> <h2> Callbacks </h2>
<dl class="summary-callbacks summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#c:date_to_string/3">date_to_string(year, month, day)</a> </dt> <dd class="summary-synopsis"><p>Converts the date into a string according to the calendar.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:datetime_to_string/11">datetime_to_string(year, month, day, hour, minute, second, microsecond, time_zone, zone_abbr, utc_offset, std_offset)</a> </dt> <dd class="summary-synopsis"><p>Converts the datetime (with time zone) into a string according to the calendar.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:day_of_era/3">day_of_era(year, month, day)</a> </dt> <dd class="summary-synopsis"><p>Calculates the day and era from the given <code class="inline">year</code>, <code class="inline">month</code>, and <code class="inline">day</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:day_of_week/4">day_of_week(year, month, day, starting_on)</a> </dt> <dd class="summary-synopsis"><p>Calculates the day of the week from the given <code class="inline">year</code>, <code class="inline">month</code>, and <code class="inline">day</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:day_of_year/3">day_of_year(year, month, day)</a> </dt> <dd class="summary-synopsis"><p>Calculates the day of the year from the given <code class="inline">year</code>, <code class="inline">month</code>, and <code class="inline">day</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:day_rollover_relative_to_midnight_utc/0">day_rollover_relative_to_midnight_utc()</a> </dt> <dd class="summary-synopsis"><p>Define the rollover moment for the given calendar.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:days_in_month/2">days_in_month(year, month)</a> </dt> <dd class="summary-synopsis"><p>Returns how many days there are in the given year-month.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:leap_year?/1">leap_year?(year)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if the given year is a leap year.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:months_in_year/1">months_in_year(year)</a> </dt> <dd class="summary-synopsis"><p>Returns how many months there are in the given year.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:naive_datetime_from_iso_days/1">naive_datetime_from_iso_days(iso_days)</a> </dt> <dd class="summary-synopsis"><p>Converts <a href="#t:iso_days/0"><code class="inline">iso_days/0</code></a> to the Calendar's datetime format.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:naive_datetime_to_iso_days/7">naive_datetime_to_iso_days(year, month, day, hour, minute, second, microsecond)</a> </dt> <dd class="summary-synopsis"><p>Converts the given datetime (without time zone) into the <a href="#t:iso_days/0"><code class="inline">iso_days/0</code></a> format.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:naive_datetime_to_string/7">naive_datetime_to_string(year, month, day, hour, minute, second, microsecond)</a> </dt> <dd class="summary-synopsis"><p>Converts the datetime (without time zone) into a string according to the calendar.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:parse_date/1">parse_date(arg1)</a> </dt> <dd class="summary-synopsis"><p>Parses the string representation for a date returned by <a href="#c:date_to_string/3"><code class="inline">date_to_string/3</code></a> into a date-tuple.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:parse_naive_datetime/1">parse_naive_datetime(arg1)</a> </dt> <dd class="summary-synopsis"><p>Parses the string representation for a naive datetime returned by <a href="#c:naive_datetime_to_string/7"><code class="inline">naive_datetime_to_string/7</code></a> into a naive-datetime-tuple.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:parse_time/1">parse_time(arg1)</a> </dt> <dd class="summary-synopsis"><p>Parses the string representation for a time returned by <a href="#c:time_to_string/4"><code class="inline">time_to_string/4</code></a> into a time-tuple.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:parse_utc_datetime/1">parse_utc_datetime(arg1)</a> </dt> <dd class="summary-synopsis"><p>Parses the string representation for a datetime returned by <a href="#c:datetime_to_string/11"><code class="inline">datetime_to_string/11</code></a> into a datetime-tuple.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:quarter_of_year/3">quarter_of_year(year, month, day)</a> </dt> <dd class="summary-synopsis"><p>Calculates the quarter of the year from the given <code class="inline">year</code>, <code class="inline">month</code>, and <code class="inline">day</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:time_from_day_fraction/1">time_from_day_fraction(day_fraction)</a> </dt> <dd class="summary-synopsis"><p>Converts <a href="#t:day_fraction/0"><code class="inline">day_fraction/0</code></a> to the Calendar's time format.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:time_to_day_fraction/4">time_to_day_fraction(hour, minute, second, microsecond)</a> </dt> <dd class="summary-synopsis"><p>Converts the given time to the <a href="#t:day_fraction/0"><code class="inline">day_fraction/0</code></a> format.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:time_to_string/4">time_to_string(hour, minute, second, microsecond)</a> </dt> <dd class="summary-synopsis"><p>Converts the time into a string according to the calendar.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:valid_date?/3">valid_date?(year, month, day)</a> </dt> <dd class="summary-synopsis"><p>Should return <code class="inline">true</code> if the given date describes a proper date in the calendar.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:valid_time?/4">valid_time?(hour, minute, second, microsecond)</a> </dt> <dd class="summary-synopsis"><p>Should return <code class="inline">true</code> if the given time describes a proper time in the calendar.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:year_of_era/1">year_of_era(year)</a> </dt> <dd class="summary-synopsis"><p>Calculates the year and era from the given <code class="inline">year</code>.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:calendar/0">calendar()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L63" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">calendar() :: module()</pre> </div> <p>A calendar implementation</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:date/0">date()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L86" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">date() :: %{
  optional(any()) =&gt; any(),
  :calendar =&gt; calendar(),
  :year =&gt; year(),
  :month =&gt; month(),
  :day =&gt; day()
}</pre> </div> <p>Any map/struct that contains the date fields</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:datetime/0">datetime()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L111" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">datetime() :: %{
  optional(any()) =&gt; any(),
  :calendar =&gt; calendar(),
  :year =&gt; year(),
  :month =&gt; month(),
  :day =&gt; day(),
  :hour =&gt; hour(),
  :minute =&gt; minute(),
  :second =&gt; second(),
  :microsecond =&gt; microsecond(),
  :time_zone =&gt; time_zone(),
  :zone_abbr =&gt; zone_abbr(),
  :utc_offset =&gt; utc_offset(),
  :std_offset =&gt; std_offset()
}</pre> </div> <p>Any map/struct that contains the datetime fields</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:day/0">day()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L21" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">day() :: pos_integer()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:day_fraction/0">day_fraction()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L42" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">day_fraction() ::
  {parts_in_day :: non_neg_integer(), parts_per_day :: pos_integer()}</pre> </div> <p>The internal time format is used when converting between calendars.</p>
<p>It represents time as a fraction of a day (starting from midnight). <code class="inline">parts_in_day</code> specifies how much of the day is already passed, while <code class="inline">parts_per_day</code> signifies how many parts there fit in a day.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:day_of_era/0">day_of_era()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L29" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">day_of_era() :: {day :: non_neg_integer(), era()}</pre> </div> <p>A tuple representing the <code class="inline">day</code> and the <code class="inline">era</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:day_of_week/0">day_of_week()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L23" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">day_of_week() :: non_neg_integer()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:era/0">era()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L24" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">era() :: non_neg_integer()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:hour/0">hour()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L31" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">hour() :: non_neg_integer()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:iso_days/0">iso_days()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L51" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">iso_days() :: {days :: integer(), day_fraction()}</pre> </div> <p>The internal date format that is used when converting between calendars.</p>
<p>This is the number of days including the fractional part that has passed of the last day since 0000-01-01+00:00T00:00.000000 in ISO 8601 notation (also known as midnight 1 January BC 1 of the proleptic Gregorian calendar).</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:microsecond/0">microsecond()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L60" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">microsecond() :: {non_neg_integer(), non_neg_integer()}</pre> </div> <p>Microseconds with stored precision.</p>
<p>The precision represents the number of digits that must be used when representing the microseconds to external format. If the precision is 0, it means microseconds must be skipped.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:minute/0">minute()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L32" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">minute() :: non_neg_integer()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:month/0">month()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L20" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">month() :: pos_integer()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:naive_datetime/0">naive_datetime()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L98" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">naive_datetime() :: %{
  optional(any()) =&gt; any(),
  :calendar =&gt; calendar(),
  :year =&gt; year(),
  :month =&gt; month(),
  :day =&gt; day(),
  :hour =&gt; hour(),
  :minute =&gt; minute(),
  :second =&gt; second(),
  :microsecond =&gt; microsecond()
}</pre> </div> <p>Any map/struct that contains the naive_datetime fields</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:second/0">second()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L33" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">second() :: non_neg_integer()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:std_offset/0">std_offset()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L83" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">std_offset() :: integer()</pre> </div> <p>The time zone standard offset in seconds (typically not zero in summer times).</p>
<p>It must be added to <a href="#t:utc_offset/0"><code class="inline">utc_offset/0</code></a> to get the total offset from UTC used for "wall time".</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:time/0">time()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L89" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">time() :: %{
  optional(any()) =&gt; any(),
  :hour =&gt; hour(),
  :minute =&gt; minute(),
  :second =&gt; second(),
  :microsecond =&gt; microsecond()
}</pre> </div> <p>Any map/struct that contains the time fields</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:time_zone/0">time_zone()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L66" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">time_zone() :: String.t()</pre> </div> <p>The time zone ID according to the IANA tz database (for example, Europe/Zurich)</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:time_zone_database/0">time_zone_database()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L147" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">time_zone_database() :: module()</pre> </div> <p>Specifies the time zone database for calendar operations.</p>
<p>Many functions in the <a href="datetime"><code class="inline">DateTime</code></a> module require a time zone database. By default, it uses the default time zone database returned by <a href="#get_time_zone_database/0"><code class="inline">Calendar.get_time_zone_database/0</code></a>, which defaults to <a href="calendar.utconlytimezonedatabase"><code class="inline">Calendar.UTCOnlyTimeZoneDatabase</code></a> which only handles "Etc/UTC" datetimes and returns <code class="inline">{:error, :utc_only_time_zone_database}</code> for any other time zone.</p>
<p>Other time zone databases (including ones provided by packages) can be configured as default either via configuration:</p>
<pre data-language="elixir">config :elixir, :time_zone_database, CustomTimeZoneDatabase</pre>
<p>or by calling <a href="#put_time_zone_database/1"><code class="inline">Calendar.put_time_zone_database/1</code></a>.</p>
<p>See <a href="calendar.timezonedatabase"><code class="inline">Calendar.TimeZoneDatabase</code></a> for more information on custom time zone databases.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:utc_offset/0">utc_offset()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L76" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">utc_offset() :: integer()</pre> </div> <p>The time zone UTC offset in seconds for standard time.</p>
<p>See also <a href="#t:std_offset/0"><code class="inline">std_offset/0</code></a>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:week/0">week()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L22" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">week() :: pos_integer()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:year/0">year()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L19" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">year() :: integer()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:zone_abbr/0">zone_abbr()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L69" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">zone_abbr() :: String.t()</pre> </div> <p>The time zone abbreviation (for example, CET or CEST or BST, and such)</p> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="compatible_calendars?/2">compatible_calendars?(calendar, calendar)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L340" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">compatible_calendars?(calendar(), calendar()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if two calendars have the same moment of starting a new day, <code class="inline">false</code> otherwise.</p>
<p>If two calendars are not compatible, we can only convert datetimes and times between them. If they are compatible, this means that we can also convert dates as well as naive datetimes between them.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_time_zone_database/0">get_time_zone_database()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L377" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">get_time_zone_database() :: time_zone_database()</pre> </div> <p>Gets the current time zone database.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_time_zone_database/1">put_time_zone_database(database)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L368" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">put_time_zone_database(time_zone_database()) :: :ok</pre> </div> <p>Sets the current time zone database.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="strftime/3">strftime(date_or_time_or_datetime, string_format, user_options \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L523" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">strftime(map(), String.t(), keyword()) :: String.t()</pre> </div> <p>Formats received datetime into a string.</p>
<p>The datetime can be any of the Calendar types (<a href="time"><code class="inline">Time</code></a>, <a href="date"><code class="inline">Date</code></a>, <a href="naivedatetime"><code class="inline">NaiveDateTime</code></a>, and <a href="datetime"><code class="inline">DateTime</code></a>) or any map, as long as they contain all of the relevant fields necessary for formatting. For example, if you use <code class="inline">%Y</code> to format the year, the datetime must have the <code class="inline">:year</code> field. Therefore, if you pass a <a href="time"><code class="inline">Time</code></a>, or a map without the <code class="inline">:year</code> field to a format that expects <code class="inline">%Y</code>, an error will be raised.</p>
<h4 id="strftime/3-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:preferred_datetime</code> - a string for the preferred format to show datetimes, it can't contain the <code class="inline">%c</code> format and defaults to <code class="inline">"%Y-%m-%d %H:%M:%S"</code> if the option is not received</p></li>
<li><p><code class="inline">:preferred_date</code> - a string for the preferred format to show dates, it can't contain the <code class="inline">%x</code> format and defaults to <code class="inline">"%Y-%m-%d"</code> if the option is not received</p></li>
<li><p><code class="inline">:preferred_time</code> - a string for the preferred format to show times, it can't contain the <code class="inline">%X</code> format and defaults to <code class="inline">"%H:%M:%S"</code> if the option is not received</p></li>
<li><p><code class="inline">:am_pm_names</code> - a function that receives either <code class="inline">:am</code> or <code class="inline">:pm</code> and returns the name of the period of the day, if the option is not received it defaults to a function that returns <code class="inline">"am"</code> and <code class="inline">"pm"</code>, respectively</p></li>
<li><p> <code class="inline">:month_names</code> - a function that receives a number and returns the name of the corresponding month, if the option is not received it defaults to a function that returns the month names in English</p></li>
<li><p><code class="inline">:abbreviated_month_names</code> - a function that receives a number and returns the abbreviated name of the corresponding month, if the option is not received it defaults to a function that returns the abbreviated month names in English</p></li>
<li><p><code class="inline">:day_of_week_names</code> - a function that receives a number and returns the name of the corresponding day of week, if the option is not received it defaults to a function that returns the day of week names in English</p></li>
<li><p><code class="inline">:abbreviated_day_of_week_names</code> - a function that receives a number and returns the abbreviated name of the corresponding day of week, if the option is not received it defaults to a function that returns the abbreviated day of week names in English</p></li>
</ul>
<h4 id="strftime/3-formatting-syntax" class="section-heading">  Formatting syntax </h4> <p>The formatting syntax for strftime is a sequence of characters in the following format:</p>
<pre data-language="elixir">%&lt;padding&gt;&lt;width&gt;&lt;format&gt;</pre>
<p>where:</p>
<ul>
<li>
<code class="inline">%</code>: indicates the start of a formatted section</li>
<li>
<code class="inline">&lt;padding&gt;</code>: set the padding (see below)</li>
<li>
<code class="inline">&lt;width&gt;</code>: a number indicating the minimum size of the formatted section</li>
<li>
<code class="inline">&lt;format&gt;</code>: the format itself (see below)</li>
</ul>
<h3 id="strftime/3-accepted-padding-options" class="section-heading">  Accepted padding options </h3> <ul>
<li>
<code class="inline">-</code>: no padding, removes all padding from the format</li>
<li>
<code class="inline">_</code>: pad with spaces</li>
<li>
<code class="inline">0</code>: pad with zeroes</li>
</ul>
<h3 id="strftime/3-accepted-formats" class="section-heading">  Accepted formats </h3> <p>The accepted formats are:</p>
<table>
<thead><tr>
<th style="text-align: left;">Format</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Examples (in ISO)</th>
</tr></thead>
<tbody>
<tr>
<td style="text-align: left;">a</td>
<td style="text-align: left;">Abbreviated name of day</td>
<td style="text-align: left;">Mon</td>
</tr>
<tr>
<td style="text-align: left;">A</td>
<td style="text-align: left;">Full name of day</td>
<td style="text-align: left;">Monday</td>
</tr>
<tr>
<td style="text-align: left;">b</td>
<td style="text-align: left;">Abbreviated month name</td>
<td style="text-align: left;">Jan</td>
</tr>
<tr>
<td style="text-align: left;">B</td>
<td style="text-align: left;">Full month name</td>
<td style="text-align: left;">January</td>
</tr>
<tr>
<td style="text-align: left;">c</td>
<td style="text-align: left;">Preferred date+time representation</td>
<td style="text-align: left;">2018-10-17 12:34:56</td>
</tr>
<tr>
<td style="text-align: left;">d</td>
<td style="text-align: left;">Day of the month</td>
<td style="text-align: left;">01, 31</td>
</tr>
<tr>
<td style="text-align: left;">f</td>
<td style="text-align: left;">Microseconds <em>(does not support width and padding modifiers)</em>
</td>
<td style="text-align: left;">000000, 999999, 0123</td>
</tr>
<tr>
<td style="text-align: left;">H</td>
<td style="text-align: left;">Hour using a 24-hour clock</td>
<td style="text-align: left;">00, 23</td>
</tr>
<tr>
<td style="text-align: left;">I</td>
<td style="text-align: left;">Hour using a 12-hour clock</td>
<td style="text-align: left;">01, 12</td>
</tr>
<tr>
<td style="text-align: left;">j</td>
<td style="text-align: left;">Day of the year</td>
<td style="text-align: left;">001, 366</td>
</tr>
<tr>
<td style="text-align: left;">m</td>
<td style="text-align: left;">Month</td>
<td style="text-align: left;">01, 12</td>
</tr>
<tr>
<td style="text-align: left;">M</td>
<td style="text-align: left;">Minute</td>
<td style="text-align: left;">00, 59</td>
</tr>
<tr>
<td style="text-align: left;">p</td>
<td style="text-align: left;">"AM" or "PM" (noon is "PM", midnight as "AM")</td>
<td style="text-align: left;">AM, PM</td>
</tr>
<tr>
<td style="text-align: left;">P</td>
<td style="text-align: left;">"am" or "pm" (noon is "pm", midnight as "am")</td>
<td style="text-align: left;">am, pm</td>
</tr>
<tr>
<td style="text-align: left;">q</td>
<td style="text-align: left;">Quarter</td>
<td style="text-align: left;">1, 2, 3, 4</td>
</tr>
<tr>
<td style="text-align: left;">S</td>
<td style="text-align: left;">Second</td>
<td style="text-align: left;">00, 59, 60</td>
</tr>
<tr>
<td style="text-align: left;">u</td>
<td style="text-align: left;">Day of the week</td>
<td style="text-align: left;">1 (Monday), 7 (Sunday)</td>
</tr>
<tr>
<td style="text-align: left;">x</td>
<td style="text-align: left;">Preferred date (without time) representation</td>
<td style="text-align: left;">2018-10-17</td>
</tr>
<tr>
<td style="text-align: left;">X</td>
<td style="text-align: left;">Preferred time (without date) representation</td>
<td style="text-align: left;">12:34:56</td>
</tr>
<tr>
<td style="text-align: left;">y</td>
<td style="text-align: left;">Year as 2-digits</td>
<td style="text-align: left;">01, 01, 86, 18</td>
</tr>
<tr>
<td style="text-align: left;">Y</td>
<td style="text-align: left;">Year</td>
<td style="text-align: left;">-0001, 0001, 1986</td>
</tr>
<tr>
<td style="text-align: left;">z</td>
<td style="text-align: left;">+hhmm/-hhmm time zone offset from UTC (empty string if naive)</td>
<td style="text-align: left;">+0300, -0530</td>
</tr>
<tr>
<td style="text-align: left;">Z</td>
<td style="text-align: left;">Time zone abbreviation (empty string if naive)</td>
<td style="text-align: left;">CET, BRST</td>
</tr>
<tr>
<td style="text-align: left;">%</td>
<td style="text-align: left;">Literal "%" character</td>
<td style="text-align: left;">%</td>
</tr>
</tbody>
</table>
<p>Any other character will be interpreted as an invalid format and raise an error</p>
<h4 id="strftime/3-examples" class="section-heading">  Examples </h4> <p>Without options:</p>
<pre data-language="elixir">iex&gt; Calendar.strftime(~U[2019-08-26 13:52:06.0Z], "%y-%m-%d %I:%M:%S %p")
"19-08-26 01:52:06 PM"

iex&gt; Calendar.strftime(~U[2019-08-26 13:52:06.0Z], "%a, %B %d %Y")
"Mon, August 26 2019"

iex&gt; Calendar.strftime(~U[2020-04-02 13:52:06.0Z], "%B %-d, %Y")
"April 2, 2020"

iex&gt; Calendar.strftime(~U[2019-08-26 13:52:06.0Z], "%c")
"2019-08-26 13:52:06"</pre>
<p>With options:</p>
<pre data-language="elixir">iex&gt; Calendar.strftime(~U[2019-08-26 13:52:06.0Z], "%c", preferred_datetime: "%H:%M:%S %d-%m-%y")
"13:52:06 26-08-19"

iex&gt; Calendar.strftime(
...&gt;  ~U[2019-08-26 13:52:06.0Z],
...&gt;  "%A",
...&gt;  day_of_week_names: fn day_of_week -&gt;
...&gt;    {"segunda-feira", "terça-feira", "quarta-feira", "quinta-feira",
...&gt;    "sexta-feira", "sábado", "domingo"}
...&gt;    |&gt; elem(day_of_week - 1)
...&gt;  end
...&gt;)
"segunda-feira"

iex&gt; Calendar.strftime(
...&gt;  ~U[2019-08-26 13:52:06.0Z],
...&gt;  "%B",
...&gt;  month_names: fn month -&gt;
...&gt;    {"январь", "февраль", "март", "апрель", "май", "июнь",
...&gt;    "июль", "август", "сентябрь", "октябрь", "ноябрь", "декабрь"}
...&gt;    |&gt; elem(month - 1)
...&gt;  end
...&gt;)
"август"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="truncate/2">truncate(microsecond_tuple, atom)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L354" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">truncate(microsecond(), :microsecond | :millisecond | :second) :: microsecond()</pre> </div> <p>Returns a microsecond tuple truncated to a given precision (<code class="inline">:microsecond</code>, <code class="inline">:millisecond</code> or <code class="inline">:second</code>).</p> </section> </section> </div> </section> <section id="callbacks" class="details-list"> <h1 class="section-heading">  Callbacks </h1> <div class="callbacks-list"> <section class="detail"> <h3 class="detail-header" id="c:date_to_string/3">date_to_string(year, month, day)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L202" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">date_to_string(year(), month(), day()) :: String.t()</pre> </div> <p>Converts the date into a string according to the calendar.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:datetime_to_string/11">datetime_to_string(year, month, day, hour, minute, second, microsecond, time_zone, zone_abbr, utc_offset, std_offset)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L225" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">datetime_to_string(
  year(),
  month(),
  day(),
  hour(),
  minute(),
  second(),
  microsecond(),
  time_zone(),
  zone_abbr(),
  utc_offset(),
  std_offset()
) :: String.t()</pre> </div> <p>Converts the datetime (with time zone) into a string according to the calendar.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:day_of_era/3">day_of_era(year, month, day)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L197" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">day_of_era(year(), month(), day()) :: day_of_era()</pre> </div> <p>Calculates the day and era from the given <code class="inline">year</code>, <code class="inline">month</code>, and <code class="inline">day</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:day_of_week/4">day_of_week(year, month, day, starting_on)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L175" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">day_of_week(year(), month(), day(), starting_on :: :default | atom()) ::
  {day_of_week(), first_day_of_week :: non_neg_integer(),
   last_day_of_week :: non_neg_integer()}</pre> </div> <p>Calculates the day of the week from the given <code class="inline">year</code>, <code class="inline">month</code>, and <code class="inline">day</code>.</p>
<p>The <code class="inline">starting_on</code> represents the starting day of the week. All calendars must support at least the <code class="inline">:default</code> value. They may also support other values representing their days of the week.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:day_of_year/3">day_of_year(year, month, day)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L182" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">day_of_year(year(), month(), day()) :: non_neg_integer()</pre> </div> <p>Calculates the day of the year from the given <code class="inline">year</code>, <code class="inline">month</code>, and <code class="inline">day</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:day_rollover_relative_to_midnight_utc/0">day_rollover_relative_to_midnight_utc()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L275" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">day_rollover_relative_to_midnight_utc() :: day_fraction()</pre> </div> <p>Define the rollover moment for the given calendar.</p>
<p>This is the moment, in your calendar, when the current day ends and the next day starts.</p>
<p>The result of this function is used to check if two calendars rollover at the same time of day. If they do not, we can only convert datetimes and times between them. If they do, this means that we can also convert dates as well as naive datetimes between them.</p>
<p>This day fraction should be in its most simplified form possible, to make comparisons fast.</p>
<h4 id="c:day_rollover_relative_to_midnight_utc/0-examples" class="section-heading">  Examples </h4> <ul>
<li>If, in your Calendar, a new day starts at midnight, return {0, 1}.</li>
<li>If, in your Calendar, a new day starts at sunrise, return {1, 4}.</li>
<li>If, in your Calendar, a new day starts at noon, return {1, 2}.</li>
<li>If, in your Calendar, a new day starts at sunset, return {3, 4}.</li>
</ul> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:days_in_month/2">days_in_month(year, month)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L152" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">days_in_month(year(), month()) :: day()</pre> </div> <p>Returns how many days there are in the given year-month.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:leap_year?/1">leap_year?(year)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L166" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">leap_year?(year()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if the given year is a leap year.</p>
<p>A leap year is a year of a longer length than normal. The exact meaning is up to the calendar. A calendar must return <code class="inline">false</code> if it does not support the concept of leap years.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:months_in_year/1">months_in_year(year)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L157" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">months_in_year(year()) :: month()</pre> </div> <p>Returns how many months there are in the given year.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:naive_datetime_from_iso_days/1">naive_datetime_from_iso_days(iso_days)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L241" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">naive_datetime_from_iso_days(iso_days()) ::
  {year(), month(), day(), hour(), minute(), second(), microsecond()}</pre> </div> <p>Converts <a href="#t:iso_days/0"><code class="inline">iso_days/0</code></a> to the Calendar's datetime format.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:naive_datetime_to_iso_days/7">naive_datetime_to_iso_days(year, month, day, hour, minute, second, microsecond)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L235" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">naive_datetime_to_iso_days(
  year(),
  month(),
  day(),
  hour(),
  minute(),
  second(),
  microsecond()
) :: iso_days()</pre> </div> <p>Converts the given datetime (without time zone) into the <a href="#t:iso_days/0"><code class="inline">iso_days/0</code></a> format.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:naive_datetime_to_string/7">naive_datetime_to_string(year, month, day, hour, minute, second, microsecond)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L207" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">naive_datetime_to_string(
  year(),
  month(),
  day(),
  hour(),
  minute(),
  second(),
  microsecond()
) :: String.t()</pre> </div> <p>Converts the datetime (without time zone) into a string according to the calendar.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:parse_date/1">parse_date(arg1)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L301" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">parse_date(String.t()) :: {:ok, {year(), month(), day()}} | {:error, atom()}</pre> </div> <p>Parses the string representation for a date returned by <a href="#c:date_to_string/3"><code class="inline">date_to_string/3</code></a> into a date-tuple.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:parse_naive_datetime/1">parse_naive_datetime(arg1)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L312" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">parse_naive_datetime(String.t()) ::
  {:ok, {year(), month(), day(), hour(), minute(), second(), microsecond()}}
  | {:error, atom()}</pre> </div> <p>Parses the string representation for a naive datetime returned by <a href="#c:naive_datetime_to_string/7"><code class="inline">naive_datetime_to_string/7</code></a> into a naive-datetime-tuple.</p>
<p>The given string may contain a timezone offset but it is ignored.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:parse_time/1">parse_time(arg1)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L292" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">parse_time(String.t()) ::
  {:ok, {hour(), minute(), second(), microsecond()}} | {:error, atom()}</pre> </div> <p>Parses the string representation for a time returned by <a href="#c:time_to_string/4"><code class="inline">time_to_string/4</code></a> into a time-tuple.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:parse_utc_datetime/1">parse_utc_datetime(arg1)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L324" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">parse_utc_datetime(String.t()) ::
  {:ok, {year(), month(), day(), hour(), minute(), second(), microsecond()},
   utc_offset()}
  | {:error, atom()}</pre> </div> <p>Parses the string representation for a datetime returned by <a href="#c:datetime_to_string/11"><code class="inline">datetime_to_string/11</code></a> into a datetime-tuple.</p>
<p>The returned datetime must be in UTC. The original <code class="inline">utc_offset</code> it was written in must be returned in the result.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:quarter_of_year/3">quarter_of_year(year, month, day)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L187" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">quarter_of_year(year(), month(), day()) :: non_neg_integer()</pre> </div> <p>Calculates the quarter of the year from the given <code class="inline">year</code>, <code class="inline">month</code>, and <code class="inline">day</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:time_from_day_fraction/1">time_from_day_fraction(day_fraction)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L252" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">time_from_day_fraction(day_fraction()) ::
  {hour(), minute(), second(), microsecond()}</pre> </div> <p>Converts <a href="#t:day_fraction/0"><code class="inline">day_fraction/0</code></a> to the Calendar's time format.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:time_to_day_fraction/4">time_to_day_fraction(hour, minute, second, microsecond)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L247" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">time_to_day_fraction(hour(), minute(), second(), microsecond()) ::
  day_fraction()</pre> </div> <p>Converts the given time to the <a href="#t:day_fraction/0"><code class="inline">day_fraction/0</code></a> format.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:time_to_string/4">time_to_string(hour, minute, second, microsecond)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L230" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">time_to_string(hour(), minute(), second(), microsecond()) :: String.t()</pre> </div> <p>Converts the time into a string according to the calendar.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:valid_date?/3">valid_date?(year, month, day)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L280" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">valid_date?(year(), month(), day()) :: boolean()</pre> </div> <p>Should return <code class="inline">true</code> if the given date describes a proper date in the calendar.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:valid_time?/4">valid_time?(hour, minute, second, microsecond)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L285" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">valid_time?(hour(), minute(), second(), microsecond()) :: boolean()</pre> </div> <p>Should return <code class="inline">true</code> if the given time describes a proper time in the calendar.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:year_of_era/1">year_of_era(year)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/calendar.ex#L192" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">year_of_era(year()) :: {year(), era()}</pre> </div> <p>Calculates the year and era from the given <code class="inline">year</code>.</p> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/elixir/1.12.0/Calendar.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.12.0/Calendar.html</a>
  </p>
</div>
