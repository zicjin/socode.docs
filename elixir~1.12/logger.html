<h1> Logger   </h1> <section id="moduledoc"> <p>A logger for Elixir applications.</p>
<p>It includes many features:</p>
<ul>
<li><p>Provides debug, info, warn, and error levels.</p></li>
<li><p>Supports multiple backends which are automatically supervised when plugged into <a href="logger#content"><code class="inline">Logger</code></a>.</p></li>
<li><p>Formats and truncates messages on the client to avoid clogging <a href="logger#content"><code class="inline">Logger</code></a> backends.</p></li>
<li><p>Alternates between sync and async modes to remain performant when required but also apply backpressure when under stress.</p></li>
<li><p>Integrates with Erlang's <a href="https://erlang.org/doc/man/logger.html"><code class="inline">:logger</code></a> to convert terms to Elixir syntax.</p></li>
</ul>
<p>Logging is useful for tracking when an event of interest happens in your system. For example, it may be helpful to log whenever a user is deleted.</p>
<pre data-language="elixir">def delete_user(user) do
  Logger.info("Deleting user from the system: #{inspect(user)}")
  # ...
end</pre>
<p>The <a href="#info/2"><code class="inline">Logger.info/2</code></a> macro emits the provided message at the <code class="inline">:info</code> level. Note the arguments given to <a href="#info/2"><code class="inline">info/2</code></a> will only be evaluated if a message is logged. For instance, if the Logger level is set to <code class="inline">:warning</code>, <code class="inline">:info</code> messages are never logged and therefore the arguments given above won't even be executed.</p>
<p>There are additional macros for other levels.</p>
<p>Logger also allows log commands to be removed altogether via the <code class="inline">:compile_time_purge_matching</code> option (see below).</p>
<p>For dynamically logging messages, see <a href="#bare_log/3"><code class="inline">bare_log/3</code></a>. But note that <a href="#bare_log/3"><code class="inline">bare_log/3</code></a> always evaluates its arguments (unless the argument is an anonymous function).</p>
<h2 id="module-levels" class="section-heading">  Levels </h2> <p>The supported levels, ordered by importance, are:</p>
<ul>
<li>
<code class="inline">:emergency</code> - when system is unusable, panics</li>
<li>
<code class="inline">:alert</code> - for alerts, actions that must be taken immediately, ex. corrupted database</li>
<li>
<code class="inline">:critical</code> - for critical conditions</li>
<li>
<code class="inline">:error</code> - for errors</li>
<li>
<code class="inline">:warning</code> - for warnings</li>
<li>
<code class="inline">:notice</code> - for normal, but significant, messages</li>
<li>
<code class="inline">:info</code> - for information of any kind</li>
<li>
<code class="inline">:debug</code> - for debug-related messages</li>
</ul>
<p>For example, <code class="inline">:info</code> takes precedence over <code class="inline">:debug</code>. If your log level is set to <code class="inline">:info</code>, then all <code class="inline">:info</code>, <code class="inline">:notice</code> and above will be passed to backends. If your log level is set to <code class="inline">:alert</code>, only <code class="inline">:alert</code> and <code class="inline">:emergency</code> will be printed.</p>
<h2 id="module-metadata" class="section-heading">  Metadata </h2> <p>Whenever a message is logged, additional information can be given via metadata. Each log operation, such as <a href="#info/2"><code class="inline">Logger.info/2</code></a>, allows metadata to be given as argument.</p>
<p>Furthermore, metadata can be set per process with <a href="#metadata/1"><code class="inline">Logger.metadata/1</code></a>.</p>
<p>Some metadata, however, is always added automatically by Logger whenever possible. Those are:</p>
<ul>
<li><p><code class="inline">:application</code> - the current application</p></li>
<li><p><code class="inline">:mfa</code> - the current module, function and arity</p></li>
<li><p><code class="inline">:file</code> - the current file</p></li>
<li><p><code class="inline">:line</code> - the current line</p></li>
<li><p><code class="inline">:pid</code> - the current process identifier</p></li>
<li><p><code class="inline">:initial_call</code> - the initial call that started the process</p></li>
<li><p><code class="inline">:registered_name</code> - the process registered name as an atom</p></li>
<li><p><code class="inline">:domain</code> - a list of domains for the logged message. For example, all Elixir reports default to <code class="inline">[:elixir]</code>. Erlang reports may start with <code class="inline">[:otp]</code> or <code class="inline">[:sasl]</code></p></li>
<li><p><code class="inline">:crash_reason</code> - a two-element tuple with the throw/error/exit reason as first argument and the stacktrace as second. A throw will always be <code class="inline">{:nocatch, term}</code>. An error is always an <a href="https://hexdocs.pm/elixir/1.12/Exception.html"><code class="inline">Exception</code></a> struct. All other entries are exits. The console backend ignores this metadata by default but it can be useful to other backends, such as the ones that report errors to third-party services</p></li>
</ul>
<p>Note that all metadata is optional and may not always be available. The <code class="inline">:mfa</code>, <code class="inline">:file</code>, <code class="inline">:line</code>, and similar metadata are automatically included when using <a href="logger#content"><code class="inline">Logger</code></a> macros. <a href="#bare_log/3"><code class="inline">Logger.bare_log/3</code></a> does not include any metadata beyond the <code class="inline">:pid</code> by default. Other metadata, such as <code class="inline">:crash_reason</code>, <code class="inline">:initial_call</code>, and <code class="inline">:registered_name</code> are available only inside behaviours such as GenServer, Supervisor, and others.</p>
<p>For example, you might wish to include a custom <code class="inline">:error_code</code> metadata in your logs:</p>
<pre data-language="elixir">Logger.error("We have a problem", [error_code: :pc_load_letter])</pre>
<p>In your app's logger configuration, you would need to include the <code class="inline">:error_code</code> key and you would need to include <code class="inline">$metadata</code> as part of your log format template:</p>
<pre data-language="elixir">config :logger, :console,
 format: "[$level] $message $metadata\n",
 metadata: [:error_code, :file]</pre>
<p>Your logs might then receive lines like this:</p>
<pre data-language="elixir">[error] We have a problem error_code=pc_load_letter file=lib/app.ex</pre>
<h2 id="module-configuration" class="section-heading">  Configuration </h2> <p><a href="logger#content"><code class="inline">Logger</code></a> supports a wide range of configurations.</p>
<p>This configuration is split in three categories:</p>
<ul>
<li><p>Application configuration - must be set before the <code class="inline">:logger</code> application is started</p></li>
<li><p>Runtime configuration - can be set before the <code class="inline">:logger</code> application is started, but may be changed during runtime</p></li>
<li><p>Erlang configuration - options that handle integration with Erlang's logging facilities</p></li>
</ul>
<h3 id="module-application-configuration" class="section-heading">  Application configuration </h3> <p>The following configuration must be set via config files (such as <code class="inline">config/config.exs</code>) before the <code class="inline">:logger</code> application is started.</p>
<ul>
<li><p><code class="inline">:backends</code> - the backends to be used. Defaults to <code class="inline">[:console]</code>. See the "Backends" section for more information.</p></li>
<li><p><code class="inline">:compile_time_application</code> - sets the <code class="inline">:application</code> metadata value to the configured value at compilation time. This configuration is automatically set by Mix and made available as metadata when logging.</p></li>
<li>
<p><code class="inline">:compile_time_purge_matching</code> - purges <em>at compilation time</em> all calls that match the given conditions. This means that <a href="logger#content"><code class="inline">Logger</code></a> calls with level lower than this option will be completely removed at compile time, accruing no overhead at runtime. This configuration expects a list of keyword lists. Each keyword list contains a metadata key and the matching value that should be purged. Some special keys are supported:</p>
<ul>
<li>
<code class="inline">:level_lower_than</code> - purges all messages with a lower logger level</li>
<li>
<code class="inline">:module</code> - purges all messages with the matching module</li>
<li>
<code class="inline">:function</code> - purges all messages with the "function/arity" Remember that if you want to purge log calls from a dependency, the dependency must be recompiled.</li>
</ul>
</li>
<li><p><code class="inline">:start_options</code> - passes start options to Logger's main process, such as <code class="inline">:spawn_opt</code> and <code class="inline">:hibernate_after</code>. All options in <a href="https://hexdocs.pm/elixir/1.12/GenServer.html#t:option/0"><code class="inline">GenServer.option/0</code></a> are accepted, except <code class="inline">:name</code>.</p></li>
</ul>
<p>For example, to configure the <code class="inline">:backends</code> and purge all calls that happen at compile time with level lower than <code class="inline">:info</code> in a <code class="inline">config/config.exs</code> file:</p>
<pre data-language="elixir">config :logger,
  backends: [:console],
  compile_time_purge_matching: [
    [level_lower_than: :info]
  ]</pre>
<p>If you want to purge all log calls from an application named <code class="inline">:foo</code> and only keep errors from <code class="inline">Bar.foo/3</code>, you can set up two different matches:</p>
<pre data-language="elixir">config :logger,
  compile_time_purge_matching: [
    [application: :foo],
    [module: Bar, function: "foo/3", level_lower_than: :error]
  ]</pre>
<h3 id="module-runtime-configuration" class="section-heading">  Runtime Configuration </h3> <p>All configuration below can be set via config files (such as <code class="inline">config/config.exs</code>) but also changed dynamically during runtime via <a href="#configure/1"><code class="inline">Logger.configure/1</code></a>.</p>
<ul>
<li>
<p><code class="inline">:level</code> - the logging level. Attempting to log any message with severity less than the configured level will simply cause the message to be ignored. Keep in mind that each backend may have its specific level, too. In addition to levels mentioned above it also support 2 "meta-levels":</p>
<ul>
<li>
<code class="inline">:all</code> - all messages will be logged, conceptually identical to <code class="inline">:debug</code>
</li>
<li>
<code class="inline">:none</code> - no messages will be logged at all</li>
</ul>
</li>
<li><p><code class="inline">:utc_log</code> - when <code class="inline">true</code>, uses UTC in logs. By default it uses local time (i.e., it defaults to <code class="inline">false</code>).</p></li>
<li><p><code class="inline">:truncate</code> - the maximum message size to be logged (in bytes). Defaults to 8192 bytes. Note this configuration is approximate. Truncated messages will have <code class="inline">" (truncated)"</code> at the end. The atom <code class="inline">:infinity</code> can be passed to disable this behavior.</p></li>
<li><p><code class="inline">:sync_threshold</code> - if the <a href="logger#content"><code class="inline">Logger</code></a> manager has more than <code class="inline">:sync_threshold</code> messages in its queue, <a href="logger#content"><code class="inline">Logger</code></a> will change to <em>sync mode</em>, to apply backpressure to the clients. <a href="logger#content"><code class="inline">Logger</code></a> will return to <em>async mode</em> once the number of messages in the queue is reduced to one below the <code class="inline">sync_threshold</code>. Defaults to 20 messages. <code class="inline">:sync_threshold</code> can be set to <code class="inline">0</code> to force <em>sync mode</em>.</p></li>
<li><p><code class="inline">:discard_threshold</code> - if the <a href="logger#content"><code class="inline">Logger</code></a> manager has more than <code class="inline">:discard_threshold</code> messages in its queue, <a href="logger#content"><code class="inline">Logger</code></a> will change to <em>discard mode</em> and messages will be discarded directly in the clients. <a href="logger#content"><code class="inline">Logger</code></a> will return to <em>sync mode</em> once the number of messages in the queue is reduced to one below the <code class="inline">discard_threshold</code>. Defaults to 500 messages.</p></li>
<li><p><code class="inline">:discard_threshold_periodic_check</code> - a periodic check that checks and reports if logger is discarding messages. It logs a warning message whenever the system is (or continues) in discard mode and it logs a warning message whenever if the system was discarding messages but stopped doing so after the previous check. By default it runs every <code class="inline">30_000</code> milliseconds.</p></li>
<li><p><code class="inline">:translator_inspect_opts</code> - when translating OTP reports and errors, the last message and state must be inspected in the error reports. This configuration allow developers to change how much and how the data should be inspected.</p></li>
</ul>
<p>For example, to configure the <code class="inline">:level</code> and <code class="inline">:truncate</code> options in a <code class="inline">config/config.exs</code> file:</p>
<pre data-language="elixir">config :logger,
  level: :warning,
  truncate: 4096</pre>
<h3 id="module-erlang-otp-integration" class="section-heading">  Erlang/OTP integration </h3> <p>From Elixir v1.10, Elixir's Logger is fully integrated with Erlang's logger. They share the same <a href="#level/0"><code class="inline">Logger.level/0</code></a>, any metadata set with <a href="#metadata/1"><code class="inline">Logger.metadata/1</code></a> applies to both, and so on.</p>
<p>Elixir also supports formatting Erlang reports using Elixir syntax. This can be controlled with two configurations:</p>
<ul>
<li><p><code class="inline">:handle_otp_reports</code> - redirects OTP reports to <a href="logger#content"><code class="inline">Logger</code></a> so they are formatted in Elixir terms. This effectively disables Erlang standard logger. Defaults to <code class="inline">true</code>.</p></li>
<li><p><code class="inline">:handle_sasl_reports</code> - redirects supervisor, crash and progress reports to <a href="logger#content"><code class="inline">Logger</code></a> so they are formatted in Elixir terms. Your application must guarantee <code class="inline">:sasl</code> is started before <code class="inline">:logger</code>. This means you may see some initial reports written in Erlang syntax until the Logger application kicks in. Defaults to <code class="inline">false</code>. This option only has an effect if <code class="inline">:handle_otp_reports</code> is true.</p></li>
</ul>
<p>For example, to configure <a href="logger#content"><code class="inline">Logger</code></a> to redirect all Erlang messages using a <code class="inline">config/config.exs</code> file:</p>
<pre data-language="elixir">config :logger,
  handle_otp_reports: true,
  handle_sasl_reports: true</pre>
<p>Furthermore, <a href="logger#content"><code class="inline">Logger</code></a> allows messages sent by Erlang to be translated into an Elixir format via translators. Translators can be added at any time with the <a href="#add_translator/1"><code class="inline">add_translator/1</code></a> and <a href="#remove_translator/1"><code class="inline">remove_translator/1</code></a> APIs. Check <a href="logger.translator"><code class="inline">Logger.Translator</code></a> for more information.</p>
<h2 id="module-backends" class="section-heading">  Backends </h2> <p><a href="logger#content"><code class="inline">Logger</code></a> supports different backends where log messages are written to.</p>
<p>The available backends by default are:</p>
<ul><li>
<code class="inline">:console</code> - logs messages to the console (enabled by default). <code class="inline">:console</code> is simply a shortcut for <a href="logger.backends.console"><code class="inline">Logger.Backends.Console</code></a>.</li></ul>
<p>Developers may also implement their own backends, an option that is explored in more detail below.</p>
<p>The initial backends are loaded via the <code class="inline">:backends</code> configuration, which must be set before the <code class="inline">:logger</code> application is started. However, it preferred to add and remove backends via <a href="#add_backend/2"><code class="inline">add_backend/2</code></a> and <a href="#remove_backend/2"><code class="inline">remove_backend/2</code></a> functions. This is often done in your <a href="https://hexdocs.pm/elixir/1.12/Application.html#c:start/2"><code class="inline">Application.start/2</code></a> callback:</p>
<pre data-language="elixir">@impl true
def start(_type, _args) do
  Logger.add_backend(MyCustomBackend)</pre>
<p>The backend can be configured either on the <a href="#add_backend/2"><code class="inline">add_backend/2</code></a> call:</p>
<pre data-language="elixir">@impl true
def start(_type, _args) do
  Logger.add_backend(MyCustomBackend, some_config: ...)</pre>
<p>Or in your config files:</p>
<pre data-language="elixir">config :logger, MyCustomBackend,
  some_config: ...</pre>
<h3 id="module-elixir-custom-backends" class="section-heading">  Elixir custom backends </h3> <p>Any developer can create their own <a href="logger#content"><code class="inline">Logger</code></a> backend. Since <a href="logger#content"><code class="inline">Logger</code></a> is an event manager powered by <code class="inline">:gen_event</code>, writing a new backend is a matter of creating an event handler, as described in the <a href="https://erlang.org/doc/man/gen_event.html"><code class="inline">:gen_event</code></a> documentation.</p>
<p>From now on, we will be using the term "event handler" to refer to your custom backend, as we head into implementation details.</p>
<p>Once the <code class="inline">:logger</code> application starts, it installs all event handlers listed under the <code class="inline">:backends</code> configuration into the <a href="logger#content"><code class="inline">Logger</code></a> event manager. The event manager and all added event handlers are automatically supervised by <a href="logger#content"><code class="inline">Logger</code></a>.</p>
<p>Note that if a backend fails to start by returning <code class="inline">{:error, :ignore}</code> from its <code class="inline">init/1</code> callback, then it's not added to the backends but nothing fails. If a backend fails to start by returning <code class="inline">{:error, reason}</code> from its <code class="inline">init/1</code> callback, the <code class="inline">:logger</code> application will fail to start.</p>
<p>Once initialized, the handler should be designed to handle the following events:</p>
<ul>
<li>
<p><code class="inline">{level, group_leader, {Logger, message, timestamp, metadata}}</code> where:</p>
<ul>
<li>
<code class="inline">level</code> is one of <code class="inline">:debug</code>, <code class="inline">:info</code>, <code class="inline">:warn</code>, or <code class="inline">:error</code>, as previously described (for compatibility with pre 1.10 backends the <code class="inline">:notice</code> will be translated to <code class="inline">:info</code> and all messages above <code class="inline">:error</code> will be translated to <code class="inline">:error</code>)</li>
<li>
<code class="inline">group_leader</code> is the group leader of the process which logged the message</li>
<li>
<code class="inline">{Logger, message, timestamp, metadata}</code> is a tuple containing information about the logged message:<ul>
<li>the first element is always the atom <a href="logger#content"><code class="inline">Logger</code></a>
</li>
<li>
<code class="inline">message</code> is the actual message (as chardata)</li>
<li>
<code class="inline">timestamp</code> is the timestamp for when the message was logged, as a <code class="inline">{{year, month, day}, {hour, minute, second, millisecond}}</code> tuple</li>
<li>
<code class="inline">metadata</code> is a keyword list of metadata used when logging the message</li>
</ul>
</li>
</ul>
</li>
<li><p><code class="inline">:flush</code></p></li>
</ul>
<p>It is recommended that handlers ignore messages where the group leader is in a different node than the one where the handler is installed. For example:</p>
<pre data-language="elixir">def handle_event({_level, gl, {Logger, _, _, _}}, state)
    when node(gl) != node() do
  {:ok, state}
end</pre>
<p>In the case of the event <code class="inline">:flush</code> handlers should flush any pending data. This event is triggered by <a href="#flush/0"><code class="inline">Logger.flush/0</code></a>.</p>
<p>Furthermore, backends can be configured via the <a href="#configure_backend/2"><code class="inline">configure_backend/2</code></a> function which requires event handlers to handle calls of the following format:</p>
<pre data-language="elixir">{:configure, options}</pre>
<p>where <code class="inline">options</code> is a keyword list. The result of the call is the result returned by <a href="#configure_backend/2"><code class="inline">configure_backend/2</code></a>. The recommended return value for successful configuration is <code class="inline">:ok</code>. For example:</p>
<pre data-language="elixir">def handle_call({:configure, options}, state) do
  new_state = reconfigure_state(state, options)
  {:ok, :ok, new_state}
end</pre>
<p>It is recommended that backends support at least the following configuration options:</p>
<ul>
<li>
<code class="inline">:level</code> - the logging level for that backend</li>
<li>
<code class="inline">:format</code> - the logging format for that backend</li>
<li>
<code class="inline">:metadata</code> - the metadata to include in that backend</li>
</ul>
<p>Check the <a href="logger.backends.console"><code class="inline">Logger.Backends.Console</code></a> implementation in Elixir's codebase for examples on how to handle the recommendations in this section and how to process the existing options.</p>
<h3 id="module-erlang-otp-handlers" class="section-heading">  Erlang/OTP handlers </h3> <p>While Elixir Logger provides backends, Erlang/OTP logger provides handlers. They represent the same concept: the ability to integrate into the logging system to handle each logged message/event.</p>
<p>However, implementation-wise, they have the following differences:</p>
<ul>
<li><p>Elixir backends run in a separate process which comes with overload protection. However, because this process is a single GenEvent, any long running action should be avoided, as it can lead to bottlenecks in the system</p></li>
<li><p>Erlang handlers run in the same process as the process logging the message/event. This gives developers more flexibility but they should avoid performing any long running action in such handlers, as it may slow down the action being executed considerably. At the moment, there is no built-in overload protection for Erlang handlers, so it is your responsibility to implement it</p></li>
</ul>
<p>The good news is that developers can use third-party implementations of both Elixir backends and Erlang handlers. We have already covered Elixir backends, so let's see how to add Erlang/OTP handlers.</p>
<p>Erlang/OTP handlers must be listed under your own application:</p>
<pre data-language="elixir">config :my_app, :logger, [
  {:handler, :name_of_the_handler, ACustomHandler, configuration = %{}}
]</pre>
<p>And then, explicitly attached in your <a href="https://hexdocs.pm/elixir/1.12/Application.html#c:start/2"><code class="inline">Application.start/2</code></a> callback:</p>
<pre data-language="elixir">:logger.add_handlers(:my_app)</pre>
<p>Note we do not recommend configuring Erlang/OTP's logger directly under the <code class="inline">:kernel</code> application in your <code class="inline">config/config.exs</code>, like this:</p>
<pre data-language="elixir"># Not recommended:
config :kernel, :logger, ...</pre>
<p>This is because by the time Elixir starts, Erlang's kernel has already been started, which means the configuration above would have no effect.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:backend/0">backend()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:level/0">level()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:message/0">message()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:metadata/0">metadata()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:report/0">report()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#add_backend/2">add_backend(backend, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Adds a new backend.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#add_translator/1">add_translator(translator)</a> </dt> <dd class="summary-synopsis"><p>Adds a new translator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#alert/2">alert(message_or_fun, metadata \\ [])</a> </dt> <dd class="summary-synopsis"><p>Logs a alert message.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#bare_log/3">bare_log(level, message_or_fun, metadata \\ [])</a> </dt> <dd class="summary-synopsis"><p>Logs a message dynamically.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#compare_levels/2">compare_levels(left, right)</a> </dt> <dd class="summary-synopsis"><p>Compares log levels.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#configure/1">configure(options)</a> </dt> <dd class="summary-synopsis"><p>Configures the logger.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#configure_backend/2">configure_backend(backend, options)</a> </dt> <dd class="summary-synopsis"><p>Configures the given backend.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#critical/2">critical(message_or_fun, metadata \\ [])</a> </dt> <dd class="summary-synopsis"><p>Logs a critical message.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#debug/2">debug(message_or_fun, metadata \\ [])</a> </dt> <dd class="summary-synopsis"><p>Logs a debug message.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete_all_module_levels/0">delete_all_module_levels()</a> </dt> <dd class="summary-synopsis"><p>Deletes logging level for all modules to primary level</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete_module_level/1">delete_module_level(module)</a> </dt> <dd class="summary-synopsis"><p>Deletes logging level for given module to primary level.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#disable/1">disable(pid)</a> </dt> <dd class="summary-synopsis"><p>Disables logging for the current process.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#emergency/2">emergency(message_or_fun, metadata \\ [])</a> </dt> <dd class="summary-synopsis"><p>Logs a emergency message.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#enable/1">enable(pid)</a> </dt> <dd class="summary-synopsis"><p>Enables logging for the current process.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#enabled?/1">enabled?(pid)</a> </dt> <dd class="summary-synopsis"><p>Returns whether the logging is enabled for given process.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#error/2">error(message_or_fun, metadata \\ [])</a> </dt> <dd class="summary-synopsis"><p>Logs a error message.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#flush/0">flush()</a> </dt> <dd class="summary-synopsis"><p>Flushes the logger.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_module_level/1">get_module_level(mod)</a> </dt> <dd class="summary-synopsis"><p>Gets logging level for given module.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#info/2">info(message_or_fun, metadata \\ [])</a> </dt> <dd class="summary-synopsis"><p>Logs a info message.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#level/0">level()</a> </dt> <dd class="summary-synopsis"><p>Retrieves the <a href="logger#content"><code class="inline">Logger</code></a> level.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#log/3">log(level, message_or_fun, metadata \\ [])</a> </dt> <dd class="summary-synopsis"><p>Logs a message with the given <code class="inline">level</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#metadata/0">metadata()</a> </dt> <dd class="summary-synopsis"><p>Reads the current process metadata.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#metadata/1">metadata(keyword)</a> </dt> <dd class="summary-synopsis"><p>Alters the current process metadata according the given keyword list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#notice/2">notice(message_or_fun, metadata \\ [])</a> </dt> <dd class="summary-synopsis"><p>Logs a notice message.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_module_level/2">put_module_level(mod, level)</a> </dt> <dd class="summary-synopsis"><p>Puts logging level for given module.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#remove_backend/2">remove_backend(backend, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Removes a backend.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#remove_translator/1">remove_translator(translator)</a> </dt> <dd class="summary-synopsis"><p>Removes a translator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reset_metadata/1">reset_metadata(keyword \\ [])</a> </dt> <dd class="summary-synopsis"><p>Resets the current process metadata to the given keyword list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#warn/2">warn(message_or_fun, metadata \\ [])</a> </dt> <dd class="summary-synopsis"><p>Logs a warning message.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#warning/2">warning(message_or_fun, metadata \\ [])</a> </dt> <dd class="summary-synopsis"><p>Logs a warning message.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:backend/0">backend()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L434" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">backend() :: :gen_event.handler()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:level/0">level()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L432" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">level() ::
  :emergency
  | :alert
  | :critical
  | :error
  | :warning
  | :warn
  | :notice
  | :info
  | :debug</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:message/0">message()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L436" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">message() :: :unicode.chardata() | String.Chars.t() | report()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:metadata/0">metadata()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L437" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">metadata() :: keyword()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:report/0">report()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L435" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">report() :: map() | keyword()</pre> </div> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail">  <h3 class="detail-header" id="add_backend/2">add_backend(backend, opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L689" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">add_backend(backend(), keyword()) :: Supervisor.on_start_child()</pre> </div> <p>Adds a new backend.</p>
<p>Adding a backend calls the <code class="inline">init/1</code> function in that backend with the name of the backend as its argument. For example, calling</p>
<pre data-language="elixir">Logger.add_backend(MyBackend)</pre>
<p>will call <code class="inline">MyBackend.init(MyBackend)</code> to initialize the new backend. If the backend's <code class="inline">init/1</code> callback returns <code class="inline">{:ok, _}</code>, then this function returns <code class="inline">{:ok, pid}</code>. If the handler returns <code class="inline">{:error, :ignore}</code> from <code class="inline">init/1</code>, this function still returns <code class="inline">{:ok, pid}</code> but the handler is not started. If the handler returns <code class="inline">{:error, reason}</code> from <code class="inline">init/1</code>, this function returns <code class="inline">{:error, {reason, info}}</code> where <code class="inline">info</code> is more information on the backend that failed to start.</p>
<p>Backends added by this function are not persisted. Therefore if the Logger application or supervision tree is restarted, the backend won't be available. If you need this guarantee, then configure the backend via the application environment:</p>
<pre data-language="elixir">config :logger, :backends, [MyBackend]</pre>
<h4 id="add_backend/2-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:flush</code> - when <code class="inline">true</code>, guarantees all messages currently sent to <a href="logger#content"><code class="inline">Logger</code></a> are processed before the backend is added</li></ul>
<h4 id="add_backend/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, _pid} = Logger.add_backend(MyBackend, flush: true)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="add_translator/1">add_translator(translator)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L723" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">add_translator({module(), function :: atom()}) :: :ok</pre> </div> <p>Adds a new translator.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="alert/2">alert(message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L849" class="source">Source</a>
</h3> <section class="docstring"> <p>Logs a alert message.</p>
<p>Returns <code class="inline">:ok</code>.</p>
<p>This is reported as "error" in Elixir's logger backends for backwards compatibility reasons.</p>
<h4 id="alert/2-examples" class="section-heading">  Examples </h4> <p>Logging a message (string or iodata):</p>
<pre data-language="elixir">Logger.alert("this is a alert message")</pre>
<p>Report message (maps or keywords):</p>
<pre data-language="elixir"># as keyword list
Logger.alert([something: :reported, this: :alert])

# as map
Logger.alert(%{something: :reported, this: :alert})</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="bare_log/3">bare_log(level, message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L756" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">bare_log(
  level(),
  message() | (() -&gt; message() | {message(), keyword()}),
  keyword()
) :: :ok</pre> </div> <p>Logs a message dynamically.</p>
<p>Opposite to <a href="#log/3"><code class="inline">log/3</code></a>, <a href="#debug/2"><code class="inline">debug/2</code></a>, <a href="#info/2"><code class="inline">info/2</code></a>, and friends, the arguments given to <a href="#bare_log/3"><code class="inline">bare_log/3</code></a> are always evaluated. However, you can pass anonymous functions to <a href="#bare_log/3"><code class="inline">bare_log/3</code></a> and they will only be evaluated if there is something to be logged.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="compare_levels/2">compare_levels(left, right)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L554" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">compare_levels(level(), level()) :: :lt | :eq | :gt</pre> </div> <p>Compares log levels.</p>
<p>Receives two log levels and compares the <code class="inline">left</code> level against the <code class="inline">right</code> level and returns:</p>
<ul>
<li>
<code class="inline">:lt</code> if <code class="inline">left</code> is less than <code class="inline">right</code>
</li>
<li>
<code class="inline">:eq</code> if <code class="inline">left</code> and <code class="inline">right</code> are equal</li>
<li>
<code class="inline">:gt</code> if <code class="inline">left</code> is greater than <code class="inline">right</code>
</li>
</ul>
<h4 id="compare_levels/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Logger.compare_levels(:debug, :warning)
:lt
iex&gt; Logger.compare_levels(:error, :info)
:gt</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="configure/1">configure(options)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L581" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">configure(keyword()) :: :ok</pre> </div> <p>Configures the logger.</p>
<p>See the "Runtime Configuration" section in the <a href="logger#content"><code class="inline">Logger</code></a> module documentation for the available options. The changes done here are automatically persisted to the <code class="inline">:logger</code> application environment.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="configure_backend/2">configure_backend(backend, options)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L742" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">configure_backend(backend(), keyword()) :: term()</pre> </div> <p>Configures the given backend.</p>
<p>The backend needs to be started and running in order to be configured at runtime.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="critical/2">critical(message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L849" class="source">Source</a>
</h3> <section class="docstring"> <p>Logs a critical message.</p>
<p>Returns <code class="inline">:ok</code>.</p>
<p>This is reported as "error" in Elixir's logger backends for backwards compatibility reasons.</p>
<h4 id="critical/2-examples" class="section-heading">  Examples </h4> <p>Logging a message (string or iodata):</p>
<pre data-language="elixir">Logger.critical("this is a critical message")</pre>
<p>Report message (maps or keywords):</p>
<pre data-language="elixir"># as keyword list
Logger.critical([something: :reported, this: :critical])

# as map
Logger.critical(%{something: :reported, this: :critical})</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="debug/2">debug(message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L849" class="source">Source</a>
</h3> <section class="docstring"> <p>Logs a debug message.</p>
<p>Returns <code class="inline">:ok</code>.</p>
<h4 id="debug/2-examples" class="section-heading">  Examples </h4> <p>Logging a message (string or iodata):</p>
<pre data-language="elixir">Logger.debug("this is a debug message")</pre>
<p>Report message (maps or keywords):</p>
<pre data-language="elixir"># as keyword list
Logger.debug([something: :reported, this: :debug])

# as map
Logger.debug(%{something: :reported, this: :debug})</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="delete_all_module_levels/0">delete_all_module_levels()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L651" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">delete_all_module_levels() :: :ok</pre> </div> <p>Deletes logging level for all modules to primary level</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="delete_module_level/1">delete_module_level(module)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L644" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">delete_module_level(module() | [module()]) :: :ok</pre> </div> <p>Deletes logging level for given module to primary level.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="disable/1">disable(pid)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L507" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">disable(pid()) :: :ok</pre> </div> <p>Disables logging for the current process.</p>
<p>Currently the only accepted PID is <code class="inline">self()</code>.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="emergency/2">emergency(message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L849" class="source">Source</a>
</h3> <section class="docstring"> <p>Logs a emergency message.</p>
<p>Returns <code class="inline">:ok</code>.</p>
<p>This is reported as "error" in Elixir's logger backends for backwards compatibility reasons.</p>
<h4 id="emergency/2-examples" class="section-heading">  Examples </h4> <p>Logging a message (string or iodata):</p>
<pre data-language="elixir">Logger.emergency("this is a emergency message")</pre>
<p>Report message (maps or keywords):</p>
<pre data-language="elixir"># as keyword list
Logger.emergency([something: :reported, this: :emergency])

# as map
Logger.emergency(%{something: :reported, this: :emergency})</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="enable/1">enable(pid)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L496" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">enable(pid()) :: :ok</pre> </div> <p>Enables logging for the current process.</p>
<p>Currently the only accepted PID is <code class="inline">self()</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="enabled?/1">enabled?(pid)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L519" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">enabled?(pid()) :: boolean()</pre> </div> <p>Returns whether the logging is enabled for given process.</p>
<p>Currently the only accepted PID is <code class="inline">self()</code>.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="error/2">error(message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L849" class="source">Source</a>
</h3> <section class="docstring"> <p>Logs a error message.</p>
<p>Returns <code class="inline">:ok</code>.</p>
<h4 id="error/2-examples" class="section-heading">  Examples </h4> <p>Logging a message (string or iodata):</p>
<pre data-language="elixir">Logger.error("this is a error message")</pre>
<p>Report message (maps or keywords):</p>
<pre data-language="elixir"># as keyword list
Logger.error([something: :reported, this: :error])

# as map
Logger.error(%{something: :reported, this: :error})</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="flush/0">flush()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L599" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">flush() :: :ok</pre> </div> <p>Flushes the logger.</p>
<p>This guarantees all messages sent to <a href="logger#content"><code class="inline">Logger</code></a> prior to this call will be processed. This is useful for testing and it should not be called in production code.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_module_level/1">get_module_level(mod)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L637" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">get_module_level(module() | [module()]) :: [{module(), level() | :all | :none}]</pre> </div> <p>Gets logging level for given module.</p>
<p>Returned value will be the effective value used. If no value was set for given module, then it will not be present in the returned list.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="info/2">info(message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L849" class="source">Source</a>
</h3> <section class="docstring"> <p>Logs a info message.</p>
<p>Returns <code class="inline">:ok</code>.</p>
<h4 id="info/2-examples" class="section-heading">  Examples </h4> <p>Logging a message (string or iodata):</p>
<pre data-language="elixir">Logger.info("this is a info message")</pre>
<p>Report message (maps or keywords):</p>
<pre data-language="elixir"># as keyword list
Logger.info([something: :reported, this: :info])

# as map
Logger.info(%{something: :reported, this: :info})</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="level/0">level()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L529" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">level() :: level()</pre> </div> <p>Retrieves the <a href="logger#content"><code class="inline">Logger</code></a> level.</p>
<p>The <a href="logger#content"><code class="inline">Logger</code></a> level can be changed via <a href="#configure/1"><code class="inline">configure/1</code></a>.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="log/3">log(level, message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L882" class="source">Source</a>
</h3> <section class="docstring"> <p>Logs a message with the given <code class="inline">level</code>.</p>
<p>Returns <code class="inline">:ok</code>.</p>
<p>The macros <a href="#debug/2"><code class="inline">debug/2</code></a>, <a href="#info/2"><code class="inline">info/2</code></a>, <a href="#notice/2"><code class="inline">notice/2</code></a>, <a href="#warning/2"><code class="inline">warning/2</code></a>, <a href="#error/2"><code class="inline">error/2</code></a>, <a href="#critical/2"><code class="inline">critical/2</code></a>, <a href="#alert/2"><code class="inline">alert/2</code></a>, and <a href="#emergency/2"><code class="inline">emergency/2</code></a> are preferred over this macro as they can automatically eliminate the call to <a href="logger#content"><code class="inline">Logger</code></a> altogether at compile time if desired (see the documentation for the <a href="logger#content"><code class="inline">Logger</code></a> module).</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="metadata/0">metadata()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L471" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">metadata() :: metadata()</pre> </div> <p>Reads the current process metadata.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="metadata/1">metadata(keyword)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L451" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">metadata(metadata()) :: :ok</pre> </div> <p>Alters the current process metadata according the given keyword list.</p>
<p>This function will merge the given keyword list into the existing metadata, with the exception of setting a key to <code class="inline">nil</code>, which will remove that key from the metadata.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="notice/2">notice(message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L849" class="source">Source</a>
</h3> <section class="docstring"> <p>Logs a notice message.</p>
<p>Returns <code class="inline">:ok</code>.</p>
<p>This is reported as "info" in Elixir's logger backends for backwards compatibility reasons.</p>
<h4 id="notice/2-examples" class="section-heading">  Examples </h4> <p>Logging a message (string or iodata):</p>
<pre data-language="elixir">Logger.notice("this is a notice message")</pre>
<p>Report message (maps or keywords):</p>
<pre data-language="elixir"># as keyword list
Logger.notice([something: :reported, this: :notice])

# as map
Logger.notice(%{something: :reported, this: :notice})</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_module_level/2">put_module_level(mod, level)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L626" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">put_module_level(module(), level() | :all | :none) :: :ok | {:error, term()}</pre> </div> <p>Puts logging level for given module.</p>
<p>This will take priority over the primary level set, so it can be used to increase or decrease verbosity of some parts of the project.</p>
<h4 id="put_module_level/2-example" class="section-heading">  Example </h4> <pre data-language="elixir">defmodule Foo do
  require Logger

  def log, do: Logger.debug("foo")
end

Logger.configure(level: :error)
Logger.put_module_level(Foo, :all)

Foo.log()
# This will print the message even if global level is :error</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="remove_backend/2">remove_backend(backend, opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L714" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">remove_backend(backend(), keyword()) :: :ok | {:error, term()}</pre> </div> <p>Removes a backend.</p>
<h4 id="remove_backend/2-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:flush</code> - when <code class="inline">true</code>, guarantees all messages currently sent to <a href="logger#content"><code class="inline">Logger</code></a> are processed before the backend is removed</li></ul> </section> </section> <section class="detail"> <h3 class="detail-header" id="remove_translator/1">remove_translator(translator)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L731" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">remove_translator({module(), function :: atom()}) :: :ok</pre> </div> <p>Removes a translator.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="reset_metadata/1">reset_metadata(keyword \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L482" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">reset_metadata(metadata()) :: :ok</pre> </div> <p>Resets the current process metadata to the given keyword list.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="warn/2">warn(message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L867" class="source">Source</a>
</h3> <section class="docstring"> <p>Logs a warning message.</p>
<p>Returns <code class="inline">:ok</code>.</p>
<p>This macro is deprecated in favour of <a href="#warning/2"><code class="inline">warning/2</code></a>.</p>
<h4 id="warn/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Logger.warn("knob turned too far to the right")</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="warning/2">warning(message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/logger/lib/logger.ex#L849" class="source">Source</a>
</h3> <section class="docstring"> <p>Logs a warning message.</p>
<p>Returns <code class="inline">:ok</code>.</p>
<p>This is reported as "warn" in Elixir's logger backends for backwards compatibility reasons.</p>
<h4 id="warning/2-examples" class="section-heading">  Examples </h4> <p>Logging a message (string or iodata):</p>
<pre data-language="elixir">Logger.warning("this is a warning message")</pre>
<p>Report message (maps or keywords):</p>
<pre data-language="elixir"># as keyword list
Logger.warning([something: :reported, this: :warning])

# as map
Logger.warning(%{something: :reported, this: :warning})</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/logger/1.12.0/Logger.html" class="_attribution-link" target="_blank">https://hexdocs.pm/logger/1.12.0/Logger.html</a>
  </p>
</div>
