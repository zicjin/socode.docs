<h1> Macro   </h1> <section id="moduledoc"> <p>Macros are compile-time constructs that are invoked with Elixir's AST as input and a superset of Elixir's AST as output.</p>
<p>Let's see a simple example that shows the difference between functions and macros:</p>
<pre data-language="elixir">defmodule Example do
  defmacro macro_inspect(value) do
    IO.inspect(value)
    value
  end

  def fun_inspect(value) do
    IO.inspect(value)
    value
  end
end</pre>
<p>Now let's give it a try:</p>
<pre data-language="elixir">import Example

macro_inspect(1)
#=&gt; 1
#=&gt; 1

fun_inspect(1)
#=&gt; 1
#=&gt; 1</pre>
<p>So far they behave the same, as we are passing an integer as argument. But what happens when we pass an expression:</p>
<pre data-language="elixir">macro_inspect(1 + 2)
#=&gt; {:+, [line: 3], [1, 2]}
#=&gt; 3

fun_inspect(1 + 2)
#=&gt; 3
#=&gt; 3</pre>
<p>The macro receives the representation of the code given as argument, while a function receives the result of the code given as argument. A macro must return a superset of the code representation. See <a href="#t:input/0"><code class="inline">input/0</code></a> and <a href="#t:output/0"><code class="inline">output/0</code></a> for more information.</p>
<p>To learn more about Elixir's AST and how to build them programmatically, see <a href="kernel.specialforms#quote/2"><code class="inline">quote/2</code></a>.</p>
<h2 id="module-custom-sigils" class="section-heading">  Custom Sigils </h2> <p>Macros are also commonly used to implement custom sigils. To create a custom sigil, define a function with the name <code class="inline">sigil_{identifier}</code> that takes two arguments. The first argument will be the string, the second will be a charlist containing any modifiers. If the sigil is lower case (such as <code class="inline">sigil_x</code>) then the string argument will allow interpolation. If the sigil is upper case (such as <code class="inline">sigil_X</code>) then the string will not be interpolated.</p>
<p>Valid modifiers include only lower and upper case letters. Other characters will cause a syntax error.</p>
<p>The module containing the custom sigil must be imported before the sigil syntax can be used.</p>
<h3 id="module-examples" class="section-heading">  Examples </h3> <pre data-language="elixir">defmodule MySigils do
  defmacro sigil_x(term, [?r]) do
    quote do
      unquote(term) |&gt; String.reverse()
    end
  end
  defmacro sigil_x(term, _modifiers) do
    term
  end
  defmacro sigil_X(term, [?r]) do
    quote do
      unquote(term) |&gt; String.reverse()
    end
  end
  defmacro sigil_X(term, _modifiers) do
    term
  end
end

import MySigils

~x(with #{"inter" &lt;&gt; "polation"})
#=&gt;"with interpolation"

~x(with #{"inter" &lt;&gt; "polation"})r
#=&gt;"noitalopretni htiw"

~X(without #{"interpolation"})
#=&gt;"without \#{"interpolation"}"

~X(without #{"interpolation"})r
#=&gt;"}\"noitalopretni\"{# tuohtiw"</pre> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:captured_remote_function/0">captured_remote_function()</a> </dt> <dd class="summary-synopsis"><p>A captured remote function in the format of &amp;Mod.fun/arity</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:input/0">input()</a> </dt> <dd class="summary-synopsis"><p>The inputs of a macro</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:metadata/0">metadata()</a> </dt> <dd class="summary-synopsis"><p>A keyword list of AST metadata.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:output/0">output()</a> </dt> <dd class="summary-synopsis"><p>The output of a macro</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt> <dd class="summary-synopsis"><p>Abstract Syntax Tree (AST)</p></dd> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#camelize/1">camelize(string)</a> </dt> <dd class="summary-synopsis"><p>Converts the given string to CamelCase format.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#decompose_call/1">decompose_call(ast)</a> </dt> <dd class="summary-synopsis"><p>Decomposes a local or remote call into its remote part (when provided), function name and argument list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#escape/2">escape(expr, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Recursively escapes a value so it can be inserted into a syntax tree.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#expand/2">expand(ast, env)</a> </dt> <dd class="summary-synopsis"><p>Receives an AST node and expands it until it can no longer be expanded.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#expand_once/2">expand_once(ast, env)</a> </dt> <dd class="summary-synopsis"><p>Receives an AST node and expands it once.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#generate_arguments/2">generate_arguments(amount, context)</a> </dt> <dd class="summary-synopsis"><p>Generates AST nodes for a given number of required argument variables using <a href="#var/2"><code class="inline">Macro.var/2</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#generate_unique_arguments/2">generate_unique_arguments(amount, context)</a> </dt> <dd class="summary-synopsis"><p>Generates AST nodes for a given number of required argument variables using <a href="#unique_var/2"><code class="inline">Macro.unique_var/2</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#operator?/2">operator?(name, arity)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if the given name and arity is an operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#pipe/3">pipe(expr, call_args, position)</a> </dt> <dd class="summary-synopsis"><p>Pipes <code class="inline">expr</code> into the <code class="inline">call_args</code> at the given <code class="inline">position</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#postwalk/2">postwalk(ast, fun)</a> </dt> <dd class="summary-synopsis"><p>Performs a depth-first, post-order traversal of quoted expressions.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#postwalk/3">postwalk(ast, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Performs a depth-first, post-order traversal of quoted expressions using an accumulator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#prewalk/2">prewalk(ast, fun)</a> </dt> <dd class="summary-synopsis"><p>Performs a depth-first, pre-order traversal of quoted expressions.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#prewalk/3">prewalk(ast, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Performs a depth-first, pre-order traversal of quoted expressions using an accumulator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#quoted_literal?/1">quoted_literal?(term)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if the given quoted expression represents a quoted literal.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#special_form?/2">special_form?(name, arity)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if the given name and arity is a special form.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#struct!/2">struct!(module, env)</a> </dt> <dd class="summary-synopsis"><p>Expands the struct given by <code class="inline">module</code> in the given <code class="inline">env</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_string/2">to_string(tree, fun \\ fn _ast, string -&gt; string end)</a> </dt> <dd class="summary-synopsis"><p>Converts the given expression AST to a string.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#traverse/4">traverse(ast, acc, pre, post)</a> </dt> <dd class="summary-synopsis"><p>Performs a depth-first traversal of quoted expressions using an accumulator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#underscore/1">underscore(atom)</a> </dt> <dd class="summary-synopsis"><p>Converts the given atom or binary to underscore format.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#unescape_string/1">unescape_string(string)</a> </dt> <dd class="summary-synopsis"><p>Unescapes the given chars.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#unescape_string/2">unescape_string(string, map)</a> </dt> <dd class="summary-synopsis"><p>Unescapes the given chars according to the map given.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#unique_var/2">unique_var(var, context)</a> </dt> <dd class="summary-synopsis"><p>Generates an AST node representing a unique variable given by the atoms <code class="inline">var</code> and <code class="inline">context</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#unpipe/1">unpipe(expr)</a> </dt> <dd class="summary-synopsis"><p>Breaks a pipeline expression into a list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#update_meta/2">update_meta(quoted, fun)</a> </dt> <dd class="summary-synopsis"><p>Applies the given function to the node metadata if it contains one.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#validate/1">validate(expr)</a> </dt> <dd class="summary-synopsis"><p>Validates the given expressions are valid quoted expressions.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#var/2">var(var, context)</a> </dt> <dd class="summary-synopsis"><p>Generates an AST node representing the variable given by the atoms <code class="inline">var</code> and <code class="inline">context</code>.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:captured_remote_function/0">captured_remote_function()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L196" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">captured_remote_function() :: (... -&gt; any())</pre> </div> <p>A captured remote function in the format of &amp;Mod.fun/arity</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:input/0">input()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L111" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">input() ::
  input_expr() | {input(), input()} | [input()] | atom() | number() | binary()</pre> </div> <p>The inputs of a macro</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:metadata/0">metadata()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L193" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">metadata() :: keyword()</pre> </div> <p>A keyword list of AST metadata.</p>
<p>The metadata in Elixir AST is a keyword list of values. Any key can be used and different parts of the compiler may use different keys. For example, the AST received by a macro will always include the <code class="inline">:line</code> annotation, while the AST emitted by <a href="kernel.specialforms#quote/2"><code class="inline">quote/2</code></a> will only have the <code class="inline">:line</code> annotation if the <code class="inline">:line</code> option is provided.</p>
<p>The following metadata keys are public:</p>
<ul>
<li>
<code class="inline">:context</code> - Defines the context in which the AST was generated. For example, <a href="kernel.specialforms#quote/2"><code class="inline">quote/2</code></a> will include the module calling <a href="kernel.specialforms#quote/2"><code class="inline">quote/2</code></a> as the context. This is often used to distinguish regular code from code generated by a macro or by <a href="kernel.specialforms#quote/2"><code class="inline">quote/2</code></a>.</li>
<li>
<code class="inline">:counter</code> - The variable counter used for variable hygiene. In terms of the compiler, each variable is identified by the combination of either <code class="inline">name</code> and <code class="inline">metadata[:counter]</code>, or <code class="inline">name</code> and <code class="inline">context</code>.</li>
<li>
<code class="inline">:generated</code> - Whether the code should be considered as generated by the compiler or not. This means the compiler and tools like Dialyzer may not emit certain warnings.</li>
<li>
<code class="inline">:keep</code> - Used by <a href="kernel.specialforms#quote/2"><code class="inline">quote/2</code></a> with the option <code class="inline">location: :keep</code> to annotate the file and the line number of the quoted source.</li>
<li>
<code class="inline">:line</code> - The line number of the AST node.</li>
</ul>
<p>The following metadata keys are enabled by <a href="code#string_to_quoted/2"><code class="inline">Code.string_to_quoted/2</code></a>:</p>
<ul>
<li>
<code class="inline">:closing</code> - contains metadata about the closing pair, such as a <code class="inline">}</code> in a tuple or in a map, or such as the closing <code class="inline">)</code> in a function call with parens. The <code class="inline">:closing</code> does not delimit the end of expression if there are <code class="inline">:do</code> and <code class="inline">:end</code> metadata (when <code class="inline">:token_metadata</code> is true)</li>
<li>
<code class="inline">:column</code> - the column number of the AST node (when <code class="inline">:columns</code> is true)</li>
<li>
<code class="inline">:delimiter</code> - contains the opening delimiter for sigils, strings, and charlists as a string (such as <code class="inline">"{"</code>, <code class="inline">"/"</code>, <code class="inline">"'"</code>, and the like)</li>
<li>
<code class="inline">:format</code> - set to <code class="inline">:keyword</code> when an atom is defined as a keyword</li>
<li>
<code class="inline">:do</code> - contains metadata about the <code class="inline">do</code> location in a function call with <code class="inline">do/end</code> blocks (when <code class="inline">:token_metadata</code> is true)</li>
<li>
<code class="inline">:end</code> - contains metadata about the <code class="inline">end</code> location in a function call with <code class="inline">do/end</code> blocks (when <code class="inline">:token_metadata</code> is true)</li>
<li>
<code class="inline">:end_of_expression</code> - denotes when the end of expression effectively happens. Available for all expressions except the last one inside a <code class="inline">__block__</code> (when <code class="inline">:token_metadata</code> is true)</li>
<li>
<code class="inline">:indentation</code> - indentation of a sigil heredoc</li>
</ul>
<p>The following metadata keys are private:</p>
<ul>
<li>
<code class="inline">:alias</code> - Used for alias hygiene.</li>
<li>
<code class="inline">:ambiguous_op</code> - Used for improved error messages in the compiler.</li>
<li>
<code class="inline">:import</code> - Used for import hygiene.</li>
<li>
<code class="inline">:var</code> - Used for improved error messages on undefined variables.</li>
</ul>
<p>Do not rely on them as they may change or be fully removed in future versions of the language. They are often used by <a href="kernel.specialforms#quote/2"><code class="inline">quote/2</code></a> and the compiler to provide features like hygiene, better error messages, and so forth.</p>
<p>If you introduce custom keys into the AST metadata, please make sure to prefix them with the name of your library or application, so that they will not conflict with keys that could potentially be introduced by the compiler in the future.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:output/0">output()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L122" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">output() ::
  output_expr()
  | {output(), output()}
  | [output()]
  | atom()
  | number()
  | binary()
  | captured_remote_function()
  | pid()</pre> </div> <p>The output of a macro</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L108" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">t() :: input()</pre> </div> <p>Abstract Syntax Tree (AST)</p> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="camelize/1">camelize(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L1727" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">camelize(String.t()) :: String.t()</pre> </div> <p>Converts the given string to CamelCase format.</p>
<p>This function was designed to camelize language identifiers/tokens, that's why it belongs to the <a href="macro#content"><code class="inline">Macro</code></a> module. Do not use it as a general mechanism for camelizing strings as it does not support Unicode or characters that are not valid in Elixir identifiers.</p>
<h4 id="camelize/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Macro.camelize("foo_bar")
"FooBar"</pre>
<p>If uppercase characters are present, they are not modified in any way as a mechanism to preserve acronyms:</p>
<pre data-language="elixir">iex&gt; Macro.camelize("API.V1")
"API.V1"
iex&gt; Macro.camelize("API_SPEC")
"API_SPEC"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="decompose_call/1">decompose_call(ast)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L553" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">decompose_call(t()) :: {atom(), [t()]} | {t(), atom(), [t()]} | :error</pre> </div> <p>Decomposes a local or remote call into its remote part (when provided), function name and argument list.</p>
<p>Returns <code class="inline">:error</code> when an invalid call syntax is provided.</p>
<h4 id="decompose_call/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Macro.decompose_call(quote(do: foo))
{:foo, []}

iex&gt; Macro.decompose_call(quote(do: foo()))
{:foo, []}

iex&gt; Macro.decompose_call(quote(do: foo(1, 2, 3)))
{:foo, [1, 2, 3]}

iex&gt; Macro.decompose_call(quote(do: Elixir.M.foo(1, 2, 3)))
{{:__aliases__, [], [:Elixir, :M]}, :foo, [1, 2, 3]}

iex&gt; Macro.decompose_call(quote(do: 42))
:error

iex&gt; Macro.decompose_call(quote(do: {:foo, [], []}))
:error</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="escape/2">escape(expr, opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L628" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">escape(term(), keyword()) :: t()</pre> </div> <p>Recursively escapes a value so it can be inserted into a syntax tree.</p>
<h4 id="escape/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Macro.escape(:foo)
:foo

iex&gt; Macro.escape({:a, :b, :c})
{:{}, [], [:a, :b, :c]}

iex&gt; Macro.escape({:unquote, [], [1]}, unquote: true)
1</pre>
<h4 id="escape/2-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:unquote</code> - when true, this function leaves <a href="kernel.specialforms#unquote/1"><code class="inline">unquote/1</code></a> and <a href="kernel.specialforms#unquote_splicing/1"><code class="inline">unquote_splicing/1</code></a> statements unescaped, effectively unquoting the contents on escape. This option is useful only when escaping ASTs which may have quoted fragments in them. Defaults to false.</p></li>
<li>
<p><code class="inline">:prune_metadata</code> - when true, removes metadata from escaped AST nodes. Note this option changes the semantics of escaped code and it should only be used when escaping ASTs, never values. Defaults to false.</p>
<p>As an example, <a href="https://hexdocs.pm/ex_unit/1.12/ExUnit.html"><code class="inline">ExUnit</code></a> stores the AST of every assertion, so when an assertion fails we can show code snippets to users. Without this option, each time the test module is compiled, we get a different MD5 of the module bytecode, because the AST contains metadata, such as counters, specific to the compilation environment. By pruning the metadata, we ensure that the module is deterministic and reduce the amount of data <a href="https://hexdocs.pm/ex_unit/1.12/ExUnit.html"><code class="inline">ExUnit</code></a> needs to keep around.</p>
</li>
</ul>
<h4 id="escape/2-comparison-to-kernel-specialforms-quote-2" class="section-heading">  Comparison to <a href="kernel.specialforms#quote/2"><code class="inline">Kernel.SpecialForms.quote/2</code></a> </h4> <p>The <a href="#escape/2"><code class="inline">escape/2</code></a> function is sometimes confused with <a href="kernel.specialforms#quote/2"><code class="inline">Kernel.SpecialForms.quote/2</code></a>, because the above examples behave the same with both. The key difference is best illustrated when the value to escape is stored in a variable.</p>
<pre data-language="elixir">iex&gt; Macro.escape({:a, :b, :c})
{:{}, [], [:a, :b, :c]}
iex&gt; quote do: {:a, :b, :c}
{:{}, [], [:a, :b, :c]}

iex&gt; value = {:a, :b, :c}
iex&gt; Macro.escape(value)
{:{}, [], [:a, :b, :c]}

iex&gt; quote do: value
{:value, [], __MODULE__}

iex&gt; value = {:a, :b, :c}
iex&gt; quote do: unquote(value)
{:a, :b, :c}</pre>
<p><a href="#escape/2"><code class="inline">escape/2</code></a> is used to escape <em>values</em> (either directly passed or variable bound), while <a href="kernel.specialforms#quote/2"><code class="inline">Kernel.SpecialForms.quote/2</code></a> produces syntax trees for expressions.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="expand/2">expand(ast, env)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L1620" class="source">Source</a>
</h3> <section class="docstring"> <p>Receives an AST node and expands it until it can no longer be expanded.</p>
<p>Note this function does not traverse the AST, only the root node is expanded.</p>
<p>This function uses <a href="#expand_once/2"><code class="inline">expand_once/2</code></a> under the hood. Check it out for more information and examples.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="expand_once/2">expand_once(ast, env)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L1439" class="source">Source</a>
</h3> <section class="docstring"> <p>Receives an AST node and expands it once.</p>
<p>The following contents are expanded:</p>
<ul>
<li>Macros (local or remote)</li>
<li>Aliases are expanded (if possible) and return atoms</li>
<li>Compilation environment macros (<a href="kernel.specialforms#__CALLER__/0"><code class="inline">__CALLER__/0</code></a>, <a href="kernel.specialforms#__DIR__/0"><code class="inline">__DIR__/0</code></a>, <a href="kernel.specialforms#__ENV__/0"><code class="inline">__ENV__/0</code></a> and <a href="kernel.specialforms#__MODULE__/0"><code class="inline">__MODULE__/0</code></a>)</li>
<li>Module attributes reader (<code class="inline">@foo</code>)</li>
</ul>
<p>If the expression cannot be expanded, it returns the expression itself. This function does not traverse the AST, only the root node is expanded.</p>
<p><a href="#expand_once/2"><code class="inline">expand_once/2</code></a> performs the expansion just once. Check <a href="#expand/2"><code class="inline">expand/2</code></a> to perform expansion until the node can no longer be expanded.</p>
<h4 id="expand_once/2-examples" class="section-heading">  Examples </h4> <p>In the example below, we have a macro that generates a module with a function named <code class="inline">name_length</code> that returns the length of the module name. The value of this function will be calculated at compilation time and not at runtime.</p>
<p>Consider the implementation below:</p>
<pre data-language="elixir">defmacro defmodule_with_length(name, do: block) do
  length = length(Atom.to_charlist(name))

  quote do
    defmodule unquote(name) do
      def name_length, do: unquote(length)
      unquote(block)
    end
  end
end</pre>
<p>When invoked like this:</p>
<pre data-language="elixir">defmodule_with_length My.Module do
  def other_function, do: ...
end</pre>
<p>The compilation will fail because <code class="inline">My.Module</code> when quoted is not an atom, but a syntax tree as follows:</p>
<pre data-language="elixir">{:__aliases__, [], [:My, :Module]}</pre>
<p>That said, we need to expand the aliases node above to an atom, so we can retrieve its length. Expanding the node is not straightforward because we also need to expand the caller aliases. For example:</p>
<pre data-language="elixir">alias MyHelpers, as: My

defmodule_with_length My.Module do
  def other_function, do: ...
end</pre>
<p>The final module name will be <code class="inline">MyHelpers.Module</code> and not <code class="inline">My.Module</code>. With <a href="#expand/2"><code class="inline">Macro.expand/2</code></a>, such aliases are taken into consideration. Local and remote macros are also expanded. We could rewrite our macro above to use this function as:</p>
<pre data-language="elixir">defmacro defmodule_with_length(name, do: block) do
  expanded = Macro.expand(name, __CALLER__)
  length = length(Atom.to_charlist(expanded))

  quote do
    defmodule unquote(name) do
      def name_length, do: unquote(length)
      unquote(block)
    end
  end
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="generate_arguments/2">generate_arguments(amount, context)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L357" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">generate_arguments(0, context :: atom()) :: []</pre> <pre data-language="elixir">generate_arguments(pos_integer(), context) :: [{atom(), [], context}, ...]
when context: atom()</pre> </div> <p>Generates AST nodes for a given number of required argument variables using <a href="#var/2"><code class="inline">Macro.var/2</code></a>.</p>
<p>Note the arguments are not unique. If you later on want to access the same variables, you can invoke this function with the same inputs. Use <a href="#generate_unique_arguments/2"><code class="inline">generate_unique_arguments/2</code></a> to generate a unique arguments that can't be overridden.</p>
<h4 id="generate_arguments/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Macro.generate_arguments(2, __MODULE__)
[{:arg1, [], __MODULE__}, {:arg2, [], __MODULE__}]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="generate_unique_arguments/2">generate_unique_arguments(amount, context)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L379" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">generate_unique_arguments(0, context :: atom()) :: []</pre> <pre data-language="elixir">generate_unique_arguments(pos_integer(), context) :: [
  {atom(), [{:counter, integer()}], context},
  ...
]
when context: atom()</pre> </div> <p>Generates AST nodes for a given number of required argument variables using <a href="#unique_var/2"><code class="inline">Macro.unique_var/2</code></a>.</p>
<h4 id="generate_unique_arguments/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; [var1, var2] = Macro.generate_unique_arguments(2, __MODULE__)
iex&gt; {:arg1, [counter: c1], __MODULE__} = var1
iex&gt; {:arg2, [counter: c2], __MODULE__} = var2
iex&gt; is_integer(c1) and is_integer(c2)
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="operator?/2">operator?(name, arity)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L1564" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">operator?(name :: atom(), arity()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if the given name and arity is an operator.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="pipe/3">pipe(expr, call_args, position)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L243" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">pipe(t(), t(), integer()) :: t()</pre> </div> <p>Pipes <code class="inline">expr</code> into the <code class="inline">call_args</code> at the given <code class="inline">position</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="postwalk/2">postwalk(ast, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L512" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">postwalk(t(), (t() -&gt; t())) :: t()</pre> </div> <p>Performs a depth-first, post-order traversal of quoted expressions.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="postwalk/3">postwalk(ast, acc, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L521" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">postwalk(t(), any(), (t(), any() -&gt; {t(), any()})) :: {t(), any()}</pre> </div> <p>Performs a depth-first, post-order traversal of quoted expressions using an accumulator.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="prewalk/2">prewalk(ast, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L495" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">prewalk(t(), (t() -&gt; t())) :: t()</pre> </div> <p>Performs a depth-first, pre-order traversal of quoted expressions.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="prewalk/3">prewalk(ast, acc, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L504" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">prewalk(t(), any(), (t(), any() -&gt; {t(), any()})) :: {t(), any()}</pre> </div> <p>Performs a depth-first, pre-order traversal of quoted expressions using an accumulator.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="quoted_literal?/1">quoted_literal?(term)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L1594" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">quoted_literal?(t()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if the given quoted expression represents a quoted literal.</p>
<p>Atoms, numbers, and functions are always literals. Binaries, lists, tuples, maps, and structs are only literals if all of their terms are also literals.</p>
<h4 id="quoted_literal?/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Macro.quoted_literal?(quote(do: "foo"))
true
iex&gt; Macro.quoted_literal?(quote(do: {"foo", 1}))
true
iex&gt; Macro.quoted_literal?(quote(do: {"foo", 1, :baz}))
true
iex&gt; Macro.quoted_literal?(quote(do: %{foo: "bar"}))
true
iex&gt; Macro.quoted_literal?(quote(do: %URI{path: "/"}))
true
iex&gt; Macro.quoted_literal?(quote(do: URI.parse("/")))
false
iex&gt; Macro.quoted_literal?(quote(do: {foo, var}))
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="special_form?/2">special_form?(name, arity)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L1555" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">special_form?(name :: atom(), arity()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if the given name and arity is a special form.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="struct!/2">struct!(module, env)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L648" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">struct!(module, Macro.Env.t()) :: %{__struct__: module} when module: module()</pre> </div> <p>Expands the struct given by <code class="inline">module</code> in the given <code class="inline">env</code>.</p>
<p>This is useful when a struct needs to be expanded at compilation time and the struct being expanded may or may not have been compiled. This function is also capable of expanding structs defined under the module being compiled.</p>
<p>It will raise <a href="compileerror"><code class="inline">CompileError</code></a> if the struct is not available. From Elixir v1.12, calling this function also adds an export dependency on the given struct.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="to_string/2">to_string(tree, fun \\ fn _ast, string -&gt; string end)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L819" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_string(t(), (t(), String.t() -&gt; String.t())) :: String.t()</pre> </div> <p>Converts the given expression AST to a string.</p>
<p>The given <code class="inline">fun</code> is called for every node in the AST with two arguments: the AST of the node being printed and the string representation of that same node. The return value of this function is used as the final string representation for that AST node.</p>
<p>This function discards all formatting of the original code.</p>
<h4 id="to_string/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Macro.to_string(quote(do: foo.bar(1, 2, 3)))
"foo.bar(1, 2, 3)"

iex&gt; Macro.to_string(quote(do: 1 + 2), fn
...&gt;   1, _string -&gt; "one"
...&gt;   2, _string -&gt; "two"
...&gt;   _ast, string -&gt; string
...&gt; end)
"one + two"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="traverse/4">traverse(ast, acc, pre, post)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L442" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">traverse(t(), any(), (t(), any() -&gt; {t(), any()}), (t(), any() -&gt; {t(), any()})) ::
  {t(), any()}</pre> </div> <p>Performs a depth-first traversal of quoted expressions using an accumulator.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="underscore/1">underscore(atom)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L1668" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">underscore(atom() | String.t()) :: String.t()</pre> </div> <p>Converts the given atom or binary to underscore format.</p>
<p>If an atom is given, it is assumed to be an Elixir module, so it is converted to a binary and then processed.</p>
<p>This function was designed to underscore language identifiers/tokens, that's why it belongs to the <a href="macro#content"><code class="inline">Macro</code></a> module. Do not use it as a general mechanism for underscoring strings as it does not support Unicode or characters that are not valid in Elixir identifiers.</p>
<h4 id="underscore/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Macro.underscore("FooBar")
"foo_bar"

iex&gt; Macro.underscore("Foo.Bar")
"foo/bar"

iex&gt; Macro.underscore(Foo.Bar)
"foo/bar"</pre>
<p>In general, <code class="inline">underscore</code> can be thought of as the reverse of <code class="inline">camelize</code>, however, in some cases formatting may be lost:</p>
<pre data-language="elixir">iex&gt; Macro.underscore("SAPExample")
"sap_example"

iex&gt; Macro.camelize("sap_example")
"SapExample"

iex&gt; Macro.camelize("hello_10")
"Hello10"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="unescape_string/1">unescape_string(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L728" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">unescape_string(String.t()) :: String.t()</pre> </div> <p>Unescapes the given chars.</p>
<p>This is the unescaping behaviour used by default in Elixir single- and double-quoted strings. Check <a href="#unescape_string/2"><code class="inline">unescape_string/2</code></a> for information on how to customize the escaping map.</p>
<p>In this setup, Elixir will escape the following: <code class="inline">\0</code>, <code class="inline">\a</code>, <code class="inline">\b</code>, <code class="inline">\d</code>, <code class="inline">\e</code>, <code class="inline">\f</code>, <code class="inline">\n</code>, <code class="inline">\r</code>, <code class="inline">\s</code>, <code class="inline">\t</code> and <code class="inline">\v</code>. Bytes can be given as hexadecimals via <code class="inline">\xNN</code> and Unicode code points as <code class="inline">\uNNNN</code> escapes.</p>
<p>This function is commonly used on sigil implementations (like <code class="inline">~r</code>, <code class="inline">~s</code> and others) which receive a raw, unescaped string.</p>
<h4 id="unescape_string/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Macro.unescape_string("example\\n")
"example\n"</pre>
<p>In the example above, we pass a string with <code class="inline">\n</code> escaped and return a version with it unescaped.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="unescape_string/2">unescape_string(string, map)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L775" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">unescape_string(String.t(), (non_neg_integer() -&gt; non_neg_integer() | false)) ::
  String.t()</pre> </div> <p>Unescapes the given chars according to the map given.</p>
<p>Check <a href="#unescape_string/1"><code class="inline">unescape_string/1</code></a> if you want to use the same map as Elixir single- and double-quoted strings.</p>
<h4 id="unescape_string/2-map" class="section-heading">  Map </h4> <p>The map must be a function. The function receives an integer representing the code point of the character it wants to unescape. Here is the default mapping function implemented by Elixir:</p>
<pre data-language="elixir">def unescape_map(:newline), do: true
def unescape_map(:unicode), do: true
def unescape_map(:hex), do: true
def unescape_map(?0), do: ?0
def unescape_map(?a), do: ?\a
def unescape_map(?b), do: ?\b
def unescape_map(?d), do: ?\d
def unescape_map(?e), do: ?\e
def unescape_map(?f), do: ?\f
def unescape_map(?n), do: ?\n
def unescape_map(?r), do: ?\r
def unescape_map(?s), do: ?\s
def unescape_map(?t), do: ?\t
def unescape_map(?v), do: ?\v
def unescape_map(e), do: e</pre>
<p>If the <code class="inline">unescape_map/1</code> function returns <code class="inline">false</code>, the char is not escaped and the backslash is kept in the string.</p>
<p>Newlines, Unicode, and hexadecimals code points will be escaped if the map returns <code class="inline">true</code> respectively for <code class="inline">:newline</code>, <code class="inline">:unicode</code>, and <code class="inline">:hex</code>.</p>
<h4 id="unescape_string/2-examples" class="section-heading">  Examples </h4> <p>Using the <code class="inline">unescape_map/1</code> function defined above is easy:</p>
<pre data-language="elixir">Macro.unescape_string("example\\n", &amp;unescape_map(&amp;1))</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="unique_var/2">unique_var(var, context)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L433" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">unique_var(var, context) :: {var, [{:counter, integer()}], context}
when var: atom(), context: atom()</pre> </div> <p>Generates an AST node representing a unique variable given by the atoms <code class="inline">var</code> and <code class="inline">context</code>.</p>
<h4 id="unique_var/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; {:foo, [counter: c], __MODULE__} = Macro.unique_var(:foo, __MODULE__)
iex&gt; is_integer(c)
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="unpipe/1">unpipe(expr)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L227" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">unpipe(t()) :: [t()]</pre> </div> <p>Breaks a pipeline expression into a list.</p>
<p>The AST for a pipeline (a sequence of applications of <code class="inline">|&gt;</code>) is similar to the AST of a sequence of binary operators or function applications: the top-level expression is the right-most <code class="inline">:|&gt;</code> (which is the last one to be executed), and its left-hand and right-hand sides are its arguments:</p>
<pre data-language="elixir">quote do: 100 |&gt; div(5) |&gt; div(2)
#=&gt; {:|&gt;, _, [arg1, arg2]}</pre>
<p>In the example above, the <code class="inline">|&gt;</code> pipe is the right-most pipe; <code class="inline">arg1</code> is the AST for <code class="inline">100 |&gt; div(5)</code>, and <code class="inline">arg2</code> is the AST for <code class="inline">div(2)</code>.</p>
<p>It's often useful to have the AST for such a pipeline as a list of function applications. This function does exactly that:</p>
<pre data-language="elixir">Macro.unpipe(quote do: 100 |&gt; div(5) |&gt; div(2))
#=&gt; [{100, 0}, {{:div, [], [5]}, 0}, {{:div, [], [2]}, 0}]</pre>
<p>We get a list that follows the pipeline directly: first the <code class="inline">100</code>, then the <code class="inline">div(5)</code> (more precisely, its AST), then <code class="inline">div(2)</code>. The <code class="inline">0</code> as the second element of the tuples is the position of the previous element in the pipeline inside the current function application: <code class="inline">{{:div, [], [5]}, 0}</code> means that the previous element (<code class="inline">100</code>) will be inserted as the 0th (first) argument to the <a href="kernel#div/2"><code class="inline">div/2</code></a> function, so that the AST for that function will become <code class="inline">{:div, [], [100, 5]}</code> (<code class="inline">div(100, 5)</code>).</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="update_meta/2">update_meta(quoted, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L329" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">update_meta(t(), (keyword() -&gt; keyword())) :: t()</pre> </div> <p>Applies the given function to the node metadata if it contains one.</p>
<p>This is often useful when used with <a href="#prewalk/2"><code class="inline">Macro.prewalk/2</code></a> to remove information like lines and hygienic counters from the expression for either storage or comparison.</p>
<h4 id="update_meta/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; quoted = quote line: 10, do: sample()
{:sample, [line: 10], []}
iex&gt; Macro.update_meta(quoted, &amp;Keyword.delete(&amp;1, :line))
{:sample, [], []}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="validate/1">validate(expr)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L677" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">validate(term()) :: :ok | {:error, term()}</pre> </div> <p>Validates the given expressions are valid quoted expressions.</p>
<p>Checks the <a href="#t:t/0"><code class="inline">Macro.t/0</code></a> for the specification of a valid quoted expression.</p>
<p>It returns <code class="inline">:ok</code> if the expression is valid. Otherwise it returns a tuple in the form of <code class="inline">{:error, remainder}</code> where <code class="inline">remainder</code> is the invalid part of the quoted expression.</p>
<h4 id="validate/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Macro.validate({:two_element, :tuple})
:ok
iex&gt; Macro.validate({:three, :element, :tuple})
{:error, {:three, :element, :tuple}}

iex&gt; Macro.validate([1, 2, 3])
:ok
iex&gt; Macro.validate([1, 2, 3, {4}])
{:error, {4}}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="var/2">var(var, context)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/macro.ex#L415" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">var(var, context) :: {var, [], context} when var: atom(), context: atom()</pre> </div> <p>Generates an AST node representing the variable given by the atoms <code class="inline">var</code> and <code class="inline">context</code>.</p>
<p>Note this variable is not unique. If you later on want to access this same variable, you can invoke <a href="#var/2"><code class="inline">var/2</code></a> again with the same arguments. Use <a href="#unique_var/2"><code class="inline">unique_var/2</code></a> to generate a unique variable that can't be overridden.</p>
<h4 id="var/2-examples" class="section-heading">  Examples </h4> <p>In order to build a variable, a context is expected. Most of the times, in order to preserve hygiene, the context must be <a href="kernel.specialforms#__MODULE__/0"><code class="inline">__MODULE__/0</code></a>:</p>
<pre data-language="elixir">iex&gt; Macro.var(:foo, __MODULE__)
{:foo, [], __MODULE__}</pre>
<p>However, if there is a need to access the user variable, nil can be given:</p>
<pre data-language="elixir">iex&gt; Macro.var(:foo, nil)
{:foo, [], nil}</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/elixir/1.12.0/Macro.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.12.0/Macro.html</a>
  </p>
</div>
