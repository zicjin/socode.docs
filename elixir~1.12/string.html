<h1> String   </h1> <section id="moduledoc"> <p>Strings in Elixir are UTF-8 encoded binaries.</p>
<p>Strings in Elixir are a sequence of Unicode characters, typically written between double quoted strings, such as <code class="inline">"hello"</code> and <code class="inline">"héllò"</code>.</p>
<p>In case a string must have a double-quote in itself, the double quotes must be escaped with a backslash, for example: <code class="inline">"this is a string with \"double quotes\""</code>.</p>
<p>You can concatenate two strings with the <a href="kernel#%3C%3E/2"><code class="inline">&lt;&gt;/2</code></a> operator:</p>
<pre data-language="elixir">iex&gt; "hello" &lt;&gt; " " &lt;&gt; "world"
"hello world"</pre>
<h2 id="module-interpolation" class="section-heading">  Interpolation </h2> <p>Strings in Elixir also support interpolation. This allows you to place some value in the middle of a string by using the <code class="inline">#{}</code> syntax:</p>
<pre data-language="elixir">iex&gt; name = "joe"
iex&gt; "hello #{name}"
"hello joe"</pre>
<p>Any Elixir expression is valid inside the interpolation. If a string is given, the string is interpolated as is. If any other value is given, Elixir will attempt to convert it to a string using the <a href="string.chars"><code class="inline">String.Chars</code></a> protocol. This allows, for example, to output an integer from the interpolation:</p>
<pre data-language="elixir">iex&gt; "2 + 2 = #{2 + 2}"
"2 + 2 = 4"</pre>
<p>In case the value you want to interpolate cannot be converted to a string, because it doesn't have an human textual representation, a protocol error will be raised.</p>
<h2 id="module-escape-characters" class="section-heading">  Escape characters </h2> <p>Besides allowing double-quotes to be escaped with a backslash, strings also support the following escape characters:</p>
<ul>
<li>
<code class="inline">\a</code> - Bell</li>
<li>
<code class="inline">\b</code> - Backspace</li>
<li>
<code class="inline">\t</code> - Horizontal tab</li>
<li>
<code class="inline">\n</code> - Line feed (New lines)</li>
<li>
<code class="inline">\v</code> - Vertical tab</li>
<li>
<code class="inline">\f</code> - Form feed</li>
<li>
<code class="inline">\r</code> - Carriage return</li>
<li>
<code class="inline">\e</code> - Command Escape</li>
<li>
<code class="inline">\#</code> - Returns the <code class="inline">#</code> character itself, skipping interpolation</li>
<li>
<code class="inline">\xNN</code> - A byte represented by the hexadecimal <code class="inline">NN</code>
</li>
<li>
<code class="inline">\uNNNN</code> - A Unicode code point represented by <code class="inline">NNNN</code>
</li>
</ul>
<p>Note it is generally not advised to use <code class="inline">\xNN</code> in Elixir strings, as introducing an invalid byte sequence would make the string invalid. If you have to introduce a character by its hexadecimal representation, it is best to work with Unicode code points, such as <code class="inline">\uNNNN</code>. In fact, understanding Unicode code points can be essential when doing low-level manipulations of string, so let's explore them in detail next.</p>
<h2 id="module-code-points-and-grapheme-cluster" class="section-heading">  Code points and grapheme cluster </h2> <p>The functions in this module act according to the Unicode Standard, version 13.0.0.</p>
<p>As per the standard, a code point is a single Unicode Character, which may be represented by one or more bytes.</p>
<p>For example, although the code point "é" is a single character, its underlying representation uses two bytes:</p>
<pre data-language="elixir">iex&gt; String.length("é")
1
iex&gt; byte_size("é")
2</pre>
<p>Furthermore, this module also presents the concept of grapheme cluster (from now on referenced as graphemes). Graphemes can consist of multiple code points that may be perceived as a single character by readers. For example, "é" can be represented either as a single "e with acute" code point or as the letter "e" followed by a "combining acute accent" (two code points):</p>
<pre data-language="elixir">iex&gt; string = "\u0065\u0301"
iex&gt; byte_size(string)
3
iex&gt; String.length(string)
1
iex&gt; String.codepoints(string)
["e", "́"]
iex&gt; String.graphemes(string)
["é"]</pre>
<p>Although the example above is made of two characters, it is perceived by users as one.</p>
<p>Graphemes can also be two characters that are interpreted as one by some languages. For example, some languages may consider "ch" as a single character. However, since this information depends on the locale, it is not taken into account by this module.</p>
<p>In general, the functions in this module rely on the Unicode Standard, but do not contain any of the locale specific behaviour. More information about graphemes can be found in the <a href="https://www.unicode.org/reports/tr29/">Unicode Standard Annex #29</a>.</p>
<p>For converting a binary to a different encoding and for Unicode normalization mechanisms, see Erlang's <code class="inline">:unicode</code> module.</p>
<h2 id="module-string-and-binary-operations" class="section-heading">  String and binary operations </h2> <p>To act according to the Unicode Standard, many functions in this module run in linear time, as they need to traverse the whole string considering the proper Unicode code points.</p>
<p>For example, <a href="#length/1"><code class="inline">String.length/1</code></a> will take longer as the input grows. On the other hand, <a href="kernel#byte_size/1"><code class="inline">Kernel.byte_size/1</code></a> always runs in constant time (i.e. regardless of the input size).</p>
<p>This means often there are performance costs in using the functions in this module, compared to the more low-level operations that work directly with binaries:</p>
<ul>
<li>
<a href="kernel#binary_part/3"><code class="inline">Kernel.binary_part/3</code></a> - retrieves part of the binary</li>
<li>
<a href="kernel#bit_size/1"><code class="inline">Kernel.bit_size/1</code></a> and <a href="kernel#byte_size/1"><code class="inline">Kernel.byte_size/1</code></a> - size related functions</li>
<li>
<a href="kernel#is_bitstring/1"><code class="inline">Kernel.is_bitstring/1</code></a> and <a href="kernel#is_binary/1"><code class="inline">Kernel.is_binary/1</code></a> - type-check function</li>
<li>Plus a number of functions for working with binaries (bytes) in the <a href="https://erlang.org/doc/man/binary.html"><code class="inline">:binary</code> module</a>
</li>
</ul>
<p>There are many situations where using the <a href="string#content"><code class="inline">String</code></a> module can be avoided in favor of binary functions or pattern matching. For example, imagine you have a string <code class="inline">prefix</code> and you want to remove this prefix from another string named <code class="inline">full</code>.</p>
<p>One may be tempted to write:</p>
<pre data-language="elixir">iex&gt; take_prefix = fn full, prefix -&gt;
...&gt;   base = String.length(prefix)
...&gt;   String.slice(full, base, String.length(full) - base)
...&gt; end
iex&gt; take_prefix.("Mr. John", "Mr. ")
"John"</pre>
<p>Although the function above works, it performs poorly. To calculate the length of the string, we need to traverse it fully, so we traverse both <code class="inline">prefix</code> and <code class="inline">full</code> strings, then slice the <code class="inline">full</code> one, traversing it again.</p>
<p>A first attempt at improving it could be with ranges:</p>
<pre data-language="elixir">iex&gt; take_prefix = fn full, prefix -&gt;
...&gt;   base = String.length(prefix)
...&gt;   String.slice(full, base..-1)
...&gt; end
iex&gt; take_prefix.("Mr. John", "Mr. ")
"John"</pre>
<p>While this is much better (we don't traverse <code class="inline">full</code> twice), it could still be improved. In this case, since we want to extract a substring from a string, we can use <a href="kernel#byte_size/1"><code class="inline">Kernel.byte_size/1</code></a> and <a href="kernel#binary_part/3"><code class="inline">Kernel.binary_part/3</code></a> as there is no chance we will slice in the middle of a code point made of more than one byte:</p>
<pre data-language="elixir">iex&gt; take_prefix = fn full, prefix -&gt;
...&gt;   base = byte_size(prefix)
...&gt;   binary_part(full, base, byte_size(full) - base)
...&gt; end
iex&gt; take_prefix.("Mr. John", "Mr. ")
"John"</pre>
<p>Or simply use pattern matching:</p>
<pre data-language="elixir">iex&gt; take_prefix = fn full, prefix -&gt;
...&gt;   base = byte_size(prefix)
...&gt;   &lt;&lt;_::binary-size(base), rest::binary&gt;&gt; = full
...&gt;   rest
...&gt; end
iex&gt; take_prefix.("Mr. John", "Mr. ")
"John"</pre>
<p>On the other hand, if you want to dynamically slice a string based on an integer value, then using <a href="#slice/3"><code class="inline">String.slice/3</code></a> is the best option as it guarantees we won't incorrectly split a valid code point into multiple bytes.</p>
<h2 id="module-integer-code-points" class="section-heading">  Integer code points </h2> <p>Although code points are represented as integers, this module represents code points in their encoded format as strings. For example:</p>
<pre data-language="elixir">iex&gt; String.codepoints("olá")
["o", "l", "á"]</pre>
<p>There are a couple of ways to retrieve the character code point. One may use the <code class="inline">?</code> construct:</p>
<pre data-language="elixir">iex&gt; ?o
111

iex&gt; ?á
225</pre>
<p>Or also via pattern matching:</p>
<pre data-language="elixir">iex&gt; &lt;&lt;aacute::utf8&gt;&gt; = "á"
iex&gt; aacute
225</pre>
<p>As we have seen above, code points can be inserted into a string by their hexadecimal code:</p>
<pre data-language="elixir">iex&gt; "ol\u00E1"
"olá"</pre>
<p>Finally, to convert a String into a list of integer code points, known as "charlists" in Elixir, you can call <code class="inline">String.to_charlist</code>:</p>
<pre data-language="elixir">iex&gt; String.to_charlist("olá")
[111, 108, 225]</pre>
<h2 id="module-self-synchronization" class="section-heading">  Self-synchronization </h2> <p>The UTF-8 encoding is self-synchronizing. This means that if malformed data (i.e., data that is not possible according to the definition of the encoding) is encountered, only one code point needs to be rejected.</p>
<p>This module relies on this behaviour to ignore such invalid characters. For example, <a href="#length/1"><code class="inline">length/1</code></a> will return a correct result even if an invalid code point is fed into it.</p>
<p>In other words, this module expects invalid data to be detected elsewhere, usually when retrieving data from the external source. For example, a driver that reads strings from a database will be responsible to check the validity of the encoding. <a href="#chunk/2"><code class="inline">String.chunk/2</code></a> can be used for breaking a string into valid and invalid parts.</p>
<h2 id="module-compile-binary-patterns" class="section-heading">  Compile binary patterns </h2> <p>Many functions in this module work with patterns. For example, <a href="#split/3"><code class="inline">String.split/3</code></a> can split a string into multiple strings given a pattern. This pattern can be a string, a list of strings or a compiled pattern:</p>
<pre data-language="elixir">iex&gt; String.split("foo bar", " ")
["foo", "bar"]

iex&gt; String.split("foo bar!", [" ", "!"])
["foo", "bar", ""]

iex&gt; pattern = :binary.compile_pattern([" ", "!"])
iex&gt; String.split("foo bar!", pattern)
["foo", "bar", ""]</pre>
<p>The compiled pattern is useful when the same match will be done over and over again. Note though that the compiled pattern cannot be stored in a module attribute as the pattern is generated at runtime and does not survive compile time.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:codepoint/0">codepoint()</a> </dt> <dd class="summary-synopsis"><p>A single Unicode code point encoded in UTF-8. It may be one or more bytes.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:grapheme/0">grapheme()</a> </dt> <dd class="summary-synopsis"><p>Multiple code points that may be perceived as a single character by readers</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:pattern/0">pattern()</a> </dt> <dd class="summary-synopsis"><p>Pattern used in functions like <a href="#replace/4"><code class="inline">replace/4</code></a> and <a href="#split/3"><code class="inline">split/3</code></a></p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt> <dd class="summary-synopsis"><p>A UTF-8 encoded binary.</p></dd> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#at/2">at(string, position)</a> </dt> <dd class="summary-synopsis"><p>Returns the grapheme at the <code class="inline">position</code> of the given UTF-8 <code class="inline">string</code>. If <code class="inline">position</code> is greater than <code class="inline">string</code> length, then it returns <code class="inline">nil</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#bag_distance/2">bag_distance(string1, string2)</a> </dt> <dd class="summary-synopsis"><p>Computes the bag distance between two strings.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#capitalize/2">capitalize(string, mode \\ :default)</a> </dt> <dd class="summary-synopsis"><p>Converts the first character in the given string to uppercase and the remainder to lowercase according to <code class="inline">mode</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#chunk/2">chunk(string, trait)</a> </dt> <dd class="summary-synopsis"><p>Splits the string into chunks of characters that share a common trait.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#codepoints/1">codepoints(string)</a> </dt> <dd class="summary-synopsis"><p>Returns a list of code points encoded as strings.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#contains?/2">contains?(string, contents)</a> </dt> <dd class="summary-synopsis"><p>Checks if <code class="inline">string</code> contains any of the given <code class="inline">contents</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#downcase/2">downcase(string, mode \\ :default)</a> </dt> <dd class="summary-synopsis"><p>Converts all characters in the given string to lowercase according to <code class="inline">mode</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#duplicate/2">duplicate(subject, n)</a> </dt> <dd class="summary-synopsis"><p>Returns a string <code class="inline">subject</code> repeated <code class="inline">n</code> times.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#ends_with?/2">ends_with?(string, suffix)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">string</code> ends with any of the suffixes given.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#equivalent?/2">equivalent?(string1, string2)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">string1</code> is canonically equivalent to <code class="inline">string2</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#first/1">first(string)</a> </dt> <dd class="summary-synopsis"><p>Returns the first grapheme from a UTF-8 string, <code class="inline">nil</code> if the string is empty.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#graphemes/1">graphemes(string)</a> </dt> <dd class="summary-synopsis"><p>Returns Unicode graphemes in the string as per Extended Grapheme Cluster algorithm.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#jaro_distance/2">jaro_distance(string1, string2)</a> </dt> <dd class="summary-synopsis"><p>Computes the Jaro distance (similarity) between two strings.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#last/1">last(string)</a> </dt> <dd class="summary-synopsis"><p>Returns the last grapheme from a UTF-8 string, <code class="inline">nil</code> if the string is empty.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#length/1">length(string)</a> </dt> <dd class="summary-synopsis"><p>Returns the number of Unicode graphemes in a UTF-8 string.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#match?/2">match?(string, regex)</a> </dt> <dd class="summary-synopsis"><p>Checks if <code class="inline">string</code> matches the given regular expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#myers_difference/2">myers_difference(string1, string2)</a> </dt> <dd class="summary-synopsis"><p>Returns a keyword list that represents an edit script.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#next_codepoint/1">next_codepoint(string)</a> </dt> <dd class="summary-synopsis"><p>Returns the next code point in a string.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#next_grapheme/1">next_grapheme(binary)</a> </dt> <dd class="summary-synopsis"><p>Returns the next grapheme in a string.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#next_grapheme_size/1">next_grapheme_size(string)</a> </dt> <dd class="summary-synopsis"><p>Returns the size (in bytes) of the next grapheme.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#normalize/2">normalize(string, form)</a> </dt> <dd class="summary-synopsis"><p>Converts all characters in <code class="inline">string</code> to Unicode normalization form identified by <code class="inline">form</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#pad_leading/3">pad_leading(string, count, padding \\ [" "])</a> </dt> <dd class="summary-synopsis"><p>Returns a new string padded with a leading filler which is made of elements from the <code class="inline">padding</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#pad_trailing/3">pad_trailing(string, count, padding \\ [" "])</a> </dt> <dd class="summary-synopsis"><p>Returns a new string padded with a trailing filler which is made of elements from the <code class="inline">padding</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#printable?/2">printable?(string, character_limit \\ :infinity)</a> </dt> <dd class="summary-synopsis"><p>Checks if a string contains only printable characters up to <code class="inline">character_limit</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#replace/4">replace(subject, pattern, replacement, options \\ [])</a> </dt> <dd class="summary-synopsis"><p>Returns a new string created by replacing occurrences of <code class="inline">pattern</code> in <code class="inline">subject</code> with <code class="inline">replacement</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#replace_leading/3">replace_leading(string, match, replacement)</a> </dt> <dd class="summary-synopsis"><p>Replaces all leading occurrences of <code class="inline">match</code> by <code class="inline">replacement</code> of <code class="inline">match</code> in <code class="inline">string</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#replace_prefix/3">replace_prefix(string, match, replacement)</a> </dt> <dd class="summary-synopsis"><p>Replaces prefix in <code class="inline">string</code> by <code class="inline">replacement</code> if it matches <code class="inline">match</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#replace_suffix/3">replace_suffix(string, match, replacement)</a> </dt> <dd class="summary-synopsis"><p>Replaces suffix in <code class="inline">string</code> by <code class="inline">replacement</code> if it matches <code class="inline">match</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#replace_trailing/3">replace_trailing(string, match, replacement)</a> </dt> <dd class="summary-synopsis"><p>Replaces all trailing occurrences of <code class="inline">match</code> by <code class="inline">replacement</code> in <code class="inline">string</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reverse/1">reverse(string)</a> </dt> <dd class="summary-synopsis"><p>Reverses the graphemes in given string.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#slice/2">slice(string, range)</a> </dt> <dd class="summary-synopsis"><p>Returns a substring from the offset given by the start of the range to the offset given by the end of the range.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#slice/3">slice(string, start, length)</a> </dt> <dd class="summary-synopsis"><p>Returns a substring starting at the offset <code class="inline">start</code>, and of the given <code class="inline">length</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#split/1">split(binary)</a> </dt> <dd class="summary-synopsis"><p>Divides a string into substrings at each Unicode whitespace occurrence with leading and trailing whitespace ignored. Groups of whitespace are treated as a single occurrence. Divisions do not occur on non-breaking whitespace.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#split/3">split(string, pattern, options \\ [])</a> </dt> <dd class="summary-synopsis"><p>Divides a string into parts based on a pattern.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#split_at/2">split_at(string, position)</a> </dt> <dd class="summary-synopsis"><p>Splits a string into two at the specified offset. When the offset given is negative, location is counted from the end of the string.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#splitter/3">splitter(string, pattern, options \\ [])</a> </dt> <dd class="summary-synopsis"><p>Returns an enumerable that splits a string on demand.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#starts_with?/2">starts_with?(string, prefix)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">string</code> starts with any of the prefixes given.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_atom/1">to_atom(string)</a> </dt> <dd class="summary-synopsis"><p>Converts a string to an atom.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_charlist/1">to_charlist(string)</a> </dt> <dd class="summary-synopsis"><p>Converts a string into a charlist.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_existing_atom/1">to_existing_atom(string)</a> </dt> <dd class="summary-synopsis"><p>Converts a string to an existing atom.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_float/1">to_float(string)</a> </dt> <dd class="summary-synopsis"><p>Returns a float whose text representation is <code class="inline">string</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_integer/1">to_integer(string)</a> </dt> <dd class="summary-synopsis"><p>Returns an integer whose text representation is <code class="inline">string</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_integer/2">to_integer(string, base)</a> </dt> <dd class="summary-synopsis"><p>Returns an integer whose text representation is <code class="inline">string</code> in base <code class="inline">base</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#trim/1">trim(string)</a> </dt> <dd class="summary-synopsis"><p>Returns a string where all leading and trailing Unicode whitespaces have been removed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#trim/2">trim(string, to_trim)</a> </dt> <dd class="summary-synopsis"><p>Returns a string where all leading and trailing <code class="inline">to_trim</code> characters have been removed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#trim_leading/1">trim_leading(string)</a> </dt> <dd class="summary-synopsis"><p>Returns a string where all leading Unicode whitespaces have been removed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#trim_leading/2">trim_leading(string, to_trim)</a> </dt> <dd class="summary-synopsis"><p>Returns a string where all leading <code class="inline">to_trim</code> characters have been removed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#trim_trailing/1">trim_trailing(string)</a> </dt> <dd class="summary-synopsis"><p>Returns a string where all trailing Unicode whitespaces has been removed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#trim_trailing/2">trim_trailing(string, to_trim)</a> </dt> <dd class="summary-synopsis"><p>Returns a string where all trailing <code class="inline">to_trim</code> characters have been removed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#upcase/2">upcase(string, mode \\ :default)</a> </dt> <dd class="summary-synopsis"><p>Converts all characters in the given string to uppercase according to <code class="inline">mode</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#valid?/1">valid?(arg1)</a> </dt> <dd class="summary-synopsis"><p>Checks whether <code class="inline">string</code> contains only valid characters.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:codepoint/0">codepoint()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L281" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">codepoint() :: t()</pre> </div> <p>A single Unicode code point encoded in UTF-8. It may be one or more bytes.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:grapheme/0">grapheme()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L284" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">grapheme() :: t()</pre> </div> <p>Multiple code points that may be perceived as a single character by readers</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:pattern/0">pattern()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L287" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">pattern() :: t() | [t()] | :binary.cp()</pre> </div> <p>Pattern used in functions like <a href="#replace/4"><code class="inline">replace/4</code></a> and <a href="#split/3"><code class="inline">split/3</code></a></p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L278" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">t() :: binary()</pre> </div> <p>A UTF-8 encoded binary.</p>
<p>The types <code class="inline">String.t()</code> and <code class="inline">binary()</code> are equivalent to analysis tools. Although, for those reading the documentation, <code class="inline">String.t()</code> implies it is a UTF-8 encoded binary.</p> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="at/2">at(string, position)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1946" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">at(t(), integer()) :: grapheme() | nil</pre> </div> <p>Returns the grapheme at the <code class="inline">position</code> of the given UTF-8 <code class="inline">string</code>. If <code class="inline">position</code> is greater than <code class="inline">string</code> length, then it returns <code class="inline">nil</code>.</p>
<h4 id="at/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.at("elixir", 0)
"e"

iex&gt; String.at("elixir", 1)
"l"

iex&gt; String.at("elixir", 10)
nil

iex&gt; String.at("elixir", -1)
"r"

iex&gt; String.at("elixir", -10)
nil</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="bag_distance/2">bag_distance(string1, string2)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L2491" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">bag_distance(t(), t()) :: float()</pre> </div> <p>Computes the bag distance between two strings.</p>
<p>Returns a float value between 0 and 1 representing the bag distance between <code class="inline">string1</code> and <code class="inline">string2</code>.</p>
<p>The bag distance is meant to be an efficient approximation of the distance between two strings to quickly rule out strings that are largely different.</p>
<p>The algorithm is outlined in the "String Matching with Metric Trees Using an Approximate Distance" paper by Ilaria Bartolini, Paolo Ciaccia, and Marco Patella.</p>
<h4 id="bag_distance/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.bag_distance("abc", "")
0.0
iex&gt; String.bag_distance("abcd", "a")
0.25
iex&gt; String.bag_distance("abcd", "ab")
0.5
iex&gt; String.bag_distance("abcd", "abc")
0.75
iex&gt; String.bag_distance("abcd", "abcd")
1.0</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="capitalize/2">capitalize(string, mode \\ :default)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L911" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">capitalize(t(), :default | :ascii | :greek | :turkic) :: t()</pre> </div> <p>Converts the first character in the given string to uppercase and the remainder to lowercase according to <code class="inline">mode</code>.</p>
<p><code class="inline">mode</code> may be <code class="inline">:default</code>, <code class="inline">:ascii</code>, <code class="inline">:greek</code> or <code class="inline">:turkic</code>. The <code class="inline">:default</code> mode considers all non-conditional transformations outlined in the Unicode standard. <code class="inline">:ascii</code> capitalizes only the letters A to Z. <code class="inline">:greek</code> includes the context sensitive mappings found in Greek. <code class="inline">:turkic</code> properly handles the letter i with the dotless variant.</p>
<h4 id="capitalize/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.capitalize("abcd")
"Abcd"

iex&gt; String.capitalize("ﬁn")
"Fin"

iex&gt; String.capitalize("olá")
"Olá"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="chunk/2">chunk(string, trait)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1761" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">chunk(t(), :valid | :printable) :: [t()]</pre> </div> <p>Splits the string into chunks of characters that share a common trait.</p>
<p>The trait can be one of two options:</p>
<ul>
<li><p><code class="inline">:valid</code> - the string is split into chunks of valid and invalid character sequences</p></li>
<li><p><code class="inline">:printable</code> - the string is split into chunks of printable and non-printable character sequences</p></li>
</ul>
<p>Returns a list of binaries each of which contains only one kind of characters.</p>
<p>If the given string is empty, an empty list is returned.</p>
<h4 id="chunk/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.chunk(&lt;&lt;?a, ?b, ?c, 0&gt;&gt;, :valid)
["abc\0"]

iex&gt; String.chunk(&lt;&lt;?a, ?b, ?c, 0, 0xFFFF::utf16&gt;&gt;, :valid)
["abc\0", &lt;&lt;0xFFFF::utf16&gt;&gt;]

iex&gt; String.chunk(&lt;&lt;?a, ?b, ?c, 0, 0x0FFFF::utf8&gt;&gt;, :printable)
["abc", &lt;&lt;0, 0x0FFFF::utf8&gt;&gt;]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="codepoints/1">codepoints(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1646" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">codepoints(t()) :: [codepoint()]</pre> </div> <p>Returns a list of code points encoded as strings.</p>
<p>To retrieve code points in their natural integer representation, see <a href="#to_charlist/1"><code class="inline">to_charlist/1</code></a>. For details about code points and graphemes, see the <a href="string#content"><code class="inline">String</code></a> module documentation.</p>
<h4 id="codepoints/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.codepoints("olá")
["o", "l", "á"]

iex&gt; String.codepoints("оптими зации")
["о", "п", "т", "и", "м", "и", " ", "з", "а", "ц", "и", "и"]

iex&gt; String.codepoints("ἅἪῼ")
["ἅ", "Ἢ", "ῼ"]

iex&gt; String.codepoints("\u00e9")
["é"]

iex&gt; String.codepoints("\u0065\u0301")
["e", "́"]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="contains?/2">contains?(string, contents)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L2306" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">contains?(t(), pattern()) :: boolean()</pre> </div> <p>Checks if <code class="inline">string</code> contains any of the given <code class="inline">contents</code>.</p>
<p><code class="inline">contents</code> can be either a string, a list of strings, or a compiled pattern.</p>
<h4 id="contains?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.contains?("elixir of life", "of")
true
iex&gt; String.contains?("elixir of life", ["life", "death"])
true
iex&gt; String.contains?("elixir of life", ["death", "mercury"])
false</pre>
<p>The argument can also be a compiled pattern:</p>
<pre data-language="elixir">iex&gt; pattern = :binary.compile_pattern(["life", "death"])
iex&gt; String.contains?("elixir of life", pattern)
true</pre>
<p>An empty string will always match:</p>
<pre data-language="elixir">iex&gt; String.contains?("elixir of life", "")
true
iex&gt; String.contains?("elixir of life", ["", "other"])
true</pre>
<p>Be aware that this function can match within or across grapheme boundaries. For example, take the grapheme "é" which is made of the characters "e" and the acute accent. The following returns <code class="inline">true</code>:</p>
<pre data-language="elixir">iex&gt; String.contains?(String.normalize("é", :nfd), "e")
true</pre>
<p>However, if "é" is represented by the single character "e with acute" accent, then it will return <code class="inline">false</code>:</p>
<pre data-language="elixir">iex&gt; String.contains?(String.normalize("é", :nfc), "e")
false</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="downcase/2">downcase(string, mode \\ :default)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L865" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">downcase(t(), :default | :ascii | :greek | :turkic) :: t()</pre> </div> <p>Converts all characters in the given string to lowercase according to <code class="inline">mode</code>.</p>
<p><code class="inline">mode</code> may be <code class="inline">:default</code>, <code class="inline">:ascii</code>, <code class="inline">:greek</code> or <code class="inline">:turkic</code>. The <code class="inline">:default</code> mode considers all non-conditional transformations outlined in the Unicode standard. <code class="inline">:ascii</code> lowercases only the letters A to Z. <code class="inline">:greek</code> includes the context sensitive mappings found in Greek. <code class="inline">:turkic</code> properly handles the letter i with the dotless variant.</p>
<h4 id="downcase/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.downcase("ABCD")
"abcd"

iex&gt; String.downcase("AB 123 XPTO")
"ab 123 xpto"

iex&gt; String.downcase("OLÁ")
"olá"</pre>
<p>The <code class="inline">:ascii</code> mode ignores Unicode characters and provides a more performant implementation when you know the string contains only ASCII characters:</p>
<pre data-language="elixir">iex&gt; String.downcase("OLÁ", :ascii)
"olÁ"</pre>
<p>The <code class="inline">:greek</code> mode properly handles the context sensitive sigma in Greek:</p>
<pre data-language="elixir">iex&gt; String.downcase("ΣΣ")
"σσ"

iex&gt; String.downcase("ΣΣ", :greek)
"σς"</pre>
<p>And <code class="inline">:turkic</code> properly handles the letter i with the dotless variant:</p>
<pre data-language="elixir">iex&gt; String.downcase("Iİ")
"ii̇"

iex&gt; String.downcase("Iİ", :turkic)
"ıi"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="duplicate/2">duplicate(subject, n)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1615" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">duplicate(t(), non_neg_integer()) :: t()</pre> </div> <p>Returns a string <code class="inline">subject</code> repeated <code class="inline">n</code> times.</p>
<p>Inlined by the compiler.</p>
<h4 id="duplicate/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.duplicate("abc", 0)
""

iex&gt; String.duplicate("abc", 1)
"abc"

iex&gt; String.duplicate("abc", 2)
"abcabc"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="ends_with?/2">ends_with?(string, suffix)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L2226" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">ends_with?(t(), t() | [t()]) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">string</code> ends with any of the suffixes given.</p>
<p><code class="inline">suffixes</code> can be either a single suffix or a list of suffixes.</p>
<h4 id="ends_with?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.ends_with?("language", "age")
true
iex&gt; String.ends_with?("language", ["youth", "age"])
true
iex&gt; String.ends_with?("language", ["youth", "elixir"])
false</pre>
<p>An empty suffix will always match:</p>
<pre data-language="elixir">iex&gt; String.ends_with?("language", "")
true
iex&gt; String.ends_with?("language", ["", "other"])
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="equivalent?/2">equivalent?(string1, string2)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L677" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">equivalent?(t(), t()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">string1</code> is canonically equivalent to <code class="inline">string2</code>.</p>
<p>It performs Normalization Form Canonical Decomposition (NFD) on the strings before comparing them. This function is equivalent to:</p>
<pre data-language="elixir">String.normalize(string1, :nfd) == String.normalize(string2, :nfd)</pre>
<p>If you plan to compare multiple strings, multiple times in a row, you may normalize them upfront and compare them directly to avoid multiple normalization passes.</p>
<h4 id="equivalent?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.equivalent?("abc", "abc")
true

iex&gt; String.equivalent?("man\u0303ana", "mañana")
true

iex&gt; String.equivalent?("abc", "ABC")
false

iex&gt; String.equivalent?("nø", "nó")
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="first/1">first(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1876" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">first(t()) :: grapheme() | nil</pre> </div> <p>Returns the first grapheme from a UTF-8 string, <code class="inline">nil</code> if the string is empty.</p>
<h4 id="first/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.first("elixir")
"e"

iex&gt; String.first("եոգլի")
"ե"

iex&gt; String.first("")
nil</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="graphemes/1">graphemes(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1812" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">graphemes(t()) :: [grapheme()]</pre> </div> <p>Returns Unicode graphemes in the string as per Extended Grapheme Cluster algorithm.</p>
<p>The algorithm is outlined in the <a href="https://www.unicode.org/reports/tr29/">Unicode Standard Annex #29, Unicode Text Segmentation</a>.</p>
<p>For details about code points and graphemes, see the <a href="string#content"><code class="inline">String</code></a> module documentation.</p>
<h4 id="graphemes/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.graphemes("Ńaïve")
["Ń", "a", "ï", "v", "e"]

iex&gt; String.graphemes("\u00e9")
["é"]

iex&gt; String.graphemes("\u0065\u0301")
["é"]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="jaro_distance/2">jaro_distance(string1, string2)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L2554" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">jaro_distance(t(), t()) :: float()</pre> </div> <p>Computes the Jaro distance (similarity) between two strings.</p>
<p>Returns a float value between <code class="inline">0.0</code> (equates to no similarity) and <code class="inline">1.0</code> (is an exact match) representing <a href="https://en.wikipedia.org/wiki/Jaro-Winkler_distance">Jaro</a> distance between <code class="inline">string1</code> and <code class="inline">string2</code>.</p>
<p>The Jaro distance metric is designed and best suited for short strings such as person names. Elixir itself uses this function to provide the "did you mean?" functionality. For instance, when you are calling a function in a module and you have a typo in the function name, we attempt to suggest the most similar function name available, if any, based on the <a href="#jaro_distance/2"><code class="inline">jaro_distance/2</code></a> score.</p>
<h4 id="jaro_distance/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.jaro_distance("Dwayne", "Duane")
0.8222222222222223
iex&gt; String.jaro_distance("even", "odd")
0.0
iex&gt; String.jaro_distance("same", "same")
1.0</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="last/1">last(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1897" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">last(t()) :: grapheme() | nil</pre> </div> <p>Returns the last grapheme from a UTF-8 string, <code class="inline">nil</code> if the string is empty.</p>
<h4 id="last/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.last("elixir")
"r"

iex&gt; String.last("եոգլի")
"ի"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="length/1">length(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1920" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">length(t()) :: non_neg_integer()</pre> </div> <p>Returns the number of Unicode graphemes in a UTF-8 string.</p>
<h4 id="length/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.length("elixir")
6

iex&gt; String.length("եոգլի")
5</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="match?/2">match?(string, regex)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L2259" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">match?(t(), Regex.t()) :: boolean()</pre> </div> <p>Checks if <code class="inline">string</code> matches the given regular expression.</p>
<h4 id="match?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.match?("foo", ~r/foo/)
true

iex&gt; String.match?("bar", ~r/foo/)
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="myers_difference/2">myers_difference(string1, string2)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L2647" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">myers_difference(t(), t()) :: [{:eq | :ins | :del, t()}]</pre> </div> <p>Returns a keyword list that represents an edit script.</p>
<p>Check <a href="list#myers_difference/2"><code class="inline">List.myers_difference/2</code></a> for more information.</p>
<h4 id="myers_difference/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; string1 = "fox hops over the dog"
iex&gt; string2 = "fox jumps over the lazy cat"
iex&gt; String.myers_difference(string1, string2)
[eq: "fox ", del: "ho", ins: "jum", eq: "ps over the ", del: "dog", ins: "lazy cat"]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="next_codepoint/1">next_codepoint(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1691" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">next_codepoint(t()) :: {codepoint(), t()} | nil</pre> </div> <p>Returns the next code point in a string.</p>
<p>The result is a tuple with the code point and the remainder of the string or <code class="inline">nil</code> in case the string reached its end.</p>
<p>As with other functions in the <a href="string#content"><code class="inline">String</code></a> module, <a href="#next_codepoint/1"><code class="inline">next_codepoint/1</code></a> works with binaries that are invalid UTF-8. If the string starts with a sequence of bytes that is not valid in UTF-8 encoding, the first element of the returned tuple is a binary with the first byte.</p>
<h4 id="next_codepoint/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.next_codepoint("olá")
{"o", "lá"}

iex&gt; invalid = "\x80\x80OK" # first two bytes are invalid in UTF-8
iex&gt; {_, rest} = String.next_codepoint(invalid)
{&lt;&lt;128&gt;&gt;, &lt;&lt;128, 79, 75&gt;&gt;}
iex&gt; String.next_codepoint(rest)
{&lt;&lt;128&gt;&gt;, "OK"}</pre>
<h4 id="next_codepoint/1-comparison-with-binary-pattern-matching" class="section-heading">  Comparison with binary pattern matching </h4> <p>Binary pattern matching provides a similar way to decompose a string:</p>
<pre data-language="elixir">iex&gt; &lt;&lt;codepoint::utf8, rest::binary&gt;&gt; = "Elixir"
"Elixir"
iex&gt; codepoint
69
iex&gt; rest
"lixir"</pre>
<p>though not entirely equivalent because <code class="inline">codepoint</code> comes as an integer, and the pattern won't match invalid UTF-8.</p>
<p>Binary pattern matching, however, is simpler and more efficient, so pick the option that better suits your use case.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="next_grapheme/1">next_grapheme(binary)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1833" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">next_grapheme(t()) :: {grapheme(), t()} | nil</pre> </div> <p>Returns the next grapheme in a string.</p>
<p>The result is a tuple with the grapheme and the remainder of the string or <code class="inline">nil</code> in case the String reached its end.</p>
<h4 id="next_grapheme/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.next_grapheme("olá")
{"o", "lá"}

iex&gt; String.next_grapheme("")
nil</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="next_grapheme_size/1">next_grapheme_size(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1857" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">next_grapheme_size(t()) :: {pos_integer(), t()} | nil</pre> </div> <p>Returns the size (in bytes) of the next grapheme.</p>
<p>The result is a tuple with the next grapheme size in bytes and the remainder of the string or <code class="inline">nil</code> in case the string reached its end.</p>
<h4 id="next_grapheme_size/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.next_grapheme_size("olá")
{1, "lá"}

iex&gt; String.next_grapheme_size("")
nil</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="normalize/2">normalize(string, form)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L731" class="source">Source</a>
</h3> <section class="docstring"> <p>Converts all characters in <code class="inline">string</code> to Unicode normalization form identified by <code class="inline">form</code>.</p>
<p>Invalid Unicode codepoints are skipped and the remaining of the string is converted. If you want the algorithm to stop and return on invalid codepoint, use <a href="https://erlang.org/doc/man/unicode.html#characters_to_nfd_binary-1"><code class="inline">:unicode.characters_to_nfd_binary/1</code></a>, <a href="https://erlang.org/doc/man/unicode.html#characters_to_nfc_binary-1"><code class="inline">:unicode.characters_to_nfc_binary/1</code></a>, <a href="https://erlang.org/doc/man/unicode.html#characters_to_nfkd_binary-1"><code class="inline">:unicode.characters_to_nfkd_binary/1</code></a>, and <a href="https://erlang.org/doc/man/unicode.html#characters_to_nfkc_binary-1"><code class="inline">:unicode.characters_to_nfkc_binary/1</code></a> instead.</p>
<p>Normalization forms <code class="inline">:nfkc</code> and <code class="inline">:nfkd</code> should not be blindly applied to arbitrary text. Because they erase many formatting distinctions, they will prevent round-trip conversion to and from many legacy character sets.</p>
<h4 id="normalize/2-forms" class="section-heading">  Forms </h4> <p>The supported forms are:</p>
<ul>
<li><p><code class="inline">:nfd</code> - Normalization Form Canonical Decomposition. Characters are decomposed by canonical equivalence, and multiple combining characters are arranged in a specific order.</p></li>
<li><p><code class="inline">:nfc</code> - Normalization Form Canonical Composition. Characters are decomposed and then recomposed by canonical equivalence.</p></li>
<li><p><code class="inline">:nfkd</code> - Normalization Form Compatibility Decomposition. Characters are decomposed by compatibility equivalence, and multiple combining characters are arranged in a specific order.</p></li>
<li><p><code class="inline">:nfkc</code> - Normalization Form Compatibility Composition. Characters are decomposed and then recomposed by compatibility equivalence.</p></li>
</ul>
<h4 id="normalize/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.normalize("yêṩ", :nfd)
"yêṩ"

iex&gt; String.normalize("leña", :nfc)
"leña"

iex&gt; String.normalize("ﬁ", :nfkd)
"fi"

iex&gt; String.normalize("fi", :nfkc)
"fi"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="pad_leading/3">pad_leading(string, count, padding \\ [" "])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1285" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">pad_leading(t(), non_neg_integer(), t() | [t()]) :: t()</pre> </div> <p>Returns a new string padded with a leading filler which is made of elements from the <code class="inline">padding</code>.</p>
<p>Passing a list of strings as <code class="inline">padding</code> will take one element of the list for every missing entry. If the list is shorter than the number of inserts, the filling will start again from the beginning of the list. Passing a string <code class="inline">padding</code> is equivalent to passing the list of graphemes in it. If no <code class="inline">padding</code> is given, it defaults to whitespace.</p>
<p>When <code class="inline">count</code> is less than or equal to the length of <code class="inline">string</code>, given <code class="inline">string</code> is returned.</p>
<p>Raises <a href="argumenterror"><code class="inline">ArgumentError</code></a> if the given <code class="inline">padding</code> contains a non-string element.</p>
<h4 id="pad_leading/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.pad_leading("abc", 5)
"  abc"

iex&gt; String.pad_leading("abc", 4, "12")
"1abc"

iex&gt; String.pad_leading("abc", 6, "12")
"121abc"

iex&gt; String.pad_leading("abc", 5, ["1", "23"])
"123abc"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="pad_trailing/3">pad_trailing(string, count, padding \\ [" "])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1327" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">pad_trailing(t(), non_neg_integer(), t() | [t()]) :: t()</pre> </div> <p>Returns a new string padded with a trailing filler which is made of elements from the <code class="inline">padding</code>.</p>
<p>Passing a list of strings as <code class="inline">padding</code> will take one element of the list for every missing entry. If the list is shorter than the number of inserts, the filling will start again from the beginning of the list. Passing a string <code class="inline">padding</code> is equivalent to passing the list of graphemes in it. If no <code class="inline">padding</code> is given, it defaults to whitespace.</p>
<p>When <code class="inline">count</code> is less than or equal to the length of <code class="inline">string</code>, given <code class="inline">string</code> is returned.</p>
<p>Raises <a href="argumenterror"><code class="inline">ArgumentError</code></a> if the given <code class="inline">padding</code> contains a non-string element.</p>
<h4 id="pad_trailing/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.pad_trailing("abc", 5)
"abc  "

iex&gt; String.pad_trailing("abc", 4, "12")
"abc1"

iex&gt; String.pad_trailing("abc", 6, "12")
"abc121"

iex&gt; String.pad_trailing("abc", 5, ["1", "23"])
"abc123"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="printable?/2">printable?(string, character_limit \\ :infinity)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L314" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">printable?(t(), 0) :: true</pre> <pre data-language="elixir">printable?(t(), pos_integer() | :infinity) :: boolean()</pre> </div> <p>Checks if a string contains only printable characters up to <code class="inline">character_limit</code>.</p>
<p>Takes an optional <code class="inline">character_limit</code> as a second argument. If <code class="inline">character_limit</code> is <code class="inline">0</code>, this function will return <code class="inline">true</code>.</p>
<h4 id="printable?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.printable?("abc")
true

iex&gt; String.printable?("abc" &lt;&gt; &lt;&lt;0&gt;&gt;)
false

iex&gt; String.printable?("abc" &lt;&gt; &lt;&lt;0&gt;&gt;, 2)
true

iex&gt; String.printable?("abc" &lt;&gt; &lt;&lt;0&gt;&gt;, 0)
true</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="replace/4">replace(subject, pattern, replacement, options \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1467" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">replace(t(), pattern() | Regex.t(), t() | (t() -&gt; t() | iodata()), keyword()) ::
  t()</pre> </div> <p>Returns a new string created by replacing occurrences of <code class="inline">pattern</code> in <code class="inline">subject</code> with <code class="inline">replacement</code>.</p>
<p>The <code class="inline">subject</code> is always a string.</p>
<p>The <code class="inline">pattern</code> may be a string, a list of strings, a regular expression, or a compiled pattern.</p>
<p>The <code class="inline">replacement</code> may be a string or a function that receives the matched pattern and must return the replacement as a string or iodata.</p>
<p>By default it replaces all occurrences but this behaviour can be controlled through the <code class="inline">:global</code> option; see the "Options" section below.</p>
<h4 id="replace/4-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:global</code> - (boolean) if <code class="inline">true</code>, all occurrences of <code class="inline">pattern</code> are replaced with <code class="inline">replacement</code>, otherwise only the first occurrence is replaced. Defaults to <code class="inline">true</code>
</li></ul>
<h4 id="replace/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.replace("a,b,c", ",", "-")
"a-b-c"

iex&gt; String.replace("a,b,c", ",", "-", global: false)
"a-b,c"</pre>
<p>The pattern may also be a list of strings and the replacement may also be a function that receives the matches:</p>
<pre data-language="elixir">iex&gt; String.replace("a,b,c", ["a", "c"], fn &lt;&lt;char&gt;&gt; -&gt; &lt;&lt;char + 1&gt;&gt; end)
"b,b,d"</pre>
<p>When the pattern is a regular expression, one can give <code class="inline">\N</code> or <code class="inline">\g{N}</code> in the <code class="inline">replacement</code> string to access a specific capture in the regular expression:</p>
<pre data-language="elixir">iex&gt; String.replace("a,b,c", ~r/,(.)/, ",\\1\\g{1}")
"a,bb,cc"</pre>
<p>Note that we had to escape the backslash escape character (i.e., we used <code class="inline">\\N</code> instead of just <code class="inline">\N</code> to escape the backslash; same thing for <code class="inline">\\g{N}</code>). By giving <code class="inline">\0</code>, one can inject the whole match in the replacement string.</p>
<p>A compiled pattern can also be given:</p>
<pre data-language="elixir">iex&gt; pattern = :binary.compile_pattern(",")
iex&gt; String.replace("a,b,c", pattern, "[]")
"a[]b[]c"</pre>
<p>When an empty string is provided as a <code class="inline">pattern</code>, the function will treat it as an implicit empty string between each grapheme and the string will be interspersed. If an empty string is provided as <code class="inline">replacement</code> the <code class="inline">subject</code> will be returned:</p>
<pre data-language="elixir">iex&gt; String.replace("ELIXIR", "", ".")
".E.L.I.X.I.R."

iex&gt; String.replace("ELIXIR", "", "")
"ELIXIR"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="replace_leading/3">replace_leading(string, match, replacement)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L957" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">replace_leading(t(), t(), t()) :: t()</pre> </div> <p>Replaces all leading occurrences of <code class="inline">match</code> by <code class="inline">replacement</code> of <code class="inline">match</code> in <code class="inline">string</code>.</p>
<p>Returns the string untouched if there are no occurrences.</p>
<p>If <code class="inline">match</code> is <code class="inline">""</code>, this function raises an <a href="argumenterror"><code class="inline">ArgumentError</code></a> exception: this happens because this function replaces <strong>all</strong> the occurrences of <code class="inline">match</code> at the beginning of <code class="inline">string</code>, and it's impossible to replace "multiple" occurrences of <code class="inline">""</code>.</p>
<h4 id="replace_leading/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.replace_leading("hello world", "hello ", "")
"world"
iex&gt; String.replace_leading("hello hello world", "hello ", "")
"world"

iex&gt; String.replace_leading("hello world", "hello ", "ola ")
"ola world"
iex&gt; String.replace_leading("hello hello world", "hello ", "ola ")
"ola ola world"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="replace_prefix/3">replace_prefix(string, match, replacement)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1074" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">replace_prefix(t(), t(), t()) :: t()</pre> </div> <p>Replaces prefix in <code class="inline">string</code> by <code class="inline">replacement</code> if it matches <code class="inline">match</code>.</p>
<p>Returns the string untouched if there is no match. If <code class="inline">match</code> is an empty string (<code class="inline">""</code>), <code class="inline">replacement</code> is just prepended to <code class="inline">string</code>.</p>
<h4 id="replace_prefix/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.replace_prefix("world", "hello ", "")
"world"
iex&gt; String.replace_prefix("hello world", "hello ", "")
"world"
iex&gt; String.replace_prefix("hello hello world", "hello ", "")
"hello world"

iex&gt; String.replace_prefix("world", "hello ", "ola ")
"world"
iex&gt; String.replace_prefix("hello world", "hello ", "ola ")
"ola world"
iex&gt; String.replace_prefix("hello hello world", "hello ", "ola ")
"ola hello world"

iex&gt; String.replace_prefix("world", "", "hello ")
"hello world"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="replace_suffix/3">replace_suffix(string, match, replacement)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1114" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">replace_suffix(t(), t(), t()) :: t()</pre> </div> <p>Replaces suffix in <code class="inline">string</code> by <code class="inline">replacement</code> if it matches <code class="inline">match</code>.</p>
<p>Returns the string untouched if there is no match. If <code class="inline">match</code> is an empty string (<code class="inline">""</code>), <code class="inline">replacement</code> is just appended to <code class="inline">string</code>.</p>
<h4 id="replace_suffix/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.replace_suffix("hello", " world", "")
"hello"
iex&gt; String.replace_suffix("hello world", " world", "")
"hello"
iex&gt; String.replace_suffix("hello world world", " world", "")
"hello world"

iex&gt; String.replace_suffix("hello", " world", " mundo")
"hello"
iex&gt; String.replace_suffix("hello world", " world", " mundo")
"hello mundo"
iex&gt; String.replace_suffix("hello world world", " world", " mundo")
"hello world mundo"

iex&gt; String.replace_suffix("hello", "", " world")
"hello world"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="replace_trailing/3">replace_trailing(string, match, replacement)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1014" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">replace_trailing(t(), t(), t()) :: t()</pre> </div> <p>Replaces all trailing occurrences of <code class="inline">match</code> by <code class="inline">replacement</code> in <code class="inline">string</code>.</p>
<p>Returns the string untouched if there are no occurrences.</p>
<p>If <code class="inline">match</code> is <code class="inline">""</code>, this function raises an <a href="argumenterror"><code class="inline">ArgumentError</code></a> exception: this happens because this function replaces <strong>all</strong> the occurrences of <code class="inline">match</code> at the end of <code class="inline">string</code>, and it's impossible to replace "multiple" occurrences of <code class="inline">""</code>.</p>
<h4 id="replace_trailing/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.replace_trailing("hello world", " world", "")
"hello"
iex&gt; String.replace_trailing("hello world world", " world", "")
"hello"

iex&gt; String.replace_trailing("hello world", " world", " mundo")
"hello mundo"
iex&gt; String.replace_trailing("hello world world", " world", " mundo")
"hello mundo mundo"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="reverse/1">reverse(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1585" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">reverse(t()) :: t()</pre> </div> <p>Reverses the graphemes in given string.</p>
<h4 id="reverse/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.reverse("abcd")
"dcba"

iex&gt; String.reverse("hello world")
"dlrow olleh"

iex&gt; String.reverse("hello ∂og")
"go∂ olleh"</pre>
<p>Keep in mind reversing the same string twice does not necessarily yield the original string:</p>
<pre data-language="elixir">iex&gt; "̀e"
"̀e"
iex&gt; String.reverse("̀e")
"è"
iex&gt; String.reverse(String.reverse("̀e"))
"è"</pre>
<p>In the first example the accent is before the vowel, so it is considered two graphemes. However, when you reverse it once, you have the vowel followed by the accent, which becomes one grapheme. Reversing it again will keep it as one single grapheme.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="slice/2">slice(string, range)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L2086" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">slice(t(), Range.t()) :: t()</pre> </div> <p>Returns a substring from the offset given by the start of the range to the offset given by the end of the range.</p>
<p>If the start of the range is not a valid offset for the given string or if the range is in reverse order, returns <code class="inline">""</code>.</p>
<p>If the start or end of the range is negative, the whole string is traversed first in order to convert the negative indices into positive ones.</p>
<p>Remember this function works with Unicode graphemes and considers the slices to represent grapheme offsets. If you want to split on raw bytes, check <a href="kernel#binary_part/3"><code class="inline">Kernel.binary_part/3</code></a> instead.</p>
<h4 id="slice/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.slice("elixir", 1..3)
"lix"

iex&gt; String.slice("elixir", 1..10)
"lixir"

iex&gt; String.slice("elixir", -4..-1)
"ixir"

iex&gt; String.slice("elixir", -4..6)
"ixir"</pre>
<p>For ranges where <code class="inline">start &gt; stop</code>, you need to explicit mark them as increasing:</p>
<pre data-language="elixir">iex&gt; String.slice("elixir", 2..-1//1)
"ixir"

iex&gt; String.slice("elixir", 1..-2//1)
"lixi"</pre>
<p>If values are out of bounds, it returns an empty string:</p>
<pre data-language="elixir">iex&gt; String.slice("elixir", 10..3)
""

iex&gt; String.slice("elixir", -10..-7)
""

iex&gt; String.slice("a", 0..1500)
"a"

iex&gt; String.slice("a", 1..1500)
""</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="slice/3">slice(string, start, length)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L2004" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">slice(t(), integer(), non_neg_integer()) :: grapheme()</pre> </div> <p>Returns a substring starting at the offset <code class="inline">start</code>, and of the given <code class="inline">length</code>.</p>
<p>If the offset is greater than string length, then it returns <code class="inline">""</code>.</p>
<p>Remember this function works with Unicode graphemes and considers the slices to represent grapheme offsets. If you want to split on raw bytes, check <a href="kernel#binary_part/3"><code class="inline">Kernel.binary_part/3</code></a> instead.</p>
<h4 id="slice/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.slice("elixir", 1, 3)
"lix"

iex&gt; String.slice("elixir", 1, 10)
"lixir"

iex&gt; String.slice("elixir", 10, 3)
""

iex&gt; String.slice("elixir", -4, 4)
"ixir"

iex&gt; String.slice("elixir", -10, 3)
""

iex&gt; String.slice("a", 0, 1500)
"a"

iex&gt; String.slice("a", 1, 1500)
""

iex&gt; String.slice("a", 2, 1500)
""</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="split/1">split(binary)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L372" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">split(t()) :: [t()]</pre> </div> <p>Divides a string into substrings at each Unicode whitespace occurrence with leading and trailing whitespace ignored. Groups of whitespace are treated as a single occurrence. Divisions do not occur on non-breaking whitespace.</p>
<h4 id="split/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.split("foo bar")
["foo", "bar"]

iex&gt; String.split("foo" &lt;&gt; &lt;&lt;194, 133&gt;&gt; &lt;&gt; "bar")
["foo", "bar"]

iex&gt; String.split(" foo   bar ")
["foo", "bar"]

iex&gt; String.split("no\u00a0break")
["no\u00a0break"]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="split/3">split(string, pattern, options \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L471" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">split(t(), pattern() | Regex.t(), keyword()) :: [t()]</pre> </div> <p>Divides a string into parts based on a pattern.</p>
<p>Returns a list of these parts.</p>
<p>The <code class="inline">pattern</code> may be a string, a list of strings, a regular expression, or a compiled pattern.</p>
<p>The string is split into as many parts as possible by default, but can be controlled via the <code class="inline">:parts</code> option.</p>
<p>Empty strings are only removed from the result if the <code class="inline">:trim</code> option is set to <code class="inline">true</code>.</p>
<p>When the pattern used is a regular expression, the string is split using <a href="regex#split/3"><code class="inline">Regex.split/3</code></a>.</p>
<h4 id="split/3-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:parts</code> (positive integer or <code class="inline">:infinity</code>) - the string is split into at most as many parts as this option specifies. If <code class="inline">:infinity</code>, the string will be split into all possible parts. Defaults to <code class="inline">:infinity</code>.</p></li>
<li><p><code class="inline">:trim</code> (boolean) - if <code class="inline">true</code>, empty strings are removed from the resulting list.</p></li>
</ul>
<p>This function also accepts all options accepted by <a href="regex#split/3"><code class="inline">Regex.split/3</code></a> if <code class="inline">pattern</code> is a regular expression.</p>
<h4 id="split/3-examples" class="section-heading">  Examples </h4> <p>Splitting with a string pattern:</p>
<pre data-language="elixir">iex&gt; String.split("a,b,c", ",")
["a", "b", "c"]

iex&gt; String.split("a,b,c", ",", parts: 2)
["a", "b,c"]

iex&gt; String.split(" a b c ", " ", trim: true)
["a", "b", "c"]</pre>
<p>A list of patterns:</p>
<pre data-language="elixir">iex&gt; String.split("1,2 3,4", [" ", ","])
["1", "2", "3", "4"]</pre>
<p>A regular expression:</p>
<pre data-language="elixir">iex&gt; String.split("a,b,c", ~r{,})
["a", "b", "c"]

iex&gt; String.split("a,b,c", ~r{,}, parts: 2)
["a", "b,c"]

iex&gt; String.split(" a b c ", ~r{\s}, trim: true)
["a", "b", "c"]

iex&gt; String.split("abc", ~r{b}, include_captures: true)
["a", "b", "c"]</pre>
<p>A compiled pattern:</p>
<pre data-language="elixir">iex&gt; pattern = :binary.compile_pattern([" ", ","])
iex&gt; String.split("1,2 3,4", pattern)
["1", "2", "3", "4"]</pre>
<p>Splitting on empty string returns graphemes:</p>
<pre data-language="elixir">iex&gt; String.split("abc", "")
["", "a", "b", "c", ""]

iex&gt; String.split("abc", "", trim: true)
["a", "b", "c"]

iex&gt; String.split("abc", "", parts: 1)
["abc"]

iex&gt; String.split("abc", "", parts: 3)
["", "a", "bc"]</pre>
<p>Be aware that this function can split within or across grapheme boundaries. For example, take the grapheme "é" which is made of the characters "e" and the acute accent. The following will split the string into two parts:</p>
<pre data-language="elixir">iex&gt; String.split(String.normalize("é", :nfd), "e")
["", "́"]</pre>
<p>However, if "é" is represented by the single character "e with acute" accent, then it will split the string into just one part:</p>
<pre data-language="elixir">iex&gt; String.split(String.normalize("é", :nfc), "e")
["é"]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="split_at/2">split_at(string, position)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L627" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">split_at(t(), integer()) :: {t(), t()}</pre> </div> <p>Splits a string into two at the specified offset. When the offset given is negative, location is counted from the end of the string.</p>
<p>The offset is capped to the length of the string. Returns a tuple with two elements.</p>
<p>Note: keep in mind this function splits on graphemes and for such it has to linearly traverse the string. If you want to split a string or a binary based on the number of bytes, use <a href="kernel#binary_part/3"><code class="inline">Kernel.binary_part/3</code></a> instead.</p>
<h4 id="split_at/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.split_at("sweetelixir", 5)
{"sweet", "elixir"}

iex&gt; String.split_at("sweetelixir", -6)
{"sweet", "elixir"}

iex&gt; String.split_at("abc", 0)
{"", "abc"}

iex&gt; String.split_at("abc", 1000)
{"abc", ""}

iex&gt; String.split_at("abc", -1000)
{"", "abc"}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="splitter/3">splitter(string, pattern, options \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L560" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">splitter(t(), pattern(), keyword()) :: Enumerable.t()</pre> </div> <p>Returns an enumerable that splits a string on demand.</p>
<p>This is in contrast to <a href="#split/3"><code class="inline">split/3</code></a> which splits the entire string upfront.</p>
<p>This function does not support regular expressions by design. When using regular expressions, it is often more efficient to have the regular expressions traverse the string at once than in parts, like this function does.</p>
<h4 id="splitter/3-options" class="section-heading">  Options </h4> <ul><li>:trim - when <code class="inline">true</code>, does not emit empty patterns</li></ul>
<h4 id="splitter/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.splitter("1,2 3,4 5,6 7,8,...,99999", [" ", ","]) |&gt; Enum.take(4)
["1", "2", "3", "4"]

iex&gt; String.splitter("abcd", "") |&gt; Enum.take(10)
["", "a", "b", "c", "d", ""]

iex&gt; String.splitter("abcd", "", trim: true) |&gt; Enum.take(10)
["a", "b", "c", "d"]</pre>
<p>A compiled pattern can also be given:</p>
<pre data-language="elixir">iex&gt; pattern = :binary.compile_pattern([" ", ","])
iex&gt; String.splitter("1,2 3,4 5,6 7,8,...,99999", pattern) |&gt; Enum.take(4)
["1", "2", "3", "4"]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="starts_with?/2">starts_with?(string, prefix)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L2179" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">starts_with?(t(), pattern()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">string</code> starts with any of the prefixes given.</p>
<p><code class="inline">prefix</code> can be either a string, a list of strings, or a compiled pattern.</p>
<h4 id="starts_with?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.starts_with?("elixir", "eli")
true
iex&gt; String.starts_with?("elixir", ["erlang", "elixir"])
true
iex&gt; String.starts_with?("elixir", ["erlang", "ruby"])
false</pre>
<p>A compiled pattern can also be given:</p>
<pre data-language="elixir">iex&gt; pattern = :binary.compile_pattern(["erlang", "elixir"])
iex&gt; String.starts_with?("elixir", pattern)
true</pre>
<p>An empty string will always match:</p>
<pre data-language="elixir">iex&gt; String.starts_with?("elixir", "")
true
iex&gt; String.starts_with?("elixir", ["", "other"])
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_atom/1">to_atom(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L2370" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_atom(t()) :: atom()</pre> </div> <p>Converts a string to an atom.</p>
<p>Warning: this function creates atoms dynamically and atoms are not garbage-collected. Therefore, <code class="inline">string</code> should not be an untrusted value, such as input received from a socket or during a web request. Consider using <a href="#to_existing_atom/1"><code class="inline">to_existing_atom/1</code></a> instead.</p>
<p>By default, the maximum number of atoms is <code class="inline">1_048_576</code>. This limit can be raised or lowered using the VM option <code class="inline">+t</code>.</p>
<p>The maximum atom size is of 255 Unicode code points.</p>
<p>Inlined by the compiler.</p>
<h4 id="to_atom/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.to_atom("my_atom")
:my_atom</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_charlist/1">to_charlist(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L2335" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_charlist(t()) :: charlist()</pre> </div> <p>Converts a string into a charlist.</p>
<p>Specifically, this function takes a UTF-8 encoded binary and returns a list of its integer code points. It is similar to <a href="#codepoints/1"><code class="inline">codepoints/1</code></a> except that the latter returns a list of code points as strings.</p>
<p>In case you need to work with bytes, take a look at the <a href="https://erlang.org/doc/man/binary.html"><code class="inline">:binary</code> module</a>.</p>
<h4 id="to_charlist/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.to_charlist("æß")
'æß'</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_existing_atom/1">to_existing_atom(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L2389" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_existing_atom(t()) :: atom()</pre> </div> <p>Converts a string to an existing atom.</p>
<p>The maximum atom size is of 255 Unicode code points.</p>
<p>Inlined by the compiler.</p>
<h4 id="to_existing_atom/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; _ = :my_atom
iex&gt; String.to_existing_atom("my_atom")
:my_atom</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_float/1">to_float(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L2457" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_float(t()) :: float()</pre> </div> <p>Returns a float whose text representation is <code class="inline">string</code>.</p>
<p><code class="inline">string</code> must be the string representation of a float including a decimal point. In order to parse a string without decimal point as a float then <a href="float#parse/1"><code class="inline">Float.parse/1</code></a> should be used. Otherwise, an <a href="argumenterror"><code class="inline">ArgumentError</code></a> will be raised.</p>
<p>Inlined by the compiler.</p>
<h4 id="to_float/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.to_float("2.2017764e+0")
2.2017764

iex&gt; String.to_float("3.0")
3.0

String.to_float("3")
** (ArgumentError) argument error</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_integer/1">to_integer(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L2415" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_integer(t()) :: integer()</pre> </div> <p>Returns an integer whose text representation is <code class="inline">string</code>.</p>
<p><code class="inline">string</code> must be the string representation of an integer. Otherwise, an <a href="argumenterror"><code class="inline">ArgumentError</code></a> will be raised. If you want to parse a string that may contain an ill-formatted integer, use <a href="integer#parse/1"><code class="inline">Integer.parse/1</code></a>.</p>
<p>Inlined by the compiler.</p>
<h4 id="to_integer/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.to_integer("123")
123</pre>
<p>Passing a string that does not represent an integer leads to an error:</p>
<pre data-language="elixir">String.to_integer("invalid data")
** (ArgumentError) argument error</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_integer/2">to_integer(string, base)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L2431" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">to_integer(t(), 2..36) :: integer()</pre> </div> <p>Returns an integer whose text representation is <code class="inline">string</code> in base <code class="inline">base</code>.</p>
<p>Inlined by the compiler.</p>
<h4 id="to_integer/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.to_integer("3FF", 16)
1023</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="trim/1">trim(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1231" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">trim(t()) :: t()</pre> </div> <p>Returns a string where all leading and trailing Unicode whitespaces have been removed.</p>
<h4 id="trim/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.trim("\n  abc\n  ")
"abc"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="trim/2">trim(string, to_trim)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1248" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">trim(t(), t()) :: t()</pre> </div> <p>Returns a string where all leading and trailing <code class="inline">to_trim</code> characters have been removed.</p>
<h4 id="trim/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.trim("a  abc  a", "a")
"  abc  "</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="trim_leading/1">trim_leading(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1169" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">trim_leading(t()) :: t()</pre> </div> <p>Returns a string where all leading Unicode whitespaces have been removed.</p>
<h4 id="trim_leading/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.trim_leading("\n  abc   ")
"abc   "</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="trim_leading/2">trim_leading(string, to_trim)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1184" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">trim_leading(t(), t()) :: t()</pre> </div> <p>Returns a string where all leading <code class="inline">to_trim</code> characters have been removed.</p>
<h4 id="trim_leading/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.trim_leading("__ abc _", "_")
" abc _"

iex&gt; String.trim_leading("1 abc", "11")
"1 abc"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="trim_trailing/1">trim_trailing(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1200" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">trim_trailing(t()) :: t()</pre> </div> <p>Returns a string where all trailing Unicode whitespaces has been removed.</p>
<h4 id="trim_trailing/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.trim_trailing("   abc\n  ")
"   abc"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="trim_trailing/2">trim_trailing(string, to_trim)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1215" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">trim_trailing(t(), t()) :: t()</pre> </div> <p>Returns a string where all trailing <code class="inline">to_trim</code> characters have been removed.</p>
<h4 id="trim_trailing/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.trim_trailing("_ abc __", "_")
"_ abc "

iex&gt; String.trim_trailing("abc 1", "11")
"abc 1"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="upcase/2">upcase(string, mode \\ :default)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L797" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">upcase(t(), :default | :ascii | :greek | :turkic) :: t()</pre> </div> <p>Converts all characters in the given string to uppercase according to <code class="inline">mode</code>.</p>
<p><code class="inline">mode</code> may be <code class="inline">:default</code>, <code class="inline">:ascii</code>, <code class="inline">:greek</code> or <code class="inline">:turkic</code>. The <code class="inline">:default</code> mode considers all non-conditional transformations outlined in the Unicode standard. <code class="inline">:ascii</code> uppercases only the letters a to z. <code class="inline">:greek</code> includes the context sensitive mappings found in Greek. <code class="inline">:turkic</code> properly handles the letter i with the dotless variant.</p>
<h4 id="upcase/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.upcase("abcd")
"ABCD"

iex&gt; String.upcase("ab 123 xpto")
"AB 123 XPTO"

iex&gt; String.upcase("olá")
"OLÁ"</pre>
<p>The <code class="inline">:ascii</code> mode ignores Unicode characters and provides a more performant implementation when you know the string contains only ASCII characters:</p>
<pre data-language="elixir">iex&gt; String.upcase("olá", :ascii)
"OLá"</pre>
<p>And <code class="inline">:turkic</code> properly handles the letter i with the dotless variant:</p>
<pre data-language="elixir">iex&gt; String.upcase("ıi")
"II"

iex&gt; String.upcase("ıi", :turkic)
"Iİ"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="valid?/1">valid?(arg1)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/string.ex#L1715" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">valid?(t()) :: boolean()</pre> </div> <p>Checks whether <code class="inline">string</code> contains only valid characters.</p>
<h4 id="valid?/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; String.valid?("a")
true

iex&gt; String.valid?("ø")
true

iex&gt; String.valid?(&lt;&lt;0xFFFF::16&gt;&gt;)
false

iex&gt; String.valid?(&lt;&lt;0xEF, 0xB7, 0x90&gt;&gt;)
true

iex&gt; String.valid?("asd" &lt;&gt; &lt;&lt;0xFFFF::16&gt;&gt;)
false</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/elixir/1.12.0/String.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.12.0/String.html</a>
  </p>
</div>
