<div class="getting-started-title"> <small>Getting Started</small> <h1>Optional syntax sheet</h1> </div>  <p>In this guide so far, we learned that the Elixir syntax allows developers to omit delimiters in a few occasions to make code more readable. For example, we learned that parentheses are optional:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; length([1, 2, 3]) == length [1, 2, 3]
true
</pre></div> <p>and that <code class="language-plaintext highlighter-rouge">do</code>-<code class="language-plaintext highlighter-rouge">end</code> blocks are equivalent to keyword lists:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language=""># do-end blocks
iex&gt; if true do
...&gt;   :this
...&gt; else
...&gt;   :that
...&gt; end

# keyword lists
iex&gt; if true, do: :this, else: :that
:this
</pre></div> <p>Those conveniences, which we call here “optional syntax”, allow the language syntax core to be small, without sacrificing the readability and expressiveness of your code. This is what allows us to write:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule Math do
  def add(a, b) do
    a + b
  end
end
</pre></div> <p>instead of:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule(Math, [
  {:do, def(add(a, b), [{:do, a + b}])}
])
</pre></div> <p>In this brief chapter, we will review the four rules provided by the language, using a short snippet as playground.</p> <h2 id="walk-through">Walk-through</h2> <p>Take the following code:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">if variable? do
  Call.this()
else
  Call.that()
end
</pre></div> <p>Now let’s remove the conveniences one by one:</p> <ol> <li> <p><code class="language-plaintext highlighter-rouge">do</code>-<code class="language-plaintext highlighter-rouge">end</code> blocks are equivalent to keywords:</p> <div class="language-elixir highlighter-rouge">
<pre class="highlight" data-language="">if variable?, do: Call.this(), else: Call.that()
</pre> </div> </li> <li> <p>Keyword lists as last argument do not require square brackets, but let’s add them:</p> <div class="language-elixir highlighter-rouge">
<pre class="highlight" data-language="">if variable?, [do: Call.this(), else: Call.that()]
</pre> </div> </li> <li> <p>Keyword lists are the same as lists of two-element tuples:</p> <div class="language-elixir highlighter-rouge">
<pre class="highlight" data-language="">if variable?, [{:do, Call.this()}, {:else, Call.that()}]
</pre> </div> </li> <li> <p>Finally, parentheses are optional, but let’s add them:</p> <div class="language-elixir highlighter-rouge">
<pre class="highlight" data-language="">if(variable?, [{:do, Call.this()}, {:else, Call.that()}])
</pre> </div> </li> </ol> <p>That’s it! Those four rules outline the optional syntax of the majority of the code we have written so far. Whenever you have any questions, this quick walk-through has you covered.</p> <p>In their day to day, Elixir developers use the <a href="https://hexdocs.pm/mix/Mix.Tasks.Format.html"><code class="language-plaintext highlighter-rouge">mix format</code></a> task to format their codebase according to a well-defined set of rules defined by the Elixir team and the community. For instance, <code class="language-plaintext highlighter-rouge">mix format</code> will always add parentheses to function calls unless explicitly configured to not do so. This ensures all codebases in your company and in the community follow the same standards.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://elixir-lang.org/getting-started/optional-syntax.html" class="_attribution-link" target="_blank">https://elixir-lang.org/getting-started/optional-syntax.html</a>
  </p>
</div>
