<h1> Path   </h1> <section id="moduledoc"> <p>This module provides conveniences for manipulating or retrieving file system paths.</p>
<p>The functions in this module may receive a chardata as argument (i.e. a string or a list of characters / string) and will always return a string (encoded in UTF-8).</p>
<p>The majority of the functions in this module do not interact with the file system, except for a few functions that require it (like <a href="#wildcard/2"><code class="inline">wildcard/2</code></a> and <a href="#expand/1"><code class="inline">expand/1</code></a>).</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#absname/1">absname(path)</a> </dt> <dd class="summary-synopsis"><p>Converts the given path to an absolute one. Unlike <a href="#expand/1"><code class="inline">expand/1</code></a>, no attempt is made to resolve <code class="inline">..</code>, <code class="inline">.</code> or <code class="inline">~</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#absname/2">absname(path, relative_to)</a> </dt> <dd class="summary-synopsis"><p>Builds a path from <code class="inline">relative_to</code> to <code class="inline">path</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#basename/1">basename(path)</a> </dt> <dd class="summary-synopsis"><p>Returns the last component of the path or the path itself if it does not contain any directory separators.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#basename/2">basename(path, extension)</a> </dt> <dd class="summary-synopsis"><p>Returns the last component of <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#dirname/1">dirname(path)</a> </dt> <dd class="summary-synopsis"><p>Returns the directory component of <code class="inline">path</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#expand/1">expand(path)</a> </dt> <dd class="summary-synopsis"><p>Converts the path to an absolute one and expands any <code class="inline">.</code> and <code class="inline">..</code> characters and a leading <code class="inline">~</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#expand/2">expand(path, relative_to)</a> </dt> <dd class="summary-synopsis"><p>Expands the path relative to the path given as the second argument expanding any <code class="inline">.</code> and <code class="inline">..</code> characters.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#extname/1">extname(path)</a> </dt> <dd class="summary-synopsis"><p>Returns the extension of the last component of <code class="inline">path</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#join/1">join(list)</a> </dt> <dd class="summary-synopsis"><p>Joins a list of paths.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#join/2">join(left, right)</a> </dt> <dd class="summary-synopsis"><p>Joins two paths.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#relative/1">relative(name)</a> </dt> <dd class="summary-synopsis"><p>Forces the path to be a relative path.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#relative_to/2">relative_to(path, from)</a> </dt> <dd class="summary-synopsis"><p>Returns the given <code class="inline">path</code> relative to the given <code class="inline">from</code> path.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#relative_to_cwd/1">relative_to_cwd(path)</a> </dt> <dd class="summary-synopsis"><p>Convenience to get the path relative to the current working directory.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#rootname/1">rootname(path)</a> </dt> <dd class="summary-synopsis"><p>Returns the <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#rootname/2">rootname(path, extension)</a> </dt> <dd class="summary-synopsis"><p>Returns the <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#split/1">split(path)</a> </dt> <dd class="summary-synopsis"><p>Splits the path into a list at the path separator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#type/1">type(name)</a> </dt> <dd class="summary-synopsis"><p>Returns the path type.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#wildcard/2">wildcard(glob, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Traverses paths according to the given <code class="inline">glob</code> expression and returns a list of matches.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/path.ex#L15" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">t() :: IO.chardata()</pre> </div> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="absname/1">absname(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/path.ex#L41" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">absname(t()) :: binary()</pre> </div> <p>Converts the given path to an absolute one. Unlike <a href="#expand/1"><code class="inline">expand/1</code></a>, no attempt is made to resolve <code class="inline">..</code>, <code class="inline">.</code> or <code class="inline">~</code>.</p>
<h4 id="absname/1-examples" class="section-heading">  Examples </h4> <h3 id="absname/1-unix-like-operating-systems" class="section-heading">  Unix-like operating systems </h3> <pre data-language="elixir">Path.absname("foo")
#=&gt; "/usr/local/foo"

Path.absname("../x")
#=&gt; "/usr/local/../x"</pre>
<h3 id="absname/1-windows" class="section-heading">  Windows </h3> <pre data-language="elixir">Path.absname("foo")
#=&gt; "D:/usr/local/foo"

Path.absname("../x")
#=&gt; "D:/usr/local/../x"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="absname/2">absname(path, relative_to)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/path.ex#L64" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">absname(t(), t()) :: binary()</pre> </div> <p>Builds a path from <code class="inline">relative_to</code> to <code class="inline">path</code>.</p>
<p>If <code class="inline">path</code> is already an absolute path, <code class="inline">relative_to</code> is ignored. See also <a href="#relative_to/2"><code class="inline">relative_to/2</code></a>.</p>
<p>Unlike <a href="#expand/2"><code class="inline">expand/2</code></a>, no attempt is made to resolve <code class="inline">..</code>, <code class="inline">.</code> or <code class="inline">~</code>.</p>
<h4 id="absname/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.absname("foo", "bar")
"bar/foo"

iex&gt; Path.absname("../x", "bar")
"bar/../x"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="basename/1">basename(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/path.ex#L374" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">basename(t()) :: binary()</pre> </div> <p>Returns the last component of the path or the path itself if it does not contain any directory separators.</p>
<h4 id="basename/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.basename("foo")
"foo"

iex&gt; Path.basename("foo/bar")
"bar"

iex&gt; Path.basename("/")
""</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="basename/2">basename(path, extension)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/path.ex#L398" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">basename(t(), t()) :: binary()</pre> </div> <p>Returns the last component of <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p>
<p>This function should be used to remove a specific extension which may or may not be there.</p>
<h4 id="basename/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.basename("~/foo/bar.ex", ".ex")
"bar"

iex&gt; Path.basename("~/foo/bar.exs", ".ex")
"bar.exs"

iex&gt; Path.basename("~/foo/bar.old.ex", ".ex")
"bar.old"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="dirname/1">dirname(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/path.ex#L421" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">dirname(t()) :: binary()</pre> </div> <p>Returns the directory component of <code class="inline">path</code>.</p>
<h4 id="dirname/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.dirname("/foo/bar.ex")
"/foo"

iex&gt; Path.dirname("/foo/bar/baz.ex")
"/foo/bar"

iex&gt; Path.dirname("/foo/bar/")
"/foo/bar"

iex&gt; Path.dirname("bar.ex")
"."</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="expand/1">expand(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/path.ex#L160" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">expand(t()) :: binary()</pre> </div> <p>Converts the path to an absolute one and expands any <code class="inline">.</code> and <code class="inline">..</code> characters and a leading <code class="inline">~</code>.</p>
<h4 id="expand/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Path.expand("/foo/bar/../baz")
#=&gt; "/foo/baz"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="expand/2">expand(path, relative_to)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/path.ex#L189" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">expand(t(), t()) :: binary()</pre> </div> <p>Expands the path relative to the path given as the second argument expanding any <code class="inline">.</code> and <code class="inline">..</code> characters.</p>
<p>If the path is already an absolute path, <code class="inline">relative_to</code> is ignored.</p>
<p>Note that this function treats a <code class="inline">path</code> with a leading <code class="inline">~</code> as an absolute one.</p>
<p>The second argument is first expanded to an absolute path.</p>
<h4 id="expand/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Assuming that the absolute path to baz is /quux/baz
Path.expand("foo/bar/../bar", "baz")
#=&gt; "/quux/baz/foo/bar"

Path.expand("foo/bar/../bar", "/baz")
#=&gt; "/baz/foo/bar"

Path.expand("/foo/bar/../bar", "/baz")
#=&gt; "/foo/bar"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="extname/1">extname(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/path.ex#L438" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">extname(t()) :: binary()</pre> </div> <p>Returns the extension of the last component of <code class="inline">path</code>.</p>
<h4 id="extname/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.extname("foo.erl")
".erl"

iex&gt; Path.extname("~/foo/bar")
""</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="join/1">join(list)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/path.ex#L498" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">join([t(), ...]) :: binary()</pre> </div> <p>Joins a list of paths.</p>
<p>This function should be used to convert a list of paths to a path. Note that any trailing slash is removed when joining.</p>
<h4 id="join/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.join(["~", "foo"])
"~/foo"

iex&gt; Path.join(["foo"])
"foo"

iex&gt; Path.join(["/", "foo", "bar/"])
"/foo/bar"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="join/2">join(left, right)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/path.ex#L526" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">join(t(), t()) :: binary()</pre> </div> <p>Joins two paths.</p>
<p>The right path will always be expanded to its relative format and any trailing slash will be removed when joining.</p>
<h4 id="join/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.join("foo", "bar")
"foo/bar"

iex&gt; Path.join("/foo", "/bar/")
"/foo/bar"</pre>
<p>The functions in this module support chardata, so giving a list will treat it as a single entity:</p>
<pre data-language="elixir">iex&gt; Path.join("foo", ["bar", "fiz"])
"foo/barfiz"

iex&gt; Path.join(["foo", "bar"], "fiz")
"foobar/fiz"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="relative/1">relative(name)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/path.ex#L241" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">relative(t()) :: binary()</pre> </div> <p>Forces the path to be a relative path.</p>
<h4 id="relative/1-examples" class="section-heading">  Examples </h4> <h3 id="relative/1-unix-like-operating-systems" class="section-heading">  Unix-like operating systems </h3> <pre data-language="elixir">Path.relative("/usr/local/bin")   #=&gt; "usr/local/bin"
Path.relative("usr/local/bin")    #=&gt; "usr/local/bin"
Path.relative("../usr/local/bin") #=&gt; "../usr/local/bin"</pre>
<h3 id="relative/1-windows" class="section-heading">  Windows </h3> <pre data-language="elixir">Path.relative("D:/usr/local/bin") #=&gt; "usr/local/bin"
Path.relative("usr/local/bin")    #=&gt; "usr/local/bin"
Path.relative("D:bar.ex")         #=&gt; "bar.ex"
Path.relative("/bar/foo.ex")      #=&gt; "bar/foo.ex"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="relative_to/2">relative_to(path, from)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/path.ex#L321" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">relative_to(t(), t()) :: binary()</pre> </div> <p>Returns the given <code class="inline">path</code> relative to the given <code class="inline">from</code> path.</p>
<p>In other words, this function tries to strip the <code class="inline">from</code> prefix from <code class="inline">path</code>.</p>
<p>This function does not query the file system, so it assumes no symlinks between the paths.</p>
<p>In case a direct relative path cannot be found, it returns the original path.</p>
<h4 id="relative_to/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.relative_to("/usr/local/foo", "/usr/local")
"foo"

iex&gt; Path.relative_to("/usr/local/foo", "/")
"usr/local/foo"

iex&gt; Path.relative_to("/usr/local/foo", "/etc")
"/usr/local/foo"

iex&gt; Path.relative_to("/usr/local/foo", "/usr/local/foo")
"."</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="relative_to_cwd/1">relative_to_cwd(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/path.ex#L350" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">relative_to_cwd(t()) :: binary()</pre> </div> <p>Convenience to get the path relative to the current working directory.</p>
<p>If, for some reason, the current working directory cannot be retrieved, this function returns the given <code class="inline">path</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="rootname/1">rootname(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/path.ex#L455" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">rootname(t()) :: binary()</pre> </div> <p>Returns the <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p>
<h4 id="rootname/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.rootname("/foo/bar")
"/foo/bar"

iex&gt; Path.rootname("/foo/bar.ex")
"/foo/bar"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="rootname/2">rootname(path, extension)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/path.ex#L475" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">rootname(t(), t()) :: binary()</pre> </div> <p>Returns the <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p>
<p>This function should be used to remove a specific extension which may or may not be there.</p>
<h4 id="rootname/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.rootname("/foo/bar.erl", ".erl")
"/foo/bar"

iex&gt; Path.rootname("/foo/bar.erl", ".ex")
"/foo/bar.erl"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="split/1">split(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/path.ex#L575" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">split(t()) :: [binary()]</pre> </div> <p>Splits the path into a list at the path separator.</p>
<p>If an empty string is given, returns an empty list.</p>
<p>On Windows, path is split on both "\" and "/" separators and the driver letter, if there is one, is always returned in lowercase.</p>
<h4 id="split/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Path.split("")
[]

iex&gt; Path.split("foo")
["foo"]

iex&gt; Path.split("/foo/bar")
["/", "foo", "bar"]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="type/1">type(name)<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/path.ex#L215" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">type(t()) :: :absolute | :relative | :volumerelative</pre> </div> <p>Returns the path type.</p>
<h4 id="type/1-examples" class="section-heading">  Examples </h4> <h3 id="type/1-unix-like-operating-systems" class="section-heading">  Unix-like operating systems </h3> <pre data-language="elixir">Path.type("/")                #=&gt; :absolute
Path.type("/usr/local/bin")   #=&gt; :absolute
Path.type("usr/local/bin")    #=&gt; :relative
Path.type("../usr/local/bin") #=&gt; :relative
Path.type("~/file")           #=&gt; :relative</pre>
<h3 id="type/1-windows" class="section-heading">  Windows </h3> <pre data-language="elixir">Path.type("D:/usr/local/bin") #=&gt; :absolute
Path.type("usr/local/bin")    #=&gt; :relative
Path.type("D:bar.ex")         #=&gt; :volumerelative
Path.type("/bar/foo.ex")      #=&gt; :volumerelative</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="wildcard/2">wildcard(glob, opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.12.0/lib/elixir/lib/path.ex#L650" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">wildcard(t(), keyword()) :: [binary()]</pre> </div> <p>Traverses paths according to the given <code class="inline">glob</code> expression and returns a list of matches.</p>
<p>The wildcard looks like an ordinary path, except that the following "wildcard characters" are interpreted in a special way:</p>
<ul>
<li><p><code class="inline">?</code> - matches one character.</p></li>
<li><p><code class="inline">*</code> - matches any number of characters up to the end of the filename, the next dot, or the next slash.</p></li>
<li><p><code class="inline">**</code> - two adjacent <code class="inline">*</code>'s used as a single pattern will match all files and zero or more directories and subdirectories.</p></li>
<li><p><code class="inline">[char1,char2,...]</code> - matches any of the characters listed; two characters separated by a hyphen will match a range of characters. Do not add spaces before and after the comma as it would then match paths containing the space character itself.</p></li>
<li><p><code class="inline">{item1,item2,...}</code> - matches one of the alternatives. Do not add spaces before and after the comma as it would then match paths containing the space character itself.</p></li>
</ul>
<p>Other characters represent themselves. Only paths that have exactly the same character in the same position will match. Note that matching is case-sensitive: <code class="inline">"a"</code> will not match <code class="inline">"A"</code>.</p>
<p>Directory separators must always be written as <code class="inline">/</code>, even on Windows. You may call <a href="#expand/1"><code class="inline">Path.expand/1</code></a> to normalize the path before invoking this function.</p>
<p>By default, the patterns <code class="inline">*</code> and <code class="inline">?</code> do not match files starting with a dot <code class="inline">.</code>. See the <code class="inline">:match_dot</code> option in the "Options" section below.</p>
<h4 id="wildcard/2-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:match_dot</code> - (boolean) if <code class="inline">false</code>, the special wildcard characters <code class="inline">*</code> and <code class="inline">?</code> will not match files starting with a dot (<code class="inline">.</code>). If <code class="inline">true</code>, files starting with a <code class="inline">.</code> will not be treated specially. Defaults to <code class="inline">false</code>.</li></ul>
<h4 id="wildcard/2-examples" class="section-heading">  Examples </h4> <p>Imagine you have a directory called <code class="inline">projects</code> with three Elixir projects inside of it: <code class="inline">elixir</code>, <code class="inline">ex_doc</code>, and <code class="inline">plug</code>. You can find all <code class="inline">.beam</code> files inside the <code class="inline">ebin</code> directory of each project as follows:</p>
<pre data-language="elixir">Path.wildcard("projects/*/ebin/**/*.beam")</pre>
<p>If you want to search for both <code class="inline">.beam</code> and <code class="inline">.app</code> files, you could do:</p>
<pre data-language="elixir">Path.wildcard("projects/*/ebin/**/*.{beam,app}")</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/elixir/1.12.0/Path.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.12.0/Path.html</a>
  </p>
</div>
