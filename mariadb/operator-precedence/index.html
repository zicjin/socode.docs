<h1>Operator Precedence</h1> <div> <div class="node creole"> <div class="answer formatted"> <p>The precedence is the order in which the SQL operators are evaluated.</p> <p>The following list shows the SQL operator precedence. Operators that appear first in the list have a higher precedence. Operators which are listed together have the same precedence.</p> <ul>
<li>
<code><a href="../date-and-time-units/index">INTERVAL</a></code> </li>
<li>
<code><a href="../binary-operator/index">BINARY</a></code>, <code><a href="../setting-character-sets-and-collations/index#literals">COLLATE</a></code> </li>
<li>
<code><a href="../not/index">!</a></code> </li>
<li>
<code><a href="../subtraction-operator-/index">-</a></code> (unary minus), [[bitwise-not|]] (unary bit inversion) </li>
<li>
<code>||</code> (string concatenation) </li>
<li>
<code><a href="../bitwise-xor/index">^</a></code> </li>
<li>
<code><a href="../multiplication-operator/index">*</a></code>, <code><a href="../division-operator/index">/</a></code>, <code><a href="../div/index">DIV</a></code>, <code><a href="../modulo-operator/index">%</a></code>, <code><a href="../mod/index">MOD</a></code> </li>
<li>
<code><a href="../subtraction-operator-/index">-</a></code>, <code><a href="../addition-operator/index">+</a></code> </li>
<li>
<code><a href="../shift-left/index">&lt;&lt;</a></code>, <code><a href="../shift-right/index">&gt;&gt;</a></code> </li>
<li>
<code><a href="bitwise-and">&amp;</a></code> </li>
<li>
<code><a href="../bitwise-or/index">|</a></code> </li>
<li>
<code><a href="../equal/index">=</a></code> (comparison), <code><a href="../null-safe-equal/index">&lt;=&gt;</a></code>, <code><a href="../greater-than-or-equal/index">&gt;=</a></code>, <code><a href="../greater-than/index">&gt;</a></code>, <code><a href="../less-than-or-equal/index">&lt;=</a></code>, <code><a href="../less-than/index">&lt;</a></code>, <code><a href="../not-equal/index">&lt;&gt;</a></code>, <code><a href="../not-equal/index">!=</a></code>, <code><a href="../is/index">IS</a></code>, <code><a href="../like/index">LIKE</a></code>, <code><a href="../regexp/index">REGEXP</a></code>, <code><a href="../in/index">IN</a></code> </li>
<li>
<code><a href="../between-and/index">BETWEEN</a></code>, <a href="../case-operator/index"><code>CASE</code>, <code>WHEN</code>, <code>THEN</code>, <code>ELSE</code>, <code>END</code></a> </li>
<li>
<code><a href="../not/index">NOT</a></code> </li>
<li>
<code><a href="../and/index">&amp;&amp;</a></code>, <code><a href="../and/index">AND</a></code> </li>
<li>
<code><a href="../xor/index">XOR</a></code> </li>
<li>
<code><a href="../or/index">||</a></code> (logical or), <code><a href="../or/index">OR</a></code> </li>
<li>
<code><a href="../assignment-operators-assignment-operator/index">=</a></code> (assignment), <code><a href="../assignment-operator/index">:=</a></code> </li>
</ul> <p>Functions precedence is always higher than operators precedence.</p> <p>In this page <code>CASE</code> refers to the <a href="../case-operator/index">CASE operator</a>, not to the <a href="../case-statement/index">CASE statement</a><code>.</code></p> <p>If the <code>HIGH_NOT_PRECEDENCE</code> <a href="../sql-mode/index">SQL_MODE</a> is set, <code>NOT</code> has the same precedence as <code>!</code>.</p> <p>The <code>||</code> operator's precedence, as well as its meaning, depends on the <code>PIPES_AS_CONCAT</code> <a href="../sql-mode/index">SQL_MODE</a> flag: if it is on, <code>||</code> can be used to concatenate strings (like the <a href="../concat/index">CONCAT()</a> function) and has a higher precedence.</p> <p>The <code>=</code> operator's precedence depends on the context - it is higher when <code>=</code> is used as a comparison operator.</p> <p><a href="../parenthesis/index">Parenthesis</a> can be used to modify the operators precedence in an expression.</p> <h2 class="anchored_heading" id="short-circuit-evaluation">Short-circuit evaluation</h2> <p>The <code>AND</code>, <code>OR</code>, <code>&amp;&amp;</code> and <code>||</code> operators support short-circuit evaluation. This means that, in some cases, the expression on the right of those operators is not evaluated, because its result cannot affect the result. In the following cases, short-circuit evaluation is used and <code>x()</code> is not evaluated:</p> <ul start="1">
<li>
<code>FALSE AND x()</code> </li>
<li>
<code>FALSE &amp;&amp; x()</code> </li>
<li>
<code>TRUE OR x()</code> </li>
<li>
<code>TRUE || x()</code> </li>
<li>
<code>NULL BETWEEN x() AND x()</code> </li>
</ul> <p>Note however that the short-circuit evaluation does <em>not</em> apply to <code>NULL AND x()</code>. Also, <code>BETWEEN</code>'s right operands are not evaluated if the left operand is <code>NULL</code>, but in all other cases all the operands are evaluated.</p> <p>This is a speed optimization. Also, since functions can have side-effects, this behavior can be used to choose whether execute them or not using a concise syntax:</p> <pre class="fixed" data-language="sql">SELECT some_function() OR log_error();
</pre> </div>     </div> <div id="content_disclaimer" class="graybox"> Content reproduced on this site is the property of its respective owners, and this content is not reviewed in advance by MariaDB. The views, information and opinions expressed by this content do not necessarily represent those of MariaDB or any other party. </div> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://mariadb.com/kb/en/operator-precedence/" class="_attribution-link" target="_blank">https://mariadb.com/kb/en/operator-precedence/</a>
  </p>
</div>
