<h1>Shard-Query</h1> <div> <div class="node creole"> <div class="answer formatted">  <h2 class="anchored_heading" id="overview">Overview</h2> <p>Shard-Query is a high performance MPP (massively parallel processing) query engine for MariaDB and MySQL which offers increased parallelism compared to stand-alone servers. This increased parallelism is achieved by taking advantage of MariaDB/MySQL partitioning, sharding, common query clauses like BETWEEN and IN, or some combination of the above.</p> <p>Shard-Query is implemented with PHP and Gearman.</p> <p>Shard-Query is targeted mainly at big data problems, and OLAP queries in general. The primary goal of Shard-Query is to enable low-latency query access to extremely large volumes of data utilizing commodity hardware and open source database software. Shard-Query is a federated query engine which is designed to perform as much work in parallel as possible over a sharded dataset, that is one that is split over multiple servers (shards) or partitioned tables.</p> <p>Shard-Query behaves like <code><a href="../set-transaction/index#read-committed">READ-COMMITTED</a></code> in terms of transaction isolation for a single query. Shard-Query works best with a star schema data set, and is therefore targeted towards large data marts. Shard-Query also works well with extremely large tables, such as machine generated logs or sensor data.</p> <h2 class="anchored_heading" id="shard-query-resources">Shard-Query resources</h2> <p>The <a href="https://github.com/greenlion/swanhart-tools">swanhart-tools repository</a>, on GitHub, contains tools for MariaDB and MySQL from Justin Swanhart. Shard-Query is located in the <code>shard-query</code> directory. The whole project can be downloaded via the GitHub's <em>Download</em> button. It is possible to report bugs using the <em>Issues</em> tab.</p> <p>A <a href="https://code.google.com/p/shard-query/">project on Google Code</a> also exists, but it is obsolete. All bugs from Google Code and all downloads from Google Code are deprecated and will be removed.</p> <p>A <a href="https://www.facebook.com/ShardQuery">Facebook page</a> is also available.</p> <h2 class="anchored_heading" id="requirements">Requirements</h2> <ul start="1">
<li>At least one server for data storage </li>
<li>A database schema for storing the Shard-Query configuration </li>
<li>MariaDB or MySQL, version 5.1+ </li>
<li>PHP 5.3 or newer <ul start="1">
<li>PEAR (any version) </li>
<li>mbstring module </li>
</ul> </li>
<li>gearmand 0.18 or newer (get it from epel, or compile from gearman.org) </li>
<li>cron (for automatic gearman management) </li>
<li>Lua and JSON for Lua (for the proxy) </li>
</ul> <p>No web server is required. However, Apache 2 has been tested and a configuration file is included in the project.</p> <h2 class="anchored_heading" id="what-kind-of-interfaces-does-shard-query-have">What kind of interfaces does Shard-Query have</h2> <ul start="1">
<li>A RESTful UI which allows you to submit queries and examine results as well as configure Shard-Query </li>
<li>A MySQL proxy script </li>
<li>A PHP Object Oriented interface </li>
</ul> <p>The <code>proxy</code> directory contains a MySQL/MariaDB proxy. It can be used to transmit data between Shard-Query and applications, so that client programs don't need to know Shard-Query. The proxy is a Lua script which uses the JSON for Lua library.</p> <h2 class="anchored_heading" id="what-kind-of-queries-are-supported">What kind of queries are supported?</h2> <p>You can run just about all SQL queries over your dataset.</p> <p>For <code>SELECT</code> queries:</p> <ul start="1">
<li>All aggregate functions are supported. </li>
<li>
<code>SUM</code>, <code>COUNT</code>, <code>MIN</code>, <code>MAX</code> and <code>AVG</code> are the fastest aggregate operations </li>
<li>
<code>SUM</code>/<code>COUNT(DISTINCT ..)</code> are supported, but are slower </li>
<li>
<code>STD</code>/<code>VAR</code>/etc are supported but aggregation is not pushed down at all (slowest) </li>
<li>Custom aggregate functions are now also supported. <ul start="1"><li>
<code>PERCENTILE(expr, N)</code> - take a percentile, for example percentile(score,90) </li></ul> </li>
</ul> <p><code>JOIN</code>s are supported (no self joins, or joins of tables sharded by different keys)</p> <ul start="1"><li>
<code>ORDER BY</code>, <code>GROUP BY</code>, <code>HAVING</code>, <code>WITH ROLLUP</code>, and <code>LIMIT</code> are supported </li></ul> <p><code>UNION</code>s are fully supported.</p> <p>Also supports:</p> <ul start="1">
<li>
<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, LOAD DATA INFILE </li>
<li>DDL such as <code>CREATE TABLE</code>, <code>ALTER TABLE</code> and <code>DROP TABLE</code> </li>
</ul> <p>Details about how these statements are performed are explained before.</p> <h2 class="anchored_heading" id="sharding-support">Sharding Support</h2> <p>Shard-Query is designed to work with a <a href="http://en.wikipedia.org/wiki/Shard_%28database_architecture%29">sharded data set</a>. Shard-Query is designed to make a group of shards behave as one virtual database server, even for complex queries. Shard-Query includes two shard "mappers", described below.</p> <h3 class="anchored_heading" id="hash-mapper">Hash mapper</h3> <p>Hash based sharding features very fast row to shard lookups (this is called mapping) because no network round trip is required to calculate the lookup. The downsides are significant though, because the number of shards is fixed.</p> <h3 class="anchored_heading" id="directory-mapper">Directory mapper</h3> <p>Directory based sharding uses a database table on a directory database server to map rows to shards. This is very scalable, because rows can be migrated between shards, and the number of shards is not fixed (it can be easily grown). Directory mapping can be a problem if the directory must be very large (too large for a single directory server.) Directory mapping is slightly slower than hash mapping because a round trip and database lookups must be performed.</p> <h3 class="anchored_heading" id="automatic-sharding">Automatic Sharding</h3> <h4 class="anchored_heading" id="select-queries">SELECT queries</h4> <p>Shard-Query uses one of the above mappers in order to determine to which shards a query should be sent based on the <code>WHERE</code> clause used in the query. It may be possible to reduce the number of shards to which to send a query when the <code>WHERE</code> clause includes a condition on the shard column.</p> <p>Shard-Query automatically rewrites queries so that they return proper results when the query is executed over multiple shards. For example, when the <code>COUNT</code> aggregate function is used, it is executed as the <code>SUM</code> of the <code>COUNT</code> from each of the queried shards. Shard-Query elects a 'coordinator node' for each <code>SELECT</code> query, which is used for aggregating the results.</p> <h4 class="anchored_heading" id="insert-and-loading">INSERT and loading</h4> <p>When loading data or inserting rows, Shard-Query examines the data being inserted and sends the row to the appropriate shard. The loader is massively parallel and will load delimited files in chunks in parallel.</p> <h4 class="anchored_heading" id="ddl-and-other-dml-statements">DDL and other DML statements</h4> <p>All SQL except <code>SELECT</code> and <code>INSERT</code> is sent to all shards.</p> <h4 class="anchored_heading" id="un-sharded-tables">Un-Sharded Tables</h4> <p>Shard-Query supports both sharded and un-sharded tables. Un-sharded tables are tables which do not contain the shard column. Insertions into un-sharded tables go to all shards. If a query contains no sharded tables, then the query is sent to only a single shard to prevent duplication of data.</p> <h2 class="anchored_heading" id="built-in-tools">Built-In tools</h2> <p>Shard-Query includes</p> <h3 class="anchored_heading" id="command-line-tools">Command-line tools</h3> <ul start="1">
<li>
<code>bin/run_query</code> - tool to run queries. use <code>php ./run_query --help</code>. This is the tool you should look at to see how to integrate Shard-Query in your own app. </li>
<li>
<code>loader</code> - tool to load (or pre-split) flat files for sharded loading. </li>
</ul> <h3 class="anchored_heading" id="rest-ui">REST UI</h3> <p>The REST UI is installed in <code>/usr/share/shard-query/ui</code> by default.</p> <p>You can reach the UI by visiting the url: <code>http://your_server/shard_query</code></p> <p>The default username is: user and the password is mpp.</p> </div>     </div> <div id="content_disclaimer" class="graybox"> Content reproduced on this site is the property of its respective owners, and this content is not reviewed in advance by MariaDB. The views, information and opinions expressed by this content do not necessarily represent those of MariaDB or any other party. </div> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://mariadb.com/kb/en/shard-query/" class="_attribution-link" target="_blank">https://mariadb.com/kb/en/shard-query/</a>
  </p>
</div>
