<h1 id="ansible-module-utils">Ansible Reference: Module Utilities</h1> <p id="ansible-reference-module-utilities">This page documents utilities intended to be helpful when writing Ansible modules in Python.</p>  <h2 id="ansiblemodule">AnsibleModule</h2> <p>To use this functionality, include <code>from ansible.module_utils.basic import AnsibleModule</code> in your module.</p> <dl class="class"> <dt>
<code>class ansible.module_utils.basic.AnsibleModule(argument_spec, bypass_checks=False, no_log=False, mutually_exclusive=None, required_together=None, required_one_of=None, add_file_common_args=False, supports_check_mode=False, required_if=None, required_by=None)</code> </dt> <dd>
<p>Common code for quickly building an ansible module in Python (although you can write modules with anything that can return JSON).</p> <p>See <a class="reference internal" href="https://docs.ansible.com/ansible/2.10/dev_guide/developing_modules_general.html#developing-modules-general"><span class="std std-ref">Ansible module development: getting started</span></a> for a general introduction and <a class="reference internal" href="https://docs.ansible.com/ansible/2.10/dev_guide/developing_program_flow_modules.html#developing-program-flow-modules"><span class="std std-ref">Ansible module architecture</span></a> for more detailed explanation.</p> <dl class="method"> <dt>
<code>add_path_info(kwargs)</code> </dt> <dd>
<p>for results that are files, supplement the info about the file in the return path with stats about the file path.</p> </dd>
</dl> <dl class="method"> <dt>
<code>atomic_move(src, dest, unsafe_writes=False)</code> </dt> <dd>
<p>atomically move src to dest, copying attributes from dest, returns true on success it uses os.rename to ensure this as it is an atomic operation, rest of the function is to work around limitations, corner cases and ensure selinux context is saved if possible</p> </dd>
</dl> <dl class="method"> <dt>
<code>backup_local(fn)</code> </dt> <dd>
<p>make a date-marked backup of the specified file, return True or False on success or failure</p> </dd>
</dl> <dl class="method"> <dt>
<code>boolean(arg)</code> </dt> <dd>
<p>Convert the argument to a boolean</p> </dd>
</dl> <dl class="method"> <dt>
<code>digest_from_file(filename, algorithm)</code> </dt> <dd>
<p>Return hex digest of local file for a digest_method specified by name, or None if file is not present.</p> </dd>
</dl> <dl class="method"> <dt>
<code>exit_json(**kwargs)</code> </dt> <dd>
<p>return from the module, without error</p> </dd>
</dl> <dl class="method"> <dt>
<code>fail_json(msg, **kwargs)</code> </dt> <dd>
<p>return from the module, with an error message</p> </dd>
</dl> <dl class="method"> <dt>
<code>get_bin_path(arg, required=False, opt_dirs=None)</code> </dt> <dd>
<p>Find system executable in PATH.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>arg</strong> – The executable to find.</li> <li>
<strong>required</strong> – if executable is not found and required is <code>True</code>, fail_json</li> <li>
<strong>opt_dirs</strong> – optional list of directories to search in addition to <code>PATH</code>
</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>if found return full path; otherwise return None</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt>
<code>is_executable(path)</code> </dt> <dd>
<p>is the given path executable?</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>path</strong> – The path of the file to check.</p> </dd> </dl> <p>Limitations:</p> <ul class="simple"> <li>Does not account for FSACLs.</li> <li>Most times we really want to know “Can the current user execute this file”. This function does not tell us that, only if any execute bit is set.</li> </ul> </dd>
</dl> <dl class="method"> <dt>
<code>is_special_selinux_path(path)</code> </dt> <dd>
<p>Returns a tuple containing (True, selinux_context) if the given path is on a NFS or other ‘special’ fs mount point, otherwise the return will be (False, None).</p> </dd>
</dl> <dl class="method"> <dt>
<code>load_file_common_arguments(params, path=None)</code> </dt> <dd>
<p>many modules deal with files, this encapsulates common options that the file module accepts such that it is directly available to all modules and they can share code.</p> <p>Allows to overwrite the path/dest module argument by providing path.</p> </dd>
</dl> <dl class="method"> <dt>
<code>md5(filename)</code> </dt> <dd>
<p>Return MD5 hex digest of local file using digest_from_file().</p> <dl class="simple"> <dt>Do not use this function unless you have no other choice for:</dt>
<dd>
<ol class="arabic simple"> <li>Optional backwards compatibility</li> <li>Compatibility with a third party protocol</li> </ol> </dd> </dl> <p>This function will not work on systems complying with FIPS-140-2.</p> <p>Most uses of this function can use the module.sha1 function instead.</p> </dd>
</dl> <dl class="method"> <dt>
<code>preserved_copy(src, dest)</code> </dt> <dd>
<p>Copy a file with preserved ownership, permissions and context</p> </dd>
</dl> <dl class="method"> <dt>
<code>run_command(args, check_rc=False, close_fds=True, executable=None, data=None, binary_data=False, path_prefix=None, cwd=None, use_unsafe_shell=False, prompt_regex=None, environ_update=None, umask=None, encoding='utf-8', errors='surrogate_or_strict', expand_user_and_vars=True, pass_fds=None, before_communicate_callback=None, ignore_invalid_cwd=True)</code> </dt> <dd>
<p>Execute a command, returns rc, stdout, and stderr.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>args</strong> – is the command to run * If args is a list, the command will be run with shell=False. * If args is a string and use_unsafe_shell=False it will split args to a list and run with shell=False * If args is a string and use_unsafe_shell=True it runs with shell=True.</p> </dd> <dt class="field-even">Kw check_rc</dt> <dd class="field-even">
<p>Whether to call fail_json in case of non zero RC. Default False</p> </dd> <dt class="field-odd">Kw close_fds</dt> <dd class="field-odd">
<p>See documentation for subprocess.Popen(). Default True</p> </dd> <dt class="field-even">Kw executable</dt> <dd class="field-even">
<p>See documentation for subprocess.Popen(). Default None</p> </dd> <dt class="field-odd">Kw data</dt> <dd class="field-odd">
<p>If given, information to write to the stdin of the command</p> </dd> <dt class="field-even">Kw binary_data</dt> <dd class="field-even">
<p>If False, append a newline to the data. Default False</p> </dd> <dt class="field-odd">Kw path_prefix</dt> <dd class="field-odd">
<p>If given, additional path to find the command in. This adds to the PATH environment variable so helper commands in the same directory can also be found</p> </dd> <dt class="field-even">Kw cwd</dt> <dd class="field-even">
<p>If given, working directory to run the command inside</p> </dd> <dt class="field-odd">Kw use_unsafe_shell</dt> <dd class="field-odd">
<p>See <code>args</code> parameter. Default False</p> </dd> <dt class="field-even">Kw prompt_regex</dt> <dd class="field-even">
<p>Regex string (not a compiled regex) which can be used to detect prompts in the stdout which would otherwise cause the execution to hang (especially if no input data is specified)</p> </dd> <dt class="field-odd">Kw environ_update</dt> <dd class="field-odd">
<p>dictionary to <em>update</em> os.environ with</p> </dd> <dt class="field-even">Kw umask</dt> <dd class="field-even">
<p>Umask to be used when running the command. Default None</p> </dd> <dt class="field-odd">Kw encoding</dt> <dd class="field-odd">
<p>Since we return native strings, on python3 we need to know the encoding to use to transform from bytes to text. If you want to always get bytes back, use encoding=None. The default is “utf-8”. This does not affect transformation of strings given as args.</p> </dd> <dt class="field-even">Kw errors</dt> <dd class="field-even">
<p>Since we return native strings, on python3 we need to transform stdout and stderr from bytes to text. If the bytes are undecodable in the <code>encoding</code> specified, then use this error handler to deal with them. The default is <code>surrogate_or_strict</code> which means that the bytes will be decoded using the surrogateescape error handler if available (available on all python3 versions we support) otherwise a UnicodeError traceback will be raised. This does not affect transformations of strings given as args.</p> </dd> <dt class="field-odd">Kw expand_user_and_vars</dt> <dd class="field-odd">
<p>When <code>use_unsafe_shell=False</code> this argument dictates whether <code>~</code> is expanded in paths and environment variables are expanded before running the command. When <code>True</code> a string such as <code>$SHELL</code> will be expanded regardless of escaping. When <code>False</code> and <code>use_unsafe_shell=False</code> no path or variable expansion will be done.</p> </dd> <dt class="field-even">Kw pass_fds</dt> <dd class="field-even">
<p>When running on Python 3 this argument dictates which file descriptors should be passed to an underlying <code>Popen</code> constructor. On Python 2, this will set <code>close_fds</code> to False.</p> </dd> <dt class="field-odd">Kw before_communicate_callback</dt> <dd class="field-odd">
<p>This function will be called after <code>Popen</code> object will be created but before communicating to the process. (<code>Popen</code> object will be passed to callback as a first argument)</p> </dd> <dt class="field-even">Kw ignore_invalid_cwd</dt> <dd class="field-even">
<p>This flag indicates whether an invalid <code>cwd</code> (non-existent or not a directory) should be ignored or should raise an exception.</p> </dd> <dt class="field-odd">Returns</dt> <dd class="field-odd">
<p>A 3-tuple of return code (integer), stdout (native string), and stderr (native string). On python2, stdout and stderr are both byte strings. On python3, stdout and stderr are text strings converted according to the encoding and errors parameters. If you want byte strings on python3, use encoding=None to turn decoding to text off.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt>
<code>sha1(filename)</code> </dt> <dd>
<p>Return SHA1 hex digest of local file using digest_from_file().</p> </dd>
</dl> <dl class="method"> <dt>
<code>sha256(filename)</code> </dt> <dd>
<p>Return SHA-256 hex digest of local file using digest_from_file().</p> </dd>
</dl> </dd>
</dl>   <h2 id="basic">Basic</h2> <p>To use this functionality, include <code>import ansible.module_utils.basic</code> in your module.</p> <dl class="exception" id="module-ansible.module_utils.basic"> <dt id="ansible.module_utils.basic.AnsibleFallbackNotFound">
<code>exception ansible.module_utils.basic.AnsibleFallbackNotFound</code> </dt> 
</dl> <dl class="function"> <dt id="ansible.module_utils.basic.env_fallback">
<code>ansible.module_utils.basic.env_fallback(*args, **kwargs)</code> </dt> <dd>
<p>Load value from environment</p> </dd>
</dl> <dl class="function"> <dt id="ansible.module_utils.basic.get_all_subclasses">
<code>ansible.module_utils.basic.get_all_subclasses(cls)</code> </dt> <dd>
<p><strong>Deprecated</strong>: Use ansible.module_utils.common._utils.get_all_subclasses instead</p> </dd>
</dl> <dl class="function"> <dt id="ansible.module_utils.basic.get_platform">
<code>ansible.module_utils.basic.get_platform()</code> </dt> <dd>
<p><strong>Deprecated</strong> Use <a class="reference external" href="https://docs.python.org/3/library/platform.html#platform.system" title="(in Python v3.9)"><code>platform.system()</code></a> directly.</p> <dl class="field-list simple"> <dt class="field-odd">Returns</dt> <dd class="field-odd">
<p>Name of the platform the module is running on in a native string</p> </dd> </dl> <p>Returns a native string that labels the platform (“Linux”, “Solaris”, etc). Currently, this is the result of calling <a class="reference external" href="https://docs.python.org/3/library/platform.html#platform.system" title="(in Python v3.9)"><code>platform.system()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="ansible.module_utils.basic.heuristic_log_sanitize">
<code>ansible.module_utils.basic.heuristic_log_sanitize(data, no_log_values=None)</code> </dt> <dd>
<p>Remove strings that look like passwords from log messages</p> </dd>
</dl> <dl class="function"> <dt id="ansible.module_utils.basic.load_platform_subclass">
<code>ansible.module_utils.basic.load_platform_subclass(cls, *args, **kwargs)</code> </dt> <dd>
<p><strong>Deprecated</strong>: Use ansible.module_utils.common.sys_info.get_platform_subclass instead</p> </dd>
</dl> <dl class="function"> <dt id="ansible.module_utils.basic.remove_values">
<code>ansible.module_utils.basic.remove_values(value, no_log_strings)</code> </dt> <dd>
<p>Remove strings in no_log_strings from value. If value is a container type, then remove a lot more.</p> <p>Use of deferred_removals exists, rather than a pure recursive solution, because of the potential to hit the maximum recursion depth when dealing with large amounts of data (see issue #24560).</p> </dd>
</dl> <dl class="function"> <dt id="ansible.module_utils.basic.sanitize_keys">
<code>ansible.module_utils.basic.sanitize_keys(obj, no_log_strings, ignore_keys=frozenset({}))</code> </dt> <dd>
<p>Sanitize the keys in a container object by removing no_log values from key names.</p> <p>This is a companion function to the <code>remove_values()</code> function. Similar to that function, we make use of deferred_removals to avoid hitting maximum recursion depth in cases of large data structures.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>obj</strong> – The container object to sanitize. Non-container objects are returned unmodified.</li> <li>
<strong>no_log_strings</strong> – A set of string values we do not want logged.</li> <li>
<strong>ignore_keys</strong> – A set of string values of keys to not sanitize.</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>An object with sanitized keys.</p> </dd> </dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://docs.ansible.com/ansible/2.10/reference_appendices/module_utils.html" class="_attribution-link" target="_blank">https://docs.ansible.com/ansible/2.10/reference_appendices/module_utils.html</a>
  </p>
</div>
