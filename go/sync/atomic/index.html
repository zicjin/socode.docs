<h1> Package atomic  </h1>  <ul id="short-nav">
<li><code>import "sync/atomic"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
</ul>    <h2 id="pkg-overview">Overview </h2> <p> Package atomic provides low-level atomic memory primitives useful for implementing synchronization algorithms. </p> <p> These functions require great care to be used correctly. Except for special, low-level applications, synchronization is better done with channels or the facilities of the sync package. Share memory by communicating; don't communicate by sharing memory. </p> <p> The swap operation, implemented by the SwapT functions, is the atomic equivalent of: </p> <pre data-language="go">old = *addr
*addr = new
return old
</pre> <p> The compare-and-swap operation, implemented by the CompareAndSwapT functions, is the atomic equivalent of: </p> <pre data-language="go">if *addr == old {
	*addr = new
	return true
}
return false
</pre> <p> The add operation, implemented by the AddT functions, is the atomic equivalent of: </p> <pre data-language="go">*addr += delta
return *addr
</pre> <p> The load and store operations, implemented by the LoadT and StoreT functions, are the atomic equivalents of "return *addr" and "*addr = val". </p>      <h2 id="pkg-index">Index </h2> <ul id="manual-nav">
<li><a href="#AddInt32">func AddInt32(addr *int32, delta int32) (new int32)</a></li>
<li><a href="#AddInt64">func AddInt64(addr *int64, delta int64) (new int64)</a></li>
<li><a href="#AddUint32">func AddUint32(addr *uint32, delta uint32) (new uint32)</a></li>
<li><a href="#AddUint64">func AddUint64(addr *uint64, delta uint64) (new uint64)</a></li>
<li><a href="#AddUintptr">func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</a></li>
<li><a href="#CompareAndSwapInt32">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</a></li>
<li><a href="#CompareAndSwapInt64">func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)</a></li>
<li><a href="#CompareAndSwapPointer">func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</a></li>
<li><a href="#CompareAndSwapUint32">func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)</a></li>
<li><a href="#CompareAndSwapUint64">func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)</a></li>
<li><a href="#CompareAndSwapUintptr">func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)</a></li>
<li><a href="#LoadInt32">func LoadInt32(addr *int32) (val int32)</a></li>
<li><a href="#LoadInt64">func LoadInt64(addr *int64) (val int64)</a></li>
<li><a href="#LoadPointer">func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</a></li>
<li><a href="#LoadUint32">func LoadUint32(addr *uint32) (val uint32)</a></li>
<li><a href="#LoadUint64">func LoadUint64(addr *uint64) (val uint64)</a></li>
<li><a href="#LoadUintptr">func LoadUintptr(addr *uintptr) (val uintptr)</a></li>
<li><a href="#StoreInt32">func StoreInt32(addr *int32, val int32)</a></li>
<li><a href="#StoreInt64">func StoreInt64(addr *int64, val int64)</a></li>
<li><a href="#StorePointer">func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</a></li>
<li><a href="#StoreUint32">func StoreUint32(addr *uint32, val uint32)</a></li>
<li><a href="#StoreUint64">func StoreUint64(addr *uint64, val uint64)</a></li>
<li><a href="#StoreUintptr">func StoreUintptr(addr *uintptr, val uintptr)</a></li>
<li><a href="#SwapInt32">func SwapInt32(addr *int32, new int32) (old int32)</a></li>
<li><a href="#SwapInt64">func SwapInt64(addr *int64, new int64) (old int64)</a></li>
<li><a href="#SwapPointer">func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</a></li>
<li><a href="#SwapUint32">func SwapUint32(addr *uint32, new uint32) (old uint32)</a></li>
<li><a href="#SwapUint64">func SwapUint64(addr *uint64, new uint64) (old uint64)</a></li>
<li><a href="#SwapUintptr">func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)</a></li>
<li><a href="#Value">type Value</a></li>
<li> <a href="#Value.Load">func (v *Value) Load() (x interface{})</a>
</li>
<li> <a href="#Value.Store">func (v *Value) Store(x interface{})</a>
</li>
<li><a href="#pkg-note-BUG">Bugs</a></li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_Value_config">Value (Config)</a></dd> <dd><a class="exampleLink" href="#example_Value_readMostly">Value (ReadMostly)</a></dd> </dl> </div> <h3>Package files</h3> <p>  <a href="https://golang.org/src/sync/atomic/doc.go">doc.go</a> <a href="https://golang.org/src/sync/atomic/value.go">value.go</a>  </p>   <h2 id="AddInt32">func AddInt32<a href="https://golang.org/src/sync/atomic/doc.go?s=3563:3614#L82" class="source">Source</a>  </h2> <pre data-language="go">func AddInt32(addr *int32, delta int32) (new int32)</pre> <p> AddInt32 atomically adds delta to *addr and returns the new value. </p> <h2 id="AddInt64">func AddInt64<a href="https://golang.org/src/sync/atomic/doc.go?s=3968:4019#L90" class="source">Source</a>  </h2> <pre data-language="go">func AddInt64(addr *int64, delta int64) (new int64)</pre> <p> AddInt64 atomically adds delta to *addr and returns the new value. </p> <h2 id="AddUint32">func AddUint32<a href="https://golang.org/src/sync/atomic/doc.go?s=3841:3896#L87" class="source">Source</a>  </h2> <pre data-language="go">func AddUint32(addr *uint32, delta uint32) (new uint32)</pre> <p> AddUint32 atomically adds delta to *addr and returns the new value. To subtract a signed positive constant value c from x, do AddUint32(&amp;x, ^uint32(c-1)). In particular, to decrement x, do AddUint32(&amp;x, ^uint32(0)). </p> <h2 id="AddUint64">func AddUint64<a href="https://golang.org/src/sync/atomic/doc.go?s=4246:4301#L95" class="source">Source</a>  </h2> <pre data-language="go">func AddUint64(addr *uint64, delta uint64) (new uint64)</pre> <p> AddUint64 atomically adds delta to *addr and returns the new value. To subtract a signed positive constant value c from x, do AddUint64(&amp;x, ^uint64(c-1)). In particular, to decrement x, do AddUint64(&amp;x, ^uint64(0)). </p> <h2 id="AddUintptr">func AddUintptr<a href="https://golang.org/src/sync/atomic/doc.go?s=4375:4434#L98" class="source">Source</a>  </h2> <pre data-language="go">func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</pre> <p> AddUintptr atomically adds delta to *addr and returns the new value. </p> <h2 id="CompareAndSwapInt32">func CompareAndSwapInt32<a href="https://golang.org/src/sync/atomic/doc.go?s=2611:2679#L64" class="source">Source</a>  </h2> <pre data-language="go">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</pre> <p> CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value. </p> <h2 id="CompareAndSwapInt64">func CompareAndSwapInt64<a href="https://golang.org/src/sync/atomic/doc.go?s=2764:2832#L67" class="source">Source</a>  </h2> <pre data-language="go">func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)</pre> <p> CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value. </p> <h2 id="CompareAndSwapPointer">func CompareAndSwapPointer<a href="https://golang.org/src/sync/atomic/doc.go?s=3403:3491#L79" class="source">Source</a>  </h2> <pre data-language="go">func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</pre> <p> CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value. </p> <h2 id="CompareAndSwapUint32">func CompareAndSwapUint32<a href="https://golang.org/src/sync/atomic/doc.go?s=2918:2989#L70" class="source">Source</a>  </h2> <pre data-language="go">func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)</pre> <p> CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value. </p> <h2 id="CompareAndSwapUint64">func CompareAndSwapUint64<a href="https://golang.org/src/sync/atomic/doc.go?s=3075:3146#L73" class="source">Source</a>  </h2> <pre data-language="go">func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)</pre> <p> CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value. </p> <h2 id="CompareAndSwapUintptr">func CompareAndSwapUintptr<a href="https://golang.org/src/sync/atomic/doc.go?s=3234:3308#L76" class="source">Source</a>  </h2> <pre data-language="go">func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)</pre> <p> CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value. </p> <h2 id="LoadInt32">func LoadInt32<a href="https://golang.org/src/sync/atomic/doc.go?s=4473:4512#L101" class="source">Source</a>  </h2> <pre data-language="go">func LoadInt32(addr *int32) (val int32)</pre> <p> LoadInt32 atomically loads *addr. </p> <h2 id="LoadInt64">func LoadInt64<a href="https://golang.org/src/sync/atomic/doc.go?s=4551:4590#L104" class="source">Source</a>  </h2> <pre data-language="go">func LoadInt64(addr *int64) (val int64)</pre> <p> LoadInt64 atomically loads *addr. </p> <h2 id="LoadPointer">func LoadPointer<a href="https://golang.org/src/sync/atomic/doc.go?s=4881:4940#L116" class="source">Source</a>  </h2> <pre data-language="go">func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</pre> <p> LoadPointer atomically loads *addr. </p> <h2 id="LoadUint32">func LoadUint32<a href="https://golang.org/src/sync/atomic/doc.go?s=4630:4672#L107" class="source">Source</a>  </h2> <pre data-language="go">func LoadUint32(addr *uint32) (val uint32)</pre> <p> LoadUint32 atomically loads *addr. </p> <h2 id="LoadUint64">func LoadUint64<a href="https://golang.org/src/sync/atomic/doc.go?s=4712:4754#L110" class="source">Source</a>  </h2> <pre data-language="go">func LoadUint64(addr *uint64) (val uint64)</pre> <p> LoadUint64 atomically loads *addr. </p> <h2 id="LoadUintptr">func LoadUintptr<a href="https://golang.org/src/sync/atomic/doc.go?s=4795:4840#L113" class="source">Source</a>  </h2> <pre data-language="go">func LoadUintptr(addr *uintptr) (val uintptr)</pre> <p> LoadUintptr atomically loads *addr. </p> <h2 id="StoreInt32">func StoreInt32<a href="https://golang.org/src/sync/atomic/doc.go?s=4990:5029#L119" class="source">Source</a>  </h2> <pre data-language="go">func StoreInt32(addr *int32, val int32)</pre> <p> StoreInt32 atomically stores val into *addr. </p> <h2 id="StoreInt64">func StoreInt64<a href="https://golang.org/src/sync/atomic/doc.go?s=5079:5118#L122" class="source">Source</a>  </h2> <pre data-language="go">func StoreInt64(addr *int64, val int64)</pre> <p> StoreInt64 atomically stores val into *addr. </p> <h2 id="StorePointer">func StorePointer<a href="https://golang.org/src/sync/atomic/doc.go?s=5453:5512#L134" class="source">Source</a>  </h2> <pre data-language="go">func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</pre> <p> StorePointer atomically stores val into *addr. </p> <h2 id="StoreUint32">func StoreUint32<a href="https://golang.org/src/sync/atomic/doc.go?s=5169:5211#L125" class="source">Source</a>  </h2> <pre data-language="go">func StoreUint32(addr *uint32, val uint32)</pre> <p> StoreUint32 atomically stores val into *addr. </p> <h2 id="StoreUint64">func StoreUint64<a href="https://golang.org/src/sync/atomic/doc.go?s=5262:5304#L128" class="source">Source</a>  </h2> <pre data-language="go">func StoreUint64(addr *uint64, val uint64)</pre> <p> StoreUint64 atomically stores val into *addr. </p> <h2 id="StoreUintptr">func StoreUintptr<a href="https://golang.org/src/sync/atomic/doc.go?s=5356:5401#L131" class="source">Source</a>  </h2> <pre data-language="go">func StoreUintptr(addr *uintptr, val uintptr)</pre> <p> StoreUintptr atomically stores val into *addr. </p> <h2 id="SwapInt32">func SwapInt32<a href="https://golang.org/src/sync/atomic/doc.go?s=1745:1795#L46" class="source">Source</a>  <span title="Added in Go 1.2">1.2</span> </h2> <pre data-language="go">func SwapInt32(addr *int32, new int32) (old int32)</pre> <p> SwapInt32 atomically stores new into *addr and returns the previous *addr value. </p> <h2 id="SwapInt64">func SwapInt64<a href="https://golang.org/src/sync/atomic/doc.go?s=1881:1931#L49" class="source">Source</a>  <span title="Added in Go 1.2">1.2</span> </h2> <pre data-language="go">func SwapInt64(addr *int64, new int64) (old int64)</pre> <p> SwapInt64 atomically stores new into *addr and returns the previous *addr value. </p> <h2 id="SwapPointer">func SwapPointer<a href="https://golang.org/src/sync/atomic/doc.go?s=2447:2526#L61" class="source">Source</a>  <span title="Added in Go 1.2">1.2</span> </h2> <pre data-language="go">func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</pre> <p> SwapPointer atomically stores new into *addr and returns the previous *addr value. </p> <h2 id="SwapUint32">func SwapUint32<a href="https://golang.org/src/sync/atomic/doc.go?s=2018:2072#L52" class="source">Source</a>  <span title="Added in Go 1.2">1.2</span> </h2> <pre data-language="go">func SwapUint32(addr *uint32, new uint32) (old uint32)</pre> <p> SwapUint32 atomically stores new into *addr and returns the previous *addr value. </p> <h2 id="SwapUint64">func SwapUint64<a href="https://golang.org/src/sync/atomic/doc.go?s=2159:2213#L55" class="source">Source</a>  <span title="Added in Go 1.2">1.2</span> </h2> <pre data-language="go">func SwapUint64(addr *uint64, new uint64) (old uint64)</pre> <p> SwapUint64 atomically stores new into *addr and returns the previous *addr value. </p> <h2 id="SwapUintptr">func SwapUintptr<a href="https://golang.org/src/sync/atomic/doc.go?s=2301:2359#L58" class="source">Source</a>  <span title="Added in Go 1.2">1.2</span> </h2> <pre data-language="go">func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)</pre> <p> SwapUintptr atomically stores new into *addr and returns the previous *addr value. </p> <h2 id="Value">type Value<a href="https://golang.org/src/sync/atomic/value.go?s=436:472#L6" class="source">Source</a>  <span title="Added in Go 1.4">1.4</span> </h2> <p> A Value provides an atomic load and store of a consistently typed value. The zero value for a Value returns nil from Load. Once Store has been called, a Value must not be copied. </p> <p> A Value must not be copied after first use. </p> <pre data-language="go">type Value struct {
    // contains filtered or unexported fields
}
</pre>    <h4 id="example_Value_config"> <span class="text">Example (Config)</span>
</h4> <p>The following example shows how to use Value for periodic program config updates and propagation of the changes to worker goroutines. </p> <pre class="play" data-language="go">package main

import (
	"sync/atomic"
	"time"
)

func loadConfig() map[string]string {
	return make(map[string]string)
}

func requests() chan int {
	return make(chan int)
}

func main() {
	var config atomic.Value // holds current server configuration
	// Create initial config value and store into config.
	config.Store(loadConfig())
	go func() {
		// Reload config every 10 seconds
		// and update config value with the new version.
		for {
			time.Sleep(10 * time.Second)
			config.Store(loadConfig())
		}
	}()
	// Create worker goroutines that handle incoming requests
	// using the latest config value.
	for i := 0; i &lt; 10; i++ {
		go func() {
			for r := range requests() {
				c := config.Load()
				// Handle request r using config c.
				_, _ = r, c
			}
		}()
	}
}
</pre>      <h4 id="example_Value_readMostly"> <span class="text">Example (ReadMostly)</span>
</h4> <p>The following example shows how to maintain a scalable frequently read, but infrequently updated data structure using copy-on-write idiom. </p> <pre class="play" data-language="go">package main

import (
	"sync"
	"sync/atomic"
)

func main() {
	type Map map[string]string
	var m atomic.Value
	m.Store(make(Map))
	var mu sync.Mutex // used only by writers
	// read function can be used to read the data without further synchronization
	read := func(key string) (val string) {
		m1 := m.Load().(Map)
		return m1[key]
	}
	// insert function can be used to update the data without further synchronization
	insert := func(key, val string) {
		mu.Lock() // synchronize with other potential writers
		defer mu.Unlock()
		m1 := m.Load().(Map) // load current value of the data structure
		m2 := make(Map)      // create a new value
		for k, v := range m1 {
			m2[k] = v // copy all data from the current object to the new one
		}
		m2[key] = val // do the update that we need
		m.Store(m2)   // atomically replace the current object with the new one
		// At this point all new readers start working with the new version.
		// The old version will be garbage collected once the existing readers
		// (if any) are done with it.
	}
	_, _ = read, insert
}
</pre>   <h3 id="Value.Load">func (*Value) Load<a href="https://golang.org/src/sync/atomic/value.go?s=723:761#L18" class="source">Source</a>  <span title="Added in Go 1.4">1.4</span> </h3> <pre data-language="go">func (v *Value) Load() (x interface{})</pre> <p> Load returns the value set by the most recent Store. It returns nil if there has been no call to Store for this Value. </p> <h3 id="Value.Store">func (*Value) Store<a href="https://golang.org/src/sync/atomic/value.go?s=1233:1269#L35" class="source">Source</a>  <span title="Added in Go 1.4">1.4</span> </h3> <pre data-language="go">func (v *Value) Store(x interface{})</pre> <p> Store sets the value of the Value to x. All calls to Store for a given Value must use values of the same concrete type. Store of an inconsistent type panics, as does Store(nil). </p> <h2 id="pkg-note-BUG">Bugs</h2> <ul> <li>
<a href="https://golang.org/src/sync/atomic/doc.go?s=1206:1659#L36" style="float: left;">â˜ž</a> <p> On 386, the 64-bit functions use instructions unavailable before the Pentium MMX. </p> <p> On non-Linux ARM, the 64-bit functions use instructions unavailable before the ARMv6k core. </p> <p> On ARM, 386, and 32-bit MIPS, it is the caller's responsibility to arrange for 64-bit alignment of 64-bit words accessed atomically. The first word in a variable or in an allocated struct, array, or slice can be relied upon to be 64-bit aligned. </p> </li> </ul><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://golang.org/pkg/sync/atomic/" class="_attribution-link" target="_blank">https://golang.org/pkg/sync/atomic/</a>
  </p>
</div>
