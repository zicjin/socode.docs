<h1> Package ed25519  </h1>  <ul id="short-nav">
<li><code>import "crypto/ed25519"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
</ul>    <h2 id="pkg-overview">Overview </h2> <p> Package ed25519 implements the Ed25519 signature algorithm. See <a href="https://ed25519.cr.yp.to/">https://ed25519.cr.yp.to/</a>. </p> <p> These functions are also compatible with the “Ed25519” function defined in RFC 8032. However, unlike RFC 8032's formulation, this package's private key representation includes a public key suffix to make multiple signing operations with the same key more efficient. This package refers to the RFC 8032 private key as the “seed”. </p>      <h2 id="pkg-index">Index </h2> <ul id="manual-nav">
<li><a href="#pkg-constants">Constants</a></li>
<li><a href="#GenerateKey">func GenerateKey(rand io.Reader) (PublicKey, PrivateKey, error)</a></li>
<li><a href="#Sign">func Sign(privateKey PrivateKey, message []byte) []byte</a></li>
<li><a href="#Verify">func Verify(publicKey PublicKey, message, sig []byte) bool</a></li>
<li><a href="#PrivateKey">type PrivateKey</a></li>
<li> <a href="#NewKeyFromSeed">func NewKeyFromSeed(seed []byte) PrivateKey</a>
</li>
<li> <a href="#PrivateKey.Equal">func (priv PrivateKey) Equal(x crypto.PrivateKey) bool</a>
</li>
<li> <a href="#PrivateKey.Public">func (priv PrivateKey) Public() crypto.PublicKey</a>
</li>
<li> <a href="#PrivateKey.Seed">func (priv PrivateKey) Seed() []byte</a>
</li>
<li> <a href="#PrivateKey.Sign">func (priv PrivateKey) Sign(rand io.Reader, message []byte, opts crypto.SignerOpts) (signature []byte, err error)</a>
</li>
<li><a href="#PublicKey">type PublicKey</a></li>
<li> <a href="#PublicKey.Equal">func (pub PublicKey) Equal(x crypto.PublicKey) bool</a>
</li>
</ul> <h3>Package files</h3> <p>  <a href="https://golang.org/src/crypto/ed25519/ed25519.go">ed25519.go</a>  </p>   <h2 id="pkg-constants">Constants</h2> <pre data-language="go">const (
    // PublicKeySize is the size, in bytes, of public keys as used in this package.
    PublicKeySize = 32
    // PrivateKeySize is the size, in bytes, of private keys as used in this package.
    PrivateKeySize = 64
    // SignatureSize is the size, in bytes, of signatures generated and verified by this package.
    SignatureSize = 64
    // SeedSize is the size, in bytes, of private key seeds. These are the private key representations used by RFC 8032.
    SeedSize = 32
)</pre> <h2 id="GenerateKey">func GenerateKey<a href="https://golang.org/src/crypto/ed25519/ed25519.go?s=3257:3320#L88" class="source">Source</a>  <span title="Added in Go 1.13">1.13</span> </h2> <pre data-language="go">func GenerateKey(rand io.Reader) (PublicKey, PrivateKey, error)</pre> <p> GenerateKey generates a public/private key pair using entropy from rand. If rand is nil, crypto/rand.Reader will be used. </p> <h2 id="Sign">func Sign<a href="https://golang.org/src/crypto/ed25519/ed25519.go?s=4708:4763#L139" class="source">Source</a>  <span title="Added in Go 1.13">1.13</span> </h2> <pre data-language="go">func Sign(privateKey PrivateKey, message []byte) []byte</pre> <p> Sign signs the message with privateKey and returns a signature. It will panic if len(privateKey) is not PrivateKeySize. </p> <h2 id="Verify">func Verify<a href="https://golang.org/src/crypto/ed25519/ed25519.go?s=6212:6270#L193" class="source">Source</a>  <span title="Added in Go 1.13">1.13</span> </h2> <pre data-language="go">func Verify(publicKey PublicKey, message, sig []byte) bool</pre> <p> Verify reports whether sig is a valid signature of message by publicKey. It will panic if len(publicKey) is not PublicKeySize. </p> <h2 id="PrivateKey">type PrivateKey<a href="https://golang.org/src/crypto/ed25519/ed25519.go?s=1837:1859#L46" class="source">Source</a>  <span title="Added in Go 1.13">1.13</span> </h2> <p> PrivateKey is the type of Ed25519 private keys. It implements crypto.Signer. </p> <pre data-language="go">type PrivateKey []byte</pre> <h3 id="NewKeyFromSeed">func NewKeyFromSeed<a href="https://golang.org/src/crypto/ed25519/ed25519.go?s=3866:3909#L109" class="source">Source</a>  <span title="Added in Go 1.13">1.13</span> </h3> <pre data-language="go">func NewKeyFromSeed(seed []byte) PrivateKey</pre> <p> NewKeyFromSeed calculates a private key from a seed. It will panic if len(seed) is not SeedSize. This function is provided for interoperability with RFC 8032. RFC 8032's private keys correspond to seeds in this package. </p> <h3 id="PrivateKey.Equal">func (PrivateKey) Equal<a href="https://golang.org/src/crypto/ed25519/ed25519.go?s=2126:2180#L56" class="source">Source</a>  <span title="Added in Go 1.15">1.15</span> </h3> <pre data-language="go">func (priv PrivateKey) Equal(x crypto.PrivateKey) bool</pre> <p> Equal reports whether priv and x have the same value. </p> <h3 id="PrivateKey.Public">func (PrivateKey) Public<a href="https://golang.org/src/crypto/ed25519/ed25519.go?s=1916:1964#L49" class="source">Source</a>  <span title="Added in Go 1.13">1.13</span> </h3> <pre data-language="go">func (priv PrivateKey) Public() crypto.PublicKey</pre> <p> Public returns the PublicKey corresponding to priv. </p> <h3 id="PrivateKey.Seed">func (PrivateKey) Seed<a href="https://golang.org/src/crypto/ed25519/ed25519.go?s=2448:2484#L67" class="source">Source</a>  <span title="Added in Go 1.13">1.13</span> </h3> <pre data-language="go">func (priv PrivateKey) Seed() []byte</pre> <p> Seed returns the private key seed corresponding to priv. It is provided for interoperability with RFC 8032. RFC 8032's private keys correspond to seeds in this package. </p> <h3 id="PrivateKey.Sign">func (PrivateKey) Sign<a href="https://golang.org/src/crypto/ed25519/ed25519.go?s=2869:2982#L78" class="source">Source</a>  <span title="Added in Go 1.13">1.13</span> </h3> <pre data-language="go">func (priv PrivateKey) Sign(rand io.Reader, message []byte, opts crypto.SignerOpts) (signature []byte, err error)</pre> <p> Sign signs the given message with priv. Ed25519 performs two passes over messages to be signed and therefore cannot handle pre-hashed messages. Thus opts.HashFunc() must return zero to indicate the message hasn't been hashed. This can be achieved by passing crypto.Hash(0) as the value for opts. </p> <h2 id="PublicKey">type PublicKey<a href="https://golang.org/src/crypto/ed25519/ed25519.go?s=1385:1406#L31" class="source">Source</a>  <span title="Added in Go 1.13">1.13</span> </h2> <p> PublicKey is the type of Ed25519 public keys. </p> <pre data-language="go">type PublicKey []byte</pre> <h3 id="PublicKey.Equal">func (PublicKey) Equal<a href="https://golang.org/src/crypto/ed25519/ed25519.go?s=1618:1669#L37" class="source">Source</a>  <span title="Added in Go 1.15">1.15</span> </h3> <pre data-language="go">func (pub PublicKey) Equal(x crypto.PublicKey) bool</pre> <p> Equal reports whether pub and x have the same value. </p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://golang.org/pkg/crypto/ed25519/" class="_attribution-link" target="_blank">https://golang.org/pkg/crypto/ed25519/</a>
  </p>
</div>
