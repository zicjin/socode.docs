<h1> Package mail  </h1>  <ul id="short-nav">
<li><code>import "net/mail"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
</ul>    <h2 id="pkg-overview">Overview </h2> <p> Package mail implements parsing of mail messages. </p> <p> For the most part, this package follows the syntax as specified by RFC 5322 and extended by RFC 6532. Notable divergences: </p> <pre data-language="go">* Obsolete address formats are not parsed, including addresses with
  embedded route information.
* The full range of spacing (the CFWS syntax element) is not supported,
  such as breaking addresses across lines.
* No unicode normalization is performed.
* The special characters ()[]:;@\, are allowed to appear unquoted in names.
</pre>      <h2 id="pkg-index">Index </h2> <ul id="manual-nav">
<li><a href="#pkg-variables">Variables</a></li>
<li><a href="#ParseDate">func ParseDate(date string) (time.Time, error)</a></li>
<li><a href="#Address">type Address</a></li>
<li> <a href="#ParseAddress">func ParseAddress(address string) (*Address, error)</a>
</li>
<li> <a href="#ParseAddressList">func ParseAddressList(list string) ([]*Address, error)</a>
</li>
<li> <a href="#Address.String">func (a *Address) String() string</a>
</li>
<li><a href="#AddressParser">type AddressParser</a></li>
<li> <a href="#AddressParser.Parse">func (p *AddressParser) Parse(address string) (*Address, error)</a>
</li>
<li> <a href="#AddressParser.ParseList">func (p *AddressParser) ParseList(list string) ([]*Address, error)</a>
</li>
<li><a href="#Header">type Header</a></li>
<li> <a href="#Header.AddressList">func (h Header) AddressList(key string) ([]*Address, error)</a>
</li>
<li> <a href="#Header.Date">func (h Header) Date() (time.Time, error)</a>
</li>
<li> <a href="#Header.Get">func (h Header) Get(key string) string</a>
</li>
<li><a href="#Message">type Message</a></li>
<li> <a href="#ReadMessage">func ReadMessage(r io.Reader) (msg *Message, err error)</a>
</li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_ParseAddress">ParseAddress</a></dd> <dd><a class="exampleLink" href="#example_ParseAddressList">ParseAddressList</a></dd> <dd><a class="exampleLink" href="#example_ReadMessage">ReadMessage</a></dd> </dl> </div> <h3>Package files</h3> <p>  <a href="https://golang.org/src/net/mail/message.go">message.go</a>  </p>   <h2 id="pkg-variables">Variables</h2> <pre data-language="go">var ErrHeaderNotPresent = errors.New("mail: header not in message")</pre> <h2 id="ParseDate">func ParseDate<a href="https://golang.org/src/net/mail/message.go?s=2379:2425#L89" class="source">Source</a>  <span title="Added in Go 1.8">1.8</span> </h2> <pre data-language="go">func ParseDate(date string) (time.Time, error)</pre> <p> ParseDate parses an RFC 5322 date string. </p> <h2 id="Address">type Address<a href="https://golang.org/src/net/mail/message.go?s=5096:5196#L173" class="source">Source</a>  </h2> <p> Address represents a single mail address. An address such as "Barry Gibbs &lt;bg@example.com&gt;" is represented as Address{Name: "Barry Gibbs", Address: "bg@example.com"}. </p> <pre data-language="go">type Address struct {
    Name    string // Proper name; may be empty.
    Address string // user@domain
}
</pre> <h3 id="ParseAddress">func ParseAddress<a href="https://golang.org/src/net/mail/message.go?s=5284:5335#L179" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func ParseAddress(address string) (*Address, error)</pre> <p> ParseAddress parses a single RFC 5322 address, e.g. "Barry Gibbs &lt;bg@example.com&gt;" </p>    <h4 id="example_ParseAddress"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"log"
	"net/mail"
)

func main() {
	e, err := mail.ParseAddress("Alice &lt;alice@example.com&gt;")
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println(e.Name, e.Address)

}
</pre>   <h3 id="ParseAddressList">func ParseAddressList<a href="https://golang.org/src/net/mail/message.go?s=5464:5518#L184" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func ParseAddressList(list string) ([]*Address, error)</pre> <p> ParseAddressList parses the given string as a list of addresses. </p>    <h4 id="example_ParseAddressList"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"log"
	"net/mail"
)

func main() {
	const list = "Alice &lt;alice@example.com&gt;, Bob &lt;bob@example.com&gt;, Eve &lt;eve@example.com&gt;"
	emails, err := mail.ParseAddressList(list)
	if err != nil {
		log.Fatal(err)
	}

	for _, v := range emails {
		fmt.Println(v.Name, v.Address)
	}

}
</pre>   <h3 id="Address.String">func (*Address) String<a href="https://golang.org/src/net/mail/message.go?s=6462:6495#L209" class="source">Source</a>  </h3> <pre data-language="go">func (a *Address) String() string</pre> <p> String formats the address as a valid RFC 5322 address. If the address's name contains non-ASCII characters the name will be rendered according to RFC 2047. </p> <h2 id="AddressParser">type AddressParser<a href="https://golang.org/src/net/mail/message.go?s=5625:5760#L189" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h2> <p> An AddressParser is an RFC 5322 address parser. </p> <pre data-language="go">type AddressParser struct {
    // WordDecoder optionally specifies a decoder for RFC 2047 encoded-words.
    WordDecoder *mime.WordDecoder
}
</pre> <h3 id="AddressParser.Parse">func (*AddressParser) Parse<a href="https://golang.org/src/net/mail/message.go?s=5869:5932#L196" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (p *AddressParser) Parse(address string) (*Address, error)</pre> <p> Parse parses a single RFC 5322 address of the form "Gogh Fir &lt;gf@example.com&gt;" or "foo@example.com". </p> <h3 id="AddressParser.ParseList">func (*AddressParser) ParseList<a href="https://golang.org/src/net/mail/message.go?s=6154:6220#L202" class="source">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (p *AddressParser) ParseList(list string) ([]*Address, error)</pre> <p> ParseList parses the given string as a list of comma-separated addresses of the form "Gogh Fir &lt;gf@example.com&gt;" or "foo@example.com". </p> <h2 id="Header">type Header<a href="https://golang.org/src/net/mail/message.go?s=3988:4019#L138" class="source">Source</a>  </h2> <p> A Header represents the key-value pairs in a mail message header. </p> <pre data-language="go">type Header map[string][]string</pre> <h3 id="Header.AddressList">func (Header) AddressList<a href="https://golang.org/src/net/mail/message.go?s=4753:4812#L162" class="source">Source</a>  </h3> <pre data-language="go">func (h Header) AddressList(key string) ([]*Address, error)</pre> <p> AddressList parses the named header field as a list of addresses. </p> <h3 id="Header.Date">func (Header) Date<a href="https://golang.org/src/net/mail/message.go?s=4531:4572#L153" class="source">Source</a>  </h3> <pre data-language="go">func (h Header) Date() (time.Time, error)</pre> <p> Date parses the Date header field. </p> <h3 id="Header.Get">func (Header) Get<a href="https://golang.org/src/net/mail/message.go?s=4339:4377#L146" class="source">Source</a>  </h3> <pre data-language="go">func (h Header) Get(key string) string</pre> <p> Get gets the first value associated with the given key. It is case insensitive; CanonicalMIMEHeaderKey is used to canonicalize the provided key. If there are no values associated with the key, Get returns "". To access multiple values of a key, or to use non-canonical keys, access the map directly. </p> <h2 id="Message">type Message<a href="https://golang.org/src/net/mail/message.go?s=1006:1062#L35" class="source">Source</a>  </h2> <p> A Message represents a parsed mail message. </p> <pre data-language="go">type Message struct {
    Header Header
    Body   io.Reader
}
</pre> <h3 id="ReadMessage">func ReadMessage<a href="https://golang.org/src/net/mail/message.go?s=1206:1261#L43" class="source">Source</a>  </h3> <pre data-language="go">func ReadMessage(r io.Reader) (msg *Message, err error)</pre> <p> ReadMessage reads a message from r. The headers are parsed, and the body of the message will be available for reading from msg.Body. </p>    <h4 id="example_ReadMessage"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"io"
	"log"
	"net/mail"
	"strings"
)

func main() {
	msg := `Date: Mon, 23 Jun 2015 11:40:36 -0400
From: Gopher &lt;from@example.com&gt;
To: Another Gopher &lt;to@example.com&gt;
Subject: Gophers at Gophercon

Message body
`

	r := strings.NewReader(msg)
	m, err := mail.ReadMessage(r)
	if err != nil {
		log.Fatal(err)
	}

	header := m.Header
	fmt.Println("Date:", header.Get("Date"))
	fmt.Println("From:", header.Get("From"))
	fmt.Println("To:", header.Get("To"))
	fmt.Println("Subject:", header.Get("Subject"))

	body, err := io.ReadAll(m.Body)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("%s", body)

}
</pre><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://golang.org/pkg/net/mail/" class="_attribution-link" target="_blank">https://golang.org/pkg/net/mail/</a>
  </p>
</div>
