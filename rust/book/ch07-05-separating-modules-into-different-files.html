<h1 id="separating-modules-into-different-files">Separating Modules into Different Files</h1> <p>So far, all the examples in this chapter defined multiple modules in one file. When modules get large, you might want to move their definitions to a separate file to make the code easier to navigate.</p> <p>For example, let’s start from the code in Listing 7-17 and move the <code>front_of_house</code> module to its own file <em>src/front_of_house.rs</em> by changing the crate root file so it contains the code shown in Listing 7-21. In this case, the crate root file is <em>src/lib.rs</em>, but this procedure also works with binary crates whose crate root file is <em>src/main.rs</em>.</p> <p><span class="filename">Filename: src/lib.rs</span></p> <pre data-language="rust">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
</pre> <p><span class="caption">Listing 7-21: Declaring the <code>front_of_house</code> module whose body will be in <em>src/front_of_house.rs</em></span></p> <p>And <em>src/front_of_house.rs</em> gets the definitions from the body of the <code>front_of_house</code> module, as shown in Listing 7-22.</p> <p><span class="filename">Filename: src/front_of_house.rs</span></p> <pre data-language="rust">pub mod hosting {
    pub fn add_to_waitlist() {}
}
</pre> <p><span class="caption">Listing 7-22: Definitions inside the <code>front_of_house</code> module in <em>src/front_of_house.rs</em></span></p> <p>Using a semicolon after <code>mod front_of_house</code> rather than using a block tells Rust to load the contents of the module from another file with the same name as the module. To continue with our example and extract the <code>hosting</code> module to its own file as well, we change <em>src/front_of_house.rs</em> to contain only the declaration of the <code>hosting</code> module:</p> <p><span class="filename">Filename: src/front_of_house.rs</span></p> <pre data-language="rust">pub mod hosting;
</pre> <p>Then we create a <em>src/front_of_house</em> directory and a file <em>src/front_of_house/hosting.rs</em> to contain the definitions made in the <code>hosting</code> module:</p> <p><span class="filename">Filename: src/front_of_house/hosting.rs</span></p> <pre data-language="rust">
#![allow(unused)]
fn main() {
pub fn add_to_waitlist() {}
}
</pre> <p>The module tree remains the same, and the function calls in <code>eat_at_restaurant</code> will work without any modification, even though the definitions live in different files. This technique lets you move modules to new files as they grow in size.</p> <p>Note that the <code>pub use crate::front_of_house::hosting</code> statement in <em>src/lib.rs</em> also hasn’t changed, nor does <code>use</code> have any impact on what files are compiled as part of the crate. The <code>mod</code> keyword declares modules, and Rust looks in a file with the same name as the module for the code that goes into that module.</p> <h2 id="summary">Summary</h2> <p>Rust lets you split a package into multiple crates and a crate into modules so you can refer to items defined in one module from another module. You can do this by specifying absolute or relative paths. These paths can be brought into scope with a <code>use</code> statement so you can use a shorter path for multiple uses of the item in that scope. Module code is private by default, but you can make definitions public by adding the <code>pub</code> keyword.</p> <p>In the next chapter, we’ll look at some collection data structures in the standard library that you can use in your neatly organized code.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/book/ch07-05-separating-modules-into-different-files.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/book/ch07-05-separating-modules-into-different-files.html</a>
  </p>
</div>
