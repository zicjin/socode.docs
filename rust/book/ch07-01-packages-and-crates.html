<h1 id="packages-and-crates">Packages and Crates</h1> <p>The first parts of the module system we’ll cover are packages and crates. A crate is a binary or library. The <em>crate root</em> is a source file that the Rust compiler starts from and makes up the root module of your crate (we’ll explain modules in depth in the <a href="ch07-02-defining-modules-to-control-scope-and-privacy">“Defining Modules to Control Scope and Privacy”</a> section). A <em>package</em> is one or more crates that provide a set of functionality. A package contains a <em>Cargo.toml</em> file that describes how to build those crates.</p> <p>Several rules determine what a package can contain. A package can contain at most one library crate. It can contain as many binary crates as you’d like, but it must contain at least one crate (either library or binary).</p> <p>Let’s walk through what happens when we create a package. First, we enter the command <code>cargo new</code>:</p> <pre>$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</pre> <p>When we entered the command, Cargo created a <em>Cargo.toml</em> file, giving us a package. Looking at the contents of <em>Cargo.toml</em>, there’s no mention of <em>src/main.rs</em> because Cargo follows a convention that <em>src/main.rs</em> is the crate root of a binary crate with the same name as the package. Likewise, Cargo knows that if the package directory contains <em>src/lib.rs</em>, the package contains a library crate with the same name as the package, and <em>src/lib.rs</em> is its crate root. Cargo passes the crate root files to <code>rustc</code> to build the library or binary.</p> <p>Here, we have a package that only contains <em>src/main.rs</em>, meaning it only contains a binary crate named <code>my-project</code>. If a package contains <em>src/main.rs</em> and <em>src/lib.rs</em>, it has two crates: a library and a binary, both with the same name as the package. A package can have multiple binary crates by placing files in the <em>src/bin</em> directory: each file will be a separate binary crate.</p> <p>A crate will group related functionality together in a scope so the functionality is easy to share between multiple projects. For example, the <code>rand</code> crate we used in <a href="ch02-00-guessing-game-tutorial#generating-a-random-number">Chapter 2</a> provides functionality that generates random numbers. We can use that functionality in our own projects by bringing the <code>rand</code> crate into our project’s scope. All the functionality provided by the <code>rand</code> crate is accessible through the crate’s name, <code>rand</code>.</p> <p>Keeping a crate’s functionality in its own scope clarifies whether particular functionality is defined in our crate or the <code>rand</code> crate and prevents potential conflicts. For example, the <code>rand</code> crate provides a trait named <code>Rng</code>. We can also define a <code>struct</code> named <code>Rng</code> in our own crate. Because a crate’s functionality is namespaced in its own scope, when we add <code>rand</code> as a dependency, the compiler isn’t confused about what the name <code>Rng</code> refers to. In our crate, it refers to the <code>struct Rng</code> that we defined. We would access the <code>Rng</code> trait from the <code>rand</code> crate as <code>rand::Rng</code>.</p> <p>Let’s move on and talk about the module system!</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html</a>
  </p>
</div>
