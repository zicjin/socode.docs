<h1 id="closures-anonymous-functions-that-can-capture-their-environment">Closures: Anonymous Functions that Can Capture Their Environment</h1> <p>Rust’s closures are anonymous functions you can save in a variable or pass as arguments to other functions. You can create the closure in one place and then call the closure to evaluate it in a different context. Unlike functions, closures can capture values from the scope in which they’re defined. We’ll demonstrate how these closure features allow for code reuse and behavior customization.</p>   <h3 id="capturing-the-environment-with-closures">Capturing the Environment with Closures</h3> <p>The first aspect of closures we’re going to examine is that closures can capture values from the environment they’re defined in for later use. Here’s the scenario: A t-shirt company gives away a free shirt to someone on their mailing list every so often. People on the mailing list can optionally add their favorite color to their profile. If the person chosen to get the free shirt has their favorite color in their profile, they get that color shirt. If the person hasn’t specified a favorite color, they get the color that the company currently has the most of.</p> <p>There are many ways to implement this. For this example, we’re going to use an enum called <code>ShirtColor</code> that has the variants <code>Red</code> and <code>Blue</code>. The company’s inventory is represented by an <code>Inventory</code> struct that has a field named <code>shirts</code> that contains a <code>Vec&lt;ShirtColor&gt;</code> representing the shirts currently in stock. The method <code>shirt_giveaway</code> defined on <code>Inventory</code> gets the optional shirt color preference of the person getting the free shirt, and returns the shirt color the person will get. This is shown in Listing 13-1:</p> <p><span class="filename">Filename: src/main.rs</span></p> <pre data-language="rust">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref2, giveaway2
    );
}
</pre> <p><span class="caption">Listing 13-1: Shirt company giveaway</span></p> <p>The <code>store</code> defined in <code>main</code> has two blue shirts and one red shirt in stock. Then it calls the <code>giveaway</code> method for a user with a preference for a red shirt and a user without any preference. Running this code prints:</p> <pre>$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
The user with preference Some(Red) gets Red
The user with preference None gets Blue
</pre> <p>Again, this code could be implemented in many ways, but this way uses concepts you’ve already learned, except for the body of the <code>giveaway</code> method that uses a closure. The <code>giveaway</code> method takes the user preference <code>Option&lt;ShirtColor&gt;</code> and calls <code>unwrap_or_else</code> on it. The <a href="../std/option/enum.option#method.unwrap_or_else"><code>unwrap_or_else</code> method on <code>Option&lt;T&gt;</code></a> is defined by the standard library. It takes one argument: a closure without any arguments that returns a value <code>T</code> (the same type stored in the <code>Some</code> variant of the <code>Option&lt;T&gt;</code>, in this case, a <code>ShirtColor</code>). If the <code>Option&lt;T&gt;</code> is the <code>Some</code> variant, <code>unwrap_or_else</code> returns the value from within the <code>Some</code>. If the <code>Option&lt;T&gt;</code> is the <code>None</code> variant, <code>unwrap_or_else</code> calls the closure and returns the value returned by the closure.</p> <p>This is interesting because we’ve passed a closure that calls <code>self.most_stocked()</code> on the current <code>Inventory</code> instance. The standard library didn’t need to know anything about the <code>Inventory</code> or <code>ShirtColor</code> types we defined, or the logic we want to use in this scenario. The closure captured an immutable reference to the <code>self</code> <code>Inventory</code> instance and passed it with the code we specified to the <code>unwrap_or_else</code> method. Functions are not able to capture their environment in this way.</p> <h3 id="closure-type-inference-and-annotation">Closure Type Inference and Annotation</h3> <p>There are more differences between functions and closures. Closures don’t usually require you to annotate the types of the parameters or the return value like <code>fn</code> functions do. Type annotations are required on functions because they’re part of an explicit interface exposed to your users. Defining this interface rigidly is important for ensuring that everyone agrees on what types of values a function uses and returns. But closures aren’t used in an exposed interface like this: they’re stored in variables and used without naming them and exposing them to users of our library.</p> <p>Closures are typically short and relevant only within a narrow context rather than in any arbitrary scenario. Within these limited contexts, the compiler can infer the types of the parameters and the return type, similar to how it’s able to infer the types of most variables (there are rare cases where the compiler needs closure type annotations too).</p> <p>As with variables, we can add type annotations if we want to increase explicitness and clarity at the cost of being more verbose than is strictly necessary. Annotating the types for a closure would look like the definition shown in Listing 13-2.</p> <p><span class="filename">Filename: src/main.rs</span></p> <pre data-language="rust">use std::thread;
use std::time::Duration;

fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num: u32| -&gt; u32 {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity &lt; 25 {
        println!("Today, do {} pushups!", expensive_closure(intensity));
        println!("Next, do {} situps!", expensive_closure(intensity));
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                expensive_closure(intensity)
            );
        }
    }
}

fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(simulated_user_specified_value, simulated_random_number);
}
</pre> <p><span class="caption">Listing 13-2: Adding optional type annotations of the parameter and return value types in the closure</span></p> <p>With type annotations added, the syntax of closures looks more similar to the syntax of functions. The following is a vertical comparison of the syntax for the definition of a function that adds 1 to its parameter and a closure that has the same behavior. We’ve added some spaces to line up the relevant parts. This illustrates how closure syntax is similar to function syntax except for the use of pipes and the amount of syntax that is optional:</p> <pre data-language="rust">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</pre> <p>The first line shows a function definition, and the second line shows a fully annotated closure definition. The third line removes the type annotations from the closure definition, and the fourth line removes the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they’re called. Calling the closures is required for <code>add_one_v3</code> and <code>add_one_v4</code> to be able to compile because the types will be inferred from their usage.</p> <p>Closure definitions will have one concrete type inferred for each of their parameters and for their return value. For instance, Listing 13-3 shows the definition of a short closure that just returns the value it receives as a parameter. This closure isn’t very useful except for the purposes of this example. Note that we haven’t added any type annotations to the definition: if we then try to call the closure twice, using a <code>String</code> as an argument the first time and a <code>u32</code> the second time, we’ll get an error.</p> <p><span class="filename">Filename: src/main.rs</span></p> <pre data-language="rust">fn main() {
    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);
}
</pre> <p><span class="caption">Listing 13-3: Attempting to call a closure whose types are inferred with two different types</span></p> <p>The compiler gives us this error:</p> <pre>$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |                             ^- help: try using a conversion method: `.to_string()`
  |                             |
  |                             expected struct `String`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` due to previous error
</pre> <p>The first time we call <code>example_closure</code> with the <code>String</code> value, the compiler infers the type of <code>x</code> and the return type of the closure to be <code>String</code>. Those types are then locked into the closure in <code>example_closure</code>, and we get a type error if we try to use a different type with the same closure.</p> <h3 id="capturing-references-or-moving-ownership">Capturing References or Moving Ownership</h3> <p>Closures can capture values from their environment in three ways, which directly map to the three ways a function can take a parameter: borrowing immutably, borrowing mutably, and taking ownership. The closure will decide which of these to use based on what the body of the function does with the captured values.</p> <p>Listing 13-4 defines a closure that captures an immutable borrow to the vector named <code>list</code> because it only needs an immutable borrow to print the value. This example also illustrates that a variable can bind to a closure definition, and the closure can later be called by using the variable name and parentheses as if the variable name were a function name:</p> <p><span class="filename">Filename: src/main.rs</span></p> <pre data-language="rust">fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {:?}", list);

    let only_borrows = || println!("From closure: {:?}", list);

    println!("Before calling closure: {:?}", list);
    only_borrows();
    println!("After calling closure: {:?}", list);
}
</pre> <p><span class="caption">Listing 13-4: Defining and calling a closure that captures an immutable borrow</span></p> <p>The <code>list</code> is still accessible by the code before the closure definition, after the closure definition but before the closure is called, and after the closure is called because we can have multiple immutable borrows of <code>list</code> at the same time. This code compiles, runs, and prints:</p> <pre>$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
Before calling closure: [1, 2, 3]
From closure: [1, 2, 3]
After calling closure: [1, 2, 3]
</pre> <p>Next, Listing 13-5 changes the closure definition to need a mutable borrow because the closure body adds an element to the <code>list</code> vector:</p> <p><span class="filename">Filename: src/main.rs</span></p> <pre data-language="rust">fn main() {
    let mut list = vec![1, 2, 3];
    println!("Before defining closure: {:?}", list);

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("After calling closure: {:?}", list);
}
</pre> <p><span class="caption">Listing 13-5: Defining and calling a closure that captures a mutable borrow</span></p> <p>This code compiles, runs, and prints:</p> <pre>$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
</pre> <p>Note that there’s no longer a <code>println!</code> between the definition and the call of the <code>borrows_mutably</code> closure: when <code>borrows_mutably</code> is defined, it captures a mutable reference to <code>list</code>. After the closure is called, because we don’t use the closure again after that point, the mutable borrow ends. Between the closure definition and the closure call, an immutable borrow to print isn’t allowed because no other borrows are allowed when there’s a mutable borrow. Try adding a <code>println!</code> there to see what error message you get!</p> <p>If you want to force the closure to take ownership of the values it uses in the environment even though the body of the closure doesn’t strictly need ownership, you can use the <code>move</code> keyword before the parameter list. This technique is mostly useful when passing a closure to a new thread to move the data so it’s owned by the new thread. We’ll have more examples of <code>move</code> closures in Chapter 16 when we talk about concurrency.</p>   <h3 id="moving-captured-values-out-of-the-closure-and-the-fn-traits">Moving Captured Values Out of the Closure and the <code id="">Fn</code> Traits</h3> <p>Once a closure has captured a reference or moved a value into the closure, the code in the body of the function also affects what happens to the references or values as a result of calling the function. A closure body can move a captured value out of the closure, can mutate the captured value, can neither move nor mutate the captured value, or can capture nothing from the environment. The way a closure captures and handles values from the environment affects which traits the closure implements. The traits are how functions and structs can specify what kinds of closures they can use.</p> <p>Closures will automatically implement one, two, or all three of these <code>Fn</code> traits, in an additive fashion:</p> <ol> <li>
<code>FnOnce</code> applies to closures that can be called at least once. All closures implement this trait, because all closures can be called. If a closure moves captured values out of its body, then that closure only implements <code>FnOnce</code> and not any of the other <code>Fn</code> traits, because it can only be called once.</li> <li>
<code>FnMut</code> applies to closures that don’t move captured values out of their body, but that might mutate the captured values. These closures can be called more than once.</li> <li>
<code>Fn</code> applies to closures that don’t move captured values out of their body and that don’t mutate captured values. These closures can be called more than once without mutating their environment, which is important in cases such as calling a closure multiple times concurrently. Closures that don’t capture anything from their environment implement <code>Fn</code>.</li> </ol> <p>Let’s look at the definition of the <code>unwrap_or_else</code> method on <code>Option&lt;T&gt;</code> that we used in Listing 13-6:</p> <pre data-language="rust">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}
</pre> <p>Recall that <code>T</code> is the generic type representing the type of the value in the <code>Some</code> variant of an <code>Option</code>. That type <code>T</code> is also the return type of the <code>unwrap_or_else</code> function: code that calls <code>unwrap_or_else</code> on an <code>Option&lt;String&gt;</code>, for example, will get a <code>String</code>.</p> <p>Next, notice that the <code>unwrap_or_else</code> function has an additional generic type parameter, <code>F</code>. The <code>F</code> type is the type of the parameter named <code>f</code>, which is the closure we provide when calling <code>unwrap_or_else</code>.</p> <p>The trait bound specified on the generic type <code>F</code> is <code>FnOnce() -&gt; T</code>, which means <code>F</code> must be able to be called at least once, take no arguments, and return a <code>T</code>. Using <code>FnOnce</code> in the trait bound expresses the constraint that <code>unwrap_or_else</code> is only going to call <code>f</code> at most one time. In the body of <code>unwrap_or_else</code>, we can see that if the <code>Option</code> is <code>Some</code>, <code>f</code> won’t be called. If the <code>Option</code> is <code>None</code>, <code>f</code> will be called once. Because all closures implement <code>FnOnce</code>, <code>unwrap_or_else</code> accepts the most different kinds of closures and is as flexible as it can be.</p> <blockquote> <p>Note: Functions can implement all three of the <code>Fn</code> traits too. If what we want to do doesn’t require capturing a value from the environment, we can use the name of a function rather than a closure where we need something that implements one of the <code>Fn</code> traits. For example, on an <code>Option&lt;Vec&lt;T&gt;&gt;</code> value, we could call <code>unwrap_or_else(Vec::new)</code> to get a new, empty vector if the value is <code>None</code>.</p> </blockquote> <p>Now let’s look at the standard library method <code>sort_by_key</code> defined on slices, to see how that differs. It takes a closure that implements <code>FnMut</code>. The closure gets one argument, a reference to the current item in the slice being considered, and returns a value of type <code>K</code> that can be ordered. This function is useful when you want to sort a slice by a particular attribute of each item. In Listing 13-7, we have a list of <code>Rectangle</code> instances and we use <code>sort_by_key</code> to order them by their <code>width</code> attribute from low to high:</p> <p><span class="filename">Filename: src/main.rs</span></p> <pre data-language="rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle {
            width: 10,
            height: 1,
        },
        Rectangle {
            width: 3,
            height: 5,
        },
        Rectangle {
            width: 7,
            height: 12,
        },
    ];

    list.sort_by_key(|r| r.width);
    println!("{:#?}", list);
}
</pre> <p><span class="caption">Listing 13-7: Using <code>sort_by_key</code> and a closure to sort a list of <code>Rectangle</code> instances by their <code>width</code> value</span></p> <p>This code prints:</p> <pre>$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</pre> <p>The reason <code>sort_by_key</code> is defined to take an <code>FnMut</code> closure is that it calls the closure multiple times: once for each item in the slice. The closure <code>|r| r.width</code> doesn’t capture, mutate, or move out anything from its environment, so it meets the trait bound requirements.</p> <p>In contrast, Listing 13-8 shows an example of a closure that only implements <code>FnOnce</code> because it moves a value out of the environment. The compiler won’t let us use this closure with <code>sort_by_key</code>:</p> <p><span class="filename">Filename: src/main.rs</span></p> <pre data-language="rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle {
            width: 10,
            height: 1,
        },
        Rectangle {
            width: 3,
            height: 5,
        },
        Rectangle {
            width: 7,
            height: 12,
        },
    ];

    let mut sort_operations = vec![];
    let value = String::from("by key called");

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!("{:#?}", list);
}
</pre> <p><span class="caption">Listing 13-8: Attempting to use an <code>FnOnce</code> closure with <code>sort_by_key</code></span></p> <p>This is a contrived, convoluted way (that doesn’t work) to try and count the number of times <code>sort_by_key</code> gets called when sorting <code>list</code>. This code attempts to do this counting by pushing <code>value</code>, a <code>String</code> from the closure’s environment, into the <code>sort_operations</code> vector. The closure captures <code>value</code> then moves <code>value</code> out of the closure by transferring ownership of <code>value</code> to the <code>sort_operations</code> vector. This closure can be called once; trying to call it a second time wouldn’t work because <code>value</code> would no longer be in the environment to be pushed into <code>sort_operations</code> again! Therefore, this closure only implements <code>FnOnce</code>. When we try to compile this code, we get this error that <code>value</code> can’t be moved out of the closure because the closure must implement <code>FnMut</code>:</p> <pre>$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:27:30
   |
24 |       let value = String::from("by key called");
   |           ----- captured outer variable
25 | 
26 |       list.sort_by_key(|r| {
   |  ______________________-
27 | |         sort_operations.push(value);
   | |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait
28 | |         r.width
29 | |     });
   | |_____- captured by this `FnMut` closure

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` due to previous error
</pre> <p>The error points to the line in the closure body that moves <code>value</code> out of the environment. To fix this, we need to change the closure body so that it doesn’t move values out of the environment. If we’re interested in the number of times <code>sort_by_key</code> is called, keeping a counter in the environment and incrementing its value in the closure body is a more straightforward way to calculate that. The closure in Listing 13-9 works with <code>sort_by_key</code> because it is only capturing a mutable reference to the <code>num_sort_operations</code> counter and can therefore be called more than once:</p> <p><span class="filename">Filename: src/main.rs</span></p> <pre data-language="rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle {
            width: 10,
            height: 1,
        },
        Rectangle {
            width: 3,
            height: 5,
        },
        Rectangle {
            width: 7,
            height: 12,
        },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!("{:#?}, sorted in {num_sort_operations} operations", list);
}
</pre> <p><span class="caption">Listing 13-9: Using an <code>FnMut</code> closure with <code>sort_by_key</code> is allowed</span></p> <p>The <code>Fn</code> traits are important when defining or using functions or types that make use of closures. The next section discusses iterators, and many iterator methods take closure arguments. Keep these details of closures in mind as we explore iterators!</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/book/ch13-01-closures.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/book/ch13-01-closures.html</a>
  </p>
</div>
