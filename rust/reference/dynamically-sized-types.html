<h1 id="dynamically-sized-types">Dynamically Sized Types</h1> <p>Most types have a fixed size that is known at compile time and implement the trait <a href="special-types-and-traits#sized"><code>Sized</code></a>. A type with a size that is known only at run-time is called a <em>dynamically sized type</em> (<em>DST</em>) or, informally, an unsized type. <a href="types/slice">Slices</a> and <a href="types/trait-object">trait objects</a> are two examples of <abbr title="dynamically sized
types">DSTs</abbr>. Such types can only be used in certain cases:</p> <ul> <li>
<a href="types/pointer">Pointer types</a> to <abbr title="dynamically sized types">DSTs</abbr> are sized but have twice the size of pointers to sized types <ul> <li>Pointers to slices also store the number of elements of the slice.</li> <li>Pointers to trait objects also store a pointer to a vtable.</li> </ul> </li> <li>
<abbr title="dynamically sized types">DSTs</abbr> can be provided as type arguments when a bound of <code>?Sized</code>. By default any type parameter has a <code>Sized</code> bound.</li> <li>Traits may be implemented for <abbr title="dynamically sized
  types">DSTs</abbr>. Unlike type parameters <code>Self: ?Sized</code> by default in trait definitions.</li> <li>Structs may contain a <abbr title="dynamically sized type">DST</abbr> as the last field, this makes the struct itself a <abbr title="dynamically sized type">DST</abbr>.</li> </ul> <blockquote> <p><strong>Note</strong>: <a href="variables">variables</a>, function parameters, <a href="items/constant-items">const</a> items, and <a href="items/static-items">static</a> items must be <code>Sized</code>.</p> </blockquote><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/reference/dynamically-sized-types.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/reference/dynamically-sized-types.html</a>
  </p>
</div>
