<h1 id="namespaces">Namespaces</h1> <p>A <em>namespace</em> is a logical grouping of declared <a href="../names">names</a>. Names are segregated into separate namespaces based on the kind of entity the name refers to. Namespaces allow the occurrence of a name in one namespace to not conflict with the same name in another namespace.</p> <p>Within a namespace, names are organized in a hierarchy, where each level of the hierarchy has its own collection of named entities.</p> <p>There are several different namespaces that each contain different kinds of entities. The usage of a name will look for the declaration of that name in different namespaces, based on the context, as described in the <a href="name-resolution">name resolution</a> chapter.</p> <p>The following is a list of namespaces, with their corresponding entities:</p> <ul> <li>Type Namespace <ul> <li><a href="../items/modules">Module declarations</a></li> <li><a href="../items/extern-crates">External crate declarations</a></li> <li>
<a href="preludes#extern-prelude">External crate prelude</a> items</li> <li>
<a href="../items/structs">Struct</a>, <a href="../items/unions">union</a>, <a href="../items/enumerations">enum</a>, enum variant declarations</li> <li><a href="../items/traits">Trait item declarations</a></li> <li><a href="../items/type-aliases">Type aliases</a></li> <li><a href="../items/associated-items#associated-types">Associated type declarations</a></li> <li>Built-in types: <a href="../types/boolean">boolean</a>, <a href="../types/numeric">numeric</a>, and <a href="../types/textual">textual</a>
</li> <li><a href="../items/generics">Generic type parameters</a></li> <li><a href="../paths#self-1"><code>Self</code> type</a></li> <li><a href="../attributes#tool-attributes">Tool attribute modules</a></li> </ul> </li> <li>Value Namespace <ul> <li><a href="../items/functions">Function declarations</a></li> <li><a href="../items/constant-items">Constant item declarations</a></li> <li><a href="../items/static-items">Static item declarations</a></li> <li><a href="../items/structs">Struct constructors</a></li> <li><a href="../items/enumerations">Enum variant constructors</a></li> <li><a href="../paths#self-1"><code>Self</code> constructors</a></li> <li><a href="../items/generics#const-generics">Generic const parameters</a></li> <li><a href="../items/associated-items#associated-constants">Associated const declarations</a></li> <li><a href="../items/associated-items#associated-functions-and-methods">Associated function declarations</a></li> <li>Local bindings â€” <a href="../statements#let-statements"><code>let</code></a>, <a href="../expressions/if-expr#if-let-expressions"><code>if let</code></a>, <a href="../expressions/loop-expr#predicate-pattern-loops"><code>while let</code></a>, <a href="../expressions/loop-expr#iterator-loops"><code>for</code></a>, <a href="../expressions/match-expr"><code>match</code></a> arms, <a href="../items/functions#function-parameters">function parameters</a>, <a href="../expressions/closure-expr">closure parameters</a>
</li> <li>Captured <a href="../expressions/closure-expr">closure</a> variables</li> </ul> </li> <li>Macro Namespace <ul> <li><a href="../macros-by-example"><code>macro_rules</code> declarations</a></li> <li><a href="../attributes#built-in-attributes-index">Built-in attributes</a></li> <li><a href="../attributes#tool-attributes">Tool attributes</a></li> <li><a href="../procedural-macros#function-like-procedural-macros">Function-like procedural macros</a></li> <li><a href="../procedural-macros#derive-macros">Derive macros</a></li> <li><a href="../procedural-macros#derive-macro-helper-attributes">Derive macro helpers</a></li> <li><a href="../procedural-macros#attribute-macros">Attribute macros</a></li> </ul> </li> <li>Lifetime Namespace <ul> <li><a href="../items/generics">Generic lifetime parameters</a></li> </ul> </li> <li>Label Namespace<sup class="footnote-reference"><a href="#rustc-lifetime-shadow">1</a></sup> <ul> <li><a href="../expressions/loop-expr#loop-labels">Loop labels</a></li> </ul> </li> </ul> <p>An example of how overlapping names in different namespaces can be used unambiguously:</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
// Foo introduces a type in the type namespace and a constructor in the value
// namespace.
struct Foo(u32);

// The `Foo` macro is declared in the macro namespace.
macro_rules! Foo {
    () =&gt; {};
}

// `Foo` in the `f` parameter type refers to `Foo` in the type namespace.
// `'Foo` introduces a new lifetime in the lifetime namespace.
fn example&lt;'Foo&gt;(f: Foo) {
    // `Foo` refers to the `Foo` constructor in the value namespace.
    let ctor = Foo;
    // `Foo` refers to the `Foo` macro in the macro namespace.
    Foo!{}
    // `'Foo` introduces a label in the label namespace.
    'Foo: loop {
        // `'Foo` refers to the `'Foo` lifetime parameter, and `Foo`
        // refers to the type namespace.
        let x: &amp;'Foo Foo;
        // `'Foo` refers to the label.
        break 'Foo;
    }
}
}
</pre> <h2 id="named-entities-without-a-namespace">Named entities without a namespace</h2> <p>The following entities have explicit names, but the names are not a part of any specific namespace.</p> <h3 id="fields">Fields</h3> <p>Even though struct, enum, and union fields are named, the named fields do not live in an explicit namespace. They can only be accessed via a <a href="../expressions/field-expr">field expression</a>, which only inspects the field names of the specific type being accessed.</p> <h3 id="use-declarations">Use declarations</h3> <p>A <a href="../items/use-declarations">use declaration</a> has named aliases that it imports into scope, but the <code>use</code> item itself does not belong to a specific namespace. Instead, it can introduce aliases into multiple namespaces, depending on the item kind being imported.</p>  <h2 id="sub-namespaces">Sub-namespaces</h2> <p>The macro namespace is split into two sub-namespaces: one for <a href="../macros">bang-style macros</a> and one for <a href="../attributes">attributes</a>. When an attribute is resolved, any bang-style macros in scope will be ignored. And conversely resolving a bang-style macro will ignore attribute macros in scope. This prevents one style from shadowing another.</p> <p>For example, the <a href="../conditional-compilation#the-cfg-attribute"><code>cfg</code> attribute</a> and the <a href="../conditional-compilation#the-cfg-macro"><code>cfg</code> macro</a> are two different entities with the same name in the macro namespace, but they can still be used in their respective context.</p> <p>It is still an error for a <a href="../items/use-declarations"><code>use</code> import</a> to shadow another macro, regardless of their sub-namespaces.</p> <div class="footnote-definition" id="rustc-lifetime-shadow">
<sup class="footnote-definition-label">1</sup> <p><code>rustc</code> currently warns about shadowing when using the same name for a label and lifetime in the same scope, but it still treats them independently. This is intended as a future-compatibility warning about a possible extension to the language. See <a href="https://github.com/rust-lang/rust/pull/24162">PR #24162</a>.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/reference/names/namespaces.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/reference/names/namespaces.html</a>
  </p>
</div>
