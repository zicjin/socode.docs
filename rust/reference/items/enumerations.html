<h1 id="enumerations">Enumerations</h1> <blockquote> <p><strong><sup>Syntax</sup></strong><br> <em>Enumeration</em> :<br> <code>enum</code> <a href="../identifiers">IDENTIFIER</a> <a href="generics"><em>GenericParams</em></a><sup>?</sup> <a href="generics#where-clauses"><em>WhereClause</em></a><sup>?</sup> <code>{</code> <em>EnumItems</em><sup>?</sup> <code>}</code></p> <p><em>EnumItems</em> :<br> <em>EnumItem</em> ( <code>,</code> <em>EnumItem</em> )<sup>*</sup> <code>,</code><sup>?</sup></p> <p><em>EnumItem</em> :<br> <em>OuterAttribute</em><sup>*</sup> <a href="../visibility-and-privacy"><em>Visibility</em></a><sup>?</sup><br> <a href="../identifiers">IDENTIFIER</a> ( <em>EnumItemTuple</em> | <em>EnumItemStruct</em> | <em>EnumItemDiscriminant</em> )<sup>?</sup></p> <p><em>EnumItemTuple</em> :<br> <code>(</code> <a href="structs"><em>TupleFields</em></a><sup>?</sup> <code>)</code></p> <p><em>EnumItemStruct</em> :<br> <code>{</code> <a href="structs"><em>StructFields</em></a><sup>?</sup> <code>}</code></p> <p><em>EnumItemDiscriminant</em> :<br> <code>=</code> <a href="../expressions"><em>Expression</em></a></p> </blockquote> <p>An <em>enumeration</em>, also referred to as an <em>enum</em>, is a simultaneous definition of a nominal <a href="../types/enum">enumerated type</a> as well as a set of <em>constructors</em>, that can be used to create or pattern-match values of the corresponding enumerated type.</p> <p>Enumerations are declared with the keyword <code>enum</code>.</p> <p>An example of an <code>enum</code> item and its use:</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
enum Animal {
    Dog,
    Cat,
}

let mut a: Animal = Animal::Dog;
a = Animal::Cat;
}
</pre> <p>Enum constructors can have either named or unnamed fields:</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
enum Animal {
    Dog(String, f64),
    Cat { name: String, weight: f64 },
}

let mut a: Animal = Animal::Dog("Cocoa".to_string(), 37.2);
a = Animal::Cat { name: "Spotty".to_string(), weight: 2.7 };
}
</pre> <p>In this example, <code>Cat</code> is a <em>struct-like enum variant</em>, whereas <code>Dog</code> is simply called an enum variant. Each enum instance has a <em>discriminant</em> which is an integer associated to it that is used to determine which variant it holds. An opaque reference to this discriminant can be obtained with the <a href="../../std/mem/fn.discriminant"><code>mem::discriminant</code></a> function.</p> <h2 id="custom-discriminant-values-for-fieldless-enumerations">Custom Discriminant Values for Fieldless Enumerations</h2> <p>If there is no data attached to <em>any</em> of the variants of an enumeration, then the discriminant can be directly chosen and accessed.</p> <p>These enumerations can be cast to integer types with the <code>as</code> operator by a <a href="../expressions/operator-expr#semantics">numeric cast</a>. The enumeration can optionally specify which integer each discriminant gets by following the variant name with <code>=</code> followed by a <a href="../const_eval#constant-expressions">constant expression</a>. If the first variant in the declaration is unspecified, then it is set to zero. For every other unspecified discriminant, it is set to one higher than the previous variant in the declaration.</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
enum Foo {
    Bar,            // 0
    Baz = 123,      // 123
    Quux,           // 124
}

let baz_discriminant = Foo::Baz as u32;
assert_eq!(baz_discriminant, 123);
}
</pre> <p>Under the <a href="../type-layout#the-default-representation">default representation</a>, the specified discriminant is interpreted as an <code>isize</code> value although the compiler is allowed to use a smaller type in the actual memory layout. The size and thus acceptable values can be changed by using a <a href="../type-layout#primitive-representations">primitive representation</a> or the <a href="../type-layout#the-c-representation"><code>C</code> representation</a>.</p> <p>It is an error when two variants share the same discriminant.</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
enum SharedDiscriminantError {
    SharedA = 1,
    SharedB = 1
}

enum SharedDiscriminantError2 {
    Zero,       // 0
    One,        // 1
    OneToo = 1  // 1 (collision with previous!)
}
}
</pre> <p>It is also an error to have an unspecified discriminant where the previous discriminant is the maximum value for the size of the discriminant.</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
#[repr(u8)]
enum OverflowingDiscriminantError {
    Max = 255,
    MaxPlusOne // Would be 256, but that overflows the enum.
}

#[repr(u8)]
enum OverflowingDiscriminantError2 {
    MaxMinusOne = 254, // 254
    Max,               // 255
    MaxPlusOne         // Would be 256, but that overflows the enum.
}
}
</pre> <h2 id="zero-variant-enums">Zero-variant Enums</h2> <p>Enums with zero variants are known as <em>zero-variant enums</em>. As they have no valid values, they cannot be instantiated.</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
enum ZeroVariants {}
}
</pre> <p>Zero-variant enums are equivalent to the <a href="../types/never">never type</a>, but they cannot be coerced into other types.</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
enum ZeroVariants {}
let x: ZeroVariants = panic!();
let y: u32 = x; // mismatched type error
}
</pre> <h2 id="variant-visibility">Variant visibility</h2> <p>Enum variants syntactically allow a <a href="../visibility-and-privacy"><em>Visibility</em></a> annotation, but this is rejected when the enum is validated. This allows items to be parsed with a unified syntax across different contexts where they are used.</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
macro_rules! mac_variant {
    ($vis:vis $name:ident) =&gt; {
        enum $name {
            $vis Unit,

            $vis Tuple(u8, u16),

            $vis Struct { f: u8 },
        }
    }
}

// Empty `vis` is allowed.
mac_variant! { E }

// This is allowed, since it is removed before being validated.
#[cfg(FALSE)]
enum E {
    pub U,
    pub(crate) T(u8),
    pub(super) T { f: String }
}
}
</pre><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/reference/items/enumerations.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/reference/items/enumerations.html</a>
  </p>
</div>
