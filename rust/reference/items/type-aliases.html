<h1 id="type-aliases">Type aliases</h1> <blockquote> <p><strong><sup>Syntax</sup></strong><br> <em>TypeAlias</em> :<br> <code>type</code> <a href="../identifiers">IDENTIFIER</a> <a href="generics"><em>GenericParams</em></a><sup>?</sup> <a href="generics#where-clauses"><em>WhereClause</em></a><sup>?</sup> ( <code>=</code> <a href="../types#type-expressions"><em>Type</em></a> )<sup>?</sup> <code>;</code></p> </blockquote> <p>A <em>type alias</em> defines a new name for an existing <a href="../types">type</a>. Type aliases are declared with the keyword <code>type</code>. Every value has a single, specific type, but may implement several different traits, or be compatible with several different type constraints.</p> <p>For example, the following defines the type <code>Point</code> as a synonym for the type <code>(u8, u8)</code>, the type of pairs of unsigned 8 bit integers:</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
type Point = (u8, u8);
let p: Point = (41, 68);
}
</pre> <p>A type alias to a tuple-struct or unit-struct cannot be used to qualify that type's constructor:</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
struct MyStruct(u32);

use MyStruct as UseAlias;
type TypeAlias = MyStruct;

let _ = UseAlias(5); // OK
let _ = TypeAlias(5); // Doesn't work
}
</pre> <p>A type alias without the <a href="../types#type-expressions"><em>Type</em></a> specification may only appear as an <a href="associated-items#associated-types">associated type</a> in a <a href="traits">trait</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/reference/items/type-aliases.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/reference/items/type-aliases.html</a>
  </p>
</div>
