<h1 id="statements">Statements</h1> <blockquote> <p><strong><sup>Syntax</sup></strong><br> <em>Statement</em> :<br> <code>;</code><br> | <a href="items"><em>Item</em></a><br> | <a href="#let-statements"><em>LetStatement</em></a><br> | <a href="#expression-statements"><em>ExpressionStatement</em></a><br> | <a href="macros#macro-invocation"><em>MacroInvocationSemi</em></a></p> </blockquote> <p>A <em>statement</em> is a component of a <a href="expressions/block-expr">block</a>, which is in turn a component of an outer <a href="expressions">expression</a> or <a href="items/functions">function</a>.</p> <p>Rust has two kinds of statement: <a href="#declaration-statements">declaration statements</a> and <a href="#expression-statements">expression statements</a>.</p> <h2 id="declaration-statements">Declaration statements</h2> <p>A <em>declaration statement</em> is one that introduces one or more <em>names</em> into the enclosing statement block. The declared names may denote new variables or new <a href="items">items</a>.</p> <p>The two kinds of declaration statements are item declarations and <code>let</code> statements.</p> <h3 id="item-declarations">Item declarations</h3> <p>An <em>item declaration statement</em> has a syntactic form identical to an <a href="items">item declaration</a> within a <a href="items/modules">module</a>. Declaring an item within a statement block restricts its scope to the block containing the statement. The item is not given a <a href="paths#canonical-paths">canonical path</a> nor are any sub-items it may declare. The exception to this is that associated items defined by <a href="items/implementations">implementations</a> are still accessible in outer scopes as long as the item and, if applicable, trait are accessible. It is otherwise identical in meaning to declaring the item inside a module.</p> <p>There is no implicit capture of the containing function's generic parameters, parameters, and local variables. For example, <code>inner</code> may not access <code>outer_var</code>.</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
fn outer() {
  let outer_var = true;

  fn inner() { /* outer_var is not in scope here */ }

  inner();
}
}
</pre> <h3 id="let-statements">
<code id="">let</code> statements</h3> <blockquote> <p><strong><sup>Syntax</sup></strong><br> <em>LetStatement</em> :<br> <a href="attributes"><em>OuterAttribute</em></a><sup>*</sup> <code>let</code> <a href="patterns"><em>PatternNoTopAlt</em></a> ( <code>:</code> <a href="types"><em>Type</em></a> )<sup>?</sup> (<code>=</code> <a href="expressions"><em>Expression</em></a> )<sup>?</sup> <code>;</code></p> </blockquote> <p>A <em><code>let</code> statement</em> introduces a new set of <a href="variables">variables</a>, given by an irrefutable <a href="patterns">pattern</a>. The pattern is followed optionally by a type annotation and then optionally by an initializer expression. When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope.</p> <h2 id="expression-statements">Expression statements</h2> <blockquote> <p><strong><sup>Syntax</sup></strong><br> <em>ExpressionStatement</em> :<br> <a href="expressions"><em>ExpressionWithoutBlock</em></a> <code>;</code><br> | <a href="expressions"><em>ExpressionWithBlock</em></a> <code>;</code><sup>?</sup></p> </blockquote> <p>An <em>expression statement</em> is one that evaluates an <a href="expressions">expression</a> and ignores its result. As a rule, an expression statement's purpose is to trigger the effects of evaluating its expression.</p> <p>An expression that consists of only a <a href="expressions/block-expr">block expression</a> or control flow expression, if used in a context where a statement is permitted, can omit the trailing semicolon. This can cause an ambiguity between it being parsed as a standalone statement and as a part of another expression; in this case, it is parsed as a statement. The type of <a href="expressions"><em>ExpressionWithBlock</em></a> expressions when used as statements must be the unit type.</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
let mut v = vec![1, 2, 3];
v.pop();          // Ignore the element returned from pop
if v.is_empty() {
    v.push(5);
} else {
    v.remove(0);
}                 // Semicolon can be omitted.
[1];              // Separate expression statement, not an indexing expression.
}
</pre> <p>When the trailing semicolon is omitted, the result must be type <code>()</code>.</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
// bad: the block's type is i32, not ()
// Error: expected `()` because of default return type
// if true {
//   1
// }

// good: the block's type is i32
if true {
  1
} else {
  2
};
}
</pre> <h2 id="attributes-on-statements">Attributes on Statements</h2> <p>Statements accept <a href="attributes">outer attributes</a>. The attributes that have meaning on a statement are <a href="conditional-compilation"><code>cfg</code></a>, and <a href="attributes/diagnostics#lint-check-attributes">the lint check attributes</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/reference/statements.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/reference/statements.html</a>
  </p>
</div>
