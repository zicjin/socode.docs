<h1 class="fqn">Macro std::panic</h1>
<div class="example-wrap"><pre class="rust macro" data-language="rust">
macro_rules! panic {
    ($($arg:tt)*) =&gt; { ... };
}</pre></div> <details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock">
<p>Panics the current thread.</p> <p>This allows a program to terminate immediately and provide feedback to the caller of the program. <code>panic!</code> should be used when a program reaches an unrecoverable state.</p> <p>This macro is the perfect way to assert conditions in example code and in tests. <code>panic!</code> is closely tied with the <code>unwrap</code> method of both <a href="option/enum.option#method.unwrap"><code>Option</code></a> and <a href="result/enum.result#method.unwrap"><code>Result</code></a> enums. Both implementations call <code>panic!</code> when they are set to <a href="option/enum.option#variant.None" title="None"><code>None</code></a> or <a href="result/enum.result#variant.Err" title="Err"><code>Err</code></a> variants.</p> <p>When using <code>panic!()</code> you can specify a string payload, that is built using the <a href="macro.format"><code>format!</code></a> syntax. That payload is used when injecting the panic into the calling Rust thread, causing the thread to panic entirely.</p> <p>The behavior of the default <code>std</code> hook, i.e. the code that runs directly after the panic is invoked, is to print the message payload to <code>stderr</code> along with the file/line/column information of the <code>panic!()</code> call. You can override the panic hook using <a href="panic/fn.set_hook"><code>std::panic::set_hook()</code></a>. Inside the hook a panic can be accessed as a <code>&amp;dyn Any + Send</code>, which contains either a <code>&amp;str</code> or <code>String</code> for regular <code>panic!()</code> invocations. To panic with a value of another other type, <a href="panic/fn.panic_any"><code>panic_any</code></a> can be used.</p> <p><a href="result/enum.result" title="Result"><code>Result</code></a> enum is often a better solution for recovering from errors than using the <code>panic!</code> macro. This macro should be used to avoid proceeding using incorrect values, such as from external sources. Detailed information about error handling is found in the <a href="../book/ch09-00-error-handling">book</a>.</p> <p>See also the macro <a href="macro.compile_error" title="compile_error!"><code>compile_error!</code></a>, for raising errors during compilation.</p> <h2 id="current-implementation" class="section-header">Current implementation</h2> <p>If the main thread panics it will terminate all your threads and end your program with code <code>101</code>.</p> <h2 id="examples" class="section-header">Examples</h2> <div class="information">â“˜ This example panics</div>
<div class="example-wrap"><pre class="rust rust-example-rendered should_panic" data-language="rust">
panic!();
panic!("this is a terrible mistake!");
panic!("this is a {} {message}", "fancy", message = "message");
std::panic::panic_any(4); // panic with the value of 4 to be collected elsewhere</pre></div> </div></details><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/macro.panic.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/macro.panic.html</a>
  </p>
</div>
