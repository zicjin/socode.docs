<h1 class="main-heading">Macro std::todo</h1>
<div class="example-wrap"><pre class="rust macro" data-language="rust">macro_rules! todo {
    () =&gt; { ... };
    ($($arg:tt)+) =&gt; { ... };
}</pre></div> <p>Indicates unfinished code.</p> <p>This can be useful if you are prototyping and are just looking to have your code typecheck.</p> <p>The difference between <a href="macro.unimplemented" title="unimplemented!"><code>unimplemented!</code></a> and <code>todo!</code> is that while <code>todo!</code> conveys an intent of implementing the functionality later and the message is “not yet implemented”, <code>unimplemented!</code> makes no such claims. Its message is “not implemented”. Also some IDEs will mark <code>todo!</code>s.</p> <h2 id="panics">Panics</h2> <p>This will always <a href="https://doc.rust-lang.org/core/macro.panic.html" title="panic!"><code>panic!</code></a>.</p> <h2 id="examples">Examples</h2> <p>Here’s an example of some in-progress code. We have a trait <code>Foo</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">trait Foo {
    fn bar(&amp;self);
    fn baz(&amp;self);
}</pre></div> <p>We want to implement <code>Foo</code> on one of our types, but we also want to work on just <code>bar()</code> first. In order for our code to compile, we need to implement <code>baz()</code>, so we can use <code>todo!</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">struct MyStruct;

impl Foo for MyStruct {
    fn bar(&amp;self) {
        // implementation goes here
    }

    fn baz(&amp;self) {
        // let's not worry about implementing baz() for now
        todo!();
    }
}

fn main() {
    let s = MyStruct;
    s.bar();

    // we aren't even using baz(), so this is fine.
}</pre></div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/macro.todo.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/macro.todo.html</a>
  </p>
</div>
