<h1 class="main-heading">Module std::ffi</h1>
<p>Utilities related to FFI bindings.</p> <p>This module provides utilities to handle data across non-Rust interfaces, like other programming languages and the underlying operating system. It is mainly of use for FFI (Foreign Function Interface) bindings and code that needs to exchange C-like strings with other languages.</p> <h2 id="overview">Overview</h2> <p>Rust represents owned strings with the <a href="../string/struct.string" title="String"><code>String</code></a> type, and borrowed slices of strings with the <a href="../primitive.str" title="str"><code>str</code></a> primitive. Both are always in UTF-8 encoding, and may contain nul bytes in the middle, i.e., if you look at the bytes that make up the string, there may be a <code>\0</code> among them. Both <code>String</code> and <code>str</code> store their length explicitly; there are no nul terminators at the end of strings like in C.</p> <p>C strings are different from Rust strings:</p> <ul> <li> <p><strong>Encodings</strong> - Rust strings are UTF-8, but C strings may use other encodings. If you are using a string from C, you should check its encoding explicitly, rather than just assuming that it is UTF-8 like you can do in Rust.</p> </li> <li> <p><strong>Character size</strong> - C strings may use <code>char</code> or <code>wchar_t</code>-sized characters; please <strong>note</strong> that C’s <code>char</code> is different from Rust’s. The C standard leaves the actual sizes of those types open to interpretation, but defines different APIs for strings made up of each character type. Rust strings are always UTF-8, so different Unicode characters will be encoded in a variable number of bytes each. The Rust type <a href="../primitive.char" title="char"><code>char</code></a> represents a ‘<a href="https://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar value</a>’, which is similar to, but not the same as, a ‘<a href="https://www.unicode.org/glossary/#code_point">Unicode code point</a>’.</p> </li> <li> <p><strong>Nul terminators and implicit string lengths</strong> - Often, C strings are nul-terminated, i.e., they have a <code>\0</code> character at the end. The length of a string buffer is not stored, but has to be calculated; to compute the length of a string, C code must manually call a function like <code>strlen()</code> for <code>char</code>-based strings, or <code>wcslen()</code> for <code>wchar_t</code>-based ones. Those functions return the number of characters in the string excluding the nul terminator, so the buffer length is really <code>len+1</code> characters. Rust strings don’t have a nul terminator; their length is always stored and does not need to be calculated. While in Rust accessing a string’s length is an <em>O</em>(1) operation (because the length is stored); in C it is an <em>O</em>(<em>n</em>) operation because the length needs to be computed by scanning the string for the nul terminator.</p> </li> <li> <p><strong>Internal nul characters</strong> - When C strings have a nul terminator character, this usually means that they cannot have nul characters in the middle — a nul character would essentially truncate the string. Rust strings <em>can</em> have nul characters in the middle, because nul does not have to mark the end of the string in Rust.</p> </li> </ul> <h2 id="representations-of-non-rust-strings">Representations of non-Rust strings</h2> <p><a href="type.cstring" title="CString"><code>CString</code></a> and <a href="type.cstr" title="CStr"><code>CStr</code></a> are useful when you need to transfer UTF-8 strings to and from languages with a C ABI, like Python.</p> <ul> <li> <p><strong>From Rust to C:</strong> <a href="type.cstring" title="CString"><code>CString</code></a> represents an owned, C-friendly string: it is nul-terminated, and has no internal nul characters. Rust code can create a <a href="type.cstring" title="CString"><code>CString</code></a> out of a normal string (provided that the string doesn’t have nul characters in the middle), and then use a variety of methods to obtain a raw <code>*mut <a href="../primitive.u8" title="u8">u8</a></code> that can then be passed as an argument to functions which use the C conventions for strings.</p> </li> <li> <p><strong>From C to Rust:</strong> <a href="type.cstr" title="CStr"><code>CStr</code></a> represents a borrowed C string; it is what you would use to wrap a raw <code>*const <a href="../primitive.u8" title="u8">u8</a></code> that you got from a C function. A <a href="type.cstr" title="CStr"><code>CStr</code></a> is guaranteed to be a nul-terminated array of bytes. Once you have a <a href="type.cstr" title="CStr"><code>CStr</code></a>, you can convert it to a Rust <code>&amp;<a href="../primitive.str" title="str">str</a></code> if it’s valid UTF-8, or lossily convert it by adding replacement characters.</p> </li> </ul> <p><a href="struct.osstring" title="OsString"><code>OsString</code></a> and <a href="struct.osstr" title="OsStr"><code>OsStr</code></a> are useful when you need to transfer strings to and from the operating system itself, or when capturing the output of external commands. Conversions between <a href="struct.osstring" title="OsString"><code>OsString</code></a>, <a href="struct.osstr" title="OsStr"><code>OsStr</code></a> and Rust strings work similarly to those for <a href="type.cstring" title="CString"><code>CString</code></a> and <a href="type.cstr" title="CStr"><code>CStr</code></a>.</p> <ul> <li> <p><a href="struct.osstring" title="OsString"><code>OsString</code></a> losslessly represents an owned platform string. However, this representation is not necessarily in a form native to the platform. In the Rust standard library, various APIs that transfer strings to/from the operating system use <a href="struct.osstring" title="OsString"><code>OsString</code></a> instead of plain strings. For example, <a href="../env/fn.var_os" title="env::var_os"><code>env::var_os()</code></a> is used to query environment variables; it returns an <code><a href="../option/enum.option" title="Option">Option</a>&lt;<a href="struct.osstring" title="OsString">OsString</a>&gt;</code>. If the environment variable exists you will get a <code><a href="../option/enum.option#variant.Some" title="Some">Some</a>(os_string)</code>, which you can <em>then</em> try to convert to a Rust string. This yields a <a href="../result/enum.result" title="Result"><code>Result</code></a>, so that your code can detect errors in case the environment variable did not in fact contain valid Unicode data.</p> </li> <li> <p><a href="struct.osstr" title="OsStr"><code>OsStr</code></a> losslessly represents a borrowed reference to a platform string. However, this representation is not necessarily in a form native to the platform. It can be converted into a UTF-8 Rust string slice in a similar way to <a href="struct.osstring" title="OsString"><code>OsString</code></a>.</p> </li> </ul> <h2 id="conversions">Conversions</h2>
<h3 id="on-unix">On Unix</h3> <p>On Unix, <a href="struct.osstr" title="OsStr"><code>OsStr</code></a> implements the <code>std::os::unix::ffi::<a href="../os/unix/ffi/trait.osstrext" title="os::unix::ffi::OsStrExt">OsStrExt</a></code> trait, which augments it with two methods, <a href="../os/unix/ffi/trait.osstrext#tymethod.from_bytes" title="os::unix::ffi::OsStrExt::from_bytes"><code>from_bytes</code></a> and <a href="../os/unix/ffi/trait.osstrext#tymethod.as_bytes" title="os::unix::ffi::OsStrExt::as_bytes"><code>as_bytes</code></a>. These do inexpensive conversions from and to UTF-8 byte slices.</p> <p>Additionally, on Unix <a href="struct.osstring" title="OsString"><code>OsString</code></a> implements the <code>std::os::unix::ffi::<a href="../os/unix/ffi/trait.osstringext" title="os::unix::ffi::OsStringExt">OsStringExt</a></code> trait, which provides <a href="../os/unix/ffi/trait.osstringext#tymethod.from_vec" title="os::unix::ffi::OsStringExt::from_vec"><code>from_vec</code></a> and <a href="../os/unix/ffi/trait.osstringext#tymethod.into_vec" title="os::unix::ffi::OsStringExt::into_vec"><code>into_vec</code></a> methods that consume their arguments, and take or produce vectors of <a href="../primitive.u8" title="u8"><code>u8</code></a>.</p> <h3 id="on-windows">On Windows</h3> <p>An <a href="struct.osstr" title="OsStr"><code>OsStr</code></a> can be losslessly converted to a native Windows string. And a native Windows string can be losslessly converted to an <a href="struct.osstring" title="OsString"><code>OsString</code></a>.</p> <p>On Windows, <a href="struct.osstr" title="OsStr"><code>OsStr</code></a> implements the <code>std::os::windows::ffi::<a href="../os/windows/ffi/trait.osstrext" title="os::windows::ffi::OsStrExt">OsStrExt</a></code> trait, which provides an <a href="../os/windows/ffi/trait.osstrext#tymethod.encode_wide" title="os::windows::ffi::OsStrExt::encode_wide"><code>encode_wide</code></a> method. This provides an iterator that can be <a href="../iter/trait.iterator#method.collect" title="iter::Iterator::collect"><code>collect</code></a>ed into a vector of <a href="../primitive.u16" title="u16"><code>u16</code></a>. After a nul characters is appended, this is the same as a native Windows string.</p> <p>Additionally, on Windows <a href="struct.osstring" title="OsString"><code>OsString</code></a> implements the <code>std::os::windows:ffi::<a href="../os/windows/ffi/trait.osstringext" title="os::windows::ffi::OsStringExt">OsStringExt</a></code> trait, which provides a <a href="../os/windows/ffi/trait.osstringext#tymethod.from_wide" title="os::windows::ffi::OsStringExt::from_wide"><code>from_wide</code></a> method to convert a native Windows string (without the terminating nul character) to an <a href="struct.osstring" title="OsString"><code>OsString</code></a>.</p> <h2 id="structs" class="small-section-header">Structs</h2> <div class="item-table">
<div class="item-row">
<div class="item-left unstable module-item">
<a class="struct" href="struct.valist" title="std::ffi::VaList struct">VaList</a><span class="stab unstable" title="">Experimental</span>
</div>
<div class="item-right docblock-short">
<p>A wrapper for a <code>va_list</code></p> </div>
</div>
<div class="item-row">
<div class="item-left unstable module-item">
<a class="struct" href="struct.valistimpl" title="std::ffi::VaListImpl struct">VaListImpl</a><span class="stab unstable" title="">Experimental</span>
</div>
<div class="item-right docblock-short">
<p>x86_64 ABI implementation of a <code>va_list</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.osstr" title="std::ffi::OsStr struct">OsStr</a></div>
<div class="item-right docblock-short">
<p>Borrowed reference to an OS string (see <a href="struct.osstring" title="OsString"><code>OsString</code></a>).</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.osstring" title="std::ffi::OsString struct">OsString</a></div>
<div class="item-right docblock-short">
<p>A type that can represent owned, mutable platform-native strings, but is cheaply inter-convertible with Rust strings.</p> </div>
</div>
</div>
<h2 id="enums" class="small-section-header">Enums</h2> <div class="item-table"><div class="item-row">
<div class="item-left module-item"><a class="enum" href="enum.c_void" title="std::ffi::c_void enum">c_void</a></div>
<div class="item-right docblock-short">
<p>Equivalent to C’s <code>void</code> type when used as a <a href="../primitive.pointer" title="pointer">pointer</a>.</p> </div>
</div></div>
<h2 id="types" class="small-section-header">Type Definitions</h2> <div class="item-table">
<div class="item-row">
<div class="item-left module-item"><a class="type" href="type.cstr" title="std::ffi::CStr type">CStr</a></div>
<div class="item-right docblock-short">
<p>See <a href="https://doc.rust-lang.org/core/ffi/c_str/struct.CStr.html" title="core::ffi::CStr">core::ffi::CStr</a>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="type" href="type.cstring" title="std::ffi::CString type">CString</a></div>
<div class="item-right docblock-short">
<p>See <a href="https://doc.rust-lang.org/alloc/ffi/c_str/struct.CString.html" title="alloc::ffi::CString">alloc::ffi::CString</a>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="type" href="type.frombyteswithnulerror" title="std::ffi::FromBytesWithNulError type">FromBytesWithNulError</a></div>
<div class="item-right docblock-short">
<p>See <a href="https://doc.rust-lang.org/core/ffi/c_str/struct.FromBytesWithNulError.html" title="core::ffi::FromBytesWithNulError">core::ffi::FromBytesWithNulError</a>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="type" href="type.fromvecwithnulerror" title="std::ffi::FromVecWithNulError type">FromVecWithNulError</a></div>
<div class="item-right docblock-short">
<p>See <a href="https://doc.rust-lang.org/alloc/ffi/c_str/struct.FromVecWithNulError.html" title="alloc::ffi::FromVecWithNulError">alloc::ffi::FromVecWithNulError</a>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="type" href="type.intostringerror" title="std::ffi::IntoStringError type">IntoStringError</a></div>
<div class="item-right docblock-short">
<p>See <a href="https://doc.rust-lang.org/alloc/ffi/c_str/struct.IntoStringError.html" title="alloc::ffi::IntoStringError">alloc::ffi::IntoStringError</a>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="type" href="type.nulerror" title="std::ffi::NulError type">NulError</a></div>
<div class="item-right docblock-short">
<p>See <a href="https://doc.rust-lang.org/alloc/ffi/c_str/struct.NulError.html" title="alloc::ffi::NulError">alloc::ffi::NulError</a>.</p> </div>
</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/ffi/index.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/ffi/index.html</a>
  </p>
</div>
