<h1 class="main-heading">Primitive Type str</h1>
<p>String slices.</p> <p><em><a href="str/index">See also the <code>std::str</code> module</a>.</em></p> <p>The <code>str</code> type, also called a â€˜string sliceâ€™, is the most primitive string type. It is usually seen in its borrowed form, <code>&amp;str</code>. It is also the type of string literals, <code>&amp;'static str</code>.</p> <p>String slices are always valid UTF-8.</p> <h2 id="examples">Examples</h2> <p>String literals are string slices:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let hello = "Hello, world!";

// with an explicit type annotation
let hello: &amp;'static str = "Hello, world!";</pre></div> <p>They are <code>'static</code> because theyâ€™re stored directly in the final binary, and so will be valid for the <code>'static</code> duration.</p> <h2 id="representation">Representation</h2> <p>A <code>&amp;str</code> is made up of two components: a pointer to some bytes, and a length. You can look at these with the <a href="primitive.str#method.as_ptr"><code>as_ptr</code></a> and <a href="primitive.str#method.len"><code>len</code></a> methods:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::slice;
use std::str;

let story = "Once upon a time...";

let ptr = story.as_ptr();
let len = story.len();

// story has nineteen bytes
assert_eq!(19, len);

// We can re-build a str out of ptr and len. This is all unsafe because
// we are responsible for making sure the two components are valid:
let s = unsafe {
    // First, we build a &amp;[u8]...
    let slice = slice::from_raw_parts(ptr, len);

    // ... and then convert that slice into a string slice
    str::from_utf8(slice)
};

assert_eq!(s, Ok(story));</pre></div> <p>Note: This example shows the internals of <code>&amp;str</code>. <code>unsafe</code> should not be used to get a string slice under normal circumstances. Use <code>as_str</code> instead.</p> <h2 id="implementations" class="small-section-header">Implementations</h2>
<div id="implementations-list">
<summary><section id="impl" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#134-2557">source</a></span><h3 class="code-header in-band">impl str</h3></section></summary><div class="impl-items">
<summary><section id="method.len" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#157">source</a><span class="since" title="const since 1.39.0">const: 1.39.0</span> Â· </span><h4 class="code-header">pub const fn len(&amp;self) -&gt; usize</h4></section></summary><div class="docblock">
<p>Returns the length of <code>self</code>.</p> <p>This length is in bytes, not <a href="primitive.char"><code>char</code></a>s or graphemes. In other words, it might not be what a human considers the length of the string.</p> <h5 id="examples-1">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let len = "foo".len();
assert_eq!(3, len);

assert_eq!("Æ’oo".len(), 4); // fancy f!
assert_eq!("Æ’oo".chars().count(), 3);</pre></div> </div>
<summary><section id="method.is_empty" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#178">source</a><span class="since" title="const since 1.39.0">const: 1.39.0</span> Â· </span><h4 class="code-header">pub const fn is_empty(&amp;self) -&gt; bool</h4></section></summary><div class="docblock">
<p>Returns <code>true</code> if <code>self</code> has a length of zero bytes.</p> <h5 id="examples-2">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "";
assert!(s.is_empty());

let s = "not empty";
assert!(!s.is_empty());</pre></div> </div>
<summary><section id="method.is_char_boundary" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#209">source</a><span class="since" title="Stable since Rust version 1.9.0, const unstable">1.9.0 (const: unstable)</span> Â· </span><h4 class="code-header">pub fn is_char_boundary(&amp;self, index: usize) -&gt; bool</h4></section></summary><div class="docblock">
<p>Checks that <code>index</code>-th byte is the first byte in a UTF-8 code point sequence or the end of the string.</p> <p>The start and end of the string (when <code>index == self.len()</code>) are considered to be boundaries.</p> <p>Returns <code>false</code> if <code>index</code> is greater than <code>self.len()</code>.</p> <h5 id="examples-3">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "LÃ¶we è€è™ LÃ©opard";
assert!(s.is_char_boundary(0));
// start of `è€`
assert!(s.is_char_boundary(6));
assert!(s.is_char_boundary(s.len()));

// second byte of `Ã¶`
assert!(!s.is_char_boundary(2));

// third byte of `è€`
assert!(!s.is_char_boundary(8));</pre></div> </div>
<summary><section id="method.floor_char_boundary" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#256">source</a></span><h4 class="code-header">pub fn floor_char_boundary(&amp;self, index: usize) -&gt; usize</h4></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>round_char_boundary</code> <a href="https://github.com/rust-lang/rust/issues/93743">#93743</a>)</div></span></summary><div class="docblock">
<p>Finds the closest <code>x</code> not exceeding <code>index</code> where <code>is_char_boundary(x)</code> is <code>true</code>.</p> <p>This method can help you truncate a string so that itâ€™s still valid UTF-8, but doesnâ€™t exceed a given number of bytes. Note that this is done purely at the character level and can still visually split graphemes, even though the underlying characters arenâ€™t split. For example, the emoji ğŸ§‘â€ğŸ”¬ (scientist) could be split so that the string only includes ğŸ§‘ (person) instead.</p> <h5 id="examples-4">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(round_char_boundary)]
let s = "â¤ï¸ğŸ§¡ğŸ’›ğŸ’šğŸ’™ğŸ’œ";
assert_eq!(s.len(), 26);
assert!(!s.is_char_boundary(13));

let closest = s.floor_char_boundary(13);
assert_eq!(closest, 10);
assert_eq!(&amp;s[..closest], "â¤ï¸ğŸ§¡");</pre></div> </div>
<summary><section id="method.ceil_char_boundary" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#295">source</a></span><h4 class="code-header">pub fn ceil_char_boundary(&amp;self, index: usize) -&gt; usize</h4></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>round_char_boundary</code> <a href="https://github.com/rust-lang/rust/issues/93743">#93743</a>)</div></span></summary><div class="docblock">
<p>Finds the closest <code>x</code> not below <code>index</code> where <code>is_char_boundary(x)</code> is <code>true</code>.</p> <p>This method is the natural complement to <a href="primitive.str#method.floor_char_boundary"><code>floor_char_boundary</code></a>. See that method for more details.</p> <h5 id="panics">Panics</h5> <p>Panics if <code>index &gt; self.len()</code>.</p> <h5 id="examples-5">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(round_char_boundary)]
let s = "â¤ï¸ğŸ§¡ğŸ’›ğŸ’šğŸ’™ğŸ’œ";
assert_eq!(s.len(), 26);
assert!(!s.is_char_boundary(13));

let closest = s.ceil_char_boundary(13);
assert_eq!(closest, 14);
assert_eq!(&amp;s[..closest], "â¤ï¸ğŸ§¡ğŸ’›");</pre></div> </div>
<summary><section id="method.as_bytes" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#323">source</a><span class="since" title="const since 1.39.0">const: 1.39.0</span> Â· </span><h4 class="code-header">pub const fn as_bytes(&amp;self) -&gt; &amp;[u8]</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="primitive" href="primitive.slice">&amp;[</a><a class="primitive" href="primitive.u8">u8</a><a class="primitive" href="primitive.slice">]</a></span><pre class="content">impl Read for &amp;[u8]
impl Write for &amp;mut [u8]
</pre></span></span></span></summary><div class="docblock">
<p>Converts a string slice to a byte slice. To convert the byte slice back into a string slice, use the <a href="str/fn.from_utf8" title="from_utf8"><code>from_utf8</code></a> function.</p> <h5 id="examples-6">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let bytes = "bors".as_bytes();
assert_eq!(b"bors", bytes);</pre></div> </div>
<summary><section id="method.as_bytes_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#367">source</a><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· </span><h4 class="code-header">pub unsafe fn as_bytes_mut(&amp;mut self) -&gt; &amp;mut [u8]</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="primitive" href="primitive.slice">&amp;[</a><a class="primitive" href="primitive.u8">u8</a><a class="primitive" href="primitive.slice">]</a></span><pre class="content">impl Read for &amp;[u8]
impl Write for &amp;mut [u8]
</pre></span></span></span></summary><div class="docblock">
<p>Converts a mutable string slice to a mutable byte slice.</p> <h5 id="safety">Safety</h5> <p>The caller must ensure that the content of the slice is valid UTF-8 before the borrow ends and the underlying <code>str</code> is used.</p> <p>Use of a <code>str</code> whose contents are not valid UTF-8 is undefined behavior.</p> <h5 id="examples-7">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut s = String::from("Hello");
let bytes = unsafe { s.as_bytes_mut() };

assert_eq!(b"Hello", bytes);</pre></div> <p>Mutability:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut s = String::from("ğŸ—»âˆˆğŸŒ");

unsafe {
    let bytes = s.as_bytes_mut();

    bytes[0] = 0xF0;
    bytes[1] = 0x9F;
    bytes[2] = 0x8D;
    bytes[3] = 0x94;
}

assert_eq!("ğŸ”âˆˆğŸŒ", s);</pre></div> </div>
<summary><section id="method.as_ptr" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#398">source</a><span class="since" title="const since 1.32.0">const: 1.32.0</span> Â· </span><h4 class="code-header">pub const fn as_ptr(&amp;self) -&gt; *const u8</h4></section></summary><div class="docblock">
<p>Converts a string slice to a raw pointer.</p> <p>As string slices are a slice of bytes, the raw pointer points to a <a href="primitive.u8" title="u8"><code>u8</code></a>. This pointer will be pointing to the first byte of the string slice.</p> <p>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use <a href="primitive.str#method.as_mut_ptr"><code>as_mut_ptr</code></a>.</p> <h5 id="examples-8">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "Hello";
let ptr = s.as_ptr();</pre></div> </div>
<summary><section id="method.as_mut_ptr" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#413">source</a><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> Â· </span><h4 class="code-header">pub fn as_mut_ptr(&amp;mut self) -&gt; *mut u8</h4></section></summary><div class="docblock">
<p>Converts a mutable string slice to a raw pointer.</p> <p>As string slices are a slice of bytes, the raw pointer points to a <a href="primitive.u8" title="u8"><code>u8</code></a>. This pointer will be pointing to the first byte of the string slice.</p> <p>It is your responsibility to make sure that the string slice only gets modified in a way that it remains valid UTF-8.</p> </div>
<summary><section id="method.get" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#439">source</a><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span> Â· </span><h4 class="code-header">pub fn get&lt;I&gt;(&amp;self, i: I) -&gt; Option&lt;&amp;&lt;I as SliceIndex&lt;str&gt;&gt;::Output&gt; <span class="where fmt-newline">where<br> I: <a class="trait" href="slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str">str</a>&gt;, </span>
</h4></section></summary><div class="docblock">
<p>Returns a subslice of <code>str</code>.</p> <p>This is the non-panicking alternative to indexing the <code>str</code>. Returns <a href="option/enum.option#variant.None" title="None"><code>None</code></a> whenever equivalent indexing operation would panic.</p> <h5 id="examples-9">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v = String::from("ğŸ—»âˆˆğŸŒ");

assert_eq!(Some("ğŸ—»"), v.get(0..4));

// indices not on UTF-8 sequence boundaries
assert!(v.get(1..).is_none());
assert!(v.get(..8).is_none());

// out of bounds
assert!(v.get(..42).is_none());</pre></div> </div>
<summary><section id="method.get_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#472">source</a><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span> Â· </span><h4 class="code-header">pub fn get_mut&lt;I&gt;(<br> &amp;mut self, <br> i: I<br>) -&gt; Option&lt;&amp;mut &lt;I as SliceIndex&lt;str&gt;&gt;::Output&gt; <span class="where fmt-newline">where<br> I: <a class="trait" href="slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str">str</a>&gt;, </span>
</h4></section></summary><div class="docblock">
<p>Returns a mutable subslice of <code>str</code>.</p> <p>This is the non-panicking alternative to indexing the <code>str</code>. Returns <a href="option/enum.option#variant.None" title="None"><code>None</code></a> whenever equivalent indexing operation would panic.</p> <h5 id="examples-10">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut v = String::from("hello");
// correct length
assert!(v.get_mut(0..5).is_some());
// out of bounds
assert!(v.get_mut(..42).is_none());
assert_eq!(Some("he"), v.get_mut(0..2).map(|v| &amp;*v));

assert_eq!("hello", v);
{
    let s = v.get_mut(0..2);
    let s = s.map(|s| {
        s.make_ascii_uppercase();
        &amp;*s
    });
    assert_eq!(Some("HE"), s);
}
assert_eq!("HEllo", v);</pre></div> </div>
<summary><section id="method.get_unchecked" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#505">source</a><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span> Â· </span><h4 class="code-header">pub unsafe fn get_unchecked&lt;I&gt;(&amp;self, i: I) -&gt; &amp;&lt;I as SliceIndex&lt;str&gt;&gt;::Output <span class="where fmt-newline">where<br> I: <a class="trait" href="slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str">str</a>&gt;, </span>
</h4></section></summary><div class="docblock">
<p>Returns an unchecked subslice of <code>str</code>.</p> <p>This is the unchecked alternative to indexing the <code>str</code>.</p> <h5 id="safety-1">Safety</h5> <p>Callers of this function are responsible that these preconditions are satisfied:</p> <ul> <li>The starting index must not exceed the ending index;</li> <li>Indexes must be within bounds of the original slice;</li> <li>Indexes must lie on UTF-8 sequence boundaries.</li> </ul> <p>Failing that, the returned string slice may reference invalid memory or violate the invariants communicated by the <code>str</code> type.</p> <h5 id="examples-11">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v = "ğŸ—»âˆˆğŸŒ";
unsafe {
    assert_eq!("ğŸ—»", v.get_unchecked(0..4));
    assert_eq!("âˆˆ", v.get_unchecked(4..7));
    assert_eq!("ğŸŒ", v.get_unchecked(7..11));
}</pre></div> </div>
<summary><section id="method.get_unchecked_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#541-544">source</a><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span> Â· </span><h4 class="code-header">pub unsafe fn get_unchecked_mut&lt;I&gt;(<br> &amp;mut self, <br> i: I<br>) -&gt; &amp;mut &lt;I as SliceIndex&lt;str&gt;&gt;::Output <span class="where fmt-newline">where<br> I: <a class="trait" href="slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str">str</a>&gt;, </span>
</h4></section></summary><div class="docblock">
<p>Returns a mutable, unchecked subslice of <code>str</code>.</p> <p>This is the unchecked alternative to indexing the <code>str</code>.</p> <h5 id="safety-2">Safety</h5> <p>Callers of this function are responsible that these preconditions are satisfied:</p> <ul> <li>The starting index must not exceed the ending index;</li> <li>Indexes must be within bounds of the original slice;</li> <li>Indexes must lie on UTF-8 sequence boundaries.</li> </ul> <p>Failing that, the returned string slice may reference invalid memory or violate the invariants communicated by the <code>str</code> type.</p> <h5 id="examples-12">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut v = String::from("ğŸ—»âˆˆğŸŒ");
unsafe {
    assert_eq!("ğŸ—»", v.get_unchecked_mut(0..4));
    assert_eq!("âˆˆ", v.get_unchecked_mut(4..7));
    assert_eq!("ğŸŒ", v.get_unchecked_mut(7..11));
}</pre></div> </div>
<summary><section id="method.slice_unchecked" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#597">source</a></span><h4 class="code-header">pub unsafe fn slice_unchecked(&amp;self, begin: usize, end: usize) -&gt; &amp;str</h4></section><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span> Deprecated since 1.29.0: <p>use <code>get_unchecked(begin..end)</code> instead</p> </div></span></summary><div class="docblock">
<p>Creates a string slice from another string slice, bypassing safety checks.</p> <p>This is generally not recommended, use with caution! For a safe alternative see <a href="primitive.str" title="str"><code>str</code></a> and <a href="ops/trait.index"><code>Index</code></a>.</p> <p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but excluding <code>end</code>.</p> <p>To get a mutable string slice instead, see the <a href="primitive.str#method.slice_mut_unchecked"><code>slice_mut_unchecked</code></a> method.</p> <h5 id="safety-3">Safety</h5> <p>Callers of this function are responsible that three preconditions are satisfied:</p> <ul> <li>
<code>begin</code> must not exceed <code>end</code>.</li> <li>
<code>begin</code> and <code>end</code> must be byte positions within the string slice.</li> <li>
<code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li> </ul> <h5 id="examples-13">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "LÃ¶we è€è™ LÃ©opard";

unsafe {
    assert_eq!("LÃ¶we è€è™ LÃ©opard", s.slice_unchecked(0, 21));
}

let s = "Hello, world!";

unsafe {
    assert_eq!("world", s.slice_unchecked(7, 12));
}</pre></div> </div>
<summary><section id="method.slice_mut_unchecked" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#630">source</a><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· </span><h4 class="code-header">pub unsafe fn slice_mut_unchecked(<br> &amp;mut self, <br> begin: usize, <br> end: usize<br>) -&gt; &amp;mut str</h4></section><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span> Deprecated since 1.29.0: <p>use <code>get_unchecked_mut(begin..end)</code> instead</p> </div></span></summary><div class="docblock">
<p>Creates a string slice from another string slice, bypassing safety checks. This is generally not recommended, use with caution! For a safe alternative see <a href="primitive.str" title="str"><code>str</code></a> and <a href="ops/trait.indexmut"><code>IndexMut</code></a>.</p> <p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but excluding <code>end</code>.</p> <p>To get an immutable string slice instead, see the <a href="primitive.str#method.slice_unchecked"><code>slice_unchecked</code></a> method.</p> <h5 id="safety-4">Safety</h5> <p>Callers of this function are responsible that three preconditions are satisfied:</p> <ul> <li>
<code>begin</code> must not exceed <code>end</code>.</li> <li>
<code>begin</code> and <code>end</code> must be byte positions within the string slice.</li> <li>
<code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li> </ul> </div>
<summary><section id="method.split_at" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#670">source</a><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span> Â· </span><h4 class="code-header">pub fn split_at(&amp;self, mid: usize) -&gt; (&amp;str, &amp;str)</h4></section></summary><div class="docblock">
<p>Divide one string slice into two at an index.</p> <p>The argument, <code>mid</code>, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</p> <p>The two slices returned go from the start of the string slice to <code>mid</code>, and from <code>mid</code> to the end of the string slice.</p> <p>To get mutable string slices instead, see the <a href="primitive.str#method.split_at_mut"><code>split_at_mut</code></a> method.</p> <h5 id="panics-1">Panics</h5> <p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is past the end of the last code point of the string slice.</p> <h5 id="examples-14">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "Per Martin-LÃ¶f";

let (first, last) = s.split_at(3);

assert_eq!("Per", first);
assert_eq!(" Martin-LÃ¶f", last);</pre></div> </div>
<summary><section id="method.split_at_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#714">source</a><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span> Â· </span><h4 class="code-header">pub fn split_at_mut(&amp;mut self, mid: usize) -&gt; (&amp;mut str, &amp;mut str)</h4></section></summary><div class="docblock">
<p>Divide one mutable string slice into two at an index.</p> <p>The argument, <code>mid</code>, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</p> <p>The two slices returned go from the start of the string slice to <code>mid</code>, and from <code>mid</code> to the end of the string slice.</p> <p>To get immutable string slices instead, see the <a href="primitive.str#method.split_at"><code>split_at</code></a> method.</p> <h5 id="panics-2">Panics</h5> <p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is past the end of the last code point of the string slice.</p> <h5 id="examples-15">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut s = "Per Martin-LÃ¶f".to_string();
{
    let (first, last) = s.split_at_mut(3);
    first.make_ascii_uppercase();
    assert_eq!("PER", first);
    assert_eq!(" Martin-LÃ¶f", last);
}
assert_eq!("PER Martin-LÃ¶f", s);</pre></div> </div>
<summary><section id="method.chars" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#780">source</a></span><h4 class="code-header">pub fn chars(&amp;self) -&gt; Chars&lt;'_&gt;</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.chars" title="struct std::str::Chars">Chars</a>&lt;'a&gt;</span><pre class="content">impl&lt;'a&gt; Iterator for Chars&lt;'a&gt;
    type Item = char;
</pre></span></span></span></summary><div class="docblock">
<p>Returns an iterator over the <a href="primitive.char"><code>char</code></a>s of a string slice.</p> <p>As a string slice consists of valid UTF-8, we can iterate through a string slice by <a href="primitive.char"><code>char</code></a>. This method returns such an iterator.</p> <p>Itâ€™s important to remember that <a href="primitive.char"><code>char</code></a> represents a Unicode Scalar Value, and might not match your idea of what a â€˜characterâ€™ is. Iteration over grapheme clusters may be what you actually want. This functionality is not provided by Rustâ€™s standard library, check crates.io instead.</p> <h5 id="examples-16">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let word = "goodbye";

let count = word.chars().count();
assert_eq!(7, count);

let mut chars = word.chars();

assert_eq!(Some('g'), chars.next());
assert_eq!(Some('o'), chars.next());
assert_eq!(Some('o'), chars.next());
assert_eq!(Some('d'), chars.next());
assert_eq!(Some('b'), chars.next());
assert_eq!(Some('y'), chars.next());
assert_eq!(Some('e'), chars.next());

assert_eq!(None, chars.next());</pre></div> <p>Remember, <a href="primitive.char"><code>char</code></a>s might not match your intuition about characters:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let y = "yÌ†";

let mut chars = y.chars();

assert_eq!(Some('y'), chars.next()); // not 'yÌ†'
assert_eq!(Some('\u{0306}'), chars.next());

assert_eq!(None, chars.next());</pre></div> </div>
<summary><section id="method.char_indices" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#837">source</a></span><h4 class="code-header">pub fn char_indices(&amp;self) -&gt; CharIndices&lt;'_&gt;</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.charindices" title="struct std::str::CharIndices">CharIndices</a>&lt;'a&gt;</span><pre class="content">impl&lt;'a&gt; Iterator for CharIndices&lt;'a&gt;
    type Item = (usize, char);
</pre></span></span></span></summary><div class="docblock">
<p>Returns an iterator over the <a href="primitive.char"><code>char</code></a>s of a string slice, and their positions.</p> <p>As a string slice consists of valid UTF-8, we can iterate through a string slice by <a href="primitive.char"><code>char</code></a>. This method returns an iterator of both these <a href="primitive.char"><code>char</code></a>s, as well as their byte positions.</p> <p>The iterator yields tuples. The position is first, the <a href="primitive.char"><code>char</code></a> is second.</p> <h5 id="examples-17">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let word = "goodbye";

let count = word.char_indices().count();
assert_eq!(7, count);

let mut char_indices = word.char_indices();

assert_eq!(Some((0, 'g')), char_indices.next());
assert_eq!(Some((1, 'o')), char_indices.next());
assert_eq!(Some((2, 'o')), char_indices.next());
assert_eq!(Some((3, 'd')), char_indices.next());
assert_eq!(Some((4, 'b')), char_indices.next());
assert_eq!(Some((5, 'y')), char_indices.next());
assert_eq!(Some((6, 'e')), char_indices.next());

assert_eq!(None, char_indices.next());</pre></div> <p>Remember, <a href="primitive.char"><code>char</code></a>s might not match your intuition about characters:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let yes = "yÌ†es";

let mut char_indices = yes.char_indices();

assert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'yÌ†')
assert_eq!(Some((1, '\u{0306}')), char_indices.next());

// note the 3 here - the last character took up two bytes
assert_eq!(Some((3, 'e')), char_indices.next());
assert_eq!(Some((4, 's')), char_indices.next());

assert_eq!(None, char_indices.next());</pre></div> </div>
<summary><section id="method.bytes" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#862">source</a></span><h4 class="code-header">pub fn bytes(&amp;self) -&gt; Bytes&lt;'_&gt;</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.bytes" title="struct std::str::Bytes">Bytes</a>&lt;'_&gt;</span><pre class="content">impl&lt;'_&gt; Iterator for Bytes&lt;'_&gt;
    type Item = u8;
</pre></span></span></span></summary><div class="docblock">
<p>An iterator over the bytes of a string slice.</p> <p>As a string slice consists of a sequence of bytes, we can iterate through a string slice by byte. This method returns such an iterator.</p> <h5 id="examples-18">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut bytes = "bors".bytes();

assert_eq!(Some(b'b'), bytes.next());
assert_eq!(Some(b'o'), bytes.next());
assert_eq!(Some(b'r'), bytes.next());
assert_eq!(Some(b's'), bytes.next());

assert_eq!(None, bytes.next());</pre></div> </div>
<summary><section id="method.split_whitespace" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#908">source</a><span class="since" title="Stable since Rust version 1.1.0">1.1.0</span> Â· </span><h4 class="code-header">pub fn split_whitespace(&amp;self) -&gt; SplitWhitespace&lt;'_&gt;</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.splitwhitespace" title="struct std::str::SplitWhitespace">SplitWhitespace</a>&lt;'a&gt;</span><pre class="content">impl&lt;'a&gt; Iterator for SplitWhitespace&lt;'a&gt;
    type Item = &amp;'a str;
</pre></span></span></span></summary><div class="docblock">
<p>Splits a string slice by whitespace.</p> <p>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of whitespace.</p> <p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>. If you only want to split on ASCII whitespace instead, use <a href="primitive.str#method.split_ascii_whitespace"><code>split_ascii_whitespace</code></a>.</p> <h5 id="examples-19">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut iter = "A few words".split_whitespace();

assert_eq!(Some("A"), iter.next());
assert_eq!(Some("few"), iter.next());
assert_eq!(Some("words"), iter.next());

assert_eq!(None, iter.next());</pre></div> <p>All kinds of whitespace are considered:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut iter = " Mary   had\ta\u{2009}little  \n\t lamb".split_whitespace();
assert_eq!(Some("Mary"), iter.next());
assert_eq!(Some("had"), iter.next());
assert_eq!(Some("a"), iter.next());
assert_eq!(Some("little"), iter.next());
assert_eq!(Some("lamb"), iter.next());

assert_eq!(None, iter.next());</pre></div> </div>
<summary><section id="method.split_ascii_whitespace" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#951">source</a><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· </span><h4 class="code-header">pub fn split_ascii_whitespace(&amp;self) -&gt; SplitAsciiWhitespace&lt;'_&gt;</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.splitasciiwhitespace" title="struct std::str::SplitAsciiWhitespace">SplitAsciiWhitespace</a>&lt;'a&gt;</span><pre class="content">impl&lt;'a&gt; Iterator for SplitAsciiWhitespace&lt;'a&gt;
    type Item = &amp;'a str;
</pre></span></span></span></summary><div class="docblock">
<p>Splits a string slice by ASCII whitespace.</p> <p>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of ASCII whitespace.</p> <p>To split by Unicode <code>Whitespace</code> instead, use <a href="primitive.str#method.split_whitespace"><code>split_whitespace</code></a>.</p> <h5 id="examples-20">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut iter = "A few words".split_ascii_whitespace();

assert_eq!(Some("A"), iter.next());
assert_eq!(Some("few"), iter.next());
assert_eq!(Some("words"), iter.next());

assert_eq!(None, iter.next());</pre></div> <p>All kinds of ASCII whitespace are considered:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut iter = " Mary   had\ta little  \n\t lamb".split_ascii_whitespace();
assert_eq!(Some("Mary"), iter.next());
assert_eq!(Some("had"), iter.next());
assert_eq!(Some("a"), iter.next());
assert_eq!(Some("little"), iter.next());
assert_eq!(Some("lamb"), iter.next());

assert_eq!(None, iter.next());</pre></div> </div>
<summary><section id="method.lines" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#997">source</a></span><h4 class="code-header">pub fn lines(&amp;self) -&gt; Lines&lt;'_&gt;</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.lines" title="struct std::str::Lines">Lines</a>&lt;'a&gt;</span><pre class="content">impl&lt;'a&gt; Iterator for Lines&lt;'a&gt;
    type Item = &amp;'a str;
</pre></span></span></span></summary><div class="docblock">
<p>An iterator over the lines of a string, as string slices.</p> <p>Lines are ended with either a newline (<code>\n</code>) or a carriage return with a line feed (<code>\r\n</code>).</p> <p>The final line ending is optional. A string that ends with a final line ending will return the same lines as an otherwise identical string without a final line ending.</p> <h5 id="examples-21">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let text = "foo\r\nbar\n\nbaz\n";
let mut lines = text.lines();

assert_eq!(Some("foo"), lines.next());
assert_eq!(Some("bar"), lines.next());
assert_eq!(Some(""), lines.next());
assert_eq!(Some("baz"), lines.next());

assert_eq!(None, lines.next());</pre></div> <p>The final line ending isnâ€™t required:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let text = "foo\nbar\n\r\nbaz";
let mut lines = text.lines();

assert_eq!(Some("foo"), lines.next());
assert_eq!(Some("bar"), lines.next());
assert_eq!(Some(""), lines.next());
assert_eq!(Some("baz"), lines.next());

assert_eq!(None, lines.next());</pre></div> </div>
<summary><section id="method.lines_any" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1006">source</a></span><h4 class="code-header">pub fn lines_any(&amp;self) -&gt; LinesAny&lt;'_&gt;</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.linesany" title="struct std::str::LinesAny">LinesAny</a>&lt;'a&gt;</span><pre class="content">impl&lt;'a&gt; Iterator for LinesAny&lt;'a&gt;
    type Item = &amp;'a str;
</pre></span></span></span><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span> Deprecated since 1.4.0: <p>use lines() instead now</p> </div></span></summary><div class="docblock">
<p>An iterator over the lines of a string.</p> </div>
<summary><section id="method.encode_utf16" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1027">source</a><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span> Â· </span><h4 class="code-header">pub fn encode_utf16(&amp;self) -&gt; EncodeUtf16&lt;'_&gt;</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.encodeutf16" title="struct std::str::EncodeUtf16">EncodeUtf16</a>&lt;'a&gt;</span><pre class="content">impl&lt;'a&gt; Iterator for EncodeUtf16&lt;'a&gt;
    type Item = u16;
</pre></span></span></span></summary><div class="docblock">
<p>Returns an iterator of <code>u16</code> over the string encoded as UTF-16.</p> <h5 id="examples-22">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let text = "ZaÅ¼Ã³Å‚Ä‡ gÄ™Å›lÄ… jaÅºÅ„";

let utf8_len = text.len();
let utf16_len = text.encode_utf16().count();

assert!(utf16_len &lt;= utf8_len);</pre></div> </div>
<summary><section id="method.contains" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1054">source</a></span><h4 class="code-header">pub fn contains&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; bool <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span>
</h4></section></summary><div class="docblock">
<p>Returns <code>true</code> if the given pattern matches a sub-slice of this string slice.</p> <p>Returns <code>false</code> if it does not.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-23">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let bananas = "bananas";

assert!(bananas.contains("nana"));
assert!(!bananas.contains("apples"));</pre></div> </div>
<summary><section id="method.starts_with" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1080">source</a></span><h4 class="code-header">pub fn starts_with&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; bool <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span>
</h4></section></summary><div class="docblock">
<p>Returns <code>true</code> if the given pattern matches a prefix of this string slice.</p> <p>Returns <code>false</code> if it does not.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-24">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let bananas = "bananas";

assert!(bananas.starts_with("bana"));
assert!(!bananas.starts_with("nana"));</pre></div> </div>
<summary><section id="method.ends_with" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1106-1108">source</a></span><h4 class="code-header">pub fn ends_with&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; bool <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br> &lt;P as <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span>
</h4></section></summary><div class="docblock">
<p>Returns <code>true</code> if the given pattern matches a suffix of this string slice.</p> <p>Returns <code>false</code> if it does not.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-25">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let bananas = "bananas";

assert!(bananas.ends_with("anas"));
assert!(!bananas.ends_with("nana"));</pre></div> </div>
<summary><section id="method.find" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1157">source</a></span><h4 class="code-header">pub fn find&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; Option&lt;usize&gt; <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span>
</h4></section></summary><div class="docblock">
<p>Returns the byte index of the first character of this string slice that matches the pattern.</p> <p>Returns <a href="option/enum.option#variant.None" title="None"><code>None</code></a> if the pattern doesnâ€™t match.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-26">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "LÃ¶we è€è™ LÃ©opard Gepardi";

assert_eq!(s.find('L'), Some(0));
assert_eq!(s.find('Ã©'), Some(14));
assert_eq!(s.find("pard"), Some(17));</pre></div> <p>More complex patterns using point-free style and closures:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "LÃ¶we è€è™ LÃ©opard";

assert_eq!(s.find(char::is_whitespace), Some(5));
assert_eq!(s.find(char::is_lowercase), Some(1));
assert_eq!(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), Some(1));
assert_eq!(s.find(|c: char| (c &lt; 'o') &amp;&amp; (c &gt; 'a')), Some(4));</pre></div> <p>Not finding the pattern:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "LÃ¶we è€è™ LÃ©opard";
let x: &amp;[_] = &amp;['1', '2'];

assert_eq!(s.find(x), None);</pre></div> </div>
<summary><section id="method.rfind" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1203-1205">source</a></span><h4 class="code-header">pub fn rfind&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; Option&lt;usize&gt; <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br> &lt;P as <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span>
</h4></section></summary><div class="docblock">
<p>Returns the byte index for the first character of the rightmost match of the pattern in this string slice.</p> <p>Returns <a href="option/enum.option#variant.None" title="None"><code>None</code></a> if the pattern doesnâ€™t match.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-27">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "LÃ¶we è€è™ LÃ©opard Gepardi";

assert_eq!(s.rfind('L'), Some(13));
assert_eq!(s.rfind('Ã©'), Some(14));
assert_eq!(s.rfind("pard"), Some(24));</pre></div> <p>More complex patterns with closures:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "LÃ¶we è€è™ LÃ©opard";

assert_eq!(s.rfind(char::is_whitespace), Some(12));
assert_eq!(s.rfind(char::is_lowercase), Some(20));</pre></div> <p>Not finding the pattern:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "LÃ¶we è€è™ LÃ©opard";
let x: &amp;[_] = &amp;['1', '2'];

assert_eq!(s.rfind(x), None);</pre></div> </div>
<summary><section id="method.split" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1325">source</a></span><h4 class="code-header">pub fn split&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; Split&lt;'a, P&gt; <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span>
</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.split" title="struct std::str::Split">Split</a>&lt;'a, P&gt;</span><pre class="content">impl&lt;'a, P&gt; Iterator for Split&lt;'a, P&gt; where
Â Â Â Â P: Pattern&lt;'a&gt;,Â 
    type Item = &amp;'a str;
</pre></span></span></span></summary><div class="docblock">
<p>An iterator over substrings of this string slice, separated by characters matched by a pattern.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior">Iterator behavior</h5> <p>The returned iterator will be a <a href="iter/trait.doubleendediterator" title="DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., <a href="primitive.char"><code>char</code></a>, but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="primitive.str#method.rsplit"><code>rsplit</code></a> method can be used.</p> <h5 id="examples-28">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb".split(' ').collect();
assert_eq!(v, ["Mary", "had", "a", "little", "lamb"]);

let v: Vec&lt;&amp;str&gt; = "".split('X').collect();
assert_eq!(v, [""]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".split('X').collect();
assert_eq!(v, ["lion", "", "tiger", "leopard"]);

let v: Vec&lt;&amp;str&gt; = "lion::tiger::leopard".split("::").collect();
assert_eq!(v, ["lion", "tiger", "leopard"]);

let v: Vec&lt;&amp;str&gt; = "abc1def2ghi".split(char::is_numeric).collect();
assert_eq!(v, ["abc", "def", "ghi"]);

let v: Vec&lt;&amp;str&gt; = "lionXtigerXleopard".split(char::is_uppercase).collect();
assert_eq!(v, ["lion", "tiger", "leopard"]);</pre></div> <p>If the pattern is a slice of chars, split on each occurrence of any of the characters:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "2020-11-03 23:59".split(&amp;['-', ' ', ':', '@'][..]).collect();
assert_eq!(v, ["2020", "11", "03", "23", "59"]);</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "abc1defXghi".split(|c| c == '1' || c == 'X').collect();
assert_eq!(v, ["abc", "def", "ghi"]);</pre></div> <p>If a string contains multiple contiguous separators, you will end up with empty strings in the output:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = "||||a||b|c".to_string();
let d: Vec&lt;_&gt; = x.split('|').collect();

assert_eq!(d, &amp;["", "", "", "", "a", "", "b", "c"]);</pre></div> <p>Contiguous separators are separated by the empty string.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = "(///)".to_string();
let d: Vec&lt;_&gt; = x.split('/').collect();

assert_eq!(d, &amp;["(", "", "", ")"]);</pre></div> <p>Separators at the start or end of a string are neighbored by empty strings.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let d: Vec&lt;_&gt; = "010".split("0").collect();
assert_eq!(d, &amp;["", "1", ""]);</pre></div> <p>When the empty string is used as a separator, it separates every character in the string, along with the beginning and end of the string.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let f: Vec&lt;_&gt; = "rust".split("").collect();
assert_eq!(f, &amp;["", "r", "u", "s", "t", ""]);</pre></div> <p>Contiguous separators can lead to possibly surprising behavior when whitespace is used as the separator. This code is correct:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let x = "    a  b c".to_string();
let d: Vec&lt;_&gt; = x.split(' ').collect();

assert_eq!(d, &amp;["", "", "", "", "a", "", "b", "c"]);</pre></div> <p>It does <em>not</em> give you:</p> <div class="information">â“˜ This example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">assert_eq!(d, &amp;["a", "b", "c"]);</pre></div> <p>Use <a href="primitive.str#method.split_whitespace"><code>split_whitespace</code></a> for this behavior.</p> </div>
<summary><section id="method.split_inclusive" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1365">source</a><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span> Â· </span><h4 class="code-header">pub fn split_inclusive&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; SplitInclusive&lt;'a, P&gt; <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span>
</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.splitinclusive" title="struct std::str::SplitInclusive">SplitInclusive</a>&lt;'a, P&gt;</span><pre class="content">impl&lt;'a, P&gt; Iterator for SplitInclusive&lt;'a, P&gt; where
Â Â Â Â P: Pattern&lt;'a&gt;,Â 
    type Item = &amp;'a str;
</pre></span></span></span></summary><div class="docblock">
<p>An iterator over substrings of this string slice, separated by characters matched by a pattern. Differs from the iterator produced by <code>split</code> in that <code>split_inclusive</code> leaves the matched part as the terminator of the substring.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-29">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb\nlittle lamb\nlittle lamb."
    .split_inclusive('\n').collect();
assert_eq!(v, ["Mary had a little lamb\n", "little lamb\n", "little lamb."]);</pre></div> <p>If the last element of the string is matched, that element will be considered the terminator of the preceding substring. That substring will be the last item returned by the iterator.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb\nlittle lamb\nlittle lamb.\n"
    .split_inclusive('\n').collect();
assert_eq!(v, ["Mary had a little lamb\n", "little lamb\n", "little lamb.\n"]);</pre></div> </div>
<summary><section id="method.rsplit" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1420-1422">source</a></span><h4 class="code-header">pub fn rsplit&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; RSplit&lt;'a, P&gt; <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br> &lt;P as <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span>
</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.rsplit" title="struct std::str::RSplit">RSplit</a>&lt;'a, P&gt;</span><pre class="content">impl&lt;'a, P&gt; Iterator for RSplit&lt;'a, P&gt; where
Â Â Â Â P: Pattern&lt;'a&gt;,
Â Â Â Â &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: ReverseSearcher&lt;'a&gt;,Â 
    type Item = &amp;'a str;
</pre></span></span></span></summary><div class="docblock">
<p>An iterator over substrings of the given string slice, separated by characters matched by a pattern and yielded in reverse order.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior-1">Iterator behavior</h5> <p>The returned iterator requires that the pattern supports a reverse search, and it will be a <a href="iter/trait.doubleendediterator" title="DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="primitive.str#method.split"><code>split</code></a> method can be used.</p> <h5 id="examples-30">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb".rsplit(' ').collect();
assert_eq!(v, ["lamb", "little", "a", "had", "Mary"]);

let v: Vec&lt;&amp;str&gt; = "".rsplit('X').collect();
assert_eq!(v, [""]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".rsplit('X').collect();
assert_eq!(v, ["leopard", "tiger", "", "lion"]);

let v: Vec&lt;&amp;str&gt; = "lion::tiger::leopard".rsplit("::").collect();
assert_eq!(v, ["leopard", "tiger", "lion"]);</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "abc1defXghi".rsplit(|c| c == '1' || c == 'X').collect();
assert_eq!(v, ["ghi", "def", "abc"]);</pre></div> </div>
<summary><section id="method.split_terminator" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1471">source</a></span><h4 class="code-header">pub fn split_terminator&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; SplitTerminator&lt;'a, P&gt; <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span>
</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.splitterminator" title="struct std::str::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt;</span><pre class="content">impl&lt;'a, P&gt; Iterator for SplitTerminator&lt;'a, P&gt; where
Â Â Â Â P: Pattern&lt;'a&gt;,Â 
    type Item = &amp;'a str;
</pre></span></span></span></summary><div class="docblock">
<p>An iterator over substrings of the given string slice, separated by characters matched by a pattern.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <p>Equivalent to <a href="primitive.str#method.split"><code>split</code></a>, except that the trailing substring is skipped if empty.</p> <p>This method can be used for string data that is <em>terminated</em>, rather than <em>separated</em> by a pattern.</p> <h5 id="iterator-behavior-2">Iterator behavior</h5> <p>The returned iterator will be a <a href="iter/trait.doubleendediterator" title="DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., <a href="primitive.char"><code>char</code></a>, but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="primitive.str#method.rsplit_terminator"><code>rsplit_terminator</code></a> method can be used.</p> <h5 id="examples-31">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "A.B.".split_terminator('.').collect();
assert_eq!(v, ["A", "B"]);

let v: Vec&lt;&amp;str&gt; = "A..B..".split_terminator(".").collect();
assert_eq!(v, ["A", "", "B", ""]);

let v: Vec&lt;&amp;str&gt; = "A.B:C.D".split_terminator(&amp;['.', ':'][..]).collect();
assert_eq!(v, ["A", "B", "C", "D"]);</pre></div> </div>
<summary><section id="method.rsplit_terminator" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1517-1519">source</a></span><h4 class="code-header">pub fn rsplit_terminator&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; RSplitTerminator&lt;'a, P&gt; <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br> &lt;P as <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span>
</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.rsplitterminator" title="struct std::str::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt;</span><pre class="content">impl&lt;'a, P&gt; Iterator for RSplitTerminator&lt;'a, P&gt; where
Â Â Â Â P: Pattern&lt;'a&gt;,
Â Â Â Â &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: ReverseSearcher&lt;'a&gt;,Â 
    type Item = &amp;'a str;
</pre></span></span></span></summary><div class="docblock">
<p>An iterator over substrings of <code>self</code>, separated by characters matched by a pattern and yielded in reverse order.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <p>Equivalent to <a href="primitive.str#method.split"><code>split</code></a>, except that the trailing substring is skipped if empty.</p> <p>This method can be used for string data that is <em>terminated</em>, rather than <em>separated</em> by a pattern.</p> <h5 id="iterator-behavior-3">Iterator behavior</h5> <p>The returned iterator requires that the pattern supports a reverse search, and it will be double ended if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="primitive.str#method.split_terminator"><code>split_terminator</code></a> method can be used.</p> <h5 id="examples-32">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "A.B.".rsplit_terminator('.').collect();
assert_eq!(v, ["B", "A"]);

let v: Vec&lt;&amp;str&gt; = "A..B..".rsplit_terminator(".").collect();
assert_eq!(v, ["", "B", "", "A"]);

let v: Vec&lt;&amp;str&gt; = "A.B:C.D".rsplit_terminator(&amp;['.', ':'][..]).collect();
assert_eq!(v, ["D", "C", "B", "A"]);</pre></div> </div>
<summary><section id="method.splitn" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1572">source</a></span><h4 class="code-header">pub fn splitn&lt;'a, P&gt;(&amp;'a self, n: usize, pat: P) -&gt; SplitN&lt;'a, P&gt; <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span>
</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.splitn" title="struct std::str::SplitN">SplitN</a>&lt;'a, P&gt;</span><pre class="content">impl&lt;'a, P&gt; Iterator for SplitN&lt;'a, P&gt; where
Â Â Â Â P: Pattern&lt;'a&gt;,Â 
    type Item = &amp;'a str;
</pre></span></span></span></summary><div class="docblock">
<p>An iterator over substrings of the given string slice, separated by a pattern, restricted to returning at most <code>n</code> items.</p> <p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring) will contain the remainder of the string.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior-4">Iterator behavior</h5> <p>The returned iterator will not be double ended, because it is not efficient to support.</p> <p>If the pattern allows a reverse search, the <a href="primitive.str#method.rsplitn"><code>rsplitn</code></a> method can be used.</p> <h5 id="examples-33">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "Mary had a little lambda".splitn(3, ' ').collect();
assert_eq!(v, ["Mary", "had", "a little lambda"]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".splitn(3, "X").collect();
assert_eq!(v, ["lion", "", "tigerXleopard"]);

let v: Vec&lt;&amp;str&gt; = "abcXdef".splitn(1, 'X').collect();
assert_eq!(v, ["abcXdef"]);

let v: Vec&lt;&amp;str&gt; = "".splitn(1, 'X').collect();
assert_eq!(v, [""]);</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "abc1defXghi".splitn(2, |c| c == '1' || c == 'X').collect();
assert_eq!(v, ["abc", "defXghi"]);</pre></div> </div>
<summary><section id="method.rsplitn" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1621-1623">source</a></span><h4 class="code-header">pub fn rsplitn&lt;'a, P&gt;(&amp;'a self, n: usize, pat: P) -&gt; RSplitN&lt;'a, P&gt; <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br> &lt;P as <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span>
</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.rsplitn" title="struct std::str::RSplitN">RSplitN</a>&lt;'a, P&gt;</span><pre class="content">impl&lt;'a, P&gt; Iterator for RSplitN&lt;'a, P&gt; where
Â Â Â Â P: Pattern&lt;'a&gt;,
Â Â Â Â &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: ReverseSearcher&lt;'a&gt;,Â 
    type Item = &amp;'a str;
</pre></span></span></span></summary><div class="docblock">
<p>An iterator over substrings of this string slice, separated by a pattern, starting from the end of the string, restricted to returning at most <code>n</code> items.</p> <p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring) will contain the remainder of the string.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior-5">Iterator behavior</h5> <p>The returned iterator will not be double ended, because it is not efficient to support.</p> <p>For splitting from the front, the <a href="primitive.str#method.splitn"><code>splitn</code></a> method can be used.</p> <h5 id="examples-34">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb".rsplitn(3, ' ').collect();
assert_eq!(v, ["lamb", "little", "Mary had a"]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".rsplitn(3, 'X').collect();
assert_eq!(v, ["leopard", "tiger", "lionX"]);

let v: Vec&lt;&amp;str&gt; = "lion::tiger::leopard".rsplitn(2, "::").collect();
assert_eq!(v, ["leopard", "lion::tiger"]);</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "abc1defXghi".rsplitn(2, |c| c == '1' || c == 'X').collect();
assert_eq!(v, ["ghi", "abc1def"]);</pre></div> </div>
<summary><section id="method.split_once" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1640">source</a><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span> Â· </span><h4 class="code-header">pub fn split_once&lt;'a, P&gt;(&amp;'a self, delimiter: P) -&gt; Option&lt;(&amp;'a str, &amp;'a str)&gt; <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span>
</h4></section></summary><div class="docblock">
<p>Splits the string on the first occurrence of the specified delimiter and returns prefix before delimiter and suffix after delimiter.</p> <h5 id="examples-35">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("cfg".split_once('='), None);
assert_eq!("cfg=foo".split_once('='), Some(("cfg", "foo")));
assert_eq!("cfg=foo=bar".split_once('='), Some(("cfg", "foo=bar")));</pre></div> </div>
<summary><section id="method.rsplit_once" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1658-1660">source</a><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span> Â· </span><h4 class="code-header">pub fn rsplit_once&lt;'a, P&gt;(&amp;'a self, delimiter: P) -&gt; Option&lt;(&amp;'a str, &amp;'a str)&gt; <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br> &lt;P as <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span>
</h4></section></summary><div class="docblock">
<p>Splits the string on the last occurrence of the specified delimiter and returns prefix before delimiter and suffix after delimiter.</p> <h5 id="examples-36">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("cfg".rsplit_once('='), None);
assert_eq!("cfg=foo".rsplit_once('='), Some(("cfg", "foo")));
assert_eq!("cfg=foo=bar".rsplit_once('='), Some(("cfg=foo", "bar")));</pre></div> </div>
<summary><section id="method.matches" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1700">source</a><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· </span><h4 class="code-header">pub fn matches&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; Matches&lt;'a, P&gt; <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span>
</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.matches" title="struct std::str::Matches">Matches</a>&lt;'a, P&gt;</span><pre class="content">impl&lt;'a, P&gt; Iterator for Matches&lt;'a, P&gt; where
Â Â Â Â P: Pattern&lt;'a&gt;,Â 
    type Item = &amp;'a str;
</pre></span></span></span></summary><div class="docblock">
<p>An iterator over the disjoint matches of a pattern within the given string slice.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior-6">Iterator behavior</h5> <p>The returned iterator will be a <a href="iter/trait.doubleendediterator" title="DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., <a href="primitive.char"><code>char</code></a>, but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="primitive.str#method.matches"><code>rmatches</code></a> method can be used.</p> <h5 id="examples-37">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "abcXXXabcYYYabc".matches("abc").collect();
assert_eq!(v, ["abc", "abc", "abc"]);

let v: Vec&lt;&amp;str&gt; = "1abc2abc3".matches(char::is_numeric).collect();
assert_eq!(v, ["1", "2", "3"]);</pre></div> </div>
<summary><section id="method.rmatches" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1736-1738">source</a><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· </span><h4 class="code-header">pub fn rmatches&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; RMatches&lt;'a, P&gt; <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br> &lt;P as <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span>
</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.rmatches" title="struct std::str::RMatches">RMatches</a>&lt;'a, P&gt;</span><pre class="content">impl&lt;'a, P&gt; Iterator for RMatches&lt;'a, P&gt; where
Â Â Â Â P: Pattern&lt;'a&gt;,
Â Â Â Â &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: ReverseSearcher&lt;'a&gt;,Â 
    type Item = &amp;'a str;
</pre></span></span></span></summary><div class="docblock">
<p>An iterator over the disjoint matches of a pattern within this string slice, yielded in reverse order.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior-7">Iterator behavior</h5> <p>The returned iterator requires that the pattern supports a reverse search, and it will be a <a href="iter/trait.doubleendediterator" title="DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="primitive.str#method.matches"><code>matches</code></a> method can be used.</p> <h5 id="examples-38">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;&amp;str&gt; = "abcXXXabcYYYabc".rmatches("abc").collect();
assert_eq!(v, ["abc", "abc", "abc"]);

let v: Vec&lt;&amp;str&gt; = "1abc2abc3".rmatches(char::is_numeric).collect();
assert_eq!(v, ["3", "2", "1"]);</pre></div> </div>
<summary><section id="method.match_indices" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1782">source</a><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· </span><h4 class="code-header">pub fn match_indices&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; MatchIndices&lt;'a, P&gt; <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span>
</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.matchindices" title="struct std::str::MatchIndices">MatchIndices</a>&lt;'a, P&gt;</span><pre class="content">impl&lt;'a, P&gt; Iterator for MatchIndices&lt;'a, P&gt; where
Â Â Â Â P: Pattern&lt;'a&gt;,Â 
    type Item = (usize, &amp;'a str);
</pre></span></span></span></summary><div class="docblock">
<p>An iterator over the disjoint matches of a pattern within this string slice as well as the index that the match starts at.</p> <p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices corresponding to the first match are returned.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior-8">Iterator behavior</h5> <p>The returned iterator will be a <a href="iter/trait.doubleendediterator" title="DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., <a href="primitive.char"><code>char</code></a>, but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="primitive.str#method.rmatch_indices"><code>rmatch_indices</code></a> method can be used.</p> <h5 id="examples-39">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;_&gt; = "abcXXXabcYYYabc".match_indices("abc").collect();
assert_eq!(v, [(0, "abc"), (6, "abc"), (12, "abc")]);

let v: Vec&lt;_&gt; = "1abcabc2".match_indices("abc").collect();
assert_eq!(v, [(1, "abc"), (4, "abc")]);

let v: Vec&lt;_&gt; = "ababa".match_indices("aba").collect();
assert_eq!(v, [(0, "aba")]); // only the first `aba`</pre></div> </div>
<summary><section id="method.rmatch_indices" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1824-1826">source</a><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· </span><h4 class="code-header">pub fn rmatch_indices&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; RMatchIndices&lt;'a, P&gt; <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br> &lt;P as <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span>
</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.rmatchindices" title="struct std::str::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt;</span><pre class="content">impl&lt;'a, P&gt; Iterator for RMatchIndices&lt;'a, P&gt; where
Â Â Â Â P: Pattern&lt;'a&gt;,
Â Â Â Â &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: ReverseSearcher&lt;'a&gt;,Â 
    type Item = (usize, &amp;'a str);
</pre></span></span></span></summary><div class="docblock">
<p>An iterator over the disjoint matches of a pattern within <code>self</code>, yielded in reverse order along with the index of the match.</p> <p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices corresponding to the last match are returned.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="iterator-behavior-9">Iterator behavior</h5> <p>The returned iterator requires that the pattern supports a reverse search, and it will be a <a href="iter/trait.doubleendediterator" title="DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="primitive.str#method.match_indices"><code>match_indices</code></a> method can be used.</p> <h5 id="examples-40">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v: Vec&lt;_&gt; = "abcXXXabcYYYabc".rmatch_indices("abc").collect();
assert_eq!(v, [(12, "abc"), (6, "abc"), (0, "abc")]);

let v: Vec&lt;_&gt; = "1abcabc2".rmatch_indices("abc").collect();
assert_eq!(v, [(4, "abc"), (1, "abc")]);

let v: Vec&lt;_&gt; = "ababa".rmatch_indices("aba").collect();
assert_eq!(v, [(2, "aba")]); // only the last `aba`</pre></div> </div>
<summary><section id="method.trim" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1850">source</a></span><h4 class="code-header">pub fn trim(&amp;self) -&gt; &amp;str</h4></section></summary><div class="docblock">
<p>Returns a string slice with leading and trailing whitespace removed.</p> <p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>, which includes newlines.</p> <h5 id="examples-41">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "\n Hello\tworld\t\n";

assert_eq!("Hello\tworld", s.trim());</pre></div> </div>
<summary><section id="method.trim_start" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1889">source</a><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· </span><h4 class="code-header">pub fn trim_start(&amp;self) -&gt; &amp;str</h4></section></summary><div class="docblock">
<p>Returns a string slice with leading whitespace removed.</p> <p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>, which includes newlines.</p> <h5 id="text-directionality">Text directionality</h5> <p>A string is a sequence of bytes. <code>start</code> in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side.</p> <h5 id="examples-42">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "\n Hello\tworld\t\n";
assert_eq!("Hello\tworld\t\n", s.trim_start());</pre></div> <p>Directionality:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "  English  ";
assert!(Some('E') == s.trim_start().chars().next());

let s = "  ×¢×‘×¨×™×ª  ";
assert!(Some('×¢') == s.trim_start().chars().next());</pre></div> </div>
<summary><section id="method.trim_end" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1928">source</a><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· </span><h4 class="code-header">pub fn trim_end(&amp;self) -&gt; &amp;str</h4></section></summary><div class="docblock">
<p>Returns a string slice with trailing whitespace removed.</p> <p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>, which includes newlines.</p> <h5 id="text-directionality-1">Text directionality</h5> <p>A string is a sequence of bytes. <code>end</code> in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side.</p> <h5 id="examples-43">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "\n Hello\tworld\t\n";
assert_eq!("\n Hello\tworld", s.trim_end());</pre></div> <p>Directionality:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "  English  ";
assert!(Some('h') == s.trim_end().chars().rev().next());

let s = "  ×¢×‘×¨×™×ª  ";
assert!(Some('×ª') == s.trim_end().chars().rev().next());</pre></div> </div>
<summary><section id="method.trim_left" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#1968">source</a></span><h4 class="code-header">pub fn trim_left(&amp;self) -&gt; &amp;str</h4></section><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span> Deprecated since 1.33.0: <p>superseded by <code>trim_start</code></p> </div></span></summary><div class="docblock">
<p>Returns a string slice with leading whitespace removed.</p> <p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>.</p> <h5 id="text-directionality-2">Text directionality</h5> <p>A string is a sequence of bytes. â€˜Leftâ€™ in this context means the first position of that byte string; for a language like Arabic or Hebrew which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be the <em>right</em> side, not the left.</p> <h5 id="examples-44">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = " Hello\tworld\t";

assert_eq!("Hello\tworld\t", s.trim_left());</pre></div> <p>Directionality:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "  English";
assert!(Some('E') == s.trim_left().chars().next());

let s = "  ×¢×‘×¨×™×ª";
assert!(Some('×¢') == s.trim_left().chars().next());</pre></div> </div>
<summary><section id="method.trim_right" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2008">source</a></span><h4 class="code-header">pub fn trim_right(&amp;self) -&gt; &amp;str</h4></section><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span> Deprecated since 1.33.0: <p>superseded by <code>trim_end</code></p> </div></span></summary><div class="docblock">
<p>Returns a string slice with trailing whitespace removed.</p> <p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>.</p> <h5 id="text-directionality-3">Text directionality</h5> <p>A string is a sequence of bytes. â€˜Rightâ€™ in this context means the last position of that byte string; for a language like Arabic or Hebrew which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be the <em>left</em> side, not the right.</p> <h5 id="examples-45">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = " Hello\tworld\t";

assert_eq!(" Hello\tworld", s.trim_right());</pre></div> <p>Directionality:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "English  ";
assert!(Some('h') == s.trim_right().chars().rev().next());

let s = "×¢×‘×¨×™×ª  ";
assert!(Some('×ª') == s.trim_right().chars().rev().next());</pre></div> </div>
<summary><section id="method.trim_matches" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2041-2043">source</a></span><h4 class="code-header">pub fn trim_matches&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a str <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br> &lt;P as <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.doubleendedsearcher" title="trait std::str::pattern::DoubleEndedSearcher">DoubleEndedSearcher</a>&lt;'a&gt;, </span>
</h4></section></summary><div class="docblock">
<p>Returns a string slice with all prefixes and suffixes that match a pattern repeatedly removed.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-46">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("11foo1bar11".trim_matches('1'), "foo1bar");
assert_eq!("123foo1bar123".trim_matches(char::is_numeric), "foo1bar");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_matches(x), "foo1bar");</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("1foo1barXX".trim_matches(|c| c == '1' || c == 'X'), "foo1bar");</pre></div> </div>
<summary><section id="method.trim_start_matches" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2090">source</a><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· </span><h4 class="code-header">pub fn trim_start_matches&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a str <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span>
</h4></section></summary><div class="docblock">
<p>Returns a string slice with all prefixes that match a pattern repeatedly removed.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="text-directionality-4">Text directionality</h5> <p>A string is a sequence of bytes. <code>start</code> in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side.</p> <h5 id="examples-47">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("11foo1bar11".trim_start_matches('1'), "foo1bar11");
assert_eq!("123foo1bar123".trim_start_matches(char::is_numeric), "foo1bar123");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_start_matches(x), "foo1bar12");</pre></div> </div>
<summary><section id="method.strip_prefix" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2123">source</a><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span> Â· </span><h4 class="code-header">pub fn strip_prefix&lt;'a, P&gt;(&amp;'a self, prefix: P) -&gt; Option&lt;&amp;'a str&gt; <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span>
</h4></section></summary><div class="docblock">
<p>Returns a string slice with the prefix removed.</p> <p>If the string starts with the pattern <code>prefix</code>, returns substring after the prefix, wrapped in <code>Some</code>. Unlike <code>trim_start_matches</code>, this method removes the prefix exactly once.</p> <p>If the string does not start with <code>prefix</code>, returns <code>None</code>.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-48">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("foo:bar".strip_prefix("foo:"), Some("bar"));
assert_eq!("foo:bar".strip_prefix("bar"), None);
assert_eq!("foofoo".strip_prefix("foo"), Some("foo"));</pre></div> </div>
<summary><section id="method.strip_suffix" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2150-2153">source</a><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span> Â· </span><h4 class="code-header">pub fn strip_suffix&lt;'a, P&gt;(&amp;'a self, suffix: P) -&gt; Option&lt;&amp;'a str&gt; <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br> &lt;P as <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span>
</h4></section></summary><div class="docblock">
<p>Returns a string slice with the suffix removed.</p> <p>If the string ends with the pattern <code>suffix</code>, returns the substring before the suffix, wrapped in <code>Some</code>. Unlike <code>trim_end_matches</code>, this method removes the suffix exactly once.</p> <p>If the string does not end with <code>suffix</code>, returns <code>None</code>.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="examples-49">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("bar:foo".strip_suffix(":foo"), Some("bar"));
assert_eq!("bar:foo".strip_suffix("bar"), None);
assert_eq!("foofoo".strip_suffix("foo"), Some("foo"));</pre></div> </div>
<summary><section id="method.trim_end_matches" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2194-2196">source</a><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· </span><h4 class="code-header">pub fn trim_end_matches&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a str <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br> &lt;P as <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span>
</h4></section></summary><div class="docblock">
<p>Returns a string slice with all suffixes that match a pattern repeatedly removed.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="text-directionality-5">Text directionality</h5> <p>A string is a sequence of bytes. <code>end</code> in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side.</p> <h5 id="examples-50">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("11foo1bar11".trim_end_matches('1'), "11foo1bar");
assert_eq!("123foo1bar123".trim_end_matches(char::is_numeric), "123foo1bar");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_end_matches(x), "12foo1bar");</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("1fooX".trim_end_matches(|c| c == '1' || c == 'X'), "1foo");</pre></div> </div>
<summary><section id="method.trim_left_matches" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2240">source</a></span><h4 class="code-header">pub fn trim_left_matches&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a str <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span>
</h4></section><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span> Deprecated since 1.33.0: <p>superseded by <code>trim_start_matches</code></p> </div></span></summary><div class="docblock">
<p>Returns a string slice with all prefixes that match a pattern repeatedly removed.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="text-directionality-6">Text directionality</h5> <p>A string is a sequence of bytes. â€˜Leftâ€™ in this context means the first position of that byte string; for a language like Arabic or Hebrew which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be the <em>right</em> side, not the left.</p> <h5 id="examples-51">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("11foo1bar11".trim_left_matches('1'), "foo1bar11");
assert_eq!("123foo1bar123".trim_left_matches(char::is_numeric), "foo1bar123");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_left_matches(x), "foo1bar12");</pre></div> </div>
<summary><section id="method.trim_right_matches" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2283-2285">source</a></span><h4 class="code-header">pub fn trim_right_matches&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a str <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br> &lt;P as <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span>
</h4></section><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span> Deprecated since 1.33.0: <p>superseded by <code>trim_end_matches</code></p> </div></span></summary><div class="docblock">
<p>Returns a string slice with all suffixes that match a pattern repeatedly removed.</p> <p>The <a href="str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char"><code>char</code></a>, a slice of <a href="primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h5 id="text-directionality-7">Text directionality</h5> <p>A string is a sequence of bytes. â€˜Rightâ€™ in this context means the last position of that byte string; for a language like Arabic or Hebrew which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be the <em>left</em> side, not the right.</p> <h5 id="examples-52">Examples</h5> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("11foo1bar11".trim_right_matches('1'), "11foo1bar");
assert_eq!("123foo1bar123".trim_right_matches(char::is_numeric), "123foo1bar");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_right_matches(x), "12foo1bar");</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("1fooX".trim_right_matches(|c| c == '1' || c == 'X'), "1foo");</pre></div> </div>
<summary><section id="method.parse" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2335">source</a></span><h4 class="code-header">pub fn parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, &lt;F as FromStr&gt;::Err&gt; <span class="where fmt-newline">where<br> F: <a class="trait" href="str/trait.fromstr" title="trait std::str::FromStr">FromStr</a>, </span>
</h4></section></summary><div class="docblock">
<p>Parses this string slice into another type.</p> <p>Because <code>parse</code> is so general, it can cause problems with type inference. As such, <code>parse</code> is one of the few times youâ€™ll see the syntax affectionately known as the â€˜turbofishâ€™: <code>::&lt;&gt;</code>. This helps the inference algorithm understand specifically which type youâ€™re trying to parse into.</p> <p><code>parse</code> can parse into any type that implements the <a href="str/trait.fromstr" title="FromStr"><code>FromStr</code></a> trait.</p> <h5 id="errors">Errors</h5> <p>Will return <a href="str/trait.fromstr#associatedtype.Err"><code>Err</code></a> if itâ€™s not possible to parse this string slice into the desired type.</p> <h5 id="examples-53">Examples</h5> <p>Basic usage</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let four: u32 = "4".parse().unwrap();

assert_eq!(4, four);</pre></div> <p>Using the â€˜turbofishâ€™ instead of annotating <code>four</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let four = "4".parse::&lt;u32&gt;();

assert_eq!(Ok(4), four);</pre></div> <p>Failing to parse:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let nope = "j".parse::&lt;u32&gt;();

assert!(nope.is_err());</pre></div> </div>
<summary><section id="method.is_ascii" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2353">source</a><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· </span><h4 class="code-header">pub fn is_ascii(&amp;self) -&gt; bool</h4></section></summary><div class="docblock">
<p>Checks if all characters in this string are within the ASCII range.</p> <h5 id="examples-54">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let ascii = "hello!\n";
let non_ascii = "GrÃ¼ÃŸe, JÃ¼rgen â¤";

assert!(ascii.is_ascii());
assert!(!non_ascii.is_ascii());</pre></div> </div>
<summary><section id="method.eq_ignore_ascii_case" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2375">source</a><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· </span><h4 class="code-header">pub fn eq_ignore_ascii_case(&amp;self, other: &amp;str) -&gt; bool</h4></section></summary><div class="docblock">
<p>Checks that two strings are an ASCII case-insensitive match.</p> <p>Same as <code>to_ascii_lowercase(a) == to_ascii_lowercase(b)</code>, but without allocating and copying temporaries.</p> <h5 id="examples-55">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert!("Ferris".eq_ignore_ascii_case("FERRIS"));
assert!("FerrÃ¶s".eq_ignore_ascii_case("FERRÃ¶S"));
assert!(!"FerrÃ¶s".eq_ignore_ascii_case("FERRÃ–S"));</pre></div> </div>
<summary><section id="method.make_ascii_uppercase" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2400">source</a><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· </span><h4 class="code-header">pub fn make_ascii_uppercase(&amp;mut self)</h4></section></summary><div class="docblock">
<p>Converts this string to its ASCII upper case equivalent in-place.</p> <p>ASCII letters â€˜aâ€™ to â€˜zâ€™ are mapped to â€˜Aâ€™ to â€˜Zâ€™, but non-ASCII letters are unchanged.</p> <p>To return a new uppercased value without modifying the existing one, use <a href="#method.to_ascii_uppercase"><code>to_ascii_uppercase()</code></a>.</p> <h5 id="examples-56">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut s = String::from("GrÃ¼ÃŸe, JÃ¼rgen â¤");

s.make_ascii_uppercase();

assert_eq!("GRÃ¼ÃŸE, JÃ¼RGEN â¤", s);</pre></div> </div>
<summary><section id="method.make_ascii_lowercase" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2427">source</a><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· </span><h4 class="code-header">pub fn make_ascii_lowercase(&amp;mut self)</h4></section></summary><div class="docblock">
<p>Converts this string to its ASCII lower case equivalent in-place.</p> <p>ASCII letters â€˜Aâ€™ to â€˜Zâ€™ are mapped to â€˜aâ€™ to â€˜zâ€™, but non-ASCII letters are unchanged.</p> <p>To return a new lowercased value without modifying the existing one, use <a href="#method.to_ascii_lowercase"><code>to_ascii_lowercase()</code></a>.</p> <h5 id="examples-57">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut s = String::from("GRÃœÃŸE, JÃœRGEN â¤");

s.make_ascii_lowercase();

assert_eq!("grÃœÃŸe, jÃœrgen â¤", s);</pre></div> </div>
<summary><section id="method.escape_debug" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2470">source</a><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· </span><h4 class="code-header">pub fn escape_debug(&amp;self) -&gt; EscapeDebug&lt;'_&gt;</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.escapedebug" title="struct std::str::EscapeDebug">EscapeDebug</a>&lt;'a&gt;</span><pre class="content">impl&lt;'a&gt; Iterator for EscapeDebug&lt;'a&gt;
    type Item = char;
</pre></span></span></span></summary><div class="docblock">
<p>Return an iterator that escapes each char in <code>self</code> with <a href="primitive.char#method.escape_debug" title="char::escape_debug"><code>char::escape_debug</code></a>.</p> <p>Note: only extended grapheme codepoints that begin the string will be escaped.</p> <h5 id="examples-58">Examples</h5> <p>As an iterator:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">for c in "â¤\n!".escape_debug() {
    print!("{c}");
}
println!();</pre></div> <p>Using <code>println!</code> directly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">println!("{}", "â¤\n!".escape_debug());</pre></div> <p>Both are equivalent to:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">println!("â¤\\n!");</pre></div> <p>Using <code>to_string</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("â¤\n!".escape_debug().to_string(), "â¤\\n!");</pre></div> </div>
<summary><section id="method.escape_default" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2516">source</a><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· </span><h4 class="code-header">pub fn escape_default(&amp;self) -&gt; EscapeDefault&lt;'_&gt;</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.escapedefault" title="struct std::str::EscapeDefault">EscapeDefault</a>&lt;'a&gt;</span><pre class="content">impl&lt;'a&gt; Iterator for EscapeDefault&lt;'a&gt;
    type Item = char;
</pre></span></span></span></summary><div class="docblock">
<p>Return an iterator that escapes each char in <code>self</code> with <a href="primitive.char#method.escape_default" title="char::escape_default"><code>char::escape_default</code></a>.</p> <h5 id="examples-59">Examples</h5> <p>As an iterator:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">for c in "â¤\n!".escape_default() {
    print!("{c}");
}
println!();</pre></div> <p>Using <code>println!</code> directly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">println!("{}", "â¤\n!".escape_default());</pre></div> <p>Both are equivalent to:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">println!("\\u{{2764}}\\n!");</pre></div> <p>Using <code>to_string</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("â¤\n!".escape_default().to_string(), "\\u{2764}\\n!");</pre></div> </div>
<summary><section id="method.escape_unicode" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2554">source</a><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· </span><h4 class="code-header">pub fn escape_unicode(&amp;self) -&gt; EscapeUnicode&lt;'_&gt;</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="str/struct.escapeunicode" title="struct std::str::EscapeUnicode">EscapeUnicode</a>&lt;'a&gt;</span><pre class="content">impl&lt;'a&gt; Iterator for EscapeUnicode&lt;'a&gt;
    type Item = char;
</pre></span></span></span></summary><div class="docblock">
<p>Return an iterator that escapes each char in <code>self</code> with <a href="primitive.char#method.escape_unicode" title="char::escape_unicode"><code>char::escape_unicode</code></a>.</p> <h5 id="examples-60">Examples</h5> <p>As an iterator:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">for c in "â¤\n!".escape_unicode() {
    print!("{c}");
}
println!();</pre></div> <p>Using <code>println!</code> directly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">println!("{}", "â¤\n!".escape_unicode());</pre></div> <p>Both are equivalent to:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">println!("\\u{{2764}}\\u{{a}}\\u{{21}}");</pre></div> <p>Using <code>to_string</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("â¤\n!".escape_unicode().to_string(), "\\u{2764}\\u{a}\\u{21}");</pre></div> </div>
</div>
<summary><section id="impl-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#239-601">source</a></span><h3 class="code-header in-band">impl str</h3></section></summary><div class="docblock">
<p>Methods for string slices.</p> </div>
<div class="impl-items">
<summary><section id="method.into_boxed_bytes" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#256">source</a><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· </span><h4 class="code-header">pub fn into_boxed_bytes(self: Box&lt;str, Global&gt;) -&gt; Box&lt;[u8], Global&gt;</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="boxed/struct.box" title="struct std::boxed::Box">Box</a>&lt;I, A&gt;</span><pre class="content">impl&lt;I, A&gt; Iterator for Box&lt;I, A&gt; where
Â Â Â Â I: Iterator + ?Sized,
Â Â Â Â A: Allocator,Â 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;F, A&gt; Future for Box&lt;F, A&gt; where
Â Â Â Â F: Future + Unpin + ?Sized,
Â Â Â Â A: Allocator + 'static,Â 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;R:Â Read + ?Sized&gt; Read for Box&lt;R&gt;
impl&lt;W:Â Write + ?Sized&gt; Write for Box&lt;W&gt;
</pre></span></span></span></summary><div class="docblock">
<p>Converts a <code>Box&lt;str&gt;</code> into a <code>Box&lt;[u8]&gt;</code> without copying or allocating.</p> <h5 id="examples-61">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "this is a string";
let boxed_str = s.to_owned().into_boxed_str();
let boxed_bytes = boxed_str.into_boxed_bytes();
assert_eq!(*boxed_bytes, *s.as_bytes());</pre></div> </div>
<summary><section id="method.replace" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#288">source</a></span><h4 class="code-header">pub fn replace&lt;'a, P&gt;(&amp;'a self, from: P, to: &amp;str) -&gt; String <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span>
</h4></section></summary><div class="docblock">
<p>Replaces all matches of a pattern with another string.</p> <p><code>replace</code> creates a new <a href="string/struct.string" title="String"><code>String</code></a>, and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice.</p> <h5 id="examples-62">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "this is old";

assert_eq!("this is new", s.replace("old", "new"));</pre></div> <p>When the pattern doesnâ€™t match:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "this is old";
assert_eq!(s, s.replace("cookie monster", "little lamb"));</pre></div> </div>
<summary><section id="method.replacen" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#328">source</a><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span> Â· </span><h4 class="code-header">pub fn replacen&lt;'a, P&gt;(&amp;'a self, pat: P, to: &amp;str, count: usize) -&gt; String <span class="where fmt-newline">where<br> P: <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span>
</h4></section></summary><div class="docblock">
<p>Replaces first N matches of a pattern with another string.</p> <p><code>replacen</code> creates a new <a href="string/struct.string" title="String"><code>String</code></a>, and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice at most <code>count</code> times.</p> <h5 id="examples-63">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "foo foo 123 foo";
assert_eq!("new new 123 foo", s.replacen("foo", "new", 2));
assert_eq!("faa fao 123 foo", s.replacen('o', "a", 3));
assert_eq!("foo foo new23 foo", s.replacen(char::is_numeric, "new", 1));</pre></div> <p>When the pattern doesnâ€™t match:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "this is old";
assert_eq!(s, s.replacen("cookie monster", "little lamb", 10));</pre></div> </div>
<summary><section id="method.to_lowercase" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#385">source</a><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· </span><h4 class="code-header">pub fn to_lowercase(&amp;self) -&gt; String</h4></section></summary><div class="docblock">
<p>Returns the lowercase equivalent of this string slice, as a new <a href="string/struct.string" title="String"><code>String</code></a>.</p> <p>â€˜Lowercaseâ€™ is defined according to the terms of the Unicode Derived Core Property <code>Lowercase</code>.</p> <p>Since some characters can expand into multiple characters when changing the case, this function returns a <a href="string/struct.string" title="String"><code>String</code></a> instead of modifying the parameter in-place.</p> <h5 id="examples-64">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "HELLO";

assert_eq!("hello", s.to_lowercase());</pre></div> <p>A tricky example, with sigma:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let sigma = "Î£";

assert_eq!("Ïƒ", sigma.to_lowercase());

// but at the end of a word, it's Ï‚, not Ïƒ:
let odysseus = "á½ˆÎ”Î¥Î£Î£Î•ÎÎ£";

assert_eq!("á½€Î´Ï…ÏƒÏƒÎµÏÏ‚", odysseus.to_lowercase());</pre></div> <p>Languages without case are not changed:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let new_year = "å†œå†æ–°å¹´";

assert_eq!(new_year, new_year.to_lowercase());</pre></div> </div>
<summary><section id="method.to_uppercase" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#468">source</a><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· </span><h4 class="code-header">pub fn to_uppercase(&amp;self) -&gt; String</h4></section></summary><div class="docblock">
<p>Returns the uppercase equivalent of this string slice, as a new <a href="string/struct.string" title="String"><code>String</code></a>.</p> <p>â€˜Uppercaseâ€™ is defined according to the terms of the Unicode Derived Core Property <code>Uppercase</code>.</p> <p>Since some characters can expand into multiple characters when changing the case, this function returns a <a href="string/struct.string" title="String"><code>String</code></a> instead of modifying the parameter in-place.</p> <h5 id="examples-65">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "hello";

assert_eq!("HELLO", s.to_uppercase());</pre></div> <p>Scripts without case are not changed:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let new_year = "å†œå†æ–°å¹´";

assert_eq!(new_year, new_year.to_uppercase());</pre></div> <p>One character can become multiple:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "tschÃ¼ÃŸ";

assert_eq!("TSCHÃœSS", s.to_uppercase());</pre></div> </div>
<summary><section id="method.into_string" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#503">source</a><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span> Â· </span><h4 class="code-header">pub fn into_string(self: Box&lt;str, Global&gt;) -&gt; String</h4></section></summary><div class="docblock">
<p>Converts a <a href="boxed/struct.box" title="Box&lt;str&gt;"><code>Box&lt;str&gt;</code></a> into a <a href="string/struct.string" title="String"><code>String</code></a> without copying or allocating.</p> <h5 id="examples-66">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let string = String::from("birthday gift");
let boxed_str = string.clone().into_boxed_str();

assert_eq!(boxed_str.into_string(), string);</pre></div> </div>
<summary><section id="method.repeat" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#532">source</a><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span> Â· </span><h4 class="code-header">pub fn repeat(&amp;self, n: usize) -&gt; String</h4></section></summary><div class="docblock">
<p>Creates a new <a href="string/struct.string" title="String"><code>String</code></a> by repeating a string <code>n</code> times.</p> <h5 id="panics-3">Panics</h5> <p>This function will panic if the capacity would overflow.</p> <h5 id="examples-67">Examples</h5> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("abc".repeat(4), String::from("abcabcabcabc"));</pre></div> <p>A panic upon overflow:</p> <div class="information">â“˜ This example panics</div>
<div class="example-wrap"><pre class="rust rust-example-rendered should_panic" data-language="rust">// this will panic at runtime
let huge = "0123456789abcdef".repeat(usize::MAX);</pre></div> </div>
<summary><section id="method.to_ascii_uppercase" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#562">source</a><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· </span><h4 class="code-header">pub fn to_ascii_uppercase(&amp;self) -&gt; String</h4></section></summary><div class="docblock">
<p>Returns a copy of this string where each character is mapped to its ASCII upper case equivalent.</p> <p>ASCII letters â€˜aâ€™ to â€˜zâ€™ are mapped to â€˜Aâ€™ to â€˜Zâ€™, but non-ASCII letters are unchanged.</p> <p>To uppercase the value in-place, use <a href="primitive.str#method.make_ascii_uppercase"><code>make_ascii_uppercase</code></a>.</p> <p>To uppercase ASCII characters in addition to non-ASCII characters, use <a href="#method.to_uppercase"><code>to_uppercase</code></a>.</p> <h5 id="examples-68">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "GrÃ¼ÃŸe, JÃ¼rgen â¤";

assert_eq!("GRÃ¼ÃŸE, JÃ¼RGEN â¤", s.to_ascii_uppercase());</pre></div> </div>
<summary><section id="method.to_ascii_lowercase" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#595">source</a><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· </span><h4 class="code-header">pub fn to_ascii_lowercase(&amp;self) -&gt; String</h4></section></summary><div class="docblock">
<p>Returns a copy of this string where each character is mapped to its ASCII lower case equivalent.</p> <p>ASCII letters â€˜Aâ€™ to â€˜Zâ€™ are mapped to â€˜aâ€™ to â€˜zâ€™, but non-ASCII letters are unchanged.</p> <p>To lowercase the value in-place, use <a href="primitive.str#method.make_ascii_lowercase"><code>make_ascii_lowercase</code></a>.</p> <p>To lowercase ASCII characters in addition to non-ASCII characters, use <a href="#method.to_lowercase"><code>to_lowercase</code></a>.</p> <h5 id="examples-69">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "GrÃ¼ÃŸe, JÃ¼rgen â¤";

assert_eq!("grÃ¼ÃŸe, jÃ¼rgen â¤", s.to_ascii_lowercase());</pre></div> </div>
</div>
</div>
<h2 id="trait-implementations" class="small-section-header">Trait Implementations</h2>
<div id="trait-implementations-list">
<summary><section id="impl-Add%3C%26%27_%20str%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2278-2286">source</a></span><h3 class="code-header in-band">impl&lt;'_&gt; Add&lt;&amp;'_ str&gt; for String</h3></section></summary><div class="docblock">
<p>Implements the <code>+</code> operator for concatenating two strings.</p> <p>This consumes the <code>String</code> on the left-hand side and re-uses its buffer (growing it if necessary). This is done to avoid allocating a new <code>String</code> and copying the entire contents on every operation, which would lead to <em>O</em>(<em>n</em>^2) running time when building an <em>n</em>-byte string by repeated concatenation.</p> <p>The string on the right-hand side is only borrowed; its contents are copied into the returned <code>String</code>.</p> <h4 id="examples-72">Examples</h4> <p>Concatenating two <code>String</code>s takes the first by value and borrows the second:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = String::from("hello");
let b = String::from(" world");
let c = a + &amp;b;
// `a` is moved and can no longer be used here.</pre></div> <p>If you want to keep using the first <code>String</code>, you can clone it and append to the clone instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = String::from("hello");
let b = String::from(" world");
let c = a.clone() + &amp;b;
// `a` is still valid here.</pre></div> <p>Concatenating <code>&amp;str</code> slices can be done by converting the first to a <code>String</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let a = "hello";
let b = " world";
let c = a.to_string() + b;</pre></div> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-9" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Output = String</h4></section></summary><div class="docblock">
<p>The resulting type after applying the <code>+</code> operator.</p> </div>
<summary><section id="method.add-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2282">source</a></span><h4 class="code-header">fn add(self, other: &amp;str) -&gt; String</h4></section></summary><div class="docblock">
<p>Performs the <code>+</code> operation. <a href="ops/trait.add#tymethod.add">Read more</a></p> </div>
</div>
<summary><section id="impl-Add%3C%26%27a%20str%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#442-450">source</a><span class="since" title="Stable since Rust version 1.14.0">1.14.0</span> Â· </span><h3 class="code-header in-band">impl&lt;'a&gt; Add&lt;&amp;'a str&gt; for Cow&lt;'a, str&gt;</h3></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-8" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Output = Cow&lt;'a, str&gt;</h4></section></summary><div class="docblock">
<p>The resulting type after applying the <code>+</code> operator.</p> </div>
<summary><section id="method.add" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#446">source</a></span><h4 class="code-header">fn add(self, rhs: &amp;'a str) -&gt; &lt;Cow&lt;'a, str&gt; as Add&lt;&amp;'a str&gt;&gt;::Output</h4></section></summary><div class="docblock">
<p>Performs the <code>+</code> operation. <a href="ops/trait.add#tymethod.add">Read more</a></p> </div>
</div>
<summary><section id="impl-AddAssign%3C%26%27_%20str%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2293-2298">source</a><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span> Â· </span><h3 class="code-header in-band">impl&lt;'_&gt; AddAssign&lt;&amp;'_ str&gt; for String</h3></section></summary><div class="docblock">
<p>Implements the <code>+=</code> operator for appending to a <code>String</code>.</p> <p>This has the same behavior as the <a href="string/struct.string#method.push_str" title="String::push_str"><code>push_str</code></a> method.</p> </div>
<div class="impl-items">
<summary><section id="method.add_assign-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2295">source</a></span><h4 class="code-header">fn add_assign(&amp;mut self, other: &amp;str)</h4></section></summary><div class="docblock">
<p>Performs the <code>+=</code> operation. <a href="ops/trait.addassign#tymethod.add_assign">Read more</a></p> </div>
</div>
<summary><section id="impl-AddAssign%3C%26%27a%20str%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#466-479">source</a><span class="since" title="Stable since Rust version 1.14.0">1.14.0</span> Â· </span><h3 class="code-header in-band">impl&lt;'a&gt; AddAssign&lt;&amp;'a str&gt; for Cow&lt;'a, str&gt;</h3></section></summary><div class="impl-items">
<summary><section id="method.add_assign" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#467">source</a></span><h4 class="code-header">fn add_assign(&amp;mut self, rhs: &amp;'a str)</h4></section></summary><div class="docblock">
<p>Performs the <code>+=</code> operation. <a href="ops/trait.addassign#tymethod.add_assign">Read more</a></p> </div>
</div>
<summary><section id="impl-AsMut%3Cstr%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#636-641">source</a><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span> Â· </span><h3 class="code-header in-band">impl AsMut&lt;str&gt; for str</h3></section></summary><div class="impl-items">
<summary><section id="method.as_mut" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#638">source</a></span><h4 class="code-header">fn as_mut(&amp;mut self) -&gt; &amp;mut str</h4></section></summary><div class="docblock">
<p>Converts this type into a mutable reference of the (usually inferred) input type.</p> </div>
</div>
<summary><section id="impl-AsMut%3Cstr%3E-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2574-2579">source</a><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span> Â· </span><h3 class="code-header in-band">impl AsMut&lt;str&gt; for String</h3></section></summary><div class="impl-items">
<summary><section id="method.as_mut-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2576">source</a></span><h4 class="code-header">fn as_mut(&amp;mut self) -&gt; &amp;mut str</h4></section></summary><div class="docblock">
<p>Converts this type into a mutable reference of the (usually inferred) input type.</p> </div>
</div>
<summary><section id="impl-AsRef%3C%5Bu8%5D%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2560-2565">source</a></span><h3 class="code-header in-band">impl AsRef&lt;[u8]&gt; for str</h3></section></summary><div class="impl-items">
<summary><section id="method.as_ref" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2562">source</a></span><h4 class="code-header">fn as_ref(&amp;self) -&gt; &amp;[u8]</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="primitive" href="primitive.slice">&amp;[</a><a class="primitive" href="primitive.u8">u8</a><a class="primitive" href="primitive.slice">]</a></span><pre class="content">impl Read for &amp;[u8]
impl Write for &amp;mut [u8]
</pre></span></span></span></summary><div class="docblock">
<p>Converts this type into a shared reference of the (usually inferred) input type.</p> </div>
</div>
<summary><section id="impl-AsRef%3COsStr%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1263-1268">source</a></span><h3 class="code-header in-band">impl AsRef&lt;OsStr&gt; for str</h3></section></summary><div class="impl-items">
<summary><section id="method.as_ref-4" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1265-1267">source</a></span><h4 class="code-header">fn as_ref(&amp;self) -&gt; &amp;OsStr</h4></section></summary><div class="docblock">
<p>Converts this type into a shared reference of the (usually inferred) input type.</p> </div>
</div>
<summary><section id="impl-AsRef%3CPath%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/path.rs.html#3028-3033">source</a></span><h3 class="code-header in-band">impl AsRef&lt;Path&gt; for str</h3></section></summary><div class="impl-items">
<summary><section id="method.as_ref-5" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/path.rs.html#3030-3032">source</a></span><h4 class="code-header">fn as_ref(&amp;self) -&gt; &amp;Path</h4></section></summary><div class="docblock">
<p>Converts this type into a shared reference of the (usually inferred) input type.</p> </div>
</div>
<summary><section id="impl-AsRef%3Cstr%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#628-633">source</a></span><h3 class="code-header in-band">impl AsRef&lt;str&gt; for str</h3></section></summary><div class="impl-items">
<summary><section id="method.as_ref-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#630">source</a></span><h4 class="code-header">fn as_ref(&amp;self) -&gt; &amp;str</h4></section></summary><div class="docblock">
<p>Converts this type into a shared reference of the (usually inferred) input type.</p> </div>
</div>
<summary><section id="impl-AsRef%3Cstr%3E-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2884-2888">source</a><span class="since" title="Stable since Rust version 1.55.0">1.55.0</span> Â· </span><h3 class="code-header in-band">impl&lt;'a&gt; AsRef&lt;str&gt; for Drain&lt;'a&gt;</h3></section></summary><div class="impl-items">
<summary><section id="method.as_ref-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2885">source</a></span><h4 class="code-header">fn as_ref(&amp;self) -&gt; &amp;str</h4></section></summary><div class="docblock">
<p>Converts this type into a shared reference of the (usually inferred) input type.</p> </div>
</div>
<summary><section id="impl-AsRef%3Cstr%3E-2" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2566-2571">source</a></span><h3 class="code-header in-band">impl AsRef&lt;str&gt; for String</h3></section></summary><div class="impl-items">
<summary><section id="method.as_ref-3" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2568">source</a></span><h4 class="code-header">fn as_ref(&amp;self) -&gt; &amp;str</h4></section></summary><div class="docblock">
<p>Converts this type into a shared reference of the (usually inferred) input type.</p> </div>
</div>
<summary><section id="impl-AsciiExt" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ascii.rs.html#204-208">source</a></span><h3 class="code-header in-band">impl AsciiExt for str</h3></section></summary><div class="impl-items">
<summary><section id="associatedtype.Owned-1" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Owned = String</h4></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span> Deprecated since 1.26.0: <p>use inherent methods instead</p> </div></span><div class="docblock">
<p>Container type for copied ASCII characters.</p> </div>
<summary><section id="method.is_ascii-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ascii.rs.html#207">source</a></span><h4 class="code-header">fn is_ascii(&amp;self) -&gt; bool</h4></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span> Deprecated since 1.26.0: <p>use inherent methods instead</p> </div></span><div class="docblock">
<p>Checks if the value is within the ASCII range. <a href="ascii/trait.asciiext#tymethod.is_ascii">Read more</a></p> </div>
<summary><section id="method.to_ascii_uppercase-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ascii.rs.html#207">source</a></span><h4 class="code-header">fn to_ascii_uppercase(&amp;self) -&gt; Self::Owned</h4></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span> Deprecated since 1.26.0: <p>use inherent methods instead</p> </div></span><div class="docblock">
<p>Makes a copy of the value in its ASCII upper case equivalent. <a href="ascii/trait.asciiext#tymethod.to_ascii_uppercase">Read more</a></p> </div>
<summary><section id="method.to_ascii_lowercase-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ascii.rs.html#207">source</a></span><h4 class="code-header">fn to_ascii_lowercase(&amp;self) -&gt; Self::Owned</h4></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span> Deprecated since 1.26.0: <p>use inherent methods instead</p> </div></span><div class="docblock">
<p>Makes a copy of the value in its ASCII lower case equivalent. <a href="ascii/trait.asciiext#tymethod.to_ascii_lowercase">Read more</a></p> </div>
<summary><section id="method.eq_ignore_ascii_case-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ascii.rs.html#207">source</a></span><h4 class="code-header">fn eq_ignore_ascii_case(&amp;self, o: &amp;Self) -&gt; bool</h4></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span> Deprecated since 1.26.0: <p>use inherent methods instead</p> </div></span><div class="docblock">
<p>Checks that two values are an ASCII case-insensitive match. <a href="ascii/trait.asciiext#tymethod.eq_ignore_ascii_case">Read more</a></p> </div>
<summary><section id="method.make_ascii_uppercase-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ascii.rs.html#207">source</a></span><h4 class="code-header">fn make_ascii_uppercase(&amp;mut self)</h4></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span> Deprecated since 1.26.0: <p>use inherent methods instead</p> </div></span><div class="docblock">
<p>Converts this type to its ASCII upper case equivalent in-place. <a href="ascii/trait.asciiext#tymethod.make_ascii_uppercase">Read more</a></p> </div>
<summary><section id="method.make_ascii_lowercase-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ascii.rs.html#207">source</a></span><h4 class="code-header">fn make_ascii_lowercase(&amp;mut self)</h4></section></summary><span class="item-info"><div class="stab deprecated">
<span class="emoji">ğŸ‘</span> Deprecated since 1.26.0: <p>use inherent methods instead</p> </div></span><div class="docblock">
<p>Converts this type to its ASCII lower case equivalent in-place. <a href="ascii/trait.asciiext#tymethod.make_ascii_lowercase">Read more</a></p> </div>
</div>
<summary><section id="impl-Borrow%3Cstr%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#206-211">source</a></span><h3 class="code-header in-band">impl Borrow&lt;str&gt; for String</h3></section></summary><div class="impl-items">
<summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#208">source</a></span><h4 class="code-header">fn borrow(&amp;self) -&gt; &amp;str</h4></section></summary><div class="docblock">
<p>Immutably borrows from an owned value. <a href="borrow/trait.borrow#tymethod.borrow">Read more</a></p> </div>
</div>
<summary><section id="impl-BorrowMut%3Cstr%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#214-219">source</a><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> Â· </span><h3 class="code-header in-band">impl BorrowMut&lt;str&gt; for String</h3></section></summary><div class="impl-items">
<summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#216">source</a></span><h4 class="code-header">fn borrow_mut(&amp;mut self) -&gt; &amp;mut str</h4></section></summary><div class="docblock">
<p>Mutably borrows from an owned value. <a href="borrow/trait.borrowmut#tymethod.borrow_mut">Read more</a></p> </div>
</div>
<summary><section id="impl-Concat%3Cstr%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#79-85">source</a></span><h3 class="code-header in-band">impl&lt;S&gt; Concat&lt;str&gt; for [S] <span class="where fmt-newline">where<br> S: <a class="trait" href="borrow/trait.borrow" title="trait std::borrow::Borrow">Borrow</a>&lt;<a class="primitive" href="primitive.str">str</a>&gt;, </span>
</h3></section></summary><div class="docblock">
<p>Note: <code>str</code> in <code>Concat&lt;str&gt;</code> is not meaningful here. This type parameter of the trait only exists to enable another impl.</p> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-10" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Output = String</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_concat_trait</code> <a href="https://github.com/rust-lang/rust/issues/27747">#27747</a>)</div></span><div class="docblock">
<p>The resulting type after concatenation</p> </div>
<summary><section id="method.concat" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#82">source</a></span><h4 class="code-header">fn concat(slice: &amp;[S]) -&gt; String</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_concat_trait</code> <a href="https://github.com/rust-lang/rust/issues/27747">#27747</a>)</div></span><div class="docblock">
<p>Implementation of <a href="primitive.slice#method.concat"><code>[T]::concat</code></a></p> </div>
</div>
<summary><section id="impl-Debug" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#2176-2198">source</a></span><h3 class="code-header in-band">impl Debug for str</h3></section></summary><div class="impl-items">
<summary><section id="method.fmt" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#2177">source</a></span><h4 class="code-header">fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</h4></section></summary><div class="docblock">
<p>Formats the value using the given formatter. <a href="fmt/trait.debug#tymethod.fmt">Read more</a></p> </div>
</div>
<summary><section id="impl-Default" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2578-2585">source</a><span class="since" title="Stable since Rust version 1.28.0">1.28.0</span> Â· </span><h3 class="code-header in-band">impl&lt;'_&gt; Default for &amp;'_ mut str</h3></section></summary><div class="impl-items">
<summary><section id="method.default" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2581">source</a></span><h4 class="code-header">fn default() -&gt; &amp;'_ mut str</h4></section></summary><div class="docblock">
<p>Creates an empty mutable str</p> </div>
</div>
<summary><section id="impl-Default-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2569-2575">source</a><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/87864" title="Tracking issue for const_default_impls">unstable</a></span> Â· </span><h3 class="code-header in-band">impl&lt;'_&gt; Default for &amp;'_ str</h3></section></summary><div class="impl-items">
<summary><section id="method.default-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2572">source</a><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/87864" title="Tracking issue for const_default_impls">unstable</a></span> Â· </span><h4 class="code-header">fn default() -&gt; &amp;'_ str</h4></section></summary><div class="docblock">
<p>Creates an empty str</p> </div>
</div>
<summary><section id="impl-Display" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#2201-2205">source</a></span><h3 class="code-header in-band">impl Display for str</h3></section></summary><div class="impl-items">
<summary><section id="method.fmt-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#2202">source</a></span><h4 class="code-header">fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</h4></section></summary><div class="docblock">
<p>Formats the value using the given formatter. <a href="fmt/trait.display#tymethod.fmt">Read more</a></p> </div>
</div>
<summary><section id="impl-Extend%3C%26%27a%20str%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2064-2073">source</a></span><h3 class="code-header in-band">impl&lt;'a&gt; Extend&lt;&amp;'a str&gt; for String</h3></section></summary><div class="impl-items">
<summary><section id="method.extend" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2065">source</a></span><h4 class="code-header">fn extend&lt;I&gt;(&amp;mut self, iter: I) <span class="where fmt-newline">where<br> I: <a class="trait" href="iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = &amp;'a <a class="primitive" href="primitive.str">str</a>&gt;, </span>
</h4></section></summary><div class="docblock">
<p>Extends a collection with the contents of an iterator. <a href="iter/trait.extend#tymethod.extend">Read more</a></p> </div>
<summary><section id="method.extend_one" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2070">source</a></span><h4 class="code-header">fn extend_one(&amp;mut self, s: &amp;'a str)</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>extend_one</code> <a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</div></span><div class="docblock">
<p>Extends a collection with exactly one element.</p> </div>
<summary><section id="method.extend_reserve" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/iter/traits/collect.rs.html#379">source</a></span><h4 class="code-header">fn extend_reserve(&amp;mut self, additional: usize)</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>extend_one</code> <a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</div></span><div class="docblock">
<p>Reserves capacity in a collection for the given number of additional elements. <a href="iter/trait.extend#method.extend_reserve">Read more</a></p> </div>
</div>
<summary><section id="impl-From%3C%26%27_%20mut%20str%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2603-2611">source</a><span class="since" title="Stable since Rust version 1.44.0">1.44.0</span> Â· </span><h3 class="code-header in-band">impl&lt;'_&gt; From&lt;&amp;'_ mut str&gt; for String</h3></section></summary><div class="impl-items">
<summary><section id="method.from-5" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2608">source</a></span><h4 class="code-header">fn from(s: &amp;mut str) -&gt; String</h4></section></summary><div class="docblock">
<p>Converts a <code>&amp;mut str</code> into a <a href="string/struct.string" title="String"><code>String</code></a>.</p> <p>The result is allocated on the heap.</p> </div>
</div>
<summary><section id="impl-From%3C%26%27_%20str%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/vec/mod.rs.html#3056-3067">source</a></span><h3 class="code-header in-band">impl&lt;'_&gt; From&lt;&amp;'_ str&gt; for Vec&lt;u8, Global&gt;</h3></section></summary><div class="impl-items">
<summary><section id="method.from" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/vec/mod.rs.html#3064">source</a></span><h4 class="code-header">fn from(s: &amp;str) -&gt; Vec&lt;u8, Global&gt;</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="primitive.u8">u8</a>, A&gt;</span><pre class="content">impl&lt;A:Â Allocator&gt; Write for Vec&lt;u8, A&gt;
</pre></span></span></span></summary><div class="docblock">
<p>Allocate a <code>Vec&lt;u8&gt;</code> and fill it with a UTF-8 string.</p> <h5 id="examples-73">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!(Vec::from("123"), vec![b'1', b'2', b'3']);</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26%27_%20str%3E-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2591-2599">source</a></span><h3 class="code-header in-band">impl&lt;'_&gt; From&lt;&amp;'_ str&gt; for String</h3></section></summary><div class="impl-items">
<summary><section id="method.from-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2596">source</a></span><h4 class="code-header">fn from(s: &amp;str) -&gt; String</h4></section></summary><div class="docblock">
<p>Converts a <code>&amp;str</code> into a <a href="string/struct.string" title="String"><code>String</code></a>.</p> <p>The result is allocated on the heap.</p> </div>
</div>
<summary><section id="impl-From%3C%26%27_%20str%3E-2" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1863-1878">source</a><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> Â· </span><h3 class="code-header in-band">impl&lt;'_&gt; From&lt;&amp;'_ str&gt; for Rc&lt;str&gt;</h3></section></summary><div class="impl-items">
<summary><section id="method.from-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1874">source</a></span><h4 class="code-header">fn from(v: &amp;str) -&gt; Rc&lt;str&gt;</h4></section></summary><div class="docblock">
<p>Allocate a reference-counted string slice and copy <code>v</code> into it.</p> <h5 id="example">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let shared: Rc&lt;str&gt; = Rc::from("statue");
assert_eq!("statue", &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26%27_%20str%3E-3" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/boxed.rs.html#1461-1477">source</a><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span> Â· </span><h3 class="code-header in-band">impl&lt;'_&gt; From&lt;&amp;'_ str&gt; for Box&lt;str, Global&gt;</h3></section></summary><div class="impl-items">
<summary><section id="method.from-4" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/boxed.rs.html#1474">source</a></span><h4 class="code-header">fn from(s: &amp;str) -&gt; Box&lt;str, Global&gt;</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="boxed/struct.box" title="struct std::boxed::Box">Box</a>&lt;I, A&gt;</span><pre class="content">impl&lt;I, A&gt; Iterator for Box&lt;I, A&gt; where
Â Â Â Â I: Iterator + ?Sized,
Â Â Â Â A: Allocator,Â 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;F, A&gt; Future for Box&lt;F, A&gt; where
Â Â Â Â F: Future + Unpin + ?Sized,
Â Â Â Â A: Allocator + 'static,Â 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;R:Â Read + ?Sized&gt; Read for Box&lt;R&gt;
impl&lt;W:Â Write + ?Sized&gt; Write for Box&lt;W&gt;
</pre></span></span></span></summary><div class="docblock">
<p>Converts a <code>&amp;str</code> into a <code>Box&lt;str&gt;</code></p> <p>This conversion allocates on the heap and performs a copy of <code>s</code>.</p> <h5 id="examples-74">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let boxed: Box&lt;str&gt; = Box::from("hello");
println!("{boxed}");</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26%27_%20str%3E-4" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2464-2479">source</a><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> Â· </span><h3 class="code-header in-band">impl&lt;'_&gt; From&lt;&amp;'_ str&gt; for Arc&lt;str&gt;</h3></section></summary><div class="impl-items">
<summary><section id="method.from-6" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2475">source</a></span><h4 class="code-header">fn from(v: &amp;str) -&gt; Arc&lt;str&gt;</h4></section></summary><div class="docblock">
<p>Allocate a reference-counted <code>str</code> and copy <code>v</code> into it.</p> <h5 id="example-2">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let shared: Arc&lt;str&gt; = Arc::from("eggplant");
assert_eq!("eggplant", &amp;shared[..]);</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26%27_%20str%3E-5" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/error.rs.html#307-327">source</a></span><h3 class="code-header in-band">impl&lt;'a&gt; From&lt;&amp;'_ str&gt; for Box&lt;dyn Error + Send + Sync + 'a&gt;</h3></section></summary><div class="impl-items">
<summary><section id="method.from-7" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/error.rs.html#324-326">source</a></span><h4 class="code-header">fn from(err: &amp;str) -&gt; Box&lt;dyn Error + Send + Sync + 'a&gt;</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="boxed/struct.box" title="struct std::boxed::Box">Box</a>&lt;I, A&gt;</span><pre class="content">impl&lt;I, A&gt; Iterator for Box&lt;I, A&gt; where
Â Â Â Â I: Iterator + ?Sized,
Â Â Â Â A: Allocator,Â 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;F, A&gt; Future for Box&lt;F, A&gt; where
Â Â Â Â F: Future + Unpin + ?Sized,
Â Â Â Â A: Allocator + 'static,Â 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;R:Â Read + ?Sized&gt; Read for Box&lt;R&gt;
impl&lt;W:Â Write + ?Sized&gt; Write for Box&lt;W&gt;
</pre></span></span></span></summary><div class="docblock">
<p>Converts a <a href="primitive.str"><code>str</code></a> into a box of dyn <a href="error/trait.error" title="Error"><code>Error</code></a> + <a href="marker/trait.send" title="Send"><code>Send</code></a> + <a href="marker/trait.sync" title="Sync"><code>Sync</code></a>.</p> <h5 id="examples-75">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::error::Error;
use std::mem;

let a_str_error = "a str error";
let a_boxed_error = Box::&lt;dyn Error + Send + Sync&gt;::from(a_str_error);
assert!(
    mem::size_of::&lt;Box&lt;dyn Error + Send + Sync&gt;&gt;() == mem::size_of_val(&amp;a_boxed_error))</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26%27_%20str%3E-6" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/error.rs.html#330-348">source</a><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span> Â· </span><h3 class="code-header in-band">impl From&lt;&amp;'_ str&gt; for Box&lt;dyn Error&gt;</h3></section></summary><div class="impl-items">
<summary><section id="method.from-8" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/error.rs.html#345-347">source</a></span><h4 class="code-header">fn from(err: &amp;str) -&gt; Box&lt;dyn Error&gt;</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="boxed/struct.box" title="struct std::boxed::Box">Box</a>&lt;I, A&gt;</span><pre class="content">impl&lt;I, A&gt; Iterator for Box&lt;I, A&gt; where
Â Â Â Â I: Iterator + ?Sized,
Â Â Â Â A: Allocator,Â 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;F, A&gt; Future for Box&lt;F, A&gt; where
Â Â Â Â F: Future + Unpin + ?Sized,
Â Â Â Â A: Allocator + 'static,Â 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;R:Â Read + ?Sized&gt; Read for Box&lt;R&gt;
impl&lt;W:Â Write + ?Sized&gt; Write for Box&lt;W&gt;
</pre></span></span></span></summary><div class="docblock">
<p>Converts a <a href="primitive.str"><code>str</code></a> into a box of dyn <a href="error/trait.error" title="Error"><code>Error</code></a>.</p> <h5 id="examples-76">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::error::Error;
use std::mem;

let a_str_error = "a str error";
let a_boxed_error = Box::&lt;dyn Error&gt;::from(a_str_error);
assert!(mem::size_of::&lt;Box&lt;dyn Error&gt;&gt;() == mem::size_of_val(&amp;a_boxed_error))</pre></div> </div>
</div>
<summary><section id="impl-From%3C%26%27a%20str%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2695-2712">source</a></span><h3 class="code-header in-band">impl&lt;'a&gt; From&lt;&amp;'a str&gt; for Cow&lt;'a, str&gt;</h3></section></summary><div class="impl-items">
<summary><section id="method.from-3" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2709">source</a></span><h4 class="code-header">fn from(s: &amp;'a str) -&gt; Cow&lt;'a, str&gt;</h4></section></summary><div class="docblock">
<p>Converts a string slice into a <a href="borrow/enum.cow#variant.Borrowed" title="borrow::Cow::Borrowed"><code>Borrowed</code></a> variant. No heap allocation is performed, and the string is not copied.</p> <h5 id="example-1">Example</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!(Cow::from("eggplant"), Cow::Borrowed("eggplant"));</pre></div> </div>
</div>
<summary><section id="impl-FromIterator%3C%26%27a%20str%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1966-1972">source</a></span><h3 class="code-header in-band">impl&lt;'a&gt; FromIterator&lt;&amp;'a str&gt; for String</h3></section></summary><div class="impl-items">
<summary><section id="method.from_iter-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1967">source</a></span><h4 class="code-header">fn from_iter&lt;I&gt;(iter: I) -&gt; String <span class="where fmt-newline">where<br> I: <a class="trait" href="iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = &amp;'a <a class="primitive" href="primitive.str">str</a>&gt;, </span>
</h4></section></summary><div class="docblock">
<p>Creates a value from an iterator. <a href="iter/trait.fromiterator#tymethod.from_iter">Read more</a></p> </div>
</div>
<summary><section id="impl-FromIterator%3C%26%27b%20str%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2769-2773">source</a><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span> Â· </span><h3 class="code-header in-band">impl&lt;'a, 'b&gt; FromIterator&lt;&amp;'b str&gt; for Cow&lt;'a, str&gt;</h3></section></summary><div class="impl-items">
<summary><section id="method.from_iter" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2770">source</a></span><h4 class="code-header">fn from_iter&lt;I&gt;(it: I) -&gt; Cow&lt;'a, str&gt; <span class="where fmt-newline">where<br> I: <a class="trait" href="iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = &amp;'b <a class="primitive" href="primitive.str">str</a>&gt;, </span>
</h4></section></summary><div class="docblock">
<p>Creates a value from an iterator. <a href="iter/trait.fromiterator#tymethod.from_iter">Read more</a></p> </div>
</div>
<summary><section id="impl-Hash" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/hash/mod.rs.html#861-866">source</a></span><h3 class="code-header in-band">impl Hash for str</h3></section></summary><div class="impl-items">
<summary><section id="method.hash" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/hash/mod.rs.html#863">source</a></span><h4 class="code-header">fn hash&lt;H&gt;(&amp;self, state: &amp;mut H) <span class="where fmt-newline">where<br> H: <a class="trait" href="hash/trait.hasher" title="trait std::hash::Hasher">Hasher</a>, </span>
</h4></section></summary><div class="docblock">
<p>Feeds this value into the given <a href="hash/trait.hasher" title="Hasher"><code>Hasher</code></a>. <a href="hash/trait.hash#tymethod.hash">Read more</a></p> </div>
<summary><section id="method.hash_slice" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/hash/mod.rs.html#237-239">source</a><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> Â· </span><h4 class="code-header">fn hash_slice&lt;H&gt;(data: &amp;[Self], state: &amp;mut H) <span class="where fmt-newline">where<br> H: <a class="trait" href="hash/trait.hasher" title="trait std::hash::Hasher">Hasher</a>, </span>
</h4></section></summary><div class="docblock">
<p>Feeds a slice of this type into the given <a href="hash/trait.hasher" title="Hasher"><code>Hasher</code></a>. <a href="hash/trait.hash#method.hash_slice">Read more</a></p> </div>
</div>
<summary><section id="impl-Index%3CI%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#57-67">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h3 class="code-header in-band">impl&lt;I&gt; Index&lt;I&gt; for str <span class="where fmt-newline">where<br> I: <a class="trait" href="slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str">str</a>&gt;, </span>
</h3></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Output = &lt;I as SliceIndex&lt;str&gt;&gt;::Output</h4></section></summary><div class="docblock">
<p>The returned type after indexing.</p> </div>
<summary><section id="method.index" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#64">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn index(&amp;self, index: I) -&gt; &amp;&lt;I as SliceIndex&lt;str&gt;&gt;::Output</h4></section></summary><div class="docblock">
<p>Performs the indexing (<code>container[index]</code>) operation. <a href="ops/trait.index#tymethod.index">Read more</a></p> </div>
</div>
<summary><section id="impl-IndexMut%3CI%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#71-79">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h3 class="code-header in-band">impl&lt;I&gt; IndexMut&lt;I&gt; for str <span class="where fmt-newline">where<br> I: <a class="trait" href="slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str">str</a>&gt;, </span>
</h3></section></summary><div class="impl-items">
<summary><section id="method.index_mut-6" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#76">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn index_mut(&amp;mut self, index: I) -&gt; &amp;mut &lt;I as SliceIndex&lt;str&gt;&gt;::Output</h4></section></summary><div class="docblock">
<p>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="ops/trait.indexmut#tymethod.index_mut">Read more</a></p> </div>
</div>
<summary><section id="impl-Join%3C%26%27_%20str%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#89-95">source</a></span><h3 class="code-header in-band">impl&lt;'_, S&gt; Join&lt;&amp;'_ str&gt; for [S] <span class="where fmt-newline">where<br> S: <a class="trait" href="borrow/trait.borrow" title="trait std::borrow::Borrow">Borrow</a>&lt;<a class="primitive" href="primitive.str">str</a>&gt;, </span>
</h3></section></summary><div class="impl-items">
<summary><section id="associatedtype.Output-7" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Output = String</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_concat_trait</code> <a href="https://github.com/rust-lang/rust/issues/27747">#27747</a>)</div></span><div class="docblock">
<p>The resulting type after concatenation</p> </div>
<summary><section id="method.join" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#92">source</a></span><h4 class="code-header">fn join(slice: &amp;[S], sep: &amp;str) -&gt; String</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_concat_trait</code> <a href="https://github.com/rust-lang/rust/issues/27747">#27747</a>)</div></span><div class="docblock">
<p>Implementation of <a href="primitive.slice#method.join"><code>[T]::join</code></a></p> </div>
</div>
<summary><section id="impl-Ord" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#18-23">source</a></span><h3 class="code-header in-band">impl Ord for str</h3></section></summary><div class="docblock">
<p>Implements ordering of strings.</p> <p>Strings are ordered <a href="cmp/trait.ord#lexicographical-comparison">lexicographically</a> by their byte values. This orders Unicode code points based on their positions in the code charts. This is not necessarily the same as â€œalphabeticalâ€ order, which varies by language and locale. Sorting strings according to culturally-accepted standards requires locale-specific data that is outside the scope of the <code>str</code> type.</p> </div>
<div class="impl-items">
<summary><section id="method.cmp" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#20">source</a></span><h4 class="code-header">fn cmp(&amp;self, other: &amp;str) -&gt; Ordering</h4></section></summary><div class="docblock">
<p>This method returns an <a href="cmp/enum.ordering" title="Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="cmp/trait.ord#tymethod.cmp">Read more</a></p> </div>
<summary><section id="method.max" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#796-798">source</a><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> Â· </span><h4 class="code-header">fn max(self, other: Self) -&gt; Self</h4></section></summary><div class="docblock">
<p>Compares and returns the maximum of two values. <a href="cmp/trait.ord#method.max">Read more</a></p> </div>
<summary><section id="method.min" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#816-818">source</a><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> Â· </span><h4 class="code-header">fn min(self, other: Self) -&gt; Self</h4></section></summary><div class="docblock">
<p>Compares and returns the minimum of two values. <a href="cmp/trait.ord#method.min">Read more</a></p> </div>
<summary><section id="method.clamp" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#841-843">source</a><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> Â· </span><h4 class="code-header">fn clamp(self, min: Self, max: Self) -&gt; Self</h4></section></summary><div class="docblock">
<p>Restrict a value to a certain interval. <a href="cmp/trait.ord#method.clamp">Read more</a></p> </div>
</div>
<summary><section id="impl-PartialEq%3C%26%27_%20str%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#552-557">source</a><span class="since" title="Stable since Rust version 1.29.0">1.29.0</span> Â· </span><h3 class="code-header in-band">impl PartialEq&lt;&amp;'_ str&gt; for OsString</h3></section></summary><div class="impl-items">
<summary><section id="method.eq-11" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#554-556">source</a></span><h4 class="code-header">fn eq(&amp;self, other: &amp;&amp;str) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<summary><section id="method.ne-11" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#230">source</a></span><h4 class="code-header">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<summary><section id="impl-PartialEq%3C%26%27a%20str%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2197">source</a></span><h3 class="code-header in-band">impl&lt;'a, 'b&gt; PartialEq&lt;&amp;'a str&gt; for String</h3></section></summary><div class="impl-items">
<summary><section id="method.eq-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2197">source</a></span><h4 class="code-header">fn eq(&amp;self, other: &amp;&amp;'a str) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<summary><section id="method.ne-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2197">source</a></span><h4 class="code-header">fn ne(&amp;self, other: &amp;&amp;'a str) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<summary><section id="impl-PartialEq%3C%26%27b%20str%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2201">source</a></span><h3 class="code-header in-band">impl&lt;'a, 'b&gt; PartialEq&lt;&amp;'b str&gt; for Cow&lt;'a, str&gt;</h3></section></summary><div class="impl-items">
<summary><section id="method.eq-7" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2201">source</a></span><h4 class="code-header">fn eq(&amp;self, other: &amp;&amp;'b str) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<summary><section id="method.ne-7" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2201">source</a></span><h4 class="code-header">fn ne(&amp;self, other: &amp;&amp;'b str) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<summary><section id="impl-PartialEq%3CCow%3C%27a%2C%20str%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2199">source</a></span><h3 class="code-header in-band">impl&lt;'a, 'b&gt; PartialEq&lt;Cow&lt;'a, str&gt;&gt; for str</h3></section></summary><div class="impl-items">
<summary><section id="method.eq-5" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2199">source</a></span><h4 class="code-header">fn eq(&amp;self, other: &amp;Cow&lt;'a, str&gt;) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<summary><section id="method.ne-5" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2199">source</a></span><h4 class="code-header">fn ne(&amp;self, other: &amp;Cow&lt;'a, str&gt;) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<summary><section id="impl-PartialEq%3CCow%3C%27a%2C%20str%3E%3E-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2201">source</a></span><h3 class="code-header in-band">impl&lt;'a, 'b&gt; PartialEq&lt;Cow&lt;'a, str&gt;&gt; for &amp;'b str</h3></section></summary><div class="impl-items">
<summary><section id="method.eq-6" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2201">source</a></span><h4 class="code-header">fn eq(&amp;self, other: &amp;Cow&lt;'a, str&gt;) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<summary><section id="method.ne-6" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2201">source</a></span><h4 class="code-header">fn ne(&amp;self, other: &amp;Cow&lt;'a, str&gt;) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<summary><section id="impl-PartialEq%3COsStr%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1109-1114">source</a></span><h3 class="code-header in-band">impl PartialEq&lt;OsStr&gt; for str</h3></section></summary><div class="impl-items">
<summary><section id="method.eq-14" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1111-1113">source</a></span><h4 class="code-header">fn eq(&amp;self, other: &amp;OsStr) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<summary><section id="method.ne-14" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#230">source</a></span><h4 class="code-header">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<summary><section id="impl-PartialEq%3COsString%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#544-549">source</a></span><h3 class="code-header in-band">impl PartialEq&lt;OsString&gt; for str</h3></section></summary><div class="impl-items">
<summary><section id="method.eq-10" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#546-548">source</a></span><h4 class="code-header">fn eq(&amp;self, other: &amp;OsString) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<summary><section id="method.ne-10" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#230">source</a></span><h4 class="code-header">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<summary><section id="impl-PartialEq%3COsString%3E-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#560-565">source</a><span class="since" title="Stable since Rust version 1.29.0">1.29.0</span> Â· </span><h3 class="code-header in-band">impl&lt;'a&gt; PartialEq&lt;OsString&gt; for &amp;'a str</h3></section></summary><div class="impl-items">
<summary><section id="method.eq-12" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#562-564">source</a></span><h4 class="code-header">fn eq(&amp;self, other: &amp;OsString) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<summary><section id="method.ne-12" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#230">source</a></span><h4 class="code-header">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<summary><section id="impl-PartialEq%3CString%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2197">source</a></span><h3 class="code-header in-band">impl&lt;'a, 'b&gt; PartialEq&lt;String&gt; for &amp;'a str</h3></section></summary><div class="impl-items">
<summary><section id="method.eq-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2197">source</a></span><h4 class="code-header">fn eq(&amp;self, other: &amp;String) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<summary><section id="method.ne-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2197">source</a></span><h4 class="code-header">fn ne(&amp;self, other: &amp;String) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<summary><section id="impl-PartialEq%3CString%3E-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2196">source</a></span><h3 class="code-header in-band">impl&lt;'a, 'b&gt; PartialEq&lt;String&gt; for str</h3></section></summary><div class="impl-items">
<summary><section id="method.eq-3" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2196">source</a></span><h4 class="code-header">fn eq(&amp;self, other: &amp;String) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<summary><section id="method.ne-3" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2196">source</a></span><h4 class="code-header">fn ne(&amp;self, other: &amp;String) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<summary><section id="impl-PartialEq%3Cstr%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#26-35">source</a></span><h3 class="code-header in-band">impl PartialEq&lt;str&gt; for str</h3></section></summary><div class="impl-items">
<summary><section id="method.eq" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#28">source</a></span><h4 class="code-header">fn eq(&amp;self, other: &amp;str) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<summary><section id="method.ne" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#32">source</a></span><h4 class="code-header">fn ne(&amp;self, other: &amp;str) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<summary><section id="impl-PartialEq%3Cstr%3E-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2199">source</a></span><h3 class="code-header in-band">impl&lt;'a, 'b&gt; PartialEq&lt;str&gt; for Cow&lt;'a, str&gt;</h3></section></summary><div class="impl-items">
<summary><section id="method.eq-4" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2199">source</a></span><h4 class="code-header">fn eq(&amp;self, other: &amp;str) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<summary><section id="method.ne-4" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2199">source</a></span><h4 class="code-header">fn ne(&amp;self, other: &amp;str) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<summary><section id="impl-PartialEq%3Cstr%3E-2" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2196">source</a></span><h3 class="code-header in-band">impl&lt;'a, 'b&gt; PartialEq&lt;str&gt; for String</h3></section></summary><div class="impl-items">
<summary><section id="method.eq-8" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2196">source</a></span><h4 class="code-header">fn eq(&amp;self, other: &amp;str) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<summary><section id="method.ne-8" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2196">source</a></span><h4 class="code-header">fn ne(&amp;self, other: &amp;str) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<summary><section id="impl-PartialEq%3Cstr%3E-3" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#536-541">source</a></span><h3 class="code-header in-band">impl PartialEq&lt;str&gt; for OsString</h3></section></summary><div class="impl-items">
<summary><section id="method.eq-9" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#538-540">source</a></span><h4 class="code-header">fn eq(&amp;self, other: &amp;str) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<summary><section id="method.ne-9" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#230">source</a></span><h4 class="code-header">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<summary><section id="impl-PartialEq%3Cstr%3E-4" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1101-1106">source</a></span><h3 class="code-header in-band">impl PartialEq&lt;str&gt; for OsStr</h3></section></summary><div class="impl-items">
<summary><section id="method.eq-13" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1103-1105">source</a></span><h4 class="code-header">fn eq(&amp;self, other: &amp;str) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<summary><section id="method.ne-13" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#230">source</a></span><h4 class="code-header">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<summary><section id="impl-PartialOrd%3Cstr%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#48-53">source</a></span><h3 class="code-header in-band">impl PartialOrd&lt;str&gt; for str</h3></section></summary><div class="docblock">
<p>Implements comparison operations on strings.</p> <p>Strings are compared <a href="cmp/trait.ord#lexicographical-comparison">lexicographically</a> by their byte values. This compares Unicode code points based on their positions in the code charts. This is not necessarily the same as â€œalphabeticalâ€ order, which varies by language and locale. Comparing strings according to culturally-accepted standards requires locale-specific data that is outside the scope of the <code>str</code> type.</p> </div>
<div class="impl-items">
<summary><section id="method.partial_cmp" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#50">source</a></span><h4 class="code-header">fn partial_cmp(&amp;self, other: &amp;str) -&gt; Option&lt;Ordering&gt;</h4></section></summary><div class="docblock">
<p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.partialord#tymethod.partial_cmp">Read more</a></p> </div>
<summary><section id="method.lt" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1100">source</a></span><h4 class="code-header">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.partialord#method.lt">Read more</a></p> </div>
<summary><section id="method.le" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1120">source</a></span><h4 class="code-header">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="cmp/trait.partialord#method.le">Read more</a></p> </div>
<summary><section id="method.gt" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1143">source</a></span><h4 class="code-header">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.partialord#method.gt">Read more</a></p> </div>
<summary><section id="method.ge" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1163">source</a></span><h4 class="code-header">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="cmp/trait.partialord#method.ge">Read more</a></p> </div>
</div>
<summary><section id="impl-PartialOrd%3Cstr%3E-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#595-600">source</a></span><h3 class="code-header in-band">impl PartialOrd&lt;str&gt; for OsString</h3></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#597-599">source</a></span><h4 class="code-header">fn partial_cmp(&amp;self, other: &amp;str) -&gt; Option&lt;Ordering&gt;</h4></section></summary><div class="docblock">
<p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.partialord#tymethod.partial_cmp">Read more</a></p> </div>
<summary><section id="method.lt-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1100">source</a></span><h4 class="code-header">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.partialord#method.lt">Read more</a></p> </div>
<summary><section id="method.le-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1120">source</a></span><h4 class="code-header">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="cmp/trait.partialord#method.le">Read more</a></p> </div>
<summary><section id="method.gt-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1143">source</a></span><h4 class="code-header">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.partialord#method.gt">Read more</a></p> </div>
<summary><section id="method.ge-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1163">source</a></span><h4 class="code-header">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="cmp/trait.partialord#method.ge">Read more</a></p> </div>
</div>
<summary><section id="impl-PartialOrd%3Cstr%3E-2" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1144-1149">source</a></span><h3 class="code-header in-band">impl PartialOrd&lt;str&gt; for OsStr</h3></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1146-1148">source</a></span><h4 class="code-header">fn partial_cmp(&amp;self, other: &amp;str) -&gt; Option&lt;Ordering&gt;</h4></section></summary><div class="docblock">
<p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.partialord#tymethod.partial_cmp">Read more</a></p> </div>
<summary><section id="method.lt-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1100">source</a></span><h4 class="code-header">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.partialord#method.lt">Read more</a></p> </div>
<summary><section id="method.le-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1120">source</a></span><h4 class="code-header">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="cmp/trait.partialord#method.le">Read more</a></p> </div>
<summary><section id="method.gt-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1143">source</a></span><h4 class="code-header">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.partialord#method.gt">Read more</a></p> </div>
<summary><section id="method.ge-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1163">source</a></span><h4 class="code-header">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class="docblock">
<p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="cmp/trait.partialord#method.ge">Read more</a></p> </div>
</div>
<summary><section id="impl-Pattern%3C%27a%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#935-977">source</a></span><h3 class="code-header in-band">impl&lt;'a, 'b&gt; Pattern&lt;'a&gt; for &amp;'b str</h3></section></summary><div class="docblock">
<p>Non-allocating substring search.</p> <p>Will handle the pattern <code>""</code> as returning empty matches at each character boundary.</p> <h4 id="examples-70">Examples</h4> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">assert_eq!("Hello world".find("world"), Some(6));</pre></div> </div>
<div class="impl-items">
<summary><section id="method.is_prefix_of" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#945">source</a></span><h4 class="code-header">fn is_prefix_of(self, haystack: &amp;'a str) -&gt; bool</h4></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</div></span></summary><div class="docblock">
<p>Checks whether the pattern matches at the front of the haystack.</p> </div>
<summary><section id="method.strip_prefix_of" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#951">source</a></span><h4 class="code-header">fn strip_prefix_of(self, haystack: &amp;'a str) -&gt; Option&lt;&amp;'a str&gt;</h4></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</div></span></summary><div class="docblock">
<p>Removes the pattern from the front of haystack, if it matches.</p> </div>
<summary><section id="method.is_suffix_of" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#962">source</a></span><h4 class="code-header">fn is_suffix_of(self, haystack: &amp;'a str) -&gt; bool</h4></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</div></span></summary><div class="docblock">
<p>Checks whether the pattern matches at the back of the haystack.</p> </div>
<summary><section id="method.strip_suffix_of" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#968">source</a></span><h4 class="code-header">fn strip_suffix_of(self, haystack: &amp;'a str) -&gt; Option&lt;&amp;'a str&gt;</h4></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</div></span></summary><div class="docblock">
<p>Removes the pattern from the back of haystack, if it matches.</p> </div>
<summary><section id="associatedtype.Searcher" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Searcher = StrSearcher&lt;'a, 'b&gt;</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</div></span><div class="docblock">
<p>Associated searcher for this pattern</p> </div>
<summary><section id="method.into_searcher" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#939">source</a></span><h4 class="code-header">fn into_searcher(self, haystack: &amp;'a str) -&gt; StrSearcher&lt;'a, 'b&gt;</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</div></span><div class="docblock">
<p>Constructs the associated searcher from <code>self</code> and the <code>haystack</code> to search in. <a href="str/pattern/trait.pattern#tymethod.into_searcher">Read more</a></p> </div>
<summary><section id="method.is_contained_in" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#108">source</a></span><h4 class="code-header">fn is_contained_in(self, haystack: &amp;'a str) -&gt; bool</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>pattern</code> <a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</div></span><div class="docblock">
<p>Checks whether the pattern matches anywhere in the haystack</p> </div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#403-437">source</a><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: unstable)</span> Â· </span><h3 class="code-header in-band">impl SliceIndex&lt;str&gt; for RangeInclusive&lt;usize&gt;</h3></section></summary><div class="docblock">
<p>Implements substring slicing with syntax <code>&amp;self[begin ..= end]</code> or <code>&amp;mut self[begin ..= end]</code>.</p> <p>Returns a slice of the given string from the byte range [<code>begin</code>, <code>end</code>]. Equivalent to <code>&amp;self [begin .. end + 1]</code> or <code>&amp;mut self[begin .. end + 1]</code>, except if <code>end</code> has the maximum value for <code>usize</code>.</p> <p>This operation is <em>O</em>(1).</p> <h4 id="panics-4">Panics</h4> <p>Panics if <code>begin</code> does not point to the starting byte offset of a character (as defined by <code>is_char_boundary</code>), if <code>end</code> does not point to the ending byte offset of a character (<code>end + 1</code> is either a starting byte offset or equal to <code>len</code>), if <code>begin &gt; end</code>, or if <code>end &gt;= len</code>.</p> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-1" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Output = str</h4></section></summary><div class="docblock">
<p>The output type returned by methods.</p> </div>
<summary><section id="method.get-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#406">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn get(<br> self, <br> slice: &amp;str<br>) -&gt; Option&lt;&amp;&lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a shared reference to the output at this location, if in bounds. <a href="slice/trait.sliceindex#tymethod.get">Read more</a></p> </div>
<summary><section id="method.get_mut-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#410">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn get_mut(<br> self, <br> slice: &amp;mut str<br>) -&gt; Option&lt;&amp;mut &lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a mutable reference to the output at this location, if in bounds. <a href="slice/trait.sliceindex#tymethod.get_mut">Read more</a></p> </div>
<summary><section id="method.get_unchecked-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#414">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">unsafe fn get_unchecked(<br> self, <br> slice: *const str<br>) -&gt; *const &lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a shared reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.sliceindex#tymethod.get_unchecked">Read more</a></p> </div>
<summary><section id="method.get_unchecked_mut-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#419">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">unsafe fn get_unchecked_mut(<br> self, <br> slice: *mut str<br>) -&gt; *mut &lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a mutable reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.sliceindex#tymethod.get_unchecked_mut">Read more</a></p> </div>
<summary><section id="method.index-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#424">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn index(<br> self, <br> slice: &amp;str<br>) -&gt; &amp;&lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="ops/struct.rangeinclusive" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;A&gt;</span><pre class="content">impl&lt;A&gt; Iterator for RangeInclusive&lt;A&gt; where
Â Â Â Â A: Step,Â 
    type Item = A;
</pre></span></span></span></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a shared reference to the output at this location, panicking if out of bounds. <a href="slice/trait.sliceindex#tymethod.index">Read more</a></p> </div>
<summary><section id="method.index_mut" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#431">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn index_mut(<br> self, <br> slice: &amp;mut str<br>) -&gt; &amp;mut &lt;RangeInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="ops/struct.rangeinclusive" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;A&gt;</span><pre class="content">impl&lt;A&gt; Iterator for RangeInclusive&lt;A&gt; where
Â Â Â Â A: Step,Â 
    type Item = A;
</pre></span></span></span></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a mutable reference to the output at this location, panicking if out of bounds. <a href="slice/trait.sliceindex#tymethod.index_mut">Read more</a></p> </div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#255-307">source</a><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span> Â· </span><h3 class="code-header in-band">impl SliceIndex&lt;str&gt; for RangeTo&lt;usize&gt;</h3></section></summary><div class="docblock">
<p>Implements substring slicing with syntax <code>&amp;self[.. end]</code> or <code>&amp;mut self[.. end]</code>.</p> <p>Returns a slice of the given string from the byte range [0, <code>end</code>). Equivalent to <code>&amp;self[0 .. end]</code> or <code>&amp;mut self[0 .. end]</code>.</p> <p>This operation is <em>O</em>(1).</p> <p>Prior to 1.20.0, these indexing operations were still supported by direct implementation of <code>Index</code> and <code>IndexMut</code>.</p> <h4 id="panics-5">Panics</h4> <p>Panics if <code>end</code> does not point to the starting byte offset of a character (as defined by <code>is_char_boundary</code>), or if <code>end &gt; len</code>.</p> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-2" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Output = str</h4></section></summary><div class="docblock">
<p>The output type returned by methods.</p> </div>
<summary><section id="method.get-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#258">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn get(<br> self, <br> slice: &amp;str<br>) -&gt; Option&lt;&amp;&lt;RangeTo&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a shared reference to the output at this location, if in bounds. <a href="slice/trait.sliceindex#tymethod.get">Read more</a></p> </div>
<summary><section id="method.get_mut-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#268">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn get_mut(<br> self, <br> slice: &amp;mut str<br>) -&gt; Option&lt;&amp;mut &lt;RangeTo&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a mutable reference to the output at this location, if in bounds. <a href="slice/trait.sliceindex#tymethod.get_mut">Read more</a></p> </div>
<summary><section id="method.get_unchecked-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#278">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">unsafe fn get_unchecked(<br> self, <br> slice: *const str<br>) -&gt; *const &lt;RangeTo&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a shared reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.sliceindex#tymethod.get_unchecked">Read more</a></p> </div>
<summary><section id="method.get_unchecked_mut-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#284">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">unsafe fn get_unchecked_mut(<br> self, <br> slice: *mut str<br>) -&gt; *mut &lt;RangeTo&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a mutable reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.sliceindex#tymethod.get_unchecked_mut">Read more</a></p> </div>
<summary><section id="method.index-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#290">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn index(self, slice: &amp;str) -&gt; &amp;&lt;RangeTo&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a shared reference to the output at this location, panicking if out of bounds. <a href="slice/trait.sliceindex#tymethod.index">Read more</a></p> </div>
<summary><section id="method.index_mut-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#298">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn index_mut(<br> self, <br> slice: &amp;mut str<br>) -&gt; &amp;mut &lt;RangeTo&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a mutable reference to the output at this location, panicking if out of bounds. <a href="slice/trait.sliceindex#tymethod.index_mut">Read more</a></p> </div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-2" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#102-128">source</a><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span> Â· </span><h3 class="code-header in-band">impl SliceIndex&lt;str&gt; for RangeFull</h3></section></summary><div class="docblock">
<p>Implements substring slicing with syntax <code>&amp;self[..]</code> or <code>&amp;mut self[..]</code>.</p> <p>Returns a slice of the whole string, i.e., returns <code>&amp;self</code> or <code>&amp;mut self</code>. Equivalent to <code>&amp;self[0 .. len]</code> or <code>&amp;mut self[0 .. len]</code>. Unlike other indexing operations, this can never panic.</p> <p>This operation is <em>O</em>(1).</p> <p>Prior to 1.20.0, these indexing operations were still supported by direct implementation of <code>Index</code> and <code>IndexMut</code>.</p> <p>Equivalent to <code>&amp;self[0 .. len]</code> or <code>&amp;mut self[0 .. len]</code>.</p> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-3" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Output = str</h4></section></summary><div class="docblock">
<p>The output type returned by methods.</p> </div>
<summary><section id="method.get-3" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#105">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn get(self, slice: &amp;str) -&gt; Option&lt;&amp;&lt;RangeFull as SliceIndex&lt;str&gt;&gt;::Output&gt;</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a shared reference to the output at this location, if in bounds. <a href="slice/trait.sliceindex#tymethod.get">Read more</a></p> </div>
<summary><section id="method.get_mut-3" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#109">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn get_mut(<br> self, <br> slice: &amp;mut str<br>) -&gt; Option&lt;&amp;mut &lt;RangeFull as SliceIndex&lt;str&gt;&gt;::Output&gt;</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a mutable reference to the output at this location, if in bounds. <a href="slice/trait.sliceindex#tymethod.get_mut">Read more</a></p> </div>
<summary><section id="method.get_unchecked-3" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#113">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">unsafe fn get_unchecked(<br> self, <br> slice: *const str<br>) -&gt; *const &lt;RangeFull as SliceIndex&lt;str&gt;&gt;::Output</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a shared reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.sliceindex#tymethod.get_unchecked">Read more</a></p> </div>
<summary><section id="method.get_unchecked_mut-3" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#117">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">unsafe fn get_unchecked_mut(<br> self, <br> slice: *mut str<br>) -&gt; *mut &lt;RangeFull as SliceIndex&lt;str&gt;&gt;::Output</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a mutable reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.sliceindex#tymethod.get_unchecked_mut">Read more</a></p> </div>
<summary><section id="method.index-3" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#121">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn index(self, slice: &amp;str) -&gt; &amp;&lt;RangeFull as SliceIndex&lt;str&gt;&gt;::Output</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a shared reference to the output at this location, panicking if out of bounds. <a href="slice/trait.sliceindex#tymethod.index">Read more</a></p> </div>
<summary><section id="method.index_mut-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#125">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn index_mut(<br> self, <br> slice: &amp;mut str<br>) -&gt; &amp;mut &lt;RangeFull as SliceIndex&lt;str&gt;&gt;::Output</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a mutable reference to the output at this location, panicking if out of bounds. <a href="slice/trait.sliceindex#tymethod.index_mut">Read more</a></p> </div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-3" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#167-236">source</a><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span> Â· </span><h3 class="code-header in-band">impl SliceIndex&lt;str&gt; for Range&lt;usize&gt;</h3></section></summary><div class="docblock">
<p>Implements substring slicing with syntax <code>&amp;self[begin .. end]</code> or <code>&amp;mut self[begin .. end]</code>.</p> <p>Returns a slice of the given string from the byte range [<code>begin</code>, <code>end</code>).</p> <p>This operation is <em>O</em>(1).</p> <p>Prior to 1.20.0, these indexing operations were still supported by direct implementation of <code>Index</code> and <code>IndexMut</code>.</p> <h4 id="panics-6">Panics</h4> <p>Panics if <code>begin</code> or <code>end</code> does not point to the starting byte offset of a character (as defined by <code>is_char_boundary</code>), if <code>begin &gt; end</code>, or if <code>end &gt; len</code>.</p> <h4 id="examples-71">Examples</h4> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let s = "LÃ¶we è€è™ LÃ©opard";
assert_eq!(&amp;s[0 .. 1], "L");

assert_eq!(&amp;s[1 .. 9], "Ã¶we è€");

// these will panic:
// byte 2 lies within `Ã¶`:
// &amp;s[2 ..3];

// byte 8 lies within `è€`
// &amp;s[1 .. 8];

// byte 100 is outside the string
// &amp;s[3 .. 100];</pre></div> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-4" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Output = str</h4></section></summary><div class="docblock">
<p>The output type returned by methods.</p> </div>
<summary><section id="method.get-4" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#170">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn get(self, slice: &amp;str) -&gt; Option&lt;&amp;&lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a shared reference to the output at this location, if in bounds. <a href="slice/trait.sliceindex#tymethod.get">Read more</a></p> </div>
<summary><section id="method.get_mut-4" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#184">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn get_mut(<br> self, <br> slice: &amp;mut str<br>) -&gt; Option&lt;&amp;mut &lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a mutable reference to the output at this location, if in bounds. <a href="slice/trait.sliceindex#tymethod.get_mut">Read more</a></p> </div>
<summary><section id="method.get_unchecked-4" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#197">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">unsafe fn get_unchecked(<br> self, <br> slice: *const str<br>) -&gt; *const &lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a shared reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.sliceindex#tymethod.get_unchecked">Read more</a></p> </div>
<summary><section id="method.get_unchecked_mut-4" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#206">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">unsafe fn get_unchecked_mut(<br> self, <br> slice: *mut str<br>) -&gt; *mut &lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a mutable reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.sliceindex#tymethod.get_unchecked_mut">Read more</a></p> </div>
<summary><section id="method.index-4" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#214">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn index(self, slice: &amp;str) -&gt; &amp;&lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="ops/struct.range" title="struct std::ops::Range">Range</a>&lt;A&gt;</span><pre class="content">impl&lt;A&gt; Iterator for Range&lt;A&gt; where
Â Â Â Â A: Step,Â 
    type Item = A;
</pre></span></span></span></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a shared reference to the output at this location, panicking if out of bounds. <a href="slice/trait.sliceindex#tymethod.index">Read more</a></p> </div>
<summary><section id="method.index_mut-3" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#222">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn index_mut(<br> self, <br> slice: &amp;mut str<br>) -&gt; &amp;mut &lt;Range&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="ops/struct.range" title="struct std::ops::Range">Range</a>&lt;A&gt;</span><pre class="content">impl&lt;A&gt; Iterator for Range&lt;A&gt; where
Â Â Â Â A: Step,Â 
    type Item = A;
</pre></span></span></span></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a mutable reference to the output at this location, panicking if out of bounds. <a href="slice/trait.sliceindex#tymethod.index_mut">Read more</a></p> </div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-4" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#326-383">source</a><span class="since" title="Stable since Rust version 1.20.0, const unstable">1.20.0 (const: unstable)</span> Â· </span><h3 class="code-header in-band">impl SliceIndex&lt;str&gt; for RangeFrom&lt;usize&gt;</h3></section></summary><div class="docblock">
<p>Implements substring slicing with syntax <code>&amp;self[begin ..]</code> or <code>&amp;mut self[begin ..]</code>.</p> <p>Returns a slice of the given string from the byte range [<code>begin</code>, <code>len</code>). Equivalent to <code>&amp;self[begin .. len]</code> or <code>&amp;mut self[begin .. len]</code>.</p> <p>This operation is <em>O</em>(1).</p> <p>Prior to 1.20.0, these indexing operations were still supported by direct implementation of <code>Index</code> and <code>IndexMut</code>.</p> <h4 id="panics-7">Panics</h4> <p>Panics if <code>begin</code> does not point to the starting byte offset of a character (as defined by <code>is_char_boundary</code>), or if <code>begin &gt; len</code>.</p> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-5" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Output = str</h4></section></summary><div class="docblock">
<p>The output type returned by methods.</p> </div>
<summary><section id="method.get-5" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#329">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn get(<br> self, <br> slice: &amp;str<br>) -&gt; Option&lt;&amp;&lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a shared reference to the output at this location, if in bounds. <a href="slice/trait.sliceindex#tymethod.get">Read more</a></p> </div>
<summary><section id="method.get_mut-5" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#339">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn get_mut(<br> self, <br> slice: &amp;mut str<br>) -&gt; Option&lt;&amp;mut &lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a mutable reference to the output at this location, if in bounds. <a href="slice/trait.sliceindex#tymethod.get_mut">Read more</a></p> </div>
<summary><section id="method.get_unchecked-5" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#349">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">unsafe fn get_unchecked(<br> self, <br> slice: *const str<br>) -&gt; *const &lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a shared reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.sliceindex#tymethod.get_unchecked">Read more</a></p> </div>
<summary><section id="method.get_unchecked_mut-5" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#358">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">unsafe fn get_unchecked_mut(<br> self, <br> slice: *mut str<br>) -&gt; *mut &lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a mutable reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.sliceindex#tymethod.get_unchecked_mut">Read more</a></p> </div>
<summary><section id="method.index-5" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#366">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn index(self, slice: &amp;str) -&gt; &amp;&lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="ops/struct.rangefrom" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;A&gt;</span><pre class="content">impl&lt;A&gt; Iterator for RangeFrom&lt;A&gt; where
Â Â Â Â A: Step,Â 
    type Item = A;
</pre></span></span></span></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a shared reference to the output at this location, panicking if out of bounds. <a href="slice/trait.sliceindex#tymethod.index">Read more</a></p> </div>
<summary><section id="method.index_mut-4" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#374">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn index_mut(<br> self, <br> slice: &amp;mut str<br>) -&gt; &amp;mut &lt;RangeFrom&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</h4></section><span class="notable-traits"><span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="ops/struct.rangefrom" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;A&gt;</span><pre class="content">impl&lt;A&gt; Iterator for RangeFrom&lt;A&gt; where
Â Â Â Â A: Step,Â 
    type Item = A;
</pre></span></span></span></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a mutable reference to the output at this location, panicking if out of bounds. <a href="slice/trait.sliceindex#tymethod.index_mut">Read more</a></p> </div>
</div>
<summary><section id="impl-SliceIndex%3Cstr%3E-5" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#455-489">source</a><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: unstable)</span> Â· </span><h3 class="code-header in-band">impl SliceIndex&lt;str&gt; for RangeToInclusive&lt;usize&gt;</h3></section></summary><div class="docblock">
<p>Implements substring slicing with syntax <code>&amp;self[..= end]</code> or <code>&amp;mut self[..= end]</code>.</p> <p>Returns a slice of the given string from the byte range [0, <code>end</code>]. Equivalent to <code>&amp;self [0 .. end + 1]</code>, except if <code>end</code> has the maximum value for <code>usize</code>.</p> <p>This operation is <em>O</em>(1).</p> <h4 id="panics-8">Panics</h4> <p>Panics if <code>end</code> does not point to the ending byte offset of a character (<code>end + 1</code> is either a starting byte offset as defined by <code>is_char_boundary</code>, or equal to <code>len</code>), or if <code>end &gt;= len</code>.</p> </div>
<div class="impl-items">
<summary><section id="associatedtype.Output-6" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Output = str</h4></section></summary><div class="docblock">
<p>The output type returned by methods.</p> </div>
<summary><section id="method.get-6" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#458">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn get(<br> self, <br> slice: &amp;str<br>) -&gt; Option&lt;&amp;&lt;RangeToInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a shared reference to the output at this location, if in bounds. <a href="slice/trait.sliceindex#tymethod.get">Read more</a></p> </div>
<summary><section id="method.get_mut-6" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#462">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn get_mut(<br> self, <br> slice: &amp;mut str<br>) -&gt; Option&lt;&amp;mut &lt;RangeToInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output&gt;</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a mutable reference to the output at this location, if in bounds. <a href="slice/trait.sliceindex#tymethod.get_mut">Read more</a></p> </div>
<summary><section id="method.get_unchecked-6" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#466">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">unsafe fn get_unchecked(<br> self, <br> slice: *const str<br>) -&gt; *const &lt;RangeToInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a shared reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.sliceindex#tymethod.get_unchecked">Read more</a></p> </div>
<summary><section id="method.get_unchecked_mut-6" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#471">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">unsafe fn get_unchecked_mut(<br> self, <br> slice: *mut str<br>) -&gt; *mut &lt;RangeToInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a mutable reference to the output at this location, without performing any bounds checking. Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer is <em><a href="../reference/behavior-considered-undefined">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.sliceindex#tymethod.get_unchecked_mut">Read more</a></p> </div>
<summary><section id="method.index-6" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#476">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn index(<br> self, <br> slice: &amp;str<br>) -&gt; &amp;&lt;RangeToInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a shared reference to the output at this location, panicking if out of bounds. <a href="slice/trait.sliceindex#tymethod.index">Read more</a></p> </div>
<summary><section id="method.index_mut-5" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#483">source</a><span class="since" title="const unstable">const: unstable</span> Â· </span><h4 class="code-header">fn index_mut(<br> self, <br> slice: &amp;mut str<br>) -&gt; &amp;mut &lt;RangeToInclusive&lt;usize&gt; as SliceIndex&lt;str&gt;&gt;::Output</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></span><div class="docblock">
<p>Returns a mutable reference to the output at this location, panicking if out of bounds. <a href="slice/trait.sliceindex#tymethod.index_mut">Read more</a></p> </div>
</div>
<summary><section id="impl-ToOwned" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#223-235">source</a></span><h3 class="code-header in-band">impl ToOwned for str</h3></section></summary><div class="impl-items">
<summary><section id="associatedtype.Owned" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Owned = String</h4></section></summary><div class="docblock">
<p>The resulting type after obtaining ownership.</p> </div>
<summary><section id="method.to_owned" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#226">source</a></span><h4 class="code-header">fn to_owned(&amp;self) -&gt; String</h4></section></summary><div class="docblock">
<p>Creates owned data from borrowed data, usually by cloning. <a href="borrow/trait.toowned#tymethod.to_owned">Read more</a></p> </div>
<summary><section id="method.clone_into" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#230">source</a></span><h4 class="code-header">fn clone_into(&amp;self, target: &amp;mut String)</h4></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code> <a href="https://github.com/rust-lang/rust/issues/41263">#41263</a>)</div></span><div class="docblock">
<p>Uses borrowed data to replace owned data, usually by cloning. <a href="borrow/trait.toowned#method.clone_into">Read more</a></p> </div>
</div>
<summary><section id="impl-ToSocketAddrs" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/net/addr.rs.html#992-1002">source</a></span><h3 class="code-header in-band">impl ToSocketAddrs for str</h3></section></summary><div class="impl-items">
<summary><section id="associatedtype.Iter" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Iter = IntoIter&lt;SocketAddr, Global&gt;</h4></section></summary><div class="docblock">
<p>Returned iterator over socket addresses which this type may correspond to. <a href="net/trait.tosocketaddrs#associatedtype.Iter">Read more</a></p> </div>
<summary><section id="method.to_socket_addrs" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/std/net/addr.rs.html#994-1001">source</a></span><h4 class="code-header">fn to_socket_addrs(&amp;self) -&gt; Result&lt;IntoIter&lt;SocketAddr&gt;&gt;</h4></section></summary><div class="docblock">
<p>Converts this object to an iterator of resolved <a href="net/enum.socketaddr" title="SocketAddr"><code>SocketAddr</code></a>s. <a href="net/trait.tosocketaddrs#tymethod.to_socket_addrs">Read more</a></p> </div>
</div>
<summary><section id="impl-ToString" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2540-2545">source</a><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span> Â· </span><h3 class="code-header in-band">impl ToString for str</h3></section></summary><div class="impl-items">
<summary><section id="method.to_string" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2542">source</a></span><h4 class="code-header">fn to_string(&amp;self) -&gt; String</h4></section></summary><div class="docblock">
<p>Converts the given value to a <code>String</code>. <a href="string/trait.tostring#tymethod.to_string">Read more</a></p> </div>
</div>
<section id="impl-Eq" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/str/traits.rs.html#38">source</a></span><h3 class="code-header in-band">impl Eq for str</h3></section>
</div>
<h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations</h2>
<div id="synthetic-implementations-list">
<section id="impl-RefUnwindSafe" class="impl has-srclink"><h3 class="code-header in-band">impl RefUnwindSafe for str</h3></section><section id="impl-Send" class="impl has-srclink"><h3 class="code-header in-band">impl Send for str</h3></section><section id="impl-Sized" class="impl has-srclink"><h3 class="code-header in-band">impl !Sized for str</h3></section><section id="impl-Sync" class="impl has-srclink"><h3 class="code-header in-band">impl Sync for str</h3></section><section id="impl-Unpin" class="impl has-srclink"><h3 class="code-header in-band">impl Unpin for str</h3></section><section id="impl-UnwindSafe" class="impl has-srclink"><h3 class="code-header in-band">impl UnwindSafe for str</h3></section>
</div>
<h2 id="blanket-implementations" class="small-section-header">Blanket Implementations</h2>
<div id="blanket-implementations-list">
<summary><section id="impl-Any" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/any.rs.html#132-136">source</a></span><h3 class="code-header in-band">impl&lt;T&gt; Any for T <span class="where fmt-newline">where<br> T: 'static + ?<a class="trait" href="marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span>
</h3></section></summary><div class="impl-items">
<summary><section id="method.type_id" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/any.rs.html#133">source</a></span><h4 class="code-header">fn type_id(&amp;self) -&gt; TypeId</h4></section></summary><div class="docblock">
<p>Gets the <code>TypeId</code> of <code>self</code>. <a href="any/trait.any#tymethod.type_id">Read more</a></p> </div>
</div>
<summary><section id="impl-Borrow%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#209-214">source</a></span><h3 class="code-header in-band">impl&lt;T&gt; Borrow&lt;T&gt; for T <span class="where fmt-newline">where<br> T: ?<a class="trait" href="marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span>
</h3></section></summary><div class="impl-items">
<summary><section id="method.borrow-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#211">source</a><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> Â· </span><h4 class="code-header">fn borrow(&amp;self) -&gt; &amp;T</h4></section></summary><div class="docblock">
<p>Immutably borrows from an owned value. <a href="borrow/trait.borrow#tymethod.borrow">Read more</a></p> </div>
</div>
<summary><section id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#218-222">source</a></span><h3 class="code-header in-band">impl&lt;T&gt; BorrowMut&lt;T&gt; for T <span class="where fmt-newline">where<br> T: ?<a class="trait" href="marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span>
</h3></section></summary><div class="impl-items">
<summary><section id="method.borrow_mut-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#219">source</a><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> Â· </span><h4 class="code-header">fn borrow_mut(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class="docblock">
<p>Mutably borrows from an owned value. <a href="borrow/trait.borrowmut#tymethod.borrow_mut">Read more</a></p> </div>
</div>
<summary><section id="impl-ToString-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2470-2484">source</a></span><h3 class="code-header in-band">impl&lt;T&gt; ToString for T <span class="where fmt-newline">where<br> T: <a class="trait" href="fmt/trait.display" title="trait std::fmt::Display">Display</a> + ?<a class="trait" href="marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span>
</h3></section></summary><div class="impl-items">
<summary><section id="method.to_string-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2476">source</a></span><h4 class="code-header">default fn to_string(&amp;self) -&gt; String</h4></section></summary><div class="docblock">
<p>Converts the given value to a <code>String</code>. <a href="string/trait.tostring#tymethod.to_string">Read more</a></p> </div>
</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/primitive.str.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/primitive.str.html</a>
  </p>
</div>
