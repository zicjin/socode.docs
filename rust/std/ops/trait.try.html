<h1 class="main-heading">Trait std::ops::Try</h1>
<pre class="rust trait" data-language="rust">pub trait Try: FromResidual&lt;Self::Residual&gt; {
    type Output;
    type Residual;

    fn from_output(output: Self::Output) -&gt; Self;
    fn branch(self) -&gt; ControlFlow&lt;Self::Residual, Self::Output&gt;;
}</pre>
<span class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span> This is a nightly-only experimental API. (<code>try_trait_v2</code> <a href="https://github.com/rust-lang/rust/issues/84277">#84277</a>)</div></span><p>The <code>?</code> operator and <code>try {}</code> blocks.</p> <p><code>try_*</code> methods typically involve a type implementing this trait. For example, the closures passed to <a href="../iter/trait.iterator#method.try_fold" title="Iterator::try_fold"><code>Iterator::try_fold</code></a> and <a href="../iter/trait.iterator#method.try_for_each" title="Iterator::try_for_each"><code>Iterator::try_for_each</code></a> must return such a type.</p> <p><code>Try</code> types are typically those containing two or more categories of values, some subset of which are so commonly handled via early returns that it‚Äôs worth providing a terse (but still visible) syntax to make that easy.</p> <p>This is most often seen for error handling with <a href="../result/enum.result" title="Result"><code>Result</code></a> and <a href="../option/enum.option" title="Option"><code>Option</code></a>. The quintessential implementation of this trait is on <a href="enum.controlflow" title="ControlFlow"><code>ControlFlow</code></a>.</p> <h2 id="using-try-in-generic-code">Using <code>Try</code> in Generic Code</h2> <p><code>Iterator::try_fold</code> was stabilized to call back in Rust 1.27, but this trait is much newer. To illustrate the various associated types and methods, let‚Äôs implement our own version.</p> <p>As a reminder, an infallible version of a fold looks something like this:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">fn simple_fold&lt;A, T&gt;(
    iter: impl Iterator&lt;Item = T&gt;,
    mut accum: A,
    mut f: impl FnMut(A, T) -&gt; A,
) -&gt; A {
    for x in iter {
        accum = f(accum, x);
    }
    accum
}</pre></div> <p>So instead of <code>f</code> returning just an <code>A</code>, we‚Äôll need it to return some other type that produces an <code>A</code> in the ‚Äúdon‚Äôt short circuit‚Äù path. Conveniently, that‚Äôs also the type we need to return from the function.</p> <p>Let‚Äôs add a new generic parameter <code>R</code> for that type, and bound it to the output type that we want:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">fn simple_try_fold_1&lt;A, T, R: Try&lt;Output = A&gt;&gt;(
    iter: impl Iterator&lt;Item = T&gt;,
    mut accum: A,
    mut f: impl FnMut(A, T) -&gt; R,
) -&gt; R {
    todo!()
}</pre></div> <p>If we get through the entire iterator, we need to wrap up the accumulator into the return type using <a href="trait.try#tymethod.from_output" title="Try::from_output"><code>Try::from_output</code></a>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">fn simple_try_fold_2&lt;A, T, R: Try&lt;Output = A&gt;&gt;(
    iter: impl Iterator&lt;Item = T&gt;,
    mut accum: A,
    mut f: impl FnMut(A, T) -&gt; R,
) -&gt; R {
    for x in iter {
        let cf = f(accum, x).branch();
        match cf {
            ControlFlow::Continue(a) =&gt; accum = a,
            ControlFlow::Break(_) =&gt; todo!(),
        }
    }
    R::from_output(accum)
}</pre></div> <p>We‚Äôll also need <a href="trait.fromresidual#tymethod.from_residual" title="FromResidual::from_residual"><code>FromResidual::from_residual</code></a> to turn the residual back into the original type. But because it‚Äôs a supertrait of <code>Try</code>, we don‚Äôt need to mention it in the bounds. All types which implement <code>Try</code> can be recreated from their corresponding residual, so we‚Äôll just call it:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">pub fn simple_try_fold_3&lt;A, T, R: Try&lt;Output = A&gt;&gt;(
    iter: impl Iterator&lt;Item = T&gt;,
    mut accum: A,
    mut f: impl FnMut(A, T) -&gt; R,
) -&gt; R {
    for x in iter {
        let cf = f(accum, x).branch();
        match cf {
            ControlFlow::Continue(a) =&gt; accum = a,
            ControlFlow::Break(r) =&gt; return R::from_residual(r),
        }
    }
    R::from_output(accum)
}</pre></div> <p>But this ‚Äúcall <code>branch</code>, then <code>match</code> on it, and <code>return</code> if it was a <code>Break</code>‚Äù is exactly what happens inside the <code>?</code> operator. So rather than do all this manually, we can just use <code>?</code> instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">fn simple_try_fold&lt;A, T, R: Try&lt;Output = A&gt;&gt;(
    iter: impl Iterator&lt;Item = T&gt;,
    mut accum: A,
    mut f: impl FnMut(A, T) -&gt; R,
) -&gt; R {
    for x in iter {
        accum = f(accum, x)?;
    }
    R::from_output(accum)
}</pre></div> <h2 id="required-associated-types" class="small-section-header">Required Associated Types</h2>
<div class="methods">
<summary><div id="associatedtype.Output" class="method has-srclink">
<div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/ops/try_trait.rs.html#134">source</a></div>
<h4 class="code-header">type Output</h4>
</div></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span> This is a nightly-only experimental API. (<code>try_trait_v2</code> <a href="https://github.com/rust-lang/rust/issues/84277">#84277</a>)</div></span><div class="docblock">
<p>The type of the value produced by <code>?</code> when <em>not</em> short-circuiting.</p> </div>
<summary><div id="associatedtype.Residual" class="method has-srclink">
<div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/ops/try_trait.rs.html#158">source</a></div>
<h4 class="code-header">type Residual</h4>
</div></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span> This is a nightly-only experimental API. (<code>try_trait_v2</code> <a href="https://github.com/rust-lang/rust/issues/84277">#84277</a>)</div></span><div class="docblock">
<p>The type of the value passed to <a href="trait.fromresidual#tymethod.from_residual" title="FromResidual::from_residual"><code>FromResidual::from_residual</code></a> as part of <code>?</code> when short-circuiting.</p> <p>This represents the possible values of the <code>Self</code> type which are <em>not</em> represented by the <code>Output</code> type.</p> <h5 id="note-to-implementors">Note to Implementors</h5> <p>The choice of this type is critical to interconversion. Unlike the <code>Output</code> type, which will often be a raw generic type, this type is typically a newtype of some sort to ‚Äúcolor‚Äù the type so that it‚Äôs distinguishable from the residuals of other types.</p> <p>This is why <code>Result&lt;T, E&gt;::Residual</code> is not <code>E</code>, but <code>Result&lt;Infallible, E&gt;</code>. That way it‚Äôs distinct from <code>ControlFlow&lt;E&gt;::Residual</code>, for example, and thus <code>?</code> on <code>ControlFlow</code> cannot be used in a method returning <code>Result</code>.</p> <p>If you‚Äôre making a generic type <code>Foo&lt;T&gt;</code> that implements <code>Try&lt;Output = T&gt;</code>, then typically you can use <code>Foo&lt;std::convert::Infallible&gt;</code> as its <code>Residual</code> type: that type will have a ‚Äúhole‚Äù in the correct place, and will maintain the ‚Äúfoo-ness‚Äù of the residual so other types need to opt-in to interconversion.</p> </div>
</div>
<h2 id="required-methods" class="small-section-header">Required Methods</h2>
<div class="methods">
<summary><div id="tymethod.from_output" class="method has-srclink">
<div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/ops/try_trait.rs.html#190">source</a></div>
<h4 class="code-header">fn from_output(output: Self::Output) -&gt; Self</h4>
</div></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span> This is a nightly-only experimental API. (<code>try_trait_v2</code> <a href="https://github.com/rust-lang/rust/issues/84277">#84277</a>)</div></span><div class="docblock">
<p>Constructs the type from its <code>Output</code> type.</p> <p>This should be implemented consistently with the <code>branch</code> method such that applying the <code>?</code> operator will get back the original value: <code>Try::from_output(x).branch() --&gt; ControlFlow::Continue(x)</code>.</p> <h5 id="examples">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(try_trait_v2)]
use std::ops::Try;

assert_eq!(&lt;Result&lt;_, String&gt; as Try&gt;::from_output(3), Ok(3));
assert_eq!(&lt;Option&lt;_&gt; as Try&gt;::from_output(4), Some(4));
assert_eq!(
    &lt;std::ops::ControlFlow&lt;String, _&gt; as Try&gt;::from_output(5),
    std::ops::ControlFlow::Continue(5),
);

assert_eq!(Option::from_output(4)?, 4);

// This is used, for example, on the accumulator in `try_fold`:
let r = std::iter::empty().try_fold(4, |_, ()| -&gt; Option&lt;_&gt; { unreachable!() });
assert_eq!(r, Some(4));</pre></div> </div>
<summary><div id="tymethod.branch" class="method has-srclink">
<div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/ops/try_trait.rs.html#217">source</a></div>
<h4 class="code-header">fn branch(self) -&gt; ControlFlow&lt;Self::Residual, Self::Output&gt;</h4>
</div></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span> This is a nightly-only experimental API. (<code>try_trait_v2</code> <a href="https://github.com/rust-lang/rust/issues/84277">#84277</a>)</div></span><div class="docblock">
<p>Used in <code>?</code> to decide whether the operator should produce a value (because this returned <a href="enum.controlflow#variant.Continue" title="ControlFlow::Continue"><code>ControlFlow::Continue</code></a>) or propagate a value back to the caller (because this returned <a href="enum.controlflow#variant.Break" title="ControlFlow::Break"><code>ControlFlow::Break</code></a>).</p> <h5 id="examples-1">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(try_trait_v2)]
use std::ops::{ControlFlow, Try};

assert_eq!(Ok::&lt;_, String&gt;(3).branch(), ControlFlow::Continue(3));
assert_eq!(Err::&lt;String, _&gt;(3).branch(), ControlFlow::Break(Err(3)));

assert_eq!(Some(3).branch(), ControlFlow::Continue(3));
assert_eq!(None::&lt;String&gt;.branch(), ControlFlow::Break(None));

assert_eq!(ControlFlow::&lt;String, _&gt;::Continue(3).branch(), ControlFlow::Continue(3));
assert_eq!(
    ControlFlow::&lt;_, String&gt;::Break(3).branch(),
    ControlFlow::Break(ControlFlow::Break(3)),
);</pre></div> </div>
</div>
<h2 id="implementors" class="small-section-header">Implementors</h2>
<div class="item-list" id="implementors-list">
<summary><section id="impl-Try" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/ops/control_flow.rs.html#98-114">source</a></span><h3 class="code-header in-band">impl&lt;B, C&gt; Try for ControlFlow&lt;B, C&gt;</h3></section></summary><div class="impl-items">
<section id="associatedtype.Output-1" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Output = C</h4></section><section id="associatedtype.Residual-1" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Residual = ControlFlow&lt;B, Infallible&gt;</h4></section>
</div>
<summary><section id="impl-Try-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/option.rs.html#2260-2276">source</a><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> ¬∑ </span><h3 class="code-header in-band">impl&lt;T&gt; Try for Option&lt;T&gt;</h3></section></summary><div class="impl-items">
<section id="associatedtype.Output-2" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Output = T</h4></section><section id="associatedtype.Residual-2" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Residual = Option&lt;Infallible&gt;</h4></section>
</div>
<summary><section id="impl-Try-2" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/task/ready.rs.html#74-90">source</a></span><h3 class="code-header in-band">impl&lt;T&gt; Try for Ready&lt;T&gt;</h3></section></summary><div class="impl-items">
<section id="associatedtype.Output-3" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Output = T</h4></section><section id="associatedtype.Residual-3" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Residual = Ready&lt;Infallible&gt;</h4></section>
</div>
<summary><section id="impl-Try-3" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/result.rs.html#2078-2094">source</a><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> ¬∑ </span><h3 class="code-header in-band">impl&lt;T, E&gt; Try for Result&lt;T, E&gt;</h3></section></summary><div class="impl-items">
<section id="associatedtype.Output-4" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Output = T</h4></section><section id="associatedtype.Residual-4" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Residual = Result&lt;Infallible, E&gt;</h4></section>
</div>
<summary><section id="impl-Try-4" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/task/poll.rs.html#290-308">source</a></span><h3 class="code-header in-band">impl&lt;T, E&gt; Try for Poll&lt;Option&lt;Result&lt;T, E&gt;&gt;&gt;</h3></section></summary><div class="impl-items">
<section id="associatedtype.Output-5" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Output = Poll&lt;Option&lt;T&gt;&gt;</h4></section><section id="associatedtype.Residual-5" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Residual = Result&lt;Infallible, E&gt;</h4></section>
</div>
<summary><section id="impl-Try-5" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/task/poll.rs.html#260-277">source</a></span><h3 class="code-header in-band">impl&lt;T, E&gt; Try for Poll&lt;Result&lt;T, E&gt;&gt;</h3></section></summary><div class="impl-items">
<section id="associatedtype.Output-6" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Output = Poll&lt;T&gt;</h4></section><section id="associatedtype.Residual-6" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Residual = Result&lt;Infallible, E&gt;</h4></section>
</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/ops/trait.Try.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/ops/trait.Try.html</a>
  </p>
</div>
