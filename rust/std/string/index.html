<h1 class="fqn">Module std::string</h1>
<details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock">
<p>A UTF-8â€“encoded, growable string.</p> <p>This module contains the <a href="struct.string" title="String"><code>String</code></a> type, the <a href="trait.tostring" title="ToString"><code>ToString</code></a> trait for converting to strings, and several error types that may result from working with <a href="struct.string" title="String"><code>String</code></a>s.</p> <h2 id="examples" class="section-header">Examples</h2> <p>There are multiple ways to create a new <a href="struct.string" title="String"><code>String</code></a> from a string literal:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "Hello".to_string();

let s = String::from("world");
let s: String = "also this".into();</pre></div> <p>You can create a new <a href="struct.string" title="String"><code>String</code></a> from an existing one by concatenating with <code>+</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "Hello".to_string();

let message = s + " world!";</pre></div> <p>If you have a vector of valid UTF-8 bytes, you can make a <a href="struct.string" title="String"><code>String</code></a> out of it. You can do the reverse too.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let sparkle_heart = vec![240, 159, 146, 150];

// We know these bytes are valid, so we'll use `unwrap()`.
let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();

assert_eq!("ðŸ’–", sparkle_heart);

let bytes = sparkle_heart.into_bytes();

assert_eq!(bytes, [240, 159, 146, 150]);</pre></div> </div></details><h3 id="structs" class="section-header">Structs</h3> <table>
<tr class="module-item">
<td><a class="struct" href="struct.drain" title="std::string::Drain struct">Drain</a></td>
<td class="docblock-short">
<p>A draining iterator for <code>String</code>.</p> </td>
</tr>
<tr class="module-item">
<td><a class="struct" href="struct.fromutf8error" title="std::string::FromUtf8Error struct">FromUtf8Error</a></td>
<td class="docblock-short">
<p>A possible error value when converting a <code>String</code> from a UTF-8 byte vector.</p> </td>
</tr>
<tr class="module-item">
<td><a class="struct" href="struct.fromutf16error" title="std::string::FromUtf16Error struct">FromUtf16Error</a></td>
<td class="docblock-short">
<p>A possible error value when converting a <code>String</code> from a UTF-16 byte slice.</p> </td>
</tr>
<tr class="module-item">
<td><a class="struct" href="struct.string" title="std::string::String struct">String</a></td>
<td class="docblock-short">
<p>A UTF-8â€“encoded, growable string.</p> </td>
</tr>
</table>
<h3 id="traits" class="section-header">Traits</h3> <table><tr class="module-item">
<td><a class="trait" href="trait.tostring" title="std::string::ToString trait">ToString</a></td>
<td class="docblock-short">
<p>A trait for converting a value to a <code>String</code>.</p> </td>
</tr></table>
<h3 id="types" class="section-header">Type Definitions</h3> <table><tr class="module-item">
<td><a class="type" href="type.parseerror" title="std::string::ParseError type">ParseError</a></td>
<td class="docblock-short">
<p>A type alias for <a href="../convert/enum.infallible"><code>Infallible</code></a>.</p> </td>
</tr></table><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/string/index.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/string/index.html</a>
  </p>
</div>
