<h1 class="main-heading">Function std::thread::yield_now</h1>
<pre class="rust fn" data-language="rust">pub fn yield_now()</pre>
<p>Cooperatively gives up a timeslice to the OS scheduler.</p> <p>This calls the underlying OS scheduler’s yield primitive, signaling that the calling thread is willing to give up its remaining timeslice so that the OS may schedule other threads on the CPU.</p> <p>A drawback of yielding in a loop is that if the OS does not have any other ready threads to run on the current CPU, the thread will effectively busy-wait, which wastes CPU time and energy.</p> <p>Therefore, when waiting for events of interest, a programmer’s first choice should be to use synchronization devices such as <a href="../sync/mpsc/index"><code>channel</code></a>s, <a href="../sync/struct.condvar"><code>Condvar</code></a>s, <a href="../sync/struct.mutex"><code>Mutex</code></a>es or <a href="struct.joinhandle#method.join"><code>join</code></a> since these primitives are implemented in a blocking manner, giving up the CPU until the event of interest has occurred which avoids repeated yielding.</p> <p><code>yield_now</code> should thus be used only rarely, mostly in situations where repeated polling is required because there is no other suitable way to learn when an event of interest has occurred.</p> <h2 id="examples">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::thread;

thread::yield_now();</pre></div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/thread/fn.yield_now.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/thread/fn.yield_now.html</a>
  </p>
</div>
