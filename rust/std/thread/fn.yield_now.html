<h1 class="fqn">Function std::thread::yield_now</h1>
<pre class="rust fn" data-language="rust">pub fn yield_now()</pre>
<details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock">
<p>Cooperatively gives up a timeslice to the OS scheduler.</p> <p>This is used when the programmer knows that the thread will have nothing to do for some time, and thus avoid wasting computing time.</p> <p>For example when polling on a resource, it is common to check that it is available, and if not to yield in order to avoid busy waiting.</p> <p>Thus the pattern of <code>yield</code>ing after a failed poll is rather common when implementing low-level shared resources or synchronization primitives.</p> <p>However programmers will usually prefer to use <a href="../sync/mpsc/index"><code>channel</code></a>s, <a href="../sync/struct.condvar"><code>Condvar</code></a>s, <a href="../sync/struct.mutex"><code>Mutex</code></a>es or <a href="struct.joinhandle#method.join"><code>join</code></a> for their synchronization routines, as they avoid thinking about thread scheduling.</p> <p>Note that <a href="../sync/mpsc/index"><code>channel</code></a>s for example are implemented using this primitive. Indeed when you call <code>send</code> or <code>recv</code>, which are blocking, they will yield if the channel is not available.</p> <h2 id="examples" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::thread;

thread::yield_now();</pre></div> </div></details><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/thread/fn.yield_now.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/thread/fn.yield_now.html</a>
  </p>
</div>
