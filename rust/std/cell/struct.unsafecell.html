<h1 class="fqn">Struct std::cell::UnsafeCell</h1>
<pre class="rust struct" data-language="rust">#[repr(transparent)]#[repr(no_niche)]pub struct UnsafeCell&lt;T&gt; where¬†¬†¬†¬†T: ?Sized,¬† { /* fields omitted */ }</pre>
<details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock">
<p>The core primitive for interior mutability in Rust.</p> <p>If you have a reference <code>&amp;T</code>, then normally in Rust the compiler performs optimizations based on the knowledge that <code>&amp;T</code> points to immutable data. Mutating that data, for example through an alias or by transmuting an <code>&amp;T</code> into an <code>&amp;mut T</code>, is considered undefined behavior. <code>UnsafeCell&lt;T&gt;</code> opts-out of the immutability guarantee for <code>&amp;T</code>: a shared reference <code>&amp;UnsafeCell&lt;T&gt;</code> may point to data that is being mutated. This is called ‚Äúinterior mutability‚Äù.</p> <p>All other types that allow internal mutability, such as <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>, internally use <code>UnsafeCell</code> to wrap their data.</p> <p>Note that only the immutability guarantee for shared references is affected by <code>UnsafeCell</code>. The uniqueness guarantee for mutable references is unaffected. There is <em>no</em> legal way to obtain aliasing <code>&amp;mut</code>, not even with <code>UnsafeCell&lt;T&gt;</code>.</p> <p>The <code>UnsafeCell</code> API itself is technically very simple: <a href="struct.unsafecell#method.get"><code>.get()</code></a> gives you a raw pointer <code>*mut T</code> to its contents. It is up to <em>you</em> as the abstraction designer to use that raw pointer correctly.</p> <p>The precise Rust aliasing rules are somewhat in flux, but the main points are not contentious:</p> <ul> <li> <p>If you create a safe reference with lifetime <code>'a</code> (either a <code>&amp;T</code> or <code>&amp;mut T</code> reference) that is accessible by safe code (for example, because you returned it), then you must not access the data in any way that contradicts that reference for the remainder of <code>'a</code>. For example, this means that if you take the <code>*mut T</code> from an <code>UnsafeCell&lt;T&gt;</code> and cast it to an <code>&amp;T</code>, then the data in <code>T</code> must remain immutable (modulo any <code>UnsafeCell</code> data found within <code>T</code>, of course) until that reference‚Äôs lifetime expires. Similarly, if you create a <code>&amp;mut T</code> reference that is released to safe code, then you must not access the data within the <code>UnsafeCell</code> until that reference expires.</p> </li> <li> <p>At all times, you must avoid data races. If multiple threads have access to the same <code>UnsafeCell</code>, then any writes must have a proper happens-before relation to all other accesses (or use atomics).</p> </li> </ul> <p>To assist with proper design, the following scenarios are explicitly declared legal for single-threaded code:</p> <ol> <li> <p>A <code>&amp;T</code> reference can be released to safe code and there it can co-exist with other <code>&amp;T</code> references, but not with a <code>&amp;mut T</code></p> </li> <li> <p>A <code>&amp;mut T</code> reference may be released to safe code provided neither other <code>&amp;mut T</code> nor <code>&amp;T</code> co-exist with it. A <code>&amp;mut T</code> must always be unique.</p> </li> </ol> <p>Note that whilst mutating the contents of an <code>&amp;UnsafeCell&lt;T&gt;</code> (even while other <code>&amp;UnsafeCell&lt;T&gt;</code> references alias the cell) is ok (provided you enforce the above invariants some other way), it is still undefined behavior to have multiple <code>&amp;mut UnsafeCell&lt;T&gt;</code> aliases. That is, <code>UnsafeCell</code> is a wrapper designed to have a special interaction with <em>shared</em> accesses (<em>i.e.</em>, through an <code>&amp;UnsafeCell&lt;_&gt;</code> reference); there is no magic whatsoever when dealing with <em>exclusive</em> accesses (<em>e.g.</em>, through an <code>&amp;mut UnsafeCell&lt;_&gt;</code>): neither the cell nor the wrapped value may be aliased for the duration of that <code>&amp;mut</code> borrow. This is showcased by the <a href="struct.unsafecell#method.get_mut"><code>.get_mut()</code></a> accessor, which is a <em>safe</em> getter that yields a <code>&amp;mut T</code>.</p> <h2 id="examples" class="section-header">Examples</h2> <p>Here is an example showcasing how to soundly mutate the contents of an <code>UnsafeCell&lt;_&gt;</code> despite there being multiple references aliasing the cell:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::cell::UnsafeCell;

let x: UnsafeCell&lt;i32&gt; = 42.into();
// Get multiple / concurrent / shared references to the same `x`.
let (p1, p2): (&amp;UnsafeCell&lt;i32&gt;, &amp;UnsafeCell&lt;i32&gt;) = (&amp;x, &amp;x);

unsafe {
    // SAFETY: within this scope there are no other references to `x`'s contents,
    // so ours is effectively unique.
    let p1_exclusive: &amp;mut i32 = &amp;mut *p1.get(); // -- borrow --+
    *p1_exclusive += 27; //                                     |
} // &lt;---------- cannot go beyond this point -------------------+

unsafe {
    // SAFETY: within this scope nobody expects to have exclusive access to `x`'s contents,
    // so we can have multiple shared accesses concurrently.
    let p2_shared: &amp;i32 = &amp;*p2.get();
    assert_eq!(*p2_shared, 42 + 27);
    let p1_shared: &amp;i32 = &amp;*p1.get();
    assert_eq!(*p1_shared, *p2_shared);
}</pre></div> <p>The following example showcases the fact that exclusive access to an <code>UnsafeCell&lt;T&gt;</code> implies exclusive access to its <code>T</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![forbid(unsafe_code)] // with exclusive accesses,
                        // `UnsafeCell` is a transparent no-op wrapper,
                        // so no need for `unsafe` here.
use std::cell::UnsafeCell;

let mut x: UnsafeCell&lt;i32&gt; = 42.into();

// Get a compile-time-checked unique reference to `x`.
let p_unique: &amp;mut UnsafeCell&lt;i32&gt; = &amp;mut x;
// With an exclusive reference, we can mutate the contents for free.
*p_unique.get_mut() = 0;
// Or, equivalently:
x = UnsafeCell::new(0);

// When we own the value, we can extract the contents for free.
let contents: i32 = x.into_inner();
assert_eq!(contents, 0);</pre></div> </div></details><h2 id="implementations" class="small-section-header">Implementations</h2>
<details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; UnsafeCell&lt;T&gt;</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1812-1849" title="goto source code">[src]</a>
</div></summary><div class="impl-items">
<details class="rustdoc-toggle method-toggle" open><summary><div id="method.new" class="method has-srclink">
<h4 class="code-header">pub const fn new(value: T) -&gt; UnsafeCell&lt;T&gt;</h4>
<span class="since" title="Stable since Rust version 1.0.0, const since 1.32.0">1.0.0 (const: 1.32.0)</span><a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1828" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Constructs a new instance of <code>UnsafeCell</code> which will wrap the specified value.</p> <p>All access to the inner value through methods is <code>unsafe</code>.</p> <h2 id="examples-1" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::cell::UnsafeCell;

let uc = UnsafeCell::new(5);</pre></div> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into_inner" class="method has-srclink">
<h4 class="code-header">pub const fn into_inner(self) -&gt; T</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1846" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Unwraps the value.</p> <h2 id="examples-2" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::cell::UnsafeCell;

let uc = UnsafeCell::new(5);

let five = uc.into_inner();</pre></div> </div></details>
</div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-1" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; UnsafeCell&lt;T&gt; <span class="where fmt-newline">where<br> T: ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1851-1934" title="goto source code">[src]</a>
</div></summary><div class="impl-items">
<details class="rustdoc-toggle method-toggle" open><summary><div id="method.get" class="method has-srclink">
<h4 class="code-header">pub const fn get(&amp;self) -&gt; *mut T</h4>
<span class="since" title="Stable since Rust version 1.0.0, const since 1.32.0">1.0.0 (const: 1.32.0)</span><a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1871" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Gets a mutable pointer to the wrapped value.</p> <p>This can be cast to a pointer of any kind. Ensure that the access is unique (no active references, mutable or not) when casting to <code>&amp;mut T</code>, and ensure that there are no mutations or mutable aliases going on when casting to <code>&amp;T</code></p> <h2 id="examples-3" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::cell::UnsafeCell;

let uc = UnsafeCell::new(5);

let five = uc.get();</pre></div> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_mut" class="method has-srclink">
<h4 class="code-header">pub fn get_mut(&amp;mut self) -&gt; &amp;mut T</h4>
<span class="since" title="Stable since Rust version 1.50.0">1.50.0</span><a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1895" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Returns a mutable reference to the underlying data.</p> <p>This call borrows the <code>UnsafeCell</code> mutably (at compile-time) which guarantees that we possess the only reference.</p> <h2 id="examples-4" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::cell::UnsafeCell;

let mut c = UnsafeCell::new(5);
*c.get_mut() += 1;

assert_eq!(*c.get_mut(), 6);</pre></div> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.raw_get" class="method has-srclink">
<h4 class="code-header">pub const fn raw_get(this: *const UnsafeCell&lt;T&gt;) -&gt; *mut T</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1928" title="goto source code">[src]</a>
</div>
<div class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span> This is a nightly-only experimental API. (<code>unsafe_cell_raw_get</code> <a href="https://github.com/rust-lang/rust/issues/66358">#66358</a>)</div></div></summary><div class="docblock">
<p>Gets a mutable pointer to the wrapped value. The difference to <a href="struct.unsafecell#method.get"><code>get</code></a> is that this function accepts a raw pointer, which is useful to avoid the creation of temporary references.</p> <p>The result can be cast to a pointer of any kind. Ensure that the access is unique (no active references, mutable or not) when casting to <code>&amp;mut T</code>, and ensure that there are no mutations or mutable aliases going on when casting to <code>&amp;T</code>.</p> <h2 id="examples-5" class="section-header">Examples</h2> <p>Gradual initialization of an <code>UnsafeCell</code> requires <code>raw_get</code>, as calling <code>get</code> would require creating a reference to uninitialized data:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(unsafe_cell_raw_get)]
use std::cell::UnsafeCell;
use std::mem::MaybeUninit;

let m = MaybeUninit::&lt;UnsafeCell&lt;i32&gt;&gt;::uninit();
unsafe { UnsafeCell::raw_get(m.as_ptr()).write(5); }
let uc = unsafe { m.assume_init() };

assert_eq!(uc.into_inner(), 5);</pre></div> </div></details>
</div></details><h2 id="trait-implementations" class="small-section-header">Trait Implementations</h2>
<div id="trait-implementations-list">
<details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Debug" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; Debug for UnsafeCell&lt;T&gt; <span class="where fmt-newline">where<br> T: ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#2290-2294" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span>
</div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.fmt" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#2291" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Formats the value using the given formatter. <a href="../fmt/trait.debug#tymethod.fmt">Read more</a></p> </div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Default" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; Default for UnsafeCell&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../default/trait.default" title="trait std::default::Default">Default</a>, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1937-1942" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.10.0">1.10.0</span>
</div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.default" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn default() -&gt; UnsafeCell&lt;T&gt;</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1939" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Creates an <code>UnsafeCell</code>, with the <code>Default</code> value for T.</p> </div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-From%3CT%3E" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; From&lt;T&gt; for UnsafeCell&lt;T&gt;</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1945-1949" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span>
</div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn from(t: T) -&gt; UnsafeCell&lt;T&gt;</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1946" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Performs the conversion.</p> </div></details></div></details><div id="impl-CoerceUnsized%3CUnsafeCell%3CU%3E%3E" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T, U&gt; CoerceUnsized&lt;UnsafeCell&lt;U&gt;&gt; for UnsafeCell&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../ops/trait.coerceunsized" title="trait std::ops::CoerceUnsized">CoerceUnsized</a>&lt;U&gt;, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1952" title="goto source code">[src]</a>
</div>
<div id="impl-RefUnwindSafe" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T: ?Sized&gt; !RefUnwindSafe for UnsafeCell&lt;T&gt;</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/std/panic.rs.html#261" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span>
</div>
<div id="impl-Sync" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; !Sync for UnsafeCell&lt;T&gt; <span class="where fmt-newline">where<br> T: ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1810" title="goto source code">[src]</a>
</div>
</div>
<h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations</h2>
<div id="synthetic-implementations-list">
<div id="impl-Send" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T: ?Sized&gt; Send for UnsafeCell&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../marker/trait.send" title="trait std::marker::Send">Send</a>, </span>
</h3>

</div>
<div id="impl-Unpin" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T: ?Sized&gt; Unpin for UnsafeCell&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../marker/trait.unpin" title="trait std::marker::Unpin">Unpin</a>, </span>
</h3>

</div>
<div id="impl-UnwindSafe" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T: ?Sized&gt; UnwindSafe for UnsafeCell&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../panic/trait.unwindsafe" title="trait std::panic::UnwindSafe">UnwindSafe</a>, </span>
</h3>

</div>
</div>
<h2 id="blanket-implementations" class="small-section-header">Blanket Implementations</h2>
<div id="blanket-implementations-list">
<details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Any" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; Any for T <span class="where fmt-newline">where<br> T: 'static + ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/any.rs.html#131-135" title="goto source code">[src]</a>
</div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.type_id" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn type_id(&amp;self) -&gt; TypeId</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/core/any.rs.html#132" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Gets the <code>TypeId</code> of <code>self</code>. <a href="../any/trait.any#tymethod.type_id">Read more</a></p> </div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Borrow%3CT%3E" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; Borrow&lt;T&gt; for T <span class="where fmt-newline">where<br> T: ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#208-213" title="goto source code">[src]</a>
</div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn borrow(&amp;self) -&gt; &amp;T</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#210" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Immutably borrows from an owned value. <a href="../borrow/trait.borrow#tymethod.borrow">Read more</a></p> </div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-BorrowMut%3CT%3E" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; BorrowMut&lt;T&gt; for T <span class="where fmt-newline">where<br> T: ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#216-220" title="goto source code">[src]</a>
</div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow_mut" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn borrow_mut(&amp;mut self) -&gt; &amp;mut T</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#217" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Mutably borrows from an owned value. <a href="../borrow/trait.borrowmut#tymethod.borrow_mut">Read more</a></p> </div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-From%3C!%3E" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; From&lt;!&gt; for T</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#559-563" title="goto source code">[src]</a>
</div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from-2" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn from(t: !) -&gt; T</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#560" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Performs the conversion.</p> </div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-From%3CT%3E-1" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; From&lt;T&gt; for T</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#544-548" title="goto source code">[src]</a>
</div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from-1" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn from(t: T) -&gt; T</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#545" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Performs the conversion.</p> </div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Into%3CU%3E" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T, U&gt; Into&lt;U&gt; for T <span class="where fmt-newline">where<br> U: <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;T&gt;, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#533-540" title="goto source code">[src]</a>
</div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn into(self) -&gt; U</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#537" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Performs the conversion.</p> </div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-TryFrom%3CU%3E" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T, U&gt; TryFrom&lt;U&gt; for T <span class="where fmt-newline">where<br> U: <a class="trait" href="../convert/trait.into" title="trait std::convert::Into">Into</a>&lt;T&gt;, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#581-590" title="goto source code">[src]</a>
</div></summary><div class="impl-items">
<details class="rustdoc-toggle" open><summary><div id="associatedtype.Error" class="type trait-impl has-srclink">
<h4 class="code-header">type Error = Infallible</h4>

</div></summary><div class="docblock">
<p>The type returned in the event of a conversion error.</p> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_from" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn try_from(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#587" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Performs the conversion.</p> </div></details>
</div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-TryInto%3CU%3E" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T, U&gt; TryInto&lt;U&gt; for T <span class="where fmt-newline">where<br> U: <a class="trait" href="../convert/trait.tryfrom" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#567-576" title="goto source code">[src]</a>
</div></summary><div class="impl-items">
<details class="rustdoc-toggle" open><summary><div id="associatedtype.Error-1" class="type trait-impl has-srclink">
<h4 class="code-header">type Error = &lt;U as TryFrom&lt;T&gt;&gt;::Error</h4>

</div></summary><div class="docblock">
<p>The type returned in the event of a conversion error.</p> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_into" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn try_into(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#573" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Performs the conversion.</p> </div></details>
</div></details>
</div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html</a>
  </p>
</div>
