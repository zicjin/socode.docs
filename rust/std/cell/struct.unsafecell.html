<h1 class="main-heading">Struct std::cell::UnsafeCell</h1>
<pre class="rust struct" data-language="rust">#[repr(transparent)]#[repr(no_niche)]pub struct UnsafeCell&lt;T&gt; where    T: ?Sized,  { /* private fields */ }</pre>
<p>The core primitive for interior mutability in Rust.</p> <p>If you have a reference <code>&amp;T</code>, then normally in Rust the compiler performs optimizations based on the knowledge that <code>&amp;T</code> points to immutable data. Mutating that data, for example through an alias or by transmuting an <code>&amp;T</code> into an <code>&amp;mut T</code>, is considered undefined behavior. <code>UnsafeCell&lt;T&gt;</code> opts-out of the immutability guarantee for <code>&amp;T</code>: a shared reference <code>&amp;UnsafeCell&lt;T&gt;</code> may point to data that is being mutated. This is called “interior mutability”.</p> <p>All other types that allow internal mutability, such as <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>, internally use <code>UnsafeCell</code> to wrap their data.</p> <p>Note that only the immutability guarantee for shared references is affected by <code>UnsafeCell</code>. The uniqueness guarantee for mutable references is unaffected. There is <em>no</em> legal way to obtain aliasing <code>&amp;mut</code>, not even with <code>UnsafeCell&lt;T&gt;</code>.</p> <p>The <code>UnsafeCell</code> API itself is technically very simple: <a href="struct.unsafecell#method.get"><code>.get()</code></a> gives you a raw pointer <code>*mut T</code> to its contents. It is up to <em>you</em> as the abstraction designer to use that raw pointer correctly.</p> <p>The precise Rust aliasing rules are somewhat in flux, but the main points are not contentious:</p> <ul> <li> <p>If you create a safe reference with lifetime <code>'a</code> (either a <code>&amp;T</code> or <code>&amp;mut T</code> reference) that is accessible by safe code (for example, because you returned it), then you must not access the data in any way that contradicts that reference for the remainder of <code>'a</code>. For example, this means that if you take the <code>*mut T</code> from an <code>UnsafeCell&lt;T&gt;</code> and cast it to an <code>&amp;T</code>, then the data in <code>T</code> must remain immutable (modulo any <code>UnsafeCell</code> data found within <code>T</code>, of course) until that reference’s lifetime expires. Similarly, if you create a <code>&amp;mut T</code> reference that is released to safe code, then you must not access the data within the <code>UnsafeCell</code> until that reference expires.</p> </li> <li> <p>At all times, you must avoid data races. If multiple threads have access to the same <code>UnsafeCell</code>, then any writes must have a proper happens-before relation to all other accesses (or use atomics).</p> </li> </ul> <p>To assist with proper design, the following scenarios are explicitly declared legal for single-threaded code:</p> <ol> <li> <p>A <code>&amp;T</code> reference can be released to safe code and there it can co-exist with other <code>&amp;T</code> references, but not with a <code>&amp;mut T</code></p> </li> <li> <p>A <code>&amp;mut T</code> reference may be released to safe code provided neither other <code>&amp;mut T</code> nor <code>&amp;T</code> co-exist with it. A <code>&amp;mut T</code> must always be unique.</p> </li> </ol> <p>Note that whilst mutating the contents of an <code>&amp;UnsafeCell&lt;T&gt;</code> (even while other <code>&amp;UnsafeCell&lt;T&gt;</code> references alias the cell) is ok (provided you enforce the above invariants some other way), it is still undefined behavior to have multiple <code>&amp;mut UnsafeCell&lt;T&gt;</code> aliases. That is, <code>UnsafeCell</code> is a wrapper designed to have a special interaction with <em>shared</em> accesses (<em>i.e.</em>, through an <code>&amp;UnsafeCell&lt;_&gt;</code> reference); there is no magic whatsoever when dealing with <em>exclusive</em> accesses (<em>e.g.</em>, through an <code>&amp;mut UnsafeCell&lt;_&gt;</code>): neither the cell nor the wrapped value may be aliased for the duration of that <code>&amp;mut</code> borrow. This is showcased by the <a href="struct.unsafecell#method.get_mut"><code>.get_mut()</code></a> accessor, which is a <em>safe</em> getter that yields a <code>&amp;mut T</code>.</p> <h2 id="examples">Examples</h2> <p>Here is an example showcasing how to soundly mutate the contents of an <code>UnsafeCell&lt;_&gt;</code> despite there being multiple references aliasing the cell:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::cell::UnsafeCell;

let x: UnsafeCell&lt;i32&gt; = 42.into();
// Get multiple / concurrent / shared references to the same `x`.
let (p1, p2): (&amp;UnsafeCell&lt;i32&gt;, &amp;UnsafeCell&lt;i32&gt;) = (&amp;x, &amp;x);

unsafe {
    // SAFETY: within this scope there are no other references to `x`'s contents,
    // so ours is effectively unique.
    let p1_exclusive: &amp;mut i32 = &amp;mut *p1.get(); // -- borrow --+
    *p1_exclusive += 27; //                                     |
} // &lt;---------- cannot go beyond this point -------------------+

unsafe {
    // SAFETY: within this scope nobody expects to have exclusive access to `x`'s contents,
    // so we can have multiple shared accesses concurrently.
    let p2_shared: &amp;i32 = &amp;*p2.get();
    assert_eq!(*p2_shared, 42 + 27);
    let p1_shared: &amp;i32 = &amp;*p1.get();
    assert_eq!(*p1_shared, *p2_shared);
}</pre></div> <p>The following example showcases the fact that exclusive access to an <code>UnsafeCell&lt;T&gt;</code> implies exclusive access to its <code>T</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![forbid(unsafe_code)] // with exclusive accesses,
                        // `UnsafeCell` is a transparent no-op wrapper,
                        // so no need for `unsafe` here.
use std::cell::UnsafeCell;

let mut x: UnsafeCell&lt;i32&gt; = 42.into();

// Get a compile-time-checked unique reference to `x`.
let p_unique: &amp;mut UnsafeCell&lt;i32&gt; = &amp;mut x;
// With an exclusive reference, we can mutate the contents for free.
*p_unique.get_mut() = 0;
// Or, equivalently:
x = UnsafeCell::new(0);

// When we own the value, we can extract the contents for free.
let contents: i32 = x.into_inner();
assert_eq!(contents, 0);</pre></div> <h2 id="implementations" class="small-section-header">Implementations</h2>
<div id="implementations-list">
<summary><section id="impl" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1848-1885">source</a></span><h3 class="code-header in-band">impl&lt;T&gt; UnsafeCell&lt;T&gt;</h3></section></summary><div class="impl-items">
<summary><section id="method.new" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1864">source</a><span class="since" title="const since 1.32.0">const: 1.32.0</span> · </span><h4 class="code-header">pub const fn new(value: T) -&gt; UnsafeCell&lt;T&gt;</h4></section></summary><div class="docblock">
<p>Constructs a new instance of <code>UnsafeCell</code> which will wrap the specified value.</p> <p>All access to the inner value through methods is <code>unsafe</code>.</p> <h5 id="examples-1">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::cell::UnsafeCell;

let uc = UnsafeCell::new(5);</pre></div> </div>
<summary><section id="method.into_inner" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1882">source</a><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/78729" title="Tracking issue for const_cell_into_inner">unstable</a></span> · </span><h4 class="code-header">pub fn into_inner(self) -&gt; T</h4></section></summary><div class="docblock">
<p>Unwraps the value.</p> <h5 id="examples-2">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::cell::UnsafeCell;

let uc = UnsafeCell::new(5);

let five = uc.into_inner();</pre></div> </div>
</div>
<summary><section id="impl-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1887-1971">source</a></span><h3 class="code-header in-band">impl&lt;T&gt; UnsafeCell&lt;T&gt; <span class="where fmt-newline">where<br> T: ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span>
</h3></section></summary><div class="impl-items">
<summary><section id="method.get" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1907">source</a><span class="since" title="const since 1.32.0">const: 1.32.0</span> · </span><h4 class="code-header">pub const fn get(&amp;self) -&gt; *mut T</h4></section></summary><div class="docblock">
<p>Gets a mutable pointer to the wrapped value.</p> <p>This can be cast to a pointer of any kind. Ensure that the access is unique (no active references, mutable or not) when casting to <code>&amp;mut T</code>, and ensure that there are no mutations or mutable aliases going on when casting to <code>&amp;T</code></p> <h5 id="examples-3">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::cell::UnsafeCell;

let uc = UnsafeCell::new(5);

let five = uc.get();</pre></div> </div>
<summary><section id="method.get_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1932">source</a><span class="since" title="Stable since Rust version 1.50.0, const unstable">1.50.0 (const: <a href="https://github.com/rust-lang/rust/issues/88836" title="Tracking issue for const_unsafecell_get_mut">unstable</a>)</span> · </span><h4 class="code-header">pub fn get_mut(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class="docblock">
<p>Returns a mutable reference to the underlying data.</p> <p>This call borrows the <code>UnsafeCell</code> mutably (at compile-time) which guarantees that we possess the only reference.</p> <h5 id="examples-4">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::cell::UnsafeCell;

let mut c = UnsafeCell::new(5);
*c.get_mut() += 1;

assert_eq!(*c.get_mut(), 6);</pre></div> </div>
<summary><section id="method.raw_get" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1965">source</a><span class="since" title="Stable since Rust version 1.56.0, const since 1.56.0">1.56.0 (const: 1.56.0)</span> · </span><h4 class="code-header">pub const fn raw_get(this: *const UnsafeCell&lt;T&gt;) -&gt; *mut T</h4></section></summary><div class="docblock">
<p>Gets a mutable pointer to the wrapped value. The difference from <a href="struct.unsafecell#method.get"><code>get</code></a> is that this function accepts a raw pointer, which is useful to avoid the creation of temporary references.</p> <p>The result can be cast to a pointer of any kind. Ensure that the access is unique (no active references, mutable or not) when casting to <code>&amp;mut T</code>, and ensure that there are no mutations or mutable aliases going on when casting to <code>&amp;T</code>.</p> <h5 id="examples-5">Examples</h5> <p>Gradual initialization of an <code>UnsafeCell</code> requires <code>raw_get</code>, as calling <code>get</code> would require creating a reference to uninitialized data:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::cell::UnsafeCell;
use std::mem::MaybeUninit;

let m = MaybeUninit::&lt;UnsafeCell&lt;i32&gt;&gt;::uninit();
unsafe { UnsafeCell::raw_get(m.as_ptr()).write(5); }
let uc = unsafe { m.assume_init() };

assert_eq!(uc.into_inner(), 5);</pre></div> </div>
</div>
</div>
<h2 id="trait-implementations" class="small-section-header">Trait Implementations</h2>
<div id="trait-implementations-list">
<summary><section id="impl-Debug" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#2399-2403">source</a><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span> · </span><h3 class="code-header in-band">impl&lt;T&gt; Debug for UnsafeCell&lt;T&gt; <span class="where fmt-newline">where<br> T: ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span>
</h3></section></summary><div class="impl-items">
<summary><section id="method.fmt" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#2400">source</a></span><h4 class="code-header">fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</h4></section></summary><div class="docblock">
<p>Formats the value using the given formatter. <a href="../fmt/trait.debug#tymethod.fmt">Read more</a></p> </div>
</div>
<summary><section id="impl-Default" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1974-1979">source</a><span class="since" title="Stable since Rust version 1.10.0">1.10.0</span> · </span><h3 class="code-header in-band">impl&lt;T&gt; Default for UnsafeCell&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../default/trait.default" title="trait std::default::Default">Default</a>, </span>
</h3></section></summary><div class="impl-items">
<summary><section id="method.default" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1976">source</a></span><h4 class="code-header">fn default() -&gt; UnsafeCell&lt;T&gt;</h4></section></summary><div class="docblock">
<p>Creates an <code>UnsafeCell</code>, with the <code>Default</code> value for T.</p> </div>
</div>
<summary><section id="impl-From%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1983-1988">source</a><span class="since" title="Stable since Rust version 1.12.0, const unstable">1.12.0 (const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a>)</span> · </span><h3 class="code-header in-band">impl&lt;T&gt; From&lt;T&gt; for UnsafeCell&lt;T&gt;</h3></section></summary><div class="impl-items">
<summary><section id="method.from" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1985">source</a><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · </span><h4 class="code-header">fn from(t: T) -&gt; UnsafeCell&lt;T&gt;</h4></section></summary><div class="docblock">
<p>Creates a new <code>UnsafeCell&lt;T&gt;</code> containing the given value.</p> </div>
</div>
<section id="impl-CoerceUnsized%3CUnsafeCell%3CU%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1991">source</a></span><h3 class="code-header in-band">impl&lt;T, U&gt; CoerceUnsized&lt;UnsafeCell&lt;U&gt;&gt; for UnsafeCell&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../ops/trait.coerceunsized" title="trait std::ops::CoerceUnsized">CoerceUnsized</a>&lt;U&gt;, </span>
</h3></section><section id="impl-RefUnwindSafe" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/panic/unwind_safe.rs.html#200">source</a><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span> · </span><h3 class="code-header in-band">impl&lt;T&gt; !RefUnwindSafe for UnsafeCell&lt;T&gt; <span class="where fmt-newline">where<br> T: ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span>
</h3></section><section id="impl-Sync" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/cell.rs.html#1846">source</a></span><h3 class="code-header in-band">impl&lt;T&gt; !Sync for UnsafeCell&lt;T&gt; <span class="where fmt-newline">where<br> T: ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span>
</h3></section>
</div>
<h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations</h2>
<div id="synthetic-implementations-list">
<section id="impl-Send" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T: ?Sized&gt; Send for UnsafeCell&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../marker/trait.send" title="trait std::marker::Send">Send</a>, </span>
</h3></section><section id="impl-Unpin" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T: ?Sized&gt; Unpin for UnsafeCell&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../marker/trait.unpin" title="trait std::marker::Unpin">Unpin</a>, </span>
</h3></section><section id="impl-UnwindSafe" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T: ?Sized&gt; UnwindSafe for UnsafeCell&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../panic/trait.unwindsafe" title="trait std::panic::UnwindSafe">UnwindSafe</a>, </span>
</h3></section>
</div>
<h2 id="blanket-implementations" class="small-section-header">Blanket Implementations</h2>
<div id="blanket-implementations-list">
<summary><section id="impl-Any" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/any.rs.html#132-136">source</a></span><h3 class="code-header in-band">impl&lt;T&gt; Any for T <span class="where fmt-newline">where<br> T: 'static + ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span>
</h3></section></summary><div class="impl-items">
<summary><section id="method.type_id" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/any.rs.html#133">source</a></span><h4 class="code-header">fn type_id(&amp;self) -&gt; TypeId</h4></section></summary><div class="docblock">
<p>Gets the <code>TypeId</code> of <code>self</code>. <a href="../any/trait.any#tymethod.type_id">Read more</a></p> </div>
</div>
<summary><section id="impl-Borrow%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#209-214">source</a></span><h3 class="code-header in-band">impl&lt;T&gt; Borrow&lt;T&gt; for T <span class="where fmt-newline">where<br> T: ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span>
</h3></section></summary><div class="impl-items">
<summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#211">source</a><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · </span><h4 class="code-header">fn borrow(&amp;self) -&gt; &amp;T</h4></section></summary><div class="docblock">
<p>Immutably borrows from an owned value. <a href="../borrow/trait.borrow#tymethod.borrow">Read more</a></p> </div>
</div>
<summary><section id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#218-222">source</a></span><h3 class="code-header in-band">impl&lt;T&gt; BorrowMut&lt;T&gt; for T <span class="where fmt-newline">where<br> T: ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span>
</h3></section></summary><div class="impl-items">
<summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#219">source</a><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · </span><h4 class="code-header">fn borrow_mut(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class="docblock">
<p>Mutably borrows from an owned value. <a href="../borrow/trait.borrowmut#tymethod.borrow_mut">Read more</a></p> </div>
</div>
<summary><section id="impl-From%3C!%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#574-578">source</a></span><h3 class="code-header in-band">impl&lt;T&gt; From&lt;!&gt; for T</h3></section></summary><div class="impl-items">
<summary><section id="method.from-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#575">source</a><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · </span><h4 class="code-header">fn from(t: !) -&gt; T</h4></section></summary><div class="docblock">
<p>Converts to this type from the input type.</p> </div>
</div>
<summary><section id="impl-From%3CT%3E-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#557-562">source</a></span><h3 class="code-header in-band">impl&lt;T&gt; From&lt;T&gt; for T</h3></section></summary><div class="impl-items">
<summary><section id="method.from-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#559">source</a><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · </span><h4 class="code-header">fn from(t: T) -&gt; T</h4></section></summary><div class="docblock">
<p>Returns the argument unchanged.</p> </div>
</div>
<summary><section id="impl-Into%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#541-552">source</a></span><h3 class="code-header in-band">impl&lt;T, U&gt; Into&lt;U&gt; for T <span class="where fmt-newline">where<br> U: <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;T&gt;, </span>
</h3></section></summary><div class="impl-items">
<summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#549">source</a><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · </span><h4 class="code-header">fn into(self) -&gt; U</h4></section></summary><div class="docblock">
<p>Calls <code>U::from(self)</code>.</p> <p>That is, this conversion is whatever the implementation of <code><a href="../convert/trait.from" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p> </div>
</div>
<summary><section id="impl-TryFrom%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#598-607">source</a></span><h3 class="code-header in-band">impl&lt;T, U&gt; TryFrom&lt;U&gt; for T <span class="where fmt-newline">where<br> U: <a class="trait" href="../convert/trait.into" title="trait std::convert::Into">Into</a>&lt;T&gt;, </span>
</h3></section></summary><div class="impl-items">
<summary><section id="associatedtype.Error-1" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Error = Infallible</h4></section></summary><div class="docblock">
<p>The type returned in the event of a conversion error.</p> </div>
<summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#604">source</a><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · </span><h4 class="code-header">fn try_from(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</h4></section></summary><div class="docblock">
<p>Performs the conversion.</p> </div>
</div>
<summary><section id="impl-TryInto%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#583-592">source</a></span><h3 class="code-header in-band">impl&lt;T, U&gt; TryInto&lt;U&gt; for T <span class="where fmt-newline">where<br> U: <a class="trait" href="../convert/trait.tryfrom" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;, </span>
</h3></section></summary><div class="impl-items">
<summary><section id="associatedtype.Error" class="associatedtype trait-impl has-srclink"><h4 class="code-header">type Error = &lt;U as TryFrom&lt;T&gt;&gt;::Error</h4></section></summary><div class="docblock">
<p>The type returned in the event of a conversion error.</p> </div>
<summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#589">source</a><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · </span><h4 class="code-header">fn try_into(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</h4></section></summary><div class="docblock">
<p>Performs the conversion.</p> </div>
</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html</a>
  </p>
</div>
