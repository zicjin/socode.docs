<h1 class="main-heading">Macro std::pin::pin</h1>
<div class="example-wrap"><pre class="rust macro" data-language="rust">pub macro pin($value:expr $(,)?) {
    ...
}</pre></div> <span class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span> This is a nightly-only experimental API. (<code>pin_macro</code> <a href="https://github.com/rust-lang/rust/issues/93178">#93178</a>)</div></span><p>Constructs a <code><a href="struct.pin" title="Pin">Pin</a>&lt;<a href="../primitive.reference" title="&amp;mut">&amp;mut</a> T&gt;</code>, by pinning<sup id="fnref1"><a href="#fn1">1</a></sup> a <code>value: T</code> <em>locally</em><sup id="fnref2"><a href="#fn2">2</a></sup>.</p> <p>Unlike <a href="../boxed/struct.box#method.pin"><code>Box::pin</code></a>, this does not involve a heap allocation.</p> <h3 id="examples">Examples</h3>
<h4 id="basic-usage">Basic usage</h4> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(pin_macro)]
use core::pin::{pin, Pin};

fn stuff(foo: Pin&lt;&amp;mut Foo&gt;) {
    // ‚Ä¶
}

let pinned_foo = pin!(Foo { /* ‚Ä¶ */ });
stuff(pinned_foo);
// or, directly:
stuff(pin!(Foo { /* ‚Ä¶ */ }));</pre></div> <h4 id="manually-polling-a-future-without-unpin-bounds">Manually polling a <code>Future</code> (without <code>Unpin</code> bounds)</h4> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(pin_macro)]
use std::{
    future::Future,
    pin::pin,
    task::{Context, Poll},
    thread,
};

/// Runs a future to completion.
fn block_on&lt;Fut: Future&gt;(fut: Fut) -&gt; Fut::Output {
    let waker_that_unparks_thread = // ‚Ä¶
    let mut cx = Context::from_waker(&amp;waker_that_unparks_thread);
    // Pin the future so it can be polled.
    let mut pinned_fut = pin!(fut);
    loop {
        match pinned_fut.as_mut().poll(&amp;mut cx) {
            Poll::Pending =&gt; thread::park(),
            Poll::Ready(res) =&gt; return res,
        }
    }
}</pre></div> <h4 id="with-generators">With <code>Generator</code>s</h4> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(generators, generator_trait, pin_macro)]
use core::{
    ops::{Generator, GeneratorState},
    pin::pin,
};

fn generator_fn() -&gt; impl Generator&lt;Yield = usize, Return = ()&gt; /* not Unpin */ {
 // Allow generator to be self-referential (not `Unpin`)
 // vvvvvv        so that locals can cross yield points.
    static || {
        let foo = String::from("foo"); // --+
        yield 0;                         // | &lt;- crosses yield point!
        println!("{}", &amp;foo); // &lt;----------+
        yield foo.len();
    }
}

fn main() {
    let mut generator = pin!(generator_fn());
    match generator.as_mut().resume(()) {
        GeneratorState::Yielded(0) =&gt; {},
        _ =&gt; unreachable!(),
    }
    match generator.as_mut().resume(()) {
        GeneratorState::Yielded(3) =&gt; {},
        _ =&gt; unreachable!(),
    }
    match generator.resume(()) {
        GeneratorState::Yielded(_) =&gt; unreachable!(),
        GeneratorState::Complete(()) =&gt; {},
    }
}</pre></div> <h3 id="remarks">Remarks</h3> <p>Precisely because a value is pinned to local storage, the resulting <code><a href="struct.pin" title="Pin">Pin</a>&lt;<a href="../primitive.reference" title="&amp;mut">&amp;mut</a> T&gt;</code> reference ends up borrowing a local tied to that block: it can‚Äôt escape it.</p> <p>The following, for instance, fails to compile:</p> <div class="information">‚ìò This example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">#![feature(pin_macro)]
use core::pin::{pin, Pin};

let x: Pin&lt;&amp;mut Foo&gt; = {
    let x: Pin&lt;&amp;mut Foo&gt; = pin!(Foo { /* ‚Ä¶ */ });
    x
}; // &lt;- Foo is dropped
stuff(x); // Error: use of dropped value</pre></div> <summary>Error message</summary> <div class="example-wrap"><pre class="language-console">error[E0716]: temporary value dropped while borrowed
  --&gt; src/main.rs:9:28
   |
8  | let x: Pin&lt;&amp;mut Foo&gt; = {
   |     - borrow later stored here
9  |     let x: Pin&lt;&amp;mut Foo&gt; = pin!(Foo { /* ‚Ä¶ */ });
   |                            ^^^^^^^^^^^^^^^^^^^^^ creates a temporary which is freed while still in use
10 |     x
11 | }; // &lt;- Foo is dropped
   | - temporary value is freed at the end of this statement
   |
   = note: consider using a `let` binding to create a longer lived value</pre></div> <p>This makes <a href="macro.pin" title="pin!"><code>pin!</code></a> <strong>unsuitable to pin values when intending to <em>return</em> them</strong>. Instead, the value is expected to be passed around <em>unpinned</em> until the point where it is to be consumed, where it is then useful and even sensible to pin the value locally using <a href="macro.pin" title="pin!"><code>pin!</code></a>.</p> <p>If you really need to return a pinned value, consider using <a href="../boxed/struct.box#method.pin"><code>Box::pin</code></a> instead.</p> <p>On the other hand, pinning to the stack<a href="#fn2"><sup>2</sup></a> using <a href="macro.pin" title="pin!"><code>pin!</code></a> is likely to be cheaper than pinning into a fresh heap allocation using <a href="../boxed/struct.box#method.pin"><code>Box::pin</code></a>. Moreover, by virtue of not even needing an allocator, <a href="macro.pin" title="pin!"><code>pin!</code></a> is the main non-<code>unsafe</code> <code>#![no_std]</code>-compatible <a href="struct.pin" title="Pin"><code>Pin</code></a> constructor.</p> <div class="footnotes"><ol>
<li id="fn1"><p>If the (type <code>T</code> of the) given value does not implement <a href="../marker/trait.unpin" title="Unpin"><code>Unpin</code></a>, then this effectively pins the <code>value</code> in memory, where it will be unable to be moved. Otherwise, <code><a href="struct.pin" title="Pin">Pin</a>&lt;<a href="../primitive.reference" title="&amp;mut">&amp;mut</a> T&gt;</code> behaves like <code><a href="../primitive.reference" title="&amp;mut">&amp;mut</a> T</code>, and operations such as <a href="../mem/fn.replace" title="crate::mem::replace"><code>mem::replace()</code></a> will allow extracting that value, and therefore, moving it. See <a href="index#unpin" title="self">the <code>Unpin</code> section of the <code>pin</code> module</a> for more info. <a href="#fnref1">‚Ü©</a></p></li>
<li id="fn2"><p>This is usually dubbed ‚Äústack‚Äù-pinning. And whilst local values are almost always located in the stack (<em>e.g.</em>, when within the body of a non-<code>async</code> function), the truth is that inside the body of an <code>async fn</code> or block ‚Äîmore generally, the body of a generator‚Äî any locals crossing an <code>.await</code> point ‚Äîa <code>yield</code> point‚Äî end up being part of the state captured by the <code>Future</code> ‚Äîby the <code>Generator</code>‚Äî, and thus will be stored wherever that one is. <a href="#fnref2">‚Ü©</a></p></li>
</ol></div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/pin/macro.pin.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/pin/macro.pin.html</a>
  </p>
</div>
