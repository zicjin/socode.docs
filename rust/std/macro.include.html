<h1 class="fqn">Macro std::include</h1>
<div class="example-wrap"><pre class="rust macro" data-language="rust">macro_rules! include {
    ($file : expr $(,) ?) =&gt; { ... };
}</pre></div> <p>Parses a file as an expression or an item according to the context.</p> <p>The file is located relative to the current file (similarly to how modules are found). The provided path is interpreted in a platform-specific way at compile time. So, for instance, an invocation with a Windows path containing backslashes <code>\</code> would not compile correctly on Unix.</p> <p>Using this macro is often a bad idea, because if the file is parsed as an expression, it is going to be placed in the surrounding code unhygienically. This could result in variables or functions being different from what the file expected if there are variables or functions that have the same name in the current file.</p> <h3 id="examples" class="section-header">Examples</h3> <p>Assume there are two files in the same directory with the following contents:</p> <p>File ‘monkeys.in’:</p> <div class="information">ⓘ This example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">['🙈', '🙊', '🙉']
    .iter()
    .cycle()
    .take(6)
    .collect::&lt;String&gt;()</pre></div> <p>File ‘main.rs’:</p> <div class="information">ⓘ This example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">fn main() {
    let my_string = include!("monkeys.in");
    assert_eq!("🙈🙊🙉🙈🙊🙉", my_string);
    println!("{}", my_string);
}</pre></div> <p>Compiling ‘main.rs’ and running the resulting binary will print “🙈🙊🙉🙈🙊🙉”.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/macro.include.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/macro.include.html</a>
  </p>
</div>
