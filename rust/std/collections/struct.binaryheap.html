<h1 class="fqn">Struct std::collections::BinaryHeap</h1>
<pre class="rust struct" data-language="rust">pub struct BinaryHeap&lt;T&gt; { /* fields omitted */ }</pre>
<details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock">
<p>A priority queue implemented with a binary heap.</p> <p>This will be a max-heap.</p> <p>It is a logic error for an item to be modified in such a way that the itemâ€™s ordering relative to any other item, as determined by the <code>Ord</code> trait, changes while it is in the heap. This is normally only possible through <code>Cell</code>, <code>RefCell</code>, global state, I/O, or unsafe code. The behavior resulting from such a logic error is not specified, but will not result in undefined behavior. This could include panics, incorrect results, aborts, memory leaks, and non-termination.</p> <h2 id="examples" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;

// Type inference lets us omit an explicit type signature (which
// would be `BinaryHeap&lt;i32&gt;` in this example).
let mut heap = BinaryHeap::new();

// We can use peek to look at the next item in the heap. In this case,
// there's no items in there yet so we get None.
assert_eq!(heap.peek(), None);

// Let's add some scores...
heap.push(1);
heap.push(5);
heap.push(2);

// Now peek shows the most important item in the heap.
assert_eq!(heap.peek(), Some(&amp;5));

// We can check the length of a heap.
assert_eq!(heap.len(), 3);

// We can iterate over the items in the heap, although they are returned in
// a random order.
for x in &amp;heap {
    println!("{}", x);
}

// If we instead pop these scores, they should come back in order.
assert_eq!(heap.pop(), Some(5));
assert_eq!(heap.pop(), Some(2));
assert_eq!(heap.pop(), Some(1));
assert_eq!(heap.pop(), None);

// We can clear the heap of any remaining items.
heap.clear();

// The heap should now be empty.
assert!(heap.is_empty())</pre></div> <h3 id="min-heap" class="section-header">Min-heap</h3> <p>Either <code>std::cmp::Reverse</code> or a custom <code>Ord</code> implementation can be used to make <code>BinaryHeap</code> a min-heap. This makes <code>heap.pop()</code> return the smallest value instead of the greatest one.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
use std::cmp::Reverse;

let mut heap = BinaryHeap::new();

// Wrap values in `Reverse`
heap.push(Reverse(1));
heap.push(Reverse(5));
heap.push(Reverse(2));

// If we pop these scores now, they should come back in the reverse order.
assert_eq!(heap.pop(), Some(Reverse(1)));
assert_eq!(heap.pop(), Some(Reverse(2)));
assert_eq!(heap.pop(), Some(Reverse(5)));
assert_eq!(heap.pop(), None);</pre></div> <h2 id="time-complexity" class="section-header">Time complexity</h2>
<table>
<thead><tr>
<th><a href="struct.binaryheap#method.push">push</a></th>
<th><a href="struct.binaryheap#method.pop">pop</a></th>
<th>
<a href="struct.binaryheap#method.peek">peek</a>/<a href="struct.binaryheap#method.peek_mut">peek_mut</a>
</th>
</tr></thead>
<tbody> <tr>
<td>O(1)~</td>
<td>
<em>O</em>(log(<em>n</em>))</td>
<td>
<em>O</em>(1)</td>
</tr> </tbody>
</table> <p>The value for <code>push</code> is an expected cost; the method documentation gives a more detailed analysis.</p> </div></details><h2 id="implementations" class="small-section-header">Implementations</h2>
<details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; BinaryHeap&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../cmp/trait.ord" title="trait std::cmp::Ord">Ord</a>, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#342-801" title="goto source code">[src]</a>
</div></summary><div class="impl-items">
<details class="rustdoc-toggle method-toggle" open><summary><div id="method.new" class="method has-srclink">
<h4 class="code-header">pub fn new() -&gt; BinaryHeap&lt;T&gt;</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#355" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Creates an empty <code>BinaryHeap</code> as a max-heap.</p> <h2 id="examples-1" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();
heap.push(4);</pre></div> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.with_capacity" class="method has-srclink">
<h4 class="code-header">pub fn with_capacity(capacity: usize) -&gt; BinaryHeap&lt;T&gt;</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#374" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Creates an empty <code>BinaryHeap</code> with a specific capacity. This preallocates enough memory for <code>capacity</code> elements, so that the <code>BinaryHeap</code> does not have to be reallocated until it contains at least that many values.</p> <h2 id="examples-2" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::with_capacity(10);
heap.push(4);</pre></div> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.peek_mut" class="method has-srclink">
<h4 class="code-header">pub fn peek_mut(&amp;mut self) -&gt; Option&lt;PeekMut&lt;'_, T&gt;&gt;</h4>
<span class="since" title="Stable since Rust version 1.12.0">1.12.0</span><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#408" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Returns a mutable reference to the greatest item in the binary heap, or <code>None</code> if it is empty.</p> <p>Note: If the <code>PeekMut</code> value is leaked, the heap may be in an inconsistent state.</p> <h2 id="examples-3" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();
assert!(heap.peek_mut().is_none());

heap.push(1);
heap.push(5);
heap.push(2);
{
    let mut val = heap.peek_mut().unwrap();
    *val = 0;
}
assert_eq!(heap.peek(), Some(&amp;2));</pre></div> <h2 id="time-complexity-1" class="section-header">Time complexity</h2> <p>If the item is modified then the worst case time complexity is <em>O</em>(log(<em>n</em>)), otherwise itâ€™s <em>O</em>(1).</p> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.pop" class="method has-srclink">
<h4 class="code-header">pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt;</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#432" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Removes the greatest item from the binary heap and returns it, or <code>None</code> if it is empty.</p> <h2 id="examples-4" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::from(vec![1, 3]);

assert_eq!(heap.pop(), Some(3));
assert_eq!(heap.pop(), Some(1));
assert_eq!(heap.pop(), None);</pre></div> <h2 id="time-complexity-2" class="section-header">Time complexity</h2> <p>The worst case cost of <code>pop</code> on a heap containing <em>n</em> elements is <em>O</em>(log(<em>n</em>)).</p> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.push" class="method has-srclink">
<h4 class="code-header">pub fn push(&amp;mut self, item: T)</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#476" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Pushes an item onto the binary heap.</p> <h2 id="examples-5" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();
heap.push(3);
heap.push(5);
heap.push(1);

assert_eq!(heap.len(), 3);
assert_eq!(heap.peek(), Some(&amp;5));</pre></div> <h2 id="time-complexity-3" class="section-header">Time complexity</h2> <p>The expected cost of <code>push</code>, averaged over every possible ordering of the elements being pushed, and over a sufficiently large number of pushes, is <em>O</em>(1). This is the most meaningful cost metric when pushing elements that are <em>not</em> already in any sorted pattern.</p> <p>The time complexity degrades if elements are pushed in predominantly ascending order. In the worst case, elements are pushed in ascending sorted order and the amortized cost per push is <em>O</em>(log(<em>n</em>)) against a heap containing <em>n</em> elements.</p> <p>The worst case cost of a <em>single</em> call to <code>push</code> is <em>O</em>(<em>n</em>). The worst case occurs when capacity is exhausted and needs a resize. The resize cost has been amortized in the previous figures.</p> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into_sorted_vec" class="method has-srclink">
<h4 class="code-header">pub fn into_sorted_vec(self) -&gt; Vec&lt;T, Global&gt;</h4>
<span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#502" title="goto source code">[src]</a>
</div>
<span class="notable-traits"><div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="../vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>, A&gt;</div>
<pre class="content">impl&lt;A:Â Allocator&gt; Write for Vec&lt;u8, A&gt;
</pre></span></div></span></summary><div class="docblock">
<p>Consumes the <code>BinaryHeap</code> and returns a vector in sorted (ascending) order.</p> <h2 id="examples-6" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;

let mut heap = BinaryHeap::from(vec![1, 2, 4, 5, 7]);
heap.push(6);
heap.push(3);

let vec = heap.into_sorted_vec();
assert_eq!(vec, [1, 2, 3, 4, 5, 6, 7]);</pre></div> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.append" class="method has-srclink">
<h4 class="code-header">pub fn append(&amp;mut self, other: &amp;mut BinaryHeap&lt;T&gt;)</h4>
<span class="since" title="Stable since Rust version 1.11.0">1.11.0</span><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#724" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Moves all the elements of <code>other</code> into <code>self</code>, leaving <code>other</code> empty.</p> <h2 id="examples-7" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;

let v = vec![-10, 1, 2, 3, 3];
let mut a = BinaryHeap::from(v);

let v = vec![-20, 5, 43];
let mut b = BinaryHeap::from(v);

a.append(&amp;mut b);

assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);
assert!(b.is_empty());</pre></div> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.drain_sorted" class="method has-srclink">
<h4 class="code-header">pub fn drain_sorted(&amp;mut self) -&gt; DrainSorted&lt;'_, T&gt;</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#760" title="goto source code">[src]</a>
</div>
<span class="notable-traits"><div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="binary_heap/struct.drainsorted" title="struct std::collections::binary_heap::DrainSorted">DrainSorted</a>&lt;'_, T&gt;</div>
<pre class="content">impl&lt;'_, T&gt; Iterator for DrainSorted&lt;'_, T&gt; where
Â Â Â Â T: Ord,Â 
    type Item = T;
</pre></span></div></span><div class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span> This is a nightly-only experimental API. (<code>binary_heap_drain_sorted</code> <a href="https://github.com/rust-lang/rust/issues/59278">#59278</a>)</div></div></summary><div class="docblock">
<p>Returns an iterator which retrieves elements in heap order. The retrieved elements are removed from the original heap. The remaining elements will be removed on drop in heap order.</p> <p>Note:</p> <ul> <li>
<code>.drain_sorted()</code> is <em>O</em>(<em>n</em> * log(<em>n</em>)); much slower than <code>.drain()</code>. You should use the latter for most cases.</li> </ul> <h2 id="examples-8" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(binary_heap_drain_sorted)]
use std::collections::BinaryHeap;

let mut heap = BinaryHeap::from(vec![1, 2, 3, 4, 5]);
assert_eq!(heap.len(), 5);

drop(heap.drain_sorted()); // removes all elements in heap order
assert_eq!(heap.len(), 0);</pre></div> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.retain" class="method has-srclink">
<h4 class="code-header">pub fn retain&lt;F&gt;(&amp;mut self, f: F) <span class="where fmt-newline">where<br> F: <a class="trait" href="../ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="../primitive.reference">&amp;</a>T) -&gt; <a class="primitive" href="../primitive.bool">bool</a>, </span>
</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#784-786" title="goto source code">[src]</a>
</div>
<div class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span> This is a nightly-only experimental API. (<code>binary_heap_retain</code> <a href="https://github.com/rust-lang/rust/issues/71503">#71503</a>)</div></div></summary><div class="docblock">
<p>Retains only the elements specified by the predicate.</p> <p>In other words, remove all elements <code>e</code> such that <code>f(&amp;e)</code> returns <code>false</code>. The elements are visited in unsorted (and unspecified) order.</p> <h2 id="examples-9" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(binary_heap_retain)]
use std::collections::BinaryHeap;

let mut heap = BinaryHeap::from(vec![-10, -5, 1, 2, 4, 13]);

heap.retain(|x| x % 2 == 0); // only keep even numbers

assert_eq!(heap.into_sorted_vec(), [-10, 2, 4])</pre></div> </div></details>
</div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-1" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; BinaryHeap&lt;T&gt;</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#803-1112" title="goto source code">[src]</a>
</div></summary><div class="impl-items">
<details class="rustdoc-toggle method-toggle" open><summary><div id="method.iter" class="method has-srclink">
<h4 class="code-header">pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt;</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#821" title="goto source code">[src]</a>
</div>
<span class="notable-traits"><div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="binary_heap/struct.iter" title="struct std::collections::binary_heap::Iter">Iter</a>&lt;'a, T&gt;</div>
<pre class="content">impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt;
    type Item = &amp;'a T;
</pre></span></div></span></summary><div class="docblock">
<p>Returns an iterator visiting all values in the underlying vector, in arbitrary order.</p> <h2 id="examples-10" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let heap = BinaryHeap::from(vec![1, 2, 3, 4]);

// Print 1, 2, 3, 4 in arbitrary order
for x in heap.iter() {
    println!("{}", x);
}</pre></div> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into_iter_sorted" class="method has-srclink">
<h4 class="code-header">pub fn into_iter_sorted(self) -&gt; IntoIterSorted&lt;T&gt;</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#840" title="goto source code">[src]</a>
</div>
<span class="notable-traits"><div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="binary_heap/struct.intoitersorted" title="struct std::collections::binary_heap::IntoIterSorted">IntoIterSorted</a>&lt;T&gt;</div>
<pre class="content">impl&lt;T&gt; Iterator for IntoIterSorted&lt;T&gt; where
Â Â Â Â T: Ord,Â 
    type Item = T;
</pre></span></div></span><div class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span> This is a nightly-only experimental API. (<code>binary_heap_into_iter_sorted</code> <a href="https://github.com/rust-lang/rust/issues/59278">#59278</a>)</div></div></summary><div class="docblock">
<p>Returns an iterator which retrieves elements in heap order. This method consumes the original heap.</p> <h2 id="examples-11" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(binary_heap_into_iter_sorted)]
use std::collections::BinaryHeap;
let heap = BinaryHeap::from(vec![1, 2, 3, 4, 5]);

assert_eq!(heap.into_iter_sorted().take(2).collect::&lt;Vec&lt;_&gt;&gt;(), vec![5, 4]);</pre></div> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.peek" class="method has-srclink">
<h4 class="code-header">pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt;</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#866" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Returns the greatest item in the binary heap, or <code>None</code> if it is empty.</p> <h2 id="examples-12" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();
assert_eq!(heap.peek(), None);

heap.push(1);
heap.push(5);
heap.push(2);
assert_eq!(heap.peek(), Some(&amp;5));
</pre></div> <h2 id="time-complexity-4" class="section-header">Time complexity</h2> <p>Cost is <em>O</em>(1) in the worst case.</p> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.capacity" class="method has-srclink">
<h4 class="code-header">pub fn capacity(&amp;self) -&gt; usize</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#883" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Returns the number of elements the binary heap can hold without reallocating.</p> <h2 id="examples-13" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::with_capacity(100);
assert!(heap.capacity() &gt;= 100);
heap.push(4);</pre></div> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.reserve_exact" class="method has-srclink">
<h4 class="code-header">pub fn reserve_exact(&amp;mut self, additional: usize)</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#912" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Reserves the minimum capacity for exactly <code>additional</code> more elements to be inserted in the given <code>BinaryHeap</code>. Does nothing if the capacity is already sufficient.</p> <p>Note that the allocator may give the collection more space than it requests. Therefore capacity can not be relied upon to be precisely minimal. Prefer <a href="struct.binaryheap#method.reserve"><code>reserve</code></a> if future insertions are expected.</p> <h2 id="panics" class="section-header">Panics</h2> <p>Panics if the new capacity overflows <code>usize</code>.</p> <h2 id="examples-14" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();
heap.reserve_exact(100);
assert!(heap.capacity() &gt;= 100);
heap.push(4);</pre></div> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.reserve" class="method has-srclink">
<h4 class="code-header">pub fn reserve(&amp;mut self, additional: usize)</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#935" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Reserves capacity for at least <code>additional</code> more elements to be inserted in the <code>BinaryHeap</code>. The collection may reserve more space to avoid frequent reallocations.</p> <h2 id="panics-1" class="section-header">Panics</h2> <p>Panics if the new capacity overflows <code>usize</code>.</p> <h2 id="examples-15" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();
heap.reserve(100);
assert!(heap.capacity() &gt;= 100);
heap.push(4);</pre></div> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.shrink_to_fit" class="method has-srclink">
<h4 class="code-header">pub fn shrink_to_fit(&amp;mut self)</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#954" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Discards as much additional capacity as possible.</p> <h2 id="examples-16" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap: BinaryHeap&lt;i32&gt; = BinaryHeap::with_capacity(100);

assert!(heap.capacity() &gt;= 100);
heap.shrink_to_fit();
assert!(heap.capacity() == 0);</pre></div> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.shrink_to" class="method has-srclink">
<h4 class="code-header">pub fn shrink_to(&amp;mut self, min_capacity: usize)</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#978" title="goto source code">[src]</a>
</div>
<div class="item-info"><div class="stab unstable"><details><summary><span class="emoji">ðŸ”¬</span> This is a nightly-only experimental API. (<code>shrink_to</code> <a href="https://github.com/rust-lang/rust/issues/56431">#56431</a>)</summary><p>new API</p> </details></div></div></summary><div class="docblock">
<p>Discards capacity with a lower bound.</p> <p>The capacity will remain at least as large as both the length and the supplied value.</p> <p>If the current capacity is less than the lower limit, this is a no-op.</p> <h2 id="examples-17" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(shrink_to)]
use std::collections::BinaryHeap;
let mut heap: BinaryHeap&lt;i32&gt; = BinaryHeap::with_capacity(100);

assert!(heap.capacity() &gt;= 100);
heap.shrink_to(10);
assert!(heap.capacity() &gt;= 10);</pre></div> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_slice" class="method has-srclink">
<h4 class="code-header">pub fn as_slice(&amp;self) -&gt; &amp;[T]</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#999" title="goto source code">[src]</a>
</div>
<span class="notable-traits"><div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="primitive" href="../primitive.slice">&amp;[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>
</div>
<pre class="content">impl Read for &amp;[u8]
impl Write for &amp;mut [u8]
</pre></span></div></span><div class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span> This is a nightly-only experimental API. (<code>binary_heap_as_slice</code> <a href="https://github.com/rust-lang/rust/issues/83659">#83659</a>)</div></div></summary><div class="docblock">
<p>Returns a slice of all values in the underlying vector, in arbitrary order.</p> <h2 id="examples-18" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(binary_heap_as_slice)]
use std::collections::BinaryHeap;
use std::io::{self, Write};

let heap = BinaryHeap::from(vec![1, 2, 3, 4, 5, 6, 7]);

io::sink().write(heap.as_slice()).unwrap();</pre></div> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into_vec" class="method has-srclink">
<h4 class="code-header">pub fn into_vec(self) -&gt; Vec&lt;T, Global&gt;</h4>
<span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1021" title="goto source code">[src]</a>
</div>
<span class="notable-traits"><div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="../vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>, A&gt;</div>
<pre class="content">impl&lt;A:Â Allocator&gt; Write for Vec&lt;u8, A&gt;
</pre></span></div></span></summary><div class="docblock">
<p>Consumes the <code>BinaryHeap</code> and returns the underlying vector in arbitrary order.</p> <h2 id="examples-19" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let heap = BinaryHeap::from(vec![1, 2, 3, 4, 5, 6, 7]);
let vec = heap.into_vec();

// Will print in some order
for x in vec {
    println!("{}", x);
}</pre></div> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.len" class="method has-srclink">
<h4 class="code-header">pub fn len(&amp;self) -&gt; usize</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1039" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Returns the length of the binary heap.</p> <h2 id="examples-20" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let heap = BinaryHeap::from(vec![1, 3]);

assert_eq!(heap.len(), 2);</pre></div> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.is_empty" class="method has-srclink">
<h4 class="code-header">pub fn is_empty(&amp;self) -&gt; bool</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1062" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Checks if the binary heap is empty.</p> <h2 id="examples-21" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::new();

assert!(heap.is_empty());

heap.push(3);
heap.push(5);
heap.push(1);

assert!(!heap.is_empty());</pre></div> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.drain" class="method has-srclink">
<h4 class="code-header">pub fn drain(&amp;mut self) -&gt; Drain&lt;'_, T&gt;</h4>
<span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1088" title="goto source code">[src]</a>
</div>
<span class="notable-traits"><div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="binary_heap/struct.drain" title="struct std::collections::binary_heap::Drain">Drain</a>&lt;'_, T&gt;</div>
<pre class="content">impl&lt;'_, T&gt; Iterator for Drain&lt;'_, T&gt;
    type Item = T;
</pre></span></div></span></summary><div class="docblock">
<p>Clears the binary heap, returning an iterator over the removed elements.</p> <p>The elements are removed in arbitrary order.</p> <h2 id="examples-22" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::from(vec![1, 3]);

assert!(!heap.is_empty());

for x in heap.drain() {
    println!("{}", x);
}

assert!(heap.is_empty());</pre></div> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clear" class="method has-srclink">
<h4 class="code-header">pub fn clear(&amp;mut self)</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1109" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Drops all items from the binary heap.</p> <h2 id="examples-23" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let mut heap = BinaryHeap::from(vec![1, 3]);

assert!(!heap.is_empty());

heap.clear();

assert!(heap.is_empty());</pre></div> </div></details>
</div></details><h2 id="trait-implementations" class="small-section-header">Trait Implementations</h2>
<div id="trait-implementations-list">
<details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Clone" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; Clone for BinaryHeap&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../clone/trait.clone" title="trait std::clone::Clone">Clone</a>, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#316-324" title="goto source code">[src]</a>
</div></summary><div class="impl-items">
<details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn clone(&amp;self) -&gt; BinaryHeap&lt;T&gt;</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#317" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Returns a copy of the value. <a href="../clone/trait.clone#tymethod.clone">Read more</a></p> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone_from" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn clone_from(&amp;mut self, source: &amp;BinaryHeap&lt;T&gt;)</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#321" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Performs copy-assignment from <code>source</code>. <a href="../clone/trait.clone#method.clone_from">Read more</a></p> </div></details>
</div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Debug" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; Debug for BinaryHeap&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../fmt/trait.debug" title="trait std::fmt::Debug">Debug</a>, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#336-340" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span>
</div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.fmt" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#337" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Formats the value using the given formatter. <a href="../fmt/trait.debug#tymethod.fmt">Read more</a></p> </div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Default" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; Default for BinaryHeap&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../cmp/trait.ord" title="trait std::cmp::Ord">Ord</a>, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#327-333" title="goto source code">[src]</a>
</div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.default" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn default() -&gt; BinaryHeap&lt;T&gt;</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#330" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Creates an empty <code>BinaryHeap&lt;T&gt;</code>.</p> </div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Extend%3C%26%27a%20T%3E" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;'a, T&gt; Extend&lt;&amp;'a T&gt; for BinaryHeap&lt;T&gt; <span class="where fmt-newline">where<br> T: 'a + <a class="trait" href="../cmp/trait.ord" title="trait std::cmp::Ord">Ord</a> + <a class="trait" href="../marker/trait.copy" title="trait std::marker::Copy">Copy</a>, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1567-1581" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span>
</div></summary><div class="impl-items">
<details class="rustdoc-toggle method-toggle" open><summary><div id="method.extend-1" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn extend&lt;I&gt;(&amp;mut self, iter: I) <span class="where fmt-newline">where<br> I: <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="../primitive.reference">&amp;'a </a>T&gt;, </span>
</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1568" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Extends a collection with the contents of an iterator. <a href="../iter/trait.extend#tymethod.extend">Read more</a></p> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.extend_one-1" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn extend_one(&amp;mut self, &amp;'a T)</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1573" title="goto source code">[src]</a>
</div></summary><div class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span> This is a nightly-only experimental API. (<code>extend_one</code> <a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</div></div>
<div class="docblock">
<p>Extends a collection with exactly one element.</p> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.extend_reserve-1" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn extend_reserve(&amp;mut self, additional: usize)</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1578" title="goto source code">[src]</a>
</div></summary><div class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span> This is a nightly-only experimental API. (<code>extend_one</code> <a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</div></div>
<div class="docblock">
<p>Reserves capacity in a collection for the given number of additional elements. <a href="../iter/trait.extend#method.extend_reserve">Read more</a></p> </div></details>
</div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Extend%3CT%3E" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; Extend&lt;T&gt; for BinaryHeap&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../cmp/trait.ord" title="trait std::cmp::Ord">Ord</a>, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1526-1541" title="goto source code">[src]</a>
</div></summary><div class="impl-items">
<details class="rustdoc-toggle method-toggle" open><summary><div id="method.extend" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn extend&lt;I&gt;(&amp;mut self, iter: I) <span class="where fmt-newline">where<br> I: <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = T&gt;, </span>
</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1528" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Extends a collection with the contents of an iterator. <a href="../iter/trait.extend#tymethod.extend">Read more</a></p> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.extend_one" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn extend_one(&amp;mut self, item: T)</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1533" title="goto source code">[src]</a>
</div></summary><div class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span> This is a nightly-only experimental API. (<code>extend_one</code> <a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</div></div>
<div class="docblock">
<p>Extends a collection with exactly one element.</p> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.extend_reserve" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn extend_reserve(&amp;mut self, additional: usize)</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1538" title="goto source code">[src]</a>
</div></summary><div class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span> This is a nightly-only experimental API. (<code>extend_one</code> <a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</div></div>
<div class="docblock">
<p>Reserves capacity in a collection for the given number of additional elements. <a href="../iter/trait.extend#method.extend_reserve">Read more</a></p> </div></details>
</div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-From%3CBinaryHeap%3CT%3E%3E" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; From&lt;BinaryHeap&lt;T&gt;&gt; for Vec&lt;T, Global&gt;</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1470-1478" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span>
</div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from-1" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn from(heap: BinaryHeap&lt;T&gt;) -&gt; Vec&lt;T, Global&gt;</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1475" title="goto source code">[src]</a>
</div>
<span class="notable-traits"><div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="../vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>, A&gt;</div>
<pre class="content">impl&lt;A:Â Allocator&gt; Write for Vec&lt;u8, A&gt;
</pre></span></div></span></summary><div class="docblock">
<p>Converts a <code>BinaryHeap&lt;T&gt;</code> into a <code>Vec&lt;T&gt;</code>.</p> <p>This conversion requires no data movement or allocation, and has constant time complexity.</p> </div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-From%3CVec%3CT%2C%20Global%3E%3E" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; From&lt;Vec&lt;T, Global&gt;&gt; for BinaryHeap&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../cmp/trait.ord" title="trait std::cmp::Ord">Ord</a>, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1458-1467" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span>
</div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn from(vec: Vec&lt;T, Global&gt;) -&gt; BinaryHeap&lt;T&gt;</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1462" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Converts a <code>Vec&lt;T&gt;</code> into a <code>BinaryHeap&lt;T&gt;</code>.</p> <p>This conversion happens in-place, and has <em>O</em>(<em>n</em>) time complexity.</p> </div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-FromIterator%3CT%3E" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; FromIterator&lt;T&gt; for BinaryHeap&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../cmp/trait.ord" title="trait std::cmp::Ord">Ord</a>, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1481-1485" title="goto source code">[src]</a>
</div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from_iter" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn from_iter&lt;I&gt;(iter: I) -&gt; BinaryHeap&lt;T&gt; <span class="where fmt-newline">where<br> I: <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = T&gt;, </span>
</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1482" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Creates a value from an iterator. <a href="../iter/trait.fromiterator#tymethod.from_iter">Read more</a></p> </div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-IntoIterator" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;'a, T&gt; IntoIterator for &amp;'a BinaryHeap&lt;T&gt;</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1516-1523" title="goto source code">[src]</a>
</div></summary><div class="impl-items">
<details class="rustdoc-toggle" open><summary><div id="associatedtype.Item" class="type trait-impl has-srclink">
<h4 class="code-header">type Item = &amp;'a T</h4>

</div></summary><div class="docblock">
<p>The type of the elements being iterated over.</p> </div></details><details class="rustdoc-toggle" open><summary><div id="associatedtype.IntoIter" class="type trait-impl has-srclink">
<h4 class="code-header">type IntoIter = Iter&lt;'a, T&gt;</h4>

</div></summary><div class="docblock">
<p>Which kind of iterator are we turning this into?</p> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into_iter" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn into_iter(self) -&gt; Iter&lt;'a, T&gt;</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1520" title="goto source code">[src]</a>
</div>
<span class="notable-traits"><div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="binary_heap/struct.iter" title="struct std::collections::binary_heap::Iter">Iter</a>&lt;'a, T&gt;</div>
<pre class="content">impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt;
    type Item = &amp;'a T;
</pre></span></div></span></summary><div class="docblock">
<p>Creates an iterator from a value. <a href="../iter/trait.intoiterator#tymethod.into_iter">Read more</a></p> </div></details>
</div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-IntoIterator-1" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; IntoIterator for BinaryHeap&lt;T&gt;</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1488-1513" title="goto source code">[src]</a>
</div></summary><div class="impl-items">
<details class="rustdoc-toggle method-toggle" open><summary><div id="method.into_iter-1" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn into_iter(self) -&gt; IntoIter&lt;T&gt;</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#1510" title="goto source code">[src]</a>
</div>
<span class="notable-traits"><div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="binary_heap/struct.intoiter" title="struct std::collections::binary_heap::IntoIter">IntoIter</a>&lt;T&gt;</div>
<pre class="content">impl&lt;T&gt; Iterator for IntoIter&lt;T&gt;
    type Item = T;
</pre></span></div></span></summary><div class="docblock">
<p>Creates a consuming iterator, that is, one that moves each value out of the binary heap in arbitrary order. The binary heap cannot be used after calling this.</p> <h2 id="examples-24" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::BinaryHeap;
let heap = BinaryHeap::from(vec![1, 2, 3, 4]);

// Print 1, 2, 3, 4 in arbitrary order
for x in heap.into_iter() {
    // x has type i32, not &amp;i32
    println!("{}", x);
}</pre></div> </div></details><details class="rustdoc-toggle" open><summary><div id="associatedtype.Item-1" class="type trait-impl has-srclink">
<h4 class="code-header">type Item = T</h4>

</div></summary><div class="docblock">
<p>The type of the elements being iterated over.</p> </div></details><details class="rustdoc-toggle" open><summary><div id="associatedtype.IntoIter-1" class="type trait-impl has-srclink">
<h4 class="code-header">type IntoIter = IntoIter&lt;T&gt;</h4>

</div></summary><div class="docblock">
<p>Which kind of iterator are we turning this into?</p> </div></details>
</div></details>
</div>
<h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations</h2>
<div id="synthetic-implementations-list">
<div id="impl-RefUnwindSafe" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; RefUnwindSafe for BinaryHeap&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../panic/trait.refunwindsafe" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>, </span>
</h3>

</div>
<div id="impl-Send" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; Send for BinaryHeap&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../marker/trait.send" title="trait std::marker::Send">Send</a>, </span>
</h3>

</div>
<div id="impl-Sync" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; Sync for BinaryHeap&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../marker/trait.sync" title="trait std::marker::Sync">Sync</a>, </span>
</h3>

</div>
<div id="impl-Unpin" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; Unpin for BinaryHeap&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../marker/trait.unpin" title="trait std::marker::Unpin">Unpin</a>, </span>
</h3>

</div>
<div id="impl-UnwindSafe" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; UnwindSafe for BinaryHeap&lt;T&gt; <span class="where fmt-newline">where<br> T: <a class="trait" href="../panic/trait.unwindsafe" title="trait std::panic::UnwindSafe">UnwindSafe</a>, </span>
</h3>

</div>
</div>
<h2 id="blanket-implementations" class="small-section-header">Blanket Implementations</h2>
<div id="blanket-implementations-list">
<details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Any" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; Any for T <span class="where fmt-newline">where<br> T: 'static + ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/any.rs.html#131-135" title="goto source code">[src]</a>
</div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.type_id" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn type_id(&amp;self) -&gt; TypeId</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/core/any.rs.html#132" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Gets the <code>TypeId</code> of <code>self</code>. <a href="../any/trait.any#tymethod.type_id">Read more</a></p> </div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Borrow%3CT%3E" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; Borrow&lt;T&gt; for T <span class="where fmt-newline">where<br> T: ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#208-213" title="goto source code">[src]</a>
</div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn borrow(&amp;self) -&gt; &amp;T</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#210" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Immutably borrows from an owned value. <a href="../borrow/trait.borrow#tymethod.borrow">Read more</a></p> </div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-BorrowMut%3CT%3E" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; BorrowMut&lt;T&gt; for T <span class="where fmt-newline">where<br> T: ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#216-220" title="goto source code">[src]</a>
</div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow_mut" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn borrow_mut(&amp;mut self) -&gt; &amp;mut T</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#217" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Mutably borrows from an owned value. <a href="../borrow/trait.borrowmut#tymethod.borrow_mut">Read more</a></p> </div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-From%3CT%3E" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; From&lt;T&gt; for T</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#544-548" title="goto source code">[src]</a>
</div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from-2" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn from(t: T) -&gt; T</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#545" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Performs the conversion.</p> </div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Into%3CU%3E" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T, U&gt; Into&lt;U&gt; for T <span class="where fmt-newline">where<br> U: <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;T&gt;, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#533-540" title="goto source code">[src]</a>
</div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn into(self) -&gt; U</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#537" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Performs the conversion.</p> </div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-ToOwned" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T&gt; ToOwned for T <span class="where fmt-newline">where<br> T: <a class="trait" href="../clone/trait.clone" title="trait std::clone::Clone">Clone</a>, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#84-96" title="goto source code">[src]</a>
</div></summary><div class="impl-items">
<details class="rustdoc-toggle" open><summary><div id="associatedtype.Owned" class="type trait-impl has-srclink">
<h4 class="code-header">type Owned = T</h4>

</div></summary><div class="docblock">
<p>The resulting type after obtaining ownership.</p> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_owned" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn to_owned(&amp;self) -&gt; T</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#89" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Creates owned data from borrowed data, usually by cloning. <a href="../borrow/trait.toowned#tymethod.to_owned">Read more</a></p> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone_into" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn clone_into(&amp;self, target: &amp;mut T)</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#93" title="goto source code">[src]</a>
</div></summary><div class="item-info"><div class="stab unstable"><details><summary><span class="emoji">ðŸ”¬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code> <a href="https://github.com/rust-lang/rust/issues/41263">#41263</a>)</summary><p>recently added</p> </details></div></div>
<div class="docblock">
<p>Uses borrowed data to replace owned data, usually by cloning. <a href="../borrow/trait.toowned#method.clone_into">Read more</a></p> </div></details>
</div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-TryFrom%3CU%3E" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T, U&gt; TryFrom&lt;U&gt; for T <span class="where fmt-newline">where<br> U: <a class="trait" href="../convert/trait.into" title="trait std::convert::Into">Into</a>&lt;T&gt;, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#581-590" title="goto source code">[src]</a>
</div></summary><div class="impl-items">
<details class="rustdoc-toggle" open><summary><div id="associatedtype.Error" class="type trait-impl has-srclink">
<h4 class="code-header">type Error = Infallible</h4>

</div></summary><div class="docblock">
<p>The type returned in the event of a conversion error.</p> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_from" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn try_from(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#587" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Performs the conversion.</p> </div></details>
</div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-TryInto%3CU%3E" class="impl has-srclink">
<h3 class="code-header in-band">impl&lt;T, U&gt; TryInto&lt;U&gt; for T <span class="where fmt-newline">where<br> U: <a class="trait" href="../convert/trait.tryfrom" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;, </span>
</h3>
<a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#567-576" title="goto source code">[src]</a>
</div></summary><div class="impl-items">
<details class="rustdoc-toggle" open><summary><div id="associatedtype.Error-1" class="type trait-impl has-srclink">
<h4 class="code-header">type Error = &lt;U as TryFrom&lt;T&gt;&gt;::Error</h4>

</div></summary><div class="docblock">
<p>The type returned in the event of a conversion error.</p> </div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_into" class="method trait-impl has-srclink">
<h4 class="code-header">pub fn try_into(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</h4>
<a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#573" title="goto source code">[src]</a>
</div></summary><div class="docblock">
<p>Performs the conversion.</p> </div></details>
</div></details>
</div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html</a>
  </p>
</div>
