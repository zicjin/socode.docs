<h1 class="main-heading">Module std::iter</h1>
<p>Composable external iteration.</p> <p>If you’ve found yourself with a collection of some kind, and needed to perform an operation on the elements of said collection, you’ll quickly run into ‘iterators’. Iterators are heavily used in idiomatic Rust code, so it’s worth becoming familiar with them.</p> <p>Before explaining more, let’s talk about how this module is structured:</p> <h2 id="organization">Organization</h2> <p>This module is largely organized by type:</p> <ul> <li>
<a href="#traits">Traits</a> are the core portion: these traits define what kind of iterators exist and what you can do with them. The methods of these traits are worth putting some extra study time into.</li> <li>
<a href="#functions">Functions</a> provide some helpful ways to create some basic iterators.</li> <li>
<a href="#structs">Structs</a> are often the return types of the various methods on this module’s traits. You’ll usually want to look at the method that creates the <code>struct</code>, rather than the <code>struct</code> itself. For more detail about why, see ‘<a href="#implementing-iterator">Implementing Iterator</a>’.</li> </ul> <p>That’s it! Let’s dig into iterators.</p> <h2 id="iterator">Iterator</h2> <p>The heart and soul of this module is the <a href="trait.iterator" title="Iterator"><code>Iterator</code></a> trait. The core of <a href="trait.iterator" title="Iterator"><code>Iterator</code></a> looks like this:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}</pre></div> <p>An iterator has a method, <a href="trait.iterator#tymethod.next"><code>next</code></a>, which when called, returns an <code><a href="../option/enum.option" title="Option">Option</a>&lt;Item&gt;</code>. Calling <a href="trait.iterator#tymethod.next"><code>next</code></a> will return <a href="../option/enum.option#variant.Some"><code>Some(Item)</code></a> as long as there are elements, and once they’ve all been exhausted, will return <code>None</code> to indicate that iteration is finished. Individual iterators may choose to resume iteration, and so calling <a href="trait.iterator#tymethod.next"><code>next</code></a> again may or may not eventually start returning <a href="../option/enum.option#variant.Some"><code>Some(Item)</code></a> again at some point (for example, see <a href="../sync/mpsc/struct.tryiter"><code>TryIter</code></a>).</p> <p><a href="trait.iterator" title="Iterator"><code>Iterator</code></a>’s full definition includes a number of other methods as well, but they are default methods, built on top of <a href="trait.iterator#tymethod.next"><code>next</code></a>, and so you get them for free.</p> <p>Iterators are also composable, and it’s common to chain them together to do more complex forms of processing. See the <a href="#adapters">Adapters</a> section below for more details.</p> <h2 id="the-three-forms-of-iteration">The three forms of iteration</h2> <p>There are three common methods which can create iterators from a collection:</p> <ul> <li>
<code>iter()</code>, which iterates over <code>&amp;T</code>.</li> <li>
<code>iter_mut()</code>, which iterates over <code>&amp;mut T</code>.</li> <li>
<code>into_iter()</code>, which iterates over <code>T</code>.</li> </ul> <p>Various things in the standard library may implement one or more of the three, where appropriate.</p> <h2 id="implementing-iterator">Implementing Iterator</h2> <p>Creating an iterator of your own involves two steps: creating a <code>struct</code> to hold the iterator’s state, and then implementing <a href="trait.iterator" title="Iterator"><code>Iterator</code></a> for that <code>struct</code>. This is why there are so many <code>struct</code>s in this module: there is one for each iterator and iterator adapter.</p> <p>Let’s make an iterator named <code>Counter</code> which counts from <code>1</code> to <code>5</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">// First, the struct:

/// An iterator which counts from one to five
struct Counter {
    count: usize,
}

// we want our count to start at one, so let's add a new() method to help.
// This isn't strictly necessary, but is convenient. Note that we start
// `count` at zero, we'll see why in `next()`'s implementation below.
impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}

// Then, we implement `Iterator` for our `Counter`:

impl Iterator for Counter {
    // we will be counting with usize
    type Item = usize;

    // next() is the only required method
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // Increment our count. This is why we started at zero.
        self.count += 1;

        // Check to see if we've finished counting or not.
        if self.count &lt; 6 {
            Some(self.count)
        } else {
            None
        }
    }
}

// And now we can use it!

let mut counter = Counter::new();

assert_eq!(counter.next(), Some(1));
assert_eq!(counter.next(), Some(2));
assert_eq!(counter.next(), Some(3));
assert_eq!(counter.next(), Some(4));
assert_eq!(counter.next(), Some(5));
assert_eq!(counter.next(), None);</pre></div> <p>Calling <a href="trait.iterator#tymethod.next"><code>next</code></a> this way gets repetitive. Rust has a construct which can call <a href="trait.iterator#tymethod.next"><code>next</code></a> on your iterator, until it reaches <code>None</code>. Let’s go over that next.</p> <p>Also note that <code>Iterator</code> provides a default implementation of methods such as <code>nth</code> and <code>fold</code> which call <code>next</code> internally. However, it is also possible to write a custom implementation of methods like <code>nth</code> and <code>fold</code> if an iterator can compute them more efficiently without calling <code>next</code>.</p> <h2 id="for-loops-and-intoiterator">
<code>for</code> loops and <code>IntoIterator</code>
</h2> <p>Rust’s <code>for</code> loop syntax is actually sugar for iterators. Here’s a basic example of <code>for</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let values = vec![1, 2, 3, 4, 5];

for x in values {
    println!("{x}");
}</pre></div> <p>This will print the numbers one through five, each on their own line. But you’ll notice something here: we never called anything on our vector to produce an iterator. What gives?</p> <p>There’s a trait in the standard library for converting something into an iterator: <a href="trait.intoiterator" title="IntoIterator"><code>IntoIterator</code></a>. This trait has one method, <a href="trait.intoiterator#tymethod.into_iter"><code>into_iter</code></a>, which converts the thing implementing <a href="trait.intoiterator" title="IntoIterator"><code>IntoIterator</code></a> into an iterator. Let’s take a look at that <code>for</code> loop again, and what the compiler converts it into:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let values = vec![1, 2, 3, 4, 5];

for x in values {
    println!("{x}");
}</pre></div> <p>Rust de-sugars this into:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let values = vec![1, 2, 3, 4, 5];
{
    let result = match IntoIterator::into_iter(values) {
        mut iter =&gt; loop {
            let next;
            match iter.next() {
                Some(val) =&gt; next = val,
                None =&gt; break,
            };
            let x = next;
            let () = { println!("{x}"); };
        },
    };
    result
}</pre></div> <p>First, we call <code>into_iter()</code> on the value. Then, we match on the iterator that returns, calling <a href="trait.iterator#tymethod.next"><code>next</code></a> over and over until we see a <code>None</code>. At that point, we <code>break</code> out of the loop, and we’re done iterating.</p> <p>There’s one more subtle bit here: the standard library contains an interesting implementation of <a href="trait.intoiterator" title="IntoIterator"><code>IntoIterator</code></a>:</p> <div class="information">ⓘ This example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">impl&lt;I: Iterator&gt; IntoIterator for I</pre></div> <p>In other words, all <a href="trait.iterator" title="Iterator"><code>Iterator</code></a>s implement <a href="trait.intoiterator" title="IntoIterator"><code>IntoIterator</code></a>, by just returning themselves. This means two things:</p> <ol> <li>If you’re writing an <a href="trait.iterator" title="Iterator"><code>Iterator</code></a>, you can use it with a <code>for</code> loop.</li> <li>If you’re creating a collection, implementing <a href="trait.intoiterator" title="IntoIterator"><code>IntoIterator</code></a> for it will allow your collection to be used with the <code>for</code> loop.</li> </ol> <h2 id="iterating-by-reference">Iterating by reference</h2> <p>Since <a href="trait.intoiterator#tymethod.into_iter"><code>into_iter()</code></a> takes <code>self</code> by value, using a <code>for</code> loop to iterate over a collection consumes that collection. Often, you may want to iterate over a collection without consuming it. Many collections offer methods that provide iterators over references, conventionally called <code>iter()</code> and <code>iter_mut()</code> respectively:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut values = vec![41];
for x in values.iter_mut() {
    *x += 1;
}
for x in values.iter() {
    assert_eq!(*x, 42);
}
assert_eq!(values.len(), 1); // `values` is still owned by this function.</pre></div> <p>If a collection type <code>C</code> provides <code>iter()</code>, it usually also implements <code>IntoIterator</code> for <code>&amp;C</code>, with an implementation that just calls <code>iter()</code>. Likewise, a collection <code>C</code> that provides <code>iter_mut()</code> generally implements <code>IntoIterator</code> for <code>&amp;mut C</code> by delegating to <code>iter_mut()</code>. This enables a convenient shorthand:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut values = vec![41];
for x in &amp;mut values { // same as `values.iter_mut()`
    *x += 1;
}
for x in &amp;values { // same as `values.iter()`
    assert_eq!(*x, 42);
}
assert_eq!(values.len(), 1);</pre></div> <p>While many collections offer <code>iter()</code>, not all offer <code>iter_mut()</code>. For example, mutating the keys of a <a href="../collections/struct.hashset"><code>HashSet&lt;T&gt;</code></a> could put the collection into an inconsistent state if the key hashes change, so this collection only offers <code>iter()</code>.</p> <h2 id="adapters">Adapters</h2> <p>Functions which take an <a href="trait.iterator" title="Iterator"><code>Iterator</code></a> and return another <a href="trait.iterator" title="Iterator"><code>Iterator</code></a> are often called ‘iterator adapters’, as they’re a form of the ‘adapter pattern’.</p> <p>Common iterator adapters include <a href="trait.iterator#method.map"><code>map</code></a>, <a href="trait.iterator#method.take"><code>take</code></a>, and <a href="trait.iterator#method.filter"><code>filter</code></a>. For more, see their documentation.</p> <p>If an iterator adapter panics, the iterator will be in an unspecified (but memory safe) state. This state is also not guaranteed to stay the same across versions of Rust, so you should avoid relying on the exact values returned by an iterator which panicked.</p> <h2 id="laziness">Laziness</h2> <p>Iterators (and iterator <a href="#adapters">adapters</a>) are <em>lazy</em>. This means that just creating an iterator doesn’t <em>do</em> a whole lot. Nothing really happens until you call <a href="trait.iterator#tymethod.next"><code>next</code></a>. This is sometimes a source of confusion when creating an iterator solely for its side effects. For example, the <a href="trait.iterator#method.map"><code>map</code></a> method calls a closure on each element it iterates over:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v = vec![1, 2, 3, 4, 5];
v.iter().map(|x| println!("{x}"));</pre></div> <p>This will not print any values, as we only created an iterator, rather than using it. The compiler will warn us about this kind of behavior:</p> <div class="example-wrap"><pre class="language-text">warning: unused result that must be used: iterators are lazy and
do nothing unless consumed</pre></div> <p>The idiomatic way to write a <a href="trait.iterator#method.map"><code>map</code></a> for its side effects is to use a <code>for</code> loop or call the <a href="trait.iterator#method.for_each"><code>for_each</code></a> method:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let v = vec![1, 2, 3, 4, 5];

v.iter().for_each(|x| println!("{x}"));
// or
for x in &amp;v {
    println!("{x}");
}</pre></div> <p>Another common way to evaluate an iterator is to use the <a href="trait.iterator#method.collect"><code>collect</code></a> method to produce a new collection.</p> <h2 id="infinity">Infinity</h2> <p>Iterators do not have to be finite. As an example, an open-ended range is an infinite iterator:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let numbers = 0..;</pre></div> <p>It is common to use the <a href="trait.iterator#method.take"><code>take</code></a> iterator adapter to turn an infinite iterator into a finite one:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let numbers = 0..;
let five_numbers = numbers.take(5);

for number in five_numbers {
    println!("{number}");
}</pre></div> <p>This will print the numbers <code>0</code> through <code>4</code>, each on their own line.</p> <p>Bear in mind that methods on infinite iterators, even those for which a result can be determined mathematically in finite time, might not terminate. Specifically, methods such as <a href="trait.iterator#method.min"><code>min</code></a>, which in the general case require traversing every element in the iterator, are likely not to return successfully for any infinite iterators.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let ones = std::iter::repeat(1);
let least = ones.min().unwrap(); // Oh no! An infinite loop!
// `ones.min()` causes an infinite loop, so we won't reach this point!
println!("The smallest number one is {least}.");</pre></div> <h2 id="structs" class="small-section-header">Structs</h2> <div class="item-table">
<div class="item-row">
<div class="item-left unstable module-item">
<a class="struct" href="struct.intersperse" title="std::iter::Intersperse struct">Intersperse</a><span class="stab unstable" title="">Experimental</span>
</div>
<div class="item-right docblock-short">
<p>An iterator adapter that places a separator between all elements.</p> </div>
</div>
<div class="item-row">
<div class="item-left unstable module-item">
<a class="struct" href="struct.interspersewith" title="std::iter::IntersperseWith struct">IntersperseWith</a><span class="stab unstable" title="">Experimental</span>
</div>
<div class="item-right docblock-short">
<p>An iterator adapter that places a separator between all elements.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.chain" title="std::iter::Chain struct">Chain</a></div>
<div class="item-right docblock-short">
<p>An iterator that links two iterators together, in a chain.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.cloned" title="std::iter::Cloned struct">Cloned</a></div>
<div class="item-right docblock-short">
<p>An iterator that clones the elements of an underlying iterator.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.copied" title="std::iter::Copied struct">Copied</a></div>
<div class="item-right docblock-short">
<p>An iterator that copies the elements of an underlying iterator.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.cycle" title="std::iter::Cycle struct">Cycle</a></div>
<div class="item-right docblock-short">
<p>An iterator that repeats endlessly.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.empty" title="std::iter::Empty struct">Empty</a></div>
<div class="item-right docblock-short">
<p>An iterator that yields nothing.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.enumerate" title="std::iter::Enumerate struct">Enumerate</a></div>
<div class="item-right docblock-short">
<p>An iterator that yields the current count and the element during iteration.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.filter" title="std::iter::Filter struct">Filter</a></div>
<div class="item-right docblock-short">
<p>An iterator that filters the elements of <code>iter</code> with <code>predicate</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.filtermap" title="std::iter::FilterMap struct">FilterMap</a></div>
<div class="item-right docblock-short">
<p>An iterator that uses <code>f</code> to both filter and map elements from <code>iter</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.flatmap" title="std::iter::FlatMap struct">FlatMap</a></div>
<div class="item-right docblock-short">
<p>An iterator that maps each element to an iterator, and yields the elements of the produced iterators.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.flatten" title="std::iter::Flatten struct">Flatten</a></div>
<div class="item-right docblock-short">
<p>An iterator that flattens one level of nesting in an iterator of things that can be turned into iterators.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.fromfn" title="std::iter::FromFn struct">FromFn</a></div>
<div class="item-right docblock-short">
<p>An iterator where each iteration calls the provided closure <code>F: FnMut() -&gt; Option&lt;T&gt;</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.fuse" title="std::iter::Fuse struct">Fuse</a></div>
<div class="item-right docblock-short">
<p>An iterator that yields <code>None</code> forever after the underlying iterator yields <code>None</code> once.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.inspect" title="std::iter::Inspect struct">Inspect</a></div>
<div class="item-right docblock-short">
<p>An iterator that calls a function with a reference to each element before yielding it.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.map" title="std::iter::Map struct">Map</a></div>
<div class="item-right docblock-short">
<p>An iterator that maps the values of <code>iter</code> with <code>f</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.mapwhile" title="std::iter::MapWhile struct">MapWhile</a></div>
<div class="item-right docblock-short">
<p>An iterator that only accepts elements while <code>predicate</code> returns <code>Some(_)</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.once" title="std::iter::Once struct">Once</a></div>
<div class="item-right docblock-short">
<p>An iterator that yields an element exactly once.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.oncewith" title="std::iter::OnceWith struct">OnceWith</a></div>
<div class="item-right docblock-short">
<p>An iterator that yields a single element of type <code>A</code> by applying the provided closure <code>F: FnOnce() -&gt; A</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.peekable" title="std::iter::Peekable struct">Peekable</a></div>
<div class="item-right docblock-short">
<p>An iterator with a <code>peek()</code> that returns an optional reference to the next element.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.repeat" title="std::iter::Repeat struct">Repeat</a></div>
<div class="item-right docblock-short">
<p>An iterator that repeats an element endlessly.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.repeatwith" title="std::iter::RepeatWith struct">RepeatWith</a></div>
<div class="item-right docblock-short">
<p>An iterator that repeats elements of type <code>A</code> endlessly by applying the provided closure <code>F: FnMut() -&gt; A</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.rev" title="std::iter::Rev struct">Rev</a></div>
<div class="item-right docblock-short">
<p>A double-ended iterator with the direction inverted.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.scan" title="std::iter::Scan struct">Scan</a></div>
<div class="item-right docblock-short">
<p>An iterator to maintain state while iterating another iterator.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.skip" title="std::iter::Skip struct">Skip</a></div>
<div class="item-right docblock-short">
<p>An iterator that skips over <code>n</code> elements of <code>iter</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.skipwhile" title="std::iter::SkipWhile struct">SkipWhile</a></div>
<div class="item-right docblock-short">
<p>An iterator that rejects elements while <code>predicate</code> returns <code>true</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.stepby" title="std::iter::StepBy struct">StepBy</a></div>
<div class="item-right docblock-short">
<p>An iterator for stepping iterators by a custom amount.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.successors" title="std::iter::Successors struct">Successors</a></div>
<div class="item-right docblock-short">
<p>An new iterator where each successive item is computed based on the preceding one.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.take" title="std::iter::Take struct">Take</a></div>
<div class="item-right docblock-short">
<p>An iterator that only iterates over the first <code>n</code> iterations of <code>iter</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.takewhile" title="std::iter::TakeWhile struct">TakeWhile</a></div>
<div class="item-right docblock-short">
<p>An iterator that only accepts elements while <code>predicate</code> returns <code>true</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.zip" title="std::iter::Zip struct">Zip</a></div>
<div class="item-right docblock-short">
<p>An iterator that iterates two other iterators simultaneously.</p> </div>
</div>
</div>
<h2 id="traits" class="small-section-header">Traits</h2> <div class="item-table">
<div class="item-row">
<div class="item-left unstable module-item">
<a class="trait" href="trait.step" title="std::iter::Step trait">Step</a><span class="stab unstable" title="">Experimental</span>
</div>
<div class="item-right docblock-short">
<p>Objects that have a notion of <em>successor</em> and <em>predecessor</em> operations.</p> </div>
</div>
<div class="item-row">
<div class="item-left unstable module-item">
<a class="trait" href="trait.trustedlen" title="std::iter::TrustedLen trait">TrustedLen</a><span class="stab unstable" title="">Experimental</span>
</div>
<div class="item-right docblock-short">
<p>An iterator that reports an accurate length using size_hint.</p> </div>
</div>
<div class="item-row">
<div class="item-left unstable module-item">
<a class="trait" href="trait.trustedstep" title="std::iter::TrustedStep trait">TrustedStep</a><span class="stab unstable" title="">Experimental</span>
</div>
<div class="item-right docblock-short">
<p>A type that upholds all invariants of <a href="trait.step" title="Step"><code>Step</code></a>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="trait" href="trait.doubleendediterator" title="std::iter::DoubleEndedIterator trait">DoubleEndedIterator</a></div>
<div class="item-right docblock-short">
<p>An iterator able to yield elements from both ends.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="trait" href="trait.exactsizeiterator" title="std::iter::ExactSizeIterator trait">ExactSizeIterator</a></div>
<div class="item-right docblock-short">
<p>An iterator that knows its exact length.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="trait" href="trait.extend" title="std::iter::Extend trait">Extend</a></div>
<div class="item-right docblock-short">
<p>Extend a collection with the contents of an iterator.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="trait" href="trait.fromiterator" title="std::iter::FromIterator trait">FromIterator</a></div>
<div class="item-right docblock-short">
<p>Conversion from an <a href="trait.iterator" title="Iterator"><code>Iterator</code></a>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="trait" href="trait.fusediterator" title="std::iter::FusedIterator trait">FusedIterator</a></div>
<div class="item-right docblock-short">
<p>An iterator that always continues to yield <code>None</code> when exhausted.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="trait" href="trait.intoiterator" title="std::iter::IntoIterator trait">IntoIterator</a></div>
<div class="item-right docblock-short">
<p>Conversion into an <a href="trait.iterator" title="Iterator"><code>Iterator</code></a>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="trait" href="trait.iterator" title="std::iter::Iterator trait">Iterator</a></div>
<div class="item-right docblock-short">
<p>An interface for dealing with iterators.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="trait" href="trait.product" title="std::iter::Product trait">Product</a></div>
<div class="item-right docblock-short">
<p>Trait to represent types that can be created by multiplying elements of an iterator.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="trait" href="trait.sum" title="std::iter::Sum trait">Sum</a></div>
<div class="item-right docblock-short">
<p>Trait to represent types that can be created by summing up an iterator.</p> </div>
</div>
</div>
<h2 id="functions" class="small-section-header">Functions</h2> <div class="item-table">
<div class="item-row">
<div class="item-left module-item"><a class="fn" href="fn.empty" title="std::iter::empty fn">empty</a></div>
<div class="item-right docblock-short">
<p>Creates an iterator that yields nothing.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="fn" href="fn.from_fn" title="std::iter::from_fn fn">from_fn</a></div>
<div class="item-right docblock-short">
<p>Creates a new iterator where each iteration calls the provided closure <code>F: FnMut() -&gt; Option&lt;T&gt;</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="fn" href="fn.once" title="std::iter::once fn">once</a></div>
<div class="item-right docblock-short">
<p>Creates an iterator that yields an element exactly once.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="fn" href="fn.once_with" title="std::iter::once_with fn">once_with</a></div>
<div class="item-right docblock-short">
<p>Creates an iterator that lazily generates a value exactly once by invoking the provided closure.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="fn" href="fn.repeat" title="std::iter::repeat fn">repeat</a></div>
<div class="item-right docblock-short">
<p>Creates a new iterator that endlessly repeats a single element.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="fn" href="fn.repeat_with" title="std::iter::repeat_with fn">repeat_with</a></div>
<div class="item-right docblock-short">
<p>Creates a new iterator that repeats elements of type <code>A</code> endlessly by applying the provided closure, the repeater, <code>F: FnMut() -&gt; A</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="fn" href="fn.successors" title="std::iter::successors fn">successors</a></div>
<div class="item-right docblock-short">
<p>Creates a new iterator where each successive item is computed based on the preceding one.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="fn" href="fn.zip" title="std::iter::zip fn">zip</a></div>
<div class="item-right docblock-short">
<p>Converts the arguments to iterators and zips them.</p> </div>
</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/iter/index.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/iter/index.html</a>
  </p>
</div>
