<h1 class="main-heading">Module std::sync::atomic</h1>
<p>Atomic types</p> <p>Atomic types provide primitive shared-memory communication between threads, and are the building blocks of other concurrent types.</p> <p>This module defines atomic versions of a select number of primitive types, including <a href="struct.atomicbool" title="AtomicBool"><code>AtomicBool</code></a>, <a href="struct.atomicisize" title="AtomicIsize"><code>AtomicIsize</code></a>, <a href="struct.atomicusize" title="AtomicUsize"><code>AtomicUsize</code></a>, <a href="struct.atomici8" title="AtomicI8"><code>AtomicI8</code></a>, <a href="struct.atomicu16" title="AtomicU16"><code>AtomicU16</code></a>, etc. Atomic types present operations that, when used correctly, synchronize updates between threads.</p> <p>Each method takes an <a href="enum.ordering" title="Ordering"><code>Ordering</code></a> which represents the strength of the memory barrier for that operation. These orderings are the same as the <a href="https://en.cppreference.com/w/cpp/atomic/memory_order">C++20 atomic orderings</a>. For more information see the <a href="https://doc.rust-lang.org/nomicon/atomics.html">nomicon</a>.</p> <p>Atomic variables are safe to share between threads (they implement <a href="../../marker/trait.sync" title="Sync"><code>Sync</code></a>) but they do not themselves provide the mechanism for sharing and follow the <a href="../../thread/index#the-threading-model">threading model</a> of Rust. The most common way to share an atomic variable is to put it into an <a href="../struct.arc"><code>Arc</code></a> (an atomically-reference-counted shared pointer).</p> <p>Atomic types may be stored in static variables, initialized using the constant initializers like <a href="struct.atomicbool#method.new" title="AtomicBool::new"><code>AtomicBool::new</code></a>. Atomic statics are often used for lazy global initialization.</p> <h2 id="portability">Portability</h2> <p>All atomic types in this module are guaranteed to be <a href="https://en.wikipedia.org/wiki/Non-blocking_algorithm">lock-free</a> if they’re available. This means they don’t internally acquire a global mutex. Atomic types and operations are not guaranteed to be wait-free. This means that operations like <code>fetch_or</code> may be implemented with a compare-and-swap loop.</p> <p>Atomic operations may be implemented at the instruction layer with larger-size atomics. For example some platforms use 4-byte atomic instructions to implement <code>AtomicI8</code>. Note that this emulation should not have an impact on correctness of code, it’s just something to be aware of.</p> <p>The atomic types in this module might not be available on all platforms. The atomic types here are all widely available, however, and can generally be relied upon existing. Some notable exceptions are:</p> <ul> <li>PowerPC and MIPS platforms with 32-bit pointers do not have <code>AtomicU64</code> or <code>AtomicI64</code> types.</li> <li>ARM platforms like <code>armv5te</code> that aren’t for Linux only provide <code>load</code> and <code>store</code> operations, and do not support Compare and Swap (CAS) operations, such as <code>swap</code>, <code>fetch_add</code>, etc. Additionally on Linux, these CAS operations are implemented via <a href="https://www.kernel.org/doc/Documentation/arm/kernel_user_helpers.txt">operating system support</a>, which may come with a performance penalty.</li> <li>ARM targets with <code>thumbv6m</code> only provide <code>load</code> and <code>store</code> operations, and do not support Compare and Swap (CAS) operations, such as <code>swap</code>, <code>fetch_add</code>, etc.</li> </ul> <p>Note that future platforms may be added that also do not have support for some atomic operations. Maximally portable code will want to be careful about which atomic types are used. <code>AtomicUsize</code> and <code>AtomicIsize</code> are generally the most portable, but even then they’re not available everywhere. For reference, the <code>std</code> library requires <code>AtomicBool</code>s and pointer-sized atomics, although <code>core</code> does not.</p> <p>The <code>#[cfg(target_has_atomic)]</code> attribute can be used to conditionally compile based on the target’s supported bit widths. It is a key-value option set for each supported size, with values “8”, “16”, “32”, “64”, “128”, and “ptr” for pointer-sized atomics.</p> <h2 id="examples">Examples</h2> <p>A simple spinlock:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::{hint, thread};

fn main() {
    let spinlock = Arc::new(AtomicUsize::new(1));

    let spinlock_clone = Arc::clone(&amp;spinlock);
    let thread = thread::spawn(move|| {
        spinlock_clone.store(0, Ordering::SeqCst);
    });

    // Wait for the other thread to release the lock
    while spinlock.load(Ordering::SeqCst) != 0 {
        hint::spin_loop();
    }

    if let Err(panic) = thread.join() {
        println!("Thread had an error: {panic:?}");
    }
}</pre></div> <p>Keep a global count of live threads:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::atomic::{AtomicUsize, Ordering};

static GLOBAL_THREAD_COUNT: AtomicUsize = AtomicUsize::new(0);

let old_thread_count = GLOBAL_THREAD_COUNT.fetch_add(1, Ordering::SeqCst);
println!("live threads: {}", old_thread_count + 1);</pre></div> <h2 id="structs" class="small-section-header">Structs</h2> <div class="item-table">
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.atomicbool" title="std::sync::atomic::AtomicBool struct">AtomicBool</a></div>
<div class="item-right docblock-short">
<p>A boolean type which can be safely shared between threads.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.atomici8" title="std::sync::atomic::AtomicI8 struct">AtomicI8</a></div>
<div class="item-right docblock-short">
<p>An integer type which can be safely shared between threads.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.atomici16" title="std::sync::atomic::AtomicI16 struct">AtomicI16</a></div>
<div class="item-right docblock-short">
<p>An integer type which can be safely shared between threads.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.atomici32" title="std::sync::atomic::AtomicI32 struct">AtomicI32</a></div>
<div class="item-right docblock-short">
<p>An integer type which can be safely shared between threads.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.atomici64" title="std::sync::atomic::AtomicI64 struct">AtomicI64</a></div>
<div class="item-right docblock-short">
<p>An integer type which can be safely shared between threads.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.atomicisize" title="std::sync::atomic::AtomicIsize struct">AtomicIsize</a></div>
<div class="item-right docblock-short">
<p>An integer type which can be safely shared between threads.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.atomicptr" title="std::sync::atomic::AtomicPtr struct">AtomicPtr</a></div>
<div class="item-right docblock-short">
<p>A raw pointer type which can be safely shared between threads.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.atomicu8" title="std::sync::atomic::AtomicU8 struct">AtomicU8</a></div>
<div class="item-right docblock-short">
<p>An integer type which can be safely shared between threads.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.atomicu16" title="std::sync::atomic::AtomicU16 struct">AtomicU16</a></div>
<div class="item-right docblock-short">
<p>An integer type which can be safely shared between threads.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.atomicu32" title="std::sync::atomic::AtomicU32 struct">AtomicU32</a></div>
<div class="item-right docblock-short">
<p>An integer type which can be safely shared between threads.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.atomicu64" title="std::sync::atomic::AtomicU64 struct">AtomicU64</a></div>
<div class="item-right docblock-short">
<p>An integer type which can be safely shared between threads.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="struct" href="struct.atomicusize" title="std::sync::atomic::AtomicUsize struct">AtomicUsize</a></div>
<div class="item-right docblock-short">
<p>An integer type which can be safely shared between threads.</p> </div>
</div>
</div>
<h2 id="enums" class="small-section-header">Enums</h2> <div class="item-table"><div class="item-row">
<div class="item-left module-item"><a class="enum" href="enum.ordering" title="std::sync::atomic::Ordering enum">Ordering</a></div>
<div class="item-right docblock-short">
<p>Atomic memory orderings</p> </div>
</div></div>
<h2 id="constants" class="small-section-header">Constants</h2> <div class="item-table">
<div class="item-row">
<div class="item-left unstable deprecated module-item">
<a class="constant" href="constant.atomic_i8_init" title="std::sync::atomic::ATOMIC_I8_INIT constant">ATOMIC_I8_INIT</a><span class="stab deprecated" title="">Deprecated</span><span class="stab unstable" title="">Experimental</span>
</div>
<div class="item-right docblock-short">
<p>An atomic integer initialized to <code>0</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left unstable deprecated module-item">
<a class="constant" href="constant.atomic_i16_init" title="std::sync::atomic::ATOMIC_I16_INIT constant">ATOMIC_I16_INIT</a><span class="stab deprecated" title="">Deprecated</span><span class="stab unstable" title="">Experimental</span>
</div>
<div class="item-right docblock-short">
<p>An atomic integer initialized to <code>0</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left unstable deprecated module-item">
<a class="constant" href="constant.atomic_i32_init" title="std::sync::atomic::ATOMIC_I32_INIT constant">ATOMIC_I32_INIT</a><span class="stab deprecated" title="">Deprecated</span><span class="stab unstable" title="">Experimental</span>
</div>
<div class="item-right docblock-short">
<p>An atomic integer initialized to <code>0</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left unstable deprecated module-item">
<a class="constant" href="constant.atomic_i64_init" title="std::sync::atomic::ATOMIC_I64_INIT constant">ATOMIC_I64_INIT</a><span class="stab deprecated" title="">Deprecated</span><span class="stab unstable" title="">Experimental</span>
</div>
<div class="item-right docblock-short">
<p>An atomic integer initialized to <code>0</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left unstable deprecated module-item">
<a class="constant" href="constant.atomic_u8_init" title="std::sync::atomic::ATOMIC_U8_INIT constant">ATOMIC_U8_INIT</a><span class="stab deprecated" title="">Deprecated</span><span class="stab unstable" title="">Experimental</span>
</div>
<div class="item-right docblock-short">
<p>An atomic integer initialized to <code>0</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left unstable deprecated module-item">
<a class="constant" href="constant.atomic_u16_init" title="std::sync::atomic::ATOMIC_U16_INIT constant">ATOMIC_U16_INIT</a><span class="stab deprecated" title="">Deprecated</span><span class="stab unstable" title="">Experimental</span>
</div>
<div class="item-right docblock-short">
<p>An atomic integer initialized to <code>0</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left unstable deprecated module-item">
<a class="constant" href="constant.atomic_u32_init" title="std::sync::atomic::ATOMIC_U32_INIT constant">ATOMIC_U32_INIT</a><span class="stab deprecated" title="">Deprecated</span><span class="stab unstable" title="">Experimental</span>
</div>
<div class="item-right docblock-short">
<p>An atomic integer initialized to <code>0</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left unstable deprecated module-item">
<a class="constant" href="constant.atomic_u64_init" title="std::sync::atomic::ATOMIC_U64_INIT constant">ATOMIC_U64_INIT</a><span class="stab deprecated" title="">Deprecated</span><span class="stab unstable" title="">Experimental</span>
</div>
<div class="item-right docblock-short">
<p>An atomic integer initialized to <code>0</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left deprecated module-item">
<a class="constant" href="constant.atomic_bool_init" title="std::sync::atomic::ATOMIC_BOOL_INIT constant">ATOMIC_BOOL_INIT</a><span class="stab deprecated" title="">Deprecated</span>
</div>
<div class="item-right docblock-short">
<p>An <a href="struct.atomicbool" title="AtomicBool"><code>AtomicBool</code></a> initialized to <code>false</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left deprecated module-item">
<a class="constant" href="constant.atomic_isize_init" title="std::sync::atomic::ATOMIC_ISIZE_INIT constant">ATOMIC_ISIZE_INIT</a><span class="stab deprecated" title="">Deprecated</span>
</div>
<div class="item-right docblock-short">
<p>An atomic integer initialized to <code>0</code>.</p> </div>
</div>
<div class="item-row">
<div class="item-left deprecated module-item">
<a class="constant" href="constant.atomic_usize_init" title="std::sync::atomic::ATOMIC_USIZE_INIT constant">ATOMIC_USIZE_INIT</a><span class="stab deprecated" title="">Deprecated</span>
</div>
<div class="item-right docblock-short">
<p>An atomic integer initialized to <code>0</code>.</p> </div>
</div>
</div>
<h2 id="functions" class="small-section-header">Functions</h2> <div class="item-table">
<div class="item-row">
<div class="item-left module-item"><a class="fn" href="fn.compiler_fence" title="std::sync::atomic::compiler_fence fn">compiler_fence</a></div>
<div class="item-right docblock-short">
<p>A compiler memory fence.</p> </div>
</div>
<div class="item-row">
<div class="item-left module-item"><a class="fn" href="fn.fence" title="std::sync::atomic::fence fn">fence</a></div>
<div class="item-right docblock-short">
<p>An atomic fence.</p> </div>
</div>
<div class="item-row">
<div class="item-left deprecated module-item">
<a class="fn" href="fn.spin_loop_hint" title="std::sync::atomic::spin_loop_hint fn">spin_loop_hint</a><span class="stab deprecated" title="">Deprecated</span>
</div>
<div class="item-right docblock-short">
<p>Signals the processor that it is inside a busy-wait spin-loop (“spin lock”).</p> </div>
</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/sync/atomic/index.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/sync/atomic/index.html</a>
  </p>
</div>
