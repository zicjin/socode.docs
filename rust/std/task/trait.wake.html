<h1 class="fqn">Trait std::task::Wake</h1>
<pre class="rust trait" data-language="rust">pub trait Wake {
    fn wake(self: Arc&lt;Self&gt;);

    fn wake_by_ref(self: &amp;Arc&lt;Self&gt;) { ... }
}</pre>
<p>The implementation of waking a task on an executor.</p> <p>This trait can be used to create a <a href="struct.waker" title="Waker"><code>Waker</code></a>. An executor can define an implementation of this trait, and use that to construct a Waker to pass to the tasks that are executed on that executor.</p> <p>This trait is a memory-safe and ergonomic alternative to constructing a <a href="struct.rawwaker" title="RawWaker"><code>RawWaker</code></a>. It supports the common executor design in which the data used to wake up a task is stored in an <a href="../sync/struct.arc" title="Arc"><code>Arc</code></a>. Some executors (especially those for embedded systems) cannot use this API, which is why <a href="struct.rawwaker" title="RawWaker"><code>RawWaker</code></a> exists as an alternative for those systems.</p> <h3 id="examples" class="section-header">Examples</h3> <p>A basic <code>block_on</code> function that takes a future and runs it to completion on the current thread.</p> <p><strong>Note:</strong> This example trades correctness for simplicity. In order to prevent deadlocks, production-grade implementations will also need to handle intermediate calls to <code>thread::unpark</code> as well as nested invocations.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::future::Future;
use std::sync::Arc;
use std::task::{Context, Poll, Wake};
use std::thread::{self, Thread};

/// A waker that wakes up the current thread when called.
struct ThreadWaker(Thread);

impl Wake for ThreadWaker {
    fn wake(self: Arc&lt;Self&gt;) {
        self.0.unpark();
    }
}

/// Run a future to completion on the current thread.
fn block_on&lt;T&gt;(fut: impl Future&lt;Output = T&gt;) -&gt; T {
    // Pin the future so it can be polled.
    let mut fut = Box::pin(fut);

    // Create a new context to be passed to the future.
    let t = thread::current();
    let waker = Arc::new(ThreadWaker(t)).into();
    let mut cx = Context::from_waker(&amp;waker);

    // Run the future to completion.
    loop {
        match fut.as_mut().poll(&amp;mut cx) {
            Poll::Ready(res) =&gt; return res,
            Poll::Pending =&gt; thread::park(),
        }
    }
}

block_on(async {
    println!("Hi from inside a future!");
});</pre></div> <h2 id="required-methods" class="small-section-header">Required methods</h2>
<div class="methods">
<summary><div id="tymethod.wake" class="method has-srclink">
<div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/task.rs.html#73" title="goto source code">[src]</a></div>
<h4 class="code-header">fn wake(self: Arc&lt;Self&gt;)</h4>
</div></summary><div class="docblock">
<p>Wake this task.</p> </div>
</div>
<h2 id="provided-methods" class="small-section-header">Provided methods</h2>
<div class="methods">
<summary><div id="method.wake_by_ref" class="method has-srclink">
<div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/task.rs.html#83" title="goto source code">[src]</a></div>
<h4 class="code-header">fn wake_by_ref(self: &amp;Arc&lt;Self&gt;)</h4>
</div></summary><div class="docblock">
<p>Wake this task without consuming the waker.</p> <p>If an executor supports a cheaper way to wake without consuming the waker, it should override this method. By default, it clones the <a href="../sync/struct.arc" title="Arc"><code>Arc</code></a> and calls <a href="trait.wake#tymethod.wake"><code>wake</code></a> on the clone.</p> </div>
</div>
<h2 id="implementors" class="small-section-header">Implementors</h2>
<div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/task/trait.Wake.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/task/trait.Wake.html</a>
  </p>
</div>
