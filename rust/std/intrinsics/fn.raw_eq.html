<h1 class="main-heading">Function std::intrinsics::raw_eq</h1>
<pre class="rust fn" data-language="rust">pub unsafe extern "rust-intrinsic" fn raw_eq&lt;T&gt;(a: &amp;T, b: &amp;T) -&gt; bool</pre>
<span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span> This is a nightly-only experimental API. (<code>core_intrinsics</code>)</div></span><p>Determines whether the raw bytes of the two values are equal.</p> <p>This is particularly handy for arrays, since it allows things like just comparing <code>i96</code>s instead of forcing <code>alloca</code>s for <code>[6 x i16]</code>.</p> <p>Above some backend-decided threshold this will emit calls to <code>memcmp</code>, like slice equality does, instead of causing massive code size.</p> <h2 id="safety">Safety</h2> <p>Itâ€™s UB to call this if any of the <em>bytes</em> in <code>*a</code> or <code>*b</code> are uninitialized. Note that this is a stricter criterion than just the <em>values</em> being fully-initialized: if <code>T</code> has padding, itâ€™s UB to call this intrinsic.</p> <p>(The implementation is allowed to branch on the results of comparisons, which is UB if any of their inputs are <code>undef</code>.)</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/intrinsics/fn.raw_eq.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/intrinsics/fn.raw_eq.html</a>
  </p>
</div>
