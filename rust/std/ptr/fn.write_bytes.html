<h1 class="fqn">Function std::ptr::write_bytes</h1>
<pre class="rust fn" data-language="rust">pub unsafe fn write_bytes&lt;T&gt;(dst: *mut T, val: u8, count: usize)</pre>
<details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock">
<p>Sets <code>count * size_of::&lt;T&gt;()</code> bytes of memory starting at <code>dst</code> to <code>val</code>.</p> <p><code>write_bytes</code> is similar to Câ€™s <a href="https://en.cppreference.com/w/c/string/byte/memset"><code>memset</code></a>, but sets <code>count * size_of::&lt;T&gt;()</code> bytes to <code>val</code>.</p> <h2 id="safety" class="section-header">Safety</h2> <p>Behavior is undefined if any of the following conditions are violated:</p> <ul> <li> <p><code>dst</code> must be <a href="index#safety">valid</a> for writes of <code>count * size_of::&lt;T&gt;()</code> bytes.</p> </li> <li> <p><code>dst</code> must be properly aligned.</p> </li> </ul> <p>Additionally, the caller must ensure that writing <code>count * size_of::&lt;T&gt;()</code> bytes to the given region of memory results in a valid value of <code>T</code>. Using a region of memory typed as a <code>T</code> that contains an invalid value of <code>T</code> is undefined behavior.</p> <p>Note that even if the effectively copied size (<code>count * size_of::&lt;T&gt;()</code>) is <code>0</code>, the pointer must be non-null and properly aligned.</p> <h2 id="examples" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::ptr;

let mut vec = vec![0u32; 4];
unsafe {
    let vec_ptr = vec.as_mut_ptr();
    ptr::write_bytes(vec_ptr, 0xfe, 2);
}
assert_eq!(vec, [0xfefefefe, 0xfefefefe, 0, 0]);</pre></div> <p>Creating an invalid value:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::ptr;

let mut v = Box::new(0i32);

unsafe {
    // Leaks the previously held value by overwriting the `Box&lt;T&gt;` with
    // a null pointer.
    ptr::write_bytes(&amp;mut v as *mut Box&lt;i32&gt;, 0, 1);
}

// At this point, using or dropping `v` results in undefined behavior.
// drop(v); // ERROR

// Even leaking `v` "uses" it, and hence is undefined behavior.
// mem::forget(v); // ERROR

// In fact, `v` is invalid according to basic type layout invariants, so *any*
// operation touching it is undefined behavior.
// let v2 = v; // ERROR

unsafe {
    // Let us instead put in a valid value
    ptr::write(&amp;mut v as *mut Box&lt;i32&gt;, Box::new(42i32));
}

// Now the box is fine
assert_eq!(*v, 42);</pre></div> </div></details><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/ptr/fn.write_bytes.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/ptr/fn.write_bytes.html</a>
  </p>
</div>
