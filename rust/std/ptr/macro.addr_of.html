<h1 class="main-heading">Macro std::ptr::addr_of</h1>
<div class="example-wrap"><pre class="rust macro" data-language="rust">pub macro addr_of($place:expr) {
    ...
}</pre></div> <p>Create a <code>const</code> raw pointer to a place, without creating an intermediate reference.</p> <p>Creating a reference with <code>&amp;</code>/<code>&amp;mut</code> is only allowed if the pointer is properly aligned and points to initialized data. For cases where those requirements do not hold, raw pointers should be used instead. However, <code>&amp;expr as *const _</code> creates a reference before casting it to a raw pointer, and that reference is subject to the same rules as all other references. This macro can create a raw pointer <em>without</em> creating a reference first.</p> <p>Note, however, that the <code>expr</code> in <code>addr_of!(expr)</code> is still subject to all the usual rules. In particular, <code>addr_of!(*ptr::null())</code> is Undefined Behavior because it dereferences a null pointer.</p> <h2 id="example">Example</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::ptr;

#[repr(packed)]
struct Packed {
    f1: u8,
    f2: u16,
}

let packed = Packed { f1: 1, f2: 2 };
// `&amp;packed.f2` would create an unaligned reference, and thus be Undefined Behavior!
let raw_f2 = ptr::addr_of!(packed.f2);
assert_eq!(unsafe { raw_f2.read_unaligned() }, 2);</pre></div> <p>See <a href="macro.addr_of_mut" title="addr_of_mut"><code>addr_of_mut</code></a> for how to create a pointer to unininitialized data. Doing that with <code>addr_of</code> would not make much sense since one could only read the data, and that would be Undefined Behavior.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/ptr/macro.addr_of.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/ptr/macro.addr_of.html</a>
  </p>
</div>
