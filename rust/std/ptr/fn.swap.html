<h1 class="main-heading">Function std::ptr::swap</h1>
<pre class="rust fn" data-language="rust">pub unsafe fn swap&lt;T&gt;(x: *mut T, y: *mut T)</pre>
<p>Swaps the values at two mutable locations of the same type, without deinitializing either.</p> <p>But for the following two exceptions, this function is semantically equivalent to <a href="../mem/fn.swap" title="mem::swap"><code>mem::swap</code></a>:</p> <ul> <li> <p>It operates on raw pointers instead of references. When references are available, <a href="../mem/fn.swap" title="mem::swap"><code>mem::swap</code></a> should be preferred.</p> </li> <li> <p>The two pointed-to values may overlap. If the values do overlap, then the overlapping region of memory from <code>x</code> will be used. This is demonstrated in the second example below.</p> </li> </ul> <h2 id="safety">Safety</h2> <p>Behavior is undefined if any of the following conditions are violated:</p> <ul> <li> <p>Both <code>x</code> and <code>y</code> must be <a href="index#safety">valid</a> for both reads and writes.</p> </li> <li> <p>Both <code>x</code> and <code>y</code> must be properly aligned.</p> </li> </ul> <p>Note that even if <code>T</code> has size <code>0</code>, the pointers must be non-null and properly aligned.</p> <h2 id="examples">Examples</h2> <p>Swapping two non-overlapping regions:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::ptr;

let mut array = [0, 1, 2, 3];

let (x, y) = array.split_at_mut(2);
let x = x.as_mut_ptr().cast::&lt;[u32; 2]&gt;(); // this is `array[0..2]`
let y = y.as_mut_ptr().cast::&lt;[u32; 2]&gt;(); // this is `array[2..4]`

unsafe {
    ptr::swap(x, y);
    assert_eq!([2, 3, 0, 1], array);
}</pre></div> <p>Swapping two overlapping regions:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::ptr;

let mut array: [i32; 4] = [0, 1, 2, 3];

let array_ptr: *mut i32 = array.as_mut_ptr();

let x = array_ptr as *mut [i32; 3]; // this is `array[0..3]`
let y = unsafe { array_ptr.add(1) } as *mut [i32; 3]; // this is `array[1..4]`

unsafe {
    ptr::swap(x, y);
    // The indices `1..3` of the slice overlap between `x` and `y`.
    // Reasonable results would be for to them be `[2, 3]`, so that indices `0..3` are
    // `[1, 2, 3]` (matching `y` before the `swap`); or for them to be `[0, 1]`
    // so that indices `1..4` are `[0, 1, 2]` (matching `x` before the `swap`).
    // This implementation is defined to make the latter choice.
    assert_eq!([1, 0, 1, 2], array);
}</pre></div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/ptr/fn.swap.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/ptr/fn.swap.html</a>
  </p>
</div>
