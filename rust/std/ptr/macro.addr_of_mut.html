<h1 class="main-heading">Macro std::ptr::addr_of_mut</h1>
<div class="example-wrap"><pre class="rust macro" data-language="rust">pub macro addr_of_mut($place:expr) {
    ...
}</pre></div> <p>Create a <code>mut</code> raw pointer to a place, without creating an intermediate reference.</p> <p>Creating a reference with <code>&amp;</code>/<code>&amp;mut</code> is only allowed if the pointer is properly aligned and points to initialized data. For cases where those requirements do not hold, raw pointers should be used instead. However, <code>&amp;mut expr as *mut _</code> creates a reference before casting it to a raw pointer, and that reference is subject to the same rules as all other references. This macro can create a raw pointer <em>without</em> creating a reference first.</p> <p>Note, however, that the <code>expr</code> in <code>addr_of_mut!(expr)</code> is still subject to all the usual rules. In particular, <code>addr_of_mut!(*ptr::null_mut())</code> is Undefined Behavior because it dereferences a null pointer.</p> <h2 id="examples">Examples</h2> <p><strong>Creating a pointer to unaligned data:</strong></p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::ptr;

#[repr(packed)]
struct Packed {
    f1: u8,
    f2: u16,
}

let mut packed = Packed { f1: 1, f2: 2 };
// `&amp;mut packed.f2` would create an unaligned reference, and thus be Undefined Behavior!
let raw_f2 = ptr::addr_of_mut!(packed.f2);
unsafe { raw_f2.write_unaligned(42); }
assert_eq!({packed.f2}, 42); // `{...}` forces copying the field instead of creating a reference.</pre></div> <p><strong>Creating a pointer to uninitialized data:</strong></p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::{ptr, mem::MaybeUninit};

struct Demo {
    field: bool,
}

let mut uninit = MaybeUninit::&lt;Demo&gt;::uninit();
// `&amp;uninit.as_mut().field` would create a reference to an uninitialized `bool`,
// and thus be Undefined Behavior!
let f1_ptr = unsafe { ptr::addr_of_mut!((*uninit.as_mut_ptr()).field) };
unsafe { f1_ptr.write(true); }
let init = unsafe { uninit.assume_init() };</pre></div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/ptr/macro.addr_of_mut.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/ptr/macro.addr_of_mut.html</a>
  </p>
</div>
