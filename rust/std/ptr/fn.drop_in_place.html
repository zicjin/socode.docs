<h1 class="fqn">Function std::ptr::drop_in_place</h1>
<pre class="rust fn" data-language="rust">pub unsafe fn drop_in_place&lt;T&gt;(to_drop: *mut T) where    T: ?Sized, </pre>
<details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock">
<p>Executes the destructor (if any) of the pointed-to value.</p> <p>This is semantically equivalent to calling <a href="fn.read"><code>ptr::read</code></a> and discarding the result, but has the following advantages:</p> <ul> <li> <p>It is <em>required</em> to use <code>drop_in_place</code> to drop unsized types like trait objects, because they can’t be read out onto the stack and dropped normally.</p> </li> <li> <p>It is friendlier to the optimizer to do this over <a href="fn.read"><code>ptr::read</code></a> when dropping manually allocated memory (e.g., in the implementations of <code>Box</code>/<code>Rc</code>/<code>Vec</code>), as the compiler doesn’t need to prove that it’s sound to elide the copy.</p> </li> <li> <p>It can be used to drop <a href="../pin/index">pinned</a> data when <code>T</code> is not <code>repr(packed)</code> (pinned data must not be moved before it is dropped).</p> </li> </ul> <p>Unaligned values cannot be dropped in place, they must be copied to an aligned location first using <a href="fn.read_unaligned"><code>ptr::read_unaligned</code></a>. For packed structs, this move is done automatically by the compiler. This means the fields of packed structs are not dropped in-place.</p> <h2 id="safety" class="section-header">Safety</h2> <p>Behavior is undefined if any of the following conditions are violated:</p> <ul> <li> <p><code>to_drop</code> must be <a href="index#safety">valid</a> for both reads and writes.</p> </li> <li> <p><code>to_drop</code> must be properly aligned.</p> </li> <li> <p>The value <code>to_drop</code> points to must be valid for dropping, which may mean it must uphold additional invariants - this is type-dependent.</p> </li> </ul> <p>Additionally, if <code>T</code> is not <a href="../marker/trait.copy" title="Copy"><code>Copy</code></a>, using the pointed-to value after calling <code>drop_in_place</code> can cause undefined behavior. Note that <code>*to_drop = foo</code> counts as a use because it will cause the value to be dropped again. <a href="fn.write" title="write()"><code>write()</code></a> can be used to overwrite data without causing it to be dropped.</p> <p>Note that even if <code>T</code> has size <code>0</code>, the pointer must be non-null and properly aligned.</p> <h2 id="examples" class="section-header">Examples</h2> <p>Manually remove the last item from a vector:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::ptr;
use std::rc::Rc;

let last = Rc::new(1);
let weak = Rc::downgrade(&amp;last);

let mut v = vec![Rc::new(0), last];

unsafe {
    // Get a raw pointer to the last element in `v`.
    let ptr = &amp;mut v[1] as *mut _;
    // Shorten `v` to prevent the last item from being dropped. We do that first,
    // to prevent issues if the `drop_in_place` below panics.
    v.set_len(1);
    // Without a call `drop_in_place`, the last item would never be dropped,
    // and the memory it manages would be leaked.
    ptr::drop_in_place(ptr);
}

assert_eq!(v, &amp;[0.into()]);

// Ensure that the last item was dropped.
assert!(weak.upgrade().is_none());</pre></div> <p>Notice that the compiler performs this copy automatically when dropping packed structs, i.e., you do not usually have to worry about such issues unless you call <code>drop_in_place</code> manually.</p> </div></details><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/ptr/fn.drop_in_place.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/ptr/fn.drop_in_place.html</a>
  </p>
</div>
