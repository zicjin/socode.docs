<h1 class="fqn">Macro std::concat_idents</h1>
<div class="example-wrap"><pre class="rust macro" data-language="rust">
macro_rules! concat_idents {
     =&gt; { ... };
}</pre></div> <div class="item-info"><div class="stab unstable"><details><summary><span class="emoji">ðŸ”¬</span> This is a nightly-only experimental API. (<code>concat_idents</code> <a href="https://github.com/rust-lang/rust/issues/29599">#29599</a>)</summary><p><code>concat_idents</code> is not stable enough for use and is subject to change</p> </details></div></div>
<details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock">
<p>Concatenates identifiers into one identifier.</p> <p>This macro takes any number of comma-separated identifiers, and concatenates them all into one, yielding an expression which is a new identifier. Note that hygiene makes it such that this macro cannot capture local variables. Also, as a general rule, macros are only allowed in item, statement or expression position. That means while you may use this macro for referring to existing variables, functions or modules etc, you cannot define a new one with it.</p> <h2 id="examples" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(concat_idents)]

fn foobar() -&gt; u32 { 23 }

let f = concat_idents!(foo, bar);
println!("{}", f());

// fn concat_idents!(new, fun, name) { } // not usable in this way!</pre></div> </div></details><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/macro.concat_idents.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/macro.concat_idents.html</a>
  </p>
</div>
