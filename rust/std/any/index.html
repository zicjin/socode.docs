<h1 class="fqn">Module std::any</h1>
<details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock">
<p>This module implements the <code>Any</code> trait, which enables dynamic typing of any <code>'static</code> type through runtime reflection.</p> <p><code>Any</code> itself can be used to get a <code>TypeId</code>, and has more features when used as a trait object. As <code>&amp;dyn Any</code> (a borrowed trait object), it has the <code>is</code> and <code>downcast_ref</code> methods, to test if the contained value is of a given type, and to get a reference to the inner value as a type. As <code>&amp;mut dyn Any</code>, there is also the <code>downcast_mut</code> method, for getting a mutable reference to the inner value. <code>Box&lt;dyn Any&gt;</code> adds the <code>downcast</code> method, which attempts to convert to a <code>Box&lt;T&gt;</code>. See the <a href="../boxed/struct.box"><code>Box</code></a> documentation for the full details.</p> <p>Note that <code>&amp;dyn Any</code> is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.</p> <h2 id="smart-pointers-and-dyn-any" class="section-header">Smart pointers and <code>dyn Any</code>
</h2> <p>One piece of behavior to keep in mind when using <code>Any</code> as a trait object, especially with types like <code>Box&lt;dyn Any&gt;</code> or <code>Arc&lt;dyn Any&gt;</code>, is that simply calling <code>.type_id()</code> on the value will produce the <code>TypeId</code> of the <em>container</em>, not the underlying trait object. This can be avoided by converting the smart pointer into a <code>&amp;dyn Any</code> instead, which will return the object’s <code>TypeId</code>. For example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::any::{Any, TypeId};

let boxed: Box&lt;dyn Any&gt; = Box::new(3_i32);

// You're more likely to want this:
let actual_id = (&amp;*boxed).type_id();
// ... than this:
let boxed_id = boxed.type_id();

assert_eq!(actual_id, TypeId::of::&lt;i32&gt;());
assert_eq!(boxed_id, TypeId::of::&lt;Box&lt;dyn Any&gt;&gt;());</pre></div> <h2 id="examples" class="section-header">Examples</h2> <p>Consider a situation where we want to log out a value passed to a function. We know the value we’re working on implements Debug, but we don’t know its concrete type. We want to give special treatment to certain types: in this case printing out the length of String values prior to their value. We don’t know the concrete type of our value at compile time, so we need to use runtime reflection instead.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::fmt::Debug;
use std::any::Any;

// Logger function for any type that implements Debug.
fn log&lt;T: Any + Debug&gt;(value: &amp;T) {
    let value_any = value as &amp;dyn Any;

    // Try to convert our value to a `String`. If successful, we want to
    // output the String`'s length as well as its value. If not, it's a
    // different type: just print it out unadorned.
    match value_any.downcast_ref::&lt;String&gt;() {
        Some(as_string) =&gt; {
            println!("String ({}): {}", as_string.len(), as_string);
        }
        None =&gt; {
            println!("{:?}", value);
        }
    }
}

// This function wants to log its parameter out prior to doing work with it.
fn do_work&lt;T: Any + Debug&gt;(value: &amp;T) {
    log(value);
    // ...do some other work
}

fn main() {
    let my_string = "Hello World".to_string();
    do_work(&amp;my_string);

    let my_i8: i8 = 100;
    do_work(&amp;my_i8);
}</pre></div> </div></details><h3 id="structs" class="section-header">Structs</h3> <table><tr class="module-item">
<td><a class="struct" href="struct.typeid" title="std::any::TypeId struct">TypeId</a></td>
<td class="docblock-short">
<p>A <code>TypeId</code> represents a globally unique identifier for a type.</p> </td>
</tr></table>
<h3 id="traits" class="section-header">Traits</h3> <table><tr class="module-item">
<td><a class="trait" href="trait.any" title="std::any::Any trait">Any</a></td>
<td class="docblock-short">
<p>A trait to emulate dynamic typing.</p> </td>
</tr></table>
<h3 id="functions" class="section-header">Functions</h3> <table>
<tr class="unstable module-item">
<td><a class="fn" href="fn.type_name_of_val" title="std::any::type_name_of_val fn">type_name_of_val</a></td>
<td class="docblock-short">
<span class="stab unstable" title="">Experimental</span><p>Returns the name of the type of the pointed-to value as a string slice. This is the same as <code>type_name::&lt;T&gt;()</code>, but can be used where the type of a variable is not easily available.</p> </td>
</tr>
<tr class="module-item">
<td><a class="fn" href="fn.type_name" title="std::any::type_name fn">type_name</a></td>
<td class="docblock-short">
<p>Returns the name of a type as a string slice.</p> </td>
</tr>
</table><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.rust-lang.org/std/any/index.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/any/index.html</a>
  </p>
</div>
