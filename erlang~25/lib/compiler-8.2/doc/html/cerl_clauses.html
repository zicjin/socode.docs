  <div class="innertube"> <h2 id="module" class="title-link" onmouseover="document.getElementById('ghlink-module-idm4732').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-module-idm4732').style.visibility = 'hidden';"> <div class="title-name">Module</div>  </h2> <p class="REFBODY module-body">cerl_clauses</p> </div> <div class="innertube"> <h2 id="module-summary" class="title-link" onmouseover="document.getElementById('ghlink-module-summary-idm4733').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-module-summary-idm4733').style.visibility = 'hidden';"> <div class="title-name">Module Summary</div>  </h2> <p class="REFBODY module-summary-body">Utility functions for Core Erlang case/receive clauses.</p> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link" onmouseover="document.getElementById('ghlink-description-idm4734').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-description-idm4734').style.visibility = 'hidden';"> <div class="title-name">Description</div>  </h2> 
<p>Utility functions for Core Erlang case/receive clauses.</p> <p>Syntax trees are defined in the module <code><a href="cerl">cerl</a></code>.</p>  </div></section> <section class="innertube"><h2 id="data-types" class="title-link" onmouseover="document.getElementById('ghlink-data-types-idm4738').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-data-types-idm4738').style.visibility = 'hidden';"> data types  </h2>   <dl id="types"> <dt><strong>bindings() = [{<code id="type-bindings">cerl:cerl()</code>, <code>cerl:cerl()</code>}]</strong></dt>  <dt><strong>cerl() = <code id="type-cerl">cerl:cerl()</code></strong></dt>  <dt><strong>expr() = any | <code id="type-expr">cerl:cerl()</code></strong></dt>  <dt><strong>match_ret() = none | {true, <code id="type-match_ret"><a href="#type-bindings">bindings()</a></code>} | {false, <code><a href="#type-bindings">bindings()</a></code>}</strong></dt>  </dl> </section> <div class="innertube"><h2 id="export" class="title-link" onmouseover="document.getElementById('ghlink-export-idm4764').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-export-idm4764').style.visibility = 'hidden';"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><div><h4 id="any_catchall-1" class="title-link" onmouseover="document.getElementById('ghlink-any_catchall-1-idm4766').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-any_catchall-1-idm4766').style.visibility = 'hidden';">  <div class="title-name">any_catchall(Cs::[<code>cerl:cerl()</code>]) -&gt; boolean()</div> </h4></div> <div class="exports-tube">  <p id="any_catchall-1">Returns <code class="code">true</code> if any of the abstract clauses in the list is a catch-all, otherwise <code class="code">false</code>. See <code class="code">is_catchall/1</code> for details.</p> <p>Note: each node in <code class="code">Clauses</code> must have type <code class="code">clause</code>.</p> <p><strong>See also:</strong> <code><a href="#is_catchall-1">is_catchall/1</a></code>.</p> </div></article><article class="func"><div><h4 id="eval_guard-1" class="title-link" onmouseover="document.getElementById('ghlink-eval_guard-1-idm4782').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-eval_guard-1-idm4782').style.visibility = 'hidden';">  <div class="title-name">eval_guard(E::<code>cerl:cerl()</code>) -&gt; none | {value, term()}</div> </h4></div> <div class="exports-tube">  <p id="eval_guard-1">Tries to reduce a guard expression to a single constant value, if possible. The returned value is <code class="code">{value, Term}</code> if the guard expression <code class="code">Expr</code> always yields the constant value <code class="code">Term</code>, and is otherwise <code class="code">none</code>.</p> <p>Note that although guard expressions should only yield boolean values, this function does not guarantee that <code class="code">Term</code> is either <code class="code">true</code> or <code class="code">false</code>. Also note that only simple constructs like let-expressions are examined recursively; general constant folding is not performed.</p> <p><strong>See also:</strong> <code><a href="#is_catchall-1">is_catchall/1</a></code>.</p> </div></article><article class="func"><div><h4 id="is_catchall-1" class="title-link" onmouseover="document.getElementById('ghlink-is_catchall-1-idm4800').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-is_catchall-1-idm4800').style.visibility = 'hidden';">  <div class="title-name">is_catchall(C::<code>cerl:c_clause()</code>) -&gt; boolean()</div> </h4></div> <div class="exports-tube">  <p id="is_catchall-1">Returns <code class="code">true</code> if an abstract clause is a catch-all, otherwise <code class="code">false</code>. A clause is a catch-all if all its patterns are variables, and its guard expression always evaluates to <code class="code">true</code>; cf. <code class="code">eval_guard/1</code>.</p> <p>Note: <code class="code">Clause</code> must have type <code class="code">clause</code>.</p> <p><strong>See also:</strong> <code><a href="#any_catchall-1">any_catchall/1</a></code>, <code><a href="#eval_guard-1">eval_guard/1</a></code>.</p> </div></article><article class="func"><div><h4 id="match-2" class="title-link" onmouseover="document.getElementById('ghlink-match-2-idm4818').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-match-2-idm4818').style.visibility = 'hidden';">  <div class="title-name">match(P::<code>cerl:cerl()</code>, E::<code><a href="#type-expr">expr()</a></code>) -&gt; <code><a href="#type-match_ret">match_ret()</a></code> </div> </h4></div> <div class="exports-tube">  <p id="match-2">Matches a pattern against an expression. The returned value is <code class="code">none</code> if a match is impossible, <code class="code">{true, Bindings}</code> if <code class="code">Pattern</code> definitely matches <code class="code">Expr</code>, and <code class="code">{false, Bindings}</code> if a match is not definite, but cannot be excluded. <code class="code">Bindings</code> is then a list of pairs <code class="code">{Var, SubExpr}</code>, associating each variable in the pattern with either the corresponding subexpression of <code class="code">Expr</code>, or with the atom <code class="code">any</code> if no matching subexpression exists. (Recall that variables may not be repeated in a Core Erlang pattern.) The list of bindings is given in innermost-first order; this should only be of interest if <code class="code">Pattern</code> contains one or more alias patterns. If the returned value is <code class="code">{true, []}</code>, it implies that the pattern and the expression are syntactically identical.</p> <p>Instead of a syntax tree, the atom <code class="code">any</code> can be passed for <code class="code">Expr</code> (or, more generally, be used for any subtree of <code class="code">Expr</code>, in as much the abstract syntax tree implementation allows it); this means that it cannot be decided whether the pattern will match or not, and the corresponding variable bindings will all map to <code class="code">any</code>. The typical use is for producing bindings for <code class="code">receive</code> clauses.</p> <p>Note: Binary-syntax patterns are never structurally matched against binary-syntax expressions by this function.</p> <p>Examples: </p> <ul> <li><p>Matching a pattern "<code class="code">{X, Y}</code>" against the expression "<code class="code">{foo, f(Z)}</code>" yields <code class="code">{true, Bindings}</code> where <code class="code">Bindings</code> associates "<code class="code">X</code>" with the subtree "<code class="code">foo</code>" and "<code class="code">Y</code>" with the subtree "<code class="code">f(Z)</code>".</p></li> <li><p>Matching pattern "<code class="code">{X, {bar, Y}}</code>" against expression "<code class="code">{foo, f(Z)}</code>" yields <code class="code">{false, Bindings}</code> where <code class="code">Bindings</code> associates "<code class="code">X</code>" with the subtree "<code class="code">foo</code>" and "<code class="code">Y</code>" with <code class="code">any</code> (because it is not known if "<code class="code">{foo, Y}</code>" might match the run-time value of "<code class="code">f(Z)</code>" or not).</p></li> <li><p>Matching pattern "<code class="code">{foo, bar}</code>" against expression "<code class="code">{foo, f()}</code>" yields <code class="code">{false, []}</code>, telling us that there might be a match, but we cannot deduce any bindings.</p></li> <li><p>Matching <code class="code">{foo, X = {bar, Y}}</code> against expression "<code class="code">{foo, {bar, baz}}</code>" yields <code class="code">{true, Bindings}</code> where <code class="code">Bindings</code> associates "<code class="code">Y</code>" with "<code class="code">baz</code>", and "<code class="code">X</code>" with "<code class="code">{bar, baz}</code>".</p></li> <li><p>Matching a pattern "<code class="code">{X, Y}</code>" against <code class="code">any</code> yields <code class="code">{false, Bindings}</code> where <code class="code">Bindings</code> associates both "<code class="code">X</code>" and "<code class="code">Y</code>" with <code class="code">any</code>.</p></li> </ul> </div></article><article class="func"><div><h4 id="match_list-2" class="title-link" onmouseover="document.getElementById('ghlink-match_list-2-idm4893').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-match_list-2-idm4893').style.visibility = 'hidden';">  <div class="title-name">match_list(Ps::[<code>cerl:cerl()</code>], Es::[<code><a href="#type-expr">expr()</a></code>]) -&gt; <code><a href="#type-match_ret">match_ret()</a></code> </div> </h4></div> <div class="exports-tube">  <p id="match_list-2">Like <code class="code">match/2</code>, but matching a sequence of patterns against a sequence of expressions. Passing an empty list for <code class="code">Exprs</code> is equivalent to passing a list of <code class="code">any</code> atoms of the same length as <code class="code">Patterns</code>. </p> <p><strong>See also:</strong> <code><a href="#match-2">match/2</a></code>.</p> </div></article><article class="func"><div><h4 id="reduce-1" class="title-link" onmouseover="document.getElementById('ghlink-reduce-1-idm4909').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-reduce-1-idm4909').style.visibility = 'hidden';">  <div class="title-name">reduce(Cs::[<code>cerl:c_clause()</code>]) -&gt; {true, {<code>cerl:c_clause()</code>, <code><a href="#type-bindings">bindings()</a></code>}} | {false, [<code>cerl:c_clause()</code>]}</div> </h4></div> <div class="exports-tube">  <p id="reduce-1">Equivalent to <code><a href="#reduce-2">reduce(Cs, [])</a></code>.</p> </div></article><article class="func"><div><h4 id="reduce-2" class="title-link" onmouseover="document.getElementById('ghlink-reduce-2-idm4920').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-reduce-2-idm4920').style.visibility = 'hidden';">  <div class="title-name">reduce(Cs::[<code>cerl:c_clause()</code>], Es::[<code><a href="#type-expr">expr()</a></code>]) -&gt; {true, {<code>cerl:c_clause()</code>, <code><a href="#type-bindings">bindings()</a></code>}} | {false, [<code>cerl:c_clause()</code>]}</div> </h4></div> <div class="exports-tube">  <p id="reduce-2">Selects a single clause, if possible, or otherwise reduces the list of selectable clauses. The input is a list <code class="code">Clauses</code> of abstract clauses (i.e., syntax trees of type <code class="code">clause</code>), and a list of switch expressions <code class="code">Exprs</code>. The function tries to uniquely select a single clause or discard unselectable clauses, with respect to the switch expressions. All abstract clauses in the list must have the same number of patterns. If <code class="code">Exprs</code> is not the empty list, it must have the same length as the number of patterns in each clause; see <code class="code">match_list/2</code> for details.</p> <p>A clause can only be selected if its guard expression always yields the atom <code class="code">true</code>, and a clause whose guard expression always yields the atom <code class="code">false</code> can never be selected. Other guard expressions are considered to have unknown value; cf. <code class="code">eval_guard/1</code>.</p> <p>If a particular clause can be selected, the function returns <code class="code">{true, {Clause, Bindings}}</code>, where <code class="code">Clause</code> is the selected clause and <code class="code">Bindings</code> is a list of pairs <code class="code">{Var, SubExpr}</code> associating the variables occurring in the patterns of <code class="code">Clause</code> with the corresponding subexpressions in <code class="code">Exprs</code>. The list of bindings is given in innermost-first order; see the <code class="code">match/2</code> function for details.</p> <p>If no clause could be definitely selected, the function returns <code class="code">{false, NewClauses}</code>, where <code class="code">NewClauses</code> is the list of entries in <code class="code">Clauses</code> that remain after eliminating unselectable clauses, preserving the relative order.</p> <p><strong>See also:</strong> <code><a href="#eval_guard-1">eval_guard/1</a></code>, <code><a href="#match-2">match/2</a></code>, <code><a href="#match_list-2">match_list/2</a></code>.</p> </div></article> </div> Richard Carlsson carlsson.richard@gmail.com<div class="footer"> <hr> <p>Copyright © 1997-2022 Ericsson AB. All Rights Reserved.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2022 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
