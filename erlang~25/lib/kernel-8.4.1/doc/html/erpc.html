  <div class="innertube"> <h2 id="module" class="title-link" onmouseover="document.getElementById('ghlink-module-idm6700').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-module-idm6700').style.visibility = 'hidden';"> <div class="title-name">Module</div>  </h2> <p class="REFBODY module-body">erpc</p> </div> <div class="innertube"> <h2 id="module-summary" class="title-link" onmouseover="document.getElementById('ghlink-module-summary-idm6701').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-module-summary-idm6701').style.visibility = 'hidden';"> <div class="title-name">Module Summary</div>  </h2> <p class="REFBODY module-summary-body">Enhanced Remote Procedure Call</p> <h2 id="since" class="title-link" onmouseover="document.getElementById('ghlink-since-idm6701').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-since-idm6701').style.visibility = 'hidden';"> <div class="title-name">Since</div>  </h2> <p class="REFBODY module-since"> Module erpc was introduced in OTP 23.0. </p> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link" onmouseover="document.getElementById('ghlink-description-idm6702').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-description-idm6702').style.visibility = 'hidden';"> <div class="title-name">Description</div>  </h2> 
<p> This module provide services similar to Remote Procedure Calls. A remote procedure call is a method to call a function on a remote node and collect the answer. It is used for collecting information on a remote node, or for running a function with some specific side effects on the remote node. </p> <p> This is an enhanced subset of the operations provided by the <code><a href="rpc"><span class="code">rpc</span></a></code> module. Enhanced in the sense that it makes it possible to distinguish between returned value, raised exceptions, and other errors. <code class="code">erpc</code> also has better performance and scalability than the original <code class="code">rpc</code> implementation. However, current <code class="code">rpc</code> module will utilize <code class="code">erpc</code> in order to also provide these properties when possible. </p> <p> In order for an <code class="code">erpc</code> operation to succeed, the remote node also needs to support <code class="code">erpc</code>. Typically only ordinary Erlang nodes as of OTP 23 have <code class="code">erpc</code> support. </p> <p> Note that it is up to the user to ensure that correct code to execute via <code class="code">erpc</code> is available on the involved nodes. </p>  </div></section> <div class="innertube"> <h2 id="data-types" class="title-link" onmouseover="document.getElementById('ghlink-data-types-idm6717').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-data-types-idm6717').style.visibility = 'hidden';"> <div class="title-name">Data Types</div>  </h2> <article class="data-types-body"><h4 id="type-request_id" class="title-link data-type-name" onmouseover="document.getElementById('ghlink-type-request_id').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-request_id').style.visibility = 'hidden';">  <div class="title-name"> <code id="type-request_id">request_id()</code><br> </div> </h4> <div class="data-type-desc"> <p> An opaque request identifier. For more information see <code><a href="#send_request-4"><span class="code">send_request/4</span></a></code>. </p> </div></article> <article class="data-types-body"><h4 id="type-request_id_collection" class="title-link data-type-name" onmouseover="document.getElementById('ghlink-type-request_id_collection').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-request_id_collection').style.visibility = 'hidden';">  <div class="title-name"> <code id="type-request_id_collection">request_id_collection()</code><br> </div> </h4> <div class="data-type-desc"> <p> An opaque collection of request identifiers (<code><a href="#type-request_id"><span class="code">request_id()</span></a></code>) where each request identifier can be associated with a label chosen by the user. For more information see <code><a href="#reqids_new-0"><span class="code">reqids_new/0</span></a></code>. </p> </div></article> <article class="data-types-body"><h4 id="type-timeout_time" class="title-link data-type-name" onmouseover="document.getElementById('ghlink-type-timeout_time').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-timeout_time').style.visibility = 'hidden';">  <div class="title-name"> <code>timeout_time() = 0..4294967295 | infinity | {abs, <span id="type-timeout_time">integer()</span>}</code><br> </div> </h4> <div class="data-type-desc"> <dl> <dt><strong><code class="code">0..4294967295</code></strong></dt> <dd><p> Timeout relative to current time in milliseconds. </p></dd> <dt><strong><code class="code">infinity</code></strong></dt> <dd><p> Infinite timeout. That is, the operation will never time out. </p></dd> <dt><strong><code class="code">{abs, Timeout}</code></strong></dt> <dd><p> An absolute <code>Erlang monotonic time</code> timeout in milliseconds. That is, the operation will time out when <code><span class="code">erlang:monotonic_time(millisecond)</span></code> returns a value larger than or equal to <code class="code">Timeout</code>. <code class="code">Timeout</code> is not allowed to identify a time further into the future than <code class="code">4294967295</code> milliseconds. Identifying the timeout using an absolute timeout value is especially handy when you have a deadline for responses corresponding to a complete collection of requests (<code><a href="#type-request_id_collection"><span class="code">request_id_collection()</span></a></code>) , since you do not have to recalculate the relative time until the deadline over and over again. </p></dd> </dl> </div></article> </div> <div class="innertube"><h2 id="export" class="title-link" onmouseover="document.getElementById('ghlink-export-idm6756').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-export-idm6756').style.visibility = 'hidden';"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h4 id="call-2" onmouseover="document.getElementById('ghlink-call-2-idp147').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-call-2-idp147').style.visibility = 'hidden';">  <span class="title-name">call(Node, Fun) -&gt; Result</span><div class="title-since"><span class="since">OTP 23.0</span></div> </h4> <h4 id="call-3" onmouseover="document.getElementById('ghlink-call-3-idp148').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-call-3-idp148').style.visibility = 'hidden';">  <span class="title-name">call(Node, Fun, Timeout) -&gt; Result</span><div class="title-since"><span class="since">OTP 23.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>      <div class="exports-tube"> <p> The same as calling <code><a href="#call-5"><span class="code">erpc:call(Node, erlang, apply, [Fun,[]], Timeout)</span></a></code>. May raise all the same exceptions as <code class="code">call/5</code> plus an <code class="code">{erpc, badarg}</code> <code class="code">error</code> exception if <code class="code">Fun</code> is not a fun of zero arity. </p> <p> The call <code class="code">erpc:call(Node,Fun)</code> is the same as the call <code class="code">erpc:call(Node,Fun,infinity)</code>. </p> </div></article><article class="func"><h4 id="call-4" onmouseover="document.getElementById('ghlink-call-4-idp149').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-call-4-idp149').style.visibility = 'hidden';">  <span class="title-name">call(Node, Module, Function, Args) -&gt; Result</span><div class="title-since"><span class="since">OTP 23.0</span></div> </h4> <h4 id="call-5" onmouseover="document.getElementById('ghlink-call-5-idp150').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-call-5-idp150').style.visibility = 'hidden';">  <span class="title-name">call(Node, Module, Function, Args, Timeout) -&gt; Result</span><div class="title-since"><span class="since">OTP 23.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>        <div class="exports-tube"> <p> Evaluates <code class="code">apply(Module, Function, Args)</code> on node <code class="code">Node</code> and returns the corresponding value <code class="code">Result</code>. <code class="code">Timeout</code> sets an upper time limit for the <code class="code">call</code> operation to complete. </p> <p>The call <code class="code">erpc:call(Node, Module, Function, Args)</code> is equivalent to the call <code class="code">erpc:call(Node, Module, Function, Args, infinity)</code></p> <p> The <code class="code">call()</code> function only returns if the applied function successfully returned without raising any uncaught exceptions, the operation did not time out, and no failures occurred. In all other cases an exception is raised. The following exceptions, listed by exception class, can currently be raised by <code class="code">call()</code>: </p> <dl> <dt><strong><code class="code">throw</code></strong></dt> <dd><p> The applied function called <code class="code">throw(Value)</code> and did not catch this exception. The exception reason <code class="code">Value</code> equals the argument passed to <code class="code">throw/1</code>. </p></dd> <dt><strong><code class="code">exit</code></strong></dt> <dd> <p> Exception reason: </p> <dl> <dt><strong><code class="code">{exception, ExitReason}</code></strong></dt> <dd><p> The applied function called <code class="code">exit(ExitReason)</code> and did not catch this exception. The exit reason <code class="code">ExitReason</code> equals the argument passed to <code class="code">exit/1</code>. </p></dd> <dt><strong><code class="code">{signal, ExitReason}</code></strong></dt> <dd><p> The process that applied the function received an exit signal and terminated due to this signal. The process terminated with exit reason <code class="code">ExitReason</code>. </p></dd> </dl> </dd> <dt><strong><code class="code">error</code></strong></dt> <dd> <p> Exception reason: </p> <dl> <dt><strong><code class="code">{exception, ErrorReason, StackTrace}</code></strong></dt> <dd><p> A runtime error occurred which raised an error exception while applying the function, and the applied function did not catch the exception. The error reason <code class="code">ErrorReason</code> indicates the type of error that occurred. <code class="code">StackTrace</code> is formatted as when caught in a <code class="code">try/catch</code> construct. The <code class="code">StackTrace</code> is limited to the applied function and functions called by it. </p></dd> <dt><strong><code class="code">{erpc, ERpcErrorReason}</code></strong></dt> <dd> <p> The <code class="code">erpc</code> operation failed. The following <code class="code">ERpcErrorReason</code>s are the most common ones: </p> <dl> <dt><strong><code class="code">badarg</code></strong></dt> <dd> <p>If any one of these are true:</p> <ul> <li><p><code class="code">Node</code> is not an atom.</p></li> <li><p><code class="code">Module</code> is not an atom.</p></li> <li><p><code class="code">Function</code> is not an atom.</p></li> <li><p><code class="code">Args</code> is not a list. Note that the list is not verified to be a proper list at the client side.</p></li> <li><p><code class="code">Timeout</code> is invalid.</p></li> </ul> </dd> <dt><strong><code class="code">noconnection</code></strong></dt> <dd><p> The connection to <code class="code">Node</code> was lost or could not be established. The function may or may not be applied. </p></dd> <dt><strong><code class="code">system_limit</code></strong></dt> <dd><p> The <code class="code">erpc</code> operation failed due to some system limit being reached. This typically due to failure to create a process on the remote node <code class="code">Node</code>, but can be other things as well. </p></dd> <dt><strong><code class="code">timeout</code></strong></dt> <dd><p> The <code class="code">erpc</code> operation timed out. The function may or may not be applied. </p></dd> <dt><strong><code class="code">notsup</code></strong></dt> <dd> <p> The remote node <code class="code">Node</code> does not support this <code class="code">erpc</code> operation. </p> </dd> </dl> </dd> </dl> </dd> </dl> <p> If the <code class="code">erpc</code> operation fails, but it is unknown if the function is/will be applied (that is, a timeout or a connection loss), the caller will not receive any further information about the result if/when the applied function completes. If the applied function explicitly communicates with the calling process, such communication may, of course, reach the calling process. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> You cannot make <strong>any</strong> assumptions about the process that will perform the <code class="code">apply()</code>. It may be the calling process itself, a server, or a freshly spawned process. </p> </div> </div> </div></article><article class="func"><h4 id="cast-2" onmouseover="document.getElementById('ghlink-cast-2-idp151').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-cast-2-idp151').style.visibility = 'hidden';">  <span class="title-name">cast(Node, Fun) -&gt; ok</span><div class="title-since"><span class="since">OTP 23.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>    <div class="exports-tube"> <p> The same as calling <code><a href="#cast-4"><span class="code">erpc:cast(Node,erlang,apply,[Fun,[]])</span></a></code>. </p> <p><code class="code">cast/2</code> fails with an <code class="code">{erpc, badarg}</code> <code class="code">error</code> exception if:</p> <ul> <li><p><code class="code">Node</code> is not an atom.</p></li> <li><p><code class="code">Fun</code> is not a a fun of zero arity.</p></li> </ul> </div></article><article class="func"><h4 id="cast-4" onmouseover="document.getElementById('ghlink-cast-4-idp152').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-cast-4-idp152').style.visibility = 'hidden';">  <span class="title-name">cast(Node, Module, Function, Args) -&gt; ok</span><div class="title-since"><span class="since">OTP 23.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>      <div class="exports-tube"> <p> Evaluates <code class="code">apply(Module, Function, Args)</code> on node <code class="code">Node</code>. No response is delivered to the calling process. <code class="code">cast()</code> returns immediately after the cast request has been sent. Any failures beside bad arguments are silently ignored. </p> <p><code class="code">cast/4</code> fails with an <code class="code">{erpc, badarg}</code> <code class="code">error</code> exception if:</p> <ul> <li><p><code class="code">Node</code> is not an atom.</p></li> <li><p><code class="code">Module</code> is not an atom.</p></li> <li><p><code class="code">Function</code> is not an atom.</p></li> <li><p><code class="code">Args</code> is not a list. Note that the list is not verified to be a proper list at the client side.</p></li> </ul> <div class="note"> <div class="label">Note</div> <div class="content">

<p> You cannot make <strong>any</strong> assumptions about the process that will perform the <code class="code">apply()</code>. It may be a server, or a freshly spawned process. </p> </div> </div> </div></article><article class="func"><h4 id="check_response-2" onmouseover="document.getElementById('ghlink-check_response-2-idp153').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-check_response-2-idp153').style.visibility = 'hidden';">  <span class="title-name">check_response(Message, RequestId) -&gt;<br> {response, Result} | no_response</span><div class="title-since"><span class="since">OTP 23.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>     <div class="exports-tube"> <p> Check if a message is a response to a <code class="code">call</code> request previously made by the calling process using <code><a href="#send_request-4"><span class="code">send_request/4</span></a></code>. <code class="code">RequestId</code> should be the value returned from the previously made <code class="code">send_request/4</code> call, and the corresponding response should not already have been received and handled to completion by <code class="code">check_response/2</code>, <code><a href="#receive_response-2"><span class="code">receive_response/2</span></a></code>, or <code><a href="#wait_response-2"><span class="code">wait_response/2</span></a></code>. <code class="code">Message</code> is the message to check. </p> <p> If <code class="code">Message</code> does not correspond to the response, the atom <code class="code">no_response</code> is returned. If <code class="code">Message</code> corresponds to the response, the <code class="code">call</code> operation is completed and either the result is returned as <code class="code">{response, Result}</code> where <code class="code">Result</code> corresponds to the value returned from the applied function or an exception is raised. The exceptions that can be raised corresponds to the same exceptions as can be raised by <code><a href="#call-4"><span class="code">call/4</span></a></code>. That is, no <code class="code">{erpc, timeout}</code> <code class="code">error</code> exception can be raised. <code class="code">check_response()</code> will fail with an <code class="code">{erpc, badarg}</code> exception if/when an invalid <code class="code">RequestId</code> is detected. </p> <p> If the <code class="code">erpc</code> operation fails, but it is unknown if the function is/will be applied (that is, a connection loss), the caller will not receive any further information about the result if/when the applied function completes. If the applied function explicitly communicates with the calling process, such communication may, of course, reach the calling process. </p> </div></article><article class="func"><h4 id="check_response-3" onmouseover="document.getElementById('ghlink-check_response-3-idp154').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-check_response-3-idp154').style.visibility = 'hidden';">  <span class="title-name">check_response(Message, RequestIdCollection, Delete) -&gt;<br> {{response, Result},<br> Label, NewRequestIdCollection} |<br> no_response | no_request</span><div class="title-since"><span class="since">OTP 25.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>        <div class="exports-tube"> <p> Check if a message is a response to a <code class="code">call</code> request corresponding to a request identifier saved in <code class="code">RequestIdCollection</code>. All request identifiers of <code class="code">RequestIdCollection</code> must correspond to requests that have been made using <code><a href="#send_request-4"><span class="code">send_request/4</span></a></code> or <code><a href="#send_request-6"><span class="code">send_request/6</span></a></code>, and all requests must have been made by the process calling this function. </p> <p> <code class="code">Label</code> is the label associated with the request identifier of the request that the response corresponds to. A request identifier is associated with a label when <code><a href="#reqids_add-3">adding a request identifier</a></code> in a <code><a href="#type-request_id_collection">request identifier collection</a></code>, or when sending the request using <code><a href="#send_request-6"><span class="code">send_request/6</span></a></code>. </p> <p> Compared to <code><a href="#check_response-2"><span class="code">check_response/2</span></a></code>, the returned result associated with a specific request identifier or an exception associated with a specific request identifier will be wrapped in a 3-tuple. The first element of this tuple equals the value that would have been produced by <code class="code">check_response/2</code>, the second element equals the <code class="code">Label</code> associated with the specific request identifier, and the third element <code class="code">NewRequestIdCollection</code> is a possibly modified request identifier collection. The <code class="code">error</code> exception <code class="code">{erpc, badarg}</code> is not associated with any specific request identifier, and will hence not be wrapped. </p> <p> If <code class="code">RequestIdCollection</code> is empty, the atom <code class="code">no_request</code> will be returned. If <code class="code">Message</code> does not correspond to any of the request identifiers in <code class="code">RequestIdCollection</code>, the atom <code class="code">no_response</code> is returned. </p> <p> If <code class="code">Delete</code> equals <code class="code">true</code>, the association with <code class="code">Label</code> will have been deleted from <code class="code">RequestIdCollection</code> in the resulting <code class="code">NewRequestIdCollection</code>. If <code class="code">Delete</code> equals <code class="code">false</code>, <code class="code">NewRequestIdCollection</code> will equal <code class="code">RequestIdCollection</code>. Note that deleting an association is not for free and that a collection containing already handled requests can still be used by subsequent calls to <code class="code">check_response/3</code>, <code><a href="#receive_response-3"><span class="code">receive_response/3</span></a></code>, and <code><a href="#wait_response-3"><span class="code">wait_response/3</span></a></code>. However, without deleting handled associations, the above calls will not be able to detect when there are no more outstanding requests to handle, so you will have to keep track of this some other way than relying on a <code class="code">no_request</code> return. Note that if you pass a collection only containing associations of already handled or abandoned requests to <code class="code">check_response/3</code>, it will always return <code class="code">no_response</code>. </p> <p> Note that a response might have been consumed uppon an <code class="code">{erpc, badarg}</code> exception and if so, will be lost for ever. </p> </div></article><article class="func"><h4 id="multicall-2" onmouseover="document.getElementById('ghlink-multicall-2-idp155').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-multicall-2-idp155').style.visibility = 'hidden';">  <span class="title-name">multicall(Nodes, Fun) -&gt; Result</span><div class="title-since"><span class="since">OTP 23.0</span></div> </h4> <h4 id="multicall-3" onmouseover="document.getElementById('ghlink-multicall-3-idp156').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-multicall-3-idp156').style.visibility = 'hidden';">  <span class="title-name">multicall(Nodes, Fun, Timeout) -&gt; Result</span><div class="title-since"><span class="since">OTP 23.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>      <div class="exports-tube"> <p> The same as calling <code><a href="#multicall-5"><span class="code">erpc:multicall(Nodes, erlang, apply, [Fun,[]], Timeout)</span></a></code>. May raise all the same exceptions as <code class="code">multicall/5</code> plus an <code class="code">{erpc, badarg}</code> <code class="code">error</code> exception if <code class="code">Fun</code> is not a fun of zero arity. </p> <p> The call <code class="code">erpc:multicall(Nodes,Fun)</code> is the same as the call <code class="code">erpc:multicall(Nodes,Fun, infinity)</code>. </p> </div></article><article class="func"><h4 id="multicall-4" onmouseover="document.getElementById('ghlink-multicall-4-idp157').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-multicall-4-idp157').style.visibility = 'hidden';">  <span class="title-name">multicall(Nodes, Module, Function, Args) -&gt; Result</span><div class="title-since"><span class="since">OTP 23.0</span></div> </h4> <h4 id="multicall-5" onmouseover="document.getElementById('ghlink-multicall-5-idp158').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-multicall-5-idp158').style.visibility = 'hidden';">  <span class="title-name">multicall(Nodes, Module, Function, Args, Timeout) -&gt; Result</span><div class="title-since"><span class="since">OTP 23.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>          <div class="exports-tube"> <p> Performs multiple <code class="code">call</code> operations in parallel on multiple nodes. That is, evaluates <code class="code">apply(Module, Function, Args)</code> on the nodes <code class="code">Nodes</code> in parallel. <code class="code">Timeout</code> sets an upper time limit for all <code class="code">call</code> operations to complete. The result is returned as a list where the result from each node is placed at the same position as the node name is placed in <code class="code">Nodes</code>. Each item in the resulting list is formatted as either: </p> <dl> <dt><strong><code class="code">{ok, Result}</code></strong></dt> <dd><p> The <code class="code">call</code> operation for this specific node returned <code class="code">Result</code>. </p></dd> <dt><strong><code class="code">{Class, ExceptionReason}</code></strong></dt> <dd><p> The <code class="code">call</code> operation for this specific node raised an exception of class <code class="code">Class</code> with exception reason <code class="code">ExceptionReason</code>. These corresponds the the exceptions that <code><a href="#call-5"><span class="code">call/5</span></a></code> can raise. </p></dd> </dl> <p><code class="code">multicall/5</code> fails with an <code class="code">{erpc, badarg}</code> <code class="code">error</code> exception if:</p> <ul> <li><p><code class="code">Nodes</code> is not a proper list of atoms. Note that some requests may already have been sent when the failure occurs. That is, the function may or may not be applied on some nodes.</p></li> <li><p><code class="code">Module</code> is not an atom.</p></li> <li><p><code class="code">Function</code> is not an atom.</p></li> <li><p><code class="code">Args</code> is not a list. Note that the list is not verified to be a proper list at the client side.</p></li> </ul> <p> The call <code class="code">erpc:multicall(Nodes, Module, Function, Args)</code> is equivalent to the call <code class="code">erpc:multicall(Nodes, Module, Function, Args, infinity)</code>. These calls are also equivalent to calling <code class="code">my_multicall(Nodes, Module, Function, Args)</code> below if one disregard performance and failure behavior. <code class="code">multicall()</code> can utilize a selective receive optimization which removes the need to scan the message queue from the beginning in order to find a matching message. The <code class="code">send_request()/receive_response()</code> combination can, however, not utilize this optimization. </p> <pre data-language="erlang">
my_multicall(Nodes, Module, Function, Args) -&gt;
  ReqIds = lists:map(fun (Node) -&gt;
                       <a href="#send_request-4">erpc:send_request(Node, Module, Function, Args)</a>
                     end,
                     Nodes),
  lists:map(fun (ReqId) -&gt;
              try
                {ok, <a href="#receive_response-2">erpc:receive_response(ReqId, infinity)</a>}
              catch
                Class:Reason -&gt;
                  {Class, Reason}
              end
            end,
            ReqIds).
</pre> <p> If an <code class="code">erpc</code> operation fails, but it is unknown if the function is/will be applied (that is, a timeout, connection loss, or an improper <code class="code">Nodes</code> list), the caller will not receive any further information about the result if/when the applied function completes. If the applied function communicates with the calling process, such communication may, of course, reach the calling process. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> You cannot make <strong>any</strong> assumptions about the process that will perform the <code class="code">apply()</code>. It may be the calling process itself, a server, or a freshly spawned process. </p> </div> </div> </div></article><article class="func"><h4 id="multicast-2" onmouseover="document.getElementById('ghlink-multicast-2-idp159').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-multicast-2-idp159').style.visibility = 'hidden';">  <span class="title-name">multicast(Nodes, Fun) -&gt; ok</span><div class="title-since"><span class="since">OTP 23.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>    <div class="exports-tube"> <p> The same as calling <code><a href="#multicast-4"><span class="code">erpc:multicast(Nodes,erlang,apply,[Fun,[]])</span></a></code>. </p> <p><code class="code">multicast/2</code> fails with an <code class="code">{erpc, badarg}</code> <code class="code">error</code> exception if:</p> <ul> <li><p><code class="code">Nodes</code> is not a proper list of atoms.</p></li> <li><p><code class="code">Fun</code> is not a a fun of zero arity.</p></li> </ul> </div></article><article class="func"><h4 id="multicast-4" onmouseover="document.getElementById('ghlink-multicast-4-idp160').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-multicast-4-idp160').style.visibility = 'hidden';">  <span class="title-name">multicast(Nodes, Module, Function, Args) -&gt; ok</span><div class="title-since"><span class="since">OTP 23.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>      <div class="exports-tube"> <p> Evaluates <code class="code">apply(Module, Function, Args)</code> on the nodes <code class="code">Nodes</code>. No response is delivered to the calling process. <code class="code">multicast()</code> returns immediately after the cast requests have been sent. Any failures beside bad arguments are silently ignored. </p> <p><code class="code">multicast/4</code> fails with an <code class="code">{erpc, badarg}</code> <code class="code">error</code> exception if:</p> <ul> <li><p><code class="code">Nodes</code> is not a proper list of atoms. Note that some requests may already have been sent when the failure occurs. That is, the function may or may not be applied on some nodes.</p></li> <li><p><code class="code">Module</code> is not an atom.</p></li> <li><p><code class="code">Function</code> is not an atom.</p></li> <li><p><code class="code">Args</code> is not a list. Note that the list is not verified to be a proper list at the client side.</p></li> </ul> <div class="note"> <div class="label">Note</div> <div class="content">

<p> You cannot make <strong>any</strong> assumptions about the process that will perform the <code class="code">apply()</code>. It may be a server, or a freshly spawned process. </p> </div> </div> </div></article><article class="func"><h4 id="receive_response-1" onmouseover="document.getElementById('ghlink-receive_response-1-idp161').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-receive_response-1-idp161').style.visibility = 'hidden';">  <span class="title-name">receive_response(RequestId) -&gt; Result</span><div class="title-since"><span class="since">OTP 23.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>    <div class="exports-tube"> <p> The same as calling <code><a href="#receive_response-2"><span class="code">erpc:receive_response(RequestId, infinity)</span></a></code>. </p> </div></article><article class="func"><h4 id="receive_response-2" onmouseover="document.getElementById('ghlink-receive_response-2-idp162').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-receive_response-2-idp162').style.visibility = 'hidden';">  <span class="title-name">receive_response(RequestId, Timeout) -&gt; Result</span><div class="title-since"><span class="since">OTP 23.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>     <div class="exports-tube"> <p> Receive a response to a <code class="code">call</code> request previously made by the calling process using <code><a href="#send_request-4"><span class="code">send_request/4</span></a></code>. <code class="code">RequestId</code> should be the value returned from the previously made <code class="code">send_request/4</code> call, and the corresponding response should not already have been received and handled to completion by <code class="code">receive_response()</code>, <code><a href="#check_response-2"><span class="code">check_response/4</span></a></code>, or <code><a href="#wait_response-2"><span class="code">wait_response/4</span></a></code>. </p> <p> <code class="code">Timeout</code> sets an upper time limit on how long to wait for a response. If the operation times out, the request identified by <code class="code">RequestId</code> will be abandoned, then an <code class="code">{erpc, timeout}</code> <code class="code">error</code> exception will be raised. That is, no response corresponding to the request will ever be received after a timeout. If a response is received, the <code class="code">call</code> operation is completed and either the result is returned or an exception is raised. The exceptions that can be raised corresponds to the same exceptions as can be raised by <code><a href="#call-5"><span class="code">call/5</span></a></code>. <code class="code">receive_response/2</code> will fail with an <code class="code">{erpc, badarg}</code> exception if/when an invalid <code class="code">RequestId</code> is detected or if an invalid <code class="code">Timeout</code> is passed. </p> <p> A call to the function <code class="code">my_call(Node, Module, Function, Args, Timeout)</code> below is equivalent to the call <code><a href="#call-5"><span class="code">erpc:call(Node, Module, Function, Args, Timeout)</span></a></code> if one disregards performance. <code class="code">call()</code> can utilize a selective receive optimization which removes the need to scan the message queue from the beginning in order to find a matching message. The <code class="code">send_request()/receive_response()</code> combination can, however, not utilize this optimization. </p> <pre data-language="erlang">
my_call(Node, Module, Function, Args, Timeout) -&gt;
  RequestId = <a href="#send_request-4">erpc:send_request(Node, Module, Function, Args)</a>,
  erpc:receive_response(RequestId, Timeout).
</pre> <p> If the <code class="code">erpc</code> operation fails, but it is unknown if the function is/will be applied (that is, a timeout, or a connection loss), the caller will not receive any further information about the result if/when the applied function completes. If the applied function explicitly communicates with the calling process, such communication may, of course, reach the calling process. </p> </div></article><article class="func"><h4 id="receive_response-3" onmouseover="document.getElementById('ghlink-receive_response-3-idp163').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-receive_response-3-idp163').style.visibility = 'hidden';">  <span class="title-name">receive_response(RequestIdCollection, Timeout, Delete) -&gt;<br> {Result, Label, NewRequestIdCollection} |<br> no_request</span><div class="title-since"><span class="since">OTP 25.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>        <div class="exports-tube"> <p> Receive a response to a <code class="code">call</code> request corresponding to a request identifier saved in <code class="code">RequestIdCollection</code>. All request identifiers of <code class="code">RequestIdCollection</code> must correspond to requests that have been made using <code><a href="#send_request-4"><span class="code">send_request/4</span></a></code> or <code><a href="#send_request-6"><span class="code">send_request/6</span></a></code>, and all requests must have been made by the process calling this function. </p> <p> <code class="code">Label</code> is the label associated with the request identifier of the request that the response corresponds to. A request identifier is associated with a label when <code><a href="#reqids_add-3">adding a request identifier</a></code> in a <code><a href="#type-request_id_collection">request identifier collection</a></code>, or when sending the request using <code><a href="#send_request-6"><span class="code">send_request/6</span></a></code>. </p> <p> Compared to <code><a href="#receive_response-2"><span class="code">receive_response/2</span></a></code>, the returned result associated with a specific request identifier or an exception associated with a specific request identifier will be wrapped in a 3-tuple. The first element of this tuple equals the value that would have been produced by <code class="code">receive_response/2</code>, the second element equals the <code class="code">Label</code> associated with the specific request identifier, and the third element <code class="code">NewRequestIdCollection</code> is a possibly modified request identifier collection. The <code class="code">error</code> exceptions <code class="code">{erpc, badarg}</code> and <code class="code">{erpc, timeout}</code> are not associated with any specific request identifiers, and will hence not be wrapped. </p> <p> If <code class="code">RequestIdCollection</code> is empty, the atom <code class="code">no_request</code> will be returned. </p> <p> If the operation times out, all requests identified by <code class="code">RequestIdCollection</code> will be abandoned, then an <code class="code">{erpc, timeout}</code> <code class="code">error</code> exception will be raised. That is, no responses corresponding to any of the request identifiers in <code class="code">RequestIdCollection</code> will ever be received after a timeout. The difference between <code class="code">receive_response/3</code> and <code><a href="#wait_response-3"><span class="code">wait_response/3</span></a></code> is that <code class="code">receive_response/3</code> abandons the requests at timeout so that any potential future responses are ignored, while <code class="code">wait_response/3</code> does not. </p> <p> If <code class="code">Delete</code> equals <code class="code">true</code>, the association with <code class="code">Label</code> will have been deleted from <code class="code">RequestIdCollection</code> in the resulting <code class="code">NewRequestIdCollection</code>. If <code class="code">Delete</code> equals <code class="code">false</code>, <code class="code">NewRequestIdCollection</code> will equal <code class="code">RequestIdCollection</code>. Note that deleting an association is not for free and that a collection containing already handled requests can still be used by subsequent calls to <code class="code">receive_response/3</code>, <code><a href="#check_response-3"><span class="code">check_response/3</span></a></code>, and <code><a href="#wait_response-3"><span class="code">wait_response/3</span></a></code>. However, without deleting handled associations, the above calls will not be able to detect when there are no more outstanding requests to handle, so you will have to keep track of this some other way than relying on a <code class="code">no_request</code> return. Note that if you pass a collection only containing associations of already handled or abandoned requests to <code class="code">receive_response/3</code>, it will always block until a timeout determined by <code class="code">Timeout</code> is triggered. </p> <p> Note that a response might have been consumed uppon an <code class="code">{erpc, badarg}</code> exception and if so, will be lost for ever. </p> </div></article><article class="func"><h4 id="reqids_add-3" onmouseover="document.getElementById('ghlink-reqids_add-3-idp164').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-reqids_add-3-idp164').style.visibility = 'hidden';">  <span class="title-name">reqids_add(RequestId :: <code><a href="#type-request_id">request_id()</a></code>,<br> Label :: <code>term()</code>,<br> RequestIdCollection :: <code><a href="#type-request_id_collection">request_id_collection()</a></code>) -&gt;<br> NewRequestIdCollection :: <code><a href="#type-request_id_collection">request_id_collection()</a></code></span><div class="title-since"><span class="since">OTP 25.0</span></div> </h4> <div class="exports-tube"> <p> Saves <code class="code">RequestId</code> and associates a <code class="code">Label</code> with the request identifier by adding this information to <code class="code">RequestIdCollection</code> and returning the resulting request identifier collection. </p> </div></article><article class="func"><h4 id="reqids_new-0" onmouseover="document.getElementById('ghlink-reqids_new-0-idp165').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-reqids_new-0-idp165').style.visibility = 'hidden';">  <span class="title-name">reqids_new() -&gt; NewRequestIdCollection :: <code><a href="#type-request_id_collection">request_id_collection()</a></code></span><div class="title-since"><span class="since">OTP 25.0</span></div> </h4> <div class="exports-tube"> <p> Returns a new empty request identifier collection. A request identifier collection can be utilized in order the handle multiple outstanding requests. </p> <p> Request identifiers of requests made by <code><a href="#send_request-4"><span class="code">send_request/4</span></a></code> can be saved in a request identifier collection using <code><a href="#reqids_add-3"><span class="code">reqids_add/3</span></a></code>. Such a collection of request identifiers can later be used in order to get one response corresponding to a request in the collection by passing the collection as argument to <code><a href="#check_response-3"><span class="code">check_response/3</span></a></code>, <code><a href="#receive_response-3"><span class="code">receive_response/3</span></a></code>, and <code><a href="#wait_response-3"><span class="code">wait_response/3</span></a></code>. </p> <p> <code><a href="#reqids_size-1"><span class="code">reqids_size/1</span></a></code> can be used to determine the amount of request identifiers in a request identifier collection. </p> </div></article><article class="func"><h4 id="reqids_size-1" onmouseover="document.getElementById('ghlink-reqids_size-1-idp166').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-reqids_size-1-idp166').style.visibility = 'hidden';">  <span class="title-name">reqids_size(RequestIdCollection :: <code><a href="#type-request_id_collection">request_id_collection()</a></code>) -&gt;<br> <code>integer() &gt;= 0</code></span><div class="title-since"><span class="since">OTP 25.0</span></div> </h4> <div class="exports-tube"> <p> Returns the amount of request identifiers saved in <code class="code">RequestIdCollection</code>. </p> </div></article><article class="func"><h4 id="reqids_to_list-1" onmouseover="document.getElementById('ghlink-reqids_to_list-1-idp167').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-reqids_to_list-1-idp167').style.visibility = 'hidden';">  <span class="title-name">reqids_to_list(RequestIdCollection :: <code><a href="#type-request_id_collection">request_id_collection()</a></code>) -&gt;<br> [{RequestId :: <code><a href="#type-request_id">request_id()</a></code>, Label :: <code>term()</code>}]</span><div class="title-since"><span class="since">OTP 25.0</span></div> </h4> <div class="exports-tube"> <p> Returns a list of <code class="code">{RequestId, Label}</code> tuples which corresponds to all request identifiers with their associated labels present in the <code class="code">RequestIdCollection</code> collection. </p> </div></article><article class="func"><h4 id="send_request-2" onmouseover="document.getElementById('ghlink-send_request-2-idp168').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-send_request-2-idp168').style.visibility = 'hidden';">  <span class="title-name">send_request(Node, Fun) -&gt; RequestId</span><div class="title-since"><span class="since">OTP 23.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>     <div class="exports-tube"> <p> The same as calling <code><a href="#send_request-4"><span class="code">erpc:send_request(Node, erlang, apply, [Fun, []])</span></a></code>. </p> <p>Fails with an <code class="code">{erpc, badarg}</code> <code class="code">error</code> exception if:</p> <ul> <li><p><code class="code">Node</code> is not an atom.</p></li> <li><p><code class="code">Fun</code> is not a fun of zero arity.</p></li> </ul> <div class="note"> <div class="label">Note</div> <div class="content">

<p> You cannot make <strong>any</strong> assumptions about the process that will perform the <code class="code">apply()</code>. It may be a server, or a freshly spawned process. </p> </div> </div> </div></article><article class="func"><h4 id="send_request-4" onmouseover="document.getElementById('ghlink-send_request-4-idp169').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-send_request-4-idp169').style.visibility = 'hidden';">  <span class="title-name">send_request(Node, Module, Function, Args) -&gt; RequestId</span><div class="title-since"><span class="since">OTP 23.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>       <div class="exports-tube"> <p> Send an asynchronous <code class="code">call</code> request to the node <code class="code">Node</code>. <code class="code">send_request/4</code> returns a request identifier that later is to be passed to either <code><a href="#receive_response-2"><span class="code">receive_response/2</span></a></code>, <code><a href="#wait_response-2"><span class="code">wait_response/2</span></a></code>, or, <code><a href="#check_response-2"><span class="code">check_response/2</span></a></code> in order to get the response of the call request. Besides passing the request identifier directly to these functions, it can also be added in a request identifier collection using <code><a href="#reqids_add-3"><span class="code">reqids_add/3</span></a></code>. Such a collection of request identifiers can later be used in order to get one response corresponding to a request in the collection by passing the collection as argument to <code><a href="#receive_response-3"><span class="code">receive_response/3</span></a></code>, <code><a href="#wait_response-3"><span class="code">wait_response/3</span></a></code>, or, <code><a href="#check_response-3"><span class="code">check_response/3</span></a></code>. If you are about to save the request identifier in a request identifier collection, you may want to consider using <code><a href="#send_request-6"><span class="code">send_request/6</span></a></code> instead. </p> <p> A call to the function <code class="code">my_call(Node, Module, Function, Args, Timeout)</code> below is equivalent to the call <code><a href="#call-5"><span class="code">erpc:call(Node, Module, Function, Args, Timeout)</span></a></code> if one disregards performance. <code class="code">call()</code> can utilize a selective receive optimization which removes the need to scan the message queue from the beginning in order to find a matching message. The <code class="code">send_request()/receive_response()</code> combination can, however, not utilize this optimization. </p> <pre data-language="erlang">
my_call(Node, Module, Function, Args, Timeout) -&gt;
  RequestId = erpc:send_request(Node, Module, Function, Args),
  <a href="#receive_response-2">erpc:receive_response(RequestId, Timeout)</a>.
</pre> <p>Fails with an <code class="code">{erpc, badarg}</code> <code class="code">error</code> exception if:</p> <ul> <li><p><code class="code">Node</code> is not an atom.</p></li> <li><p><code class="code">Module</code> is not an atom.</p></li> <li><p><code class="code">Function</code> is not an atom.</p></li> <li><p><code class="code">Args</code> is not a list. Note that the list is not verified to be a proper list at the client side.</p></li> </ul> <div class="note"> <div class="label">Note</div> <div class="content">

<p> You cannot make <strong>any</strong> assumptions about the process that will perform the <code class="code">apply()</code>. It may be a server, or a freshly spawned process. </p> </div> </div> </div></article><article class="func"><h4 id="send_request-4" onmouseover="document.getElementById('ghlink-send_request-4-idp170').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-send_request-4-idp170').style.visibility = 'hidden';">  <span class="title-name">send_request(Node, Fun, Label, RequestIdCollection) -&gt;<br> NewRequestIdCollection</span><div class="title-since"><span class="since">OTP 25.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>       <div class="exports-tube"> <p> The same as calling <code><a href="#send_request-6"><span class="code">erpc:send_request(Node, erlang, apply, [Fun,[]]), Label, RequestIdCollection)</span></a></code>. </p> <p>Fails with an <code class="code">{erpc, badarg}</code> <code class="code">error</code> exception if:</p> <ul> <li><p><code class="code">Node</code> is not an atom.</p></li> <li><p><code class="code">Fun</code> is not a fun of zero arity.</p></li> <li><p><code class="code">RequestIdCollection</code> is detected not to be request identifier collection.</p></li> </ul> <div class="note"> <div class="label">Note</div> <div class="content">

<p> You cannot make <strong>any</strong> assumptions about the process that will perform the <code class="code">apply()</code>. It may be a server, or a freshly spawned process. </p> </div> </div> </div></article><article class="func"><h4 id="send_request-6" onmouseover="document.getElementById('ghlink-send_request-6-idp171').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-send_request-6-idp171').style.visibility = 'hidden';">  <span class="title-name">send_request(Node, Module, Function, Args, Label,<br> RequestIdCollection) -&gt;<br> NewRequestIdCollection</span><div class="title-since"><span class="since">OTP 25.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>         <div class="exports-tube"> <p> Send an asynchronous <code class="code">call</code> request to the node <code class="code">Node</code>. The <code class="code">Label</code> will be associated with the request identifier of the operation and added to the returned request identifier collection <code class="code">NewRequestIdCollection</code>. The collection can later be used in order to get one response corresponding to a request in the collection by passing the collection as argument to <code><a href="#receive_response-3"><span class="code">receive_response/3</span></a></code>, <code><a href="#wait_response-3"><span class="code">wait_response/3</span></a></code>, or, <code><a href="#check_response-3"><span class="code">check_response/3</span></a></code>. </p> <p> The same as calling <code><a href="#reqids_add-3"><span class="code">erpc:reqids_add</span></a></code>(<code><a href="#send_request-4"><span class="code">erpc:send_request</span></a></code><code class="code">(Node, Module, Function, Args), Label, RequestIdCollection)</code>, but calling <code class="code">send_request/6</code> is slightly more efficient. </p> <p>Fails with an <code class="code">{erpc, badarg}</code> <code class="code">error</code> exception if:</p> <ul> <li><p><code class="code">Node</code> is not an atom.</p></li> <li><p><code class="code">Module</code> is not an atom.</p></li> <li><p><code class="code">Function</code> is not an atom.</p></li> <li><p><code class="code">Args</code> is not a list. Note that the list is not verified to be a proper list at the client side.</p></li> <li><p><code class="code">RequestIdCollection</code> is detected not to be request identifier collection.</p></li> </ul> <div class="note"> <div class="label">Note</div> <div class="content">

<p> You cannot make <strong>any</strong> assumptions about the process that will perform the <code class="code">apply()</code>. It may be a server, or a freshly spawned process. </p> </div> </div> </div></article><article class="func"><h4 id="wait_response-1" onmouseover="document.getElementById('ghlink-wait_response-1-idp172').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-wait_response-1-idp172').style.visibility = 'hidden';">  <span class="title-name">wait_response(RequestId) -&gt; {response, Result} | no_response</span><div class="title-since"><span class="since">OTP 23.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>    <div class="exports-tube"> <p> The same as calling <code><a href="#wait_response-2"><span class="code">erpc:wait_response(RequestId, 0)</span></a></code>. That is, poll for a response message to a <code class="code">call</code> request previously made by the calling process. </p> </div></article><article class="func"><h4 id="wait_response-2" onmouseover="document.getElementById('ghlink-wait_response-2-idp173').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-wait_response-2-idp173').style.visibility = 'hidden';">  <span class="title-name">wait_response(RequestId, WaitTime) -&gt;<br> {response, Result} | no_response</span><div class="title-since"><span class="since">OTP 23.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>     <div class="exports-tube"> <p> Wait or poll for a response message to a <code class="code">call</code> request previously made by the calling process using <code><a href="#send_request-4"><span class="code">send_request/4</span></a></code>. <code class="code">RequestId</code> should be the value returned from the previously made <code class="code">send_request()</code> call, and the corresponding response should not already have been received and handled to completion by <code><a href="#check_response-2"><span class="code">check_response/2</span></a></code>, <code><a href="#receive_response-2"><span class="code">receive_response/2</span></a></code>, or <code class="code">wait_response()</code>. </p> <p> <code class="code">WaitTime</code> sets an upper time limit on how long to wait for a response. If no response is received before the <code class="code">WaitTime</code> timeout has triggered, the atom <code class="code">no_response</code> is returned. It is valid to continue waiting for a response as many times as needed up until a response has been received and completed by <code class="code">check_response()</code>, <code class="code">receive_response()</code>, or <code class="code">wait_response()</code>. If a response is received, the <code class="code">call</code> operation is completed and either the result is returned as <code class="code">{response, Result}</code> where <code class="code">Result</code> corresponds to the value returned from the applied function or an exception is raised. The exceptions that can be raised corresponds to the same exceptions as can be raised by <code><a href="#call-4"><span class="code">call/4</span></a></code>. That is, no <code class="code">{erpc, timeout}</code> <code class="code">error</code> exception can be raised. <code class="code">wait_response/2</code> will fail with an <code class="code">{erpc, badarg}</code> exception if/when an invalid <code class="code">RequestId</code> is detected or if an invalid <code class="code">WaitTime</code> is passed. </p> <p> If the <code class="code">erpc</code> operation fails, but it is unknown if the function is/will be applied (that is, a too large wait time value, or a connection loss), the caller will not receive any further information about the result if/when the applied function completes. If the applied function explicitly communicates with the calling process, such communication may, of course, reach the calling process. </p> </div></article><article class="func"><h4 id="wait_response-3" onmouseover="document.getElementById('ghlink-wait_response-3-idp174').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-wait_response-3-idp174').style.visibility = 'hidden';">  <span class="title-name">wait_response(RequestIdCollection, WaitTime, Delete) -&gt;<br> {{response, Result},<br> Label, NewRequestIdCollection} |<br> no_response | no_request</span><div class="title-since"><span class="since">OTP 25.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>        <div class="exports-tube"> <p> Wait or poll for a response to a <code class="code">call</code> request corresponding to a request identifier saved in <code class="code">RequestIdCollection</code>. All request identifiers of <code class="code">RequestIdCollection</code> must correspond to requests that have been made using <code><a href="#send_request-4"><span class="code">send_request/4</span></a></code> or <code><a href="#send_request-6"><span class="code">send_request/6</span></a></code>, and all requests must have been made by the process calling this function. </p> <p> <code class="code">Label</code> is the label associated with the request identifier of the request that the response corresponds to. A request identifier is associated with a label when <code><a href="#reqids_add-3">adding a request identifier</a></code> in a <code><a href="#type-request_id_collection">request identifier collection</a></code>, or when sending the request using <code><a href="#send_request-6"><span class="code">send_request/6</span></a></code>. </p> <p> Compared to <code><a href="#wait_response-2"><span class="code">wait_response/2</span></a></code>, the returned result associated with a specific request identifier or an exception associated with a specific request identifier will be wrapped in a 3-tuple. The first element of this tuple equals the value that would have been produced by <code class="code">wait_response/2</code>, the second element equals the <code class="code">Label</code> associated with the specific request identifier, and the third element <code class="code">NewRequestIdCollection</code> is a possibly modified request identifier collection. The <code class="code">error</code> exception <code class="code">{erpc, badarg}</code> is not associated with any specific request identifier, and will hence not be wrapped. </p> <p> If <code class="code">RequestIdCollection</code> is empty, <code class="code">no_request</code> will be returned. If no response is received before the <code class="code">WaitTime</code> timeout has triggered, the atom <code class="code">no_response</code> is returned. It is valid to continue waiting for a response as many times as needed up until a response has been received and completed by <code class="code">check_response()</code>, <code class="code">receive_response()</code>, or <code class="code">wait_response()</code>. The difference between <code><a href="#receive_response-3"><span class="code">receive_response/3</span></a></code> and <code class="code">wait_response/3</code> is that <code class="code">receive_response/3</code> abandons requests at timeout so that any potential future responses are ignored, while <code class="code">wait_response/3</code> does not. </p> <p> If <code class="code">Delete</code> equals <code class="code">true</code>, the association with <code class="code">Label</code> will have been deleted from <code class="code">RequestIdCollection</code> in the resulting <code class="code">NewRequestIdCollection</code>. If <code class="code">Delete</code> equals <code class="code">false</code>, <code class="code">NewRequestIdCollection</code> will equal <code class="code">RequestIdCollection</code>. Note that deleting an association is not for free and that a collection containing already handled requests can still be used by subsequent calls to <code class="code">wait_response/3</code>, <code><a href="#check_response-3"><span class="code">check_response/3</span></a></code>, and <code><a href="#receive_response-3"><span class="code">receive_response/3</span></a></code>. However, without deleting handled associations, the above calls will not be able to detect when there are no more outstanding requests to handle, so you will have to keep track of this some other way than relying on a <code class="code">no_request</code> return. Note that if you pass a collection only containing associations of already handled or abandoned requests to <code class="code">wait_response/3</code>, it will always block until a timeout determined by <code class="code">WaitTime</code> is triggered and then return <code class="code">no_response</code>. </p> <p> Note that a response might have been consumed uppon an <code class="code">{erpc, badarg}</code> exception and if so, will be lost for ever. </p> </div></article> </div> <div class="footer"> <hr> <p>Copyright © 1997-2022 Ericsson AB. All Rights Reserved.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2022 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
