  <div class="innertube"> <h2 id="module" class="title-link" onmouseover="document.getElementById('ghlink-module-idm22110').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-module-idm22110').style.visibility = 'hidden';"> <div class="title-name">Module</div>  </h2> <p class="REFBODY module-body">peer</p> </div> <div class="innertube"> <h2 id="module-summary" class="title-link" onmouseover="document.getElementById('ghlink-module-summary-idm22111').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-module-summary-idm22111').style.visibility = 'hidden';"> <div class="title-name">Module Summary</div>  </h2> <p class="REFBODY module-summary-body">Start and control linked Erlang nodes. </p> <h2 id="since" class="title-link" onmouseover="document.getElementById('ghlink-since-idm22111').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-since-idm22111').style.visibility = 'hidden';"> <div class="title-name">Since</div>  </h2> <p class="REFBODY module-since"> Module peer was introduced in OTP 25.0. </p> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link" onmouseover="document.getElementById('ghlink-description-idm22112').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-description-idm22112').style.visibility = 'hidden';"> <div class="title-name">Description</div>  </h2> 
<p> This module provides functions for starting linked Erlang nodes. The node spawning new nodes is called <strong>origin</strong>, and newly started nodes are <strong>peer</strong> nodes, or peers. A peer node automatically terminates when it loses the <strong>control connection</strong> to the origin. This connection could be an Erlang distribution connection, or an alternative - TCP or standard I/O. The alternative connection provides a way to execute remote procedure calls even when Erlang Distribution is not available, allowing to test the distribution itself. </p> <p> Peer node terminal input/output is relayed through the origin. If a standard I/O alternative connection is requested, console output also goes via the origin, allowing debugging of node startup and boot script execution (see <code> <span class="code">-init_debug</span></code>). File I/O is not redirected, contrary to <code><a href="slave"><span class="code">slave(3)</span></a></code> behaviour. </p> <p> The peer node can start on the same or a different host (via <code class="code">ssh</code>) or in a separate container (for example Docker). When the peer starts on the same host as the origin, it inherits the current directory and environment variables from the origin. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> This module is designed to facilitate multi-node testing with Common Test. Use the <code class="code">?CT_PEER()</code> macro to start a linked peer node according to Common Test conventions: crash dumps written to specific location, node name prefixed with module name, calling function, and origin OS process ID). Use <code><a href="#random_name-1"><span class="code">random_name/1</span></a></code> to create sufficiently unique node names if you need more control. </p> <p> A peer node started without alternative connection behaves similarly to <code><a href="slave"><span class="code">slave(3)</span></a></code>. When an alternative connection is requested, the behaviour is similar to <code class="code">test_server:start_node(Name, peer, Args).</code> </p> </div> </div>  </div></section> <section class="innertube"><h2 id="example" class="title-link" onmouseover="document.getElementById('ghlink-example-idm22133').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-example-idm22133').style.visibility = 'hidden';"> <div class="title-name">Example</div>  </h2>  <p> The following example implements a test suite starting extra Erlang nodes. It employs a number of techniques to speed up testing and reliably shut down peer nodes: </p> <ul> <li>peers start linked to test runner process. If the test case fails, the peer node is stopped automatically, leaving no rogue nodes running in the background</li> <li>arguments used to start the peer are saved in the control process state for manual analysis. If the test case fails, the CRASH REPORT contains these arguments</li> <li>multiple test cases can run concurrently speeding up overall testing process, peer node names are unique even when there are multiple instances of the same test suite running in parallel</li> </ul> <pre data-language="erlang">-module(my_SUITE).
-behaviour(ct_suite).
-export([all/0, groups/0]).
-export([basic/1, args/1, named/1, restart_node/1, multi_node/1]).

-include_lib("common_test/include/ct.hrl").

groups() -&gt;
    [{quick, [parallel],
        [basic, args, named, restart_node, multi_node]}].

all() -&gt;
    [{group, quick}].

basic(Config) when is_list(Config) -&gt;
    {ok, Peer, _Node} = ?CT_PEER(),
    peer:stop(Peer).

args(Config) when is_list(Config) -&gt;
    %% specify additional arguments to the new node
    {ok, Peer, _Node} = ?CT_PEER(["-emu_flavor", "smp"]),
    peer:stop(Peer).

named(Config) when is_list(Config) -&gt;
    %% pass test case name down to function starting nodes
    Peer = start_node_impl(named_test),
    peer:stop(Peer).

start_node_impl(ActualTestCase) -&gt;
    {ok, Peer, Node} = ?CT_PEER(#{name =&gt; ?CT_PEER_NAME(ActualTestCase)}),
    %% extra setup needed for multiple test cases
    ok = rpc:call(Node, application, set_env, [kernel, key, value]),
    Peer.

restart_node(Config) when is_list(Config) -&gt;
    Name = ?CT_PEER_NAME(),
    {ok, Peer, Node} = ?CT_PEER(#{name =&gt; Name}),
    peer:stop(Peer),
    %% restart the node with the same name as before
    {ok, Peer2, Node} = ?CT_PEER(#{name =&gt; Name, args =&gt; ["+fnl"]}),
    peer:stop(Peer2).</pre> <p> The next example demonstrates how to start multiple nodes concurrently: </p> <pre data-language="erlang">multi_node(Config) when is_list(Config) -&gt;
    Peers = [?CT_PEER(#{wait_boot =&gt; {self(), tag}})
        || _ &lt;- lists:seq(1, 4)],
    %% wait for all nodes to complete boot process, get their names:
    _Nodes = [receive {tag, {started, Node, Peer}} -&gt; Node end
        || {ok, Peer} &lt;- Peers],
    [peer:stop(Peer) || {ok, Peer} &lt;- Peers].</pre> <p> Start a peer on a different host. Requires <code class="code">ssh</code> key-based authentication set up, allowing "another_host" connection without password prompt. </p> <pre data-language="erlang">Ssh = os:find_executable("ssh"),
peer:start_link(#{exec =&gt; {Ssh, ["another_host", "erl"]},
    connection =&gt; standard_io}),</pre> <p> The following Common Test case demonstrates Docker integration, starting two containers with hostnames "one" and "two". In this example Erlang nodes running inside containers form an Erlang cluster. </p> <pre data-language="erlang">docker(Config) when is_list(Config) -&gt;
    Docker = os:find_executable("docker"),
    PrivDir = proplists:get_value(priv_dir, Config),
    build_release(PrivDir),
    build_image(PrivDir),

    %% start two Docker containers
    {ok, Peer, Node} = peer:start_link(#{name =&gt; lambda,
        connection =&gt; standard_io,
        exec =&gt; {Docker, ["run", "-h", "one", "-i", "lambda"]}}),
    {ok, Peer2, Node2} = peer:start_link(#{name =&gt; lambda,
        connection =&gt; standard_io,
        exec =&gt; {Docker, ["run", "-h", "two", "-i", "lambda"]}}),

    %% find IP address of the second node using alternative connection RPC
    {ok, Ips} = peer:call(Peer2, inet, getifaddrs, []),
    {"eth0", Eth0} = lists:keyfind("eth0", 1, Ips),
    {addr, Ip} = lists:keyfind(addr, 1, Eth0),

    %% make first node to discover second one
    ok = peer:call(Peer, inet_db, set_lookup, [[file]]),
    ok = peer:call(Peer, inet_db, add_host, [Ip, ["two"]]),

    %% join a cluster
    true = peer:call(Peer, net_kernel, connect_node, [Node2]),
    %% verify that second peer node has only the first node visible
    [Node] = peer:call(Peer2, erlang, nodes, []),

    %% stop peers, causing containers to also stop
    peer:stop(Peer2),
    peer:stop(Peer).

build_release(Dir) -&gt;
    %% load sasl.app file, otherwise application:get_key will fail
    application:load(sasl),
    %% create *.rel - release file
    RelFile = filename:join(Dir, "lambda.rel"),
    Release = {release, {"lambda", "1.0.0"},
        {erts, erlang:system_info(version)},
        [{App, begin {ok, Vsn} = application:get_key(App, vsn), Vsn end}
            || App &lt;- [kernel, stdlib, sasl]]},
    ok = file:write_file(RelFile, list_to_binary(lists:flatten(
        io_lib:format("~tp.", [Release])))),
    RelFileNoExt = filename:join(Dir, "lambda"),

    %% create boot script
    {ok, systools_make, []} = systools:make_script(RelFileNoExt,
        [silent, {outdir, Dir}]),
    %% package release into *.tar.gz
    ok = systools:make_tar(RelFileNoExt, [{erts, code:root_dir()}]).

build_image(Dir) -&gt;
    %% Create Dockerfile example, working only for Ubuntu 20.04
    %% Expose port 4445, and make Erlang distribution to listen
    %%  on this port, and connect to it without EPMD
    %% Set cookie on both nodes to be the same.
    BuildScript = filename:join(Dir, "Dockerfile"),
    Dockerfile =
      "FROM ubuntu:20.04 as runner\n"
      "EXPOSE 4445\n"
      "WORKDIR /opt/lambda\n"
      "COPY lambda.tar.gz /tmp\n"
      "RUN tar -zxvf /tmp/lambda.tar.gz -C /opt/lambda\n"
      "ENTRYPOINT [\"/opt/lambda/erts-" ++ erlang:system_info(version) ++
      "/bin/dyn_erl\", \"-boot\", \"/opt/lambda/releases/1.0.0/start\","
      " \"-kernel\", \"inet_dist_listen_min\", \"4445\","
      " \"-erl_epmd_port\", \"4445\","
      " \"-setcookie\", \"secret\"]\n",
    ok = file:write_file(BuildScript, Dockerfile),
    os:cmd("docker build -t lambda " ++ Dir).</pre> </section> <div class="innertube"> <h2 id="data-types" class="title-link" onmouseover="document.getElementById('ghlink-data-types-idm22148').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-data-types-idm22148').style.visibility = 'hidden';"> <div class="title-name">Data Types</div>  </h2> <article class="data-types-body"><h4 id="type-server_ref" class="title-link data-type-name" onmouseover="document.getElementById('ghlink-type-server_ref').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-server_ref').style.visibility = 'hidden';">  <div class="title-name"> <code>server_ref() = <span id="type-server_ref">pid()</span></code><br> </div> </h4> <div class="data-type-desc"> <p> Identifies the controlling process of a peer node. </p> </div></article> <article class="data-types-body"><h4 id="type-start_options" class="title-link data-type-name" onmouseover="document.getElementById('ghlink-type-start_options').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-start_options').style.visibility = 'hidden';">  <div class="title-name"> <code>start_options() = <br id="type-start_options">    #{name =&gt; <span>atom()</span> | <span>string()</span>,<br>      longnames =&gt; <span>boolean()</span>,<br>      host =&gt; <span>string()</span>,<br>      peer_down =&gt; stop | continue | crash,<br>      exec =&gt; <span><a href="#type-exec">exec()</a></span>,<br>      connection =&gt; <span><a href="#type-connection">connection()</a></span>,<br>      args =&gt; [<span>string()</span>],<br>      env =&gt; [{<span>string()</span>, <span>string()</span>}],<br>      wait_boot =&gt; <span><a href="#type-wait_boot">wait_boot()</a></span>,<br>      shutdown =&gt;<br>          close | halt |<br>          {halt, <span><a href="#type-disconnect_timeout">disconnect_timeout()</a></span>} |<br>          <span><a href="#type-disconnect_timeout">disconnect_timeout()</a></span>}</code><br> </div> </h4> <div class="data-type-desc"> <p> Options that can be used when starting a <code class="code">peer</code> node through <code><a href="#start-1"><span class="code">start/1</span></a></code> and <code><a href="#start_link-0"><span class="code">start_link/0,1</span></a></code>. </p> <dl> <dt><strong><code class="code">name</code></strong></dt> <dd> <p> Node name (the part before "@"). When <code class="code">name</code> is not specified, but <code class="code">host</code> is, <code class="code">peer</code> follows compatibility behaviour and uses the origin node name. </p> </dd> <dt><strong><code class="code">host</code></strong></dt> <dd> <p> Enforces a specific host name. Can be used to override the default behaviour and start "node@localhost" instead of "node@realhostname". </p> </dd> <dt><strong><code class="code">longnames</code></strong></dt> <dd> <p> Use long names to start a node. Default is taken from the origin using <code class="code">net_kernel:longnames()</code>. If the origin is not distributed, short names is the default. </p> </dd> <dt><strong><code class="code">peer_down</code></strong></dt> <dd> <p> Defines the peer control process behaviour when the control connection is closed from the peer node side (for example when the peer crashes or dumps core). When set to <code class="code">stop</code> (default), a lost control connection causes the control process to exit normally. Setting <code class="code">peer_down</code> to <code class="code">continue</code> keeps the control process running, and <code class="code">crash</code> will cause the controlling process to exit abnormally. </p> </dd> <dt><strong><code class="code">exec</code></strong></dt> <dd> <p> Alternative mechanism to start peer nodes with, for example, ssh instead of the default bash. </p> </dd> <dt><strong><code class="code">connection</code></strong></dt> <dd> <p>Alternative connection specification. See the <code><a href="#type-connection"><span class="code">connection</span> datatype</a></code>.</p> </dd> <dt><strong><code class="code">args</code></strong></dt> <dd> <p>Extra command line arguments to append to the "erl" command. Arguments are passed as is, no escaping or quoting is needed or accepted.</p> </dd> <dt><strong><code class="code">env</code></strong></dt> <dd> <p> List of environment variables with their values. This list is applied to a locally started executable. If you need to change the environment of the remote peer, adjust <code class="code">args</code> to contain <code class="code">-env ENV_KEY ENV_VALUE</code>. </p> </dd> <dt><strong><code class="code">wait_boot</code></strong></dt> <dd> <p>Specifies the start/start_link timeout. See <code><a href="#type-wait_boot"><span class="code">wait_boot</span> datatype</a></code>. </p> </dd> <dt><strong><code class="code">shutdown</code></strong></dt> <dd> <p>Specifies the peer node stopping behaviour. See <code><a href="#stop-1"><span class="code">stop()</span></a></code>.</p> </dd> </dl> </div></article> <article class="data-types-body"><h4 id="type-peer_state" class="title-link data-type-name" onmouseover="document.getElementById('ghlink-type-peer_state').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-peer_state').style.visibility = 'hidden';">  <div class="title-name"> <code>peer_state() = booting | running | {down, Reason :: <span id="type-peer_state">term()</span>}</code><br> </div> </h4> <div class="data-type-desc"><p>Peer node state.</p></div></article> <article class="data-types-body"><h4 id="type-connection" class="title-link data-type-name" onmouseover="document.getElementById('ghlink-type-connection').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-connection').style.visibility = 'hidden';">  <div class="title-name"> <code>connection() = <br id="type-connection">    0..65535 | {<span>inet:ip_address()</span>, 0..65535} | standard_io</code><br> </div> </h4> <div class="data-type-desc"> <p>Alternative connection between the origin and the peer. When the connection closes, the peer node terminates automatically. If the <code class="code">peer_down</code> startup flag is set to <code class="code">crash</code>, the controlling process on the origin node exits with corresponding reason, effectively providing a two-way link. </p> <p>When <code class="code">connection</code> is set to a port number, the origin starts listening on the requested TCP port, and the peer node connects to the port. When it is set to an <code class="code">{IP, Port}</code> tuple, the origin listens only on the specified IP. The port number can be set to 0 for automatic selection. </p> <p>Using the <code class="code">standard_io</code> alternative connection starts the peer attached to the origin (other connections use <code class="code">-detached</code> flag to erl). In this mode peer and origin communicate via stdin/stdout. </p> </div></article> <article class="data-types-body"><h4 id="type-exec" class="title-link data-type-name" onmouseover="document.getElementById('ghlink-type-exec').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-exec').style.visibility = 'hidden';">  <div class="title-name"> <code>exec() = <span id="type-exec">file:name()</span> | {<span>file:name()</span>, [<span>string()</span>]}</code><br> </div> </h4> <div class="data-type-desc"> <p> Overrides executable to start peer nodes with. By default it is the path to "erl", taken from <code class="code">init:get_argument(progname)</code>. If <code class="code">progname</code> is not known, <code class="code">peer</code> makes best guess given the current ERTS version. </p> <p> When a tuple is passed, the first element is the path to executable, and the second element is prepended to the final command line. This can be used to start peers on a remote host or in a Docker container. See the examples above. </p> <p> This option is useful for testing backwards compatibility with previous releases, installed at specific paths, or when the Erlang installation location is missing from the <code class="code">PATH</code>. </p> </div></article> <article class="data-types-body"><h4 id="type-wait_boot" class="title-link data-type-name" onmouseover="document.getElementById('ghlink-type-wait_boot').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-wait_boot').style.visibility = 'hidden';">  <div class="title-name"> <code>wait_boot() = <span id="type-wait_boot">timeout()</span> | {<span>pid()</span>, Tag :: <span>term()</span>} | false</code><br> </div> </h4> <div class="data-type-desc"><p>Specifies start/start_link timeout in milliseconds. Can be set to <code class="code">false</code>, allowing the peer to start asynchronously. If <code class="code">{Pid, Tag}</code> is specified instead of a timeout, the peer will send <code class="code">Tag</code> to the requested process.</p></div></article> <article class="data-types-body"><h4 id="type-disconnect_timeout" class="title-link data-type-name" onmouseover="document.getElementById('ghlink-type-disconnect_timeout').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-type-disconnect_timeout').style.visibility = 'hidden';">  <div class="title-name"> <code id="type-disconnect_timeout">disconnect_timeout() = 1000..4294967295 | infinity</code><br> </div> </h4> <div class="data-type-desc"><p>Disconnect timeout. See <code><a href="#stop-1"><span class="code">stop()</span></a></code>.</p></div></article> </div> <div class="innertube"><h2 id="export" class="title-link" onmouseover="document.getElementById('ghlink-export-idm22258').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-export-idm22258').style.visibility = 'hidden';"> <div class="title-name">Exports</div>  </h2></div> <div class="exports-body"> <article class="func"><h4 id="call-4" onmouseover="document.getElementById('ghlink-call-4-idp913').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-call-4-idp913').style.visibility = 'hidden';">  <span class="title-name">call(Dest :: <code><a href="#type-server_ref">server_ref()</a></code>,<br> Module :: <code>module()</code>,<br> Function :: <code>atom()</code>,<br> Args :: [<code>term()</code>]) -&gt;<br> Result :: <code>term()</code></span><div class="title-since"><span class="since">OTP 25.0</span></div> </h4> <h4 id="call-5" onmouseover="document.getElementById('ghlink-call-5-idp914').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-call-5-idp914').style.visibility = 'hidden';">  <span class="title-name">call(Dest :: <code><a href="#type-server_ref">server_ref()</a></code>,<br> Module :: <code>module()</code>,<br> Function :: <code>atom()</code>,<br> Args :: [<code>term()</code>],<br> Timeout :: <code>timeout()</code>) -&gt;<br> Result :: <code>term()</code></span><div class="title-since"><span class="since">OTP 25.0</span></div> </h4> <div class="exports-tube"> <p> Uses the alternative connection to evaluate <code class="code">apply(Module, Function, Args)</code> on the peer node and returns the corresponding value <code class="code">Result</code>. <code class="code">Timeout</code> is an integer representing the timeout in milliseconds or the atom <code class="code">infinity</code> which prevents the operation from ever timing out. </p> <p> When an alternative connection is not requested, this function will raise <code class="code">exit</code> signal with the <code class="code">noconnection</code> reason. Use <code><span class="code">erpc</span></code> module to communicate over Erlang distribution. </p> </div></article><article class="func"><h4 id="cast-4" onmouseover="document.getElementById('ghlink-cast-4-idp915').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-cast-4-idp915').style.visibility = 'hidden';">  <span class="title-name">cast(Dest :: <code><a href="#type-server_ref">server_ref()</a></code>,<br> Module :: <code>module()</code>,<br> Function :: <code>atom()</code>,<br> Args :: [<code>term()</code>]) -&gt;<br> ok</span><div class="title-since"><span class="since">OTP 25.0</span></div> </h4> <div class="exports-tube"> <p> Uses the alternative connection to evaluate <code class="code">apply(Module, Function, Args)</code> on the peer node. No response is delivered to the calling process. </p> <p> <code class="code">peer:cast/4</code> fails silently when the alternative connection is not configured. Use <code><span class="code">erpc</span></code> module to communicate over Erlang distribution. </p> </div></article><article class="func"><h4 id="send-3" onmouseover="document.getElementById('ghlink-send-3-idp916').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-send-3-idp916').style.visibility = 'hidden';">  <span class="title-name">send(Dest :: <code><a href="#type-server_ref">server_ref()</a></code>,<br> To :: <code>pid()</code> | <code>atom()</code>,<br> Message :: <code>term()</code>) -&gt;<br> ok</span><div class="title-since"><span class="since">OTP 25.0</span></div> </h4> <div class="exports-tube"> <p> Uses the alternative connection to send Message to a process on the the peer node. Silently fails if no alternative connection is configured. The process can be referenced by process ID or registered name. </p> </div></article><article class="func"><h4 id="get_state-1" onmouseover="document.getElementById('ghlink-get_state-1-idp917').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-get_state-1-idp917').style.visibility = 'hidden';">  <span class="title-name">get_state(Dest :: <code><a href="#type-server_ref">server_ref()</a></code>) -&gt; <code><a href="#type-peer_state">peer_state()</a></code></span><div class="title-since"><span class="since">OTP 25.0</span></div> </h4> <div class="exports-tube"> <p>Returns the peer node state. Th initial state is <code class="code">booting</code>; the node stays in that state until then boot script is complete, and then the node progresses to <code class="code">running</code>. If the node stops (gracefully or not), the state changes to <code class="code">down</code>. </p> </div></article><article class="func"><h4 id="random_name-0" onmouseover="document.getElementById('ghlink-random_name-0-idp918').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-random_name-0-idp918').style.visibility = 'hidden';">  <span class="title-name">random_name() -&gt; <code>string()</code></span><div class="title-since"><span class="since">OTP 25.0</span></div> </h4> <div class="exports-tube"> <p> The same as <code><a href="#random_name-1"><span class="code">random_name(peer)</span></a></code>. </p> </div></article><article class="func"><h4 id="random_name-1" onmouseover="document.getElementById('ghlink-random_name-1-idp919').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-random_name-1-idp919').style.visibility = 'hidden';">  <span class="title-name">random_name(Prefix :: <code>string()</code> | <code>atom()</code>) -&gt; <code>string()</code></span><div class="title-since"><span class="since">OTP 25.0</span></div> </h4> <div class="exports-tube"> <p> Creates a sufficiently unique node name for the current host, combining a prefix, a unique number, and the current OS process ID. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> Use the <code class="code">?CT_PEER(["erl_arg1"])</code> macro provided by Common Test <code class="code">-include_lib("common_test/include/ct.hrl")</code> for convenience. It starts a new peer using Erlang distribution as the control channel, supplies thes calling module's code path to the peer, and uses the calling function name for the name prefix. </p> </div> </div> </div></article><article class="func"><h4 id="start-1" onmouseover="document.getElementById('ghlink-start-1-idp920').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-start-1-idp920').style.visibility = 'hidden';">  <span class="title-name">start(Options :: <code><a href="#type-start_options">start_options()</a></code>) -&gt;<br> {ok, <code>pid()</code>} | {ok, <code>pid()</code>, <code>node()</code>} | {error, Reason}</span><div class="title-since"><span class="since">OTP 25.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>   <div class="exports-tube"> <p> Starts a peer node with the specified <code><a href="#type-start_options"><span class="code">start_options()</span></a></code>. Returns the controlling process and the full peer node name, unless <code class="code">wait_boot</code> is not requested and the host name is not known in advance. </p> </div></article><article class="func"><h4 id="start_link-0" onmouseover="document.getElementById('ghlink-start_link-0-idp921').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-start_link-0-idp921').style.visibility = 'hidden';">  <span class="title-name">start_link() -&gt; {ok, <code>pid()</code>, <code>node()</code>} | {error, Reason :: <code>term()</code>}</span><div class="title-since"><span class="since">OTP 25.0</span></div> </h4> <div class="exports-tube"> <p> The same as <code><a href="#start_link-1"><span class="code">start_link(#{name =&gt; random_name()})</span></a></code>. </p> </div></article><article class="func"><h4 id="start_link-1" onmouseover="document.getElementById('ghlink-start_link-1-idp922').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-start_link-1-idp922').style.visibility = 'hidden';">  <span class="title-name">start_link(Options :: <code><a href="#type-start_options">start_options()</a></code>) -&gt;<br> {ok, <code>pid()</code>} | {ok, <code>pid()</code>, <code>node()</code>} | {error, Reason}</span><div class="title-since"><span class="since">OTP 25.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>   <div class="exports-tube"> <p>Starts a peer node in the same way as <code><a href="#start-1"><span class="code">start/1</span></a></code>, except that the peer node is linked to the currently executing process. If that process terminates, the peer node also terminates.</p> <p> Accepts <code><a href="#type-start_options"><span class="code">start_options()</span></a></code>. Returns the controlling process and the full peer node name, unless <code class="code">wait_boot</code> is not requested and host name is not known in advance. </p> <p> When the <code class="code">standard_io</code> alternative connection is requested, and <code class="code">wait_boot</code> is not set to <code class="code">false</code>, a failed peer boot sequence causes the caller to exit with the <code class="code">{boot_failed, {exit_status, ExitCode}}</code> reason. </p> </div></article><article class="func"><h4 id="stop-1" onmouseover="document.getElementById('ghlink-stop-1-idp923').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-stop-1-idp923').style.visibility = 'hidden';">  <span class="title-name">stop(Dest :: <code><a href="#type-server_ref">server_ref()</a></code>) -&gt; ok</span><div class="title-since"><span class="since">OTP 25.0</span></div> </h4>  <h2 id="types" class="func-types-title">Types</h2>   <div class="exports-tube"> <p> Stops a peer node. How the node is stopped depends on the <code><a href="#type-start_options"><span class="code">shutdown</span></a></code> option passed when starting the peer node. Currently the following <code class="code">shutdown</code> options are supported: </p> <dl> <dt><strong><code class="code">halt</code></strong></dt> <dd><p> This is the default shutdown behavior. It behaves as <code class="code">shutdown</code> option <code class="code">{halt, DefaultTimeout}</code> where <code class="code">DefaultTimeout</code> currently equals <code class="code">5000</code>. </p></dd> <dt><strong><code class="code">{halt, Timeout :: disconnect_timeout()}</code></strong></dt> <dd><p> Triggers a call to <code><span class="code">erlang:halt()</span></code> on the peer node and then waits for the Erlang distribution connection to the peer node to be taken down. If this connection has not been taken down after <code class="code">Timeout</code> milliseconds, it will forcefully be taken down by <code class="code">peer:stop/1</code>. See the <code><a href="#dist_connection_close">warning</a></code> below for more info about this. </p></dd> <dt><strong><code class="code">Timeout :: disconnect_timeout()</code></strong></dt> <dd><p> Triggers a call to <code><span class="code">init:stop()</span></code> on the peer node and then waits for the Erlang distribution connection to the peer node to be taken down. If this connection has not been taken down after <code class="code">Timeout</code> milliseconds, it will forcefully be taken down by <code class="code">peer:stop/1</code>. See the <code><a href="#dist_connection_close">warning</a></code> below for more info about this. </p></dd> <dt><strong><code class="code">close</code></strong></dt> <dd> <p> Close the <i>control connection</i> to the peer node and return. This is the fastest way for the caller of <code class="code">peer:stop/1</code> to stop a peer node. </p> <p> Note that if the Erlang distribution connection is not used as control connection it might not have been taken down when <code class="code">peer:stop/1</code> returns. Also note that the <code><a href="#dist_connection_close">warning</a></code> below applies when the Erlang distribution connection is used as control connection. </p> </dd> </dl>  <div class="warning" id="dist_connection_close"> <div class="label">Warning</div> <div class="content">

<p> In the cases where the Erlang distribution connection is taken down by <code class="code">peer:stop/1</code>, other code independent of the peer code might react to the connection loss before the peer node is stopped which might cause undesirable effects. For example, <code><span class="code">global</span></code> might trigger even more Erlang distribution connections to other nodes to be taken down. The potential undesirable effects are, however, not limited to this. It is hard to say what the effects will be since these effects can be caused by any code with links or monitors to something on the origin node, or code monitoring the connection to the origin node. </p> </div> </div> </div></article> </div> <div class="footer"> <hr> <p>Copyright © 1997-2022 Ericsson AB. All Rights Reserved.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2022 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
