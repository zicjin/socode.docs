  <div class="innertube"> <h2 id="c-library" class="title-link" onmouseover="document.getElementById('ghlink-c-library-idm28300').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-c-library-idm28300').style.visibility = 'hidden';"> <div class="title-name">C Library</div>  </h2> <p class="REFBODY c-library-body">erts_alloc</p> </div> <div class="innertube"> <h2 id="library-summary" class="title-link" onmouseover="document.getElementById('ghlink-library-summary-idm28301').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-library-summary-idm28301').style.visibility = 'hidden';"> <div class="title-name">Library Summary</div>  </h2> <p class="REFBODY library-summary-body">An Erlang runtime system internal memory allocator library. </p> </div> <section class="description"><div class="innertube"> <h2 id="description" class="title-link" onmouseover="document.getElementById('ghlink-description-idm28302').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-description-idm28302').style.visibility = 'hidden';"> <div class="title-name">Description</div>  </h2> 
<p><code class="code">erts_alloc</code> is an Erlang runtime system internal memory allocator library. <code class="code">erts_alloc</code> provides the Erlang runtime system with a number of memory allocators.</p>  </div></section> <section class="innertube"><h2 id="allocators" class="title-link" onmouseover="document.getElementById('ghlink-allocators-idm28306').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-allocators-idm28306').style.visibility = 'hidden';"> <div class="title-name">Allocators</div>  </h2>   <p id="allocators">The following allocators are present:</p> <dl> <dt><strong><code class="code">temp_alloc</code></strong></dt> <dd>Allocator used for temporary allocations.</dd> <dt><strong><code class="code">eheap_alloc</code></strong></dt> <dd>Allocator used for Erlang heap data, such as Erlang process heaps. </dd> <dt><strong><code class="code">binary_alloc</code></strong></dt> <dd>Allocator used for Erlang binary data.</dd> <dt><strong><code class="code">ets_alloc</code></strong></dt> <dd>Allocator used for <code class="code">ets</code> data.</dd> <dt><strong><code class="code">driver_alloc</code></strong></dt> <dd>Allocator used for driver data.</dd> <dt><strong><code class="code">literal_alloc</code></strong></dt> <dd>Allocator used for constant terms in Erlang code.</dd> <dt><strong><code class="code">sl_alloc</code></strong></dt> <dd>Allocator used for memory blocks that are expected to be short-lived.</dd> <dt><strong><code class="code">ll_alloc</code></strong></dt> <dd>Allocator used for memory blocks that are expected to be long-lived, for example, Erlang code.</dd> <dt><strong><code class="code">fix_alloc</code></strong></dt> <dd>A fast allocator used for some frequently used fixed size data types.</dd> <dt><strong><code class="code">std_alloc</code></strong></dt> <dd>Allocator used for most memory blocks not allocated through any of the other allocators described above.</dd> <dt><strong><code class="code">sys_alloc</code></strong></dt> <dd>This is normally the default <code class="code">malloc</code> implementation used on the specific OS.</dd> <dt><strong><code class="code">mseg_alloc</code></strong></dt> <dd>A memory segment allocator. It is used by other allocators for allocating memory segments and is only available on systems that have the <code class="code">mmap</code> system call. Memory segments that are deallocated are kept for a while in a segment cache before they are destroyed. When segments are allocated, cached segments are used if possible instead of creating new segments. This to reduce the number of system calls made.</dd> </dl> <p><code class="code">sys_alloc</code>, <code class="code">literal_alloc</code> and <code class="code">temp_alloc</code> are always enabled and cannot be disabled. <code class="code">mseg_alloc</code> is always enabled if it is available and an allocator that uses it is enabled. All other allocators can be <code><a href="#M_e">enabled or disabled</a></code>. By default all allocators are enabled. When an allocator is disabled, <code class="code">sys_alloc</code> is used instead of the disabled allocator.</p> <p>The main idea with the <code class="code">erts_alloc</code> library is to separate memory blocks that are used differently into different memory areas, to achieve less memory fragmentation. By putting less effort in finding a good fit for memory blocks that are frequently allocated than for those less frequently allocated, a performance gain can be achieved.</p> </section> <section class="innertube"><h2 id="the-alloc_util-framework" class="title-link" onmouseover="document.getElementById('ghlink-the-alloc_util-framework-idm28359').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-the-alloc_util-framework-idm28359').style.visibility = 'hidden';"> <div class="title-name">The alloc_util Framework</div>  </h2>  <p>Internally a framework called <code class="code">alloc_util</code> is used for implementing allocators. <code class="code">sys_alloc</code> and <code class="code">mseg_alloc</code> do not use this framework, so the following does <strong>not</strong> apply to them.</p> <p>An allocator manages multiple areas, called carriers, in which memory blocks are placed. A carrier is either placed in a separate memory segment (allocated through <code class="code">mseg_alloc</code>), or in the heap segment (allocated through <code class="code">sys_alloc</code>).</p> <ul> <li> <p>Multiblock carriers are used for storage of several blocks.</p> </li> <li> <p>Singleblock carriers are used for storage of one block.</p> </li> <li> <p>Blocks that are larger than the value of the singleblock carrier threshold (<code><a href="#M_sbct"><span class="code">sbct</span></a></code>) parameter are placed in singleblock carriers.</p> </li> <li> <p>Blocks that are smaller than the value of parameter <code class="code">sbct</code> are placed in multiblock carriers.</p> </li> </ul> <p>Normally an allocator creates a "main multiblock carrier". Main multiblock carriers are never deallocated. The size of the main multiblock carrier is determined by the value of parameter <code><a href="#M_mmbcs"><span class="code">mmbcs</span></a></code>.</p> <p>Sizes of multiblock carriers allocated through <code class="code" id="mseg_mbc_sizes">mseg_alloc</code> are decided based on the following parameters:</p> <ul> <li>The values of the largest multiblock carrier size (<code><a href="#M_lmbcs"><span class="code">lmbcs</span></a></code>)</li> <li>The smallest multiblock carrier size (<code><a href="#M_smbcs"><span class="code">smbcs</span></a></code>)</li> <li>The multiblock carrier growth stages (<code><a href="#M_mbcgs"><span class="code">mbcgs</span></a></code>)</li> </ul> <p>If <code class="code">nc</code> is the current number of multiblock carriers (the main multiblock carrier excluded) managed by an allocator, the size of the next <code class="code">mseg_alloc</code> multiblock carrier allocated by this allocator is roughly <code class="code">smbcs+nc*(lmbcs-smbcs)/mbcgs</code> when <code class="code">nc &lt;= mbcgs</code>, and <code class="code">lmbcs</code> when <code class="code">nc &gt; mbcgs</code>. If the value of parameter <code class="code">sbct</code> is larger than the value of parameter <code class="code">lmbcs</code>, the allocator may have to create multiblock carriers that are larger than the value of parameter <code class="code">lmbcs</code>, though. Singleblock carriers allocated through <code class="code">mseg_alloc</code> are sized to whole pages.</p> <p>Sizes of carriers allocated through <code class="code">sys_alloc</code> are decided based on the value of the <code class="code">sys_alloc</code> carrier size (<code><a href="#Muycs"><span class="code">ycs</span></a></code>) parameter. The size of a carrier is the least number of multiples of the value of parameter <code class="code">ycs</code> satisfying the request.</p> <p>Coalescing of free blocks are always performed immediately. Boundary tags (headers and footers) in free blocks are used, which makes the time complexity for coalescing constant.</p> <p>The memory allocation strategy used for multiblock carriers by an allocator can be configured using parameter <code id="strategy"><a href="#M_as"><span class="code">as</span></a></code>. The following strategies are available:</p> <dl> <dt><strong>Best fit</strong></dt> <dd> <p>Strategy: Find the smallest block satisfying the requested block size.</p> <p>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of sizes of free blocks.</p> </dd> <dt><strong>Address order best fit</strong></dt> <dd> <p>Strategy: Find the smallest block satisfying the requested block size. If multiple blocks are found, choose the one with the lowest address.</p> <p>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of free blocks.</p> </dd> <dt><strong>Address order first fit</strong></dt> <dd> <p>Strategy: Find the block with the lowest address satisfying the requested block size.</p> <p>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of free blocks.</p> </dd> <dt><strong>Address order first fit carrier best fit</strong></dt> <dd> <p>Strategy: Find the <strong>carrier</strong> with the lowest address that can satisfy the requested block size, then find a block within that carrier using the "best fit" strategy.</p> <p>Implementation: Balanced binary search trees are used. The time complexity is proportional to log N, where N is the number of free blocks.</p> </dd> <dt><strong>Address order first fit carrier address order best fit</strong></dt> <dd> <p>Strategy: Find the <strong>carrier</strong> with the lowest address that can satisfy the requested block size, then find a block within that carrier using the "address order best fit" strategy.</p> <p>Implementation: Balanced binary search trees are used. The time complexity is proportional to log N, where N is the number of free blocks.</p> </dd> <dt><strong>Age order first fit carrier address order first fit</strong></dt> <dd> <p>Strategy: Find the <strong>oldest carrier</strong> that can satisfy the requested block size, then find a block within that carrier using the "address order first fit" strategy.</p> <p>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of free blocks.</p> </dd> <dt><strong>Age order first fit carrier best fit</strong></dt> <dd> <p>Strategy: Find the <strong>oldest carrier</strong> that can satisfy the requested block size, then find a block within that carrier using the "best fit" strategy.</p> <p>Implementation: Balanced binary search trees are used. The time complexity is proportional to log N, where N is the number of free blocks.</p> </dd> <dt><strong>Age order first fit carrier address order best fit</strong></dt> <dd> <p>Strategy: Find the <strong>oldest carrier</strong> that can satisfy the requested block size, then find a block within that carrier using the "address order best fit" strategy.</p> <p>Implementation: Balanced binary search trees are used. The time complexity is proportional to log N, where N is the number of free blocks.</p> </dd> <dt><strong>Good fit</strong></dt> <dd> <p>Strategy: Try to find the best fit, but settle for the best fit found during a limited search.</p> <p>Implementation: The implementation uses segregated free lists with a maximum block search depth (in each list) to find a good fit fast. When the maximum block search depth is small (by default 3), this implementation has a time complexity that is constant. The maximum block search depth can be configured using parameter <code><a href="#M_mbsd"><span class="code">mbsd</span></a></code>.</p> </dd> <dt><strong>A fit</strong></dt> <dd> <p>Strategy: Do not search for a fit, inspect only one free block to see if it satisfies the request. This strategy is only intended to be used for temporary allocations.</p> <p>Implementation: Inspect the first block in a free-list. If it satisfies the request, it is used, otherwise a new carrier is created. The implementation has a time complexity that is constant.</p> <p>As from ERTS 5.6.1 the emulator refuses to use this strategy on other allocators than <code class="code">temp_alloc</code>. This because it only causes problems for other allocators.</p> </dd> </dl> <p>Apart from the ordinary allocators described above, some pre-allocators are used for some specific data types. These pre-allocators pre-allocate a fixed amount of memory for certain data types when the runtime system starts. As long as pre-allocated memory is available, it is used. When no pre-allocated memory is available, memory is allocated in ordinary allocators. These pre-allocators are typically much faster than the ordinary allocators, but can only satisfy a limited number of requests.</p> </section> <section class="innertube"><h2 id="system-flags-effecting-erts_alloc" class="title-link" onmouseover="document.getElementById('ghlink-system-flags-effecting-erts_alloc-idm28471').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-system-flags-effecting-erts_alloc-idm28471').style.visibility = 'hidden';"> <div class="title-name">System Flags Effecting erts_alloc</div>  </h2>  <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Only use these flags if you are sure what you are doing. Unsuitable settings can cause serious performance degradation and even a system crash at any time during operation.</p> </div> </div> <p>Memory allocator system flags have the following syntax: <code class="code">+M&lt;S&gt;&lt;P&gt; &lt;V&gt;</code>, where <code class="code">&lt;S&gt;</code> is a letter identifying a subsystem, <code class="code">&lt;P&gt;</code> is a parameter, and <code class="code">&lt;V&gt;</code> is the value to use. The flags can be passed to the Erlang emulator (<code><a href="erl"><span class="code">erl(1)</span></a></code>) as command-line arguments.</p> <p>System flags effecting specific allocators have an uppercase letter as <code class="code">&lt;S&gt;</code>. The following letters are used for the allocators:</p> <ul> <li><code class="code">B: binary_alloc</code></li> <li><code class="code">D: std_alloc</code></li> <li><code class="code">E: ets_alloc</code></li> <li><code class="code">F: fix_alloc</code></li> <li><code class="code">H: eheap_alloc</code></li> <li><code class="code">I: literal_alloc</code></li> <li><code class="code">L: ll_alloc</code></li> <li><code class="code">M: mseg_alloc</code></li> <li><code class="code">R: driver_alloc</code></li> <li><code class="code">S: sl_alloc</code></li> <li><code class="code">T: temp_alloc</code></li> <li><code class="code">Y: sys_alloc</code></li> </ul> <section><h4 id="Flags for Configuration of mseg_alloc">Flags for Configuration of mseg_alloc</h4>  <dl> <dt><strong><code class="code" id="MMamcbf">+MMamcbf &lt;size&gt;</code></strong></dt> <dd> <p>Absolute maximum cache bad fit (in kilobytes). A segment in the memory segment cache is not reused if its size exceeds the requested size with more than the value of this parameter. Defaults to <code class="code">4096</code>.</p> </dd> <dt><strong><code class="code" id="MMrmcbf">+MMrmcbf &lt;ratio&gt;</code></strong></dt> <dd> <p>Relative maximum cache bad fit (in percent). A segment in the memory segment cache is not reused if its size exceeds the requested size with more than relative maximum cache bad fit percent of the requested size. Defaults to <code class="code">20</code>.</p> </dd> <dt><strong><code class="code" id="MMsco">+MMsco true|false</code></strong></dt> <dd> <p>Sets <code><a href="#MMscs">super carrier</a></code> only flag. Defaults to <code class="code">true</code>. When a super carrier is used and this flag is <code class="code">true</code>, <code class="code">mseg_alloc</code> only creates carriers in the super carrier. Notice that the <code class="code">alloc_util</code> framework can create <code class="code">sys_alloc</code> carriers, so if you want all carriers to be created in the super carrier, you therefore want to disable use of <code class="code">sys_alloc</code> carriers by also passing <code><a href="#Musac"><span class="code">+Musac false</span></a></code>. When the flag is <code class="code">false</code>, <code class="code">mseg_alloc</code> tries to create carriers outside of the super carrier when the super carrier is full.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Setting this flag to <code class="code">false</code> is not supported on all systems. The flag is then ignored.</p> </div> </div> </dd> <dt><strong><code class="code" id="MMscrfsd">+MMscrfsd &lt;amount&gt;</code></strong></dt> <dd> <p>Sets <code><a href="#MMscs">super carrier</a></code> reserved free segment descriptors. Defaults to <code class="code">65536</code>. This parameter determines the amount of memory to reserve for free segment descriptors used by the super carrier. If the system runs out of reserved memory for free segment descriptors, other memory is used. This can however cause fragmentation issues, so you want to ensure that this never happens. The maximum amount of free segment descriptors used can be retrieved from the <code class="code">erts_mmap</code> tuple part of the result from calling <code> <span class="code">erlang:system_info({allocator, mseg_alloc})</span></code>.</p> </dd> <dt><strong><code class="code" id="MMscrpm">+MMscrpm true|false</code></strong></dt> <dd> <p>Sets <code><a href="#MMscs">super carrier</a></code> reserve physical memory flag. Defaults to <code class="code">true</code>. When this flag is <code class="code">true</code>, physical memory is reserved for the whole super carrier at once when it is created. The reservation is after that left unchanged. When this flag is set to <code class="code">false</code>, only virtual address space is reserved for the super carrier upon creation. The system attempts to reserve physical memory upon carrier creations in the super carrier, and attempt to unreserve physical memory upon carrier destructions in the super carrier.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>What reservation of physical memory means, highly depends on the operating system, and how it is configured. For example, different memory overcommit settings on Linux drastically change the behavior.</p> <p>Setting this flag to <code class="code">false</code> is possibly not supported on all systems. The flag is then ignored.</p> </div> </div> </dd> <dt><strong><code class="code" id="MMscs">+MMscs &lt;size in MB&gt;</code></strong></dt> <dd> <p>Sets super carrier size (in MB). Defaults to <code class="code">0</code>, that is, the super carrier is by default disabled. The super carrier is a large continuous area in the virtual address space. <code class="code">mseg_alloc</code> always tries to create new carriers in the super carrier if it exists. Notice that the <code class="code">alloc_util</code> framework can create <code class="code">sys_alloc</code> carriers. For more information, see <code><a href="#MMsco"><span class="code">+MMsco</span></a></code>.</p> </dd> <dt><strong><code class="code" id="MMmcs">+MMmcs &lt;amount&gt;</code></strong></dt> <dd> <p>Maximum cached segments. The maximum number of memory segments stored in the memory segment cache. Valid range is <code class="code">[0, 30]</code>. Defaults to <code class="code">10</code>.</p> </dd> </dl> </section> <section><h4 id="Flags for Configuration of sys_alloc">Flags for Configuration of sys_alloc</h4>  <dl> <dt><strong><code class="code" id="MYe">+MYe true</code></strong></dt> <dd> <p>Enables <code class="code">sys_alloc</code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p><code class="code">sys_alloc</code> cannot be disabled.</p> </div> </div> </dd> <dt><strong><code class="code" id="MYtt">+MYtt &lt;size&gt;</code></strong></dt> <dd> <p>Trim threshold size (in kilobytes). This is the maximum amount of free memory at the top of the heap (allocated by <code class="code">sbrk</code>) that is kept by <code class="code">malloc</code> (not released to the operating system). When the amount of free memory at the top of the heap exceeds the trim threshold, <code class="code">malloc</code> releases it (by calling <code class="code">sbrk</code>). Trim threshold is specified in kilobytes. Defaults to <code class="code">128</code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This flag has effect only when the emulator is linked with the GNU C library, and uses its <code class="code">malloc</code> implementation.</p> </div> </div> </dd> <dt><strong><code class="code" id="MYtp">+MYtp &lt;size&gt;</code></strong></dt> <dd> <p>Top pad size (in kilobytes). This is the amount of extra memory that is allocated by <code class="code">malloc</code> when <code class="code">sbrk</code> is called to get more memory from the operating system. Defaults to <code class="code">0</code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This flag has effect only when the emulator is linked with the GNU C library, and uses its <code class="code">malloc</code> implementation.</p> </div> </div> </dd> </dl> </section> <section><h4 id="Flags for Configuration of Allocators Based on alloc_util">Flags for Configuration of Allocators Based on alloc_util</h4>  <p>If <code class="code">u</code> is used as subsystem identifier (that is, <code class="code">&lt;S&gt; = u</code>), all allocators based on <code class="code">alloc_util</code> are effected. If <code class="code">B</code>, <code class="code">D</code>, <code class="code">E</code>, <code class="code">F</code>, <code class="code">H</code>, <code class="code">I</code>, <code class="code">L</code>, <code class="code">R</code>, <code class="code">S</code>, <code class="code">T</code>, <code class="code">X</code> is used as subsystem identifier, only the specific allocator identifier is effected.</p> <dl> <dt><strong><code class="code" id="M_acul">+M&lt;S&gt;acul &lt;utilization&gt;|de</code> </strong></dt> <dd> <p>Abandon carrier utilization limit. A valid <code class="code">&lt;utilization&gt;</code> is an integer in the range <code class="code">[0, 100]</code> representing utilization in percent. When a utilization value &gt; 0 is used, allocator instances are allowed to abandon multiblock carriers. If <code class="code">de</code> (default enabled) is passed instead of a <code class="code">&lt;utilization&gt;</code>, a recommended non-zero utilization value is used. The value chosen depends on the allocator type and can be changed between ERTS versions. Defaults to <code class="code">de</code>, but this can be changed in the future.</p> <p>Carriers are abandoned when memory utilization in the allocator instance falls below the utilization value used. Once a carrier is abandoned, no new allocations are made in it. When an allocator instance gets an increased multiblock carrier need, it first tries to fetch an abandoned carrier from another allocator instance. If no abandoned carrier can be fetched, it creates a new empty carrier. When an abandoned carrier has been fetched, it will function as an ordinary carrier. This feature has special requirements on the <code><a href="#M_as">allocation strategy</a></code> used. Only the strategies <code class="code">aoff</code>, <code class="code">aoffcbf</code>, <code class="code">aoffcaobf</code>, <code class="code">ageffcaoff</code>m, <code class="code">ageffcbf</code> and <code class="code">ageffcaobf</code> support abandoned carriers.</p> <p>This feature also requires <code><a href="#M_t">multiple thread specific instances</a></code> to be enabled. When enabling this feature, multiple thread-specific instances are enabled if not already enabled, and the <code class="code">aoffcbf</code> strategy is enabled if the current strategy does not support abandoned carriers. This feature can be enabled on all allocators based on the <code class="code">alloc_util</code> framework, except <code class="code">temp_alloc</code> (which would be pointless).</p> </dd> <dt><strong><code class="code" id="M_acfml">+M&lt;S&gt;acfml &lt;bytes&gt;</code> </strong></dt> <dd> <p>Abandon carrier free block min limit. A valid <code class="code">&lt;bytes&gt;</code> is a positive integer representing a block size limit. The largest free block in a carrier must be at least <code class="code">bytes</code> large, for the carrier to be abandoned. The default is zero but can be changed in the future.</p> <p>See also <code><a href="#M_acul"><span class="code">acul</span></a></code>.</p> </dd> <dt><strong><code class="code" id="M_acnl">+M&lt;S&gt;acnl &lt;amount&gt;</code> </strong></dt> <dd> <p>Abandon carrier number limit. A valid <code class="code">&lt;amount&gt;</code> is a positive integer representing max number of abandoned carriers per allocator instance. Defaults to 1000 which will practically disable the limit, but this can be changed in the future.</p> <p>See also <code><a href="#M_acul"><span class="code">acul</span></a></code>.</p> </dd> <dt><strong> <code class="code" id="M_as">+M&lt;S&gt;as bf|aobf|aoff|aoffcbf|aoffcaobf|ageffcaoff|ageffcbf|ageffcaobf|gf|af</code></strong></dt> <dd> <p>Allocation strategy. The following strategies are valid:</p> <ul> <li> <code class="code">bf</code> (best fit)</li> <li> <code class="code">aobf</code> (address order best fit)</li> <li> <code class="code">aoff</code> (address order first fit)</li> <li> <code class="code">aoffcbf</code> (address order first fit carrier best fit) </li> <li> <code class="code">aoffcaobf</code> (address order first fit carrier address order best fit)</li> <li> <code class="code">ageffcaoff</code> (age order first fit carrier address order first fit)</li> <li> <code class="code">ageffcbf</code> (age order first fit carrier best fit) </li> <li> <code class="code">ageffcaobf</code> (age order first fit carrier address order best fit)</li> <li> <code class="code">gf</code> (good fit)</li> <li> <code class="code">af</code> (a fit)</li> </ul> <p>See the description of allocation strategies in section <code><a href="#strategy">The alloc_util Framework</a></code>.</p> </dd> <dt><strong><code class="code" id="M_asbcst">+M&lt;S&gt;asbcst &lt;size&gt;</code></strong></dt> <dd> <p>Absolute singleblock carrier shrink threshold (in kilobytes). When a block located in an <code class="code">mseg_alloc</code> singleblock carrier is shrunk, the carrier is left unchanged if the amount of unused memory is less than this threshold, otherwise the carrier is shrunk. See also <code><a href="#M_rsbcst"><span class="code">rsbcst</span></a></code>.</p> </dd> <dt><strong><code class="code" id="M_atags">+M&lt;S&gt;atags true|false</code></strong></dt> <dd> <p>Adds a small tag to each allocated block that contains basic information about what it is and who allocated it. Use the <code><span class="code">instrument</span></code> module to inspect this information.</p> <p>The runtime overhead is one word per allocation when enabled. This may change at any time in the future.</p> <p>The default is <code class="code">true</code> for <code class="code">binary_alloc</code> and <code class="code">driver_alloc</code>, and <code class="code">false</code> for the other allocator types.</p> </dd> <dt><strong><code class="code" id="M_cp">+M&lt;S&gt;cp B|D|E|F|H||L|R|S|@|:</code></strong></dt> <dd> <p> Set carrier pool to use for the allocator. Memory carriers will only migrate between allocator instances that use the same carrier pool. The following carrier pool names exist: </p> <dl> <dt><strong><code class="code">B</code></strong></dt> <dd>Carrier pool associated with <code class="code">binary_alloc</code>.</dd> <dt><strong><code class="code">D</code></strong></dt> <dd>Carrier pool associated with <code class="code">std_alloc</code>.</dd> <dt><strong><code class="code">E</code></strong></dt> <dd>Carrier pool associated with <code class="code">ets_alloc</code>.</dd> <dt><strong><code class="code">F</code></strong></dt> <dd>Carrier pool associated with <code class="code">fix_alloc</code>.</dd> <dt><strong><code class="code">H</code></strong></dt> <dd>Carrier pool associated with <code class="code">eheap_alloc</code>.</dd> <dt><strong><code class="code">L</code></strong></dt> <dd>Carrier pool associated with <code class="code">ll_alloc</code>.</dd> <dt><strong><code class="code">R</code></strong></dt> <dd>Carrier pool associated with <code class="code">driver_alloc</code>.</dd> <dt><strong><code class="code">S</code></strong></dt> <dd>Carrier pool associated with <code class="code">sl_alloc</code>.</dd> <dt><strong><code class="code">@</code></strong></dt> <dd>Carrier pool associated with the system as a whole.</dd> </dl> <p> Besides passing carrier pool name as value to the parameter, you can also pass <code class="code">:</code>. By passing <code class="code">:</code> instead of carrier pool name, the allocator will use the carrier pool associated with itself. By passing the command line argument "<code class="code">+Mucg :</code>", all allocators that have an associated carrier pool will use the carrier pool associated with themselves. </p> <p> The association between carrier pool and allocator is very loose. The associations are more or less only there to get names for the amount of carrier pools needed and names of carrier pools that can be easily identified by the <code class="code">:</code> value. </p> <p> This flag is only valid for allocators that have an associated carrier pool. Besides that, there are no restrictions on carrier pools to use for an allocator. </p> <p> Currently each allocator with an associated carrier pool defaults to using its own associated carrier pool. </p> </dd> <dt><strong><code class="code" id="M_e">+M&lt;S&gt;e true|false</code></strong></dt> <dd> <p>Enables allocator <code class="code">&lt;S&gt;</code>.</p> </dd> <dt><strong><code class="code" id="M_lmbcs">+M&lt;S&gt;lmbcs &lt;size&gt;</code></strong></dt> <dd> <p>Largest (<code class="code">mseg_alloc</code>) multiblock carrier size (in kilobytes). See the description on how sizes for <code class="code">mseg_alloc</code> multiblock carriers are decided in section <code><a href="#mseg_mbc_sizes"> The alloc_util Framework</a></code>. On 32-bit Unix style OS this limit cannot be set &gt; 64 MB.</p> </dd> <dt><strong><code class="code" id="M_mbcgs">+M&lt;S&gt;mbcgs &lt;ratio&gt;</code></strong></dt> <dd> <p>(<code class="code">mseg_alloc</code>) multiblock carrier growth stages. See the description on how sizes for <code class="code">mseg_alloc</code> multiblock carriers are decided in section <code><a href="#mseg_mbc_sizes"> The alloc_util Framework</a></code>.</p> </dd> <dt><strong><code class="code" id="M_mbsd">+M&lt;S&gt;mbsd &lt;depth&gt;</code></strong></dt> <dd> <p>Maximum block search depth. This flag has effect only if the good fit strategy is selected for allocator <code class="code">&lt;S&gt;</code>. When the good fit strategy is used, free blocks are placed in segregated free-lists. Each free-list contains blocks of sizes in a specific range. The maximum block search depth sets a limit on the maximum number of blocks to inspect in a free-list during a search for suitable block satisfying the request.</p> </dd> <dt><strong><code class="code" id="M_mmbcs">+M&lt;S&gt;mmbcs &lt;size&gt;</code></strong></dt> <dd> <p>Main multiblock carrier size. Sets the size of the main multiblock carrier for allocator <code class="code">&lt;S&gt;</code>. The main multiblock carrier is allocated through <code class="code">sys_alloc</code> and is never deallocated.</p> </dd> <dt><strong><code class="code" id="M_mmmbc">+M&lt;S&gt;mmmbc &lt;amount&gt;</code></strong></dt> <dd> <p>Maximum <code class="code">mseg_alloc</code> multiblock carriers. Maximum number of multiblock carriers allocated through <code class="code">mseg_alloc</code> by allocator <code class="code">&lt;S&gt;</code>. When this limit is reached, new multiblock carriers are allocated through <code class="code">sys_alloc</code>.</p> </dd> <dt><strong><code class="code" id="M_mmsbc">+M&lt;S&gt;mmsbc &lt;amount&gt;</code></strong></dt> <dd> <p>Maximum <code class="code">mseg_alloc</code> singleblock carriers. Maximum number of singleblock carriers allocated through <code class="code">mseg_alloc</code> by allocator <code class="code">&lt;S&gt;</code>. When this limit is reached, new singleblock carriers are allocated through <code class="code">sys_alloc</code>.</p> </dd> <dt><strong><code class="code" id="M_ramv">+M&lt;S&gt;ramv &lt;bool&gt;</code></strong></dt> <dd> <p>Realloc always moves. When enabled, reallocate operations are more or less translated into an allocate, copy, free sequence. This often reduces memory fragmentation, but costs performance.</p> </dd> <dt><strong><code class="code" id="M_rmbcmt">+M&lt;S&gt;rmbcmt &lt;ratio&gt;</code></strong></dt> <dd> <p>Relative multiblock carrier move threshold (in percent). When a block located in a multiblock carrier is shrunk, the block is moved if the ratio of the size of the freed memory compared to the previous size is more than this threshold, otherwise the block is shrunk at the current location.</p> </dd> <dt><strong><code class="code" id="M_rsbcmt">+M&lt;S&gt;rsbcmt &lt;ratio&gt;</code></strong></dt> <dd> <p>Relative singleblock carrier move threshold (in percent). When a block located in a singleblock carrier is shrunk to a size smaller than the value of parameter <code><a href="#M_sbct"><span class="code">sbct</span></a></code>, the block is left unchanged in the singleblock carrier if the ratio of unused memory is less than this threshold, otherwise it is moved into a multiblock carrier.</p> </dd> <dt><strong><code class="code" id="M_rsbcst">+M&lt;S&gt;rsbcst &lt;ratio&gt;</code></strong></dt> <dd> <p>Relative singleblock carrier shrink threshold (in percent). When a block located in an <code class="code">mseg_alloc</code> singleblock carrier is shrunk, the carrier is left unchanged if the ratio of unused memory is less than this threshold, otherwise the carrier is shrunk. See also <code><a href="#M_asbcst"><span class="code">asbcst</span></a></code>.</p> </dd> <dt><strong><code class="code" id="M_sbct">+M&lt;S&gt;sbct &lt;size&gt;</code></strong></dt> <dd> <p>Singleblock carrier threshold (in kilobytes). Blocks larger than this threshold are placed in singleblock carriers. Blocks smaller than this threshold are placed in multiblock carriers. On 32-bit Unix style OS this threshold cannot be set &gt; 8 MB.</p> </dd> <dt><strong><code class="code" id="M_smbcs">+M&lt;S&gt;smbcs &lt;size&gt;</code></strong></dt> <dd> <p>Smallest (<code class="code">mseg_alloc</code>) multiblock carrier size (in kilobytes). See the description on how sizes for <code class="code">mseg_alloc</code> multiblock carriers are decided in section <code><a href="#mseg_mbc_sizes"> The alloc_util Framework</a></code>.</p> </dd> <dt><strong><code class="code" id="M_t">+M&lt;S&gt;t true|false</code></strong></dt> <dd> <p>Multiple, thread-specific instances of the allocator. Default behavior is <code class="code">NoSchedulers+1</code> instances. Each scheduler uses a lock-free instance of its own and other threads use a common instance.</p> <p>Before ERTS 5.9 it was possible to configure a smaller number of thread-specific instances than schedulers. This is, however, not possible anymore.</p> </dd> </dl> </section> <section><h4 id="Flags for Configuration of alloc_util">Flags for Configuration of alloc_util</h4>  <p>All allocators based on <code class="code">alloc_util</code> are effected.</p> <dl> <dt><strong><code class="code" id="Muycs">+Muycs &lt;size&gt;</code></strong></dt> <dd> <p><code class="code">sys_alloc</code> carrier size. Carriers allocated through <code class="code">sys_alloc</code> are allocated in sizes that are multiples of the <code class="code">sys_alloc</code> carrier size. This is not true for main multiblock carriers and carriers allocated during a memory shortage, though.</p> </dd> <dt><strong><code class="code" id="Mummc">+Mummc &lt;amount&gt;</code></strong></dt> <dd> <p>Maximum <code class="code">mseg_alloc</code> carriers. Maximum number of carriers placed in separate memory segments. When this limit is reached, new carriers are placed in memory retrieved from <code class="code">sys_alloc</code>.</p> </dd> <dt><strong><code class="code" id="Musac">+Musac &lt;bool&gt;</code></strong></dt> <dd> <p>Allow <code class="code">sys_alloc</code> carriers. Defaults to <code class="code">true</code>. If set to <code class="code">false</code>, <code class="code">sys_alloc</code> carriers are never created by allocators using the <code class="code">alloc_util</code> framework.</p> </dd> </dl> </section> <section><h4 id="Special Flag for literal_alloc">Special Flag for literal_alloc</h4>  <dl> <dt><strong><code class="code" id="MIscs">+MIscs &lt;size in MB&gt;</code></strong></dt> <dd> <p><code class="code">literal_alloc</code> super carrier size (in MB). The amount of <strong>virtual</strong> address space reserved for literal terms in Erlang code on 64-bit architectures. Defaults to <code class="code">1024</code> (that is, 1 GB), which is usually sufficient. The flag is ignored on 32-bit architectures.</p> </dd> </dl> </section> <section><h4 id="Instrumentation Flags">Instrumentation Flags</h4>  <dl> <dt><strong><code class="code">+M&lt;S&gt;atags</code></strong></dt> <dd> <p>Adds a small tag to each allocated block that contains basic information about what it is and who allocated it. See <code><a href="#M_atags"><span class="code">+M&lt;S&gt;atags</span></a></code> for a more complete description.</p> </dd> </dl> <div class="note"> <div class="label">Note</div> <div class="content">

<p>When instrumentation of the emulator is enabled, the emulator uses more memory and runs slower.</p> </div> </div> </section> <section><h4 id="Other Flags">Other Flags</h4>  <dl> <dt><strong><code class="code" id="Mea">+Mea min|max|r9c|r10b|r11b|config</code></strong></dt> <dd> <p>Options:</p> <dl> <dt><strong><code class="code">min</code></strong></dt> <dd> <p>Disables all allocators that can be disabled.</p> </dd> <dt><strong><code class="code">max</code></strong></dt> <dd> <p>Enables all allocators (default).</p> </dd> <dt><strong><code class="code">r9c|r10b|r11b</code></strong></dt> <dd> <p>Configures all allocators as they were configured in respective Erlang/OTP release. These will eventually be removed.</p> </dd> <dt><strong><code class="code">config</code></strong></dt> <dd> <p>Disables features that cannot be enabled while creating an allocator configuration with <code> <span class="code">erts_alloc_config(3)</span></code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This option is to be used only while running <code class="code">erts_alloc_config(3)</code>, <strong>not</strong> when using the created configuration.</p> </div> </div> </dd> </dl> </dd> <dt><strong><code class="code" id="Mlpm">+Mlpm all|no</code></strong></dt> <dd> <p>Lock physical memory. Defaults to <code class="code">no</code>, that is, no physical memory is locked. If set to <code class="code">all</code>, all memory mappings made by the runtime system are locked into physical memory. If set to <code class="code">all</code>, the runtime system fails to start if this feature is not supported, the user has not got enough privileges, or the user is not allowed to lock enough physical memory. The runtime system also fails with an out of memory condition if the user limit on the amount of locked memory is reached.</p> </dd> <dt><strong><code class="code" id="Mdai">+Mdai max|&lt;amount&gt;</code></strong></dt> <dd> <p> Set amount of dirty allocator instances used. Defaults to <code class="code">0</code>. That is, by default no instances will be used. The maximum amount of instances equals the amount of dirty CPU schedulers on the system. </p> <p> By default, each normal scheduler thread has its own allocator instance for each allocator. All other threads in the system, including dirty schedulers, share one instance for each allocator. By enabling dirty allocator instances, dirty schedulers will get and use their own set of allocator instances. Note that these instances are not exclusive to each dirty scheduler, but instead shared among dirty schedulers. The more instances used the less risk of lock contention on these allocator instances. Memory consumption do however increase with increased amount of dirty allocator instances. </p> </dd> </dl> </section> </section> <section class="innertube"><h2 id="notes" class="title-link" onmouseover="document.getElementById('ghlink-notes-idm28975').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-notes-idm28975').style.visibility = 'hidden';"> <div class="title-name">Notes</div>  </h2>  <p>Only some default values have been presented here. For information about the currently used settings and the current status of the allocators, see <code> <span class="code">erlang:system_info(allocator)</span></code> and <code> <span class="code">erlang:system_info({allocator, Alloc})</span></code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Most of these flags are highly implementation-dependent and can be changed or removed without prior notice.</p> <p><code class="code">erts_alloc</code> is not obliged to strictly use the settings that have been passed to it (it can even ignore them).</p> </div> </div> <p>The <code> <span class="code">erts_alloc_config(3)</span></code> tool can be used to aid creation of an <code class="code">erts_alloc</code> configuration that is suitable for a limited number of runtime scenarios.</p> </section> <section class="innertube"><h2 id="see-also" class="title-link" onmouseover="document.getElementById('ghlink-see-also-idm28990').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-see-also-idm28990').style.visibility = 'hidden';"> <div class="title-name">See Also</div>  </h2>  <p><code><a href="erl"><span class="code">erl(1)</span></a></code>, <code><a href="erlang"><span class="code">erlang(3)</span></a></code>, <code> <span class="code">erts_alloc_config(3)</span></code>, <code> <span class="code">instrument(3)</span></code></p> </section> <div class="footer"> <hr> <p>Copyright © 1997-2022 Ericsson AB. All Rights Reserved.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2022 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
