<div class="innertube"> <h1 id="Opaques">8 Opaques</h1> <h2 id="opaque-type-aliases" class="title-link" onmouseover="document.getElementById('ghlink-opaque-type-aliases-idm1286').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-opaque-type-aliases-idm1286').style.visibility = 'hidden';"> <div class="title-name">8.1 Opaque Type Aliases</div>  </h2> <p>The main use case for opacity in Erlang is to hide the implementation of a data type, enabling evolving the API while minimizing the risk of breaking consumers. The runtime does not check opacity. Dialyzer provides some opacity-checking, but the rest is up to convention. </p> <p> This document explains what Erlang opacity is (and the trade-offs involved) via the example of OTP's <code class="code">sets:set()</code> data type. This type <strong>was</strong> defined in `sets` module like this: </p> <pre data-language="erlang">-opaque set(Element) :: #set{segs :: segs(Element)}.</pre> <p>OTP 24 changed the definition to the following, in <code><a href="https://github.com/erlang/otp/commit/e66941e8d7c47b973dff94c0308ea85a6be1958e">this commit</a></code> </p> <pre data-language="erlang">-opaque set(Element) :: #set{segs :: segs(Element)} | #{Element =&gt; ?VALUE}.</pre> <p> And this change was safer and more backwards-compatible than if the type had been defined with <code class="code">-type</code> instead of <code class="code">-opaque</code> . Here's why: when a module defines an <code class="code">-opaque</code> , the contract is that only the defining module should rely on the definition of the type: no other modules should rely on the definition. </p> <p> This means that code that pattern-matched on <code class="code">set</code> as a record/tuple technically broke the contract, and opted in to being potentially broken when the definition of <code class="code">set()</code> changed. Before OTP 24, this code printed <code class="code">ok</code> . In OTP 24 it may error: </p> <pre data-language="erlang">case sets:new() of
    Set when is_tuple(Set) -&gt;
        io:format("ok")
end.</pre> <p> <strong>When working with an opaque defined in another module, here are some recommendations:</strong> </p> <ul> <li> Don't examine the underlying type using pattern-matching, guards, or functions that reveal the type, such as <code class="code">tuple_size/1</code> . </li> <li> Instead, use functions provided by the module for working with the type. For example, <code class="code">sets</code> module provides <code class="code">sets:new/0</code> , <code class="code">sets:add/2</code> , <code class="code">sets:is_element/2</code> , etc. </li> <li> <code class="code">sets:set(a)</code> is a subtype of <code class="code">sets:set(a | b)</code> and not the other way around. Generally, you can rely on the property that <code class="code">the_opaque(T)</code> is a subtype of <code class="code">the_opaque(U)</code> when T is a subtype of U. </li> </ul> <p> <strong>When defining your own opaques, here are some recommendations:</strong> </p> <ul> <li> Since consumers are expected to not rely on the definition of the opaque type, you must provide functions for constructing and querying/deconstructing intances of your opaque type. For example, sets can be constructed with <code class="code">sets:new/0</code>, <code class="code">sets:from_list/1</code>, <code class="code">sets:add/2</code>, queried with <code class="code">sets:is_element/2</code>, and deconstructed with<code class="code">sets:to_list/1</code>. </li> <li> Don't define an opaque with a type variable in parameter position. This breaks the normal and expected behavior that (for example) <code class="code">my_type(a)</code> is a subtype of <code class="code">my_type(a | b)</code> </li> <li> Add <code><a href="typespec">specs</a></code> to exported functions that use the opaque type </li> </ul> <p>Note that opaques can be harder to work with for consumers, since the consumer is expected not to pattern-match and must instead use functions that the author of the opaque type provides to use instances of the type.</p> <p> Also, opacity in Erlang is skin-deep: the runtime does not enforce opacity-checking. So now that sets are implemented in terms of maps, an <code class="code">is_map</code> check on a set <strong>will</strong> pass. The opacity rules are only enforced by convention and by additional tooling such as Dialyzer. And this enforcement is not total: For example, determined consumer of <code class="code">sets</code> can still do things that reveal the structure of the set, such as by printing, serializing, or using a set as <code class="code">term()</code> and then inspecting via functions like <code class="code">is_map</code> or <code class="code">maps:get/2</code> . And Dialyzer must make some <code><a href="https://github.com/erlang/otp/issues/5118">approximations</a></code> . Opacity checking has limitations, but is still a vital tool in scalable Erlang development. </p> </div> <div class="footer"> <hr> <p>Copyright Â© 2003-2022 Ericsson AB. All Rights Reserved.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2022 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
