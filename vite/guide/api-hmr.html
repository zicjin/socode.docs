<h1 id="hmr-api" tabindex="-1">HMR API </h1>
<div class="tip custom-block">
<strong class="custom-block-title">Note</strong><p>This is the client HMR API. For handling HMR update in plugins, see <a href="api-plugin#handlehotupdate">handleHotUpdate</a>.</p>
<p>The manual HMR API is primarily intended for framework and tooling authors. As an end user, HMR is likely already handled for you in the framework specific starter templates.</p>
</div>
<p>Vite exposes its manual HMR API via the special <code>import.<wbr>meta.hot</wbr></code> object:</p>
<div class="language-ts">
<pre data-language="javascript">interface ImportMeta {
  readonly hot?: ViteHotContext
}

type ModuleNamespace = Record&lt;string, any&gt; &amp; {
  [Symbol.toStringTag]: 'Module'
}

interface ViteHotContext {
  readonly data: any

  accept(): void
  accept(cb: (mod: ModuleNamespace | undefined) =&gt; void): void
  accept(dep: string, cb: (mod: ModuleNamespace | undefined) =&gt; void): void
  accept(
    deps: readonly string[],
    cb: (mods: Array&lt;ModuleNamespace | undefined&gt;) =&gt; void
  ): void

  dispose(cb: (data: any) =&gt; void): void
  decline(): void
  invalidate(): void

  // `InferCustomEventPayload` provides types for built-in Vite events
  on&lt;T extends string&gt;(
    event: T,
    cb: (payload: InferCustomEventPayload&lt;T&gt;) =&gt; void
  ): void
  send&lt;T extends string&gt;(event: T, data?: InferCustomEventPayload&lt;T&gt;): void
}</pre>
</div>
<h2 id="required-conditional-guard" tabindex="-1">Required Conditional Guard </h2>
<p>First of all, make sure to guard all HMR API usage with a conditional block so that the code can be tree-shaken in production:</p>
<div class="language-js">
<pre data-language="javascript">if (import.meta.hot) {
  // HMR code
}</pre>
</div>
<h2 id="hot-accept-cb" tabindex="-1">
<code>hot.accept(cb)</code> </h2>
<p>For a module to self-accept, use <code>import.<wbr>meta.hot.accept</wbr></code> with a callback which receives the updated module:</p>
<div class="language-js">
<pre data-language="javascript">export const count = 1

if (import.meta.hot) {
  import.meta.hot.accept((newModule) =&gt; {
    if (newModule) {
      // newModule is undefined when SyntaxError happened
      console.log('updated: count is now ', newModule.count)
    }
  })
}</pre>
</div>
<p>A module that "accepts" hot updates is considered an <strong>HMR boundary</strong>.</p>
<p>Note that Vite's HMR does not actually swap the originally imported module: if an HMR boundary module re-exports imports from a dep, then it is responsible for updating those re-exports (and these exports must be using <code>let</code>). In addition, importers up the chain from the boundary module will not be notified of the change.</p>
<p>This simplified HMR implementation is sufficient for most dev use cases, while allowing us to skip the expensive work of generating proxy modules.</p>
<h2 id="hot-accept-deps-cb" tabindex="-1">
<code>hot.accept(deps, cb)</code> </h2>
<p>A module can also accept updates from direct dependencies without reloading itself:</p>
<div class="language-js">
<pre data-language="javascript">import { foo } from './foo.js'

foo()

if (import.meta.hot) {
  import.meta.hot.accept('./foo.js', (newFoo) =&gt; {
    // the callback receives the updated './foo.js' module
    newFoo?.foo()
  })

  // Can also accept an array of dep modules:
  import.meta.hot.accept(
    ['./foo.js', './bar.js'],
    ([newFooModule, newBarModule]) =&gt; {
      // the callback receives the updated modules in an Array
    }
  )
}</pre>
</div>
<h2 id="hot-dispose-cb" tabindex="-1">
<code>hot.dispose(cb)</code> </h2>
<p>A self-accepting module or a module that expects to be accepted by others can use <code>hot.dispose</code> to clean-up any persistent side effects created by its updated copy:</p>
<div class="language-js">
<pre data-language="javascript">function setupSideEffect() {}

setupSideEffect()

if (import.meta.hot) {
  import.meta.hot.dispose((data) =&gt; {
    // cleanup side effect
  })
}</pre>
</div>
<h2 id="hot-data" tabindex="-1">
<code>hot.data</code> </h2>
<p>The <code>import.<wbr>meta.hot.data</wbr></code> object is persisted across different instances of the same updated module. It can be used to pass on information from a previous version of the module to the next one.</p>
<h2 id="hot-decline" tabindex="-1">
<code>hot.decline()</code> </h2>
<p>Calling <code>import.<wbr>meta.hot.decline()</wbr></code> indicates this module is not hot-updatable, and the browser should perform a full reload if this module is encountered while propagating HMR updates.</p>
<h2 id="hot-invalidate" tabindex="-1">
<code>hot.invalidate()</code> </h2>
<p>For now, calling <code>import.<wbr>meta.hot.invalidate()</wbr></code> simply reloads the page.</p>
<h2 id="hot-on-event-cb" tabindex="-1">
<code>hot.on(event, cb)</code> </h2>
<p>Listen to an HMR event.</p>
<p>The following HMR events are dispatched by Vite automatically:</p>
<ul>
<li>
<code>'vite:beforeUpdate'</code> when an update is about to be applied (e.g. a module will be replaced)</li>
<li>
<code>'vite:beforeFullReload'</code> when a full reload is about to occur</li>
<li>
<code>'vite:beforePrune'</code> when modules that are no longer needed are about to be pruned</li>
<li>
<code>'vite:error'</code> when an error occurs (e.g. syntax error)</li>
</ul>
<p>Custom HMR events can also be sent from plugins. See <a href="api-plugin#handlehotupdate">handleHotUpdate</a> for more details.</p>
<h2 id="hot-send-event-data" tabindex="-1">
<code>hot.send(event, data)</code> </h2>
<p>Send custom events back to Vite's dev server.</p>
<p>If called before connected, the data will be buffered and sent once the connection is established.</p>
<p>See <a href="api-plugin#client-server-communication">Client-server Communication</a> for more details.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://vitejs.dev/guide/api-hmr.html" class="_attribution-link" target="_blank">https://vitejs.dev/guide/api-hmr.html</a>
  </p>
</div>
