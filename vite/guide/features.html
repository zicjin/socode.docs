<h1 id="features" tabindex="-1">Features </h1>
<p>At the very basic level, developing using Vite is not that much different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.</p>
<h2 id="npm-dependency-resolving-and-pre-bundling" tabindex="-1">NPM Dependency Resolving and Pre-Bundling </h2>
<p>Native ES imports do not support bare module imports like the following:</p>
<div class="language-js">
<pre data-language="javascript">import { someMethod } from 'my-dep'</pre>
</div>
<p>The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:</p>
<ol>
<li><p><a href="dep-pre-bundling">Pre-bundle</a> them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with <a href="http://esbuild.github.io/" target="_blank" rel="noopener noreferrer">esbuild</a> and makes Vite's cold start time significantly faster than any JavaScript-based bundler.</p></li>
<li><p>Rewrite the imports to valid URLs like <code>/node_modules/.vite/deps/my-dep.js?v=f3sf2ebd</code> so that the browser can import them properly.</p></li>
</ol>
<p><strong>Dependencies are Strongly Cached</strong></p>
<p>Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps <a href="dep-pre-bundling#browser-cache">here</a>.</p>
<h2 id="hot-module-replacement" tabindex="-1">Hot Module Replacement </h2>
<p>Vite provides an <a href="api-hmr">HMR API</a> over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for <a href="https://github.com/vitejs/vite/tree/main/packages/plugin-vue" target="_blank" rel="noopener noreferrer">Vue Single File Components</a> and <a href="https://github.com/vitejs/vite/tree/main/packages/plugin-react" target="_blank" rel="noopener noreferrer">React Fast Refresh</a>. There are also official integrations for Preact via <a href="https://github.com/JoviDeCroock/prefresh/tree/main/packages/vite" target="_blank" rel="noopener noreferrer">@prefresh/vite</a>.</p>
<p>Note you don't need to manually set these up - when you <a href="index">create an app via <code>create-vite</code></a>, the selected templates would have these pre-configured for you already.</p>
<h2 id="typescript" tabindex="-1">TypeScript </h2>
<p>Vite supports importing <code>.ts</code> files out of the box.</p>
<p>Vite only performs transpilation on <code>.ts</code> files and does <strong>NOT</strong> perform type checking. It assumes type checking is taken care of by your IDE and build process (you can run <code>tsc --noEmit</code> in the build script or install <code>vue-tsc</code> and run <code>vue-tsc --noEmit</code> to also type check your <code>*.vue</code> files).</p>
<p>Vite uses <a href="https://github.com/evanw/esbuild" target="_blank" rel="noopener noreferrer">esbuild</a> to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla <code>tsc</code>, and HMR updates can reflect in the browser in under 50ms.</p>
<p>Use the <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export" target="_blank" rel="noopener noreferrer">Type-Only Imports and Export</a> syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:</p>
<div class="language-ts">
<pre data-language="javascript">import type { T } from 'only/types'
export type { T }</pre>
</div>
<h3 id="typescript-compiler-options" tabindex="-1">TypeScript Compiler Options </h3>
<p>Some configuration fields under <code>compilerOptions</code> in <code>tsconfig.json</code> require special attention.</p>
<h4 id="isolatedmodules" tabindex="-1">
<code>isolatedModules</code> </h4>
<p>Should be set to <code>true</code>.</p>
<p>It is because <code>esbuild</code> only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.</p>
<p>You must set <code>"isolatedModules": true</code> in your <code>tsconfig.json</code> under <code>compilerOptions</code>, so that TS will warn you against the features that do not work with isolated transpilation.</p>
<p>However, some libraries (e.g. <a href="https://github.com/vuejs/core/issues/1228" target="_blank" rel="noopener noreferrer"><code>vue</code></a>) don't work well with <code>"isolatedModules": true</code>. You can use <code>"skipLibCheck": true</code> to temporarily suppress the errors until it is fixed upstream.</p>
<h4 id="usedefineforclassfields" tabindex="-1">
<code>useDefineForClassFields</code> </h4>
<p>Starting from Vite 2.5.0, the default value will be <code>true</code> if the TypeScript target is <code>ESNext</code>. It is consistent with the <a href="https://github.com/microsoft/TypeScript/pull/42663" target="_blank" rel="noopener noreferrer">behavior of <code>tsc</code> 4.3.2 and later</a>. It is also the standard ECMAScript runtime behavior.</p>
<p>But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier" target="_blank" rel="noopener noreferrer">TypeScript 3.7 release notes</a>.</p>
<p>If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.</p>
<p>Most libraries expect <code>"useDefineForClassFields": true</code>, such as <a href="https://mobx.js.org/installation.html#use-spec-compliant-transpilation-for-class-properties" target="_blank" rel="noopener noreferrer">MobX</a>, <a href="https://github.com/vuejs/vue-class-component/issues/465" target="_blank" rel="noopener noreferrer">Vue Class Components 8.x</a>, etc.</p>
<p>But a few libraries haven't transitioned to this new default yet, including <a href="https://github.com/lit/lit-element/issues/1030" target="_blank" rel="noopener noreferrer"><code>lit-element</code></a>. Please explicitly set <code>useDefineForClassFields</code> to <code>false</code> in these cases.</p>
<h4 id="other-compiler-options-affecting-the-build-result" tabindex="-1">Other Compiler Options Affecting the Build Result </h4>
<ul>
<li><a href="https://www.typescriptlang.org/tsconfig#extends" target="_blank" rel="noopener noreferrer"><code>extends</code></a></li>
<li><a href="https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues" target="_blank" rel="noopener noreferrer"><code>importsNotUsedAsValues</code></a></li>
<li><a href="https://www.typescriptlang.org/tsconfig#preserveValueImports" target="_blank" rel="noopener noreferrer"><code>preserveValueImports</code></a></li>
<li><a href="https://www.typescriptlang.org/tsconfig#jsxFactory" target="_blank" rel="noopener noreferrer"><code>jsxFactory</code></a></li>
<li><a href="https://www.typescriptlang.org/tsconfig#jsxFragmentFactory" target="_blank" rel="noopener noreferrer"><code>jsxFragmentFactory</code></a></li>
</ul>
<p>If migrating your codebase to <code>"isolatedModules": true</code> is an unsurmountable effort, you may be able to get around it with a third-party plugin such as <a href="https://www.npmjs.com/package/rollup-plugin-friendly-type-imports" target="_blank" rel="noopener noreferrer">rollup-plugin-friendly-type-imports</a>. However, this approach is not officially supported by Vite.</p>
<h3 id="client-types" tabindex="-1">Client Types </h3>
<p>Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a <code>d.ts</code> declaration file:</p>
<div class="language-typescript">
<pre data-language="javascript">/// &lt;reference types="vite/client" /&gt;</pre>
</div>
<p>Also, you can add <code>vite/client</code> to <code>compilerOptions.types</code> of your <code>tsconfig</code>:</p>
<div class="language-json">
<pre data-language="javascript">{
  "compilerOptions": {
    "types": ["vite/client"]
  }
}</pre>
</div>
<p>This will provide the following type shims:</p>
<ul>
<li>Asset imports (e.g. importing an <code>.svg</code> file)</li>
<li>Types for the Vite-injected <a href="env-and-mode#env-variables">env variables</a> on <code>import.<wbr>meta.env</wbr></code>
</li>
<li>Types for the <a href="api-hmr">HMR API</a> on <code>import.<wbr>meta.hot</wbr></code>
</li>
</ul>
<h2 id="vue" tabindex="-1">Vue </h2>
<p>Vite provides first-class Vue support:</p>
<ul>
<li>Vue 3 SFC support via <a href="https://github.com/vitejs/vite/tree/main/packages/plugin-vue" target="_blank" rel="noopener noreferrer">@vitejs/plugin-vue</a>
</li>
<li>Vue 3 JSX support via <a href="https://github.com/vitejs/vite/tree/main/packages/plugin-vue-jsx" target="_blank" rel="noopener noreferrer">@vitejs/plugin-vue-jsx</a>
</li>
<li>Vue 2.7 support via <a href="https://github.com/vitejs/vite-plugin-vue2" target="_blank" rel="noopener noreferrer">vitejs/vite-plugin-vue2</a>
</li>
<li>Vue &lt;2.7 support via <a href="https://github.com/underfin/vite-plugin-vue2" target="_blank" rel="noopener noreferrer">underfin/vite-plugin-vue2</a>
</li>
</ul>
<h2 id="jsx" tabindex="-1">JSX </h2>
<p><code>.jsx</code> and <code>.tsx</code> files are also supported out of the box. JSX transpilation is also handled via <a href="https://esbuild.github.io" target="_blank" rel="noopener noreferrer">esbuild</a>.</p>
<p>Vue users should use the official <a href="https://github.com/vitejs/vite/tree/main/packages/plugin-vue-jsx" target="_blank" rel="noopener noreferrer">@vitejs/plugin-vue-jsx</a> plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.</p>
<p>If not using JSX with React or Vue, custom <code>jsxFactory</code> and <code>jsxFragment</code> can be configured using the <a href="../config/shared-options#esbuild"><code>esbuild</code> option</a>. For example for Preact:</p>
<div class="language-js">
<pre data-language="javascript">// vite.config.js
import { defineConfig } from 'vite'

export default defineConfig({
  esbuild: {
    jsxFactory: 'h',
    jsxFragment: 'Fragment'
  }
})</pre>
</div>
<p>More details in <a href="https://esbuild.github.io/content-types/#jsx" target="_blank" rel="noopener noreferrer">esbuild docs</a>.</p>
<p>You can inject the JSX helpers using <code>jsxInject</code> (which is a Vite-only option) to avoid manual imports:</p>
<div class="language-js">
<pre data-language="javascript">// vite.config.js
import { defineConfig } from 'vite'

export default defineConfig({
  esbuild: {
    jsxInject: `import React from 'react'`
  }
})</pre>
</div>
<h2 id="css" tabindex="-1">CSS </h2>
<p>Importing <code>.css</code> files will inject its content to the page via a <code>&lt;style&gt;</code> tag with HMR support. You can also retrieve the processed CSS as a string as the module's default export.</p>
<h3 id="import-inlining-and-rebasing" tabindex="-1">
<code>@import</code> Inlining and Rebasing </h3>
<p>Vite is pre-configured to support CSS <code>@import</code> inlining via <code>postcss-import</code>. Vite aliases are also respected for CSS <code>@import</code>. In addition, all CSS <code>url()</code> references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.</p>
<p><code>@import</code> aliases and URL rebasing are also supported for Sass and Less files (see <a href="#css-pre-processors">CSS Pre-processors</a>).</p>
<h3 id="postcss" tabindex="-1">PostCSS </h3>
<p>If the project contains valid PostCSS config (any format supported by <a href="https://github.com/postcss/postcss-load-config" target="_blank" rel="noopener noreferrer">postcss-load-config</a>, e.g. <code>postcss.config.js</code>), it will be automatically applied to all imported CSS.</p>
<h3 id="css-modules" tabindex="-1">CSS Modules </h3>
<p>Any CSS file ending with <code>.module.css</code> is considered a <a href="https://github.com/css-modules/css-modules" target="_blank" rel="noopener noreferrer">CSS modules file</a>. Importing such a file will return the corresponding module object:</p>
<div class="language-css">
<pre data-language="javascript">/* example.module.css */
.red {
  color: red;
}</pre>
</div>
<div class="language-js">
<pre data-language="javascript">import classes from './example.module.css'
document.getElementById('foo').className = classes.red</pre>
</div>
<p>CSS modules behavior can be configured via the <a href="../config/shared-options#css-modules"><code>css.modules</code> option</a>.</p>
<p>If <code>css.modules.localsConvention</code> is set to enable camelCase locals (e.g. <code>localsConvention: 'camelCaseOnly'</code>), you can also use named imports:</p>
<div class="language-js">
<pre data-language="javascript">// .apply-color -&gt; applyColor
import { applyColor } from './example.module.css'
document.getElementById('foo').className = applyColor</pre>
</div>
<h3 id="css-pre-processors" tabindex="-1">CSS Pre-processors </h3>
<p>Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. <a href="https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-nesting" target="_blank" rel="noopener noreferrer">postcss-nesting</a>) and author plain, future-standards-compliant CSS.</p>
<p>That said, Vite does provide built-in support for <code>.scss</code>, <code>.sass</code>, <code>.less</code>, <code>.styl</code> and <code>.stylus</code> files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:</p>
<div class="language-bash">
<pre data-language="javascript"># .scss and .sass
npm add -D sass

# .less
npm add -D less

# .styl and .stylus
npm add -D stylus</pre>
</div>
<p>If using Vue single file components, this also automatically enables <code>&lt;style lang="sass"&gt;</code> et al.</p>
<p>Vite improves <code>@import</code> resolving for Sass and Less so that Vite aliases are also respected. In addition, relative <code>url()</code> references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.</p>
<p><code>@import</code> alias and url rebasing are not supported for Stylus due to its API constraints.</p>
<p>You can also use CSS modules combined with pre-processors by prepending <code>.module</code> to the file extension, for example <code>style.module.scss</code>.</p>
<h3 id="disabling-css-injection-into-the-page" tabindex="-1">Disabling CSS injection into the page </h3>
<p>The automatic injection of CSS contents can be turned off via the <code>?inline</code> query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.</p>
<div class="language-js">
<pre data-language="javascript">import styles from './foo.css' // will be injected into the page
import otherStyles from './bar.css?inline' // will not be injected into the page</pre>
</div>
<h2 id="static-assets" tabindex="-1">Static Assets </h2>
<p>Importing a static asset will return the resolved public URL when it is served:</p>
<div class="language-js">
<pre data-language="javascript">import imgUrl from './img.png'
document.getElementById('hero-img').src = imgUrl</pre>
</div>
<p>Special queries can modify how assets are loaded:</p>
<div class="language-js">
<pre data-language="javascript">// Explicitly load assets as URL
import assetAsURL from './asset.js?url'</pre>
</div>
<div class="language-js">
<pre data-language="javascript">// Load assets as strings
import assetAsString from './shader.glsl?raw'</pre>
</div>
<div class="language-js">
<pre data-language="javascript">// Load Web Workers
import Worker from './worker.js?worker'</pre>
</div>
<div class="language-js">
<pre data-language="javascript">// Web Workers inlined as base64 strings at build time
import InlineWorker from './worker.js?worker&amp;inline'</pre>
</div>
<p>More details in <a href="assets">Static Asset Handling</a>.</p>
<h2 id="json" tabindex="-1">JSON </h2>
<p>JSON files can be directly imported - named imports are also supported:</p>
<div class="language-js">
<pre data-language="javascript">// import the entire object
import json from './example.json'
// import a root field as named exports - helps with tree-shaking!
import { field } from './example.json'</pre>
</div>
<h2 id="glob-import" tabindex="-1">Glob Import </h2>
<p>Vite supports importing multiple modules from the file system via the special <code>import.<wbr>meta.glob</wbr></code> function:</p>
<div class="language-js">
<pre data-language="javascript">const modules = import.meta.glob('./dir/*.js')</pre>
</div>
<p>The above will be transformed into the following:</p>
<div class="language-js">
<pre data-language="javascript">// code produced by vite
const modules = {
  './dir/foo.js': () =&gt; import('./dir/foo.js'),
  './dir/bar.js': () =&gt; import('./dir/bar.js')
}</pre>
</div>
<p>You can then iterate over the keys of the <code>modules</code> object to access the corresponding modules:</p>
<div class="language-js">
<pre data-language="javascript">for (const path in modules) {
  modules[path]().then((mod) =&gt; {
    console.log(path, mod)
  })
}</pre>
</div>
<p>Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass <code>{ eager: true }</code> as the second argument:</p>
<div class="language-js">
<pre data-language="javascript">const modules = import.meta.glob('./dir/*.js', { eager: true })</pre>
</div>
<p>The above will be transformed into the following:</p>
<div class="language-js">
<pre data-language="javascript">// code produced by vite
import * as __glob__0_0 from './dir/foo.js'
import * as __glob__0_1 from './dir/bar.js'
const modules = {
  './dir/foo.js': __glob__0_0,
  './dir/bar.js': __glob__0_1
}</pre>
</div>
<h3 id="glob-import-as" tabindex="-1">Glob Import As </h3>
<p><code>import.<wbr>meta.glob</wbr></code> also supports importing files as strings (similar to <a href="assets#importing-asset-as-string" target="_blank" rel="noopener noreferrer">Importing Asset as String</a>) with the <a href="https://github.com/tc39/proposal-import-reflection" target="_blank" rel="noopener noreferrer">Import Reflection</a> syntax:</p>
<div class="language-js">
<pre data-language="javascript">const modules = import.meta.glob('./dir/*.js', { as: 'raw' })</pre>
</div>
<p>The above will be transformed into the following:</p>
<div class="language-js">
<pre data-language="javascript">// code produced by vite
const modules = {
  './dir/foo.js': 'export default "foo"\n',
  './dir/bar.js': 'export default "bar"\n'
}</pre>
</div>
<p><code>{ as: 'url' }</code> is also supported for loading assets as URLs.</p>
<h3 id="multiple-patterns" tabindex="-1">Multiple Patterns </h3>
<p>The first argument can be an array of globs, for example</p>
<div class="language-js">
<pre data-language="javascript">const modules = import.meta.glob(['./dir/*.js', './another/*.js'])</pre>
</div>
<h3 id="negative-patterns" tabindex="-1">Negative Patterns </h3>
<p>Negative glob patterns are also supported (prefixed with <code>!</code>). To ignore some files from the result, you can add exclude glob patterns to the first argument:</p>
<div class="language-js">
<pre data-language="javascript">const modules = import.meta.glob(['./dir/*.js', '!**/bar.js'])</pre>
</div>
<div class="language-js">
<pre data-language="javascript">// code produced by vite
const modules = {
  './dir/foo.js': () =&gt; import('./dir/foo.js')
}</pre>
</div>
<h4 id="named-imports" tabindex="-1">Named Imports </h4>
<p>It's possible to only import parts of the modules with the <code>import</code> options.</p>
<div class="language-ts">
<pre data-language="javascript">const modules = import.meta.glob('./dir/*.js', { import: 'setup' })</pre>
</div>
<div class="language-ts">
<pre data-language="javascript">// code produced by vite
const modules = {
  './dir/foo.js': () =&gt; import('./dir/foo.js').then((m) =&gt; m.setup),
  './dir/bar.js': () =&gt; import('./dir/bar.js').then((m) =&gt; m.setup)
}</pre>
</div>
<p>When combined with <code>eager</code> it's even possible to have tree-shaking enabled for those modules.</p>
<div class="language-ts">
<pre data-language="javascript">const modules = import.meta.glob('./dir/*.js', { import: 'setup', eager: true })</pre>
</div>
<div class="language-ts">
<pre data-language="javascript">// code produced by vite:
import { setup as __glob__0_0 } from './dir/foo.js'
import { setup as __glob__0_1 } from './dir/bar.js'
const modules = {
  './dir/foo.js': __glob__0_0,
  './dir/bar.js': __glob__0_1
}</pre>
</div>
<p>Set <code>import</code> to <code>default</code> to import the default export.</p>
<div class="language-ts">
<pre data-language="javascript">const modules = import.meta.glob('./dir/*.js', {
  import: 'default',
  eager: true
})</pre>
</div>
<div class="language-ts">
<pre data-language="javascript">// code produced by vite:
import __glob__0_0 from './dir/foo.js'
import __glob__0_1 from './dir/bar.js'
const modules = {
  './dir/foo.js': __glob__0_0,
  './dir/bar.js': __glob__0_1
}</pre>
</div>
<h4 id="custom-queries" tabindex="-1">Custom Queries </h4>
<p>You can also use the <code>query</code> option to provide custom queries to imports for other plugins to consume.</p>
<div class="language-ts">
<pre data-language="javascript">const modules = import.meta.glob('./dir/*.js', {
  query: { foo: 'bar', bar: true }
})</pre>
</div>
<div class="language-ts">
<pre data-language="javascript">// code produced by vite:
const modules = {
  './dir/foo.js': () =&gt;
    import('./dir/foo.js?foo=bar&amp;bar=true').then((m) =&gt; m.setup),
  './dir/bar.js': () =&gt;
    import('./dir/bar.js?foo=bar&amp;bar=true').then((m) =&gt; m.setup)
}</pre>
</div>
<h3 id="glob-import-caveats" tabindex="-1">Glob Import Caveats </h3>
<p>Note that:</p>
<ul>
<li>This is a Vite-only feature and is not a web or ES standard.</li>
<li>The glob patterns are treated like import specifiers: they must be either relative (start with <code>./</code>) or absolute (start with <code>/</code>, resolved relative to project root) or an alias path (see <a href="../config/shared-options#resolve-alias"><code>resolve.alias</code> option</a>).</li>
<li>The glob matching is done via <a href="https://github.com/mrmlnc/fast-glob" target="_blank" rel="noopener noreferrer"><code>fast-glob</code></a> - check out its documentation for <a href="https://github.com/mrmlnc/fast-glob#pattern-syntax" target="_blank" rel="noopener noreferrer">supported glob patterns</a>.</li>
<li>You should also be aware that all the arguments in the <code>import.<wbr>meta.glob</wbr></code> must be <strong>passed as literals</strong>. You can NOT use variables or expressions in them.</li>
</ul>
<h2 id="dynamic-import" tabindex="-1">Dynamic Import </h2>
<p>Similar to <a href="#glob-import">glob import</a>, Vite also supports dynamic import with variables.</p>
<div class="language-ts">
<pre data-language="javascript">const module = await import(`./dir/${file}.js`)</pre>
</div>
<p>Note that variables only represent file names one level deep. If <code>file</code> is <code>'foo/bar'</code>, the import would fail. For more advanced usage, you can use the <a href="#glob-import">glob import</a> feature.</p>
<h2 id="webassembly" tabindex="-1">WebAssembly </h2>
<p>Pre-compiled <code>.wasm</code> files can be imported with <code>?init</code> - the default export will be an initialization function that returns a Promise of the wasm instance:</p>
<div class="language-js">
<pre data-language="javascript">import init from './example.wasm?init'

init().then((instance) =&gt; {
  instance.exports.test()
})</pre>
</div>
<p>The init function can also take the <code>imports</code> object which is passed along to <code>WebAssembly.instantiate</code> as its second argument:</p>
<div class="language-js">
<pre data-language="javascript">init({
  imports: {
    someFunc: () =&gt; {
      /* ... */
    }
  }
}).then(() =&gt; {
  /* ... */
})</pre>
</div>
<p>In the production build, <code>.wasm</code> files smaller than <code>assetInlineLimit</code> will be inlined as base64 strings. Otherwise, they will be copied to the dist directory as an asset and fetched on-demand.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p><a href="https://github.com/WebAssembly/esm-integration" target="_blank" rel="noopener noreferrer">ES Module Integration Proposal for WebAssembly</a> is not currently supported. Use <a href="https://github.com/Menci/vite-plugin-wasm" target="_blank" rel="noopener noreferrer"><code>vite-plugin-wasm</code></a> or other community plugins to handle this.</p>
</div>
<h2 id="web-workers" tabindex="-1">Web Workers </h2>
<h3 id="import-with-constructors" tabindex="-1">Import with Constructors </h3>
<p>A web worker script can be imported using <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/Worker" target="_blank" rel="noopener noreferrer"><code>new Worker()</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker/SharedWorker" target="_blank" rel="noopener noreferrer"><code>new SharedWorker()</code></a>. Compared to the worker suffixes, this syntax leans closer to the standards and is the <strong>recommended</strong> way to create workers.</p>
<div class="language-ts">
<pre data-language="javascript">const worker = new Worker(new URL('./worker.js', import.meta.url))</pre>
</div>
<p>The worker constructor also accepts options, which can be used to create "module" workers:</p>
<div class="language-ts">
<pre data-language="javascript">const worker = new Worker(new URL('./worker.js', import.meta.url), {
  type: 'module'
})</pre>
</div>
<h3 id="import-with-query-suffixes" tabindex="-1">Import with Query Suffixes </h3>
<p>A web worker script can be directly imported by appending <code>?worker</code> or <code>?sharedworker</code> to the import request. The default export will be a custom worker constructor:</p>
<div class="language-js">
<pre data-language="javascript">import MyWorker from './worker?worker'

const worker = new MyWorker()</pre>
</div>
<p>The worker script can also use <code>import</code> statements instead of <code>importScripts()</code> - note during dev this relies on browser native support and currently only works in Chrome, but for the production build it is compiled away.</p>
<p>By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the <code>inline</code> query:</p>
<div class="language-js">
<pre data-language="javascript">import MyWorker from './worker?worker&amp;inline'</pre>
</div>
<p>If you wish to retrieve the worker as a URL, add the <code>url</code> query:</p>
<div class="language-js">
<pre data-language="javascript">import MyWorker from './worker?worker&amp;url'</pre>
</div>
<p>See <a href="../config/worker-options">Worker Options</a> for details on configuring the bundling of all workers.</p>
<h2 id="build-optimizations" tabindex="-1">Build Optimizations </h2>
<blockquote><p>Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.</p></blockquote>
<h3 id="css-code-splitting" tabindex="-1">CSS Code Splitting </h3>
<p>Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <code>&lt;link&gt;</code> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid <a href="https://en.wikipedia.org/wiki/Flash_of_unstyled_content#:~:text=A%20flash%20of%20unstyled%20content,before%20all%20information%20is%20retrieved." target="_blank" rel="noopener noreferrer">FOUC</a>.</p>
<p>If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting <a href="../config/build-options#build-csscodesplit"><code>build.cssCodeSplit</code></a> to <code>false</code>.</p>
<h3 id="preload-directives-generation" tabindex="-1">Preload Directives Generation </h3>
<p>Vite automatically generates <code>&lt;link rel="modulepreload"&gt;</code> directives for entry chunks and their direct imports in the built HTML.</p>
<h3 id="async-chunk-loading-optimization" tabindex="-1">Async Chunk Loading Optimization </h3>
<p>In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:</p>
<figure class="svg-image-root"><svg viewbox="0 0 1440 495" fill="none" xmlns="http://www.w3.org/2000/svg">  <text fill="#15505C" xml:space="preserve" style="white-space: pre" font-family="Inter" font-size="40" font-weight="600" letter-spacing="0em"><tspan x="105.5" y="278.545">Entry</tspan></text>  <text fill="#15505C" xml:space="preserve" style="white-space: pre" font-family="Inter" font-size="40" font-weight="600" letter-spacing="0em"><tspan x="594" y="85.0455">async chunk A</tspan></text>  <text fill="#15505C" xml:space="preserve" style="white-space: pre" font-family="Inter" font-size="40" font-weight="600" letter-spacing="0em"><tspan x="1091.5" y="254.045">common chunk C</tspan></text>  <text fill="#15505C" xml:space="preserve" style="white-space: pre" font-family="Inter" font-size="40" font-weight="600" letter-spacing="0em"><tspan x="595.5" y="439.045">async chunk B</tspan></text>   <text fill="#0B7285" xml:space="preserve" style="white-space: pre" font-family="Inter" font-size="35" letter-spacing="0em"><tspan x="172" y="98.7273">dynamic import</tspan></text> <text fill="#1864AB" xml:space="preserve" style="white-space: pre" font-family="Inter" font-size="35" letter-spacing="0em"><tspan x="1013" y="83.7273">direct import</tspan></text>   </svg> </figure><p>In the non-optimized scenarios, when async chunk <code>A</code> is imported, the browser will have to request and parse <code>A</code> before it can figure out that it also needs the common chunk <code>C</code>. This results in an extra network roundtrip:</p>
<div class="language-">
<pre data-language="javascript">Entry ---&gt; A ---&gt; C</pre>
</div>
<p>Vite automatically rewrites code-split dynamic import calls with a preload step so that when <code>A</code> is requested, <code>C</code> is fetched <strong>in parallel</strong>:</p>
<div class="language-">
<pre data-language="javascript">Entry ---&gt; (A + C)</pre>
</div>
<p>It is possible for <code>C</code> to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://vitejs.dev/guide/features" class="_attribution-link" target="_blank">https://vitejs.dev/guide/features</a>
  </p>
</div>
