<h1 id="javascript-api" tabindex="-1">JavaScript API </h1>
<p>Vite's JavaScript APIs are fully typed, and it's recommended to use TypeScript or enable JS type checking in VS Code to leverage the intellisense and validation.</p>
<h2 id="createserver" tabindex="-1">
<code>createServer</code> </h2>
<p><strong>Type Signature:</strong></p>
<div class="language-ts">
<pre data-language="javascript">async function createServer(inlineConfig?: InlineConfig): Promise&lt;ViteDevServer&gt;</pre>
</div>
<p><strong>Example Usage:</strong></p>
<div class="language-js">
<pre data-language="javascript">import { fileURLToPath } from 'url'
import { createServer } from 'vite'

const __dirname = fileURLToPath(new URL('.', import.meta.url))

;(async () =&gt; {
  const server = await createServer({
    // any valid user config options, plus `mode` and `configFile`
    configFile: false,
    root: __dirname,
    server: {
      port: 1337
    }
  })
  await server.listen()

  server.printUrls()
})()</pre>
</div>
<div class="tip custom-block">
<strong class="custom-block-title">NOTE</strong><p>When using <code>createServer</code> and <code>build</code> in the same Node.js process, both functions rely on <code>process.<wbr>env.</wbr></code><wbr><code>NODE_ENV</code> to work properly, which also depends on the <code>mode</code> config option. To prevent conflicting behavior, set <code>process.<wbr>env.</wbr></code><wbr><code>NODE_ENV</code> or the <code>mode</code> of the two APIs to <code>development</code>. Otherwise, you can spawn a child process to run the APIs separately.</wbr></wbr></p>
</div>
<h2 id="inlineconfig" tabindex="-1">
<code>InlineConfig</code> </h2>
<p>The <code>InlineConfig</code> interface extends <code>UserConfig</code> with additional properties:</p>
<ul>
<li>
<code>configFile</code>: specify config file to use. If not set, Vite will try to automatically resolve one from project root. Set to <code>false</code> to disable auto resolving.</li>
<li>
<code>envFile</code>: Set to <code>false</code> to disable <code>.env</code> files.</li>
</ul>
<h2 id="resolvedconfig" tabindex="-1">
<code>ResolvedConfig</code> </h2>
<p>The <code>ResolvedConfig</code> interface has all the same properties of a <code>UserConfig</code>, except most properties are resolved and non-undefined. It also contains utilities like:</p>
<ul>
<li>
<code>config.assetsInclude</code>: A function to check if an <code>id</code> is considered an asset.</li>
<li>
<code>config.logger</code>: Vite's internal logger object.</li>
</ul>
<h2 id="vitedevserver" tabindex="-1">
<code>ViteDevServer</code> </h2>
<div class="language-ts">
<pre data-language="javascript">interface ViteDevServer {
  /**
   * The resolved Vite config object.
   */
  config: ResolvedConfig
  /**
   * A connect app instance
   * - Can be used to attach custom middlewares to the dev server.
   * - Can also be used as the handler function of a custom http server
   *   or as a middleware in any connect-style Node.js frameworks.
   *
   * https://github.com/senchalabs/connect#use-middleware
   */
  middlewares: Connect.Server
  /**
   * Native Node http server instance.
   * Will be null in middleware mode.
   */
  httpServer: http.Server | null
  /**
   * Chokidar watcher instance.
   * https://github.com/paulmillr/chokidar#api
   */
  watcher: FSWatcher
  /**
   * Web socket server with `send(payload)` method.
   */
  ws: WebSocketServer
  /**
   * Rollup plugin container that can run plugin hooks on a given file.
   */
  pluginContainer: PluginContainer
  /**
   * Module graph that tracks the import relationships, url to file mapping
   * and hmr state.
   */
  moduleGraph: ModuleGraph
  /**
   * Programmatically resolve, load and transform a URL and get the result
   * without going through the http request pipeline.
   */
  transformRequest(
    url: string,
    options?: TransformOptions
  ): Promise&lt;TransformResult | null&gt;
  /**
   * Apply Vite built-in HTML transforms and any plugin HTML transforms.
   */
  transformIndexHtml(url: string, html: string): Promise&lt;string&gt;
  /**
   * Load a given URL as an instantiated module for SSR.
   */
  ssrLoadModule(
    url: string,
    options?: { fixStacktrace?: boolean }
  ): Promise&lt;Record&lt;string, any&gt;&gt;
  /**
   * Fix ssr error stacktrace.
   */
  ssrFixStacktrace(e: Error): void
  /**
   * Start the server.
   */
  listen(port?: number, isRestart?: boolean): Promise&lt;ViteDevServer&gt;
  /**
   * Restart the server.
   *
   * @param forceOptimize - force the optimizer to re-bundle, same as --force cli flag
   */
  restart(forceOptimize?: boolean): Promise&lt;void&gt;
  /**
   * Stop the server.
   */
  close(): Promise&lt;void&gt;
}</pre>
</div>
<h2 id="build" tabindex="-1">
<code>build</code> </h2>
<p><strong>Type Signature:</strong></p>
<div class="language-ts">
<pre data-language="javascript">async function build(
  inlineConfig?: InlineConfig
): Promise&lt;RollupOutput | RollupOutput[]&gt;</pre>
</div>
<p><strong>Example Usage:</strong></p>
<div class="language-js">
<pre data-language="javascript">import path from 'path'
import { fileURLToPath } from 'url'
import { build } from 'vite'

const __dirname = fileURLToPath(new URL('.', import.meta.url))

;(async () =&gt; {
  await build({
    root: path.resolve(__dirname, './project'),
    base: '/foo/',
    build: {
      rollupOptions: {
        // ...
      }
    }
  })
})()</pre>
</div>
<h2 id="preview" tabindex="-1">
<code>preview</code> </h2>
<p><strong>Type Signature:</strong></p>
<div class="language-ts">
<pre data-language="javascript">async function preview(inlineConfig?: InlineConfig): Promise&lt;PreviewServer&gt;</pre>
</div>
<p><strong>Example Usage:</strong></p>
<div class="language-js">
<pre data-language="javascript">import { preview } from 'vite'
;(async () =&gt; {
  const previewServer = await preview({
    // any valid user config options, plus `mode` and `configFile`
    preview: {
      port: 8080,
      open: true
    }
  })

  previewServer.printUrls()
})()</pre>
</div>
<h2 id="resolveconfig" tabindex="-1">
<code>resolveConfig</code> </h2>
<p><strong>Type Signature:</strong></p>
<div class="language-ts">
<pre data-language="javascript">async function resolveConfig(
  inlineConfig: InlineConfig,
  command: 'build' | 'serve',
  defaultMode = 'development'
): Promise&lt;ResolvedConfig&gt;</pre>
</div>
<p>The <code>command</code> value is <code>serve</code> in dev (in the cli <code>vite</code>, <code>vite dev</code>, and <code>vite serve</code> are aliases).</p>
<h2 id="mergeconfig" tabindex="-1">
<code>mergeConfig</code> </h2>
<p><strong>Type Signature:</strong></p>
<div class="language-ts">
<pre data-language="javascript">function mergeConfig(
  defaults: Record&lt;string, any&gt;,
  overrides: Record&lt;string, any&gt;,
  isRoot = true
): Record&lt;string, any&gt;</pre>
</div>
<p>Deeply merge two Vite configs. <code>isRoot</code> represents the level within the Vite config which is being merged. For example, set <code>false</code> if you're merging two <code>build</code> options.</p>
<h2 id="searchforworkspaceroot" tabindex="-1">
<code>searchForWorkspaceRoot</code> </h2>
<p><strong>Type Signature:</strong></p>
<div class="language-ts">
<pre data-language="javascript">function searchForWorkspaceRoot(
  current: string,
  root = searchForPackageRoot(current)
): string</pre>
</div>
<p><strong>Related:</strong> <a href="../config/server-options#server-fs-allow">server.fs.allow</a></p>
<p>Search for the root of the potential workspace if it meets the following conditions, otherwise it would fallback to <code>root</code>:</p>
<ul>
<li>contains <code>workspaces</code> field in <code>package.json</code>
</li>
<li>contains one of the following file <ul>
<li><code>lerna.json</code></li>
<li><code>pnpm-workspace.yaml</code></li>
</ul>
</li>
</ul>
<h2 id="loadenv" tabindex="-1">
<code>loadEnv</code> </h2>
<p><strong>Type Signature:</strong></p>
<div class="language-ts">
<pre data-language="javascript">function loadEnv(
  mode: string,
  envDir: string,
  prefixes: string | string[] = 'VITE_'
): Record&lt;string, string&gt;</pre>
</div>
<p><strong>Related:</strong> <a href="env-and-mode#env-files"><code>.env</code> Files</a></p>
<p>Load <code>.env</code> files within the <code>envDir</code>. By default only env variables prefixed with <code>VITE_</code> are loaded, unless <code>prefixes</code> is changed.</p>
<h2 id="normalizepath" tabindex="-1">
<code>normalizePath</code> </h2>
<p><strong>Type Signature:</strong></p>
<div class="language-ts">
<pre data-language="javascript">function normalizePath(id: string): string</pre>
</div>
<p><strong>Related:</strong> <a href="api-plugin#path-normalization">Path Normalization</a></p>
<p>Normalizes a path to interoperate between Vite plugins.</p>
<h2 id="transformwithesbuild" tabindex="-1">
<code>transformWithEsbuild</code> </h2>
<p><strong>Type Signature:</strong></p>
<div class="language-ts">
<pre data-language="javascript">async function transformWithEsbuild(
  code: string,
  filename: string,
  options?: EsbuildTransformOptions,
  inMap?: object
): Promise&lt;ESBuildTransformResult&gt;</pre>
</div>
<p>Transform JavaScript or TypeScript with esbuild. Useful for plugins that prefers matching Vite's internal esbuild transform.</p>
<h2 id="loadconfigfromfile" tabindex="-1">
<code>loadConfigFromFile</code> </h2>
<p><strong>Type Signature:</strong></p>
<div class="language-ts">
<pre data-language="javascript">async function loadConfigFromFile(
  configEnv: ConfigEnv,
  configFile?: string,
  configRoot: string = process.cwd(),
  logLevel?: LogLevel
): Promise&lt;{
  path: string
  config: UserConfig
  dependencies: string[]
} | null&gt;</pre>
</div>
<p>Load a Vite config file manually with esbuild.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://vitejs.dev/guide/api-javascript.html" class="_attribution-link" target="_blank">https://vitejs.dev/guide/api-javascript.html</a>
  </p>
</div>
