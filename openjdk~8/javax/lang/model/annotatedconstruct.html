<h1>Interface AnnotatedConstruct</h1>     <dl> <dt>All Known Subinterfaces:</dt> <dd>
<a href="type/arraytype">ArrayType</a>, <a href="type/declaredtype">DeclaredType</a>, <a href="element/element">Element</a>, <a href="type/errortype">ErrorType</a>, <a href="element/executableelement">ExecutableElement</a>, <a href="type/executabletype">ExecutableType</a>, <a href="type/intersectiontype">IntersectionType</a>, <a href="type/notype">NoType</a>, <a href="type/nulltype">NullType</a>, <a href="element/packageelement">PackageElement</a>, <a href="element/parameterizable">Parameterizable</a>, <a href="type/primitivetype">PrimitiveType</a>, <a href="element/qualifiednameable">QualifiedNameable</a>, <a href="type/referencetype">ReferenceType</a>, <a href="element/typeelement">TypeElement</a>, <a href="type/typemirror">TypeMirror</a>, <a href="element/typeparameterelement">TypeParameterElement</a>, <a href="type/typevariable">TypeVariable</a>, <a href="type/uniontype">UnionType</a>, <a href="element/variableelement">VariableElement</a>, <a href="type/wildcardtype">WildcardType</a>
</dd> </dl>   <pre data-language="java">public interface AnnotatedConstruct</pre> <div>
<p>Represents a construct that can be annotated. A construct is either an <a href="element/element">element</a> or a <a href="type/typemirror">type</a>. Annotations on an element are on a <em>declaration</em>, whereas annotations on a type are on a specific <em>use</em> of a type name. The terms <em>directly present</em>, <em>present</em>, <em>indirectly present</em>, and <em>associated </em> are used throughout this interface to describe precisely which annotations are returned by the methods defined herein. </p>
<p>In the definitions below, an annotation <i>A</i> has an annotation type <i>AT</i>. If <i>AT</i> is a repeatable annotation type, the type of the containing annotation is <i>ATC</i>. </p>
<p>Annotation <i>A</i> is <em>directly present</em> on a construct <i>C</i> if either: </p>
<ul> <li>
<i>A</i> is explicitly or implicitly declared as applying to the source code representation of <i>C</i>. <p>Typically, if exactly one annotation of type <i>AT</i> appears in the source code of representation of <i>C</i>, then <i>A</i> is explicitly declared as applying to <i>C</i>. If there are multiple annotations of type <i>AT</i> present on <i>C</i>, then if <i>AT</i> is repeatable annotation type, an annotation of type <i>ATC</i> is implicitly declared on <i>C</i>. </p>
</li>
<li> A representation of <i>A</i> appears in the executable output for <i>C</i>, such as the <code>RuntimeVisibleAnnotations</code> or <code>RuntimeVisibleParameterAnnotations</code> attributes of a class file. </li>
</ul> <p>An annotation <i>A</i> is <em>present</em> on a construct <i>C</i> if either: </p>
<ul> <li>
<i>A</i> is directly present on <i>C</i>. </li>
<li>No annotation of type <i>AT</i> is directly present on <i>C</i>, and <i>C</i> is a class and <i>AT</i> is inheritable and <i>A</i> is present on the superclass of <i>C</i>. </li>
</ul> An annotation <i>A</i> is <em>indirectly present</em> on a construct <i>C</i> if both: <ul> <li>
<i>AT</i> is a repeatable annotation type with a containing annotation type <i>ATC</i>. </li>
<li>An annotation of type <i>ATC</i> is directly present on <i>C</i> and <i>A</i> is an annotation included in the result of calling the <code>value</code> method of the directly present annotation of type <i>ATC</i>. </li>
</ul> An annotation <i>A</i> is <em>associated</em> with a construct <i>C</i> if either: <ul> <li> <i>A</i> is directly or indirectly present on <i>C</i>. </li>
<li> No annotation of type <i>AT</i> is directly or indirectly present on <i>C</i>, and <i>C</i> is a class, and <i>AT</i> is inheritable, and <i>A</i> is associated with the superclass of <i>C</i>. </li>
</ul>
</div> <dl> <dt>Since:</dt> <dd>1.8</dd>   </dl>       <h2 id="method.detail">Methods</h2>   <h3 id="getAnnotationMirrors--">getAnnotationMirrors</h3> <pre data-language="java">List&lt;? extends AnnotationMirror&gt; getAnnotationMirrors()</pre> <p>Returns the annotations that are <em>directly present</em> on this construct.</p> <dl> <dt>Returns:</dt> <dd>the annotations <em>directly present</em> on this construct; an empty list if there are none</dd> </dl>    <h3 id="getAnnotation-java.lang.Class-">getAnnotation</h3> <pre data-language="java">&lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationType)</pre> <div>
<p>Returns this construct's annotation of the specified type if such an annotation is <em>present</em>, else <code>null</code>. </p>
<p> The annotation returned by this method could contain an element whose value is of type <code>Class</code>. This value cannot be returned directly: information necessary to locate and load a class (such as the class loader to use) is not available, and the class might not be loadable at all. Attempting to read a <code>Class</code> object by invoking the relevant method on the returned annotation will result in a <a href="type/mirroredtypeexception"><code>MirroredTypeException</code></a>, from which the corresponding <a href="type/typemirror"><code>TypeMirror</code></a> may be extracted. Similarly, attempting to read a <code>Class[]</code>-valued element will result in a <a href="type/mirroredtypesexception"><code>MirroredTypesException</code></a>. </p>
<blockquote> <i>Note:</i> This method is unlike others in this and related interfaces. It operates on runtime reflective information — representations of annotation types currently loaded into the VM — rather than on the representations defined by and used throughout these interfaces. Consequently, calling methods on the returned annotation object can throw many of the exceptions that can be thrown when calling methods on an annotation object returned by core reflection. This method is intended for callers that are written to operate on a known, fixed set of annotation types. </blockquote>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>A</code> - the annotation type</dd> <dt>Parameters:</dt> <dd>
<code>annotationType</code> - the <code>Class</code> object corresponding to the annotation type</dd> <dt>Returns:</dt> <dd>this construct's annotation for the specified annotation type if present, else <code>null</code>
</dd> <dt>See Also:</dt> <dd>
<a href="annotatedconstruct#getAnnotationMirrors--"><code>getAnnotationMirrors()</code></a>, <a href="../../../java/lang/reflect/annotatedelement#getAnnotation-java.lang.Class-"><code>AnnotatedElement.getAnnotation(java.lang.Class&lt;T&gt;)</code></a>, <a href="../../../java/lang/enumconstantnotpresentexception"><code>EnumConstantNotPresentException</code></a>, <a href="../../../java/lang/annotation/annotationtypemismatchexception"><code>AnnotationTypeMismatchException</code></a>, <a href="../../../java/lang/annotation/incompleteannotationexception"><code>IncompleteAnnotationException</code></a>, <a href="type/mirroredtypeexception"><code>MirroredTypeException</code></a>, <a href="type/mirroredtypesexception"><code>MirroredTypesException</code></a>
</dd>   </dl>    <h3 id="getAnnotationsByType-java.lang.Class-">getAnnotationsByType</h3> <pre data-language="java">&lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationType)</pre> <div>
<p>Returns annotations that are <em>associated</em> with this construct. If there are no annotations associated with this construct, the return value is an array of length 0. The order of annotations which are directly or indirectly present on a construct <i>C</i> is computed as if indirectly present annotations on <i>C</i> are directly present on <i>C</i> in place of their container annotation, in the order in which they appear in the value element of the container annotation. The difference between this method and <a href="annotatedconstruct#getAnnotation-java.lang.Class-"><code>getAnnotation(Class)</code></a> is that this method detects if its argument is a <em>repeatable annotation type</em>, and if so, attempts to find one or more annotations of that type by "looking through" a container annotation. </p>
<p> The annotations returned by this method could contain an element whose value is of type <code>Class</code>. This value cannot be returned directly: information necessary to locate and load a class (such as the class loader to use) is not available, and the class might not be loadable at all. Attempting to read a <code>Class</code> object by invoking the relevant method on the returned annotation will result in a <a href="type/mirroredtypeexception"><code>MirroredTypeException</code></a>, from which the corresponding <a href="type/typemirror"><code>TypeMirror</code></a> may be extracted. Similarly, attempting to read a <code>Class[]</code>-valued element will result in a <a href="type/mirroredtypesexception"><code>MirroredTypesException</code></a>. </p>
<blockquote> <i>Note:</i> This method is unlike others in this and related interfaces. It operates on runtime reflective information — representations of annotation types currently loaded into the VM — rather than on the representations defined by and used throughout these interfaces. Consequently, calling methods on the returned annotation object can throw many of the exceptions that can be thrown when calling methods on an annotation object returned by core reflection. This method is intended for callers that are written to operate on a known, fixed set of annotation types. </blockquote>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>A</code> - the annotation type</dd> <dt>Parameters:</dt> <dd>
<code>annotationType</code> - the <code>Class</code> object corresponding to the annotation type</dd> <dt>Returns:</dt> <dd>this construct's annotations for the specified annotation type if present on this construct, else an empty array</dd> <dt>See Also:</dt> <dd>
<a href="annotatedconstruct#getAnnotationMirrors--"><code>getAnnotationMirrors()</code></a>, <a href="annotatedconstruct#getAnnotation-java.lang.Class-"><code>getAnnotation(Class)</code></a>, <a href="../../../java/lang/reflect/annotatedelement#getAnnotationsByType-java.lang.Class-"><code>AnnotatedElement.getAnnotationsByType(Class)</code></a>, <a href="../../../java/lang/enumconstantnotpresentexception"><code>EnumConstantNotPresentException</code></a>, <a href="../../../java/lang/annotation/annotationtypemismatchexception"><code>AnnotationTypeMismatchException</code></a>, <a href="../../../java/lang/annotation/incompleteannotationexception"><code>IncompleteAnnotationException</code></a>, <a href="type/mirroredtypeexception"><code>MirroredTypeException</code></a>, <a href="type/mirroredtypesexception"><code>MirroredTypesException</code></a>
</dd>   </dl>     <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993&ndash;2017, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    
  </p>
</div>
