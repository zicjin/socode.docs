<h1>Interface Types</h1>       <pre data-language="java">public interface Types</pre> <div>
<p>Utility methods for operating on types. </p>
<p><b>Compatibility Note:</b> Methods may be added to this interface in future releases of the platform.</p>
</div> <dl> <dt>Since:</dt> <dd>1.6</dd> <dt>See Also:</dt> <dd><a href="../../../annotation/processing/processingenvironment#getTypeUtils--"><code>ProcessingEnvironment.getTypeUtils()</code></a></dd> </dl>       <h2 id="method.detail">Methods</h2>   <h3 id="asElement-javax.lang.model.type.TypeMirror-">asElement</h3> <pre data-language="java">Element asElement(TypeMirror t)</pre> <p>Returns the element corresponding to a type. The type may be a <code>DeclaredType</code> or <code>TypeVariable</code>. Returns <code>null</code> if the type is not one with a corresponding element.</p> <dl> <dt>Parameters:</dt> <dd>
<code>t</code> - the type to map to an element</dd> <dt>Returns:</dt> <dd>the element corresponding to the given type</dd> </dl>    <h3 id="isSameType-javax.lang.model.type.TypeMirror-javax.lang.model.type.TypeMirror-">isSameType</h3> <pre data-language="java">boolean isSameType(TypeMirror t1,
                   TypeMirror t2)</pre> <div>
<p>Tests whether two <code>TypeMirror</code> objects represent the same type. </p>
<p>Caveat: if either of the arguments to this method represents a wildcard, this method will return false. As a consequence, a wildcard is not the same type as itself. This might be surprising at first, but makes sense once you consider that an example like this must be rejected by the compiler: </p>
<pre data-language="java">List&lt;?&gt; list = new ArrayList&lt;Object&gt;();
    list.add(list.get(0));</pre> <p>Since annotations are only meta-data associated with a type, the set of annotations on either argument is <em>not</em> taken into account when computing whether or not two <code>TypeMirror</code> objects are the same type. In particular, two <code>TypeMirror</code> objects can have different annotations and still be considered the same.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>t1</code> - the first type</dd> <dd>
<code>t2</code> - the second type</dd> <dt>Returns:</dt> <dd>
<code>true</code> if and only if the two types are the same</dd> </dl>    <h3 id="isSubtype-javax.lang.model.type.TypeMirror-javax.lang.model.type.TypeMirror-">isSubtype</h3> <pre data-language="java">boolean isSubtype(TypeMirror t1,
                  TypeMirror t2)</pre> <p>Tests whether one type is a subtype of another. Any type is considered to be a subtype of itself.</p> <dl> <dt>Parameters:</dt> <dd>
<code>t1</code> - the first type</dd> <dd>
<code>t2</code> - the second type</dd> <dt>Returns:</dt> <dd>
<code>true</code> if and only if the first type is a subtype of the second</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java/lang/illegalargumentexception">IllegalArgumentException</a></code> - if given an executable or package type</dd>   </dl>    <h3 id="isAssignable-javax.lang.model.type.TypeMirror-javax.lang.model.type.TypeMirror-">isAssignable</h3> <pre data-language="java">boolean isAssignable(TypeMirror t1,
                     TypeMirror t2)</pre> <p>Tests whether one type is assignable to another.</p> <dl> <dt>Parameters:</dt> <dd>
<code>t1</code> - the first type</dd> <dd>
<code>t2</code> - the second type</dd> <dt>Returns:</dt> <dd>
<code>true</code> if and only if the first type is assignable to the second</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java/lang/illegalargumentexception">IllegalArgumentException</a></code> - if given an executable or package type</dd>   </dl>    <h3 id="contains-javax.lang.model.type.TypeMirror-javax.lang.model.type.TypeMirror-">contains</h3> <pre data-language="java">boolean contains(TypeMirror t1,
                 TypeMirror t2)</pre> <p>Tests whether one type argument <i>contains</i> another.</p> <dl> <dt>Parameters:</dt> <dd>
<code>t1</code> - the first type</dd> <dd>
<code>t2</code> - the second type</dd> <dt>Returns:</dt> <dd>
<code>true</code> if and only if the first type contains the second</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java/lang/illegalargumentexception">IllegalArgumentException</a></code> - if given an executable or package type</dd>   </dl>    <h3 id="isSubsignature-javax.lang.model.type.ExecutableType-javax.lang.model.type.ExecutableType-">isSubsignature</h3> <pre data-language="java">boolean isSubsignature(ExecutableType m1,
                       ExecutableType m2)</pre> <p>Tests whether the signature of one method is a <i>subsignature</i> of another.</p> <dl> <dt>Parameters:</dt> <dd>
<code>m1</code> - the first method</dd> <dd>
<code>m2</code> - the second method</dd> <dt>Returns:</dt> <dd>
<code>true</code> if and only if the first signature is a subsignature of the second</dd>   </dl>    <h3 id="directSupertypes-javax.lang.model.type.TypeMirror-">directSupertypes</h3> <pre data-language="java">List&lt;? extends TypeMirror&gt; directSupertypes(TypeMirror t)</pre> <p>Returns the direct supertypes of a type. The interface types, if any, will appear last in the list.</p> <dl> <dt>Parameters:</dt> <dd>
<code>t</code> - the type being examined</dd> <dt>Returns:</dt> <dd>the direct supertypes, or an empty list if none</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java/lang/illegalargumentexception">IllegalArgumentException</a></code> - if given an executable or package type</dd> </dl>    <h3 id="erasure-javax.lang.model.type.TypeMirror-">erasure</h3> <pre data-language="java">TypeMirror erasure(TypeMirror t)</pre> <p>Returns the erasure of a type.</p> <dl> <dt>Parameters:</dt> <dd>
<code>t</code> - the type to be erased</dd> <dt>Returns:</dt> <dd>the erasure of the given type</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java/lang/illegalargumentexception">IllegalArgumentException</a></code> - if given a package type</dd>   </dl>    <h3 id="boxedClass-javax.lang.model.type.PrimitiveType-">boxedClass</h3> <pre data-language="java">TypeElement boxedClass(PrimitiveType p)</pre> <p>Returns the class of a boxed value of a given primitive type. That is, <i>boxing conversion</i> is applied.</p> <dl> <dt>Parameters:</dt> <dd>
<code>p</code> - the primitive type to be converted</dd> <dt>Returns:</dt> <dd>the class of a boxed value of type <code>p</code>
</dd>   </dl>    <h3 id="unboxedType-javax.lang.model.type.TypeMirror-">unboxedType</h3> <pre data-language="java">PrimitiveType unboxedType(TypeMirror t)</pre> <p>Returns the type (a primitive type) of unboxed values of a given type. That is, <i>unboxing conversion</i> is applied.</p> <dl> <dt>Parameters:</dt> <dd>
<code>t</code> - the type to be unboxed</dd> <dt>Returns:</dt> <dd>the type of an unboxed value of type <code>t</code>
</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java/lang/illegalargumentexception">IllegalArgumentException</a></code> - if the given type has no unboxing conversion</dd>   </dl>    <h3 id="capture-javax.lang.model.type.TypeMirror-">capture</h3> <pre data-language="java">TypeMirror capture(TypeMirror t)</pre> <p>Applies capture conversion to a type.</p> <dl> <dt>Parameters:</dt> <dd>
<code>t</code> - the type to be converted</dd> <dt>Returns:</dt> <dd>the result of applying capture conversion</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java/lang/illegalargumentexception">IllegalArgumentException</a></code> - if given an executable or package type</dd>   </dl>    <h3 id="getPrimitiveType-javax.lang.model.type.TypeKind-">getPrimitiveType</h3> <pre data-language="java">PrimitiveType getPrimitiveType(TypeKind kind)</pre> <p>Returns a primitive type.</p> <dl> <dt>Parameters:</dt> <dd>
<code>kind</code> - the kind of primitive type to return</dd> <dt>Returns:</dt> <dd>a primitive type</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java/lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>kind</code> is not a primitive kind</dd> </dl>    <h3 id="getNullType--">getNullType</h3> <pre data-language="java">NullType getNullType()</pre> <p>Returns the null type. This is the type of <code>null</code>.</p> <dl> <dt>Returns:</dt> <dd>the null type</dd> </dl>    <h3 id="getNoType-javax.lang.model.type.TypeKind-">getNoType</h3> <pre data-language="java">NoType getNoType(TypeKind kind)</pre> <p>Returns a pseudo-type used where no actual type is appropriate. The kind of type to return may be either <a href="../type/typekind#VOID"><code>VOID</code></a> or <a href="../type/typekind#NONE"><code>NONE</code></a>. For packages, use <a href="elements#getPackageElement-java.lang.CharSequence-"><code>Elements.getPackageElement(CharSequence)</code></a><code>.asType()</code> instead.</p> <dl> <dt>Parameters:</dt> <dd>
<code>kind</code> - the kind of type to return</dd> <dt>Returns:</dt> <dd>a pseudo-type of kind <code>VOID</code> or <code>NONE</code>
</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java/lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>kind</code> is not valid</dd> </dl>    <h3 id="getArrayType-javax.lang.model.type.TypeMirror-">getArrayType</h3> <pre data-language="java">ArrayType getArrayType(TypeMirror componentType)</pre> <p>Returns an array type with the specified component type.</p> <dl> <dt>Parameters:</dt> <dd>
<code>componentType</code> - the component type</dd> <dt>Returns:</dt> <dd>an array type with the specified component type.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java/lang/illegalargumentexception">IllegalArgumentException</a></code> - if the component type is not valid for an array</dd> </dl>    <h3 id="getWildcardType-javax.lang.model.type.TypeMirror-javax.lang.model.type.TypeMirror-">getWildcardType</h3> <pre data-language="java">WildcardType getWildcardType(TypeMirror extendsBound,
                             TypeMirror superBound)</pre> <p>Returns a new wildcard type argument. Either of the wildcard's bounds may be specified, or neither, but not both.</p> <dl> <dt>Parameters:</dt> <dd>
<code>extendsBound</code> - the extends (upper) bound, or <code>null</code> if none</dd> <dd>
<code>superBound</code> - the super (lower) bound, or <code>null</code> if none</dd> <dt>Returns:</dt> <dd>a new wildcard</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java/lang/illegalargumentexception">IllegalArgumentException</a></code> - if bounds are not valid</dd> </dl>    <h3 id="getDeclaredType-javax.lang.model.element.TypeElement-javax.lang.model.type.TypeMirror...-">getDeclaredType</h3> <pre data-language="java">DeclaredType getDeclaredType(TypeElement typeElem,
                             TypeMirror... typeArgs)</pre> <div>
<p>Returns the type corresponding to a type element and actual type arguments. Given the type element for <code>Set</code> and the type mirror for <code>String</code>, for example, this method may be used to get the parameterized type <code>Set&lt;String&gt;</code>. </p>
<p> The number of type arguments must either equal the number of the type element's formal type parameters, or must be zero. If zero, and if the type element is generic, then the type element's raw type is returned. </p>
<p> If a parameterized type is being returned, its type element must not be contained within a generic outer class. The parameterized type <code>Outer&lt;String&gt;.Inner&lt;Number&gt;</code>, for example, may be constructed by first using this method to get the type <code>Outer&lt;String&gt;</code>, and then invoking <a href="types#getDeclaredType-javax.lang.model.type.DeclaredType-javax.lang.model.element.TypeElement-javax.lang.model.type.TypeMirror...-"><code>getDeclaredType(DeclaredType, TypeElement, TypeMirror...)</code></a>.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>typeElem</code> - the type element</dd> <dd>
<code>typeArgs</code> - the actual type arguments</dd> <dt>Returns:</dt> <dd>the type corresponding to the type element and actual type arguments</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java/lang/illegalargumentexception">IllegalArgumentException</a></code> - if too many or too few type arguments are given, or if an inappropriate type argument or type element is provided</dd> </dl>    <h3 id="getDeclaredType-javax.lang.model.type.DeclaredType-javax.lang.model.element.TypeElement-javax.lang.model.type.TypeMirror...-">getDeclaredType</h3> <pre data-language="java">DeclaredType getDeclaredType(DeclaredType containing,
                             TypeElement typeElem,
                             TypeMirror... typeArgs)</pre> <div>
<p>Returns the type corresponding to a type element and actual type arguments, given a <a href="../type/declaredtype#getEnclosingType--">containing type</a> of which it is a member. The parameterized type <code>Outer&lt;String&gt;.Inner&lt;Number&gt;</code>, for example, may be constructed by first using <a href="types#getDeclaredType-javax.lang.model.element.TypeElement-javax.lang.model.type.TypeMirror...-"><code>getDeclaredType(TypeElement, TypeMirror...)</code></a> to get the type <code>Outer&lt;String&gt;</code>, and then invoking this method. </p>
<p> If the containing type is a parameterized type, the number of type arguments must equal the number of <code>typeElem</code>'s formal type parameters. If it is not parameterized or if it is <code>null</code>, this method is equivalent to <code>getDeclaredType(typeElem, typeArgs)</code>.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>containing</code> - the containing type, or <code>null</code> if none</dd> <dd>
<code>typeElem</code> - the type element</dd> <dd>
<code>typeArgs</code> - the actual type arguments</dd> <dt>Returns:</dt> <dd>the type corresponding to the type element and actual type arguments, contained within the given type</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java/lang/illegalargumentexception">IllegalArgumentException</a></code> - if too many or too few type arguments are given, or if an inappropriate type argument, type element, or containing type is provided</dd> </dl>    <h3 id="asMemberOf-javax.lang.model.type.DeclaredType-javax.lang.model.element.Element-">asMemberOf</h3> <pre data-language="java">TypeMirror asMemberOf(DeclaredType containing,
                      Element element)</pre> <p>Returns the type of an element when that element is viewed as a member of, or otherwise directly contained by, a given type. For example, when viewed as a member of the parameterized type <code>Set&lt;String&gt;</code>, the <code>Set.add</code> method is an <code>ExecutableType</code> whose parameter is of type <code>String</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>containing</code> - the containing type</dd> <dd>
<code>element</code> - the element</dd> <dt>Returns:</dt> <dd>the type of the element as viewed from the containing type</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java/lang/illegalargumentexception">IllegalArgumentException</a></code> - if the element is not a valid one for the given type</dd> </dl>     <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993&ndash;2017, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    
  </p>
</div>
