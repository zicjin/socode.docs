<h1>Class Policy</h1>   <ul class="inheritance"> <li><a href="../lang/object">java.lang.Object</a></li> <li> <ul class="inheritance"> <li>java.security.Policy</li> </ul> </li> </ul>     <pre data-language="java">public abstract class Policy
extends Object</pre> <div>
<p>A Policy object is responsible for determining whether code executing in the Java runtime environment has permission to perform a security-sensitive operation. </p>
<p> There is only one Policy object installed in the runtime at any given time. A Policy object can be installed by calling the <code>setPolicy</code> method. The installed Policy object can be obtained by calling the <code>getPolicy</code> method. </p>
<p> If no Policy object has been installed in the runtime, a call to <code>getPolicy</code> installs an instance of the default Policy implementation (a default subclass implementation of this abstract class). The default Policy implementation can be changed by setting the value of the <code>policy.provider</code> security property to the fully qualified name of the desired Policy subclass implementation. </p>
<p> Application code can directly subclass Policy to provide a custom implementation. In addition, an instance of a Policy object can be constructed by invoking one of the <code>getInstance</code> factory methods with a standard type. The default policy type is "JavaPolicy". </p>
<p> Once a Policy instance has been installed (either by default, or by calling <code>setPolicy</code>), the Java runtime invokes its <code>implies</code> method when it needs to determine whether executing code (encapsulated in a ProtectionDomain) can perform SecurityManager-protected operations. How a Policy object retrieves its policy data is up to the Policy implementation itself. The policy data may be stored, for example, in a flat ASCII file, in a serialized binary file of the Policy class, or in a database. </p>
<p> The <code>refresh</code> method causes the policy object to refresh/reload its data. This operation is implementation-dependent. For example, if the policy object stores its data in configuration files, calling <code>refresh</code> will cause it to re-read the configuration policy files. If a refresh operation is not supported, this method does nothing. Note that refreshed policy may not have an effect on classes in a particular ProtectionDomain. This is dependent on the Policy provider's implementation of the <code>implies</code> method and its PermissionCollection caching strategy.</p>
</div> <dl> <dt>See Also:</dt> <dd>
<a href="provider"><code>Provider</code></a>, <a href="protectiondomain"><code>ProtectionDomain</code></a>, <a href="permission"><code>Permission</code></a>, <a href="security"><code>security properties</code></a>
</dd> </dl>       <h2 id="nested.class.summary">Nested Classes</h2> <table> <caption>Nested Classes </caption> <tr> <th scope="col">Modifier and Type</th> <th scope="col">Class and Description</th> </tr> <tr> <td><code>static interface </code></td> <td>
<code><a href="policy.parameters">Policy.Parameters</a></code> <p>This represents a marker interface for Policy parameters.</p> </td> </tr> </table>    <h2 id="field.detail">Fields</h2>   <h3 id="UNSUPPORTED_EMPTY_COLLECTION">UNSUPPORTED_EMPTY_COLLECTION</h3> <pre data-language="java">public static final PermissionCollection UNSUPPORTED_EMPTY_COLLECTION</pre> <p>A read-only empty PermissionCollection instance.</p> <dl> <dt>Since:</dt> <dd>1.6</dd> </dl>     <h2 id="constructor.detail">Constructors</h2>   <h3 id="Policy--">Policy</h3> <pre data-language="java">public Policy()</pre>     <h2 id="method.detail">Methods</h2>   <h3 id="getPolicy--">getPolicy</h3> <pre data-language="java">public static Policy getPolicy()</pre> <p>Returns the installed Policy object. This value should not be cached, as it may be changed by a call to <code>setPolicy</code>. This method first calls <code>SecurityManager.checkPermission</code> with a <code>SecurityPermission("getPolicy")</code> permission to ensure it's ok to get the Policy object.</p> <dl> <dt>Returns:</dt> <dd>the installed Policy.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/securityexception">SecurityException</a></code> - if a security manager exists and its <code>checkPermission</code> method doesn't allow getting the Policy object.</dd> <dt>See Also:</dt> <dd>
<a href="../lang/securitymanager#checkPermission-java.security.Permission-"><code>SecurityManager.checkPermission(Permission)</code></a>, <a href="policy#setPolicy-java.security.Policy-"><code>setPolicy(java.security.Policy)</code></a>
</dd> </dl>    <h3 id="setPolicy-java.security.Policy-">setPolicy</h3> <pre data-language="java">public static void setPolicy(Policy p)</pre> <p>Sets the system-wide Policy object. This method first calls <code>SecurityManager.checkPermission</code> with a <code>SecurityPermission("setPolicy")</code> permission to ensure it's ok to set the Policy.</p> <dl> <dt>Parameters:</dt> <dd>
<code>p</code> - the new system Policy object.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/securityexception">SecurityException</a></code> - if a security manager exists and its <code>checkPermission</code> method doesn't allow setting the Policy.</dd> <dt>See Also:</dt> <dd>
<a href="../lang/securitymanager#checkPermission-java.security.Permission-"><code>SecurityManager.checkPermission(Permission)</code></a>, <a href="policy#getPolicy--"><code>getPolicy()</code></a>
</dd> </dl>    <h3 id="getInstance-java.lang.String-java.security.Policy.Parameters-">getInstance</h3> <pre data-language="java">public static Policy getInstance(String type,
                                 Policy.Parameters params)
                          throws NoSuchAlgorithmException</pre> <div>
<p>Returns a Policy object of the specified type. </p>
<p> This method traverses the list of registered security providers, starting with the most preferred Provider. A new Policy object encapsulating the PolicySpi implementation from the first Provider that supports the specified type is returned. </p>
<p> Note that the list of registered providers may be retrieved via the <a href="security#getProviders--"><code>Security.getProviders()</code></a> method.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>type</code> - the specified Policy type. See the Policy section in the <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Policy"> Java Cryptography Architecture Standard Algorithm Name Documentation</a> for a list of standard Policy types.</dd> <dd>
<code>params</code> - parameters for the Policy, which may be null.</dd> <dt>Returns:</dt> <dd>the new Policy object.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/securityexception">SecurityException</a></code> - if the caller does not have permission to get a Policy instance for the specified type.</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the specified type is null.</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if the specified parameters are not understood by the PolicySpi implementation from the selected Provider.</dd> <dd>
<code><a href="nosuchalgorithmexception">NoSuchAlgorithmException</a></code> - if no Provider supports a PolicySpi implementation for the specified type.</dd> <dt>Since:</dt> <dd>1.6</dd> <dt>See Also:</dt> <dd><a href="provider"><code>Provider</code></a></dd> </dl>    <h3 id="getInstance-java.lang.String-java.security.Policy.Parameters-java.lang.String-">getInstance</h3> <pre data-language="java">public static Policy getInstance(String type,
                                 Policy.Parameters params,
                                 String provider)
                          throws NoSuchProviderException,
                                 NoSuchAlgorithmException</pre> <div>
<p>Returns a Policy object of the specified type. </p>
<p> A new Policy object encapsulating the PolicySpi implementation from the specified provider is returned. The specified provider must be registered in the provider list. </p>
<p> Note that the list of registered providers may be retrieved via the <a href="security#getProviders--"><code>Security.getProviders()</code></a> method.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>type</code> - the specified Policy type. See the Policy section in the <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Policy"> Java Cryptography Architecture Standard Algorithm Name Documentation</a> for a list of standard Policy types.</dd> <dd>
<code>params</code> - parameters for the Policy, which may be null.</dd> <dd>
<code>provider</code> - the provider.</dd> <dt>Returns:</dt> <dd>the new Policy object.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/securityexception">SecurityException</a></code> - if the caller does not have permission to get a Policy instance for the specified type.</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the specified type is null.</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if the specified provider is null or empty, or if the specified parameters are not understood by the PolicySpi implementation from the specified provider.</dd> <dd>
<code><a href="nosuchproviderexception">NoSuchProviderException</a></code> - if the specified provider is not registered in the security provider list.</dd> <dd>
<code><a href="nosuchalgorithmexception">NoSuchAlgorithmException</a></code> - if the specified provider does not support a PolicySpi implementation for the specified type.</dd> <dt>Since:</dt> <dd>1.6</dd> <dt>See Also:</dt> <dd><a href="provider"><code>Provider</code></a></dd> </dl>    <h3 id="getInstance-java.lang.String-java.security.Policy.Parameters-java.security.Provider-">getInstance</h3> <pre data-language="java">public static Policy getInstance(String type,
                                 Policy.Parameters params,
                                 Provider provider)
                          throws NoSuchAlgorithmException</pre> <div>
<p>Returns a Policy object of the specified type. </p>
<p> A new Policy object encapsulating the PolicySpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>type</code> - the specified Policy type. See the Policy section in the <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#Policy"> Java Cryptography Architecture Standard Algorithm Name Documentation</a> for a list of standard Policy types.</dd> <dd>
<code>params</code> - parameters for the Policy, which may be null.</dd> <dd>
<code>provider</code> - the Provider.</dd> <dt>Returns:</dt> <dd>the new Policy object.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/securityexception">SecurityException</a></code> - if the caller does not have permission to get a Policy instance for the specified type.</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the specified type is null.</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if the specified Provider is null, or if the specified parameters are not understood by the PolicySpi implementation from the specified Provider.</dd> <dd>
<code><a href="nosuchalgorithmexception">NoSuchAlgorithmException</a></code> - if the specified Provider does not support a PolicySpi implementation for the specified type.</dd> <dt>Since:</dt> <dd>1.6</dd> <dt>See Also:</dt> <dd><a href="provider"><code>Provider</code></a></dd> </dl>    <h3 id="getProvider--">getProvider</h3> <pre data-language="java">public Provider getProvider()</pre> <div>
<p>Return the Provider of this Policy. </p>
<p> This Policy instance will only have a Provider if it was obtained via a call to <code>Policy.getInstance</code>. Otherwise this method returns null.</p>
</div> <dl> <dt>Returns:</dt> <dd>the Provider of this Policy, or null.</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="getType--">getType</h3> <pre data-language="java">public String getType()</pre> <div>
<p>Return the type of this Policy. </p>
<p> This Policy instance will only have a type if it was obtained via a call to <code>Policy.getInstance</code>. Otherwise this method returns null.</p>
</div> <dl> <dt>Returns:</dt> <dd>the type of this Policy, or null.</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="getParameters--">getParameters</h3> <pre data-language="java">public Policy.Parameters getParameters()</pre> <div>
<p>Return Policy parameters. </p>
<p> This Policy instance will only have parameters if it was obtained via a call to <code>Policy.getInstance</code>. Otherwise this method returns null.</p>
</div> <dl> <dt>Returns:</dt> <dd>Policy parameters, or null.</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="getPermissions-java.security.CodeSource-">getPermissions</h3> <pre data-language="java">public PermissionCollection getPermissions(CodeSource codesource)</pre> <div>
<p>Return a PermissionCollection object containing the set of permissions granted to the specified CodeSource. </p>
<p> Applications are discouraged from calling this method since this operation may not be supported by all policy implementations. Applications should solely rely on the <code>implies</code> method to perform policy checks. If an application absolutely must call a getPermissions method, it should call <code>getPermissions(ProtectionDomain)</code>. </p>
<p> The default implementation of this method returns Policy.UNSUPPORTED_EMPTY_COLLECTION. This method can be overridden if the policy implementation can return a set of permissions granted to a CodeSource.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>codesource</code> - the CodeSource to which the returned PermissionCollection has been granted.</dd> <dt>Returns:</dt> <dd>a set of permissions granted to the specified CodeSource. If this operation is supported, the returned set of permissions must be a new mutable instance and it must support heterogeneous Permission types. If this operation is not supported, Policy.UNSUPPORTED_EMPTY_COLLECTION is returned.</dd> </dl>    <h3 id="getPermissions-java.security.ProtectionDomain-">getPermissions</h3> <pre data-language="java">public PermissionCollection getPermissions(ProtectionDomain domain)</pre> <div>
<p>Return a PermissionCollection object containing the set of permissions granted to the specified ProtectionDomain. </p>
<p> Applications are discouraged from calling this method since this operation may not be supported by all policy implementations. Applications should rely on the <code>implies</code> method to perform policy checks. </p>
<p> The default implementation of this method first retrieves the permissions returned via <code>getPermissions(CodeSource)</code> (the CodeSource is taken from the specified ProtectionDomain), as well as the permissions located inside the specified ProtectionDomain. All of these permissions are then combined and returned in a new PermissionCollection object. If <code>getPermissions(CodeSource)</code> returns Policy.UNSUPPORTED_EMPTY_COLLECTION, then this method returns the permissions contained inside the specified ProtectionDomain in a new PermissionCollection object. </p>
<p> This method can be overridden if the policy implementation supports returning a set of permissions granted to a ProtectionDomain.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>domain</code> - the ProtectionDomain to which the returned PermissionCollection has been granted.</dd> <dt>Returns:</dt> <dd>a set of permissions granted to the specified ProtectionDomain. If this operation is supported, the returned set of permissions must be a new mutable instance and it must support heterogeneous Permission types. If this operation is not supported, Policy.UNSUPPORTED_EMPTY_COLLECTION is returned.</dd> <dt>Since:</dt> <dd>1.4</dd> </dl>    <h3 id="implies-java.security.ProtectionDomain-java.security.Permission-">implies</h3> <pre data-language="java">public boolean implies(ProtectionDomain domain,
                       Permission permission)</pre> <p>Evaluates the global policy for the permissions granted to the ProtectionDomain and tests whether the permission is granted.</p> <dl> <dt>Parameters:</dt> <dd>
<code>domain</code> - the ProtectionDomain to test</dd> <dd>
<code>permission</code> - the Permission object to be tested for implication.</dd> <dt>Returns:</dt> <dd>true if "permission" is a proper subset of a permission granted to this ProtectionDomain.</dd> <dt>Since:</dt> <dd>1.4</dd> <dt>See Also:</dt> <dd><a href="protectiondomain"><code>ProtectionDomain</code></a></dd> </dl>    <h3 id="refresh--">refresh</h3> <pre data-language="java">public void refresh()</pre> <div>
<p>Refreshes/reloads the policy configuration. The behavior of this method depends on the implementation. For example, calling <code>refresh</code> on a file-based policy will cause the file to be re-read. </p>
<p> The default implementation of this method does nothing. This method should be overridden if a refresh operation is supported by the policy implementation.</p>
</div>     <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993&ndash;2017, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    
  </p>
</div>
