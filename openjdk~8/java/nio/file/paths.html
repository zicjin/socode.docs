<h1>Class Paths</h1>   <ul class="inheritance"> <li><a href="../../lang/object">java.lang.Object</a></li> <li> <ul class="inheritance"> <li>java.nio.file.Paths</li> </ul> </li> </ul>     <pre data-language="java">public final class Paths
extends Object</pre> <p>This class consists exclusively of static methods that return a <a href="path"><code>Path</code></a> by converting a path string or <a href="../../net/uri"><code>URI</code></a>.</p> <dl> <dt>Since:</dt> <dd>1.7</dd> </dl>       <h2 id="method.detail">Methods</h2>   <h3 id="get-java.lang.String-java.lang.String...-">get</h3> <pre data-language="java">public static Path get(String first,
                       String... more)</pre> <div>
<p>Converts a path string, or a sequence of strings that when joined form a path string, to a <code>Path</code>. If <code>more</code> does not specify any elements then the value of the <code>first</code> parameter is the path string to convert. If <code>more</code> specifies one or more elements then each non-empty string, including <code>first</code>, is considered to be a sequence of name elements (see <a href="path"><code>Path</code></a>) and is joined to form a path string. The details as to how the Strings are joined is provider specific but typically they will be joined using the <a href="filesystem#getSeparator--"><code>name-separator</code></a> as the separator. For example, if the name separator is "<code>/</code>" and <code>getPath("/foo","bar","gus")</code> is invoked, then the path string <code>"/foo/bar/gus"</code> is converted to a <code>Path</code>. A <code>Path</code> representing an empty path is returned if <code>first</code> is the empty string and <code>more</code> does not contain any non-empty strings. </p>
<p> The <code>Path</code> is obtained by invoking the <a href="filesystem#getPath-java.lang.String-java.lang.String...-"><code>getPath</code></a> method of the <a href="filesystems#getDefault--"><code>default</code></a> <a href="filesystem"><code>FileSystem</code></a>. </p>
<p> Note that while this method is very convenient, using it will imply an assumed reference to the default <code>FileSystem</code> and limit the utility of the calling code. Hence it should not be used in library code intended for flexible reuse. A more flexible alternative is to use an existing <code>Path</code> instance as an anchor, such as: </p>
<pre data-language="java">Path dir = ...
     Path path = dir.resolve("file");</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>first</code> - the path string or initial part of the path string</dd> <dd>
<code>more</code> - additional strings to be joined to form the path string</dd> <dt>Returns:</dt> <dd>the resulting <code>Path</code>
</dd> <dt>Throws:</dt> <dd>
<code><a href="invalidpathexception">InvalidPathException</a></code> - if the path string cannot be converted to a <code>Path</code>
</dd> <dt>See Also:</dt> <dd><a href="filesystem#getPath-java.lang.String-java.lang.String...-"><code>FileSystem.getPath(java.lang.String, java.lang.String...)</code></a></dd> </dl>    <h3 id="get-java.net.URI-">get</h3> <pre data-language="java">public static Path get(URI uri)</pre> <div>
<p>Converts the given URI to a <a href="path"><code>Path</code></a> object. </p>
<p> This method iterates over the <a href="spi/filesystemprovider#installedProviders--"><code>installed</code></a> providers to locate the provider that is identified by the URI <a href="../../net/uri#getScheme--"><code>scheme</code></a> of the given URI. URI schemes are compared without regard to case. If the provider is found then its <a href="spi/filesystemprovider#getPath-java.net.URI-"><code>getPath</code></a> method is invoked to convert the URI. </p>
<p> In the case of the default provider, identified by the URI scheme "file", the given URI has a non-empty path component, and undefined query and fragment components. Whether the authority component may be present is platform specific. The returned <code>Path</code> is associated with the <a href="filesystems#getDefault--"><code>default</code></a> file system. </p>
<p> The default provider provides a similar <em>round-trip</em> guarantee to the <a href="../../io/file"><code>File</code></a> class. For a given <code>Path</code> <i>p</i> it is guaranteed that </p>
<pre data-language="java">Paths.get(p.toUri()).equals( p.toAbsolutePath())</pre> so long as the original <code>Path</code>, the <code>URI</code>, and the new <code>Path</code> are all created in (possibly different invocations of) the same Java virtual machine. Whether other providers make any guarantees is provider specific and therefore unspecified.</div> <dl> <dt>Parameters:</dt> <dd>
<code>uri</code> - the URI to convert</dd> <dt>Returns:</dt> <dd>the resulting <code>Path</code>
</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/illegalargumentexception">IllegalArgumentException</a></code> - if preconditions on the <code>uri</code> parameter do not hold. The format of the URI is provider specific.</dd> <dd>
<code><a href="filesystemnotfoundexception">FileSystemNotFoundException</a></code> - The file system, identified by the URI, does not exist and cannot be created automatically, or the provider identified by the URI's scheme component is not installed</dd> <dd>
<code><a href="../../lang/securityexception">SecurityException</a></code> - if a security manager is installed and it denies an unspecified permission to access the file system</dd> </dl>     <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993&ndash;2017, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    
  </p>
</div>
