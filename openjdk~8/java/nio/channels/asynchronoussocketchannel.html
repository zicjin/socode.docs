<h1>Class AsynchronousSocketChannel</h1>   <ul class="inheritance"> <li><a href="../../lang/object">java.lang.Object</a></li> <li> <ul class="inheritance"> <li>java.nio.channels.AsynchronousSocketChannel</li> </ul> </li> </ul>   <dl> <dt>All Implemented Interfaces:</dt> <dd>
<a href="../../io/closeable">Closeable</a>, <a href="../../lang/autocloseable">AutoCloseable</a>, <a href="asynchronousbytechannel">AsynchronousByteChannel</a>, <a href="asynchronouschannel">AsynchronousChannel</a>, <a href="channel">Channel</a>, <a href="networkchannel">NetworkChannel</a>
</dd> </dl>   <pre data-language="java">public abstract class AsynchronousSocketChannel
extends Object
implements AsynchronousByteChannel, NetworkChannel</pre> <div>
<p>An asynchronous channel for stream-oriented connecting sockets. </p>
<p> Asynchronous socket channels are created in one of two ways. A newly-created <code>AsynchronousSocketChannel</code> is created by invoking one of the <a href="asynchronoussocketchannel#open-java.nio.channels.AsynchronousChannelGroup-"><code>open</code></a> methods defined by this class. A newly-created channel is open but not yet connected. A connected <code>AsynchronousSocketChannel</code> is created when a connection is made to the socket of an <a href="asynchronousserversocketchannel"><code>AsynchronousServerSocketChannel</code></a>. It is not possible to create an asynchronous socket channel for an arbitrary, pre-existing <a href="../../net/socket"><code>socket</code></a>. </p>
<p> A newly-created channel is connected by invoking its <a href="asynchronoussocketchannel#connect-java.net.SocketAddress-A-java.nio.channels.CompletionHandler-"><code>connect</code></a> method; once connected, a channel remains connected until it is closed. Whether or not a socket channel is connected may be determined by invoking its <a href="asynchronoussocketchannel#getRemoteAddress--"><code>getRemoteAddress</code></a> method. An attempt to invoke an I/O operation upon an unconnected channel will cause a <a href="notyetconnectedexception"><code>NotYetConnectedException</code></a> to be thrown. </p>
<p> Channels of this type are safe for use by multiple concurrent threads. They support concurrent reading and writing, though at most one read operation and one write operation can be outstanding at any time. If a thread initiates a read operation before a previous read operation has completed then a <a href="readpendingexception"><code>ReadPendingException</code></a> will be thrown. Similarly, an attempt to initiate a write operation before a previous write has completed will throw a <a href="writependingexception"><code>WritePendingException</code></a>. </p>
<p> Socket options are configured using the <a href="asynchronoussocketchannel#setOption-java.net.SocketOption-T-"><code>setOption</code></a> method. Asynchronous socket channels support the following options: </p>
<table> <tr> <th>Option Name</th> <th>Description</th> </tr> <tr> <td> <a href="../../net/standardsocketoptions#SO_SNDBUF"><code>SO_SNDBUF</code></a> </td> <td> The size of the socket send buffer </td> </tr> <tr> <td> <a href="../../net/standardsocketoptions#SO_RCVBUF"><code>SO_RCVBUF</code></a> </td> <td> The size of the socket receive buffer </td> </tr> <tr> <td> <a href="../../net/standardsocketoptions#SO_KEEPALIVE"><code>SO_KEEPALIVE</code></a> </td> <td> Keep connection alive </td> </tr> <tr> <td> <a href="../../net/standardsocketoptions#SO_REUSEADDR"><code>SO_REUSEADDR</code></a> </td> <td> Re-use address </td> </tr> <tr> <td> <a href="../../net/standardsocketoptions#TCP_NODELAY"><code>TCP_NODELAY</code></a> </td> <td> Disable the Nagle algorithm </td> </tr> </table> Additional (implementation specific) options may also be supported. <h2>Timeouts</h2> <p> The <a href="asynchronoussocketchannel#read-java.nio.ByteBuffer-long-java.util.concurrent.TimeUnit-A-java.nio.channels.CompletionHandler-"><code>read</code></a> and <a href="asynchronoussocketchannel#write-java.nio.ByteBuffer-long-java.util.concurrent.TimeUnit-A-java.nio.channels.CompletionHandler-"><code>write</code></a> methods defined by this class allow a timeout to be specified when initiating a read or write operation. If the timeout elapses before an operation completes then the operation completes with the exception <a href="interruptedbytimeoutexception"><code>InterruptedByTimeoutException</code></a>. A timeout may leave the channel, or the underlying connection, in an inconsistent state. Where the implementation cannot guarantee that bytes have not been read from the channel then it puts the channel into an implementation specific <em>error state</em>. A subsequent attempt to initiate a <code>read</code> operation causes an unspecified runtime exception to be thrown. Similarly if a <code>write</code> operation times out and the implementation cannot guarantee bytes have not been written to the channel then further attempts to <code>write</code> to the channel cause an unspecified runtime exception to be thrown. When a timeout elapses then the state of the <a href="../bytebuffer"><code>ByteBuffer</code></a>, or the sequence of buffers, for the I/O operation is not defined. Buffers should be discarded or at least care must be taken to ensure that the buffers are not accessed while the channel remains open. All methods that accept timeout parameters treat values less than or equal to zero to mean that the I/O operation does not timeout.</p>
</div> <dl> <dt>Since:</dt> <dd>1.7</dd> </dl>       <h2 id="constructor.detail">Constructors</h2>   <h3 id="AsynchronousSocketChannel-java.nio.channels.spi.AsynchronousChannelProvider-">AsynchronousSocketChannel</h3> <pre data-language="java">protected AsynchronousSocketChannel(AsynchronousChannelProvider provider)</pre> <p>Initializes a new instance of this class.</p> <dl> <dt>Parameters:</dt> <dd>
<code>provider</code> - The provider that created this channel</dd> </dl>     <h2 id="method.detail">Methods</h2>   <h3 id="provider--">provider</h3> <pre data-language="java">public final AsynchronousChannelProvider provider()</pre> <p>Returns the provider that created this channel.</p> <dl> <dt>Returns:</dt> <dd>The provider that created this channel</dd> </dl>    <h3 id="open-java.nio.channels.AsynchronousChannelGroup-">open</h3> <pre data-language="java">public static AsynchronousSocketChannel open(AsynchronousChannelGroup group)
                                      throws IOException</pre> <div>
<p>Opens an asynchronous socket channel. </p>
<p> The new channel is created by invoking the <a href="spi/asynchronouschannelprovider#openAsynchronousSocketChannel-java.nio.channels.AsynchronousChannelGroup-"><code>openAsynchronousSocketChannel</code></a> method on the <a href="spi/asynchronouschannelprovider"><code>AsynchronousChannelProvider</code></a> that created the group. If the group parameter is <code>null</code> then the resulting channel is created by the system-wide default provider, and bound to the <em>default group</em>.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>group</code> - The group to which the newly constructed channel should be bound, or <code>null</code> for the default group</dd> <dt>Returns:</dt> <dd>A new asynchronous socket channel</dd> <dt>Throws:</dt> <dd>
<code><a href="shutdownchannelgroupexception">ShutdownChannelGroupException</a></code> - If the channel group is shutdown</dd> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If an I/O error occurs</dd> </dl>    <h3 id="open--">open</h3> <pre data-language="java">public static AsynchronousSocketChannel open()
                                      throws IOException</pre> <div>
<p>Opens an asynchronous socket channel. </p>
<p> This method returns an asynchronous socket channel that is bound to the <em>default group</em>.This method is equivalent to evaluating the expression: </p>
<pre data-language="java">open((AsynchronousChannelGroup)null);</pre>
</div> <dl> <dt>Returns:</dt> <dd>A new asynchronous socket channel</dd> <dt>Throws:</dt> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If an I/O error occurs</dd> </dl>    <h3 id="bind-java.net.SocketAddress-">bind</h3> <pre data-language="java">public abstract AsynchronousSocketChannel bind(SocketAddress local)
                                        throws IOException</pre> <p>Description copied from interface: <code><a href="networkchannel#bind-java.net.SocketAddress-">NetworkChannel</a></code></p> <div>
<p>Binds the channel's socket to a local address. </p>
<p> This method is used to establish an association between the socket and a local address. Once an association is established then the socket remains bound until the channel is closed. If the <code>local</code> parameter has the value <code>null</code> then the socket will be bound to an address that is assigned automatically.</p>
</div> <dl> <dt>Specified by:</dt> <dd>
<code><a href="networkchannel#bind-java.net.SocketAddress-">bind</a></code> in interface <code><a href="networkchannel">NetworkChannel</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>local</code> - The address to bind the socket, or <code>null</code> to bind the socket to an automatically assigned socket address</dd> <dt>Returns:</dt> <dd>This channel</dd> <dt>Throws:</dt> <dd>
<code><a href="connectionpendingexception">ConnectionPendingException</a></code> - If a connection operation is already in progress on this channel</dd> <dd>
<code><a href="alreadyboundexception">AlreadyBoundException</a></code> - If the socket is already bound</dd> <dd>
<code><a href="unsupportedaddresstypeexception">UnsupportedAddressTypeException</a></code> - If the type of the given address is not supported</dd> <dd>
<code><a href="closedchannelexception">ClosedChannelException</a></code> - If the channel is closed</dd> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If some other I/O error occurs</dd> <dd>
<code><a href="../../lang/securityexception">SecurityException</a></code> - If a security manager has been installed and its <a href="../../lang/securitymanager#checkListen-int-"><code>checkListen</code></a> method denies the operation</dd> <dt>See Also:</dt> <dd><a href="networkchannel#getLocalAddress--"><code>NetworkChannel.getLocalAddress()</code></a></dd> </dl>    <h3 id="setOption-java.net.SocketOption-T-">setOption</h3> <pre data-language="java">public abstract &lt;T&gt; AsynchronousSocketChannel setOption(SocketOption&lt;T&gt; name,
                                                        T value)
                                                 throws IOException</pre> <p>Description copied from interface: <code><a href="networkchannel#setOption-java.net.SocketOption-T-">NetworkChannel</a></code></p> <p>Sets the value of a socket option.</p> <dl> <dt>Specified by:</dt> <dd>
<code><a href="networkchannel#setOption-java.net.SocketOption-T-">setOption</a></code> in interface <code><a href="networkchannel">NetworkChannel</a></code>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - The type of the socket option value</dd> <dt>Parameters:</dt> <dd>
<code>name</code> - The socket option</dd> <dd>
<code>value</code> - The value of the socket option. A value of <code>null</code> may be a valid value for some socket options.</dd> <dt>Returns:</dt> <dd>This channel</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/illegalargumentexception">IllegalArgumentException</a></code> - If the value is not a valid value for this socket option</dd> <dd>
<code><a href="closedchannelexception">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If an I/O error occurs</dd> <dt>See Also:</dt> <dd><a href="../../net/standardsocketoptions"><code>StandardSocketOptions</code></a></dd> </dl>    <h3 id="shutdownInput--">shutdownInput</h3> <pre data-language="java">public abstract AsynchronousSocketChannel shutdownInput()
                                                 throws IOException</pre> <div>
<p>Shutdown the connection for reading without closing the channel. </p>
<p> Once shutdown for reading then further reads on the channel will return <code>-1</code>, the end-of-stream indication. If the input side of the connection is already shutdown then invoking this method has no effect. The effect on an outstanding read operation is system dependent and therefore not specified. The effect, if any, when there is data in the socket receive buffer that has not been read, or data arrives subsequently, is also system dependent.</p>
</div> <dl> <dt>Returns:</dt> <dd>The channel</dd> <dt>Throws:</dt> <dd>
<code><a href="notyetconnectedexception">NotYetConnectedException</a></code> - If this channel is not yet connected</dd> <dd>
<code><a href="closedchannelexception">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If some other I/O error occurs</dd> </dl>    <h3 id="shutdownOutput--">shutdownOutput</h3> <pre data-language="java">public abstract AsynchronousSocketChannel shutdownOutput()
                                                  throws IOException</pre> <div>
<p>Shutdown the connection for writing without closing the channel. </p>
<p> Once shutdown for writing then further attempts to write to the channel will throw <a href="closedchannelexception"><code>ClosedChannelException</code></a>. If the output side of the connection is already shutdown then invoking this method has no effect. The effect on an outstanding write operation is system dependent and therefore not specified.</p>
</div> <dl> <dt>Returns:</dt> <dd>The channel</dd> <dt>Throws:</dt> <dd>
<code><a href="notyetconnectedexception">NotYetConnectedException</a></code> - If this channel is not yet connected</dd> <dd>
<code><a href="closedchannelexception">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If some other I/O error occurs</dd> </dl>    <h3 id="getRemoteAddress--">getRemoteAddress</h3> <pre data-language="java">public abstract SocketAddress getRemoteAddress()
                                        throws IOException</pre> <div>
<p>Returns the remote address to which this channel's socket is connected. </p>
<p> Where the channel is bound and connected to an Internet Protocol socket address then the return value from this method is of type <a href="../../net/inetsocketaddress"><code>InetSocketAddress</code></a>.</p>
</div> <dl> <dt>Returns:</dt> <dd>The remote address; <code>null</code> if the channel's socket is not connected</dd> <dt>Throws:</dt> <dd>
<code><a href="closedchannelexception">ClosedChannelException</a></code> - If the channel is closed</dd> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If an I/O error occurs</dd> </dl>    <h3 id="connect-java.net.SocketAddress-A-java.nio.channels.CompletionHandler-">connect</h3> <pre data-language="java">public abstract &lt;A&gt; void connect(SocketAddress remote,
                                 A attachment,
                                 CompletionHandler&lt;Void,? super A&gt; handler)</pre> <div>
<p>Connects this channel. </p>
<p> This method initiates an operation to connect this channel. The <code>handler</code> parameter is a completion handler that is invoked when the connection is successfully established or connection cannot be established. If the connection cannot be established then the channel is closed. </p>
<p> This method performs exactly the same security checks as the <a href="../../net/socket"><code>Socket</code></a> class. That is, if a security manager has been installed then this method verifies that its <a href="../../lang/securitymanager#checkConnect-java.lang.String-int-"><code>checkConnect</code></a> method permits connecting to the address and port number of the given remote endpoint.</p>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>A</code> - The type of the attachment</dd> <dt>Parameters:</dt> <dd>
<code>remote</code> - The remote address to which this channel is to be connected</dd> <dd>
<code>attachment</code> - The object to attach to the I/O operation; can be <code>null</code>
</dd> <dd>
<code>handler</code> - The handler for consuming the result</dd> <dt>Throws:</dt> <dd>
<code><a href="unresolvedaddressexception">UnresolvedAddressException</a></code> - If the given remote address is not fully resolved</dd> <dd>
<code><a href="unsupportedaddresstypeexception">UnsupportedAddressTypeException</a></code> - If the type of the given remote address is not supported</dd> <dd>
<code><a href="alreadyconnectedexception">AlreadyConnectedException</a></code> - If this channel is already connected</dd> <dd>
<code><a href="connectionpendingexception">ConnectionPendingException</a></code> - If a connection operation is already in progress on this channel</dd> <dd>
<code><a href="shutdownchannelgroupexception">ShutdownChannelGroupException</a></code> - If the channel group has terminated</dd> <dd>
<code><a href="../../lang/securityexception">SecurityException</a></code> - If a security manager has been installed and it does not permit access to the given remote endpoint</dd> <dt>See Also:</dt> <dd><a href="asynchronoussocketchannel#getRemoteAddress--"><code>getRemoteAddress()</code></a></dd> </dl>    <h3 id="connect-java.net.SocketAddress-">connect</h3> <pre data-language="java">public abstract Future&lt;Void&gt; connect(SocketAddress remote)</pre> <div>
<p>Connects this channel. </p>
<p> This method initiates an operation to connect this channel. This method behaves in exactly the same manner as the <a href="asynchronoussocketchannel#connect-java.net.SocketAddress-A-java.nio.channels.CompletionHandler-"><code>connect(SocketAddress, Object, CompletionHandler)</code></a> method except that instead of specifying a completion handler, this method returns a <code>Future</code> representing the pending result. The <code>Future</code>'s <a href="../../util/concurrent/future#get--"><code>get</code></a> method returns <code>null</code> on successful completion.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>remote</code> - The remote address to which this channel is to be connected</dd> <dt>Returns:</dt> <dd>A <code>Future</code> object representing the pending result</dd> <dt>Throws:</dt> <dd>
<code><a href="unresolvedaddressexception">UnresolvedAddressException</a></code> - If the given remote address is not fully resolved</dd> <dd>
<code><a href="unsupportedaddresstypeexception">UnsupportedAddressTypeException</a></code> - If the type of the given remote address is not supported</dd> <dd>
<code><a href="alreadyconnectedexception">AlreadyConnectedException</a></code> - If this channel is already connected</dd> <dd>
<code><a href="connectionpendingexception">ConnectionPendingException</a></code> - If a connection operation is already in progress on this channel</dd> <dd>
<code><a href="../../lang/securityexception">SecurityException</a></code> - If a security manager has been installed and it does not permit access to the given remote endpoint</dd> </dl>    <h3 id="read-java.nio.ByteBuffer-long-java.util.concurrent.TimeUnit-A-java.nio.channels.CompletionHandler-">read</h3> <pre data-language="java">public abstract &lt;A&gt; void read(ByteBuffer dst,
                              long timeout,
                              TimeUnit unit,
                              A attachment,
                              CompletionHandler&lt;Integer,? super A&gt; handler)</pre> <div>
<p>Reads a sequence of bytes from this channel into the given buffer. </p>
<p> This method initiates an asynchronous read operation to read a sequence of bytes from this channel into the given buffer. The <code>handler</code> parameter is a completion handler that is invoked when the read operation completes (or fails). The result passed to the completion handler is the number of bytes read or <code>-1</code> if no bytes could be read because the channel has reached end-of-stream. </p>
<p> If a timeout is specified and the timeout elapses before the operation completes then the operation completes with the exception <a href="interruptedbytimeoutexception"><code>InterruptedByTimeoutException</code></a>. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been read, or will not be read from the channel into the given buffer, then further attempts to read from the channel will cause an unspecific runtime exception to be thrown. </p>
<p> Otherwise this method works in the same manner as the <a href="asynchronousbytechannel#read-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-"><code>AsynchronousByteChannel.read(ByteBuffer,Object,CompletionHandler)</code></a> method.</p>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>A</code> - The type of the attachment</dd> <dt>Parameters:</dt> <dd>
<code>dst</code> - The buffer into which bytes are to be transferred</dd> <dd>
<code>timeout</code> - The maximum time for the I/O operation to complete</dd> <dd>
<code>unit</code> - The time unit of the <code>timeout</code> argument</dd> <dd>
<code>attachment</code> - The object to attach to the I/O operation; can be <code>null</code>
</dd> <dd>
<code>handler</code> - The handler for consuming the result</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/illegalargumentexception">IllegalArgumentException</a></code> - If the buffer is read-only</dd> <dd>
<code><a href="readpendingexception">ReadPendingException</a></code> - If a read operation is already in progress on this channel</dd> <dd>
<code><a href="notyetconnectedexception">NotYetConnectedException</a></code> - If this channel is not yet connected</dd> <dd>
<code><a href="shutdownchannelgroupexception">ShutdownChannelGroupException</a></code> - If the channel group has terminated</dd> </dl>    <h3 id="read-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-">read</h3> <pre data-language="java">public final &lt;A&gt; void read(ByteBuffer dst,
                           A attachment,
                           CompletionHandler&lt;Integer,? super A&gt; handler)</pre> <p>Description copied from interface: <code><a href="asynchronousbytechannel#read-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-">AsynchronousByteChannel</a></code></p> <div>
<p>Reads a sequence of bytes from this channel into the given buffer. </p>
<p> This method initiates an asynchronous read operation to read a sequence of bytes from this channel into the given buffer. The <code>handler</code> parameter is a completion handler that is invoked when the read operation completes (or fails). The result passed to the completion handler is the number of bytes read or <code>-1</code> if no bytes could be read because the channel has reached end-of-stream. </p>
<p> The read operation may read up to <i>r</i> bytes from the channel, where <i>r</i> is the number of bytes remaining in the buffer, that is, <code>dst.remaining()</code> at the time that the read is attempted. Where <i>r</i> is 0, the read operation completes immediately with a result of <code>0</code> without initiating an I/O operation. </p>
<p> Suppose that a byte sequence of length <i>n</i> is read, where <code>0</code> <code>&lt;</code> <i>n</i> <code>&lt;=</code> <i>r</i>. This byte sequence will be transferred into the buffer so that the first byte in the sequence is at index <i>p</i> and the last byte is at index <i>p</i> <code>+</code> <i>n</i> <code>-</code> <code>1</code>, where <i>p</i> is the buffer's position at the moment the read is performed. Upon completion the buffer's position will be equal to <i>p</i> <code>+</code> <i>n</i>; its limit will not have changed. </p>
<p> Buffers are not safe for use by multiple concurrent threads so care should be taken to not access the buffer until the operation has completed. </p>
<p> This method may be invoked at any time. Some channel types may not allow more than one read to be outstanding at any given time. If a thread initiates a read operation before a previous read operation has completed then a <a href="readpendingexception"><code>ReadPendingException</code></a> will be thrown.</p>
</div> <dl> <dt>Specified by:</dt> <dd>
<code><a href="asynchronousbytechannel#read-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-">read</a></code> in interface <code><a href="asynchronousbytechannel">AsynchronousByteChannel</a></code>
</dd> <dt>Type Parameters:</dt> <dd>
<code>A</code> - The type of the attachment</dd> <dt>Parameters:</dt> <dd>
<code>dst</code> - The buffer into which bytes are to be transferred</dd> <dd>
<code>attachment</code> - The object to attach to the I/O operation; can be <code>null</code>
</dd> <dd>
<code>handler</code> - The completion handler</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/illegalargumentexception">IllegalArgumentException</a></code> - If the buffer is read-only</dd> <dd>
<code><a href="readpendingexception">ReadPendingException</a></code> - If the channel does not allow more than one read to be outstanding and a previous read has not completed</dd> <dd>
<code><a href="notyetconnectedexception">NotYetConnectedException</a></code> - If this channel is not yet connected</dd> <dd>
<code><a href="shutdownchannelgroupexception">ShutdownChannelGroupException</a></code> - If the channel group has terminated</dd> </dl>    <h3 id="read-java.nio.ByteBuffer-">read</h3> <pre data-language="java">public abstract Future&lt;Integer&gt; read(ByteBuffer dst)</pre> <p>Description copied from interface: <code><a href="asynchronousbytechannel#read-java.nio.ByteBuffer-">AsynchronousByteChannel</a></code></p> <div>
<p>Reads a sequence of bytes from this channel into the given buffer. </p>
<p> This method initiates an asynchronous read operation to read a sequence of bytes from this channel into the given buffer. The method behaves in exactly the same manner as the <a href="asynchronousbytechannel#read-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-"><code>read(ByteBuffer,Object,CompletionHandler)</code></a> method except that instead of specifying a completion handler, this method returns a <code>Future</code> representing the pending result. The <code>Future</code>'s <a href="../../util/concurrent/future#get--"><code>get</code></a> method returns the number of bytes read or <code>-1</code> if no bytes could be read because the channel has reached end-of-stream.</p>
</div> <dl> <dt>Specified by:</dt> <dd>
<code><a href="asynchronousbytechannel#read-java.nio.ByteBuffer-">read</a></code> in interface <code><a href="asynchronousbytechannel">AsynchronousByteChannel</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>dst</code> - The buffer into which bytes are to be transferred</dd> <dt>Returns:</dt> <dd>A Future representing the result of the operation</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/illegalargumentexception">IllegalArgumentException</a></code> - If the buffer is read-only</dd> <dd>
<code><a href="readpendingexception">ReadPendingException</a></code> - If the channel does not allow more than one read to be outstanding and a previous read has not completed</dd> <dd>
<code><a href="notyetconnectedexception">NotYetConnectedException</a></code> - If this channel is not yet connected</dd> </dl>    <h3 id="read-java.nio.ByteBuffer:A-int-int-long-java.util.concurrent.TimeUnit-A-java.nio.channels.CompletionHandler-">read</h3> <pre data-language="java">public abstract &lt;A&gt; void read(ByteBuffer[] dsts,
                              int offset,
                              int length,
                              long timeout,
                              TimeUnit unit,
                              A attachment,
                              CompletionHandler&lt;Long,? super A&gt; handler)</pre> <div>
<p>Reads a sequence of bytes from this channel into a subsequence of the given buffers. This operation, sometimes called a <em>scattering read</em>, is often useful when implementing network protocols that group data into segments consisting of one or more fixed-length headers followed by a variable-length body. The <code>handler</code> parameter is a completion handler that is invoked when the read operation completes (or fails). The result passed to the completion handler is the number of bytes read or <code>-1</code> if no bytes could be read because the channel has reached end-of-stream. </p>
<p> This method initiates a read of up to <i>r</i> bytes from this channel, where <i>r</i> is the total number of bytes remaining in the specified subsequence of the given buffer array, that is, </p>
<pre data-language="java">dsts[offset].remaining()
    + dsts[offset+1].remaining()
    + ... + dsts[offset+length-1].remaining()</pre> at the moment that the read is attempted. <p> Suppose that a byte sequence of length <i>n</i> is read, where <code>0</code> <code>&lt;</code> <i>n</i> <code>&lt;=</code> <i>r</i>. Up to the first <code>dsts[offset].remaining()</code> bytes of this sequence are transferred into buffer <code>dsts[offset]</code>, up to the next <code>dsts[offset+1].remaining()</code> bytes are transferred into buffer <code>dsts[offset+1]</code>, and so forth, until the entire byte sequence is transferred into the given buffers. As many bytes as possible are transferred into each buffer, hence the final position of each updated buffer, except the last updated buffer, is guaranteed to be equal to that buffer's limit. The underlying operating system may impose a limit on the number of buffers that may be used in an I/O operation. Where the number of buffers (with bytes remaining), exceeds this limit, then the I/O operation is performed with the maximum number of buffers allowed by the operating system. </p>
<p> If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception <a href="interruptedbytimeoutexception"><code>InterruptedByTimeoutException</code></a>. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been read, or will not be read from the channel into the given buffers, then further attempts to read from the channel will cause an unspecific runtime exception to be thrown.</p>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>A</code> - The type of the attachment</dd> <dt>Parameters:</dt> <dd>
<code>dsts</code> - The buffers into which bytes are to be transferred</dd> <dd>
<code>offset</code> - The offset within the buffer array of the first buffer into which bytes are to be transferred; must be non-negative and no larger than <code>dsts.length</code>
</dd> <dd>
<code>length</code> - The maximum number of buffers to be accessed; must be non-negative and no larger than <code>dsts.length - offset</code>
</dd> <dd>
<code>timeout</code> - The maximum time for the I/O operation to complete</dd> <dd>
<code>unit</code> - The time unit of the <code>timeout</code> argument</dd> <dd>
<code>attachment</code> - The object to attach to the I/O operation; can be <code>null</code>
</dd> <dd>
<code>handler</code> - The handler for consuming the result</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/indexoutofboundsexception">IndexOutOfBoundsException</a></code> - If the pre-conditions for the <code>offset</code> and <code>length</code> parameter aren't met</dd> <dd>
<code><a href="../../lang/illegalargumentexception">IllegalArgumentException</a></code> - If the buffer is read-only</dd> <dd>
<code><a href="readpendingexception">ReadPendingException</a></code> - If a read operation is already in progress on this channel</dd> <dd>
<code><a href="notyetconnectedexception">NotYetConnectedException</a></code> - If this channel is not yet connected</dd> <dd>
<code><a href="shutdownchannelgroupexception">ShutdownChannelGroupException</a></code> - If the channel group has terminated</dd> </dl>    <h3 id="write-java.nio.ByteBuffer-long-java.util.concurrent.TimeUnit-A-java.nio.channels.CompletionHandler-">write</h3> <pre data-language="java">public abstract &lt;A&gt; void write(ByteBuffer src,
                               long timeout,
                               TimeUnit unit,
                               A attachment,
                               CompletionHandler&lt;Integer,? super A&gt; handler)</pre> <div>
<p>Writes a sequence of bytes to this channel from the given buffer. </p>
<p> This method initiates an asynchronous write operation to write a sequence of bytes to this channel from the given buffer. The <code>handler</code> parameter is a completion handler that is invoked when the write operation completes (or fails). The result passed to the completion handler is the number of bytes written. </p>
<p> If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception <a href="interruptedbytimeoutexception"><code>InterruptedByTimeoutException</code></a>. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been written, or will not be written to the channel from the given buffer, then further attempts to write to the channel will cause an unspecific runtime exception to be thrown. </p>
<p> Otherwise this method works in the same manner as the <a href="asynchronousbytechannel#write-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-"><code>AsynchronousByteChannel.write(ByteBuffer,Object,CompletionHandler)</code></a> method.</p>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>A</code> - The type of the attachment</dd> <dt>Parameters:</dt> <dd>
<code>src</code> - The buffer from which bytes are to be retrieved</dd> <dd>
<code>timeout</code> - The maximum time for the I/O operation to complete</dd> <dd>
<code>unit</code> - The time unit of the <code>timeout</code> argument</dd> <dd>
<code>attachment</code> - The object to attach to the I/O operation; can be <code>null</code>
</dd> <dd>
<code>handler</code> - The handler for consuming the result</dd> <dt>Throws:</dt> <dd>
<code><a href="writependingexception">WritePendingException</a></code> - If a write operation is already in progress on this channel</dd> <dd>
<code><a href="notyetconnectedexception">NotYetConnectedException</a></code> - If this channel is not yet connected</dd> <dd>
<code><a href="shutdownchannelgroupexception">ShutdownChannelGroupException</a></code> - If the channel group has terminated</dd> </dl>    <h3 id="write-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-">write</h3> <pre data-language="java">public final &lt;A&gt; void write(ByteBuffer src,
                            A attachment,
                            CompletionHandler&lt;Integer,? super A&gt; handler)</pre> <p>Description copied from interface: <code><a href="asynchronousbytechannel#write-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-">AsynchronousByteChannel</a></code></p> <div>
<p>Writes a sequence of bytes to this channel from the given buffer. </p>
<p> This method initiates an asynchronous write operation to write a sequence of bytes to this channel from the given buffer. The <code>handler</code> parameter is a completion handler that is invoked when the write operation completes (or fails). The result passed to the completion handler is the number of bytes written. </p>
<p> The write operation may write up to <i>r</i> bytes to the channel, where <i>r</i> is the number of bytes remaining in the buffer, that is, <code>src.remaining()</code> at the time that the write is attempted. Where <i>r</i> is 0, the write operation completes immediately with a result of <code>0</code> without initiating an I/O operation. </p>
<p> Suppose that a byte sequence of length <i>n</i> is written, where <code>0</code> <code>&lt;</code> <i>n</i> <code>&lt;=</code> <i>r</i>. This byte sequence will be transferred from the buffer starting at index <i>p</i>, where <i>p</i> is the buffer's position at the moment the write is performed; the index of the last byte written will be <i>p</i> <code>+</code> <i>n</i> <code>-</code> <code>1</code>. Upon completion the buffer's position will be equal to <i>p</i> <code>+</code> <i>n</i>; its limit will not have changed. </p>
<p> Buffers are not safe for use by multiple concurrent threads so care should be taken to not access the buffer until the operation has completed. </p>
<p> This method may be invoked at any time. Some channel types may not allow more than one write to be outstanding at any given time. If a thread initiates a write operation before a previous write operation has completed then a <a href="writependingexception"><code>WritePendingException</code></a> will be thrown.</p>
</div> <dl> <dt>Specified by:</dt> <dd>
<code><a href="asynchronousbytechannel#write-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-">write</a></code> in interface <code><a href="asynchronousbytechannel">AsynchronousByteChannel</a></code>
</dd> <dt>Type Parameters:</dt> <dd>
<code>A</code> - The type of the attachment</dd> <dt>Parameters:</dt> <dd>
<code>src</code> - The buffer from which bytes are to be retrieved</dd> <dd>
<code>attachment</code> - The object to attach to the I/O operation; can be <code>null</code>
</dd> <dd>
<code>handler</code> - The completion handler object</dd> <dt>Throws:</dt> <dd>
<code><a href="writependingexception">WritePendingException</a></code> - If the channel does not allow more than one write to be outstanding and a previous write has not completed</dd> <dd>
<code><a href="notyetconnectedexception">NotYetConnectedException</a></code> - If this channel is not yet connected</dd> <dd>
<code><a href="shutdownchannelgroupexception">ShutdownChannelGroupException</a></code> - If the channel group has terminated</dd> </dl>    <h3 id="write-java.nio.ByteBuffer-">write</h3> <pre data-language="java">public abstract Future&lt;Integer&gt; write(ByteBuffer src)</pre> <p>Description copied from interface: <code><a href="asynchronousbytechannel#write-java.nio.ByteBuffer-">AsynchronousByteChannel</a></code></p> <div>
<p>Writes a sequence of bytes to this channel from the given buffer. </p>
<p> This method initiates an asynchronous write operation to write a sequence of bytes to this channel from the given buffer. The method behaves in exactly the same manner as the <a href="asynchronousbytechannel#write-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-"><code>write(ByteBuffer,Object,CompletionHandler)</code></a> method except that instead of specifying a completion handler, this method returns a <code>Future</code> representing the pending result. The <code>Future</code>'s <a href="../../util/concurrent/future#get--"><code>get</code></a> method returns the number of bytes written.</p>
</div> <dl> <dt>Specified by:</dt> <dd>
<code><a href="asynchronousbytechannel#write-java.nio.ByteBuffer-">write</a></code> in interface <code><a href="asynchronousbytechannel">AsynchronousByteChannel</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>src</code> - The buffer from which bytes are to be retrieved</dd> <dt>Returns:</dt> <dd>A Future representing the result of the operation</dd> <dt>Throws:</dt> <dd>
<code><a href="writependingexception">WritePendingException</a></code> - If the channel does not allow more than one write to be outstanding and a previous write has not completed</dd> <dd>
<code><a href="notyetconnectedexception">NotYetConnectedException</a></code> - If this channel is not yet connected</dd> </dl>    <h3 id="write-java.nio.ByteBuffer:A-int-int-long-java.util.concurrent.TimeUnit-A-java.nio.channels.CompletionHandler-">write</h3> <pre data-language="java">public abstract &lt;A&gt; void write(ByteBuffer[] srcs,
                               int offset,
                               int length,
                               long timeout,
                               TimeUnit unit,
                               A attachment,
                               CompletionHandler&lt;Long,? super A&gt; handler)</pre> <div>
<p>Writes a sequence of bytes to this channel from a subsequence of the given buffers. This operation, sometimes called a <em>gathering write</em>, is often useful when implementing network protocols that group data into segments consisting of one or more fixed-length headers followed by a variable-length body. The <code>handler</code> parameter is a completion handler that is invoked when the write operation completes (or fails). The result passed to the completion handler is the number of bytes written. </p>
<p> This method initiates a write of up to <i>r</i> bytes to this channel, where <i>r</i> is the total number of bytes remaining in the specified subsequence of the given buffer array, that is, </p>
<pre data-language="java">srcs[offset].remaining()
    + srcs[offset+1].remaining()
    + ... + srcs[offset+length-1].remaining()</pre> at the moment that the write is attempted. <p> Suppose that a byte sequence of length <i>n</i> is written, where <code>0</code> <code>&lt;</code> <i>n</i> <code>&lt;=</code> <i>r</i>. Up to the first <code>srcs[offset].remaining()</code> bytes of this sequence are written from buffer <code>srcs[offset]</code>, up to the next <code>srcs[offset+1].remaining()</code> bytes are written from buffer <code>srcs[offset+1]</code>, and so forth, until the entire byte sequence is written. As many bytes as possible are written from each buffer, hence the final position of each updated buffer, except the last updated buffer, is guaranteed to be equal to that buffer's limit. The underlying operating system may impose a limit on the number of buffers that may be used in an I/O operation. Where the number of buffers (with bytes remaining), exceeds this limit, then the I/O operation is performed with the maximum number of buffers allowed by the operating system. </p>
<p> If a timeout is specified and the timeout elapses before the operation completes then it completes with the exception <a href="interruptedbytimeoutexception"><code>InterruptedByTimeoutException</code></a>. Where a timeout occurs, and the implementation cannot guarantee that bytes have not been written, or will not be written to the channel from the given buffers, then further attempts to write to the channel will cause an unspecific runtime exception to be thrown.</p>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>A</code> - The type of the attachment</dd> <dt>Parameters:</dt> <dd>
<code>srcs</code> - The buffers from which bytes are to be retrieved</dd> <dd>
<code>offset</code> - The offset within the buffer array of the first buffer from which bytes are to be retrieved; must be non-negative and no larger than <code>srcs.length</code>
</dd> <dd>
<code>length</code> - The maximum number of buffers to be accessed; must be non-negative and no larger than <code>srcs.length - offset</code>
</dd> <dd>
<code>timeout</code> - The maximum time for the I/O operation to complete</dd> <dd>
<code>unit</code> - The time unit of the <code>timeout</code> argument</dd> <dd>
<code>attachment</code> - The object to attach to the I/O operation; can be <code>null</code>
</dd> <dd>
<code>handler</code> - The handler for consuming the result</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/indexoutofboundsexception">IndexOutOfBoundsException</a></code> - If the pre-conditions for the <code>offset</code> and <code>length</code> parameter aren't met</dd> <dd>
<code><a href="writependingexception">WritePendingException</a></code> - If a write operation is already in progress on this channel</dd> <dd>
<code><a href="notyetconnectedexception">NotYetConnectedException</a></code> - If this channel is not yet connected</dd> <dd>
<code><a href="shutdownchannelgroupexception">ShutdownChannelGroupException</a></code> - If the channel group has terminated</dd> </dl>    <h3 id="getLocalAddress--">getLocalAddress</h3> <pre data-language="java">public abstract SocketAddress getLocalAddress()
                                       throws IOException</pre> <div>
<p>Returns the socket address that this channel's socket is bound to. </p>
<p> Where the channel is <a href="networkchannel#bind-java.net.SocketAddress-"><code>bound</code></a> to an Internet Protocol socket address then the return value from this method is of type <a href="../../net/inetsocketaddress"><code>InetSocketAddress</code></a>. </p>
<p> If there is a security manager set, its <code>checkConnect</code> method is called with the local address and <code>-1</code> as its arguments to see if the operation is allowed. If the operation is not allowed, a <code>SocketAddress</code> representing the <a href="../../net/inetaddress#getLoopbackAddress--"><code>loopback</code></a> address and the local port of the channel's socket is returned.</p>
</div> <dl> <dt>Specified by:</dt> <dd>
<code><a href="networkchannel#getLocalAddress--">getLocalAddress</a></code> in interface <code><a href="networkchannel">NetworkChannel</a></code>
</dd> <dt>Returns:</dt> <dd>The <code>SocketAddress</code> that the socket is bound to, or the <code>SocketAddress</code> representing the loopback address if denied by the security manager, or <code>null</code> if the channel's socket is not bound</dd> <dt>Throws:</dt> <dd>
<code><a href="closedchannelexception">ClosedChannelException</a></code> - If the channel is closed</dd> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If an I/O error occurs</dd> </dl>     <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993&ndash;2017, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    
  </p>
</div>
