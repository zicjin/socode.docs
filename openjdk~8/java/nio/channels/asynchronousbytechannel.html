<h1>Interface AsynchronousByteChannel</h1>     <dl> <dt>All Superinterfaces:</dt> <dd>
<a href="asynchronouschannel">AsynchronousChannel</a>, <a href="../../lang/autocloseable">AutoCloseable</a>, <a href="channel">Channel</a>, <a href="../../io/closeable">Closeable</a>
</dd> </dl> <dl> <dt>All Known Implementing Classes:</dt> <dd><a href="asynchronoussocketchannel">AsynchronousSocketChannel</a></dd> </dl>   <pre data-language="java">public interface AsynchronousByteChannel
extends AsynchronousChannel</pre> <div>
<p>An asynchronous channel that can read and write bytes. </p>
<p> Some channels may not allow more than one read or write to be outstanding at any given time. If a thread invokes a read method before a previous read operation has completed then a <a href="readpendingexception"><code>ReadPendingException</code></a> will be thrown. Similarly, if a write method is invoked before a previous write has completed then <a href="writependingexception"><code>WritePendingException</code></a> is thrown. Whether or not other kinds of I/O operations may proceed concurrently with a read operation depends upon the type of the channel. </p>
<p> Note that <a href="../bytebuffer"><code>ByteBuffers</code></a> are not safe for use by multiple concurrent threads. When a read or write operation is initiated then care must be taken to ensure that the buffer is not accessed until the operation completes.</p>
</div> <dl> <dt>Since:</dt> <dd>1.7</dd> <dt>See Also:</dt> <dd>
<a href="channels#newInputStream-java.nio.channels.AsynchronousByteChannel-"><code>Channels.newInputStream(AsynchronousByteChannel)</code></a>, <a href="channels#newOutputStream-java.nio.channels.AsynchronousByteChannel-"><code>Channels.newOutputStream(AsynchronousByteChannel)</code></a>
</dd> </dl>       <h2 id="method.detail">Methods</h2>   <h3 id="read-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-">read</h3> <pre data-language="java">&lt;A&gt; void read(ByteBuffer dst,
              A attachment,
              CompletionHandler&lt;Integer,? super A&gt; handler)</pre> <div>
<p>Reads a sequence of bytes from this channel into the given buffer. </p>
<p> This method initiates an asynchronous read operation to read a sequence of bytes from this channel into the given buffer. The <code>handler</code> parameter is a completion handler that is invoked when the read operation completes (or fails). The result passed to the completion handler is the number of bytes read or <code>-1</code> if no bytes could be read because the channel has reached end-of-stream. </p>
<p> The read operation may read up to <i>r</i> bytes from the channel, where <i>r</i> is the number of bytes remaining in the buffer, that is, <code>dst.remaining()</code> at the time that the read is attempted. Where <i>r</i> is 0, the read operation completes immediately with a result of <code>0</code> without initiating an I/O operation. </p>
<p> Suppose that a byte sequence of length <i>n</i> is read, where <code>0</code> <code>&lt;</code> <i>n</i> <code>&lt;=</code> <i>r</i>. This byte sequence will be transferred into the buffer so that the first byte in the sequence is at index <i>p</i> and the last byte is at index <i>p</i> <code>+</code> <i>n</i> <code>-</code> <code>1</code>, where <i>p</i> is the buffer's position at the moment the read is performed. Upon completion the buffer's position will be equal to <i>p</i> <code>+</code> <i>n</i>; its limit will not have changed. </p>
<p> Buffers are not safe for use by multiple concurrent threads so care should be taken to not access the buffer until the operation has completed. </p>
<p> This method may be invoked at any time. Some channel types may not allow more than one read to be outstanding at any given time. If a thread initiates a read operation before a previous read operation has completed then a <a href="readpendingexception"><code>ReadPendingException</code></a> will be thrown.</p>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>A</code> - The type of the attachment</dd> <dt>Parameters:</dt> <dd>
<code>dst</code> - The buffer into which bytes are to be transferred</dd> <dd>
<code>attachment</code> - The object to attach to the I/O operation; can be <code>null</code>
</dd> <dd>
<code>handler</code> - The completion handler</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/illegalargumentexception">IllegalArgumentException</a></code> - If the buffer is read-only</dd> <dd>
<code><a href="readpendingexception">ReadPendingException</a></code> - If the channel does not allow more than one read to be outstanding and a previous read has not completed</dd> <dd>
<code><a href="shutdownchannelgroupexception">ShutdownChannelGroupException</a></code> - If the channel is associated with a <a href="asynchronouschannelgroup"><code>group</code></a> that has terminated</dd> </dl>    <h3 id="read-java.nio.ByteBuffer-">read</h3> <pre data-language="java">Future&lt;Integer&gt; read(ByteBuffer dst)</pre> <div>
<p>Reads a sequence of bytes from this channel into the given buffer. </p>
<p> This method initiates an asynchronous read operation to read a sequence of bytes from this channel into the given buffer. The method behaves in exactly the same manner as the <a href="asynchronousbytechannel#read-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-"><code>read(ByteBuffer,Object,CompletionHandler)</code></a> method except that instead of specifying a completion handler, this method returns a <code>Future</code> representing the pending result. The <code>Future</code>'s <a href="../../util/concurrent/future#get--"><code>get</code></a> method returns the number of bytes read or <code>-1</code> if no bytes could be read because the channel has reached end-of-stream.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>dst</code> - The buffer into which bytes are to be transferred</dd> <dt>Returns:</dt> <dd>A Future representing the result of the operation</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/illegalargumentexception">IllegalArgumentException</a></code> - If the buffer is read-only</dd> <dd>
<code><a href="readpendingexception">ReadPendingException</a></code> - If the channel does not allow more than one read to be outstanding and a previous read has not completed</dd> </dl>    <h3 id="write-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-">write</h3> <pre data-language="java">&lt;A&gt; void write(ByteBuffer src,
               A attachment,
               CompletionHandler&lt;Integer,? super A&gt; handler)</pre> <div>
<p>Writes a sequence of bytes to this channel from the given buffer. </p>
<p> This method initiates an asynchronous write operation to write a sequence of bytes to this channel from the given buffer. The <code>handler</code> parameter is a completion handler that is invoked when the write operation completes (or fails). The result passed to the completion handler is the number of bytes written. </p>
<p> The write operation may write up to <i>r</i> bytes to the channel, where <i>r</i> is the number of bytes remaining in the buffer, that is, <code>src.remaining()</code> at the time that the write is attempted. Where <i>r</i> is 0, the write operation completes immediately with a result of <code>0</code> without initiating an I/O operation. </p>
<p> Suppose that a byte sequence of length <i>n</i> is written, where <code>0</code> <code>&lt;</code> <i>n</i> <code>&lt;=</code> <i>r</i>. This byte sequence will be transferred from the buffer starting at index <i>p</i>, where <i>p</i> is the buffer's position at the moment the write is performed; the index of the last byte written will be <i>p</i> <code>+</code> <i>n</i> <code>-</code> <code>1</code>. Upon completion the buffer's position will be equal to <i>p</i> <code>+</code> <i>n</i>; its limit will not have changed. </p>
<p> Buffers are not safe for use by multiple concurrent threads so care should be taken to not access the buffer until the operation has completed. </p>
<p> This method may be invoked at any time. Some channel types may not allow more than one write to be outstanding at any given time. If a thread initiates a write operation before a previous write operation has completed then a <a href="writependingexception"><code>WritePendingException</code></a> will be thrown.</p>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>A</code> - The type of the attachment</dd> <dt>Parameters:</dt> <dd>
<code>src</code> - The buffer from which bytes are to be retrieved</dd> <dd>
<code>attachment</code> - The object to attach to the I/O operation; can be <code>null</code>
</dd> <dd>
<code>handler</code> - The completion handler object</dd> <dt>Throws:</dt> <dd>
<code><a href="writependingexception">WritePendingException</a></code> - If the channel does not allow more than one write to be outstanding and a previous write has not completed</dd> <dd>
<code><a href="shutdownchannelgroupexception">ShutdownChannelGroupException</a></code> - If the channel is associated with a <a href="asynchronouschannelgroup"><code>group</code></a> that has terminated</dd> </dl>    <h3 id="write-java.nio.ByteBuffer-">write</h3> <pre data-language="java">Future&lt;Integer&gt; write(ByteBuffer src)</pre> <div>
<p>Writes a sequence of bytes to this channel from the given buffer. </p>
<p> This method initiates an asynchronous write operation to write a sequence of bytes to this channel from the given buffer. The method behaves in exactly the same manner as the <a href="asynchronousbytechannel#write-java.nio.ByteBuffer-A-java.nio.channels.CompletionHandler-"><code>write(ByteBuffer,Object,CompletionHandler)</code></a> method except that instead of specifying a completion handler, this method returns a <code>Future</code> representing the pending result. The <code>Future</code>'s <a href="../../util/concurrent/future#get--"><code>get</code></a> method returns the number of bytes written.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>src</code> - The buffer from which bytes are to be retrieved</dd> <dt>Returns:</dt> <dd>A Future representing the result of the operation</dd> <dt>Throws:</dt> <dd>
<code><a href="writependingexception">WritePendingException</a></code> - If the channel does not allow more than one write to be outstanding and a previous write has not completed</dd> </dl>     <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993&ndash;2017, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    
  </p>
</div>
