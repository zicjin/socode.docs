<h1>Class Format</h1>   <ul class="inheritance"> <li><a href="../lang/object">java.lang.Object</a></li> <li> <ul class="inheritance"> <li>java.text.Format</li> </ul> </li> </ul>   <dl> <dt>All Implemented Interfaces:</dt> <dd>
<a href="../io/serializable">Serializable</a>, <a href="../lang/cloneable">Cloneable</a>
</dd> </dl> <dl> <dt>Direct Known Subclasses:</dt> <dd>
<a href="dateformat">DateFormat</a>, <a href="messageformat">MessageFormat</a>, <a href="numberformat">NumberFormat</a>
</dd> </dl>   <pre data-language="java">public abstract class Format
extends Object
implements Serializable, Cloneable</pre> <div>
<p><code>Format</code> is an abstract base class for formatting locale-sensitive information such as dates, messages, and numbers. </p>
<p> <code>Format</code> defines the programming interface for formatting locale-sensitive objects into <code>String</code>s (the <code>format</code> method) and for parsing <code>String</code>s back into objects (the <code>parseObject</code> method). </p>
<p> Generally, a format's <code>parseObject</code> method must be able to parse any string formatted by its <code>format</code> method. However, there may be exceptional cases where this is not possible. For example, a <code>format</code> method might create two adjacent integer numbers with no separator in between, and in this case the <code>parseObject</code> could not tell which digits belong to which number. </p>
<h2>Subclassing</h2> <p> The Java Platform provides three specialized subclasses of <code>Format</code>-- <code>DateFormat</code>, <code>MessageFormat</code>, and <code>NumberFormat</code>--for formatting dates, messages, and numbers, respectively. </p>
<p> Concrete subclasses must implement three methods: </p>
<ol> <li> <code>format(Object obj, StringBuffer toAppendTo, FieldPosition pos)</code> </li>
<li> <code>formatToCharacterIterator(Object obj)</code> </li>
<li> <code>parseObject(String source, ParsePosition pos)</code> </li>
</ol> These general methods allow polymorphic parsing and formatting of objects and are used, for example, by <code>MessageFormat</code>. Subclasses often also provide additional <code>format</code> methods for specific input types as well as <code>parse</code> methods for specific result types. Any <code>parse</code> method that does not take a <code>ParsePosition</code> argument should throw <code>ParseException</code> when no text in the required format is at the beginning of the input text. <p> Most subclasses will also implement the following factory methods: </p>
<ol> <li> <code>getInstance</code> for getting a useful format object appropriate for the current locale </li>
<li> <code>getInstance(Locale)</code> for getting a useful format object appropriate for the specified locale </li>
</ol> In addition, some subclasses may also implement other <code>getXxxxInstance</code> methods for more specialized control. For example, the <code>NumberFormat</code> class provides <code>getPercentInstance</code> and <code>getCurrencyInstance</code> methods for getting specialized number formatters. <p> Subclasses of <code>Format</code> that allow programmers to create objects for locales (with <code>getInstance(Locale)</code> for example) must also implement the following class method: </p>
<pre data-language="java">public static Locale[] getAvailableLocales()</pre> <p> And finally subclasses may define a set of constants to identify the various fields in the formatted output. These constants are used to create a FieldPosition object which identifies what information is contained in the field and its position in the formatted result. These constants should be named <code><em>item</em>_FIELD</code> where <code><em>item</em></code> identifies the field. For examples of these constants, see <code>ERA_FIELD</code> and its friends in <a href="dateformat"><code>DateFormat</code></a>. </p>
<h3><a name="synchronization">Synchronization</a></h3> <p> Formats are generally not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally.</p>
</div> <dl> <dt>See Also:</dt> <dd>
<a href="parseposition"><code>ParsePosition</code></a>, <a href="fieldposition"><code>FieldPosition</code></a>, <a href="numberformat"><code>NumberFormat</code></a>, <a href="dateformat"><code>DateFormat</code></a>, <a href="messageformat"><code>MessageFormat</code></a>, Serialized Form</dd> </dl>       <h2 id="nested.class.summary">Nested Classes</h2> <table> <caption>Nested Classes </caption> <tr> <th scope="col">Modifier and Type</th> <th scope="col">Class and Description</th> </tr> <tr> <td><code>static class </code></td> <td>
<code><a href="format.field">Format.Field</a></code> <p>Defines constants that are used as attribute keys in the <code>AttributedCharacterIterator</code> returned from <code>Format.formatToCharacterIterator</code> and as field identifiers in <code>FieldPosition</code>.</p> </td> </tr> </table>    <h2 id="constructor.detail">Constructors</h2>   <h3 id="Format--">Format</h3> <pre data-language="java">protected Format()</pre> <p>Sole constructor. (For invocation by subclass constructors, typically implicit.)</p>     <h2 id="method.detail">Methods</h2>   <h3 id="format-java.lang.Object-">format</h3> <pre data-language="java">public final String format(Object obj)</pre> <p>Formats an object to produce a string. This is equivalent to <pre data-language="java">format(obj, new StringBuffer(), new FieldPosition(0)).toString();</pre></p> <dl> <dt>Parameters:</dt> <dd>
<code>obj</code> - The object to format</dd> <dt>Returns:</dt> <dd>Formatted string.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if the Format cannot format the given object</dd> </dl>    <h3 id="format-java.lang.Object-java.lang.StringBuffer-java.text.FieldPosition-">format</h3> <pre data-language="java">public abstract StringBuffer format(Object obj,
                                    StringBuffer toAppendTo,
                                    FieldPosition pos)</pre> <p>Formats an object and appends the resulting text to a given string buffer. If the <code>pos</code> argument identifies a field used by the format, then its indices are set to the beginning and end of the first such field encountered.</p> <dl> <dt>Parameters:</dt> <dd>
<code>obj</code> - The object to format</dd> <dd>
<code>toAppendTo</code> - where the text is to be appended</dd> <dd>
<code>pos</code> - A <code>FieldPosition</code> identifying a field in the formatted text</dd> <dt>Returns:</dt> <dd>the string buffer passed in as <code>toAppendTo</code>, with formatted text appended</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>toAppendTo</code> or <code>pos</code> is null</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if the Format cannot format the given object</dd> </dl>    <h3 id="formatToCharacterIterator-java.lang.Object-">formatToCharacterIterator</h3> <pre data-language="java">public AttributedCharacterIterator formatToCharacterIterator(Object obj)</pre> <div>
<p>Formats an Object producing an <code>AttributedCharacterIterator</code>. You can use the returned <code>AttributedCharacterIterator</code> to build the resulting String, as well as to determine information about the resulting String. </p>
<p> Each attribute key of the AttributedCharacterIterator will be of type <code>Field</code>. It is up to each <code>Format</code> implementation to define what the legal values are for each attribute in the <code>AttributedCharacterIterator</code>, but typically the attribute key is also used as the attribute value. </p>
<p>The default implementation creates an <code>AttributedCharacterIterator</code> with no attributes. Subclasses that support fields should override this and create an <code>AttributedCharacterIterator</code> with meaningful attributes.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>obj</code> - The object to format</dd> <dt>Returns:</dt> <dd>AttributedCharacterIterator describing the formatted value.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if obj is null.</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - when the Format cannot format the given object.</dd> <dt>Since:</dt> <dd>1.4</dd> </dl>    <h3 id="parseObject-java.lang.String-java.text.ParsePosition-">parseObject</h3> <pre data-language="java">public abstract Object parseObject(String source,
                                   ParsePosition pos)</pre> <div>
<p>Parses text from a string to produce an object. </p>
<p> The method attempts to parse text starting at the index given by <code>pos</code>. If parsing succeeds, then the index of <code>pos</code> is updated to the index after the last character used (parsing does not necessarily use all characters up to the end of the string), and the parsed object is returned. The updated <code>pos</code> can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of <code>pos</code> is not changed, the error index of <code>pos</code> is set to the index of the character where the error occurred, and null is returned.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>source</code> - A <code>String</code>, part of which should be parsed.</dd> <dd>
<code>pos</code> - A <code>ParsePosition</code> object with index and error index information as described above.</dd> <dt>Returns:</dt> <dd>An <code>Object</code> parsed from the string. In case of error, returns null.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>pos</code> is null.</dd> </dl>    <h3 id="parseObject-java.lang.String-">parseObject</h3> <pre data-language="java">public Object parseObject(String source)
                   throws ParseException</pre> <p>Parses text from the beginning of the given string to produce an object. The method may not use the entire text of the given string.</p> <dl> <dt>Parameters:</dt> <dd>
<code>source</code> - A <code>String</code> whose beginning should be parsed.</dd> <dt>Returns:</dt> <dd>An <code>Object</code> parsed from the string.</dd> <dt>Throws:</dt> <dd>
<code><a href="parseexception">ParseException</a></code> - if the beginning of the specified string cannot be parsed.</dd> </dl>    <h3 id="clone--">clone</h3> <pre data-language="java">public Object clone()</pre> <p>Creates and returns a copy of this object.</p> <dl> <dt>Overrides:</dt> <dd>
<code><a href="../lang/object#clone--">clone</a></code> in class <code><a href="../lang/object">Object</a></code>
</dd> <dt>Returns:</dt> <dd>a clone of this instance.</dd> <dt>See Also:</dt> <dd><a href="../lang/cloneable"><code>Cloneable</code></a></dd> </dl>     <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993&ndash;2017, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    
  </p>
</div>
