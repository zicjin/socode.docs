<h1>Class ServerSocket</h1>   <ul class="inheritance"> <li><a href="../lang/object">java.lang.Object</a></li> <li> <ul class="inheritance"> <li>java.net.ServerSocket</li> </ul> </li> </ul>   <dl> <dt>All Implemented Interfaces:</dt> <dd>
<a href="../io/closeable">Closeable</a>, <a href="../lang/autocloseable">AutoCloseable</a>
</dd> </dl> <dl> <dt>Direct Known Subclasses:</dt> <dd><a href="../../javax/net/ssl/sslserversocket">SSLServerSocket</a></dd> </dl>   <pre data-language="java">public class ServerSocket
extends Object
implements Closeable</pre> <div>
<p>This class implements server sockets. A server socket waits for requests to come in over the network. It performs some operation based on that request, and then possibly returns a result to the requester. </p>
<p> The actual work of the server socket is performed by an instance of the <code>SocketImpl</code> class. An application can change the socket factory that creates the socket implementation to configure itself to create sockets appropriate to the local firewall.</p>
</div> <dl> <dt>Since:</dt> <dd>JDK1.0</dd> <dt>See Also:</dt> <dd>
<a href="socketimpl"><code>SocketImpl</code></a>, <a href="serversocket#setSocketFactory-java.net.SocketImplFactory-"><code>setSocketFactory(java.net.SocketImplFactory)</code></a>, <a href="../nio/channels/serversocketchannel"><code>ServerSocketChannel</code></a>
</dd> </dl>       <h2 id="constructor.detail">Constructors</h2>   <h3 id="ServerSocket--">ServerSocket</h3> <pre data-language="java">public ServerSocket()
             throws IOException</pre> <p>Creates an unbound server socket.</p> <dl> <dt>Throws:</dt> <dd>
<code><a href="../io/ioexception">IOException</a></code> - IO error when opening the socket.</dd> </dl>    <h3 id="ServerSocket-int-">ServerSocket</h3> <pre data-language="java">public ServerSocket(int port)
             throws IOException</pre> <div>
<p>Creates a server socket, bound to the specified port. A port number of <code>0</code> means that the port number is automatically allocated, typically from an ephemeral port range. This port number can then be retrieved by calling <a href="serversocket#getLocalPort--"><code>getLocalPort</code></a>. </p>
<p> The maximum queue length for incoming connection indications (a request to connect) is set to <code>50</code>. If a connection indication arrives when the queue is full, the connection is refused. </p>
<p> If the application has specified a server socket factory, that factory's <code>createSocketImpl</code> method is called to create the actual socket implementation. Otherwise a "plain" socket is created. </p>
<p> If there is a security manager, its <code>checkListen</code> method is called with the <code>port</code> argument as its argument to ensure the operation is allowed. This could result in a SecurityException.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>port</code> - the port number, or <code>0</code> to use a port number that is automatically allocated.</dd> <dt>Throws:</dt> <dd>
<code><a href="../io/ioexception">IOException</a></code> - if an I/O error occurs when opening the socket.</dd> <dd>
<code><a href="../lang/securityexception">SecurityException</a></code> - if a security manager exists and its <code>checkListen</code> method doesn't allow the operation.</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if the port parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive.</dd> <dt>See Also:</dt> <dd>
<a href="socketimpl"><code>SocketImpl</code></a>, <a href="socketimplfactory#createSocketImpl--"><code>SocketImplFactory.createSocketImpl()</code></a>, <a href="serversocket#setSocketFactory-java.net.SocketImplFactory-"><code>setSocketFactory(java.net.SocketImplFactory)</code></a>, <a href="../lang/securitymanager#checkListen-int-"><code>SecurityManager.checkListen(int)</code></a>
</dd> </dl>    <h3 id="ServerSocket-int-int-">ServerSocket</h3> <pre data-language="java">public ServerSocket(int port,
                    int backlog)
             throws IOException</pre> <div>
<p>Creates a server socket and binds it to the specified local port number, with the specified backlog. A port number of <code>0</code> means that the port number is automatically allocated, typically from an ephemeral port range. This port number can then be retrieved by calling <a href="serversocket#getLocalPort--"><code>getLocalPort</code></a>. </p>
<p> The maximum queue length for incoming connection indications (a request to connect) is set to the <code>backlog</code> parameter. If a connection indication arrives when the queue is full, the connection is refused. </p>
<p> If the application has specified a server socket factory, that factory's <code>createSocketImpl</code> method is called to create the actual socket implementation. Otherwise a "plain" socket is created. </p>
<p> If there is a security manager, its <code>checkListen</code> method is called with the <code>port</code> argument as its argument to ensure the operation is allowed. This could result in a SecurityException. The <code>backlog</code> argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. The value provided should be greater than <code>0</code>. If it is less than or equal to <code>0</code>, then an implementation specific default will be used. </p>

</div> <dl> <dt>Parameters:</dt> <dd>
<code>port</code> - the port number, or <code>0</code> to use a port number that is automatically allocated.</dd> <dd>
<code>backlog</code> - requested maximum length of the queue of incoming connections.</dd> <dt>Throws:</dt> <dd>
<code><a href="../io/ioexception">IOException</a></code> - if an I/O error occurs when opening the socket.</dd> <dd>
<code><a href="../lang/securityexception">SecurityException</a></code> - if a security manager exists and its <code>checkListen</code> method doesn't allow the operation.</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if the port parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive.</dd> <dt>See Also:</dt> <dd>
<a href="socketimpl"><code>SocketImpl</code></a>, <a href="socketimplfactory#createSocketImpl--"><code>SocketImplFactory.createSocketImpl()</code></a>, <a href="serversocket#setSocketFactory-java.net.SocketImplFactory-"><code>setSocketFactory(java.net.SocketImplFactory)</code></a>, <a href="../lang/securitymanager#checkListen-int-"><code>SecurityManager.checkListen(int)</code></a>
</dd> </dl>    <h3 id="ServerSocket-int-int-java.net.InetAddress-">ServerSocket</h3> <pre data-language="java">public ServerSocket(int port,
                    int backlog,
                    InetAddress bindAddr)
             throws IOException</pre> <div>
<p>Create a server with the specified port, listen backlog, and local IP address to bind to. The <i>bindAddr</i> argument can be used on a multi-homed host for a ServerSocket that will only accept connect requests to one of its addresses. If <i>bindAddr</i> is null, it will default accepting connections on any/all local addresses. The port must be between 0 and 65535, inclusive. A port number of <code>0</code> means that the port number is automatically allocated, typically from an ephemeral port range. This port number can then be retrieved by calling <a href="serversocket#getLocalPort--"><code>getLocalPort</code></a>. </p>
<p>If there is a security manager, this method calls its <code>checkListen</code> method with the <code>port</code> argument as its argument to ensure the operation is allowed. This could result in a SecurityException. The <code>backlog</code> argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. The value provided should be greater than <code>0</code>. If it is less than or equal to <code>0</code>, then an implementation specific default will be used. </p>

</div> <dl> <dt>Parameters:</dt> <dd>
<code>port</code> - the port number, or <code>0</code> to use a port number that is automatically allocated.</dd> <dd>
<code>backlog</code> - requested maximum length of the queue of incoming connections.</dd> <dd>
<code>bindAddr</code> - the local InetAddress the server will bind to</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/securityexception">SecurityException</a></code> - if a security manager exists and its <code>checkListen</code> method doesn't allow the operation.</dd> <dd>
<code><a href="../io/ioexception">IOException</a></code> - if an I/O error occurs when opening the socket.</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if the port parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive.</dd> <dt>Since:</dt> <dd>JDK1.1</dd> <dt>See Also:</dt> <dd>
<a href="socketoptions"><code>SocketOptions</code></a>, <a href="socketimpl"><code>SocketImpl</code></a>, <a href="../lang/securitymanager#checkListen-int-"><code>SecurityManager.checkListen(int)</code></a>
</dd> </dl>     <h2 id="method.detail">Methods</h2>   <h3 id="bind-java.net.SocketAddress-">bind</h3> <pre data-language="java">public void bind(SocketAddress endpoint)
          throws IOException</pre> <div>
<p>Binds the <code>ServerSocket</code> to a specific address (IP address and port number). </p>
<p> If the address is <code>null</code>, then the system will pick up an ephemeral port and a valid local address to bind the socket. </p>

</div> <dl> <dt>Parameters:</dt> <dd>
<code>endpoint</code> - The IP address and port number to bind to.</dd> <dt>Throws:</dt> <dd>
<code><a href="../io/ioexception">IOException</a></code> - if the bind operation fails, or if the socket is already bound.</dd> <dd>
<code><a href="../lang/securityexception">SecurityException</a></code> - if a <code>SecurityManager</code> is present and its <code>checkListen</code> method doesn't allow the operation.</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if endpoint is a SocketAddress subclass not supported by this socket</dd> <dt>Since:</dt> <dd>1.4</dd> </dl>    <h3 id="bind-java.net.SocketAddress-int-">bind</h3> <pre data-language="java">public void bind(SocketAddress endpoint,
                 int backlog)
          throws IOException</pre> <div>
<p>Binds the <code>ServerSocket</code> to a specific address (IP address and port number). </p>
<p> If the address is <code>null</code>, then the system will pick up an ephemeral port and a valid local address to bind the socket. </p>
<p> The <code>backlog</code> argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. The value provided should be greater than <code>0</code>. If it is less than or equal to <code>0</code>, then an implementation specific default will be used.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>endpoint</code> - The IP address and port number to bind to.</dd> <dd>
<code>backlog</code> - requested maximum length of the queue of incoming connections.</dd> <dt>Throws:</dt> <dd>
<code><a href="../io/ioexception">IOException</a></code> - if the bind operation fails, or if the socket is already bound.</dd> <dd>
<code><a href="../lang/securityexception">SecurityException</a></code> - if a <code>SecurityManager</code> is present and its <code>checkListen</code> method doesn't allow the operation.</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if endpoint is a SocketAddress subclass not supported by this socket</dd> <dt>Since:</dt> <dd>1.4</dd> </dl>    <h3 id="getInetAddress--">getInetAddress</h3> <pre data-language="java">public InetAddress getInetAddress()</pre> <div>
<p>Returns the local address of this server socket. </p>
<p> If the socket was bound prior to being <a href="serversocket#close--"><code>closed</code></a>, then this method will continue to return the local address after the socket is closed. </p>
<p> If there is a security manager set, its <code>checkConnect</code> method is called with the local address and <code>-1</code> as its arguments to see if the operation is allowed. If the operation is not allowed, the <a href="inetaddress#getLoopbackAddress--"><code>loopback</code></a> address is returned.</p>
</div> <dl> <dt>Returns:</dt> <dd>the address to which this socket is bound, or the loopback address if denied by the security manager, or <code>null</code> if the socket is unbound.</dd> <dt>See Also:</dt> <dd><a href="../lang/securitymanager#checkConnect-java.lang.String-int-"><code>SecurityManager.checkConnect(java.lang.String, int)</code></a></dd> </dl>    <h3 id="getLocalPort--">getLocalPort</h3> <pre data-language="java">public int getLocalPort()</pre> <div>
<p>Returns the port number on which this socket is listening. </p>
<p> If the socket was bound prior to being <a href="serversocket#close--"><code>closed</code></a>, then this method will continue to return the port number after the socket is closed.</p>
</div> <dl> <dt>Returns:</dt> <dd>the port number to which this socket is listening or -1 if the socket is not bound yet.</dd> </dl>    <h3 id="getLocalSocketAddress--">getLocalSocketAddress</h3> <pre data-language="java">public SocketAddress getLocalSocketAddress()</pre> <div>
<p>Returns the address of the endpoint this socket is bound to. </p>
<p> If the socket was bound prior to being <a href="serversocket#close--"><code>closed</code></a>, then this method will continue to return the address of the endpoint after the socket is closed. </p>
<p> If there is a security manager set, its <code>checkConnect</code> method is called with the local address and <code>-1</code> as its arguments to see if the operation is allowed. If the operation is not allowed, a <code>SocketAddress</code> representing the <a href="inetaddress#getLoopbackAddress--"><code>loopback</code></a> address and the local port to which the socket is bound is returned.</p>
</div> <dl> <dt>Returns:</dt> <dd>a <code>SocketAddress</code> representing the local endpoint of this socket, or a <code>SocketAddress</code> representing the loopback address if denied by the security manager, or <code>null</code> if the socket is not bound yet.</dd> <dt>Since:</dt> <dd>1.4</dd> <dt>See Also:</dt> <dd>
<a href="serversocket#getInetAddress--"><code>getInetAddress()</code></a>, <a href="serversocket#getLocalPort--"><code>getLocalPort()</code></a>, <a href="serversocket#bind-java.net.SocketAddress-"><code>bind(SocketAddress)</code></a>, <a href="../lang/securitymanager#checkConnect-java.lang.String-int-"><code>SecurityManager.checkConnect(java.lang.String, int)</code></a>
</dd> </dl>    <h3 id="accept--">accept</h3> <pre data-language="java">public Socket accept()
              throws IOException</pre> <div>
<p>Listens for a connection to be made to this socket and accepts it. The method blocks until a connection is made. </p>
<p>A new Socket <code>s</code> is created and, if there is a security manager, the security manager's <code>checkAccept</code> method is called with <code>s.getInetAddress().getHostAddress()</code> and <code>s.getPort()</code> as its arguments to ensure the operation is allowed. This could result in a SecurityException.</p>
</div> <dl> <dt>Returns:</dt> <dd>the new Socket</dd> <dt>Throws:</dt> <dd>
<code><a href="../io/ioexception">IOException</a></code> - if an I/O error occurs when waiting for a connection.</dd> <dd>
<code><a href="../lang/securityexception">SecurityException</a></code> - if a security manager exists and its <code>checkAccept</code> method doesn't allow the operation.</dd> <dd>
<code><a href="sockettimeoutexception">SocketTimeoutException</a></code> - if a timeout was previously set with setSoTimeout and the timeout has been reached.</dd> <dd>
<code><a href="../nio/channels/illegalblockingmodeexception">IllegalBlockingModeException</a></code> - if this socket has an associated channel, the channel is in non-blocking mode, and there is no connection ready to be accepted</dd> <dt>See Also:</dt> <dd><a href="../lang/securitymanager#checkAccept-java.lang.String-int-"><code>SecurityManager.checkAccept(java.lang.String, int)</code></a></dd> </dl>    <h3 id="implAccept-java.net.Socket-">implAccept</h3> <pre data-language="java">protected final void implAccept(Socket s)
                         throws IOException</pre> <p>Subclasses of ServerSocket use this method to override accept() to return their own subclass of socket. So a FooServerSocket will typically hand this method an <i>empty</i> FooSocket. On return from implAccept the FooSocket will be connected to a client.</p> <dl> <dt>Parameters:</dt> <dd>
<code>s</code> - the Socket</dd> <dt>Throws:</dt> <dd>
<code><a href="../nio/channels/illegalblockingmodeexception">IllegalBlockingModeException</a></code> - if this socket has an associated channel, and the channel is in non-blocking mode</dd> <dd>
<code><a href="../io/ioexception">IOException</a></code> - if an I/O error occurs when waiting for a connection.</dd> <dt>Since:</dt> <dd>JDK1.1</dd> </dl>    <h3 id="close--">close</h3> <pre data-language="java">public void close()
           throws IOException</pre> <div>
<p>Closes this socket. Any thread currently blocked in <a href="serversocket#accept--"><code>accept()</code></a> will throw a <a href="socketexception"><code>SocketException</code></a>. </p>
<p> If this socket has an associated channel then the channel is closed as well.</p>
</div> <dl> <dt>Specified by:</dt> <dd>
<code><a href="../io/closeable#close--">close</a></code> in interface <code><a href="../io/closeable">Closeable</a></code>
</dd> <dt>Specified by:</dt> <dd>
<code><a href="../lang/autocloseable#close--">close</a></code> in interface <code><a href="../lang/autocloseable">AutoCloseable</a></code>
</dd> <dt>Throws:</dt> <dd>
<code><a href="../io/ioexception">IOException</a></code> - if an I/O error occurs when closing the socket.</dd> </dl>    <h3 id="getChannel--">getChannel</h3> <pre data-language="java">public ServerSocketChannel getChannel()</pre> <div>
<p>Returns the unique <a href="../nio/channels/serversocketchannel"><code>ServerSocketChannel</code></a> object associated with this socket, if any. </p>
<p> A server socket will have a channel if, and only if, the channel itself was created via the <a href="../nio/channels/serversocketchannel#open--"><code>ServerSocketChannel.open</code></a> method.</p>
</div> <dl> <dt>Returns:</dt> <dd>the server-socket channel associated with this socket, or <code>null</code> if this socket was not created for a channel</dd> <dt>Since:</dt> <dd>1.4</dd> </dl>    <h3 id="isBound--">isBound</h3> <pre data-language="java">public boolean isBound()</pre> <p>Returns the binding state of the ServerSocket.</p> <dl> <dt>Returns:</dt> <dd>true if the ServerSocket successfully bound to an address</dd> <dt>Since:</dt> <dd>1.4</dd> </dl>    <h3 id="isClosed--">isClosed</h3> <pre data-language="java">public boolean isClosed()</pre> <p>Returns the closed state of the ServerSocket.</p> <dl> <dt>Returns:</dt> <dd>true if the socket has been closed</dd> <dt>Since:</dt> <dd>1.4</dd> </dl>    <h3 id="setSoTimeout-int-">setSoTimeout</h3> <pre data-language="java">public void setSoTimeout(int timeout)
                  throws SocketException</pre> <p>Enable/disable <a href="socketoptions#SO_TIMEOUT"><code>SO_TIMEOUT</code></a> with the specified timeout, in milliseconds. With this option set to a non-zero timeout, a call to accept() for this ServerSocket will block for only this amount of time. If the timeout expires, a <b>java.net.SocketTimeoutException</b> is raised, though the ServerSocket is still valid. The option <b>must</b> be enabled prior to entering the blocking operation to have effect. The timeout must be <code>&gt; 0</code>. A timeout of zero is interpreted as an infinite timeout.</p> <dl> <dt>Parameters:</dt> <dd>
<code>timeout</code> - the specified timeout, in milliseconds</dd> <dt>Throws:</dt> <dd>
<code><a href="socketexception">SocketException</a></code> - if there is an error in the underlying protocol, such as a TCP error.</dd> <dt>Since:</dt> <dd>JDK1.1</dd> <dt>See Also:</dt> <dd><a href="serversocket#getSoTimeout--"><code>getSoTimeout()</code></a></dd> </dl>    <h3 id="getSoTimeout--">getSoTimeout</h3> <pre data-language="java">public int getSoTimeout()
                 throws IOException</pre> <p>Retrieve setting for <a href="socketoptions#SO_TIMEOUT"><code>SO_TIMEOUT</code></a>. 0 returns implies that the option is disabled (i.e., timeout of infinity).</p> <dl> <dt>Returns:</dt> <dd>the <a href="socketoptions#SO_TIMEOUT"><code>SO_TIMEOUT</code></a> value</dd> <dt>Throws:</dt> <dd>
<code><a href="../io/ioexception">IOException</a></code> - if an I/O error occurs</dd> <dt>Since:</dt> <dd>JDK1.1</dd> <dt>See Also:</dt> <dd><a href="serversocket#setSoTimeout-int-"><code>setSoTimeout(int)</code></a></dd> </dl>    <h3 id="setReuseAddress-boolean-">setReuseAddress</h3> <pre data-language="java">public void setReuseAddress(boolean on)
                     throws SocketException</pre> <div>
<p>Enable/disable the <a href="socketoptions#SO_REUSEADDR"><code>SO_REUSEADDR</code></a> socket option. </p>
<p> When a TCP connection is closed the connection may remain in a timeout state for a period of time after the connection is closed (typically known as the <code>TIME_WAIT</code> state or <code>2MSL</code> wait state). For applications using a well known socket address or port it may not be possible to bind a socket to the required <code>SocketAddress</code> if there is a connection in the timeout state involving the socket address or port. </p>
<p> Enabling <a href="socketoptions#SO_REUSEADDR"><code>SO_REUSEADDR</code></a> prior to binding the socket using <a href="serversocket#bind-java.net.SocketAddress-"><code>bind(SocketAddress)</code></a> allows the socket to be bound even though a previous connection is in a timeout state. </p>
<p> When a <code>ServerSocket</code> is created the initial setting of <a href="socketoptions#SO_REUSEADDR"><code>SO_REUSEADDR</code></a> is not defined. Applications can use <a href="serversocket#getReuseAddress--"><code>getReuseAddress()</code></a> to determine the initial setting of <a href="socketoptions#SO_REUSEADDR"><code>SO_REUSEADDR</code></a>. </p>
<p> The behaviour when <a href="socketoptions#SO_REUSEADDR"><code>SO_REUSEADDR</code></a> is enabled or disabled after a socket is bound (See <a href="serversocket#isBound--"><code>isBound()</code></a>) is not defined.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>on</code> - whether to enable or disable the socket option</dd> <dt>Throws:</dt> <dd>
<code><a href="socketexception">SocketException</a></code> - if an error occurs enabling or disabling the <a href="socketoptions#SO_REUSEADDR"><code>SO_REUSEADDR</code></a> socket option, or the socket is closed.</dd> <dt>Since:</dt> <dd>1.4</dd> <dt>See Also:</dt> <dd>
<a href="serversocket#getReuseAddress--"><code>getReuseAddress()</code></a>, <a href="serversocket#bind-java.net.SocketAddress-"><code>bind(SocketAddress)</code></a>, <a href="serversocket#isBound--"><code>isBound()</code></a>, <a href="serversocket#isClosed--"><code>isClosed()</code></a>
</dd> </dl>    <h3 id="getReuseAddress--">getReuseAddress</h3> <pre data-language="java">public boolean getReuseAddress()
                        throws SocketException</pre> <p>Tests if <a href="socketoptions#SO_REUSEADDR"><code>SO_REUSEADDR</code></a> is enabled.</p> <dl> <dt>Returns:</dt> <dd>a <code>boolean</code> indicating whether or not <a href="socketoptions#SO_REUSEADDR"><code>SO_REUSEADDR</code></a> is enabled.</dd> <dt>Throws:</dt> <dd>
<code><a href="socketexception">SocketException</a></code> - if there is an error in the underlying protocol, such as a TCP error.</dd> <dt>Since:</dt> <dd>1.4</dd> <dt>See Also:</dt> <dd><a href="serversocket#setReuseAddress-boolean-"><code>setReuseAddress(boolean)</code></a></dd> </dl>    <h3 id="toString--">toString</h3> <pre data-language="java">public String toString()</pre> <div>
<p>Returns the implementation address and implementation port of this socket as a <code>String</code>. </p>
<p> If there is a security manager set, its <code>checkConnect</code> method is called with the local address and <code>-1</code> as its arguments to see if the operation is allowed. If the operation is not allowed, an <code>InetAddress</code> representing the <a href="inetaddress#getLoopbackAddress--"><code>loopback</code></a> address is returned as the implementation address.</p>
</div> <dl> <dt>Overrides:</dt> <dd>
<code><a href="../lang/object#toString--">toString</a></code> in class <code><a href="../lang/object">Object</a></code>
</dd> <dt>Returns:</dt> <dd>a string representation of this socket.</dd> </dl>    <h3 id="setSocketFactory-java.net.SocketImplFactory-">setSocketFactory</h3> <pre data-language="java">public static void setSocketFactory(SocketImplFactory fac)
                             throws IOException</pre> <div>
<p>Sets the server socket implementation factory for the application. The factory can be specified only once. </p>
<p> When an application creates a new server socket, the socket implementation factory's <code>createSocketImpl</code> method is called to create the actual socket implementation. </p>
<p> Passing <code>null</code> to the method is a no-op unless the factory was already set. </p>
<p> If there is a security manager, this method first calls the security manager's <code>checkSetFactory</code> method to ensure the operation is allowed. This could result in a SecurityException.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>fac</code> - the desired factory.</dd> <dt>Throws:</dt> <dd>
<code><a href="../io/ioexception">IOException</a></code> - if an I/O error occurs when setting the socket factory.</dd> <dd>
<code><a href="socketexception">SocketException</a></code> - if the factory has already been defined.</dd> <dd>
<code><a href="../lang/securityexception">SecurityException</a></code> - if a security manager exists and its <code>checkSetFactory</code> method doesn't allow the operation.</dd> <dt>See Also:</dt> <dd>
<a href="socketimplfactory#createSocketImpl--"><code>SocketImplFactory.createSocketImpl()</code></a>, <a href="../lang/securitymanager#checkSetFactory--"><code>SecurityManager.checkSetFactory()</code></a>
</dd> </dl>    <h3 id="setReceiveBufferSize-int-">setReceiveBufferSize</h3> <pre data-language="java">public void setReceiveBufferSize(int size)
                          throws SocketException</pre> <div>
<p>Sets a default proposed value for the <a href="socketoptions#SO_RCVBUF"><code>SO_RCVBUF</code></a> option for sockets accepted from this <code>ServerSocket</code>. The value actually set in the accepted socket must be determined by calling <a href="socket#getReceiveBufferSize--"><code>Socket.getReceiveBufferSize()</code></a> after the socket is returned by <a href="serversocket#accept--"><code>accept()</code></a>. </p>
<p> The value of <a href="socketoptions#SO_RCVBUF"><code>SO_RCVBUF</code></a> is used both to set the size of the internal socket receive buffer, and to set the size of the TCP receive window that is advertized to the remote peer. </p>
<p> It is possible to change the value subsequently, by calling <a href="socket#setReceiveBufferSize-int-"><code>Socket.setReceiveBufferSize(int)</code></a>. However, if the application wishes to allow a receive window larger than 64K bytes, as defined by RFC1323 then the proposed value must be set in the ServerSocket <b>before</b> it is bound to a local address. This implies, that the ServerSocket must be created with the no-argument constructor, then setReceiveBufferSize() must be called and lastly the ServerSocket is bound to an address by calling bind(). </p>
<p> Failure to do this will not cause an error, and the buffer size may be set to the requested value but the TCP receive window in sockets accepted from this ServerSocket will be no larger than 64K bytes.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>size</code> - the size to which to set the receive buffer size. This value must be greater than 0.</dd> <dt>Throws:</dt> <dd>
<code><a href="socketexception">SocketException</a></code> - if there is an error in the underlying protocol, such as a TCP error.</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if the value is 0 or is negative.</dd> <dt>Since:</dt> <dd>1.4</dd> <dt>See Also:</dt> <dd><a href="serversocket#getReceiveBufferSize--"><code>getReceiveBufferSize()</code></a></dd> </dl>    <h3 id="getReceiveBufferSize--">getReceiveBufferSize</h3> <pre data-language="java">public int getReceiveBufferSize()
                         throws SocketException</pre> <div>
<p>Gets the value of the <a href="socketoptions#SO_RCVBUF"><code>SO_RCVBUF</code></a> option for this <code>ServerSocket</code>, that is the proposed buffer size that will be used for Sockets accepted from this <code>ServerSocket</code>. </p>
<p>Note, the value actually set in the accepted socket is determined by calling <a href="socket#getReceiveBufferSize--"><code>Socket.getReceiveBufferSize()</code></a>.</p>
</div> <dl> <dt>Returns:</dt> <dd>the value of the <a href="socketoptions#SO_RCVBUF"><code>SO_RCVBUF</code></a> option for this <code>Socket</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="socketexception">SocketException</a></code> - if there is an error in the underlying protocol, such as a TCP error.</dd> <dt>Since:</dt> <dd>1.4</dd> <dt>See Also:</dt> <dd><a href="serversocket#setReceiveBufferSize-int-"><code>setReceiveBufferSize(int)</code></a></dd> </dl>    <h3 id="setPerformancePreferences-int-int-int-">setPerformancePreferences</h3> <pre data-language="java">public void setPerformancePreferences(int connectionTime,
                                      int latency,
                                      int bandwidth)</pre> <div>
<p>Sets performance preferences for this ServerSocket. </p>
<p> Sockets use the TCP/IP protocol by default. Some implementations may offer alternative protocols which have different performance characteristics than TCP/IP. This method allows the application to express its own preferences as to how these tradeoffs should be made when the implementation chooses from the available protocols. </p>
<p> Performance preferences are described by three integers whose values indicate the relative importance of short connection time, low latency, and high bandwidth. The absolute values of the integers are irrelevant; in order to choose a protocol the values are simply compared, with larger values indicating stronger preferences. If the application prefers short connection time over both low latency and high bandwidth, for example, then it could invoke this method with the values <code>(1, 0, 0)</code>. If the application prefers high bandwidth above low latency, and low latency above short connection time, then it could invoke this method with the values <code>(0, 1, 2)</code>. </p>
<p> Invoking this method after this socket has been bound will have no effect. This implies that in order to use this capability requires the socket to be created with the no-argument constructor.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>connectionTime</code> - An <code>int</code> expressing the relative importance of a short connection time</dd> <dd>
<code>latency</code> - An <code>int</code> expressing the relative importance of low latency</dd> <dd>
<code>bandwidth</code> - An <code>int</code> expressing the relative importance of high bandwidth</dd> <dt>Since:</dt> <dd>1.5</dd> </dl>     <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993&ndash;2017, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    
  </p>
</div>
