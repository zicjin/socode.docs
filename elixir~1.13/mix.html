<h1>   <span translate="no">Mix</span>  </h1> <section id="moduledoc"> <p>Mix is a build tool that provides tasks for creating, compiling, and testing Elixir projects, managing its dependencies, and more.</p>
<h2 id="module-mix-project" class="section-heading">  Mix.Project </h2> <p>The foundation of Mix is a project. A project can be defined by using <a href="mix.project"><code class="inline">Mix.Project</code></a> in a module, usually placed in a file named <code class="inline">mix.exs</code>:</p>
<pre data-language="elixir">defmodule MyApp.MixProject do
  use Mix.Project

  def project do
    [
      app: :my_app,
      version: "1.0.0"
    ]
  end
end</pre>
<p>See the <a href="mix.project"><code class="inline">Mix.Project</code></a> module for detailed documentation on Mix projects.</p>
<p>Once the project is defined, a number of default Mix tasks can be run directly from the command line:</p>
<ul>
<li>
<a href="mix.tasks.compile"><code class="inline">mix compile</code></a> - compiles the current project</li>
<li>
<a href="mix.tasks.test"><code class="inline">mix test</code></a> - runs tests for the given project</li>
<li>
<a href="mix.tasks.run"><code class="inline">mix run</code></a> - runs a particular command inside the project</li>
</ul>
<p>Each task has its own options and sometimes specific configuration to be defined in the <code class="inline">project/0</code> function. You can use <a href="mix.tasks.help"><code class="inline">mix help</code></a> to list all available tasks and <code class="inline">mix help NAME</code> to show help for a particular task.</p>
<p>The best way to get started with your first project is by calling <code class="inline">mix new my_project</code> from the command line.</p>
<h2 id="module-mix-task" class="section-heading">  Mix.Task </h2> <p>Tasks are what make Mix extensible.</p>
<p>Projects can extend Mix behaviour by adding their own tasks. For example, adding the task below inside your project will make it available to everyone that uses your project:</p>
<pre data-language="elixir">defmodule Mix.Tasks.Hello do
  use Mix.Task

  def run(_) do
    Mix.shell().info("Hello world")
  end
end</pre>
<p>The task can now be invoked with <code class="inline">mix hello</code>.</p>
<p>See the <a href="mix.task"><code class="inline">Mix.Task</code></a> behaviour for detailed documentation on Mix tasks.</p>
<h2 id="module-dependencies" class="section-heading">  Dependencies </h2> <p>Mix also manages your dependencies and integrates nicely with the <a href="https://hex.pm">Hex package manager</a>.</p>
<p>In order to use dependencies, you need to add a <code class="inline">:deps</code> key to your project configuration. We often extract the list of dependencies into its own function:</p>
<pre data-language="elixir">defmodule MyApp.MixProject do
  use Mix.Project

  def project do
    [
      app: :my_app,
      version: "1.0.0",
      deps: deps()
    ]
  end

  defp deps do
    [
      {:ecto, "~&gt; 2.0"},
      {:plug, github: "elixir-lang/plug"}
    ]
  end
end</pre>
<p>You can run <a href="mix.tasks.deps"><code class="inline">mix help deps</code></a> to learn more about dependencies in Mix.</p>
<h2 id="module-environments" class="section-heading">  Environments </h2> <p>Mix supports different environments. Environments allow developers to prepare and organize their project specifically for different scenarios. By default, Mix provides three environments:</p>
<ul>
<li>
<code class="inline">:dev</code> - the default environment</li>
<li>
<code class="inline">:test</code> - the environment <a href="mix.tasks.test"><code class="inline">mix test</code></a> runs on</li>
<li>
<code class="inline">:prod</code> - the environment your dependencies run on</li>
</ul>
<p>The environment can be changed via the command line by setting the <code class="inline">MIX_ENV</code> environment variable, for example:</p>
<pre data-language="elixir">$ MIX_ENV=prod mix run server.exs
</pre>
<p>You can also specify that certain dependencies are available only for certain environments:</p>
<pre data-language="elixir">{:some_test_dependency, "~&gt; 1.0", only: :test}</pre>
<p>The environment can be read via <a href="#env/0"><code class="inline">Mix.env/0</code></a>.</p>
<h2 id="module-targets" class="section-heading">  Targets </h2> <p>Besides environments, Mix supports targets. Targets are useful when a project needs to compile to different architectures and some of the dependencies are only available to some of them. By default, the target is <code class="inline">:host</code> but it can be set via the <code class="inline">MIX_TARGET</code> environment variable. The target can be read via <a href="#target/0"><code class="inline">Mix.target/0</code></a>.</p>
<h2 id="module-configuration" class="section-heading">  Configuration </h2> <p>Mix allows you configure the application environment of your application and of your dependencies. See the <a href="https://hexdocs.pm/elixir/1.13/Application.html"><code class="inline">Application</code></a> module to learn more about the application environment. On this section, we will focus on how to configure it at two distinct moments: build-time and runtime.</p>
<blockquote><p>Note: The application environment is discouraged for libraries. See Elixir's <a href="https://hexdocs.pm/elixir/library-guidelines.html">Library Guidelines</a> for more information.</p></blockquote>
<h3 id="module-build-time-configuration" class="section-heading">  Build-time configuration </h3> <p>Whenever you invoke a <code class="inline">mix</code> command, Mix loads the configuration in <code class="inline">config/config.exs</code>, if said file exists. It is common for the <code class="inline">config/config.exs</code> file itself to import other configuration based on the current <code class="inline">MIX_ENV</code>, such as <code class="inline">config/dev.exs</code>, <code class="inline">config/test.exs</code>, and <code class="inline">config/prod.exs</code>, by calling <a href="https://hexdocs.pm/elixir/1.13/Config.html#import_config/1"><code class="inline">Config.import_config/1</code></a>:</p>
<pre data-language="elixir">import Config
import_config "#{config_env()}.exs"</pre>
<p>We say <code class="inline">config/config.exs</code> and all imported files are build-time configuration as they are evaluated whenever you compile your code. In other words, if your configuration does something like:</p>
<pre data-language="elixir">import Config
config :my_app, :secret_key, System.fetch_env!("MY_APP_SECRET_KEY")</pre>
<p>The <code class="inline">:secret_key</code> key under <code class="inline">:my_app</code> will be computed on the host machine before your code compiles. This can be an issue if the machine compiling your code does not have access to all environment variables used to run your code, as loading the config above will fail due to the missing environment variable. Luckily, Mix also provides runtime configuration, which should be preferred and we will see next.</p>
<h3 id="module-runtime-configuration" class="section-heading">  Runtime configuration </h3> <p>To enable runtime configuration in your release, all you need to do is to create a file named <code class="inline">config/runtime.exs</code>:</p>
<pre data-language="elixir">import Config
config :my_app, :secret_key, System.fetch_env!("MY_APP_SECRET_KEY")</pre>
<p>This file will be executed whenever your Mix project. If you assemble a release with <a href="mix.tasks.release"><code class="inline">mix release</code></a>, it is also booted every time your release starts.</p>
<h2 id="module-aliases" class="section-heading">  Aliases </h2> <p>Aliases are shortcuts or tasks specific to the current project.</p>
<p>In the <a href="#module-mix-task">Mix.Task section</a>, we have defined a task that would be available to everyone using our project as a dependency. What if we wanted the task to only be available for our project? Just define an alias:</p>
<pre data-language="elixir">defmodule MyApp.MixProject do
  use Mix.Project

  def project do
    [
      app: :my_app,
      version: "1.0.0",
      aliases: aliases()
    ]
  end

  defp aliases do
    [
      c: "compile",
      hello: &amp;hello/1
    ]
  end

  defp hello(_) do
    Mix.shell().info("Hello world")
  end
end</pre>
<p>In the example above, we have defined two aliases. One is <code class="inline">mix c</code> which is a shortcut for <a href="mix.tasks.compile"><code class="inline">mix compile</code></a>. The other is named <code class="inline">mix hello</code>, which is the equivalent to the <code class="inline">Mix.Tasks.Hello</code> we have defined in the <a href="#module-mix-task">Mix.Task section</a>.</p>
<p>Aliases may also be lists, specifying multiple tasks to be run consecutively:</p>
<pre data-language="elixir">[all: [&amp;hello/1, "deps.get --only #{Mix.env()}", "compile"]]</pre>
<p>In the example above, we have defined an alias named <code class="inline">mix all</code>, that prints "Hello world", then fetches dependencies specific to the current environment, and compiles the project.</p>
<p>Aliases can also be used to augment existing tasks. Let's suppose you want to augment <a href="mix.tasks.clean"><code class="inline">mix clean</code></a> to clean another directory Mix does not know about:</p>
<pre data-language="elixir">[clean: ["clean", &amp;clean_extra/1]]</pre>
<p>Where <code class="inline">&amp;clean_extra/1</code> would be a function in your <code class="inline">mix.exs</code> with extra cleanup logic.</p>
<p>Arguments given to the alias will be appended to the arguments of the last task in the list. Except when overriding an existing task. In this case, the arguments will be given to the original task, in order to preserve semantics. For example, in the <code class="inline">:clean</code> alias above, the arguments given to the alias will be passed to "clean" and not to <code class="inline">clean_extra/1</code>.</p>
<p>Aliases defined in the current project do not affect its dependencies and aliases defined in dependencies are not accessible from the current project.</p>
<p>Aliases can be used very powerfully to also run Elixir scripts and shell commands, for example:</p>
<pre data-language="elixir"># priv/hello1.exs
IO.puts("Hello One")

# priv/hello2.exs
IO.puts("Hello Two")

# priv/world.sh
#!/bin/sh
echo "world!"

# mix.exs
defp aliases do
  [
    some_alias: ["hex.info", "run priv/hello1.exs", "cmd priv/world.sh"]
  ]
end</pre>
<p>In the example above we have created the alias <code class="inline">some_alias</code> that will run the task <code class="inline">mix hex.info</code>, then <a href="mix.tasks.run"><code class="inline">mix run</code></a> to run an Elixir script, then <a href="mix.tasks.cmd"><code class="inline">mix cmd</code></a> to execute a command line shell script. This shows how powerful aliases mixed with Mix tasks can be.</p>
<p>Mix tasks are designed to run only once. This prevents the same task from being executed multiple times. For example, if there are several tasks depending on <a href="mix.tasks.compile"><code class="inline">mix compile</code></a>, the code will be compiled once. Tasks can be executed again if they are explicitly reenabled using <a href="mix.task#reenable/1"><code class="inline">Mix.Task.reenable/1</code></a>:</p>
<pre data-language="elixir">another_alias: [
  "format --check-formatted priv/hello1.exs",
  "cmd priv/world.sh",
  fn _ -&gt; Mix.Task.reenable("format") end,
  "format --check-formatted priv/hello2.exs"
]</pre>
<p>Some tasks are automatically reenabled though, as they are expected to be invoked multiple times. They are: <a href="mix.tasks.cmd"><code class="inline">mix cmd</code></a>, <a href="mix.tasks.do"><code class="inline">mix do</code></a>, <a href="mix.tasks.loadconfig"><code class="inline">mix loadconfig</code></a>, <a href="mix.tasks.profile.cprof"><code class="inline">mix profile.cprof</code></a>, <a href="mix.tasks.profile.eprof"><code class="inline">mix profile.eprof</code></a>, <a href="mix.tasks.profile.fprof"><code class="inline">mix profile.fprof</code></a>, <a href="mix.tasks.run"><code class="inline">mix run</code></a>, and <a href="mix.tasks.xref"><code class="inline">mix xref</code></a>.</p>
<p>It is worth mentioning that some tasks, such as in the case of the <a href="mix.tasks.format"><code class="inline">mix format</code></a> command in the example above, can accept multiple files so it could be rewritten as:</p>
<pre data-language="elixir">another_alias: ["format --check-formatted priv/hello1.exs priv/hello2.exs"]</pre>
<h2 id="module-environment-variables" class="section-heading">  Environment variables </h2> <p>Several environment variables can be used to modify Mix's behaviour.</p>
<p>Mix responds to the following variables:</p>
<ul>
<li>
<code class="inline">MIX_ARCHIVES</code> - specifies the directory into which the archives should be installed (default: <code class="inline">~/.mix/archives</code>)</li>
<li>
<code class="inline">MIX_BUILD_ROOT</code> - sets the root directory where build artifacts should be written to. For example, "_build". If <code class="inline">MIX_BUILD_PATH</code> is set, this option is ignored.</li>
<li>
<code class="inline">MIX_BUILD_PATH</code> - sets the project <a href="mix.project#build_path/0"><code class="inline">Mix.Project.build_path/0</code></a> config. This option must always point to a subdirectory inside a temporary directory. For instance, never "/tmp" or "_build" but "_build/PROD" or "/tmp/PROD", as required by Mix</li>
<li>
<code class="inline">MIX_DEPS_PATH</code> - sets the project <a href="mix.project#deps_path/0"><code class="inline">Mix.Project.deps_path/0</code></a> config for the current project (default: <code class="inline">deps</code>)</li>
<li>
<code class="inline">MIX_DEBUG</code> - outputs debug information about each task before running it</li>
<li>
<code class="inline">MIX_ENV</code> - specifies which environment should be used. See <a href="#module-environments">Environments</a>
</li>
<li>
<code class="inline">MIX_TARGET</code> - specifies which target should be used. See <a href="#module-targets">Targets</a>
</li>
<li>
<code class="inline">MIX_EXS</code> - changes the full path to the <code class="inline">mix.exs</code> file</li>
<li>
<code class="inline">MIX_HOME</code> - path to Mix's home directory, stores configuration files and scripts used by Mix (default: <code class="inline">~/.mix</code>)</li>
<li>
<code class="inline">MIX_INSTALL_DIR</code> - (since v1.12.0) specifies directory where <a href="#install/2"><code class="inline">Mix.install/2</code></a> keeps install cache</li>
<li>
<code class="inline">MIX_INSTALL_FORCE</code> - (since v1.13.0) runs <a href="#install/2"><code class="inline">Mix.install/2</code></a> with empty install cache</li>
<li>
<code class="inline">MIX_PATH</code> - appends extra code paths</li>
<li>
<code class="inline">MIX_QUIET</code> - does not print information messages to the terminal</li>
<li>
<code class="inline">MIX_REBAR</code> - path to rebar command that overrides the one Mix installs (default: <code class="inline">~/.mix/rebar</code>)</li>
<li>
<code class="inline">MIX_REBAR3</code> - path to rebar3 command that overrides the one Mix installs (default: <code class="inline">~/.mix/rebar3</code>)</li>
<li>
<code class="inline">MIX_XDG</code> - asks Mix to follow the <a href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html">XDG Directory Specification</a> for its home directory and configuration files. This behaviour needs to be opt-in due to backwards compatibility. <code class="inline">MIX_HOME</code> has higher preference than <code class="inline">MIX_XDG</code>. If none of the variables are set, the default directory <code class="inline">~/.mix</code> will be used</li>
</ul>
<p>Environment variables that are not meant to hold a value (and act basically as flags) should be set to either <code class="inline">1</code> or <code class="inline">true</code>, for example:</p>
<pre data-language="elixir">$ MIX_DEBUG=1 mix compile
</pre> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#compilers/0" translate="no">compilers()</a> </dt> <dd class="summary-synopsis"><p>Returns the default compilers used by Mix.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#debug/1" translate="no">debug(debug)</a> </dt> <dd class="summary-synopsis"><p>Sets Mix debug mode.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#debug?/0" translate="no">debug?()</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if Mix is in debug mode, <code class="inline">false</code> otherwise.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#env/0" translate="no">env()</a> </dt> <dd class="summary-synopsis"><p>Returns the current Mix environment.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#env/1" translate="no">env(env)</a> </dt> <dd class="summary-synopsis"><p>Changes the current Mix environment to <code class="inline">env</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#install/2" translate="no">install(deps, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Installs and starts dependencies.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#installed?/0" translate="no">installed?()</a> </dt> <dd class="summary-synopsis"><p>Returns whether <a href="#install/2"><code class="inline">Mix.install/2</code></a> was called in the current node.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#path_for/1" translate="no">path_for(atom)</a> </dt> <dd class="summary-synopsis"><p>The path for local archives or escripts.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#raise/1" translate="no">raise(message)</a> </dt> <dd class="summary-synopsis"><p>Raises a Mix error that is nicely formatted, defaulting to exit status <code class="inline">1</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#raise/2" translate="no">raise(message, opts)</a> </dt> <dd class="summary-synopsis"><p>Raises a Mix error that is nicely formatted.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#shell/0" translate="no">shell()</a> </dt> <dd class="summary-synopsis"><p>Returns the current shell.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#shell/1" translate="no">shell(shell)</a> </dt> <dd class="summary-synopsis"><p>Sets the current shell.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#target/0" translate="no">target()</a> </dt> <dd class="summary-synopsis"><p>Returns the Mix target.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#target/1" translate="no">target(target)</a> </dt> <dd class="summary-synopsis"><p>Changes the current Mix target to <code class="inline">target</code>.</p></dd> </div> </dl> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="compilers/0">compilers()<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/mix/lib/mix.ex#L408" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec compilers() :: [atom()]</pre> </div> <p>Returns the default compilers used by Mix.</p>
<p>It can be used in your <code class="inline">mix.exs</code> to prepend or append new compilers to Mix:</p>
<pre data-language="elixir">def project do
  [compilers: Mix.compilers() ++ [:foo, :bar]]
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="debug/1">debug(debug)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/mix/lib/mix.ex#L483" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec debug(boolean()) :: :ok</pre> </div> <p>Sets Mix debug mode.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="debug?/0">debug?()<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/mix/lib/mix.ex#L475" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec debug?() :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if Mix is in debug mode, <code class="inline">false</code> otherwise.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="env/0">env()<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/mix/lib/mix.ex#L357" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec env() :: atom()</pre> </div> <p>Returns the current Mix environment.</p>
<p>This function should not be used at runtime in application code (as opposed to infrastructure and build code like Mix tasks). Mix is a build tool and may not be available after the code is compiled (for example in a release).</p>
<p>To differentiate the program behavior depending on the environment, it is recommended to use application environment through <a href="https://hexdocs.pm/elixir/1.13/Application.html#get_env/3"><code class="inline">Application.get_env/3</code></a>. Proper configuration can be set in config files, often per-environment (see the <a href="https://hexdocs.pm/elixir/1.13/Config.html"><code class="inline">Config</code></a> module for more information).</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="env/1">env(env)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/mix/lib/mix.ex#L372" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec env(atom()) :: :ok</pre> </div> <p>Changes the current Mix environment to <code class="inline">env</code>.</p>
<p>Be careful when invoking this function as any project configuration won't be reloaded.</p>
<p>This function should not be used at runtime in application code (see <a href="#env/0"><code class="inline">env/0</code></a> for more information).</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="install/2">install(deps, opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/mix/lib/mix.ex#L630" class="source">Source</a>
</h3> <section class="docstring"> <p>Installs and starts dependencies.</p>
<p>The given <code class="inline">deps</code> should be in the same format as defined in a regular Mix project. See <a href="mix.tasks.deps"><code class="inline">mix help deps</code></a> for more information. As a shortcut, an atom can be given as dependency to mean the latest version. In other words, specifying <code class="inline">:decimal</code> is the same as <code class="inline">{:decimal, "&gt;= 0.0.0"}</code>.</p>
<p>After each successful installation, a given set of dependencies is cached so starting another VM and calling <a href="#install/2"><code class="inline">Mix.install/2</code></a> with the same dependencies will avoid unnecessary downloads and compilations. The location of the cache directory can be controlled using the <code class="inline">MIX_INSTALL_DIR</code> environment variable.</p>
<p>This function can only be called outside of a Mix project and only with the same dependencies in the given VM.</p>
<p><strong>Note:</strong> this feature is currently experimental and it may change in future releases.</p>
<h4 id="install/2-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:force</code> - if <code class="inline">true</code>, runs with empty install cache. This is useful when you want to update your dependencies or your install got into an inconsistent state. To use this option, you can also set the <code class="inline">MIX_INSTALL_FORCE</code> environment variable. (Default: <code class="inline">false</code>)</p></li>
<li><p><code class="inline">:verbose</code> - if <code class="inline">true</code>, prints additional debugging information (Default: <code class="inline">false</code>)</p></li>
<li><p><code class="inline">:consolidate_protocols</code> - if <code class="inline">true</code>, runs protocol consolidation via the <a href="mix.tasks.compile.protocols"><code class="inline">mix compile.protocols</code></a> task (Default: <code class="inline">true</code>)</p></li>
<li><p><code class="inline">:elixir</code> - if set, ensures the current Elixir version matches the given version requirement (Default: <code class="inline">nil</code>)</p></li>
<li><p><code class="inline">:config</code> (since v1.13.0) - a keyword list of keyword lists with application configuration to be set before the apps loaded. The configuration is part of the <a href="#install/2"><code class="inline">Mix.install/2</code></a> cache, so different configurations will lead to different apps</p></li>
<li><p><code class="inline">:system_env</code> (since v1.13.0) - a list or a map of system environment variable names as binary keys and their respective values as binaries. The system environment is made part of the <a href="#install/2"><code class="inline">Mix.install/2</code></a> cache, so different configurations will lead to different apps</p></li>
</ul>
<h4 id="install/2-examples" class="section-heading">  Examples </h4> <p>To install <code class="inline">:decimal</code> and <code class="inline">:jason</code>:</p>
<pre data-language="elixir">Mix.install([
  :decimal,
  {:jason, "~&gt; 1.0"}
])</pre>
<p>Using <code class="inline">:nx</code>, <code class="inline">:exla</code>, and configure the underlying applications and environment variables:</p>
<pre data-language="elixir">Mix.install(
  [:nx, :exla],
  config: [
    nx: [default_backend: EXLA]
  ],
  system_env: [
    {"XLA_TARGET", "cuda111"}
  ]
)</pre>
<h4 id="install/2-limitations" class="section-heading">  Limitations </h4> <p>There is one limitation to <a href="#install/2"><code class="inline">Mix.install/2</code></a>, which is actually an Elixir behaviour. If you are installing a dependency that defines a struct or macro, you cannot use the struct or macro immediately after the install call. For example, this won't work:</p>
<pre data-language="elixir">Mix.install([:decimal])
%Decimal{} = Decimal.new(42)</pre>
<p>That's because Elixir first expands all structs and all macros, and then it executes the code. This means that, by the time Elixir tries to expand the <code class="inline">%Decimal{}</code> struct, the dependency has not been installed yet.</p>
<p>Luckily this has a straightforward solution, which is move the code to inside a module:</p>
<pre data-language="elixir">Mix.install([:decimal])

defmodule Script do
  def run do
    %Decimal{} = Decimal.new(42)
  end
end

Script.run()</pre>
<p>The contents inside <code class="inline">defmodule</code> will only be expanded and executed after <a href="#install/2"><code class="inline">Mix.install/2</code></a> runs, which means that any struct, macros, and imports will be correctly handled.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="installed?/0">installed?()<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/mix/lib/mix.ex#L755" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns whether <a href="#install/2"><code class="inline">Mix.install/2</code></a> was called in the current node.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="path_for/1">path_for(atom)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/mix/lib/mix.ex#L523" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec path_for(:archives | :escripts) :: String.t()</pre> </div> <p>The path for local archives or escripts.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="raise/1">raise(message)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/mix/lib/mix.ex#L491" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec raise(binary()) :: no_return()</pre> </div> <p>Raises a Mix error that is nicely formatted, defaulting to exit status <code class="inline">1</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="raise/2">raise(message, opts)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/mix/lib/mix.ex#L505" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec raise(binary(), [{:exit_status, non_neg_integer()}]) :: no_return()</pre> </div> <p>Raises a Mix error that is nicely formatted.</p>
<h4 id="raise/2-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:exit_status</code> - defines exit status, defaults to <code class="inline">1</code>
</li></ul> </section> </section> <section class="detail"> <h3 class="detail-header" id="shell/0">shell()<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/mix/lib/mix.ex#L433" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec shell() :: module()</pre> </div> <p>Returns the current shell.</p>
<p><a href="#shell/0"><code class="inline">shell/0</code></a> can be used as a wrapper for the current shell. It contains conveniences for requesting information from the user, printing to the shell and so forth. The Mix shell is swappable (see <a href="#shell/1"><code class="inline">shell/1</code></a>), allowing developers to use a test shell that simply sends messages to the current process instead of performing IO (see <a href="mix.shell.process"><code class="inline">Mix.Shell.Process</code></a>).</p>
<p>By default, this returns <a href="mix.shell.io"><code class="inline">Mix.Shell.IO</code></a>.</p>
<h4 id="shell/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Mix.shell().info("Preparing to do something dangerous...")

if Mix.shell().yes?("Are you sure?") do
  # do something dangerous
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="shell/1">shell(shell)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/mix/lib/mix.ex#L467" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec shell(module()) :: :ok</pre> </div> <p>Sets the current shell.</p>
<p>As an argument you may pass <a href="mix.shell.io"><code class="inline">Mix.Shell.IO</code></a>, <a href="mix.shell.process"><code class="inline">Mix.Shell.Process</code></a>, <a href="mix.shell.quiet"><code class="inline">Mix.Shell.Quiet</code></a>, or any module that implements the <a href="mix.shell"><code class="inline">Mix.Shell</code></a> behaviour.</p>
<p>After calling this function, <code class="inline">shell</code> becomes the shell that is returned by <a href="#shell/0"><code class="inline">shell/0</code></a>.</p>
<h4 id="shell/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Mix.shell(Mix.Shell.IO)
:ok</pre>
<p>You can use <a href="#shell/0"><code class="inline">shell/0</code></a> and <a href="#shell/1"><code class="inline">shell/1</code></a> to temporarily switch shells, for example, if you want to run a Mix Task that normally produces a lot of output:</p>
<pre data-language="elixir">shell = Mix.shell()
Mix.shell(Mix.Shell.Quiet)

try do
  Mix.Task.run("noisy.task")
after
  Mix.shell(shell)
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="target/0">target()<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/mix/lib/mix.ex#L380" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec target() :: atom()</pre> </div> <p>Returns the Mix target.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="target/1">target(target)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/mix/lib/mix.ex#L392" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec target(atom()) :: :ok</pre> </div> <p>Changes the current Mix target to <code class="inline">target</code>.</p>
<p>Be careful when invoking this function as any project configuration won't be reloaded.</p> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/mix/1.13.4/Mix.html" class="_attribution-link" target="_blank">https://hexdocs.pm/mix/1.13.4/Mix.html</a>
  </p>
</div>
