<h1>   <span translate="no">Code.Fragment</span>  </h1> <section id="moduledoc"> <p>This module provides conveniences for analyzing fragments of textual code and extract available information whenever possible.</p>
<p>Most of the functions in this module provide a best-effort and may not be accurate under all circumstances. Read each documentation for more information.</p>
<p>This module should be considered experimental.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:position/0" translate="no">position()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#container_cursor_to_quoted/2" translate="no">container_cursor_to_quoted(fragment, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Receives a code fragment and returns a quoted expression with a cursor at the nearest argument position.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#cursor_context/2" translate="no">cursor_context(fragment, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Receives a string and returns the cursor context.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#surround_context/3" translate="no">surround_context(fragment, position, options \\ [])</a> </dt> <dd class="summary-synopsis"><p>Receives a string and returns the surround context.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:position/0">position()<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/code/fragment.ex#L13" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type position() :: {line :: pos_integer(), column :: pos_integer()}</pre> </div> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail">  <h3 class="detail-header" id="container_cursor_to_quoted/2">container_cursor_to_quoted(fragment, opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/code/fragment.ex#L818" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec container_cursor_to_quoted(
  List.Chars.t(),
  keyword()
) ::
  {:ok, Macro.t()}
  | {:error, {location :: keyword(), binary() | {binary(), binary()}, binary()}}</pre> </div> <p>Receives a code fragment and returns a quoted expression with a cursor at the nearest argument position.</p>
<p>A container is any Elixir expression starting with <code class="inline">(</code>, <code class="inline">{</code>, and <code class="inline">[</code>. This includes function calls, tuples, lists, maps, and so on. For example, take this code, which would be given as input:</p>
<pre data-language="elixir">max(some_value,</pre>
<p>This function will return the AST equivalent to:</p>
<pre data-language="elixir">max(some_value, __cursor__())</pre>
<p>In other words, this function is capable of closing any open brackets and insert the cursor position. Any content at the cursor position that is after a comma or an opening bracket is discarded. For example, if this is given as input:</p>
<pre data-language="elixir">max(some_value, another_val</pre>
<p>It will return the same AST:</p>
<pre data-language="elixir">max(some_value, __cursor__())</pre>
<p>Similarly, if only this is given:</p>
<pre data-language="elixir">max(some_va</pre>
<p>Then it returns:</p>
<pre data-language="elixir">max(__cursor__())</pre>
<p>Calls without parenthesis are also supported, as we assume the brackets are implicit.</p>
<p>Operators and anonymous functions are not containers, and therefore will be discarded. The following will all return the same AST:</p>
<pre data-language="elixir">max(some_value,
max(some_value, fn x -&gt; x end
max(some_value, 1 + another_val
max(some_value, 1 |&gt; some_fun() |&gt; another_fun</pre>
<p>On the other hand, tuples, lists, maps, etc all retain the cursor position:</p>
<pre data-language="elixir">max(some_value, [1, 2,</pre>
<p>Returns the following AST:</p>
<pre data-language="elixir">max(some_value, [1, 2, __cursor__()])</pre>
<p>Keyword lists (and do-end blocks) are also retained. The following:</p>
<pre data-language="elixir">if(some_value, do:
if(some_value, do: :token
if(some_value, do: 1 + val</pre>
<p>all return:</p>
<pre data-language="elixir">if(some_value, do: __cursor__())</pre>
<p>The AST returned by this function is not safe to evaluate but it can be analyzed and expanded.</p>
<h4 id="container_cursor_to_quoted/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Code.Fragment.container_cursor_to_quoted("max(some_value, ")
{:ok, {:max, [line: 1], [{:some_value, [line: 1], nil}, {:__cursor__, [line: 1], []}]}}</pre>
<h4 id="container_cursor_to_quoted/2-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:file</code> - the filename to be reported in case of parsing errors. Defaults to <code class="inline">"nofile"</code>.</p></li>
<li><p><code class="inline">:line</code> - the starting line of the string being parsed. Defaults to 1.</p></li>
<li><p><code class="inline">:column</code> - the starting column of the string being parsed. Defaults to 1.</p></li>
<li><p><code class="inline">:columns</code> - when <code class="inline">true</code>, attach a <code class="inline">:column</code> key to the quoted metadata. Defaults to <code class="inline">false</code>.</p></li>
<li><p><code class="inline">:token_metadata</code> - when <code class="inline">true</code>, includes token-related metadata in the expression AST, such as metadata for <code class="inline">do</code> and <code class="inline">end</code> tokens, for closing tokens, end of expressions, as well as delimiters for sigils. See <a href="macro#t:metadata/0"><code class="inline">Macro.metadata/0</code></a>. Defaults to <code class="inline">false</code>.</p></li>
</ul> </section> </section> <section class="detail">  <h3 class="detail-header" id="cursor_context/2">cursor_context(fragment, opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/code/fragment.ex#L133" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec cursor_context(
  List.Chars.t(),
  keyword()
) ::
  {:alias, charlist()}
  | {:dot, inside_dot, charlist()}
  | {:dot_arity, inside_dot, charlist()}
  | {:dot_call, inside_dot, charlist()}
  | :expr
  | {:local_or_var, charlist()}
  | {:local_arity, charlist()}
  | {:local_call, charlist()}
  | {:module_attribute, charlist()}
  | {:operator, charlist()}
  | {:operator_arity, charlist()}
  | {:operator_call, charlist()}
  | :none
  | {:sigil, charlist()}
  | {:struct, charlist()}
  | {:unquoted_atom, charlist()}
when inside_dot:
       {:alias, charlist()}
       | {:dot, inside_dot, charlist()}
       | {:module_attribute, charlist()}
       | {:unquoted_atom, charlist()}
       | {:var, charlist()}</pre> </div> <p>Receives a string and returns the cursor context.</p>
<p>This function receives a string with an Elixir code fragment, representing a cursor position, and based on the string, it provides contextual information about said position. The return of this function can then be used to provide tips, suggestions, and autocompletion functionality.</p>
<p>This function provides a best-effort detection and may not be accurate under all circumstances. See the "Limitations" section below.</p>
<p>Consider adding a catch-all clause when handling the return type of this function as new cursor information may be added in future releases.</p>
<h4 id="cursor_context/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Code.Fragment.cursor_context("")
:expr

iex&gt; Code.Fragment.cursor_context("hello_wor")
{:local_or_var, 'hello_wor'}</pre>
<h4 id="cursor_context/2-return-values" class="section-heading">  Return values </h4> <ul>
<li><p><code class="inline">{:alias, charlist}</code> - the context is an alias, potentially a nested one, such as <code class="inline">Hello.Wor</code> or <code class="inline">HelloWor</code></p></li>
<li><p><code class="inline">{:dot, inside_dot, charlist}</code> - the context is a dot where <code class="inline">inside_dot</code> is either a <code class="inline">{:var, charlist}</code>, <code class="inline">{:alias, charlist}</code>, <code class="inline">{:module_attribute, charlist}</code>, <code class="inline">{:unquoted_atom, charlist}</code> or a <code class="inline">dot</code> itself. If a var is given, this may either be a remote call or a map field access. Examples are <code class="inline">Hello.wor</code>, <code class="inline">:hello.wor</code>, <code class="inline">hello.wor</code>, <code class="inline">Hello.nested.wor</code>, <code class="inline">hello.nested.wor</code>, and <code class="inline">@hello.world</code></p></li>
<li><p><code class="inline">{:dot_arity, inside_dot, charlist}</code> - the context is a dot arity where <code class="inline">inside_dot</code> is either a <code class="inline">{:var, charlist}</code>, <code class="inline">{:alias, charlist}</code>, <code class="inline">{:module_attribute, charlist}</code>, <code class="inline">{:unquoted_atom, charlist}</code> or a <code class="inline">dot</code> itself. If a var is given, it must be a remote arity. Examples are <code class="inline">Hello.world/</code>, <code class="inline">:hello.world/</code>, <code class="inline">hello.world/2</code>, and <code class="inline">@hello.world/2</code></p></li>
<li><p><code class="inline">{:dot_call, inside_dot, charlist}</code> - the context is a dot call. This means parentheses or space have been added after the expression. where <code class="inline">inside_dot</code> is either a <code class="inline">{:var, charlist}</code>, <code class="inline">{:alias, charlist}</code>, <code class="inline">{:module_attribute, charlist}</code>, <code class="inline">{:unquoted_atom, charlist}</code> or a <code class="inline">dot</code> itself. If a var is given, it must be a remote call. Examples are <code class="inline">Hello.world(</code>, <code class="inline">:hello.world(</code>, <code class="inline">Hello.world</code>, <code class="inline">hello.world(</code>, <code class="inline">hello.world</code>, and <code class="inline">@hello.world(</code></p></li>
<li><p><code class="inline">:expr</code> - may be any expression. Autocompletion may suggest an alias, local or var</p></li>
<li><p><code class="inline">{:local_or_var, charlist}</code> - the context is a variable or a local (import or local) call, such as <code class="inline">hello_wor</code></p></li>
<li><p><code class="inline">{:local_arity, charlist}</code> - the context is a local (import or local) arity, such as <code class="inline">hello_world/</code></p></li>
<li><p><code class="inline">{:local_call, charlist}</code> - the context is a local (import or local) call, such as <code class="inline">hello_world(</code> and <code class="inline">hello_world</code></p></li>
<li><p><code class="inline">{:module_attribute, charlist}</code> - the context is a module attribute, such as <code class="inline">@hello_wor</code></p></li>
<li><p><code class="inline">{:operator, charlist}</code> - the context is an operator, such as <code class="inline">+</code> or <code class="inline">==</code>. Note textual operators, such as <code class="inline">when</code> do not appear as operators but rather as <code class="inline">:local_or_var</code>. <code class="inline">@</code> is never an <code class="inline">:operator</code> and always a <code class="inline">:module_attribute</code></p></li>
<li><p><code class="inline">{:operator_arity, charlist}</code> - the context is an operator arity, which is an operator followed by /, such as <code class="inline">+/</code>, <code class="inline">not/</code> or <code class="inline">when/</code></p></li>
<li><p><code class="inline">{:operator_call, charlist}</code> - the context is an operator call, which is an operator followed by space, such as <code class="inline">left +</code>, <code class="inline">not</code> or <code class="inline">x when</code></p></li>
<li><p><code class="inline">:none</code> - no context possible</p></li>
<li><p><code class="inline">{:sigil, charlist}</code> - the context is a sigil. It may be either the beginning of a sigil, such as <code class="inline">~</code> or <code class="inline">~s</code>, or an operator starting with <code class="inline">~</code>, such as <code class="inline">~&gt;</code> and <code class="inline">~&gt;&gt;</code></p></li>
<li><p><code class="inline">{:struct, charlist}</code> - the context is a struct, such as <code class="inline">%</code>, <code class="inline">%UR</code> or <code class="inline">%URI</code></p></li>
<li><p><code class="inline">{:unquoted_atom, charlist}</code> - the context is an unquoted atom. This can be any atom or an atom representing a module</p></li>
</ul>
<h4 id="cursor_context/2-limitations" class="section-heading">  Limitations </h4> <p>The current algorithm only considers the last line of the input. This means it will also show suggestions inside strings, heredocs, etc, which is intentional as it helps with doctests, references, and more.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="surround_context/3">surround_context(fragment, position, options \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/code/fragment.ex#L511" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec surround_context(List.Chars.t(), position(), keyword()) ::
  %{begin: position(), end: position(), context: context} | :none
when context:
       {:alias, charlist()}
       | {:dot, inside_dot, charlist()}
       | {:local_or_var, charlist()}
       | {:local_arity, charlist()}
       | {:local_call, charlist()}
       | {:module_attribute, charlist()}
       | {:operator, charlist()}
       | {:unquoted_atom, charlist()},
     inside_dot:
       {:alias, charlist()}
       | {:dot, inside_dot, charlist()}
       | {:module_attribute, charlist()}
       | {:unquoted_atom, charlist()}
       | {:var, charlist()}</pre> </div> <p>Receives a string and returns the surround context.</p>
<p>This function receives a string with an Elixir code fragment and a <code class="inline">position</code>. It returns a map containing the beginning and ending of the identifier alongside its context, or <code class="inline">:none</code> if there is nothing with a known context.</p>
<p>The difference between <a href="#cursor_context/2"><code class="inline">cursor_context/2</code></a> and <a href="#surround_context/3"><code class="inline">surround_context/3</code></a> is that the former assumes the expression in the code fragment is incomplete. For example, <code class="inline">do</code> in <a href="#cursor_context/2"><code class="inline">cursor_context/2</code></a> may be a keyword or a variable or a local call, while <a href="#surround_context/3"><code class="inline">surround_context/3</code></a> assumes the expression in the code fragment is complete, therefore <code class="inline">do</code> would always be a keyword.</p>
<p>The <code class="inline">position</code> contains both the <code class="inline">line</code> and <code class="inline">column</code>, both starting with the index of 1. The column must precede the surrounding expression. For example, the expression <code class="inline">foo</code>, will return something for the columns 1, 2, and 3, but not 4:</p>
<pre data-language="elixir">foo
^ column 1

foo
 ^ column 2

foo
  ^ column 3

foo
   ^ column 4</pre>
<p>The returned map contains the column the expression starts and the first column after the expression ends.</p>
<p>Similar to <a href="#cursor_context/2"><code class="inline">cursor_context/2</code></a>, this function also provides a best-effort detection and may not be accurate under all circumstances. See the "Return values" and "Limitations" section under <a href="#cursor_context/2"><code class="inline">cursor_context/2</code></a> for more information.</p>
<h4 id="surround_context/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Code.Fragment.surround_context("foo", {1, 1})
%{begin: {1, 1}, context: {:local_or_var, 'foo'}, end: {1, 4}}</pre>
<h4 id="surround_context/3-differences-to-cursor_context-2" class="section-heading">  Differences to <a href="#cursor_context/2"><code class="inline">cursor_context/2</code></a> </h4> <p>Because <a href="#surround_context/3"><code class="inline">surround_context/3</code></a> deals with complete code, it has some difference to <a href="#cursor_context/2"><code class="inline">cursor_context/2</code></a>:</p>
<ul>
<li><p><code class="inline">dot_call</code>/<code class="inline">dot_arity</code> and <code class="inline">operator_call</code>/<code class="inline">operator_arity</code> are collapsed into <code class="inline">dot</code> and <code class="inline">operator</code> contexts respectively as there aren't any meaningful distinctions between them</p></li>
<li><p>On the other hand, this function still makes a distinction between <code class="inline">local_call</code>/<code class="inline">local_arity</code> and <code class="inline">local_or_var</code>, since the latter can be a local or variable</p></li>
<li><p><code class="inline">@</code> when not followed by any identifier is returned as <code class="inline">{:operator, '@'}</code> (in contrast to <code class="inline">{:module_attribute, ''}</code> in <a href="#cursor_context/2"><code class="inline">cursor_context/2</code></a></p></li>
<li><p>This function never returns empty sigils <code class="inline">{:sigil, ''}</code> or empty structs <code class="inline">{:struct, ''}</code> as context</p></li>
</ul> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/elixir/1.13.4/Code.Fragment.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.13.4/Code.Fragment.html</a>
  </p>
</div>
