<h1>   <span translate="no">Time</span>  </h1> <section id="moduledoc"> <p>A Time struct and functions.</p>
<p>The Time struct contains the fields hour, minute, second and microseconds. New times can be built with the <a href="#new/4"><code class="inline">new/4</code></a> function or using the <code class="inline">~T</code> (see <a href="kernel#sigil_T/2"><code class="inline">Kernel.sigil_T/2</code></a>) sigil:</p>
<pre data-language="elixir">iex&gt; ~T[23:00:07.001]
~T[23:00:07.001]</pre>
<p>Both <a href="#new/4"><code class="inline">new/4</code></a> and sigil return a struct where the time fields can be accessed directly:</p>
<pre data-language="elixir">iex&gt; time = ~T[23:00:07.001]
iex&gt; time.hour
23
iex&gt; time.microsecond
{1000, 3}</pre>
<p>The functions on this module work with the <a href="time#content"><code class="inline">Time</code></a> struct as well as any struct that contains the same fields as the <a href="time#content"><code class="inline">Time</code></a> struct, such as <a href="naivedatetime"><code class="inline">NaiveDateTime</code></a> and <a href="datetime"><code class="inline">DateTime</code></a>. Such functions expect <a href="calendar#t:time/0"><code class="inline">Calendar.time/0</code></a> in their typespecs (instead of <a href="#t:t/0"><code class="inline">t/0</code></a>).</p>
<p>Developers should avoid creating the Time structs directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries.</p>
<h2 id="module-comparing-times" class="section-heading">  Comparing times </h2> <p>Comparisons in Elixir using <a href="kernel#==/2"><code class="inline">==/2</code></a>, <a href="kernel#%3E/2"><code class="inline">&gt;/2</code></a>, <a href="kernel#%3C/2"><code class="inline">&lt;/2</code></a> and similar are structural and based on the <a href="time#content"><code class="inline">Time</code></a> struct fields. For proper comparison between times, use the <a href="#compare/2"><code class="inline">compare/2</code></a> function.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0" translate="no">t()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#add/3" translate="no">add(time, number, unit \\ :second)</a> </dt> <dd class="summary-synopsis"><p>Adds the <code class="inline">number</code> of <code class="inline">unit</code>s to the given <code class="inline">time</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#compare/2" translate="no">compare(time1, time2)</a> </dt> <dd class="summary-synopsis"><p>Compares two time structs.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#convert!/2" translate="no">convert!(time, calendar)</a> </dt> <dd class="summary-synopsis"><p>Similar to <a href="#convert/2"><code class="inline">Time.convert/2</code></a>, but raises an <a href="argumenterror"><code class="inline">ArgumentError</code></a> if the conversion between the two calendars is not possible.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#convert/2" translate="no">convert(time, calendar)</a> </dt> <dd class="summary-synopsis"><p>Converts given <code class="inline">time</code> to a different calendar.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#diff/3" translate="no">diff(time1, time2, unit \\ :second)</a> </dt> <dd class="summary-synopsis"><p>Returns the difference between two times, considering only the hour, minute, second and microsecond.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_erl!/3" translate="no">from_erl!(tuple, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Converts an Erlang time tuple to a <a href="time#content"><code class="inline">Time</code></a> struct.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_erl/3" translate="no">from_erl(tuple, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Converts an Erlang time tuple to a <a href="time#content"><code class="inline">Time</code></a> struct.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_iso8601!/2" translate="no">from_iso8601!(string, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Parses the extended "Local time" format described by <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2019</a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_iso8601/2" translate="no">from_iso8601(string, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Parses the extended "Local time" format described by <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2019</a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_seconds_after_midnight/3" translate="no">from_seconds_after_midnight(seconds, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Converts a number of seconds after midnight to a <a href="time#content"><code class="inline">Time</code></a> struct.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#new!/5" translate="no">new!(hour, minute, second, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Builds a new time.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#new/5" translate="no">new(hour, minute, second, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Builds a new time.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_erl/1" translate="no">to_erl(time)</a> </dt> <dd class="summary-synopsis"><p>Converts given <code class="inline">time</code> to an Erlang time tuple.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_iso8601/2" translate="no">to_iso8601(time, format \\ :extended)</a> </dt> <dd class="summary-synopsis"><p>Converts the given time to <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2019</a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_seconds_after_midnight/1" translate="no">to_seconds_after_midnight(time)</a> </dt> <dd class="summary-synopsis"><p>Converts a <a href="time#content"><code class="inline">Time</code></a> struct to a number of seconds after midnight.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_string/1" translate="no">to_string(time)</a> </dt> <dd class="summary-synopsis"><p>Converts the given <code class="inline">time</code> to a string.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#truncate/2" translate="no">truncate(time, precision)</a> </dt> <dd class="summary-synopsis"><p>Returns the given time with the microsecond field truncated to the given precision (<code class="inline">:microsecond</code>, <code class="inline">millisecond</code> or <code class="inline">:second</code>).</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#utc_now/1" translate="no">utc_now(calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Returns the current time in UTC.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/calendar/time.ex#L40" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type t() :: %Time{
  calendar: Calendar.calendar(),
  hour: Calendar.hour(),
  microsecond: Calendar.microsecond(),
  minute: Calendar.minute(),
  second: Calendar.second()
}</pre> </div> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail">  <h3 class="detail-header" id="add/3">add(time, number, unit \\ :second)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/calendar/time.ex#L476" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec add(Calendar.time(), integer(), System.time_unit()) :: t()</pre> </div> <p>Adds the <code class="inline">number</code> of <code class="inline">unit</code>s to the given <code class="inline">time</code>.</p>
<p>This function accepts the <code class="inline">number</code> measured according to <a href="calendar.iso"><code class="inline">Calendar.ISO</code></a>. The time is returned in the same calendar as it was given in.</p>
<p>Note the result value represents the time of day, meaning that it is cyclic, for instance, it will never go over 24 hours for the ISO calendar.</p>
<h4 id="add/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.add(~T[10:00:00], 27000)
~T[17:30:00.000000]
iex&gt; Time.add(~T[11:00:00.005], 2400)
~T[11:40:00.005000]
iex&gt; Time.add(~T[00:00:00], 86_399_999, :millisecond)
~T[23:59:59.999000]
iex&gt; Time.add(~T[17:10:05], 86400)
~T[17:10:05.000000]
iex&gt; Time.add(~T[23:00:00], -60)
~T[22:59:00.000000]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="compare/2">compare(time1, time2)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/calendar/time.ex#L535" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec compare(Calendar.time(), Calendar.time()) :: :lt | :eq | :gt</pre> </div> <p>Compares two time structs.</p>
<p>Returns <code class="inline">:gt</code> if first time is later than the second and <code class="inline">:lt</code> for vice versa. If the two times are equal <code class="inline">:eq</code> is returned.</p>
<h4 id="compare/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.compare(~T[16:04:16], ~T[16:04:28])
:lt
iex&gt; Time.compare(~T[16:04:16], ~T[16:04:16])
:eq
iex&gt; Time.compare(~T[16:04:16.01], ~T[16:04:16.001])
:gt</pre>
<p>This function can also be used to compare across more complex calendar types by considering only the time fields:</p>
<pre data-language="elixir">iex&gt; Time.compare(~N[1900-01-01 16:04:16], ~N[2015-01-01 16:04:16])
:eq
iex&gt; Time.compare(~N[2015-01-01 16:04:16], ~N[2015-01-01 16:04:28])
:lt
iex&gt; Time.compare(~N[2015-01-01 16:04:16.01], ~N[2000-01-01 16:04:16.001])
:gt</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="convert!/2">convert!(time, calendar)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/calendar/time.ex#L631" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec convert!(Calendar.time(), Calendar.calendar()) :: t()</pre> </div> <p>Similar to <a href="#convert/2"><code class="inline">Time.convert/2</code></a>, but raises an <a href="argumenterror"><code class="inline">ArgumentError</code></a> if the conversion between the two calendars is not possible.</p>
<h4 id="convert!/2-examples" class="section-heading">  Examples </h4> <p>Imagine someone implements <code class="inline">Calendar.Holocene</code>, a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year:</p>
<pre data-language="elixir">iex&gt; Time.convert!(~T[13:30:15], Calendar.Holocene)
%Time{calendar: Calendar.Holocene, hour: 13, minute: 30, second: 15, microsecond: {0, 0}}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="convert/2">convert(time, calendar)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/calendar/time.ex#L577" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec convert(Calendar.time(), Calendar.calendar()) :: {:ok, t()} | {:error, atom()}</pre> </div> <p>Converts given <code class="inline">time</code> to a different calendar.</p>
<p>Returns <code class="inline">{:ok, time}</code> if the conversion was successful, or <code class="inline">{:error, reason}</code> if it was not, for some reason.</p>
<h4 id="convert/2-examples" class="section-heading">  Examples </h4> <p>Imagine someone implements <code class="inline">Calendar.Holocene</code>, a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year:</p>
<pre data-language="elixir">iex&gt; Time.convert(~T[13:30:15], Calendar.Holocene)
{:ok, %Time{calendar: Calendar.Holocene, hour: 13, minute: 30, second: 15, microsecond: {0, 0}}}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="diff/3">diff(time1, time2, unit \\ :second)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/calendar/time.ex#L682" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec diff(Calendar.time(), Calendar.time(), System.time_unit()) :: integer()</pre> </div> <p>Returns the difference between two times, considering only the hour, minute, second and microsecond.</p>
<p>As with the <a href="#compare/2"><code class="inline">compare/2</code></a> function both <a href="time#content"><code class="inline">Time</code></a> structs and other structures containing time can be used. If for instance a <a href="naivedatetime"><code class="inline">NaiveDateTime</code></a> or <a href="datetime"><code class="inline">DateTime</code></a> is passed, only the hour, minute, second, and microsecond is considered. Any additional information about a date or time zone is ignored when calculating the difference.</p>
<p>The answer can be returned in any <code class="inline">unit</code> available from <a href="system#t:time_unit/0"><code class="inline">System.time_unit/0</code></a>. If the first time value is earlier than the second, a negative number is returned.</p>
<p>This function returns the difference in seconds where seconds are measured according to <a href="calendar.iso"><code class="inline">Calendar.ISO</code></a>.</p>
<h4 id="diff/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.diff(~T[00:29:12], ~T[00:29:10])
2

# When passing a `NaiveDateTime` the date part is ignored.
iex&gt; Time.diff(~N[2017-01-01 00:29:12], ~T[00:29:10])
2

# Two `NaiveDateTime` structs could have big differences in the date
# but only the time part is considered.
iex&gt; Time.diff(~N[2017-01-01 00:29:12], ~N[1900-02-03 00:29:10])
2

iex&gt; Time.diff(~T[00:29:12], ~T[00:29:10], :microsecond)
2_000_000
iex&gt; Time.diff(~T[00:29:10], ~T[00:29:12], :microsecond)
-2_000_000</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="from_erl!/3">from_erl!(tuple, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/calendar/time.ex#L383" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec from_erl!(:calendar.time(), Calendar.microsecond(), Calendar.calendar()) :: t()</pre> </div> <p>Converts an Erlang time tuple to a <a href="time#content"><code class="inline">Time</code></a> struct.</p>
<h4 id="from_erl!/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.from_erl!({23, 30, 15})
~T[23:30:15]
iex&gt; Time.from_erl!({23, 30, 15}, {5000, 3})
~T[23:30:15.005]
iex&gt; Time.from_erl!({24, 30, 15})
** (ArgumentError) cannot convert {24, 30, 15} to time, reason: :invalid_time</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="from_erl/3">from_erl(tuple, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/calendar/time.ex#L362" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec from_erl(:calendar.time(), Calendar.microsecond(), Calendar.calendar()) ::
  {:ok, t()} | {:error, atom()}</pre> </div> <p>Converts an Erlang time tuple to a <a href="time#content"><code class="inline">Time</code></a> struct.</p>
<h4 id="from_erl/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.from_erl({23, 30, 15}, {5000, 3})
{:ok, ~T[23:30:15.005]}
iex&gt; Time.from_erl({24, 30, 15})
{:error, :invalid_time}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="from_iso8601!/2">from_iso8601!(string, calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/calendar/time.ex#L275" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec from_iso8601!(String.t(), Calendar.calendar()) :: t()</pre> </div> <p>Parses the extended "Local time" format described by <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2019</a>.</p>
<p>Raises if the format is invalid.</p>
<h4 id="from_iso8601!/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.from_iso8601!("23:50:07,123Z")
~T[23:50:07.123]
iex&gt; Time.from_iso8601!("23:50:07.123Z")
~T[23:50:07.123]
iex&gt; Time.from_iso8601!("2015:01:23 23-50-07")
** (ArgumentError) cannot parse "2015:01:23 23-50-07" as time, reason: :invalid_format</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="from_iso8601/2">from_iso8601(string, calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/calendar/time.ex#L249" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec from_iso8601(String.t(), Calendar.calendar()) :: {:ok, t()} | {:error, atom()}</pre> </div> <p>Parses the extended "Local time" format described by <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2019</a>.</p>
<p>Time zone offset may be included in the string but they will be simply discarded as such information is not included in times.</p>
<p>As specified in the standard, the separator "T" may be omitted if desired as there is no ambiguity within this function.</p>
<h4 id="from_iso8601/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.from_iso8601("23:50:07")
{:ok, ~T[23:50:07]}
iex&gt; Time.from_iso8601("23:50:07Z")
{:ok, ~T[23:50:07]}
iex&gt; Time.from_iso8601("T23:50:07Z")
{:ok, ~T[23:50:07]}

iex&gt; Time.from_iso8601("23:50:07,0123456")
{:ok, ~T[23:50:07.012345]}
iex&gt; Time.from_iso8601("23:50:07.0123456")
{:ok, ~T[23:50:07.012345]}
iex&gt; Time.from_iso8601("23:50:07.123Z")
{:ok, ~T[23:50:07.123]}

iex&gt; Time.from_iso8601("2015:01:23 23-50-07")
{:error, :invalid_format}
iex&gt; Time.from_iso8601("23:50:07A")
{:error, :invalid_format}
iex&gt; Time.from_iso8601("23:50:07.")
{:error, :invalid_format}
iex&gt; Time.from_iso8601("23:50:61")
{:error, :invalid_time}</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="from_seconds_after_midnight/3">from_seconds_after_midnight(seconds, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/calendar/time.ex#L415" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec from_seconds_after_midnight(
  integer(),
  Calendar.microsecond(),
  Calendar.calendar()
) :: t()</pre> </div> <p>Converts a number of seconds after midnight to a <a href="time#content"><code class="inline">Time</code></a> struct.</p>
<h4 id="from_seconds_after_midnight/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.from_seconds_after_midnight(10_000)
~T[02:46:40]
iex&gt; Time.from_seconds_after_midnight(30_000, {5000, 3})
~T[08:20:00.005]
iex&gt; Time.from_seconds_after_midnight(-1)
~T[23:59:59]
iex&gt; Time.from_seconds_after_midnight(100_000)
~T[03:46:40]</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="new!/5">new!(hour, minute, second, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/calendar/time.ex#L171" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec new!(
  Calendar.hour(),
  Calendar.minute(),
  Calendar.second(),
  Calendar.microsecond() | non_neg_integer(),
  Calendar.calendar()
) :: t()</pre> </div> <p>Builds a new time.</p>
<p>Expects all values to be integers. Returns <code class="inline">time</code> if each entry fits its appropriate range, raises if the time is invalid.</p>
<p>Microseconds can also be given with a precision, which must be an integer between 0 and 6.</p>
<p>The built-in calendar does not support leap seconds.</p>
<h4 id="new!/5-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.new!(0, 0, 0, 0)
~T[00:00:00.000000]
iex&gt; Time.new!(23, 59, 59, 999_999)
~T[23:59:59.999999]
iex&gt; Time.new!(24, 59, 59, 999_999)
** (ArgumentError) cannot build time, reason: :invalid_time</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="new/5">new(hour, minute, second, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/calendar/time.ex#L117" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec new(
  Calendar.hour(),
  Calendar.minute(),
  Calendar.second(),
  Calendar.microsecond() | non_neg_integer(),
  Calendar.calendar()
) :: {:ok, t()} | {:error, atom()}</pre> </div> <p>Builds a new time.</p>
<p>Expects all values to be integers. Returns <code class="inline">{:ok, time}</code> if each entry fits its appropriate range, returns <code class="inline">{:error, reason}</code> otherwise.</p>
<p>Microseconds can also be given with a precision, which must be an integer between 0 and 6.</p>
<p>The built-in calendar does not support leap seconds.</p>
<h4 id="new/5-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.new(0, 0, 0, 0)
{:ok, ~T[00:00:00.000000]}
iex&gt; Time.new(23, 59, 59, 999_999)
{:ok, ~T[23:59:59.999999]}

iex&gt; Time.new(24, 59, 59, 999_999)
{:error, :invalid_time}
iex&gt; Time.new(23, 60, 59, 999_999)
{:error, :invalid_time}
iex&gt; Time.new(23, 59, 60, 999_999)
{:error, :invalid_time}
iex&gt; Time.new(23, 59, 59, 1_000_000)
{:error, :invalid_time}

# Invalid precision
Time.new(23, 59, 59, {999_999, 10})
{:error, :invalid_time}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_erl/1">to_erl(time)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/calendar/time.ex#L344" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_erl(Calendar.time()) :: :calendar.time()</pre> </div> <p>Converts given <code class="inline">time</code> to an Erlang time tuple.</p>
<p>WARNING: Loss of precision may occur, as Erlang time tuples only contain hours/minutes/seconds.</p>
<h4 id="to_erl/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.to_erl(~T[23:30:15.999])
{23, 30, 15}

iex&gt; Time.to_erl(~N[2010-04-17 23:30:15.999])
{23, 30, 15}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="to_iso8601/2">to_iso8601(time, format \\ :extended)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/calendar/time.ex#L309" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_iso8601(Calendar.time(), :extended | :basic) :: String.t()</pre> </div> <p>Converts the given time to <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2019</a>.</p>
<p>By default, <a href="#to_iso8601/2"><code class="inline">Time.to_iso8601/2</code></a> returns times formatted in the "extended" format, for human readability. It also supports the "basic" format through passing the <code class="inline">:basic</code> option.</p>
<h3 id="to_iso8601/2-examples" class="section-heading">  Examples </h3> <pre data-language="elixir">iex&gt; Time.to_iso8601(~T[23:00:13])
"23:00:13"

iex&gt; Time.to_iso8601(~T[23:00:13.001])
"23:00:13.001"

iex&gt; Time.to_iso8601(~T[23:00:13.001], :basic)
"230013.001"

iex&gt; Time.to_iso8601(~N[2010-04-17 23:00:13])
"23:00:13"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_seconds_after_midnight/1">to_seconds_after_midnight(time)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/calendar/time.ex#L446" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_seconds_after_midnight(Calendar.time()) :: {integer(), non_neg_integer()}</pre> </div> <p>Converts a <a href="time#content"><code class="inline">Time</code></a> struct to a number of seconds after midnight.</p>
<p>The returned value is a two-element tuple with the number of seconds and microseconds.</p>
<h4 id="to_seconds_after_midnight/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.to_seconds_after_midnight(~T[23:30:15])
{84615, 0}
iex&gt; Time.to_seconds_after_midnight(~N[2010-04-17 23:30:15.999])
{84615, 999000}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_string/1">to_string(time)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/calendar/time.ex#L200" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_string(Calendar.time()) :: String.t()</pre> </div> <p>Converts the given <code class="inline">time</code> to a string.</p>
<h3 id="to_string/1-examples" class="section-heading">  Examples </h3> <pre data-language="elixir">iex&gt; Time.to_string(~T[23:00:00])
"23:00:00"
iex&gt; Time.to_string(~T[23:00:00.001])
"23:00:00.001"
iex&gt; Time.to_string(~T[23:00:00.123456])
"23:00:00.123456"

iex&gt; Time.to_string(~N[2015-01-01 23:00:00.001])
"23:00:00.001"
iex&gt; Time.to_string(~N[2015-01-01 23:00:00.123456])
"23:00:00.123456"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="truncate/2">truncate(time, precision)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/calendar/time.ex#L737" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec truncate(t(), :microsecond | :millisecond | :second) :: t()</pre> </div> <p>Returns the given time with the microsecond field truncated to the given precision (<code class="inline">:microsecond</code>, <code class="inline">millisecond</code> or <code class="inline">:second</code>).</p>
<p>The given time is returned unchanged if it already has lower precision than the given precision.</p>
<h4 id="truncate/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Time.truncate(~T[01:01:01.123456], :microsecond)
~T[01:01:01.123456]

iex&gt; Time.truncate(~T[01:01:01.123456], :millisecond)
~T[01:01:01.123]

iex&gt; Time.truncate(~T[01:01:01.123456], :second)
~T[01:01:01]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="utc_now/1">utc_now(calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.13.4/lib/elixir/lib/calendar/time.ex#L63" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec utc_now(Calendar.calendar()) :: t()</pre> </div> <p>Returns the current time in UTC.</p>
<h4 id="utc_now/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; time = Time.utc_now()
iex&gt; time.hour &gt;= 0
true</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/elixir/1.13.4/Time.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.13.4/Time.html</a>
  </p>
</div>
