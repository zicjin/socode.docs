<h1>comments_template( string $file = '/comments.php', bool $separate_comments = false )</h1>  <section> <p>Loads the comment template specified in $file.</p> </section> <div class="content-toc">  <section> <h2 id="description">Description</h2> <p>Will not display the comments template if not on single post or page, or if the post does not have comments.</p> <p>Uses the WordPress database object to query for the comments. The comments are passed through the <a href="../hooks/comments_array">‘comments_array’</a> filter hook with the list of comments and the post ID respectively.</p> <p>The <code>$file</code> path is passed through a filter hook called <a href="../hooks/comments_template">‘comments_template’</a>, which includes the TEMPLATEPATH and $file combined. Tries the $filtered path first and if it fails it will require the default comment template from the default theme. If either does not exist, then the WordPress process will be halted. It is advised for that reason, that the default theme is not deleted.</p> <p>Will not try to get the comments if the post has none.</p> </section>  <section> <h2 id="parameters">Parameters</h2> <dl> <dt>$file</dt> <dd> <p class="desc"> <span class="type">(<span class="string">string</span>)</span> <span class="required">(Optional)</span> <span class="description"> The file to load. </span> </p> <p class="default">Default value: '/comments.php'</p> </dd> <dt>$separate_comments</dt> <dd> <p class="desc"> <span class="type">(<span class="bool">bool</span>)</span> <span class="required">(Optional)</span> <span class="description"> Whether to separate the comments by comment type. </span> </p> <p class="default">Default value: false</p> </dd> </dl> </section>  <section> <h2 id="source">Source</h2> <p> File: <a href="https://developer.wordpress.org/reference/files/wp-includes/comment-template.php/">wp-includes/comment-template.php</a> </p> <pre data-language="php">function comments_template( $file = '/comments.php', $separate_comments = false ) {
	global $wp_query, $withcomments, $post, $wpdb, $id, $comment, $user_login, $user_identity, $overridden_cpage;

	if ( ! ( is_single() || is_page() || $withcomments ) || empty( $post ) ) {
		return;
	}

	if ( empty( $file ) ) {
		$file = '/comments.php';
	}

	$req = get_option( 'require_name_email' );

	/*
	 * Comment author information fetched from the comment cookies.
	 */
	$commenter = wp_get_current_commenter();

	/*
	 * The name of the current comment author escaped for use in attributes.
	 * Escaped by sanitize_comment_cookies().
	 */
	$comment_author = $commenter['comment_author'];

	/*
	 * The email address of the current comment author escaped for use in attributes.
	 * Escaped by sanitize_comment_cookies().
	 */
	$comment_author_email = $commenter['comment_author_email'];

	/*
	 * The URL of the current comment author escaped for use in attributes.
	 */
	$comment_author_url = esc_url( $commenter['comment_author_url'] );

	$comment_args = array(
		'orderby'                   =&gt; 'comment_date_gmt',
		'order'                     =&gt; 'ASC',
		'status'                    =&gt; 'approve',
		'post_id'                   =&gt; $post-&gt;ID,
		'no_found_rows'             =&gt; false,
		'update_comment_meta_cache' =&gt; false, // We lazy-load comment meta for performance.
	);

	if ( get_option( 'thread_comments' ) ) {
		$comment_args['hierarchical'] = 'threaded';
	} else {
		$comment_args['hierarchical'] = false;
	}

	if ( is_user_logged_in() ) {
		$comment_args['include_unapproved'] = array( get_current_user_id() );
	} else {
		$unapproved_email = wp_get_unapproved_comment_author_email();

		if ( $unapproved_email ) {
			$comment_args['include_unapproved'] = array( $unapproved_email );
		}
	}

	$per_page = 0;
	if ( get_option( 'page_comments' ) ) {
		$per_page = (int) get_query_var( 'comments_per_page' );
		if ( 0 === $per_page ) {
			$per_page = (int) get_option( 'comments_per_page' );
		}

		$comment_args['number'] = $per_page;
		$page                   = (int) get_query_var( 'cpage' );

		if ( $page ) {
			$comment_args['offset'] = ( $page - 1 ) * $per_page;
		} elseif ( 'oldest' === get_option( 'default_comments_page' ) ) {
			$comment_args['offset'] = 0;
		} else {
			// If fetching the first page of 'newest', we need a top-level comment count.
			$top_level_query = new WP_Comment_Query();
			$top_level_args  = array(
				'count'   =&gt; true,
				'orderby' =&gt; false,
				'post_id' =&gt; $post-&gt;ID,
				'status'  =&gt; 'approve',
			);

			if ( $comment_args['hierarchical'] ) {
				$top_level_args['parent'] = 0;
			}

			if ( isset( $comment_args['include_unapproved'] ) ) {
				$top_level_args['include_unapproved'] = $comment_args['include_unapproved'];
			}

			/**
			 * Filters the arguments used in the top level comments query.
			 *
			 * @since 5.6.0
			 *
			 * @see WP_Comment_Query::__construct()
			 *
			 * @param array $top_level_args {
			 *     The top level query arguments for the comments template.
			 *
			 *     @type bool         $count   Whether to return a comment count.
			 *     @type string|array $orderby The field(s) to order by.
			 *     @type int          $post_id The post ID.
			 *     @type string|array $status  The comment status to limit results by.
			 * }
			 */
			$top_level_args = apply_filters( 'comments_template_top_level_query_args', $top_level_args );

			$top_level_count = $top_level_query-&gt;query( $top_level_args );

			$comment_args['offset'] = ( ceil( $top_level_count / $per_page ) - 1 ) * $per_page;
		}
	}

	/**
	 * Filters the arguments used to query comments in comments_template().
	 *
	 * @since 4.5.0
	 *
	 * @see WP_Comment_Query::__construct()
	 *
	 * @param array $comment_args {
	 *     Array of WP_Comment_Query arguments.
	 *
	 *     @type string|array $orderby                   Field(s) to order by.
	 *     @type string       $order                     Order of results. Accepts 'ASC' or 'DESC'.
	 *     @type string       $status                    Comment status.
	 *     @type array        $include_unapproved        Array of IDs or email addresses whose unapproved comments
	 *                                                   will be included in results.
	 *     @type int          $post_id                   ID of the post.
	 *     @type bool         $no_found_rows             Whether to refrain from querying for found rows.
	 *     @type bool         $update_comment_meta_cache Whether to prime cache for comment meta.
	 *     @type bool|string  $hierarchical              Whether to query for comments hierarchically.
	 *     @type int          $offset                    Comment offset.
	 *     @type int          $number                    Number of comments to fetch.
	 * }
	 */
	$comment_args = apply_filters( 'comments_template_query_args', $comment_args );

	$comment_query = new WP_Comment_Query( $comment_args );
	$_comments     = $comment_query-&gt;comments;

	// Trees must be flattened before they're passed to the walker.
	if ( $comment_args['hierarchical'] ) {
		$comments_flat = array();
		foreach ( $_comments as $_comment ) {
			$comments_flat[]  = $_comment;
			$comment_children = $_comment-&gt;get_children(
				array(
					'format'  =&gt; 'flat',
					'status'  =&gt; $comment_args['status'],
					'orderby' =&gt; $comment_args['orderby'],
				)
			);

			foreach ( $comment_children as $comment_child ) {
				$comments_flat[] = $comment_child;
			}
		}
	} else {
		$comments_flat = $_comments;
	}

	/**
	 * Filters the comments array.
	 *
	 * @since 2.1.0
	 *
	 * @param array $comments Array of comments supplied to the comments template.
	 * @param int   $post_ID  Post ID.
	 */
	$wp_query-&gt;comments = apply_filters( 'comments_array', $comments_flat, $post-&gt;ID );

	$comments                        = &amp;$wp_query-&gt;comments;
	$wp_query-&gt;comment_count         = count( $wp_query-&gt;comments );
	$wp_query-&gt;max_num_comment_pages = $comment_query-&gt;max_num_pages;

	if ( $separate_comments ) {
		$wp_query-&gt;comments_by_type = separate_comments( $comments );
		$comments_by_type           = &amp;$wp_query-&gt;comments_by_type;
	} else {
		$wp_query-&gt;comments_by_type = array();
	}

	$overridden_cpage = false;

	if ( '' == get_query_var( 'cpage' ) &amp;&amp; $wp_query-&gt;max_num_comment_pages &gt; 1 ) {
		set_query_var( 'cpage', 'newest' === get_option( 'default_comments_page' ) ? get_comment_pages_count() : 1 );
		$overridden_cpage = true;
	}

	if ( ! defined( 'COMMENTS_TEMPLATE' ) ) {
		define( 'COMMENTS_TEMPLATE', true );
	}

	$theme_template = STYLESHEETPATH . $file;

	/**
	 * Filters the path to the theme template file used for the comments template.
	 *
	 * @since 1.5.1
	 *
	 * @param string $theme_template The path to the theme template file.
	 */
	$include = apply_filters( 'comments_template', $theme_template );

	if ( file_exists( $include ) ) {
		require $include;
	} elseif ( file_exists( TEMPLATEPATH . $file ) ) {
		require TEMPLATEPATH . $file;
	} else { // Backward compat code will be removed in a future release.
		require ABSPATH . WPINC . '/theme-compat/comments.php';
	}
}</pre>  </section>  <section> <h2 id="related">Related</h2> <article class="uses"> <h3 id="uses">Uses</h3> <table id="uses-table">  <thead> <tr> <th>Uses</th> <th class="related-desc">Description</th> </tr> </thead> <tbody> <tr> <td> <span>wp-includes/comment-template.php:</span> <a href="../hooks/comments_template_top_level_query_args">comments_template_top_level_query_args</a> </td> <td class="related-desc"> <p>Filters the arguments used in the top level comments query.</p> </td> </tr> <tr> <td> <span>wp-includes/comment.php:</span> <a href="wp_get_unapproved_comment_author_email">wp_get_unapproved_comment_author_email()</a> </td> <td class="related-desc"> <p>Gets unapproved comment author’s email.</p> </td> </tr> <tr> <td> <span>wp-includes/comment-template.php:</span> <a href="../hooks/comments_template_query_args">comments_template_query_args</a> </td> <td class="related-desc"> <p>Filters the arguments used to query comments in <a href="comments_template">comments_template()</a>.</p> </td> </tr> <tr> <td> <span>wp-includes/class-wp-comment-query.php:</span> <a href="../classes/wp_comment_query/__construct">WP_Comment_Query::__construct()</a> </td> <td class="related-desc"> <p>Constructor.</p> </td> </tr> <tr> <td> <span>wp-includes/formatting.php:</span> <a href="esc_url">esc_url()</a> </td> <td class="related-desc"> <p>Checks and cleans a URL.</p> </td> </tr> <tr> <td> <span>wp-includes/pluggable.php:</span> <a href="is_user_logged_in">is_user_logged_in()</a> </td> <td class="related-desc"> <p>Determines whether the current visitor is a logged in user.</p> </td> </tr> <tr> <td> <span>wp-includes/query.php:</span> <a href="is_single">is_single()</a> </td> <td class="related-desc"> <p>Determines whether the query is for an existing single post.</p> </td> </tr> <tr> <td> <span>wp-includes/query.php:</span> <a href="is_page">is_page()</a> </td> <td class="related-desc"> <p>Determines whether the query is for an existing single page.</p> </td> </tr> <tr> <td> <span>wp-includes/query.php:</span> <a href="get_query_var">get_query_var()</a> </td> <td class="related-desc"> <p>Retrieves the value of a query variable in the <a href="../classes/wp_query">WP_Query</a> class.</p> </td> </tr> <tr> <td> <span>wp-includes/query.php:</span> <a href="set_query_var">set_query_var()</a> </td> <td class="related-desc"> <p>Sets the value of a query variable in the <a href="../classes/wp_query">WP_Query</a> class.</p> </td> </tr> <tr> <td> <span>wp-includes/plugin.php:</span> <a href="apply_filters">apply_filters()</a> </td> <td class="related-desc"> <p>Calls the callback functions that have been added to a filter hook.</p> </td> </tr> <tr> <td> <span>wp-includes/option.php:</span> <a href="get_option">get_option()</a> </td> <td class="related-desc"> <p>Retrieves an option value based on an option name.</p> </td> </tr> <tr> <td> <span>wp-includes/user.php:</span> <a href="get_current_user_id">get_current_user_id()</a> </td> <td class="related-desc"> <p>Gets the current user’s ID.</p> </td> </tr> <tr> <td> <span>wp-includes/comment-template.php:</span> <a href="../hooks/comments_array">comments_array</a> </td> <td class="related-desc"> <p>Filters the comments array.</p> </td> </tr> <tr> <td> <span>wp-includes/comment-template.php:</span> <a href="../hooks/comments_template">comments_template</a> </td> <td class="related-desc"> <p>Filters the path to the theme template file used for the comments template.</p> </td> </tr> <tr> <td> <span>wp-includes/comment.php:</span> <a href="wp_get_current_commenter">wp_get_current_commenter()</a> </td> <td class="related-desc"> <p>Gets current commenter’s name, email, and URL.</p> </td> </tr> <tr> <td> <span>wp-includes/comment.php:</span> <a href="separate_comments">separate_comments()</a> </td> <td class="related-desc"> <p>Separates an array of comments into an array keyed by comment_type.</p> </td> </tr> <tr> <td> <span>wp-includes/comment.php:</span> <a href="get_comment_pages_count">get_comment_pages_count()</a> </td> <td class="related-desc"> <p>Calculates the total number of comment pages.</p> </td> </tr> </tbody>

</table>   </article> </section>  <section> <h2 id="changelog">Changelog</h2> <table>  <thead> <tr> <th class="changelog-version">Version</th> <th class="changelog-desc">Description</th> </tr> </thead> <tbody> <tr> <td><a href="https://developer.wordpress.org/reference/since/1.5.0/" alt="WordPress 1.5.0">1.5.0</a></td> <td>Introduced.</td> </tr> </tbody> </table> </section>    </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://developer.wordpress.org/reference/functions/comments_template" class="_attribution-link" target="_blank">https://developer.wordpress.org/reference/functions/comments_template</a>
  </p>
</div>
