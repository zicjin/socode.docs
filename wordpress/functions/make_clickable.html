<h1>make_clickable( string $text )</h1>  <section> <p>Converts plaintext URI to HTML links.</p> </section> <div class="content-toc">  <section> <h2 id="description">Description</h2> <p>Converts URI, www and ftp, and email addresses. Finishes by fixing links within links.</p> </section>  <section> <h2 id="parameters">Parameters</h2> <dl> <dt>$text</dt> <dd> <p class="desc"> <span class="type">(<span class="string">string</span>)</span> <span class="required">(Required)</span> <span class="description">Content to convert URIs.</span> </p> </dd> </dl> </section>  <section> <h2 id="return">Return</h2> <p><span class="return-type">(string)</span> Content with converted URIs.</p> </section>  <section> <h2 id="more-information">More Information</h2> <p>This function can be fed long strings with URIs and email links and will convert them into clickable links. You are not limited to feeding it just the link text itself (see the long string in the example above).</p> </section>  <section> <h2 id="source">Source</h2> <p> File: <a href="https://developer.wordpress.org/reference/files/wp-includes/formatting.php/">wp-includes/formatting.php</a> </p> <pre data-language="php">function make_clickable( $text ) {
	$r               = '';
	$textarr         = preg_split( '/(&lt;[^&lt;&gt;]+&gt;)/', $text, -1, PREG_SPLIT_DELIM_CAPTURE ); // Split out HTML tags.
	$nested_code_pre = 0; // Keep track of how many levels link is nested inside &lt;pre&gt; or &lt;code&gt;.
	foreach ( $textarr as $piece ) {

		if ( preg_match( '|^&lt;code[\s&gt;]|i', $piece ) || preg_match( '|^&lt;pre[\s&gt;]|i', $piece ) || preg_match( '|^&lt;script[\s&gt;]|i', $piece ) || preg_match( '|^&lt;style[\s&gt;]|i', $piece ) ) {
			$nested_code_pre++;
		} elseif ( $nested_code_pre &amp;&amp; ( '&lt;/code&gt;' === strtolower( $piece ) || '&lt;/pre&gt;' === strtolower( $piece ) || '&lt;/script&gt;' === strtolower( $piece ) || '&lt;/style&gt;' === strtolower( $piece ) ) ) {
			$nested_code_pre--;
		}

		if ( $nested_code_pre || empty( $piece ) || ( '&lt;' === $piece[0] &amp;&amp; ! preg_match( '|^&lt;\s*[\w]{1,20}+://|', $piece ) ) ) {
			$r .= $piece;
			continue;
		}

		// Long strings might contain expensive edge cases...
		if ( 10000 &lt; strlen( $piece ) ) {
			// ...break it up.
			foreach ( _split_str_by_whitespace( $piece, 2100 ) as $chunk ) { // 2100: Extra room for scheme and leading and trailing paretheses.
				if ( 2101 &lt; strlen( $chunk ) ) {
					$r .= $chunk; // Too big, no whitespace: bail.
				} else {
					$r .= make_clickable( $chunk );
				}
			}
		} else {
			$ret = " $piece "; // Pad with whitespace to simplify the regexes.

			$url_clickable = '~
				([\\s(&lt;.,;:!?])                                # 1: Leading whitespace, or punctuation.
				(                                              # 2: URL.
					[\\w]{1,20}+://                                # Scheme and hier-part prefix.
					(?=\S{1,2000}\s)                               # Limit to URLs less than about 2000 characters long.
					[\\w\\x80-\\xff#%\\~/@\\[\\]*(+=&amp;$-]*+         # Non-punctuation URL character.
					(?:                                            # Unroll the Loop: Only allow puctuation URL character if followed by a non-punctuation URL character.
						[\'.,;:!?)]                                    # Punctuation URL character.
						[\\w\\x80-\\xff#%\\~/@\\[\\]*(+=&amp;$-]++         # Non-punctuation URL character.
					)*
				)
				(\)?)                                          # 3: Trailing closing parenthesis (for parethesis balancing post processing).
			~xS';
			// The regex is a non-anchored pattern and does not have a single fixed starting character.
			// Tell PCRE to spend more time optimizing since, when used on a page load, it will probably be used several times.

			$ret = preg_replace_callback( $url_clickable, '_make_url_clickable_cb', $ret );

			$ret = preg_replace_callback( '#([\s&gt;])((www|ftp)\.[\w\\x80-\\xff\#$%&amp;~/.\-;:=,?@\[\]+]+)#is', '_make_web_ftp_clickable_cb', $ret );
			$ret = preg_replace_callback( '#([\s&gt;])([.0-9a-z_+-]+)@(([0-9a-z-]+\.)+[0-9a-z]{2,})#i', '_make_email_clickable_cb', $ret );

			$ret = substr( $ret, 1, -1 ); // Remove our whitespace padding.
			$r  .= $ret;
		}
	}

	// Cleanup of accidental links within links.
	return preg_replace( '#(&lt;a([ \r\n\t]+[^&gt;]+?&gt;|&gt;))&lt;a [^&gt;]+?&gt;([^&gt;]+?)&lt;/a&gt;&lt;/a&gt;#i', '$1$3&lt;/a&gt;', $r );
}</pre>  </section>  <section> <h2 id="related">Related</h2> <article class="uses"> <h3 id="uses">Uses</h3> <table id="uses-table">  <thead> <tr> <th>Uses</th> <th class="related-desc">Description</th> </tr> </thead> <tbody> <tr> <td> <span>wp-includes/formatting.php:</span> <a href="_split_str_by_whitespace">_split_str_by_whitespace()</a> </td> <td class="related-desc"> <p>Breaks a string into chunks by splitting at whitespace characters.</p> </td> </tr> <tr> <td> <span>wp-includes/formatting.php:</span> <a href="make_clickable">make_clickable()</a> </td> <td class="related-desc"> <p>Converts plaintext URI to HTML links.</p> </td> </tr> </tbody>

</table> </article> <article class="used-by"> <h3 id="used-by">Used By</h3> <table id="used-by-table">  <thead> <tr> <th>Used By</th> <th class="related-desc">Description</th> </tr> </thead> <tbody> <tr> <td> <span>wp-includes/formatting.php:</span> <a href="make_clickable">make_clickable()</a> </td> <td class="related-desc"> <p>Converts plaintext URI to HTML links.</p> </td> </tr> </tbody>

</table> </article> </section>  <section> <h2 id="changelog">Changelog</h2> <table>  <thead> <tr> <th class="changelog-version">Version</th> <th class="changelog-desc">Description</th> </tr> </thead> <tbody> <tr> <td><a href="https://developer.wordpress.org/reference/since/0.71/" alt="WordPress 0.71">0.71</a></td> <td>Introduced.</td> </tr> </tbody> </table> </section>    </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://developer.wordpress.org/reference/functions/make_clickable" class="_attribution-link" target="_blank">https://developer.wordpress.org/reference/functions/make_clickable</a>
  </p>
</div>
