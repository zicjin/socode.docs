<h1 id="Mathematics">Mathematics</h1>
<h2 id="math-ops">
<a class="docs-heading-anchor" href="#math-ops">Mathematical Operators</a>
</h2>
<h3 id="Base.:--Tuple{Any}">
<code>Base.:-</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">-(x)</pre>
<p>Unary minus operator.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; -1
-1

julia&gt; -(2)
-2

julia&gt; -[1 2; 3 4]
2×2 Matrix{Int64}:
 -1  -2
 -3  -4</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/docs/basedocs.jl#L2133-L2151" target="_blank">source</a></section><h3 id="Base.:+">
<code>Base.:+</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">dt::Date + t::Time -&gt; DateTime</pre>
<p>The addition of a <code>Date</code> with a <code>Time</code> produces a <code>DateTime</code>. The hour, minute, second, and millisecond parts of the <code>Time</code> are used along with the year, month, and day of the <code>Date</code> to create the new <code>DateTime</code>. Non-zero microseconds or nanoseconds in the <code>Time</code> type will result in an <code>InexactError</code> being thrown.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/stdlib/Dates/src/arithmetic.jl#L12-L18" target="_blank">source</a></section><section><pre data-language="julia">+(x, y...)</pre>
<p>Addition operator. <code>x+y+z+...</code> calls this function with all arguments, i.e. <code>+(x, y, z, ...)</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; 1 + 20 + 4
25

julia&gt; +(1, 20, 4)
25</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/docs/basedocs.jl#L2117-L2130" target="_blank">source</a></section><h3 id="Base.:--Tuple{Any, Any}">
<code>Base.:-</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">-(x, y)</pre>
<p>Subtraction operator.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; 2 - 3
-1

julia&gt; -(2, 4.5)
-2.5</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/docs/basedocs.jl#L2154-L2167" target="_blank">source</a></section><h3 id="Base.:*-Tuple{Any, Vararg{Any, N} where N}">
<code>Base.:*</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">*(x, y...)</pre>
<p>Multiplication operator. <code>x*y*z*...</code> calls this function with all arguments, i.e. <code>*(x, y, z, ...)</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; 2 * 7 * 8
112

julia&gt; *(2, 7, 8)
112</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/docs/basedocs.jl#L2170-L2183" target="_blank">source</a></section><h3 id="Base.:/">
<code>Base.:/</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">/(x, y)</pre>
<p>Right division operator: multiplication of <code>x</code> by the inverse of <code>y</code> on the right. Gives floating-point results for integer arguments.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; 1/2
0.5

julia&gt; 4/2
2.0

julia&gt; 4.5/2
2.25</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/docs/basedocs.jl#L2186-L2203" target="_blank">source</a></section><h3 id="Base.:\\-Tuple{Any, Any}">
<code>Base.:\</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">\(x, y)</pre>
<p>Left division operator: multiplication of <code>y</code> by the inverse of <code>x</code> on the left. Gives floating-point results for integer arguments.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; 3 \ 6
2.0

julia&gt; inv(3) * 6
2.0

julia&gt; A = [4 3; 2 1]; x = [5, 6];

julia&gt; A \ x
2-element Vector{Float64}:
  6.5
 -7.0

julia&gt; inv(A) * x
2-element Vector{Float64}:
  6.5
 -7.0</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L571-L597" target="_blank">source</a></section><h3 id="Base.:^-Tuple{Number, Number}">
<code>Base.:^</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">^(x, y)</pre>
<p>Exponentiation operator. If <code>x</code> is a matrix, computes matrix exponentiation.</p>
<p>If <code>y</code> is an <code>Int</code> literal (e.g. <code>2</code> in <code>x^2</code> or <code>-3</code> in <code>x^-3</code>), the Julia code <code>x^y</code> is transformed by the compiler to <code>Base.literal_pow(^, x, Val(y))</code>, to enable compile-time specialization on the value of the exponent. (As a default fallback we have <code>Base.literal_pow(^, x, Val(y)) = ^(x,y)</code>, where usually <code>^ == Base.^</code> unless <code>^</code> has been defined in the calling namespace.) If <code>y</code> is a negative integer literal, then <code>Base.literal_pow</code> transforms the operation to <code>inv(x)^-y</code> by default, where <code>-y</code> is positive.</p>
<pre data-language="julia">julia&gt; 3^5
243

julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; A^3
2×2 Matrix{Int64}:
 37   54
 81  118</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/promotion.jl#L326-L354" target="_blank">source</a></section><h3 id="Base.fma">
<code>Base.fma</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">fma(x, y, z)</pre>
<p>Computes <code>x*y+z</code> without rounding the intermediate result <code>x*y</code>. On some systems this is significantly more expensive than <code>x*y+z</code>. <code>fma</code> is used to improve accuracy in certain algorithms. See <a href="#Base.muladd"><code>muladd</code></a>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/floatfuncs.jl#L311-L317" target="_blank">source</a></section><h3 id="Base.muladd">
<code>Base.muladd</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">muladd(x, y, z)</pre>
<p>Combined multiply-add: computes <code>x*y+z</code>, but allowing the add and multiply to be merged with each other or with surrounding operations for performance. For example, this may be implemented as an <a href="#Base.fma"><code>fma</code></a> if the hardware supports it efficiently. The result can be different on different machines and can also be different on the same machine due to constant propagation or other optimizations. See <a href="#Base.fma"><code>fma</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; muladd(3, 2, 1)
7

julia&gt; 3 * 2 + 1
7</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L1132-L1151" target="_blank">source</a></section><section><pre data-language="julia">muladd(A, y, z)</pre>
<p>Combined multiply-add, <code>A*y .+ z</code>, for matrix-matrix or matrix-vector multiplication. The result is always the same size as <code>A*y</code>, but <code>z</code> may be smaller, or a scalar.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>These methods require Julia 1.6 or later.</p></div>
</div>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A=[1.0 2.0; 3.0 4.0]; B=[1.0 1.0; 1.0 1.0]; z=[0, 100];

julia&gt; muladd(A, B, z)
2×2 Matrix{Float64}:
   3.0    3.0
 107.0  107.0</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/stdlib/LinearAlgebra/src/matmul.jl#L185-L203" target="_blank">source</a></section><h3 id="Base.inv-Tuple{Number}">
<code>Base.inv</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">inv(x)</pre>
<p>Return the multiplicative inverse of <code>x</code>, such that <code>x*inv(x)</code> or <code>inv(x)*x</code> yields <a href="../numbers/index#Base.one"><code>one(x)</code></a> (the multiplicative identity) up to roundoff errors.</p>
<p>If <code>x</code> is a number, this is essentially the same as <code>one(x)/x</code>, but for some types <code>inv(x)</code> may be slightly more efficient.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; inv(2)
0.5

julia&gt; inv(1 + 2im)
0.2 - 0.4im

julia&gt; inv(1 + 2im) * (1 + 2im)
1.0 + 0.0im

julia&gt; inv(2//3)
3//2</pre>
<div class="admonition is-compat">

<div class="admonition-body"><p><code>inv(::Missing)</code> requires at least Julia 1.2.</p></div>
</div>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/number.jl#L190-L216" target="_blank">source</a></section><h3 id="Base.div">
<code>Base.div</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">div(x, y)
÷(x, y)</pre>
<p>The quotient from Euclidean division. Computes <code>x/y</code>, truncated to an integer.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; 9 ÷ 4
2

julia&gt; -5 ÷ 3
-1

julia&gt; 5.0 ÷ 2
2.0</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L743-L760" target="_blank">source</a></section><h3 id="Base.fld">
<code>Base.fld</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">fld(x, y)</pre>
<p>Largest integer less than or equal to <code>x/y</code>. Equivalent to <code>div(x, y, RoundDown)</code>.</p>
<p>See also: <a href="#Base.div"><code>div</code></a></p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; fld(7.3,5.5)
1.0</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/div.jl#L73-L85" target="_blank">source</a></section><h3 id="Base.cld">
<code>Base.cld</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">cld(x, y)</pre>
<p>Smallest integer larger than or equal to <code>x/y</code>. Equivalent to <code>div(x, y, RoundUp)</code>.</p>
<p>See also: <a href="#Base.div"><code>div</code></a></p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; cld(5.5,2.2)
3.0</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/div.jl#L88-L100" target="_blank">source</a></section><h3 id="Base.mod">
<code>Base.mod</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">mod(x::Integer, r::AbstractUnitRange)</pre>
<p>Find <code>y</code> in the range <code>r</code> such that <span>$x ≡ y (mod n)$</span>, where <code>n = length(r)</code>, i.e. <code>y = mod(x - first(r), n) + first(r)</code>.</p>
<p>See also: <a href="#Base.mod1"><code>mod1</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; mod(0, Base.OneTo(3))
3

julia&gt; mod(3, 0:2)
0</pre>
<div class="admonition is-compat">

<div class="admonition-body"><p>This method requires at least Julia 1.3.</p></div>
</div>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/range.jl#L1135-L1154" target="_blank">source</a></section><section><pre data-language="julia">mod(x, y)
rem(x, y, RoundDown)</pre>
<p>The reduction of <code>x</code> modulo <code>y</code>, or equivalently, the remainder of <code>x</code> after floored division by <code>y</code>, i.e. <code>x - y*fld(x,y)</code> if computed without intermediate rounding.</p>
<p>The result will have the same sign as <code>y</code>, and magnitude less than <code>abs(y)</code> (with some exceptions, see note below).</p>
<div class="admonition is-info">

<div class="admonition-body"><p>When used with floating point values, the exact result may not be representable by the type, and so rounding error may occur. In particular, if the exact result is very close to <code>y</code>, then it may be rounded to <code>y</code>.</p></div>
</div>
<pre data-language="julia">julia&gt; mod(8, 3)
2

julia&gt; mod(9, 3)
0

julia&gt; mod(8.9, 3)
2.9000000000000004

julia&gt; mod(eps(), 3)
2.220446049250313e-16

julia&gt; mod(-eps(), 3)
3.0</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/int.jl#L218-L250" target="_blank">source</a></section><section><pre data-language="julia">rem(x::Integer, T::Type{&lt;:Integer}) -&gt; T
mod(x::Integer, T::Type{&lt;:Integer}) -&gt; T
%(x::Integer, T::Type{&lt;:Integer}) -&gt; T</pre>
<p>Find <code>y::T</code> such that <code>x</code> ≡ <code>y</code> (mod n), where n is the number of integers representable in <code>T</code>, and <code>y</code> is an integer in <code>[typemin(T),typemax(T)]</code>. If <code>T</code> can represent any integer (e.g. <code>T == BigInt</code>), then this operation corresponds to a conversion to <code>T</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; 129 % Int8
-127</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/int.jl#L521-L536" target="_blank">source</a></section><h3 id="Base.rem">
<code>Base.rem</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">rem(x, y)
%(x, y)</pre>
<p>Remainder from Euclidean division, returning a value of the same sign as <code>x</code>, and smaller in magnitude than <code>y</code>. This value is always exact.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; x = 15; y = 4;

julia&gt; x % y
3

julia&gt; x == div(x, y) * y + rem(x, y)
true</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L722-L739" target="_blank">source</a></section><h3 id="Base.Math.rem2pi">
<code>Base.Math.rem2pi</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">rem2pi(x, r::RoundingMode)</pre>
<p>Compute the remainder of <code>x</code> after integer division by <code>2π</code>, with the quotient rounded according to the rounding mode <code>r</code>. In other words, the quantity</p>
<pre data-language="julia">x - 2π*round(x/(2π),r)</pre>
<p>without any intermediate rounding. This internally uses a high precision approximation of 2π, and so will give a more accurate result than <code>rem(x,2π,r)</code></p>
<ul>
<li><p>if <code>r == RoundNearest</code>, then the result is in the interval <span>$[-π, π]$</span>. This will generally be the most accurate result. See also <a href="#Base.Rounding.RoundNearest"><code>RoundNearest</code></a>.</p></li>
<li><p>if <code>r == RoundToZero</code>, then the result is in the interval <span>$[0, 2π]$</span> if <code>x</code> is positive,. or <span>$[-2π, 0]$</span> otherwise. See also <a href="#Base.Rounding.RoundToZero"><code>RoundToZero</code></a>.</p></li>
<li><p>if <code>r == RoundDown</code>, then the result is in the interval <span>$[0, 2π]$</span>. See also <a href="#Base.Rounding.RoundDown"><code>RoundDown</code></a>.</p></li>
<li><p>if <code>r == RoundUp</code>, then the result is in the interval <span>$[-2π, 0]$</span>. See also <a href="#Base.Rounding.RoundUp"><code>RoundUp</code></a>.</p></li>
</ul>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; rem2pi(7pi/4, RoundNearest)
-0.7853981633974485

julia&gt; rem2pi(7pi/4, RoundDown)
5.497787143782138</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L959-L989" target="_blank">source</a></section><h3 id="Base.Math.mod2pi">
<code>Base.Math.mod2pi</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">mod2pi(x)</pre>
<p>Modulus after division by <code>2π</code>, returning in the range <span>$[0,2π)$</span>.</p>
<p>This function computes a floating point representation of the modulus after division by numerically exact <code>2π</code>, and is therefore not exactly the same as <code>mod(x,2π)</code>, which would compute the modulus of <code>x</code> relative to division by the floating-point number <code>2π</code>.</p>
<div class="admonition is-info">

<div class="admonition-body"><p>Depending on the format of the input value, the closest representable value to 2π may be less than 2π. For example, the expression <code>mod2pi(2π)</code> will not return <code>0</code>, because the intermediate value of <code>2*π</code> is a <code>Float64</code> and <code>2*Float64(π) &lt; 2*big(π)</code>. See <a href="#Base.Math.rem2pi"><code>rem2pi</code></a> for more refined control of this behavior.</p></div>
</div>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; mod2pi(9*pi/4)
0.7853981633974481</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L1107-L1127" target="_blank">source</a></section><h3 id="Base.divrem">
<code>Base.divrem</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">divrem(x, y, r::RoundingMode=RoundToZero)</pre>
<p>The quotient and remainder from Euclidean division. Equivalent to <code>(div(x,y,r), rem(x,y,r))</code>. Equivalently, with the default value of <code>r</code>, this call is equivalent to <code>(x÷y, x%y)</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; divrem(3,7)
(0, 3)

julia&gt; divrem(7,3)
(2, 1)</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/div.jl#L104-L119" target="_blank">source</a></section><h3 id="Base.fldmod">
<code>Base.fldmod</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">fldmod(x, y)</pre>
<p>The floored quotient and modulus after division. A convenience wrapper for <code>divrem(x, y, RoundDown)</code>. Equivalent to <code>(fld(x,y), mod(x,y))</code>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/div.jl#L181-L186" target="_blank">source</a></section><h3 id="Base.fld1">
<code>Base.fld1</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">fld1(x, y)</pre>
<p>Flooring division, returning a value consistent with <code>mod1(x,y)</code></p>
<p>See also: <a href="#Base.mod1"><code>mod1</code></a>, <a href="#Base.fldmod1"><code>fldmod1</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; x = 15; y = 4;

julia&gt; fld1(x, y)
4

julia&gt; x == fld(x, y) * y + mod(x, y)
true

julia&gt; x == (fld1(x, y) - 1) * y + mod1(x, y)
true</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L784-L804" target="_blank">source</a></section><h3 id="Base.mod1">
<code>Base.mod1</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">mod1(x, y)</pre>
<p>Modulus after flooring division, returning a value <code>r</code> such that <code>mod(r, y) == mod(x, y)</code> in the range <span>$(0, y]$</span> for positive <code>y</code> and in the range <span>$[y,0)$</span> for negative <code>y</code>.</p>
<p>See also: <a href="#Base.fld1"><code>fld1</code></a>, <a href="#Base.fldmod1"><code>fldmod1</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; mod1(4, 2)
2

julia&gt; mod1(4, 3)
1</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L764-L780" target="_blank">source</a></section><h3 id="Base.fldmod1">
<code>Base.fldmod1</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">fldmod1(x, y)</pre>
<p>Return <code>(fld1(x,y), mod1(x,y))</code>.</p>
<p>See also: <a href="#Base.fld1"><code>fld1</code></a>, <a href="#Base.mod1"><code>mod1</code></a>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L811-L817" target="_blank">source</a></section><h3 id="Base.://">
<code>Base.://</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">//(num, den)</pre>
<p>Divide two integers or rational numbers, giving a <a href="../numbers/index#Base.Rational"><code>Rational</code></a> result.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; 3 // 5
3//5

julia&gt; (3 // 5) // (2 // 1)
3//10</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/rational.jl#L47-L60" target="_blank">source</a></section><h3 id="Base.rationalize">
<code>Base.rationalize</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">rationalize([T&lt;:Integer=Int,] x; tol::Real=eps(x))</pre>
<p>Approximate floating point number <code>x</code> as a <a href="../numbers/index#Base.Rational"><code>Rational</code></a> number with components of the given integer type. The result will differ from <code>x</code> by no more than <code>tol</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; rationalize(5.6)
28//5

julia&gt; a = rationalize(BigInt, 10.3)
103//10

julia&gt; typeof(numerator(a))
BigInt</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/rational.jl#L138-L155" target="_blank">source</a></section><h3 id="Base.numerator">
<code>Base.numerator</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">numerator(x)</pre>
<p>Numerator of the rational representation of <code>x</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; numerator(2//3)
2

julia&gt; numerator(4)
4</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/rational.jl#L219-L232" target="_blank">source</a></section><h3 id="Base.denominator">
<code>Base.denominator</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">denominator(x)</pre>
<p>Denominator of the rational representation of <code>x</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; denominator(2//3)
3

julia&gt; denominator(4)
1</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/rational.jl#L236-L249" target="_blank">source</a></section><h3 id="Base.:&lt;&lt;">
<code>Base.:&lt;&lt;</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">&lt;&lt;(x, n)</pre>
<p>Left bit shift operator, <code>x &lt;&lt; n</code>. For <code>n &gt;= 0</code>, the result is <code>x</code> shifted left by <code>n</code> bits, filling with <code>0</code>s. This is equivalent to <code>x * 2^n</code>. For <code>n &lt; 0</code>, this is equivalent to <code>x &gt;&gt; -n</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; Int8(3) &lt;&lt; 2
12

julia&gt; bitstring(Int8(3))
"00000011"

julia&gt; bitstring(Int8(12))
"00001100"</pre>
<p>See also <a href="#Base.:&gt;&gt;"><code>&gt;&gt;</code></a>, <a href="#Base.:&gt;&gt;&gt;"><code>&gt;&gt;&gt;</code></a>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L604-L623" target="_blank">source</a></section><section><pre data-language="julia">&lt;&lt;(B::BitVector, n) -&gt; BitVector</pre>
<p>Left bit shift operator, <code>B &lt;&lt; n</code>. For <code>n &gt;= 0</code>, the result is <code>B</code> with elements shifted <code>n</code> positions backwards, filling with <code>false</code> values. If <code>n &lt; 0</code>, elements are shifted forwards. Equivalent to <code>B &gt;&gt; -n</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; B = BitVector([true, false, true, false, false])
5-element BitVector:
 1
 0
 1
 0
 0

julia&gt; B &lt;&lt; 1
5-element BitVector:
 0
 1
 0
 0
 0

julia&gt; B &lt;&lt; -1
5-element BitVector:
 0
 1
 0
 1
 0</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/bitarray.jl#L1321-L1355" target="_blank">source</a></section><h3 id="Base.:&gt;&gt;">
<code>Base.:&gt;&gt;</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">&gt;&gt;(x, n)</pre>
<p>Right bit shift operator, <code>x &gt;&gt; n</code>. For <code>n &gt;= 0</code>, the result is <code>x</code> shifted right by <code>n</code> bits, where <code>n &gt;= 0</code>, filling with <code>0</code>s if <code>x &gt;= 0</code>, <code>1</code>s if <code>x &lt; 0</code>, preserving the sign of <code>x</code>. This is equivalent to <code>fld(x, 2^n)</code>. For <code>n &lt; 0</code>, this is equivalent to <code>x &lt;&lt; -n</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; Int8(13) &gt;&gt; 2
3

julia&gt; bitstring(Int8(13))
"00001101"

julia&gt; bitstring(Int8(3))
"00000011"

julia&gt; Int8(-14) &gt;&gt; 2
-4

julia&gt; bitstring(Int8(-14))
"11110010"

julia&gt; bitstring(Int8(-4))
"11111100"</pre>
<p>See also <a href="#Base.:&gt;&gt;&gt;"><code>&gt;&gt;&gt;</code></a>, <a href="#Base.:&lt;&lt;"><code>&lt;&lt;</code></a>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L639-L668" target="_blank">source</a></section><section><pre data-language="julia">&gt;&gt;(B::BitVector, n) -&gt; BitVector</pre>
<p>Right bit shift operator, <code>B &gt;&gt; n</code>. For <code>n &gt;= 0</code>, the result is <code>B</code> with elements shifted <code>n</code> positions forward, filling with <code>false</code> values. If <code>n &lt; 0</code>, elements are shifted backwards. Equivalent to <code>B &lt;&lt; -n</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; B = BitVector([true, false, true, false, false])
5-element BitVector:
 1
 0
 1
 0
 0

julia&gt; B &gt;&gt; 1
5-element BitVector:
 0
 1
 0
 1
 0

julia&gt; B &gt;&gt; -1
5-element BitVector:
 0
 1
 0
 0
 0</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/bitarray.jl#L1283-L1317" target="_blank">source</a></section><h3 id="Base.:&gt;&gt;&gt;">
<code>Base.:&gt;&gt;&gt;</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">&gt;&gt;&gt;(x, n)</pre>
<p>Unsigned right bit shift operator, <code>x &gt;&gt;&gt; n</code>. For <code>n &gt;= 0</code>, the result is <code>x</code> shifted right by <code>n</code> bits, where <code>n &gt;= 0</code>, filling with <code>0</code>s. For <code>n &lt; 0</code>, this is equivalent to <code>x &lt;&lt; -n</code>.</p>
<p>For <a href="../numbers/index#Core.Unsigned"><code>Unsigned</code></a> integer types, this is equivalent to <a href="#Base.:&gt;&gt;"><code>&gt;&gt;</code></a>. For <a href="../numbers/index#Core.Signed"><code>Signed</code></a> integer types, this is equivalent to <code>signed(unsigned(x) &gt;&gt; n)</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; Int8(-14) &gt;&gt;&gt; 2
60

julia&gt; bitstring(Int8(-14))
"11110010"

julia&gt; bitstring(Int8(60))
"00111100"</pre>
<p><a href="../numbers/index#Base.GMP.BigInt"><code>BigInt</code></a>s are treated as if having infinite size, so no filling is required and this is equivalent to <a href="#Base.:&gt;&gt;"><code>&gt;&gt;</code></a>.</p>
<p>See also <a href="#Base.:&gt;&gt;"><code>&gt;&gt;</code></a>, <a href="#Base.:&lt;&lt;"><code>&lt;&lt;</code></a>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L680-L706" target="_blank">source</a></section><section><pre data-language="julia">&gt;&gt;&gt;(B::BitVector, n) -&gt; BitVector</pre>
<p>Unsigned right bitshift operator, <code>B &gt;&gt;&gt; n</code>. Equivalent to <code>B &gt;&gt; n</code>. See <a href="#Base.:&gt;&gt;"><code>&gt;&gt;</code></a> for details and examples.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/bitarray.jl#L1358-L1363" target="_blank">source</a></section><h3 id="Base.bitrotate">
<code>Base.bitrotate</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">bitrotate(x::Base.BitInteger, k::Integer)</pre>
<p><code>bitrotate(x, k)</code> implements bitwise rotation. It returns the value of <code>x</code> with its bits rotated left <code>k</code> times. A negative value of <code>k</code> will rotate to the right instead.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>This function requires Julia 1.5 or later.</p></div>
</div>
<pre data-language="julia">julia&gt; bitrotate(UInt8(114), 2)
0xc9

julia&gt; bitstring(bitrotate(0b01110010, 2))
"11001001"

julia&gt; bitstring(bitrotate(0b01110010, -2))
"10011100"

julia&gt; bitstring(bitrotate(0b01110010, 8))
"01110010"</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/int.jl#L489-L512" target="_blank">source</a></section><h3 id="Base.::">
<code>Base.::</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">(:)(start::CartesianIndex, [step::CartesianIndex], stop::CartesianIndex)</pre>
<p>Construct <a href="../arrays/index#Base.IteratorsMD.CartesianIndices"><code>CartesianIndices</code></a> from two <code>CartesianIndex</code> and an optional step.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>This method requires at least Julia 1.1.</p></div>
</div>
<div class="admonition is-compat">

<div class="admonition-body"><p>The step range method start:step:stop requires at least Julia 1.6.</p></div>
</div>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; I = CartesianIndex(2,1);

julia&gt; J = CartesianIndex(3,3);

julia&gt; I:J
2×3 CartesianIndices{2, Tuple{UnitRange{Int64}, UnitRange{Int64}}}:
 CartesianIndex(2, 1)  CartesianIndex(2, 2)  CartesianIndex(2, 3)
 CartesianIndex(3, 1)  CartesianIndex(3, 2)  CartesianIndex(3, 3)

julia&gt; I:CartesianIndex(1, 2):J
2×2 CartesianIndices{2, Tuple{StepRange{Int64, Int64}, StepRange{Int64, Int64}}}:
 CartesianIndex(2, 1)  CartesianIndex(2, 3)
 CartesianIndex(3, 1)  CartesianIndex(3, 3)</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/multidimensional.jl#L285-L312" target="_blank">source</a></section><section><pre data-language="julia">(:)(start, [step], stop)</pre>
<p>Range operator. <code>a:b</code> constructs a range from <code>a</code> to <code>b</code> with a step size of 1 (a <a href="../collections/index#Base.UnitRange"><code>UnitRange</code></a>) , and <code>a:s:b</code> is similar but uses a step size of <code>s</code> (a <a href="../collections/index#Base.StepRange"><code>StepRange</code></a>).</p>
<p><code>:</code> is also used in indexing to select whole dimensions and for <a href="../base/index#Core.Symbol"><code>Symbol</code></a> literals, as in e.g. <code>:hello</code>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/range.jl#L31-L39" target="_blank">source</a></section><h3 id="Base.range">
<code>Base.range</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">range(start[, stop]; length, stop, step=1)</pre>
<p>Given a starting value, construct a range either by length or from <code>start</code> to <code>stop</code>, optionally with a given step (defaults to 1, a <a href="../collections/index#Base.UnitRange"><code>UnitRange</code></a>). One of <code>length</code> or <code>stop</code> is required. If <code>length</code>, <code>stop</code>, and <code>step</code> are all specified, they must agree.</p>
<p>If <code>length</code> and <code>stop</code> are provided and <code>step</code> is not, the step size will be computed automatically such that there are <code>length</code> linearly spaced elements in the range.</p>
<p>If <code>step</code> and <code>stop</code> are provided and <code>length</code> is not, the overall range length will be computed automatically such that the elements are <code>step</code> spaced.</p>
<p>Special care is taken to ensure intermediate values are computed rationally. To avoid this induced overhead, see the <a href="../collections/index#Base.LinRange"><code>LinRange</code></a> constructor.</p>
<p><code>stop</code> may be specified as either a positional or keyword argument.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p><code>stop</code> as a positional argument requires at least Julia 1.1.</p></div>
</div>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; range(1, length=100)
1:100

julia&gt; range(1, stop=100)
1:100

julia&gt; range(1, step=5, length=100)
1:5:496

julia&gt; range(1, step=5, stop=100)
1:5:96

julia&gt; range(1, 10, length=101)
1.0:0.09:10.0

julia&gt; range(1, 100, step=5)
1:5:96</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/range.jl#L49-L90" target="_blank">source</a></section><h3 id="Base.OneTo">
<code>Base.OneTo</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">Base.OneTo(n)</pre>
<p>Define an <code>AbstractUnitRange</code> that behaves like <code>1:n</code>, with the added distinction that the lower limit is guaranteed (by the type system) to be 1.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/range.jl#L317-L323" target="_blank">source</a></section><h3 id="Base.StepRangeLen">
<code>Base.StepRangeLen</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">StepRangeLen{T,R,S}(ref::R, step::S, len, [offset=1]) where {T,R,S}
StepRangeLen(       ref::R, step::S, len, [offset=1]) where {  R,S}</pre>
<p>A range <code>r</code> where <code>r[i]</code> produces values of type <code>T</code> (in the second form, <code>T</code> is deduced automatically), parameterized by a <code>ref</code>erence value, a <code>step</code>, and the <code>len</code>gth. By default <code>ref</code> is the starting value <code>r[1]</code>, but alternatively you can supply it as the value of <code>r[offset]</code> for some other index <code>1 &lt;= offset &lt;= len</code>. In conjunction with <code>TwicePrecision</code> this can be used to implement ranges that are free of roundoff error.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/range.jl#L341-L352" target="_blank">source</a></section><h3 id="Base.:==">
<code>Base.:==</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">==(x, y)</pre>
<p>Generic equality operator. Falls back to <a href="../base/index#Core.:==="><code>===</code></a>. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding. For collections, <code>==</code> is generally called recursively on all contents, though other properties (like the shape for arrays) may also be taken into account.</p>
<p>This operator follows IEEE semantics for floating-point numbers: <code>0.0 == -0.0</code> and <code>NaN != NaN</code>.</p>
<p>The result is of type <code>Bool</code>, except when one of the operands is <a href="../base/index#Base.missing"><code>missing</code></a>, in which case <code>missing</code> is returned (<a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>). For collections, <code>missing</code> is returned if at least one of the operands contains a <code>missing</code> value and all non-missing values are equal. Use <a href="../base/index#Base.isequal"><code>isequal</code></a> or <a href="../base/index#Core.:==="><code>===</code></a> to always get a <code>Bool</code> result.</p>
<p><strong>Implementation</strong></p>
<p>New numeric types should implement this function for two arguments of the new type, and handle comparison to other types via promotion rules where possible.</p>
<p><a href="../base/index#Base.isequal"><code>isequal</code></a> falls back to <code>==</code>, so new methods of <code>==</code> will be used by the <a href="../collections/index#Base.Dict"><code>Dict</code></a> type to compare keys. If your type will be used as a dictionary key, it should therefore also implement <a href="../base/index#Base.hash"><code>hash</code></a>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L55-L82" target="_blank">source</a></section><h3 id="Base.:!=">
<code>Base.:!=</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">!=(x, y)
≠(x,y)</pre>
<p>Not-equals comparison operator. Always gives the opposite answer as <a href="#Base.:=="><code>==</code></a>.</p>
<p><strong>Implementation</strong></p>
<p>New types should generally not implement this, and rely on the fallback definition <code>!=(x,y) = !(x==y)</code> instead.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; 3 != 2
true

julia&gt; "foo" ≠ "foo"
false</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L185-L203" target="_blank">source</a></section><section><pre data-language="julia">!=(x)</pre>
<p>Create a function that compares its argument to <code>x</code> using <a href="#Base.:!="><code>!=</code></a>, i.e. a function equivalent to <code>y -&gt; y != x</code>. The returned function is of type <code>Base.Fix2{typeof(!=)}</code>, which can be used to implement specialized methods.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>This functionality requires at least Julia 1.2.</p></div>
</div>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L1026-L1036" target="_blank">source</a></section><h3 id="Base.:!==">
<code>Base.:!==</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">!==(x, y)
≢(x,y)</pre>
<p>Always gives the opposite answer as <a href="../base/index#Core.:==="><code>===</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = [1, 2]; b = [1, 2];

julia&gt; a ≢ b
true

julia&gt; a ≢ a
false</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L234-L250" target="_blank">source</a></section><h3 id="Base.:&lt;">
<code>Base.:&lt;</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">&lt;(x, y)</pre>
<p>Less-than comparison operator. Falls back to <a href="../base/index#Base.isless"><code>isless</code></a>. Because of the behavior of floating-point NaN values, this operator implements a partial order.</p>
<p><strong>Implementation</strong></p>
<p>New numeric types with a canonical partial order should implement this function for two arguments of the new type. Types with a canonical total order should implement <a href="../base/index#Base.isless"><code>isless</code></a> instead. (x &lt; y) | (x == y)</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; 'a' &lt; 'b'
true

julia&gt; "abc" &lt; "abd"
true

julia&gt; 5 &lt; 3
false</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L254-L278" target="_blank">source</a></section><section><pre data-language="julia">&lt;(x)</pre>
<p>Create a function that compares its argument to <code>x</code> using <a href="#Base.:&lt;"><code>&lt;</code></a>, i.e. a function equivalent to <code>y -&gt; y &lt; x</code>. The returned function is of type <code>Base.Fix2{typeof(&lt;)}</code>, which can be used to implement specialized methods.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>This functionality requires at least Julia 1.2.</p></div>
</div>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L1078-L1088" target="_blank">source</a></section><h3 id="Base.:&lt;=">
<code>Base.:&lt;=</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">&lt;=(x, y)
≤(x,y)</pre>
<p>Less-than-or-equals comparison operator. Falls back to <code>(x &lt; y) | (x == y)</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; 'a' &lt;= 'b'
true

julia&gt; 7 ≤ 7 ≤ 9
true

julia&gt; "abc" ≤ "abc"
true

julia&gt; 5 &lt;= 3
false</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L307-L327" target="_blank">source</a></section><section><pre data-language="julia">&lt;=(x)</pre>
<p>Create a function that compares its argument to <code>x</code> using <a href="#Base.:&lt;="><code>&lt;=</code></a>, i.e. a function equivalent to <code>y -&gt; y &lt;= x</code>. The returned function is of type <code>Base.Fix2{typeof(&lt;=)}</code>, which can be used to implement specialized methods.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>This functionality requires at least Julia 1.2.</p></div>
</div>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L1052-L1062" target="_blank">source</a></section><h3 id="Base.:&gt;">
<code>Base.:&gt;</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">&gt;(x, y)</pre>
<p>Greater-than comparison operator. Falls back to <code>y &lt; x</code>.</p>
<p><strong>Implementation</strong></p>
<p>Generally, new types should implement <a href="#Base.:&lt;"><code>&lt;</code></a> instead of this function, and rely on the fallback definition <code>&gt;(x, y) = y &lt; x</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; 'a' &gt; 'b'
false

julia&gt; 7 &gt; 3 &gt; 1
true

julia&gt; "abc" &gt; "abd"
false

julia&gt; 5 &gt; 3
true</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L281-L304" target="_blank">source</a></section><section><pre data-language="julia">&gt;(x)</pre>
<p>Create a function that compares its argument to <code>x</code> using <a href="#Base.:&gt;"><code>&gt;</code></a>, i.e. a function equivalent to <code>y -&gt; y &gt; x</code>. The returned function is of type <code>Base.Fix2{typeof(&gt;)}</code>, which can be used to implement specialized methods.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>This functionality requires at least Julia 1.2.</p></div>
</div>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L1065-L1075" target="_blank">source</a></section><h3 id="Base.:&gt;=">
<code>Base.:&gt;=</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">&gt;=(x, y)
≥(x,y)</pre>
<p>Greater-than-or-equals comparison operator. Falls back to <code>y &lt;= x</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; 'a' &gt;= 'b'
false

julia&gt; 7 ≥ 7 ≥ 3
true

julia&gt; "abc" ≥ "abc"
true

julia&gt; 5 &gt;= 3
true</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L331-L351" target="_blank">source</a></section><section><pre data-language="julia">&gt;=(x)</pre>
<p>Create a function that compares its argument to <code>x</code> using <a href="#Base.:&gt;="><code>&gt;=</code></a>, i.e. a function equivalent to <code>y -&gt; y &gt;= x</code>. The returned function is of type <code>Base.Fix2{typeof(&gt;=)}</code>, which can be used to implement specialized methods.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>This functionality requires at least Julia 1.2.</p></div>
</div>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L1039-L1049" target="_blank">source</a></section><h3 id="Base.cmp">
<code>Base.cmp</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">cmp(x,y)</pre>
<p>Return -1, 0, or 1 depending on whether <code>x</code> is less than, equal to, or greater than <code>y</code>, respectively. Uses the total order implemented by <code>isless</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; cmp(1, 2)
-1

julia&gt; cmp(2, 1)
1

julia&gt; cmp(2+im, 3-im)
ERROR: MethodError: no method matching isless(::Complex{Int64}, ::Complex{Int64})
[...]</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L375-L393" target="_blank">source</a></section><section><pre data-language="julia">cmp(&lt;, x, y)</pre>
<p>Return -1, 0, or 1 depending on whether <code>x</code> is less than, equal to, or greater than <code>y</code>, respectively. The first argument specifies a less-than comparison function to use.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L396-L401" target="_blank">source</a></section><section><pre data-language="julia">cmp(a::AbstractString, b::AbstractString) -&gt; Int</pre>
<p>Compare two strings. Return <code>0</code> if both strings have the same length and the character at each index is the same in both strings. Return <code>-1</code> if <code>a</code> is a prefix of <code>b</code>, or if <code>a</code> comes before <code>b</code> in alphabetical order. Return <code>1</code> if <code>b</code> is a prefix of <code>a</code>, or if <code>b</code> comes before <code>a</code> in alphabetical order (technically, lexicographical order by Unicode code points).</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; cmp("abc", "abc")
0

julia&gt; cmp("ab", "abc")
-1

julia&gt; cmp("abc", "ab")
1

julia&gt; cmp("ab", "ac")
-1

julia&gt; cmp("ac", "ab")
1

julia&gt; cmp("α", "a")
1

julia&gt; cmp("b", "β")
-1</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/strings/basic.jl#L266-L298" target="_blank">source</a></section><h3 id="Base.:~">
<code>Base.:~</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">~(x)</pre>
<p>Bitwise not.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; ~4
-5

julia&gt; ~10
-11

julia&gt; ~true
false</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/int.jl#L268-L284" target="_blank">source</a></section><h3 id="Base.:&amp;">
<code>Base.:&amp;</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">x &amp; y</pre>
<p>Bitwise and. Implements <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>, returning <a href="../base/index#Base.missing"><code>missing</code></a> if one operand is <code>missing</code> and the other is <code>true</code>. Add parentheses for function application form: <code>(&amp;)(x, y)</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; 4 &amp; 10
0

julia&gt; 4 &amp; 12
4

julia&gt; true &amp; missing
missing

julia&gt; false &amp; missing
false</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/int.jl#L287-L308" target="_blank">source</a></section><h3 id="Base.:|">
<code>Base.:|</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">x | y</pre>
<p>Bitwise or. Implements <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>, returning <a href="../base/index#Base.missing"><code>missing</code></a> if one operand is <code>missing</code> and the other is <code>false</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; 4 | 10
14

julia&gt; 4 | 1
5

julia&gt; true | missing
true

julia&gt; false | missing
missing</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/int.jl#L311-L331" target="_blank">source</a></section><h3 id="Base.xor">
<code>Base.xor</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">xor(x, y)
⊻(x, y)</pre>
<p>Bitwise exclusive or of <code>x</code> and <code>y</code>. Implements <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>, returning <a href="../base/index#Base.missing"><code>missing</code></a> if one of the arguments is <code>missing</code>.</p>
<p>The infix operation <code>a ⊻ b</code> is a synonym for <code>xor(a,b)</code>, and <code>⊻</code> can be typed by tab-completing <code>\xor</code> or <code>\veebar</code> in the Julia REPL.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; xor(true, false)
true

julia&gt; xor(true, true)
false

julia&gt; xor(true, missing)
missing

julia&gt; false ⊻ false
false

julia&gt; [true; true; false] .⊻ [true; false; false]
3-element BitVector:
 0
 1
 0</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/bool.jl#L39-L70" target="_blank">source</a></section><h3 id="Base.:!">
<code>Base.:!</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">!(x)</pre>
<p>Boolean not. Implements <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>, returning <a href="../base/index#Base.missing"><code>missing</code></a> if <code>x</code> is <code>missing</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; !true
false

julia&gt; !false
true

julia&gt; !missing
missing

julia&gt; .![true false true]
1×3 BitMatrix:
 0  1  0</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/bool.jl#L11-L32" target="_blank">source</a></section><section><pre data-language="julia">!f::Function</pre>
<p>Predicate function negation: when the argument of <code>!</code> is a function, it returns a function which computes the boolean negation of <code>f</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; str = "∀ ε &gt; 0, ∃ δ &gt; 0: |x-y| &lt; δ ⇒ |f(x)-f(y)| &lt; ε"
"∀ ε &gt; 0, ∃ δ &gt; 0: |x-y| &lt; δ ⇒ |f(x)-f(y)| &lt; ε"

julia&gt; filter(isletter, str)
"εδxyδfxfyε"

julia&gt; filter(!isletter, str)
"∀  &gt; 0, ∃  &gt; 0: |-| &lt;  ⇒ |()-()| &lt; "</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L950-L967" target="_blank">source</a></section><h3 id="&amp;&amp;">
<code>&amp;&amp;</code><span class="docstring-category">Keyword</span>
</h3>
<section><pre data-language="julia">x &amp;&amp; y</pre>
<p>Short-circuiting boolean AND.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/docs/basedocs.jl#L929-L933" target="_blank">source</a></section><h3 id="||">
<code>||</code><span class="docstring-category">Keyword</span>
</h3>
<section><pre data-language="julia">x || y</pre>
<p>Short-circuiting boolean OR.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/docs/basedocs.jl#L936-L940" target="_blank">source</a></section><h2 id="Mathematical-Functions">
<a class="docs-heading-anchor" href="#Mathematical-Functions">Mathematical Functions</a>
</h2>
<h3 id="Base.isapprox">
<code>Base.isapprox</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">isapprox(x, y; atol::Real=0, rtol::Real=atol&gt;0 ? 0 : √eps, nans::Bool=false[, norm::Function])</pre>
<p>Inexact equality comparison: <code>true</code> if <code>norm(x-y) &lt;= max(atol, rtol*max(norm(x), norm(y)))</code>. The default <code>atol</code> is zero and the default <code>rtol</code> depends on the types of <code>x</code> and <code>y</code>. The keyword argument <code>nans</code> determines whether or not NaN values are considered equal (defaults to false).</p>
<p>For real or complex floating-point values, if an <code>atol &gt; 0</code> is not specified, <code>rtol</code> defaults to the square root of <a href="#"><code>eps</code></a> of the type of <code>x</code> or <code>y</code>, whichever is bigger (least precise). This corresponds to requiring equality of about half of the significand digits. Otherwise, e.g. for integer arguments or if an <code>atol &gt; 0</code> is supplied, <code>rtol</code> defaults to zero.</p>
<p>The <code>norm</code> keyword defaults to <code>abs</code> for numeric <code>(x,y)</code> and to <code>LinearAlgebra.norm</code> for arrays (where an alternative <code>norm</code> choice is sometimes useful). When <code>x</code> and <code>y</code> are arrays, if <code>norm(x-y)</code> is not finite (i.e. <code>±Inf</code> or <code>NaN</code>), the comparison falls back to checking whether all elements of <code>x</code> and <code>y</code> are approximately equal component-wise.</p>
<p>The binary operator <code>≈</code> is equivalent to <code>isapprox</code> with the default arguments, and <code>x ≉ y</code> is equivalent to <code>!isapprox(x,y)</code>.</p>
<p>Note that <code>x ≈ 0</code> (i.e., comparing to zero with the default tolerances) is equivalent to <code>x == 0</code> since the default <code>atol</code> is <code>0</code>. In such cases, you should either supply an appropriate <code>atol</code> (or use <code>norm(x) ≤ atol</code>) or rearrange your code (e.g. use <code>x ≈ y</code> rather than <code>x - y ≈ 0</code>). It is not possible to pick a nonzero <code>atol</code> automatically because it depends on the overall scaling (the "units") of your problem: for example, in <code>x - y ≈ 0</code>, <code>atol=1e-9</code> is an absurdly small tolerance if <code>x</code> is the <a href="https://en.wikipedia.org/wiki/Earth_radius">radius of the Earth</a> in meters, but an absurdly large tolerance if <code>x</code> is the <a href="https://en.wikipedia.org/wiki/Bohr_radius">radius of a Hydrogen atom</a> in meters.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>Passing the <code>norm</code> keyword argument when comparing numeric (non-array) arguments requires Julia 1.6 or later.</p></div>
</div>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; 0.1 ≈ (0.1 - 1e-10)
true

julia&gt; isapprox(10, 11; atol = 2)
true

julia&gt; isapprox([10.0^9, 1.0], [10.0^9, 2.0])
true

julia&gt; 1e-10 ≈ 0
false

julia&gt; isapprox(1e-10, 0, atol=1e-8)
true</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/floatfuncs.jl#L225-L277" target="_blank">source</a></section><section><pre data-language="julia">isapprox(x; kwargs...) / ≈(x; kwargs...)</pre>
<p>Create a function that compares its argument to <code>x</code> using <code>≈</code>, i.e. a function equivalent to <code>y -&gt; y ≈ x</code>.</p>
<p>The keyword arguments supported here are the same as those in the 2-argument <code>isapprox</code>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/floatfuncs.jl#L284-L290" target="_blank">source</a></section><h3 id="Base.sin-Tuple{Number}">
<code>Base.sin</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">sin(x)</pre>
<p>Compute sine of <code>x</code>, where <code>x</code> is in radians.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L432-L436" target="_blank">source</a></section><h3 id="Base.cos-Tuple{Number}">
<code>Base.cos</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">cos(x)</pre>
<p>Compute cosine of <code>x</code>, where <code>x</code> is in radians.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L439-L443" target="_blank">source</a></section><h3 id="Base.Math.sincos-Tuple{Float64}">
<code>Base.Math.sincos</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">sincos(x)</pre>
<p>Simultaneously compute the sine and cosine of <code>x</code>, where <code>x</code> is in radians, returning a tuple <code>(sine, cosine)</code>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L166-L171" target="_blank">source</a></section><h3 id="Base.tan-Tuple{Number}">
<code>Base.tan</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">tan(x)</pre>
<p>Compute tangent of <code>x</code>, where <code>x</code> is in radians.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L446-L450" target="_blank">source</a></section><h3 id="Base.Math.sind">
<code>Base.Math.sind</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">sind(x)</pre>
<p>Compute sine of <code>x</code>, where <code>x</code> is in degrees. </p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1266-L1268" target="_blank">source</a></section><h3 id="Base.Math.cosd">
<code>Base.Math.cosd</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">cosd(x)</pre>
<p>Compute cosine of <code>x</code>, where <code>x</code> is in degrees. </p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1266-L1268" target="_blank">source</a></section><h3 id="Base.Math.tand">
<code>Base.Math.tand</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">tand(x)</pre>
<p>Compute tangent of <code>x</code>, where <code>x</code> is in degrees. </p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1266-L1268" target="_blank">source</a></section><h3 id="Base.Math.sinpi">
<code>Base.Math.sinpi</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">sinpi(x)</pre>
<p>Compute <span>$\sin(\pi x)$</span> more accurately than <code>sin(pi*x)</code>, especially for large <code>x</code>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L741-L745" target="_blank">source</a></section><h3 id="Base.Math.cospi">
<code>Base.Math.cospi</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">cospi(x)</pre>
<p>Compute <span>$\cos(\pi x)$</span> more accurately than <code>cos(pi*x)</code>, especially for large <code>x</code>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L804-L808" target="_blank">source</a></section><h3 id="Base.Math.sincospi">
<code>Base.Math.sincospi</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">sincospi(x)</pre>
<p>Simultaneously compute <a href="#Base.Math.sinpi"><code>sinpi(x)</code></a> and <a href="#Base.Math.cospi"><code>cospi(x)</code></a> (the sine and cosine of <code>π*x</code>, where <code>x</code> is in radians), returning a tuple <code>(sine, cosine)</code>.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>This function requires Julia 1.6 or later.</p></div>
</div>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L858-L866" target="_blank">source</a></section><h3 id="Base.sinh-Tuple{Number}">
<code>Base.sinh</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">sinh(x)</pre>
<p>Compute hyperbolic sine of <code>x</code>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L324-L328" target="_blank">source</a></section><h3 id="Base.cosh-Tuple{Number}">
<code>Base.cosh</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">cosh(x)</pre>
<p>Compute hyperbolic cosine of <code>x</code>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L331-L335" target="_blank">source</a></section><h3 id="Base.tanh-Tuple{Number}">
<code>Base.tanh</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">tanh(x)</pre>
<p>Compute hyperbolic tangent of <code>x</code>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L338-L342" target="_blank">source</a></section><h3 id="Base.asin-Tuple{Number}">
<code>Base.asin</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">asin(x)</pre>
<p>Compute the inverse sine of <code>x</code>, where the output is in radians.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L453-L457" target="_blank">source</a></section><h3 id="Base.acos-Tuple{Number}">
<code>Base.acos</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">acos(x)</pre>
<p>Compute the inverse cosine of <code>x</code>, where the output is in radians</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L460-L464" target="_blank">source</a></section><h3 id="Base.atan-Tuple{Number}">
<code>Base.atan</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">atan(y)
atan(y, x)</pre>
<p>Compute the inverse tangent of <code>y</code> or <code>y/x</code>, respectively.</p>
<p>For one argument, this is the angle in radians between the positive <em>x</em>-axis and the point (1, <em>y</em>), returning a value in the interval <span>$[-\pi/2, \pi/2]$</span>.</p>
<p>For two arguments, this is the angle in radians between the positive <em>x</em>-axis and the point (<em>x</em>, <em>y</em>), returning a value in the interval <span>$[-\pi, \pi]$</span>. This corresponds to a standard <a href="https://en.wikipedia.org/wiki/Atan2"><code>atan2</code></a> function. Note that by convention <code>atan(0.0,x)</code> is defined as <span>$\pi$</span> and <code>atan(-0.0,x)</code> is defined as <span>$-\pi$</span> when <code>x &lt; 0</code>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L345-L358" target="_blank">source</a></section><h3 id="Base.Math.asind">
<code>Base.Math.asind</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">asind(x)</pre>
<p>Compute the inverse sine of <code>x</code>, where the output is in degrees. </p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1276-L1279" target="_blank">source</a></section><h3 id="Base.Math.acosd">
<code>Base.Math.acosd</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">acosd(x)</pre>
<p>Compute the inverse cosine of <code>x</code>, where the output is in degrees. </p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1276-L1279" target="_blank">source</a></section><h3 id="Base.Math.atand">
<code>Base.Math.atand</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">atand(y)
atand(y,x)</pre>
<p>Compute the inverse tangent of <code>y</code> or <code>y/x</code>, respectively, where the output is in degrees.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1283-L1288" target="_blank">source</a></section><h3 id="Base.Math.sec-Tuple{Number}">
<code>Base.Math.sec</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">sec(x)</pre>
<p>Compute the secant of <code>x</code>, where <code>x</code> is in radians.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1130-L1134" target="_blank">source</a></section><h3 id="Base.Math.csc-Tuple{Number}">
<code>Base.Math.csc</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">csc(x)</pre>
<p>Compute the cosecant of <code>x</code>, where <code>x</code> is in radians.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1130-L1134" target="_blank">source</a></section><h3 id="Base.Math.cot-Tuple{Number}">
<code>Base.Math.cot</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">cot(x)</pre>
<p>Compute the cotangent of <code>x</code>, where <code>x</code> is in radians.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1130-L1134" target="_blank">source</a></section><h3 id="Base.Math.secd">
<code>Base.Math.secd</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">secd(x)</pre>
<p>Compute the secant of <code>x</code>, where <code>x</code> is in degrees.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1140-L1144" target="_blank">source</a></section><h3 id="Base.Math.cscd">
<code>Base.Math.cscd</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">cscd(x)</pre>
<p>Compute the cosecant of <code>x</code>, where <code>x</code> is in degrees.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1140-L1144" target="_blank">source</a></section><h3 id="Base.Math.cotd">
<code>Base.Math.cotd</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">cotd(x)</pre>
<p>Compute the cotangent of <code>x</code>, where <code>x</code> is in degrees.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1140-L1144" target="_blank">source</a></section><h3 id="Base.Math.asec-Tuple{Number}">
<code>Base.Math.asec</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">asec(x)</pre>
<p>Compute the inverse secant of <code>x</code>, where the output is in radians. </p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1154-L1156" target="_blank">source</a></section><h3 id="Base.Math.acsc-Tuple{Number}">
<code>Base.Math.acsc</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">acsc(x)</pre>
<p>Compute the inverse cosecant of <code>x</code>, where the output is in radians. </p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1154-L1156" target="_blank">source</a></section><h3 id="Base.Math.acot-Tuple{Number}">
<code>Base.Math.acot</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">acot(x)</pre>
<p>Compute the inverse cotangent of <code>x</code>, where the output is in radians. </p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1154-L1156" target="_blank">source</a></section><h3 id="Base.Math.asecd">
<code>Base.Math.asecd</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">asecd(x)</pre>
<p>Compute the inverse secant of <code>x</code>, where the output is in degrees. </p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1276-L1279" target="_blank">source</a></section><h3 id="Base.Math.acscd">
<code>Base.Math.acscd</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">acscd(x)</pre>
<p>Compute the inverse cosecant of <code>x</code>, where the output is in degrees. </p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1276-L1279" target="_blank">source</a></section><h3 id="Base.Math.acotd">
<code>Base.Math.acotd</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">acotd(x)</pre>
<p>Compute the inverse cotangent of <code>x</code>, where the output is in degrees. </p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1276-L1279" target="_blank">source</a></section><h3 id="Base.Math.sech-Tuple{Number}">
<code>Base.Math.sech</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">sech(x)</pre>
<p>Compute the hyperbolic secant of <code>x</code>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1135-L1139" target="_blank">source</a></section><h3 id="Base.Math.csch-Tuple{Number}">
<code>Base.Math.csch</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">csch(x)</pre>
<p>Compute the hyperbolic cosecant of <code>x</code>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1135-L1139" target="_blank">source</a></section><h3 id="Base.Math.coth-Tuple{Number}">
<code>Base.Math.coth</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">coth(x)</pre>
<p>Compute the hyperbolic cotangent of <code>x</code>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1135-L1139" target="_blank">source</a></section><h3 id="Base.asinh-Tuple{Number}">
<code>Base.asinh</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">asinh(x)</pre>
<p>Compute the inverse hyperbolic sine of <code>x</code>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L361-L365" target="_blank">source</a></section><h3 id="Base.acosh-Tuple{Number}">
<code>Base.acosh</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">acosh(x)</pre>
<p>Compute the inverse hyperbolic cosine of <code>x</code>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L467-L471" target="_blank">source</a></section><h3 id="Base.atanh-Tuple{Number}">
<code>Base.atanh</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">atanh(x)</pre>
<p>Compute the inverse hyperbolic tangent of <code>x</code>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L474-L478" target="_blank">source</a></section><h3 id="Base.Math.asech-Tuple{Number}">
<code>Base.Math.asech</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">asech(x)</pre>
<p>Compute the inverse hyperbolic secant of <code>x</code>. </p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1157-L1159" target="_blank">source</a></section><h3 id="Base.Math.acsch-Tuple{Number}">
<code>Base.Math.acsch</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">acsch(x)</pre>
<p>Compute the inverse hyperbolic cosecant of <code>x</code>. </p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1157-L1159" target="_blank">source</a></section><h3 id="Base.Math.acoth-Tuple{Number}">
<code>Base.Math.acoth</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">acoth(x)</pre>
<p>Compute the inverse hyperbolic cotangent of <code>x</code>. </p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1157-L1159" target="_blank">source</a></section><h3 id="Base.Math.sinc">
<code>Base.Math.sinc</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">sinc(x)</pre>
<p>Compute <span>$\sin(\pi x) / (\pi x)$</span> if <span>$x \neq 0$</span>, and <span>$1$</span> if <span>$x = 0$</span>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1068-L1072" target="_blank">source</a></section><h3 id="Base.Math.cosc">
<code>Base.Math.cosc</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">cosc(x)</pre>
<p>Compute <span>$\cos(\pi x) / x - \sin(\pi x) / (\pi x^2)$</span> if <span>$x \neq 0$</span>, and <span>$0$</span> if <span>$x = 0$</span>. This is the derivative of <code>sinc(x)</code>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/trig.jl#L1083-L1088" target="_blank">source</a></section><h3 id="Base.Math.deg2rad">
<code>Base.Math.deg2rad</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">deg2rad(x)</pre>
<p>Convert <code>x</code> from degrees to radians.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; deg2rad(90)
1.5707963267948966</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L257-L267" target="_blank">source</a></section><h3 id="Base.Math.rad2deg">
<code>Base.Math.rad2deg</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">rad2deg(x)</pre>
<p>Convert <code>x</code> from radians to degrees.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; rad2deg(pi)
180.0</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L244-L254" target="_blank">source</a></section><h3 id="Base.Math.hypot">
<code>Base.Math.hypot</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">hypot(x, y)</pre>
<p>Compute the hypotenuse <span>$\sqrt{|x|^2+|y|^2}$</span> avoiding overflow and underflow.</p>
<p>This code is an implementation of the algorithm described in: An Improved Algorithm for <code>hypot(a,b)</code> by Carlos F. Borges The article is available online at ArXiv at the link https://arxiv.org/abs/1904.09481</p>
<pre data-language="julia">hypot(x...)</pre>
<p>Compute the hypotenuse <span>$\sqrt{\sum |x_i|^2}$</span> avoiding overflow and underflow.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = Int64(10)^10;

julia&gt; hypot(a, a)
1.4142135623730951e10

julia&gt; √(a^2 + a^2) # a^2 overflows
ERROR: DomainError with -2.914184810805068e18:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]

julia&gt; hypot(3, 4im)
5.0

julia&gt; hypot(-5.7)
5.7

julia&gt; hypot(3, 4im, 12.0)
13.0</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L610-L647" target="_blank">source</a></section><h3 id="Base.log-Tuple{Number}">
<code>Base.log</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">log(x)</pre>
<p>Compute the natural logarithm of <code>x</code>. Throws <a href="../base/index#Core.DomainError"><code>DomainError</code></a> for negative <a href="../numbers/index#Core.Real"><code>Real</code></a> arguments. Use complex negative arguments to obtain complex results.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; log(2)
0.6931471805599453

julia&gt; log(-3)
ERROR: DomainError with -3.0:
log will only return a complex result if called with a complex argument. Try log(Complex(x)).
Stacktrace:
 [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31
[...]</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L481-L499" target="_blank">source</a></section><h3 id="Base.log-Tuple{Number, Number}">
<code>Base.log</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">log(b,x)</pre>
<p>Compute the base <code>b</code> logarithm of <code>x</code>. Throws <a href="../base/index#Core.DomainError"><code>DomainError</code></a> for negative <a href="../numbers/index#Core.Real"><code>Real</code></a> arguments.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; log(4,8)
1.5

julia&gt; log(4,2)
0.5

julia&gt; log(-2, 3)
ERROR: DomainError with -2.0:
log will only return a complex result if called with a complex argument. Try log(Complex(x)).
Stacktrace:
 [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31
[...]

julia&gt; log(2, -3)
ERROR: DomainError with -3.0:
log will only return a complex result if called with a complex argument. Try log(Complex(x)).
Stacktrace:
 [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31
[...]</pre>
<div class="admonition is-info">

<div class="admonition-body">
<p>If <code>b</code> is a power of 2 or 10, <a href="#Base.log2"><code>log2</code></a> or <a href="#Base.log10"><code>log10</code></a> should be used, as these will typically be faster and more accurate. For example,</p>
<pre data-language="julia">julia&gt; log(100,1000000)
2.9999999999999996

julia&gt; log10(1000000)/2
3.0</pre>
</div>
</div>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L276-L316" target="_blank">source</a></section><h3 id="Base.log2">
<code>Base.log2</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">log2(x)</pre>
<p>Compute the logarithm of <code>x</code> to base 2. Throws <a href="../base/index#Core.DomainError"><code>DomainError</code></a> for negative <a href="../numbers/index#Core.Real"><code>Real</code></a> arguments.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; log2(4)
2.0

julia&gt; log2(10)
3.321928094887362

julia&gt; log2(-2)
ERROR: DomainError with -2.0:
NaN result for non-NaN input.
Stacktrace:
 [1] nan_dom_err at ./math.jl:325 [inlined]
[...]</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L502-L523" target="_blank">source</a></section><h3 id="Base.log10">
<code>Base.log10</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">log10(x)</pre>
<p>Compute the logarithm of <code>x</code> to base 10. Throws <a href="../base/index#Core.DomainError"><code>DomainError</code></a> for negative <a href="../numbers/index#Core.Real"><code>Real</code></a> arguments.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; log10(100)
2.0

julia&gt; log10(2)
0.3010299956639812

julia&gt; log10(-2)
ERROR: DomainError with -2.0:
NaN result for non-NaN input.
Stacktrace:
 [1] nan_dom_err at ./math.jl:325 [inlined]
[...]</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L526-L547" target="_blank">source</a></section><h3 id="Base.log1p">
<code>Base.log1p</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">log1p(x)</pre>
<p>Accurate natural logarithm of <code>1+x</code>. Throws <a href="../base/index#Core.DomainError"><code>DomainError</code></a> for <a href="../numbers/index#Core.Real"><code>Real</code></a> arguments less than -1.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; log1p(-0.5)
-0.6931471805599453

julia&gt; log1p(0)
0.0

julia&gt; log1p(-2)
ERROR: DomainError with -2.0:
log1p will only return a complex result if called with a complex argument. Try log1p(Complex(x)).
Stacktrace:
 [1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31
[...]</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L550-L571" target="_blank">source</a></section><h3 id="Base.Math.frexp">
<code>Base.Math.frexp</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">frexp(val)</pre>
<p>Return <code>(x,exp)</code> such that <code>x</code> has a magnitude in the interval <span>$[1/2, 1)$</span> or 0, and <code>val</code> is equal to <span>$x \times 2^{exp}$</span>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L839-L844" target="_blank">source</a></section><h3 id="Base.exp-Tuple{Float64}">
<code>Base.exp</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">exp(x)</pre>
<p>Compute the natural base exponential of <code>x</code>, in other words <span>$e^x$</span>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; exp(1.0)
2.718281828459045</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/exp.jl#L249-L259" target="_blank">source</a></section><h3 id="Base.exp2">
<code>Base.exp2</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">exp2(x)</pre>
<p>Compute the base 2 exponential of <code>x</code>, in other words <span>$2^x$</span>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; exp2(5)
32.0</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L377-L387" target="_blank">source</a></section><h3 id="Base.exp10">
<code>Base.exp10</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">exp10(x)</pre>
<p>Compute the base 10 exponential of <code>x</code>, in other words <span>$10^x$</span>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; exp10(2)
100.0</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L390-L400" target="_blank">source</a></section><h3 id="Base.Math.ldexp">
<code>Base.Math.ldexp</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">ldexp(x, n)</pre>
<p>Compute <span>$x \times 2^n$</span>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; ldexp(5., 2)
20.0</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L734-L744" target="_blank">source</a></section><h3 id="Base.Math.modf">
<code>Base.Math.modf</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">modf(x)</pre>
<p>Return a tuple <code>(fpart, ipart)</code> of the fractional and integral parts of a number. Both parts have the same sign as the argument.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; modf(3.5)
(0.5, 3.0)

julia&gt; modf(-3.5)
(-0.5, -3.0)</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L869-L883" target="_blank">source</a></section><h3 id="Base.expm1">
<code>Base.expm1</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">expm1(x)</pre>
<p>Accurately compute <span>$e^x-1$</span>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L368-L372" target="_blank">source</a></section><h3 id="Base.round-Tuple{Type, Any}">
<code>Base.round</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">round([T,] x, [r::RoundingMode])
round(x, [r::RoundingMode]; digits::Integer=0, base = 10)
round(x, [r::RoundingMode]; sigdigits::Integer, base = 10)</pre>
<p>Rounds the number <code>x</code>.</p>
<p>Without keyword arguments, <code>x</code> is rounded to an integer value, returning a value of type <code>T</code>, or of the same type of <code>x</code> if no <code>T</code> is provided. An <a href="../base/index#Core.InexactError"><code>InexactError</code></a> will be thrown if the value is not representable by <code>T</code>, similar to <a href="../base/index#Base.convert"><code>convert</code></a>.</p>
<p>If the <code>digits</code> keyword argument is provided, it rounds to the specified number of digits after the decimal place (or before if negative), in base <code>base</code>.</p>
<p>If the <code>sigdigits</code> keyword argument is provided, it rounds to the specified number of significant digits, in base <code>base</code>.</p>
<p>The <a href="#Base.Rounding.RoundingMode"><code>RoundingMode</code></a><code>r</code> controls the direction of the rounding; the default is <a href="#Base.Rounding.RoundNearest"><code>RoundNearest</code></a>, which rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer. Note that <code>round</code> may give incorrect results if the global rounding mode is changed (see <a href="../numbers/index#Base.Rounding.rounding"><code>rounding</code></a>).</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; round(1.7)
2.0

julia&gt; round(Int, 1.7)
2

julia&gt; round(1.5)
2.0

julia&gt; round(2.5)
2.0

julia&gt; round(pi; digits=2)
3.14

julia&gt; round(pi; digits=3, base=2)
3.125

julia&gt; round(123.456; sigdigits=2)
120.0

julia&gt; round(357.913; sigdigits=4, base=2)
352.0</pre>
<div class="admonition is-info">

<div class="admonition-body">
<p>Rounding to specified digits in bases other than 2 can be inexact when operating on binary floating point numbers. For example, the <a href="../numbers/index#Core.Float64"><code>Float64</code></a> value represented by <code>1.15</code> is actually <em>less</em> than 1.15, yet will be rounded to 1.2.</p>
<h1>Examples</h1>
<pre data-language="julia">julia&gt; x = 1.15
1.15

julia&gt; @sprintf "%.20f" x
"1.14999999999999991118"

julia&gt; x &lt; 115//100
true

julia&gt; round(x, digits=1)
1.2</pre>
</div>
</div>
<p><strong>Extensions</strong></p>
<p>To extend <code>round</code> to new numeric types, it is typically sufficient to define <code>Base.round(x::NewType, r::RoundingMode)</code>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/floatfuncs.jl#L47-L120" target="_blank">source</a></section><h3 id="Base.Rounding.RoundingMode">
<code>Base.Rounding.RoundingMode</code><span class="docstring-category">Type</span>
</h3>
<section><pre data-language="julia">RoundingMode</pre>
<p>A type used for controlling the rounding mode of floating point operations (via <a href="../numbers/index#Base.Rounding.rounding"><code>rounding</code></a>/<a href="#"><code>setrounding</code></a> functions), or as optional arguments for rounding to the nearest integer (via the <a href="#Base.round-Tuple%7BType,%20Any%7D"><code>round</code></a> function).</p>
<p>Currently supported rounding modes are:</p>
<ul>
<li>
<a href="#Base.Rounding.RoundNearest"><code>RoundNearest</code></a> (default)</li>
<li><a href="#Base.Rounding.RoundNearestTiesAway"><code>RoundNearestTiesAway</code></a></li>
<li><a href="#Base.Rounding.RoundNearestTiesUp"><code>RoundNearestTiesUp</code></a></li>
<li><a href="#Base.Rounding.RoundToZero"><code>RoundToZero</code></a></li>
<li>
<a href="#Base.Rounding.RoundFromZero"><code>RoundFromZero</code></a> (<a href="../numbers/index#Base.MPFR.BigFloat"><code>BigFloat</code></a> only)</li>
<li><a href="#Base.Rounding.RoundUp"><code>RoundUp</code></a></li>
<li><a href="#Base.Rounding.RoundDown"><code>RoundDown</code></a></li>
</ul>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/rounding.jl#L26-L43" target="_blank">source</a></section><h3 id="Base.Rounding.RoundNearest">
<code>Base.Rounding.RoundNearest</code><span class="docstring-category">Constant</span>
</h3>
<section><pre data-language="julia">RoundNearest</pre>
<p>The default rounding mode. Rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/rounding.jl#L46-L51" target="_blank">source</a></section><h3 id="Base.Rounding.RoundNearestTiesAway">
<code>Base.Rounding.RoundNearestTiesAway</code><span class="docstring-category">Constant</span>
</h3>
<section><pre data-language="julia">RoundNearestTiesAway</pre>
<p>Rounds to nearest integer, with ties rounded away from zero (C/C++ <a href="#Base.round-Tuple%7BType,%20Any%7D"><code>round</code></a> behaviour).</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/rounding.jl#L89-L94" target="_blank">source</a></section><h3 id="Base.Rounding.RoundNearestTiesUp">
<code>Base.Rounding.RoundNearestTiesUp</code><span class="docstring-category">Constant</span>
</h3>
<section><pre data-language="julia">RoundNearestTiesUp</pre>
<p>Rounds to nearest integer, with ties rounded toward positive infinity (Java/JavaScript <a href="#Base.round-Tuple%7BType,%20Any%7D"><code>round</code></a> behaviour).</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/rounding.jl#L97-L102" target="_blank">source</a></section><h3 id="Base.Rounding.RoundToZero">
<code>Base.Rounding.RoundToZero</code><span class="docstring-category">Constant</span>
</h3>
<section><pre data-language="julia">RoundToZero</pre>
<p><a href="#Base.round-Tuple%7BType,%20Any%7D"><code>round</code></a> using this rounding mode is an alias for <a href="#Base.trunc"><code>trunc</code></a>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/rounding.jl#L54-L58" target="_blank">source</a></section><h3 id="Base.Rounding.RoundFromZero">
<code>Base.Rounding.RoundFromZero</code><span class="docstring-category">Constant</span>
</h3>
<section><pre data-language="julia">RoundFromZero</pre>
<p>Rounds away from zero. This rounding mode may only be used with <code>T == BigFloat</code> inputs to <a href="#Base.round-Tuple%7BType,%20Any%7D"><code>round</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; BigFloat("1.0000000000000001", 5, RoundFromZero)
1.06</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/rounding.jl#L75-L86" target="_blank">source</a></section><h3 id="Base.Rounding.RoundUp">
<code>Base.Rounding.RoundUp</code><span class="docstring-category">Constant</span>
</h3>
<section><pre data-language="julia">RoundUp</pre>
<p><a href="#Base.round-Tuple%7BType,%20Any%7D"><code>round</code></a> using this rounding mode is an alias for <a href="#Base.ceil"><code>ceil</code></a>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/rounding.jl#L61-L65" target="_blank">source</a></section><h3 id="Base.Rounding.RoundDown">
<code>Base.Rounding.RoundDown</code><span class="docstring-category">Constant</span>
</h3>
<section><pre data-language="julia">RoundDown</pre>
<p><a href="#Base.round-Tuple%7BType,%20Any%7D"><code>round</code></a> using this rounding mode is an alias for <a href="#Base.floor"><code>floor</code></a>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/rounding.jl#L68-L72" target="_blank">source</a></section><h3 id='Base.round-Tuple{Complex{var"#s18"} where var"#s18"&lt;:AbstractFloat, RoundingMode, RoundingMode}'>
<code>Base.round</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">round(z::Complex[, RoundingModeReal, [RoundingModeImaginary]])
round(z::Complex[, RoundingModeReal, [RoundingModeImaginary]]; digits=, base=10)
round(z::Complex[, RoundingModeReal, [RoundingModeImaginary]]; sigdigits=, base=10)</pre>
<p>Return the nearest integral value of the same type as the complex-valued <code>z</code> to <code>z</code>, breaking ties using the specified <a href="#Base.Rounding.RoundingMode"><code>RoundingMode</code></a>s. The first <a href="#Base.Rounding.RoundingMode"><code>RoundingMode</code></a> is used for rounding the real components while the second is used for rounding the imaginary components.</p>
<p><strong>Example</strong></p>
<pre data-language="julia">julia&gt; round(3.14 + 4.5im)
3.0 + 4.0im</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/complex.jl#L1022-L1037" target="_blank">source</a></section><h3 id="Base.ceil">
<code>Base.ceil</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">ceil([T,] x)
ceil(x; digits::Integer= [, base = 10])
ceil(x; sigdigits::Integer= [, base = 10])</pre>
<p><code>ceil(x)</code> returns the nearest integral value of the same type as <code>x</code> that is greater than or equal to <code>x</code>.</p>
<p><code>ceil(T, x)</code> converts the result to type <code>T</code>, throwing an <code>InexactError</code> if the value is not representable.</p>
<p><code>digits</code>, <code>sigdigits</code> and <code>base</code> work as for <a href="#Base.round-Tuple%7BType,%20Any%7D"><code>round</code></a>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/int.jl#L579-L591" target="_blank">source</a></section><h3 id="Base.floor">
<code>Base.floor</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">floor([T,] x)
floor(x; digits::Integer= [, base = 10])
floor(x; sigdigits::Integer= [, base = 10])</pre>
<p><code>floor(x)</code> returns the nearest integral value of the same type as <code>x</code> that is less than or equal to <code>x</code>.</p>
<p><code>floor(T, x)</code> converts the result to type <code>T</code>, throwing an <code>InexactError</code> if the value is not representable.</p>
<p><code>digits</code>, <code>sigdigits</code> and <code>base</code> work as for <a href="#Base.round-Tuple%7BType,%20Any%7D"><code>round</code></a>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/int.jl#L564-L576" target="_blank">source</a></section><h3 id="Base.trunc">
<code>Base.trunc</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">trunc([T,] x)
trunc(x; digits::Integer= [, base = 10])
trunc(x; sigdigits::Integer= [, base = 10])</pre>
<p><code>trunc(x)</code> returns the nearest integral value of the same type as <code>x</code> whose absolute value is less than or equal to <code>x</code>.</p>
<p><code>trunc(T, x)</code> converts the result to type <code>T</code>, throwing an <code>InexactError</code> if the value is not representable.</p>
<p><code>digits</code>, <code>sigdigits</code> and <code>base</code> work as for <a href="#Base.round-Tuple%7BType,%20Any%7D"><code>round</code></a>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/int.jl#L549-L561" target="_blank">source</a></section><h3 id="Base.unsafe_trunc">
<code>Base.unsafe_trunc</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">unsafe_trunc(T, x)</pre>
<p>Return the nearest integral value of type <code>T</code> whose absolute value is less than or equal to <code>x</code>. If the value is not representable by <code>T</code>, an arbitrary value will be returned.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/float.jl#L226-L232" target="_blank">source</a></section><h3 id="Base.min">
<code>Base.min</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">min(x, y, ...)</pre>
<p>Return the minimum of the arguments. See also the <a href="../collections/index#Base.minimum"><code>minimum</code></a> function to take the minimum element from a collection.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; min(2, 5, 1)
1</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L421-L432" target="_blank">source</a></section><h3 id="Base.max">
<code>Base.max</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">max(x, y, ...)</pre>
<p>Return the maximum of the arguments. See also the <a href="../collections/index#Base.maximum"><code>maximum</code></a> function to take the maximum element from a collection.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; max(2, 5, 1)
5</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L407-L418" target="_blank">source</a></section><h3 id="Base.minmax">
<code>Base.minmax</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">minmax(x, y)</pre>
<p>Return <code>(min(x,y), max(x,y))</code>. See also: <a href="../collections/index#Base.extrema"><code>extrema</code></a> that returns <code>(minimum(x), maximum(x))</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; minmax('c','b')
('b', 'c')</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/operators.jl#L435-L445" target="_blank">source</a></section><h3 id="Base.Math.clamp">
<code>Base.Math.clamp</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">clamp(x, lo, hi)</pre>
<p>Return <code>x</code> if <code>lo &lt;= x &lt;= hi</code>. If <code>x &gt; hi</code>, return <code>hi</code>. If <code>x &lt; lo</code>, return <code>lo</code>. Arguments are promoted to a common type.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; clamp.([pi, 1.0, big(10.)], 2., 9.)
3-element Vector{BigFloat}:
 3.141592653589793238462643383279502884197169399375105820974944592307816406286198
 2.0
 9.0

julia&gt; clamp.([11,8,5],10,6) # an example where lo &gt; hi
3-element Vector{Int64}:
  6
  6
 10</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L44-L64" target="_blank">source</a></section><section><pre data-language="julia">clamp(x, T)::T</pre>
<p>Clamp <code>x</code> between <code>typemin(T)</code> and <code>typemax(T)</code> and convert the result to type <code>T</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; clamp(200, Int8)
127
julia&gt; clamp(-200, Int8)
-128</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L71-L83" target="_blank">source</a></section><section><pre data-language="julia">clamp(x::Integer, r::AbstractUnitRange)</pre>
<p>Clamp <code>x</code> to lie within range <code>r</code>.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>This method requires at least Julia 1.6.</p></div>
</div>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L100-L107" target="_blank">source</a></section><h3 id="Base.Math.clamp!">
<code>Base.Math.clamp!</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">clamp!(array::AbstractArray, lo, hi)</pre>
<p>Restrict values in <code>array</code> to the specified range, in-place. See also <a href="#Base.Math.clamp"><code>clamp</code></a>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L87-L92" target="_blank">source</a></section><h3 id="Base.abs">
<code>Base.abs</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">abs(x)</pre>
<p>The absolute value of <code>x</code>.</p>
<p>When <code>abs</code> is applied to signed integers, overflow may occur, resulting in the return of a negative value. This overflow occurs only when <code>abs</code> is applied to the minimum representable value of a signed integer. That is, when <code>x == typemin(typeof(x))</code>, <code>abs(x) == x &lt; 0</code>, not <code>-x</code> as might be expected.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; abs(-3)
3

julia&gt; abs(1 + im)
1.4142135623730951

julia&gt; abs(typemin(Int64))
-9223372036854775808</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/int.jl#L144-L166" target="_blank">source</a></section><h3 id="Base.Checked.checked_abs">
<code>Base.Checked.checked_abs</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">Base.checked_abs(x)</pre>
<p>Calculates <code>abs(x)</code>, checking for overflow errors where applicable. For example, standard two's complement signed integers (e.g. <code>Int</code>) cannot represent <code>abs(typemin(Int))</code>, thus leading to an overflow.</p>
<p>The overflow protection may impose a perceptible performance penalty.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/checked.jl#L105-L113" target="_blank">source</a></section><h3 id="Base.Checked.checked_neg">
<code>Base.Checked.checked_neg</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">Base.checked_neg(x)</pre>
<p>Calculates <code>-x</code>, checking for overflow errors where applicable. For example, standard two's complement signed integers (e.g. <code>Int</code>) cannot represent <code>-typemin(Int)</code>, thus leading to an overflow.</p>
<p>The overflow protection may impose a perceptible performance penalty.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/checked.jl#L77-L85" target="_blank">source</a></section><h3 id="Base.Checked.checked_add">
<code>Base.Checked.checked_add</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">Base.checked_add(x, y)</pre>
<p>Calculates <code>x+y</code>, checking for overflow errors where applicable.</p>
<p>The overflow protection may impose a perceptible performance penalty.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/checked.jl#L156-L162" target="_blank">source</a></section><h3 id="Base.Checked.checked_sub">
<code>Base.Checked.checked_sub</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">Base.checked_sub(x, y)</pre>
<p>Calculates <code>x-y</code>, checking for overflow errors where applicable.</p>
<p>The overflow protection may impose a perceptible performance penalty.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/checked.jl#L213-L219" target="_blank">source</a></section><h3 id="Base.Checked.checked_mul">
<code>Base.Checked.checked_mul</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">Base.checked_mul(x, y)</pre>
<p>Calculates <code>x*y</code>, checking for overflow errors where applicable.</p>
<p>The overflow protection may impose a perceptible performance penalty.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/checked.jl#L278-L284" target="_blank">source</a></section><h3 id="Base.Checked.checked_div">
<code>Base.Checked.checked_div</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">Base.checked_div(x, y)</pre>
<p>Calculates <code>div(x,y)</code>, checking for overflow errors where applicable.</p>
<p>The overflow protection may impose a perceptible performance penalty.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/checked.jl#L307-L313" target="_blank">source</a></section><h3 id="Base.Checked.checked_rem">
<code>Base.Checked.checked_rem</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">Base.checked_rem(x, y)</pre>
<p>Calculates <code>x%y</code>, checking for overflow errors where applicable.</p>
<p>The overflow protection may impose a perceptible performance penalty.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/checked.jl#L316-L322" target="_blank">source</a></section><h3 id="Base.Checked.checked_fld">
<code>Base.Checked.checked_fld</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">Base.checked_fld(x, y)</pre>
<p>Calculates <code>fld(x,y)</code>, checking for overflow errors where applicable.</p>
<p>The overflow protection may impose a perceptible performance penalty.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/checked.jl#L325-L331" target="_blank">source</a></section><h3 id="Base.Checked.checked_mod">
<code>Base.Checked.checked_mod</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">Base.checked_mod(x, y)</pre>
<p>Calculates <code>mod(x,y)</code>, checking for overflow errors where applicable.</p>
<p>The overflow protection may impose a perceptible performance penalty.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/checked.jl#L334-L340" target="_blank">source</a></section><h3 id="Base.Checked.checked_cld">
<code>Base.Checked.checked_cld</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">Base.checked_cld(x, y)</pre>
<p>Calculates <code>cld(x,y)</code>, checking for overflow errors where applicable.</p>
<p>The overflow protection may impose a perceptible performance penalty.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/checked.jl#L343-L349" target="_blank">source</a></section><h3 id="Base.Checked.add_with_overflow">
<code>Base.Checked.add_with_overflow</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">Base.add_with_overflow(x, y) -&gt; (r, f)</pre>
<p>Calculates <code>r = x+y</code>, with the flag <code>f</code> indicating whether overflow has occurred.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/checked.jl#L126-L130" target="_blank">source</a></section><h3 id="Base.Checked.sub_with_overflow">
<code>Base.Checked.sub_with_overflow</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">Base.sub_with_overflow(x, y) -&gt; (r, f)</pre>
<p>Calculates <code>r = x-y</code>, with the flag <code>f</code> indicating whether overflow has occurred.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/checked.jl#L188-L192" target="_blank">source</a></section><h3 id="Base.Checked.mul_with_overflow">
<code>Base.Checked.mul_with_overflow</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">Base.mul_with_overflow(x, y) -&gt; (r, f)</pre>
<p>Calculates <code>r = x*y</code>, with the flag <code>f</code> indicating whether overflow has occurred.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/checked.jl#L228-L232" target="_blank">source</a></section><h3 id="Base.abs2">
<code>Base.abs2</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">abs2(x)</pre>
<p>Squared absolute value of <code>x</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; abs2(-3)
9</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/number.jl#L140-L150" target="_blank">source</a></section><h3 id="Base.copysign">
<code>Base.copysign</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">copysign(x, y) -&gt; z</pre>
<p>Return <code>z</code> which has the magnitude of <code>x</code> and the same sign as <code>y</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; copysign(1, -2)
-1

julia&gt; copysign(-1, 2)
1</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/number.jl#L169-L182" target="_blank">source</a></section><h3 id="Base.sign">
<code>Base.sign</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">sign(x)</pre>
<p>Return zero if <code>x==0</code> and <span>$x/|x|$</span> otherwise (i.e., ±1 for real <code>x</code>).</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/number.jl#L130-L134" target="_blank">source</a></section><h3 id="Base.signbit">
<code>Base.signbit</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">signbit(x)</pre>
<p>Returns <code>true</code> if the value of the sign of <code>x</code> is negative, otherwise <code>false</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; signbit(-4)
true

julia&gt; signbit(5)
false

julia&gt; signbit(5.5)
false

julia&gt; signbit(-4.1)
true</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/number.jl#L108-L127" target="_blank">source</a></section><h3 id="Base.flipsign">
<code>Base.flipsign</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">flipsign(x, y)</pre>
<p>Return <code>x</code> with its sign flipped if <code>y</code> is negative. For example <code>abs(x) = flipsign(x,x)</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; flipsign(5, 3)
5

julia&gt; flipsign(5, -3)
-5</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/number.jl#L153-L166" target="_blank">source</a></section><h3 id="Base.sqrt-Tuple{Real}">
<code>Base.sqrt</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">sqrt(x)</pre>
<p>Return <span>$\sqrt{x}$</span>. Throws <a href="../base/index#Core.DomainError"><code>DomainError</code></a> for negative <a href="../numbers/index#Core.Real"><code>Real</code></a> arguments. Use complex negative arguments instead. The prefix operator <code>√</code> is equivalent to <code>sqrt</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; sqrt(big(81))
9.0

julia&gt; sqrt(big(-81))
ERROR: DomainError with -81.0:
NaN result for non-NaN input.
Stacktrace:
 [1] sqrt(::BigFloat) at ./mpfr.jl:501
[...]

julia&gt; sqrt(big(complex(-81)))
0.0 + 9.0im</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L586-L607" target="_blank">source</a></section><h3 id="Base.isqrt">
<code>Base.isqrt</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">isqrt(n::Integer)</pre>
<p>Integer square root: the largest integer <code>m</code> such that <code>m*m &lt;= n</code>.</p>
<pre data-language="julia">julia&gt; isqrt(5)
2</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/intfuncs.jl#L909-L918" target="_blank">source</a></section><h3 id="Base.Math.cbrt">
<code>Base.Math.cbrt</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">cbrt(x::Real)</pre>
<p>Return the cube root of <code>x</code>, i.e. <span>$x^{1/3}$</span>. Negative values are accepted (returning the negative real root when <span>$x &lt; 0$</span>).</p>
<p>The prefix operator <code>∛</code> is equivalent to <code>cbrt</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; cbrt(big(27))
3.0

julia&gt; cbrt(big(-27))
-3.0</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/special/cbrt.jl#L17-L33" target="_blank">source</a></section><h3 id="Base.real-Tuple{Complex}">
<code>Base.real</code><span class="docstring-category">Method</span>
</h3>
<section><pre data-language="julia">real(z)</pre>
<p>Return the real part of the complex number <code>z</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; real(1 + 3im)
1</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/complex.jl#L52-L62" target="_blank">source</a></section><h3 id="Base.imag">
<code>Base.imag</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">imag(z)</pre>
<p>Return the imaginary part of the complex number <code>z</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; imag(1 + 3im)
3</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/complex.jl#L65-L75" target="_blank">source</a></section><h3 id="Base.reim">
<code>Base.reim</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">reim(z)</pre>
<p>Return both the real and imaginary parts of the complex number <code>z</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; reim(1 + 3im)
(1, 3)</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/complex.jl#L80-L90" target="_blank">source</a></section><h3 id="Base.conj">
<code>Base.conj</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">conj(z)</pre>
<p>Compute the complex conjugate of a complex number <code>z</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; conj(1 + 3im)
1 - 3im</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/complex.jl#L252-L262" target="_blank">source</a></section><h3 id="Base.angle">
<code>Base.angle</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">angle(z)</pre>
<p>Compute the phase angle in radians of a complex number <code>z</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; rad2deg(angle(1 + im))
45.0

julia&gt; rad2deg(angle(1 - im))
-45.0

julia&gt; rad2deg(angle(-1 - im))
-135.0</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/complex.jl#L568-L584" target="_blank">source</a></section><h3 id="Base.cis">
<code>Base.cis</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">cis(z)</pre>
<p>Return <span>$\exp(iz)$</span>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; cis(π) ≈ -1
true</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/complex.jl#L527-L537" target="_blank">source</a></section><h3 id="Base.cispi">
<code>Base.cispi</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">cispi(z)</pre>
<p>Compute <span>$\exp(i\pi x)$</span> more accurately than <code>cis(pi*x)</code>, especially for large <code>x</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; cispi(1)
-1.0 + 0.0im

julia&gt; cispi(0.25 + 1im)
0.030556854645952924 + 0.030556854645952924im</pre>
<div class="admonition is-compat">

<div class="admonition-body"><p>This function requires Julia 1.6 or later.</p></div>
</div>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/complex.jl#L546-L562" target="_blank">source</a></section><h3 id="Base.binomial">
<code>Base.binomial</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">binomial(n::Integer, k::Integer)</pre>
<p>The <em>binomial coefficient</em><span>$\binom{n}{k}$</span>, being the coefficient of the <span>$k$</span>th term in the polynomial expansion of <span>$(1+x)^n$</span>.</p>
<p>If <span>$n$</span> is non-negative, then it is the number of ways to choose <code>k</code> out of <code>n</code> items:</p>
<p class="math-container">\[\binom{n}{k} = \frac{n!}{k! (n-k)!}\]</p>
<p>where <span>$n!$</span> is the <a href="#Base.factorial"><code>factorial</code></a> function.</p>
<p>If <span>$n$</span> is negative, then it is defined in terms of the identity</p>
<p class="math-container">\[\binom{n}{k} = (-1)^k \binom{k-n-1}{k}\]</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; binomial(5, 3)
10

julia&gt; factorial(5) ÷ (factorial(5-3) * factorial(3))
10

julia&gt; binomial(-5, 3)
-35</pre>
<p><strong>See also</strong></p>
<ul><li><a href="#Base.factorial"><code>factorial</code></a></li></ul>
<p><strong>External links</strong></p>
<ul><li>
<a href="https://en.wikipedia.org/wiki/Binomial_coefficient">Binomial coefficient</a> on Wikipedia.</li></ul>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/intfuncs.jl#L966-L1000" target="_blank">source</a></section><h3 id="Base.factorial">
<code>Base.factorial</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">factorial(n::Integer)</pre>
<p>Factorial of <code>n</code>. If <code>n</code> is an <a href="../numbers/index#Core.Integer"><code>Integer</code></a>, the factorial is computed as an integer (promoted to at least 64 bits). Note that this may overflow if <code>n</code> is not small, but you can use <code>factorial(big(n))</code> to compute the result exactly in arbitrary precision.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; factorial(6)
720

julia&gt; factorial(21)
ERROR: OverflowError: 21 is too large to look up in the table; consider using `factorial(big(21))` instead
Stacktrace:
[...]

julia&gt; factorial(big(21))
51090942171709440000</pre>
<p><strong>See also</strong></p>
<ul><li><a href="#Base.binomial"><code>binomial</code></a></li></ul>
<p><strong>External links</strong></p>
<ul><li>
<a href="https://en.wikipedia.org/wiki/Factorial">Factorial</a> on Wikipedia.</li></ul>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/intfuncs.jl#L930-L956" target="_blank">source</a></section><h3 id="Base.gcd">
<code>Base.gcd</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">gcd(x, y...)</pre>
<p>Greatest common (positive) divisor (or zero if all arguments are zero). The arguments may be integer and rational numbers.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>Rational arguments require Julia 1.4 or later.</p></div>
</div>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; gcd(6,9)
3

julia&gt; gcd(6,-9)
3

julia&gt; gcd(6,0)
6

julia&gt; gcd(0,0)
0

julia&gt; gcd(1//3,2//3)
1//3

julia&gt; gcd(1//3,-2//3)
1//3

julia&gt; gcd(1//3,2)
1//3

julia&gt; gcd(0, 0, 10, 15)
5</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/intfuncs.jl#L5-L40" target="_blank">source</a></section><h3 id="Base.lcm">
<code>Base.lcm</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">lcm(x, y...)</pre>
<p>Least common (positive) multiple (or zero if any argument is zero). The arguments may be integer and rational numbers.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>Rational arguments require Julia 1.4 or later.</p></div>
</div>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; lcm(2,3)
6

julia&gt; lcm(-2,3)
6

julia&gt; lcm(0,3)
0

julia&gt; lcm(0,0)
0

julia&gt; lcm(1//3,2//3)
2//3

julia&gt; lcm(1//3,-2//3)
2//3

julia&gt; lcm(1//3,2)
2//1

julia&gt; lcm(1,3,5,7)
105</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/intfuncs.jl#L74-L109" target="_blank">source</a></section><h3 id="Base.gcdx">
<code>Base.gcdx</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">gcdx(a, b)</pre>
<p>Computes the greatest common (positive) divisor of <code>a</code> and <code>b</code> and their Bézout coefficients, i.e. the integer coefficients <code>u</code> and <code>v</code> that satisfy <span>$ua+vb = d = gcd(a, b)$</span>. <span>$gcdx(a, b)$</span> returns <span>$(d, u, v)$</span>.</p>
<p>The arguments may be integer and rational numbers.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>Rational arguments require Julia 1.4 or later.</p></div>
</div>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; gcdx(12, 42)
(6, -3, 1)

julia&gt; gcdx(240, 46)
(2, -9, 47)</pre>
<div class="admonition is-info">

<div class="admonition-body"><p>Bézout coefficients are <em>not</em> uniquely defined. <code>gcdx</code> returns the minimal Bézout coefficients that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) For signed integers, these coefficients <code>u</code> and <code>v</code> are minimal in the sense that <span>$|u| &lt; |y/d|$</span> and <span>$|v| &lt; |x/d|$</span>. Furthermore, the signs of <code>u</code> and <code>v</code> are chosen so that <code>d</code> is positive. For unsigned integers, the coefficients <code>u</code> and <code>v</code> might be near their <code>typemax</code>, and the identity then holds only via the unsigned integers' modulo arithmetic.</p></div>
</div>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/intfuncs.jl#L146-L177" target="_blank">source</a></section><h3 id="Base.ispow2">
<code>Base.ispow2</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">ispow2(n::Number) -&gt; Bool</pre>
<p>Test whether <code>n</code> is an integer power of two.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; ispow2(4)
true

julia&gt; ispow2(5)
false

julia&gt; ispow2(4.5)
false

julia&gt; ispow2(0.25)
true

julia&gt; ispow2(1//8)
true</pre>
<div class="admonition is-compat">

<div class="admonition-body"><p>Support for non-<code>Integer</code> arguments was added in Julia 1.6.</p></div>
</div>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/intfuncs.jl#L386-L411" target="_blank">source</a></section><h3 id="Base.nextpow">
<code>Base.nextpow</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">nextpow(a, x)</pre>
<p>The smallest <code>a^n</code> not less than <code>x</code>, where <code>n</code> is a non-negative integer. <code>a</code> must be greater than 1, and <code>x</code> must be greater than 0.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; nextpow(2, 7)
8

julia&gt; nextpow(2, 9)
16

julia&gt; nextpow(5, 20)
25

julia&gt; nextpow(4, 16)
16</pre>
<p>See also <a href="#Base.prevpow"><code>prevpow</code></a>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/intfuncs.jl#L416-L438" target="_blank">source</a></section><h3 id="Base.prevpow">
<code>Base.prevpow</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">prevpow(a, x)</pre>
<p>The largest <code>a^n</code> not greater than <code>x</code>, where <code>n</code> is a non-negative integer. <code>a</code> must be greater than 1, and <code>x</code> must not be less than 1.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; prevpow(2, 7)
4

julia&gt; prevpow(2, 9)
8

julia&gt; prevpow(5, 20)
5

julia&gt; prevpow(4, 16)
16</pre>
<p>See also <a href="#Base.nextpow"><code>nextpow</code></a>.</p>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/intfuncs.jl#L453-L474" target="_blank">source</a></section><h3 id="Base.nextprod">
<code>Base.nextprod</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">nextprod(factors::Union{Tuple,AbstractVector}, n)</pre>
<p>Next integer greater than or equal to <code>n</code> that can be written as <span>$\prod k_i^{p_i}$</span> for integers <span>$p_1$</span>, <span>$p_2$</span>, etcetera, for factors <span>$k_i$</span> in <code>factors</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; nextprod((2, 3), 105)
108

julia&gt; 2^2 * 3^3
108</pre>
<div class="admonition is-compat">

<div class="admonition-body"><p>The method that accepts a tuple requires Julia 1.6 or later.</p></div>
</div>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/combinatorics.jl#L292-L309" target="_blank">source</a></section><h3 id="Base.invmod">
<code>Base.invmod</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">invmod(n, m)</pre>
<p>Take the inverse of <code>n</code> modulo <code>m</code>: <code>y</code> such that <span>$n y = 1 \pmod m$</span>, and <span>$div(y,m) = 0$</span>. This will throw an error if <span>$m = 0$</span>, or if <span>$gcd(n,m) \neq 1$</span>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; invmod(2,5)
3

julia&gt; invmod(2,3)
2

julia&gt; invmod(5,6)
5</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/intfuncs.jl#L199-L217" target="_blank">source</a></section><h3 id="Base.powermod">
<code>Base.powermod</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">powermod(x::Integer, p::Integer, m)</pre>
<p>Compute <span>$x^p \pmod m$</span>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; powermod(2, 6, 5)
4

julia&gt; mod(2^6, 5)
4

julia&gt; powermod(5, 2, 20)
5

julia&gt; powermod(5, 2, 19)
6

julia&gt; powermod(5, 3, 19)
11</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/intfuncs.jl#L335-L357" target="_blank">source</a></section><h3 id="Base.ndigits">
<code>Base.ndigits</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">ndigits(n::Integer; base::Integer=10, pad::Integer=1)</pre>
<p>Compute the number of digits in integer <code>n</code> written in base <code>base</code> (<code>base</code> must not be in <code>[-1, 0, 1]</code>), optionally padded with zeros to a specified size (the result will never be less than <code>pad</code>).</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; ndigits(12345)
5

julia&gt; ndigits(1022, base=16)
3

julia&gt; string(1022, base=16)
"3fe"

julia&gt; ndigits(123, pad=5)
5</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/intfuncs.jl#L608-L629" target="_blank">source</a></section><h3 id="Base.widemul">
<code>Base.widemul</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">widemul(x, y)</pre>
<p>Multiply <code>x</code> and <code>y</code>, giving the result as a larger type.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; widemul(Float32(3.), 4.)
12.0</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/number.jl#L220-L230" target="_blank">source</a></section><h3 id="Base.Math.evalpoly">
<code>Base.Math.evalpoly</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">evalpoly(x, p)</pre>
<p>Evaluate the polynomial <span>$\sum_k x^{k-1} p[k]$</span> for the coefficients <code>p[1]</code>, <code>p[2]</code>, ...; that is, the coefficients are given in ascending order by power of <code>x</code>. Loops are unrolled at compile time if the number of coefficients is statically known, i.e. when <code>p</code> is a <code>Tuple</code>. This function generates efficient code using Horner's method if <code>x</code> is real, or using a Goertzel-like <sup class="footnote-reference"><a href="#footnote-DK62" id="citeref-DK62">[DK62]</a></sup> algorithm if <code>x</code> is complex.</p>
<div class="admonition is-compat">

<div class="admonition-body"><p>This function requires Julia 1.4 or later.</p></div>
</div>
<p><strong>Example</strong></p>
<pre data-language="julia">julia&gt; evalpoly(2, (1, 2, 3))
17</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L110-L130" target="_blank">source</a></section><h3 id="Base.Math.@evalpoly">
<code>Base.Math.@evalpoly</code><span class="docstring-category">Macro</span>
</h3>
<section><pre data-language="julia">@evalpoly(z, c...)</pre>
<p>Evaluate the polynomial <span>$\sum_k z^{k-1} c[k]$</span> for the coefficients <code>c[1]</code>, <code>c[2]</code>, ...; that is, the coefficients are given in ascending order by power of <code>z</code>. This macro expands to efficient inline code that uses either Horner's method or, for complex <code>z</code>, a more efficient Goertzel-like algorithm.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; @evalpoly(3, 1, 0, 1)
10

julia&gt; @evalpoly(2, 1, 0, 1)
5

julia&gt; @evalpoly(2, 1, 1, 1)
7</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/math.jl#L219-L238" target="_blank">source</a></section><h3 id="Base.FastMath.@fastmath">
<code>Base.FastMath.@fastmath</code><span class="docstring-category">Macro</span>
</h3>
<section><pre data-language="julia">@fastmath expr</pre>
<p>Execute a transformed version of the expression, which calls functions that may violate strict IEEE semantics. This allows the fastest possible operation, but results are undefined – be careful when doing this, as it may change numerical results.</p>
<p>This sets the <a href="http://llvm.org/docs/LangRef.html#fast-math-flags">LLVM Fast-Math flags</a>, and corresponds to the <code>-ffast-math</code> option in clang. See <a href="../../manual/performance-tips/index#man-performance-annotations">the notes on performance annotations</a> for more details.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; @fastmath 1+2
3

julia&gt; @fastmath(sin(3))
0.1411200080598672</pre>
<a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/fastmath.jl#L133-L153" target="_blank">source</a></section><h2 id="Customizable-binary-operators">
<a class="docs-heading-anchor" href="#Customizable-binary-operators">Customizable binary operators</a>
</h2>
<p>Some unicode characters can be used to define new binary operators that support infix notation. For example <code>⊗(x,y) = kron(x,y)</code> defines the <code>⊗</code> (otimes) function to be the Kronecker product, and one can call it as binary operator using infix syntax: <code>C = A ⊗ B</code> as well as with the usual prefix syntax <code>C = ⊗(A,B)</code>.</p>
<p>Other characters that support such extensions include \odot <code>⊙</code> and \oplus <code>⊕</code></p>
<p>The complete list is in the parser code: <a href="https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm">https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm</a></p>
<p>Those that are parsed like <code>*</code> (in terms of precedence) include <code>* / ÷ % &amp; ⋅ ∘ × |\\| ∩ ∧ ⊗ ⊘ ⊙ ⊚ ⊛ ⊠ ⊡ ⊓ ∗ ∙ ∤ ⅋ ≀ ⊼ ⋄ ⋆ ⋇ ⋉ ⋊ ⋋ ⋌ ⋏ ⋒ ⟑ ⦸ ⦼ ⦾ ⦿ ⧶ ⧷ ⨇ ⨰ ⨱ ⨲ ⨳ ⨴ ⨵ ⨶ ⨷ ⨸ ⨻ ⨼ ⨽ ⩀ ⩃ ⩄ ⩋ ⩍ ⩎ ⩑ ⩓ ⩕ ⩘ ⩚ ⩜ ⩞ ⩟ ⩠ ⫛ ⊍ ▷ ⨝ ⟕ ⟖ ⟗</code> and those that are parsed like <code>+</code> include <code>+ - |\|| ⊕ ⊖ ⊞ ⊟ |++| ∪ ∨ ⊔ ± ∓ ∔ ∸ ≏ ⊎ ⊻ ⊽ ⋎ ⋓ ⧺ ⧻ ⨈ ⨢ ⨣ ⨤ ⨥ ⨦ ⨧ ⨨ ⨩ ⨪ ⨫ ⨬ ⨭ ⨮ ⨹ ⨺ ⩁ ⩂ ⩅ ⩊ ⩌ ⩏ ⩐ ⩒ ⩔ ⩖ ⩗ ⩛ ⩝ ⩡ ⩢ ⩣</code> There are many others that are related to arrows, comparisons, and powers.</p>
<section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-DK62">
<a class="tag is-link" href="#citeref-DK62">DK62</a>Donald Knuth, Art of Computer Programming, Volume 2: Seminumerical Algorithms, Sec. 4.6.4.</li></ul></section><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://docs.julialang.org/en/v1.6.0/base/math/" class="_attribution-link" target="_blank">https://docs.julialang.org/en/v1.6.0/base/math/</a>
  </p>
</div>
