<h1 data-toc="cancellation-and-timeouts" id="cancellation-and-timeouts.md">Cancellation and timeouts</h1>
<p id="e5a7efeb">This section covers coroutine cancellation and timeouts.</p>
<section class="chapter"><h2 id="cancelling-coroutine-execution" data-toc="cancellation-and-timeouts#cancelling-coroutine-execution">Cancelling coroutine execution</h2>
<p id="1c298410">In a long-running application you might need fine-grained control on your background coroutines. For example, a user might have closed the page that launched a coroutine and now its result is no longer needed and its operation can be cancelled. The <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html" id="6d9a939b" data-external="true" rel="noopener noreferrer">launch</a> function returns a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html" id="10d378bc" data-external="true" rel="noopener noreferrer">Job</a> that can be used to cancel the running coroutine:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* fun main() = runBlocking { //sampleStart val job = launch { repeat(1000) { i -&gt; println("job: I'm sleeping $i ...") delay(500L) } } delay(1300L) // delay a bit println("main: I'm tired of waiting!") job.cancel() // cancels the job job.join() // waits for job's completion println("main: Now I can quit.") //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="e9b302bb"><p id="e63c9ba1">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-cancel-01.kt" id="4f0f212e" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="8d9ffba">It produces the following output:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">job: I'm sleeping 0 ... job: I'm sleeping 1 ... job: I'm sleeping 2 ... main: I'm tired of waiting! main: Now I can quit. </pre>
<p id="f0791b1d">As soon as main invokes <code class="code ">job.cancel</code>, we don't see any output from the other coroutine because it was cancelled. There is also a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html" id="4a56f812" data-external="true" rel="noopener noreferrer">Job</a> extension function <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel-and-join.html" id="72e4ca58" data-external="true" rel="noopener noreferrer">cancelAndJoin</a> that combines <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel.html" id="3a4682df" data-external="true" rel="noopener noreferrer">cancel</a> and <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html" id="d3153ca1" data-external="true" rel="noopener noreferrer">join</a> invocations.</p></section><section class="chapter"><h2 id="cancellation-is-cooperative" data-toc="cancellation-and-timeouts#cancellation-is-cooperative">Cancellation is cooperative</h2>
<p id="ff6b5d94">Coroutine cancellation is <em id="8b2367f5" class="">cooperative</em>. A coroutine code has to cooperate to be cancellable. All the suspending functions in <code class="code ">kotlinx.coroutines</code> are <em id="c83f4cc1" class="">cancellable</em>. They check for cancellation of coroutine and throw <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html" id="f3b7f4fe" data-external="true" rel="noopener noreferrer">CancellationException</a> when cancelled. However, if a coroutine is working in a computation and does not check for cancellation, then it cannot be cancelled, like the following example shows:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* fun main() = runBlocking { //sampleStart val startTime = System.currentTimeMillis() val job = launch(Dispatchers.Default) { var nextPrintTime = startTime var i = 0 while (i &lt; 5) { // computation loop, just wastes CPU // print a message twice a second if (System.currentTimeMillis() &gt;= nextPrintTime) { println("job: I'm sleeping ${i++} ...") nextPrintTime += 500L } } } delay(1300L) // delay a bit println("main: I'm tired of waiting!") job.cancelAndJoin() // cancels the job and waits for its completion println("main: Now I can quit.") //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="5445757a"><p id="61f57b0a">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-cancel-02.kt" id="ebbc8e4b" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="bc30ffdd">Run it to see that it continues to print "I'm sleeping" even after cancellation until the job completes by itself after five iterations.</p></section><section class="chapter"><h2 id="making-computation-code-cancellable" data-toc="cancellation-and-timeouts#making-computation-code-cancellable">Making computation code cancellable</h2>
<p id="225314f6">There are two approaches to making computation code cancellable. The first one is to periodically invoke a suspending function that checks for cancellation. There is a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html" id="4e34a668" data-external="true" rel="noopener noreferrer">yield</a> function that is a good choice for that purpose. The other one is to explicitly check the cancellation status. Let us try the latter approach.</p>
<p id="78efbb8f">Replace <code class="code ">while (i &lt; 5)</code> in the previous example with <code class="code ">while (isActive)</code> and rerun it.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* fun main() = runBlocking { //sampleStart val startTime = System.currentTimeMillis() val job = launch(Dispatchers.Default) { var nextPrintTime = startTime var i = 0 while (isActive) { // cancellable computation loop // print a message twice a second if (System.currentTimeMillis() &gt;= nextPrintTime) { println("job: I'm sleeping ${i++} ...") nextPrintTime += 500L } } } delay(1300L) // delay a bit println("main: I'm tired of waiting!") job.cancelAndJoin() // cancels the job and waits for its completion println("main: Now I can quit.") //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="805cfbd5"><p id="826f94b">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-cancel-03.kt" id="34c1057a" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="26e2d0e7">As you can see, now this loop is cancelled. <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/is-active.html" id="da000596" data-external="true" rel="noopener noreferrer">isActive</a> is an extension property available inside the coroutine via the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html" id="65203997" data-external="true" rel="noopener noreferrer">CoroutineScope</a> object.</p></section><section class="chapter"><h2 id="closing-resources-with-finally" data-toc="cancellation-and-timeouts#closing-resources-with-finally">Closing resources with finally</h2>
<p id="69730793">Cancellable suspending functions throw <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html" id="bf6099a" data-external="true" rel="noopener noreferrer">CancellationException</a> on cancellation which can be handled in the usual way. For example, <code class="code ">try {...} finally {...}</code> expression and Kotlin <code class="code ">use</code> function execute their finalization actions normally when a coroutine is cancelled:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* fun main() = runBlocking { //sampleStart val job = launch { try { repeat(1000) { i -&gt; println("job: I'm sleeping $i ...") delay(500L) } } finally { println("job: I'm running finally") } } delay(1300L) // delay a bit println("main: I'm tired of waiting!") job.cancelAndJoin() // cancels the job and waits for its completion println("main: Now I can quit.") //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="38209e55"><p id="49cf94b7">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-cancel-04.kt" id="694fa159" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="485ca549">Both <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html" id="c17776a3" data-external="true" rel="noopener noreferrer">join</a> and <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel-and-join.html" id="b3d46199" data-external="true" rel="noopener noreferrer">cancelAndJoin</a> wait for all finalization actions to complete, so the example above produces the following output:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">job: I'm sleeping 0 ... job: I'm sleeping 1 ... job: I'm sleeping 2 ... main: I'm tired of waiting! job: I'm running finally main: Now I can quit. </pre></section><section class="chapter"><h2 id="run-non-cancellable-block" data-toc="cancellation-and-timeouts#run-non-cancellable-block">Run non-cancellable block</h2>
<p id="c56bc5e9">Any attempt to use a suspending function in the <code class="code ">finally</code> block of the previous example causes <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html" id="368ff3c" data-external="true" rel="noopener noreferrer">CancellationException</a>, because the coroutine running this code is cancelled. Usually, this is not a problem, since all well-behaving closing operations (closing a file, cancelling a job, or closing any kind of a communication channel) are usually non-blocking and do not involve any suspending functions. However, in the rare case when you need to suspend in a cancelled coroutine you can wrap the corresponding code in <code class="code ">withContext(NonCancellable) {...}</code> using <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html" id="7ea7eed8" data-external="true" rel="noopener noreferrer">withContext</a> function and <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-non-cancellable/index.html" id="cacb4568" data-external="true" rel="noopener noreferrer">NonCancellable</a> context as the following example shows:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* fun main() = runBlocking { //sampleStart val job = launch { try { repeat(1000) { i -&gt; println("job: I'm sleeping $i ...") delay(500L) } } finally { withContext(NonCancellable) { println("job: I'm running finally") delay(1000L) println("job: And I've just delayed for 1 sec because I'm non-cancellable") } } } delay(1300L) // delay a bit println("main: I'm tired of waiting!") job.cancelAndJoin() // cancels the job and waits for its completion println("main: Now I can quit.") //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="48b5f"><p id="bb085124">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-cancel-05.kt" id="89dd4d5e" data-external="true" rel="noopener noreferrer">here</a>.</p></aside></section><section class="chapter"><h2 id="timeout" data-toc="cancellation-and-timeouts#timeout">Timeout</h2>
<p id="f41b0329">The most obvious practical reason to cancel execution of a coroutine is because its execution time has exceeded some timeout. While you can manually track the reference to the corresponding <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html" id="91e2a93e" data-external="true" rel="noopener noreferrer">Job</a> and launch a separate coroutine to cancel the tracked one after delay, there is a ready to use <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html" id="7bb7ca78" data-external="true" rel="noopener noreferrer">withTimeout</a> function that does it. Look at the following example:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* fun main() = runBlocking { //sampleStart withTimeout(1300L) { repeat(1000) { i -&gt; println("I'm sleeping $i ...") delay(500L) } } //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="92560124"><p id="48ba4d0d">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-cancel-06.kt" id="be2d0cc0" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="83a86f90">It produces the following output:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">I'm sleeping 0 ... I'm sleeping 1 ... I'm sleeping 2 ... Exception in thread "main" kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms </pre>
<p id="a136118">The <code class="code ">TimeoutCancellationException</code> that is thrown by <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html" id="483d5d6d" data-external="true" rel="noopener noreferrer">withTimeout</a> is a subclass of <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html" id="e14df42a" data-external="true" rel="noopener noreferrer">CancellationException</a>. We have not seen its stack trace printed on the console before. That is because inside a cancelled coroutine <code class="code ">CancellationException</code> is considered to be a normal reason for coroutine completion. However, in this example we have used <code class="code ">withTimeout</code> right inside the <code class="code ">main</code> function.</p>
<p id="63098d43">Since cancellation is just an exception, all resources are closed in the usual way. You can wrap the code with timeout in a <code class="code ">try {...} catch (e: TimeoutCancellationException) {...}</code> block if you need to do some additional action specifically on any kind of timeout or use the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout-or-null.html" id="816a6cde" data-external="true" rel="noopener noreferrer">withTimeoutOrNull</a> function that is similar to <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html" id="913bd859" data-external="true" rel="noopener noreferrer">withTimeout</a> but returns <code class="code ">null</code> on timeout instead of throwing an exception:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* fun main() = runBlocking { //sampleStart val result = withTimeoutOrNull(1300L) { repeat(1000) { i -&gt; println("I'm sleeping $i ...") delay(500L) } "Done" // will get cancelled before it produces this result } println("Result is $result") //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="ca52c7a4"><p id="b518db8c">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-cancel-07.kt" id="7e672027" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="38e0567d">There is no longer an exception when running this code:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">I'm sleeping 0 ... I'm sleeping 1 ... I'm sleeping 2 ... Result is null </pre></section><section class="chapter"><h2 id="asynchronous-timeout-and-resources" data-toc="cancellation-and-timeouts#asynchronous-timeout-and-resources">Asynchronous timeout and resources</h2>
<p id="d35f63eb">The timeout event in <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html" id="9c30239e" data-external="true" rel="noopener noreferrer">withTimeout</a> is asynchronous with respect to the code running in its block and may happen at any time, even right before the return from inside of the timeout block. Keep this in mind if you open or acquire some resource inside the block that needs closing or release outside of the block.</p>
<p id="34cc7ca9">For example, here we imitate a closeable resource with the <code class="code ">Resource</code> class, that simply keeps track of how many times it was created by incrementing the <code class="code ">acquired</code> counter and decrementing this counter from its <code class="code ">close</code> function. Let us run a lot of coroutines with the small timeout try acquire this resource from inside of the <code class="code ">withTimeout</code> block after a bit of delay and release it from outside.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* //sampleStart var acquired = 0 class Resource { init { acquired++ } // Acquire the resource fun close() { acquired-- } // Release the resource } fun main() { runBlocking { repeat(100_000) { // Launch 100K coroutines launch { val resource = withTimeout(60) { // Timeout of 60 ms delay(50) // Delay for 50 ms Resource() // Acquire a resource and return it from withTimeout block } resource.close() // Release the resource } } } // Outside of runBlocking all coroutines have completed println(acquired) // Print the number of resources still acquired } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="ab2eee8"><p id="81636fb">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-cancel-08.kt" id="549e4e92" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="d140b3fb">If you run the above code you'll see that it does not always print zero, though it may depend on the timings of your machine you may need to tweak timeouts in this example to actually see non-zero values.</p>
<aside data-type="note" class="prompt" data-title="" id="9eb9046e"><p id="77daa19">Note, that incrementing and decrementing <code class="code ">acquired</code> counter here from 100K coroutines is completely safe, since it always happens from the same main thread. More on that will be explained in the chapter on coroutine context.</p></aside><p id="8ebf579b">To workaround this problem you can store a reference to the resource in the variable as opposed to returning it from the <code class="code ">withTimeout</code> block.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* var acquired = 0 class Resource { init { acquired++ } // Acquire the resource fun close() { acquired-- } // Release the resource } fun main() { //sampleStart runBlocking { repeat(100_000) { // Launch 100K coroutines launch { var resource: Resource? = null // Not acquired yet try { withTimeout(60) { // Timeout of 60 ms delay(50) // Delay for 50 ms resource = Resource() // Store a resource to the variable if acquired } // We can do something else with the resource here } finally { resource?.close() // Release the resource if it was acquired } } } } // Outside of runBlocking all coroutines have completed println(acquired) // Print the number of resources still acquired //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="924b6b3b"><p id="fe3fd811">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-cancel-09.kt" id="79748284" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="a4ea4412">This example always prints zero. Resources do not leak.</p></section><div class="last-modified"> Last modified: 13 September 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="coroutines-basics">Coroutines basics</a> <a class="navigation-links__next" href="composing-suspending-functions">Composing suspending functions</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/cancellation-and-timeouts.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/cancellation-and-timeouts.html</a>
  </p>
</div>
