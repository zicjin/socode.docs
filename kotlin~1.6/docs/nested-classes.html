<h1 data-toc="nested-classes" id="nested-classes.md">Nested and inner classes</h1>
<p id="80396092">Classes can be nested in other classes:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class Outer { private val bar: Int = 1 class Nested { fun foo() = 2 } } val demo = Outer.Nested().foo() // == 2 </pre>
<p id="d4a2ef04">You can also use interfaces with nesting. All combinations of classes and interfaces are possible: You can nest interfaces in classes, classes in interfaces, and interfaces in interfaces.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">interface OuterInterface { class InnerClass interface InnerInterface } class OuterClass { class InnerClass interface InnerInterface } </pre>
<section class="chapter"><h2 id="inner-classes" data-toc="nested-classes#inner-classes">Inner classes</h2>
<p id="185fb47f">A nested class marked as <code class="code ">inner</code> can access the members of its outer class. Inner classes carry a reference to an object of an outer class:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class Outer { private val bar: Int = 1 inner class Inner { fun foo() = bar } } val demo = Outer().Inner().foo() // == 1 </pre>
<p id="31e4df9e">See <a href="this-expressions" id="13820a04">Qualified <code class="code ">this</code> expressions</a> to learn about disambiguation of <code class="code ">this</code> in inner classes.</p></section><section class="chapter"><h2 id="anonymous-inner-classes" data-toc="nested-classes#anonymous-inner-classes">Anonymous inner classes</h2>
<p id="75e5444f">Anonymous inner class instances are created using an <a href="object-declarations#object-expressions" id="eea98af0">object expression</a>:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">window.addMouseListener(object : MouseAdapter() { override fun mouseClicked(e: MouseEvent) { ... } override fun mouseEntered(e: MouseEvent) { ... } }) </pre>
<aside data-type="note" class="prompt" data-title="" id="b02413db"><p id="7c0e3837">On the JVM, if the object is an instance of a functional Java interface (that means a Java interface with a single abstract method), you can create it using a lambda expression prefixed with the type of the interface:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val listener = ActionListener { println("clicked") } </pre></aside></section><div class="last-modified"> Last modified: 11 February 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="generics">Generics: in, out, where</a> <a class="navigation-links__next" href="enum-classes">Enum classes</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/nested-classes.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/nested-classes.html</a>
  </p>
</div>
