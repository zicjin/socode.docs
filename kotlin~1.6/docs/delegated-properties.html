<h1 data-toc="delegated-properties" id="delegated-properties.md">Delegated properties</h1>
<p id="d48d65c6">With some common kinds of properties, even though you can implement them manually every time you need them, it is more helpful to implement them once, add them to a library, and reuse them later. For example:</p>
<ul class="list _ul" id="6ab047d2">
<li class="list__item" id="37b61324"><p><em id="1110cc0c" class="">Lazy</em> properties: the value is computed only on first access.</p></li>
<li class="list__item" id="8b338653"><p><em id="e864efba" class="">Observable</em> properties: listeners are notified about changes to this property.</p></li>
<li class="list__item" id="5fcf1908"><p>Storing properties in a <em id="e50a6de9" class="">map</em> instead of a separate field for each property.</p></li>
</ul>
<p id="fe2eb181">To cover these (and other) cases, Kotlin supports <em id="6ef5059e" class="">delegated properties</em>:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class Example { var p: String by Delegate() } </pre>
<p id="ab76162d">The syntax is: <code class="code ">val/var &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt;</code>. The expression after <code class="code ">by</code> is a <em id="d34318a" class="">delegate</em>, because the <code class="code ">get()</code> (and <code class="code ">set()</code>) that correspond to the property will be delegated to its <code class="code ">getValue()</code> and <code class="code ">setValue()</code> methods. Property delegates don’t have to implement an interface, but they have to provide a <code class="code ">getValue()</code> function (and <code class="code ">setValue()</code> for <code class="code ">var</code>s).</p>
<p id="311276c7">For example:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">import kotlin.reflect.KProperty class Delegate { operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String { return "$thisRef, thank you for delegating '${property.name}' to me!" } operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) { println("$value has been assigned to '${property.name}' in $thisRef.") } } </pre>
<p id="83c68fad">When you read from <code class="code ">p</code>, which delegates to an instance of <code class="code ">Delegate</code>, the <code class="code ">getValue()</code> function from <code class="code ">Delegate</code> is called. Its first parameter is the object you read <code class="code ">p</code> from, and the second parameter holds a description of <code class="code ">p</code> itself (for example, you can take its name).</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val e = Example() println(e.p) </pre>
<p id="40580303">This prints:</p>
<p><code class="code ">Example@33a17727, thank you for delegating 'p' to me!</code></p>
<p id="bce84ee3">Similarly, when you assign to <code class="code ">p</code>, the <code class="code ">setValue()</code> function is called. The first two parameters are the same, and the third holds the value being assigned:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">e.p = "NEW" </pre>
<p id="dfbb059c">This prints:</p>
<p><code class="code ">NEW has been assigned to 'p' in Example@33a17727.</code></p>
<p id="7259ab31">The specification of the requirements to the delegated object can be found <a href="#property-delegate-requirements" id="e2433bc2">below</a>.</p>
<p id="ab43d4a6">You can declare a delegated property inside a function or code block; it doesn’t have to be a member of a class. Below you can find <a href="#local-delegated-properties" id="bab48b82">an example</a>.</p>
<section class="chapter"><h2 id="standard-delegates" data-toc="delegated-properties#standard-delegates">Standard delegates</h2>
<p id="d79a44d2">The Kotlin standard library provides factory methods for several useful kinds of delegates.</p>
<section class="chapter"><h3 id="lazy-properties" data-toc="delegated-properties#lazy-properties">Lazy properties</h3>
<p id="c5efa7ae"><a href="../api/latest/jvm/stdlib/kotlin/lazy" id="a08cac43" data-external="true" rel="noopener noreferrer"><code class="code ">lazy()</code></a> is a function that takes a lambda and returns an instance of <code class="code ">Lazy&lt;T&gt;</code>, which can serve as a delegate for implementing a lazy property. The first call to <code class="code ">get()</code> executes the lambda passed to <code class="code ">lazy()</code> and remembers the result. Subsequent calls to <code class="code ">get()</code> simply return the remembered result.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-language="kotlin">val lazyValue: String by lazy { println("computed!") "Hello" } fun main() { println(lazyValue) println(lazyValue) } </pre>
<p id="2f81843d">By default, the evaluation of lazy properties is <em id="c0fcb273" class="">synchronized</em>: the value is computed only in one thread, but all threads will see the same value. If the synchronization of the initialization delegate is not required to allow multiple threads to execute it simultaneously, pass <code class="code ">LazyThreadSafetyMode.PUBLICATION</code> as a parameter to <code class="code ">lazy()</code>.</p>
<p id="13def579">If you're sure that the initialization will always happen in the same thread as the one where you use the property, you can use <code class="code ">LazyThreadSafetyMode.NONE</code>. It doesn't incur any thread-safety guarantees and related overhead.</p></section><section class="chapter"><h3 id="observable-properties" data-toc="delegated-properties#observable-properties">Observable properties</h3>
<p id="1de1394a"><a href="../api/latest/jvm/stdlib/kotlin.properties/-delegates/observable" id="4f8da047" data-external="true" rel="noopener noreferrer"><code class="code ">Delegates.observable()</code></a> takes two arguments: the initial value and a handler for modifications.</p>
<p id="8825c65a">The handler is called every time you assign to the property (<em id="dd7f258c" class="">after</em> the assignment has been performed). It has three parameters: the property being assigned to, the old value, and the new value:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-language="kotlin">import kotlin.properties.Delegates class User { var name: String by Delegates.observable("&lt;no name&gt;") { prop, old, new -&gt; println("$old -&gt; $new") } } fun main() { val user = User() user.name = "first" user.name = "second" } </pre>
<p id="a22e1f4d">If you want to intercept assignments and <em id="35548bb7" class="">veto</em> them, use <a href="../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable" id="956679fc" data-external="true" rel="noopener noreferrer"><code class="code ">vetoable()</code></a> instead of <code class="code ">observable()</code>. The handler passed to <code class="code ">vetoable</code> will be called <em id="6c796323" class="">before</em> the assignment of a new property value.</p></section></section><section class="chapter"><h2 id="delegating-to-another-property" data-toc="delegated-properties#delegating-to-another-property">Delegating to another property</h2>
<p id="63ed89e6">A property can delegate its getter and setter to another property. Such delegation is available for both top-level and class properties (member and extension). The delegate property can be:</p>
<ul class="list _ul" id="b5154762">
<li class="list__item" id="24766f93"><p>A top-level property</p></li>
<li class="list__item" id="48c580ce"><p>A member or an extension property of the same class</p></li>
<li class="list__item" id="c4f65866"><p>A member or an extension property of another class</p></li>
</ul>
<p id="5f46f702">To delegate a property to another property, use the <code class="code ">::</code> qualifier in the delegate name, for example, <code class="code ">this::delegate</code> or <code class="code ">MyClass::delegate</code>.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">var topLevelInt: Int = 0 class ClassWithDelegate(val anotherClassInt: Int) class MyClass(var memberInt: Int, val anotherClassInstance: ClassWithDelegate) { var delegatedToMember: Int by this::memberInt var delegatedToTopLevel: Int by ::topLevelInt val delegatedToAnotherClass: Int by anotherClassInstance::anotherClassInt } var MyClass.extDelegated: Int by ::topLevelInt </pre>
<p id="ddf91ab3">This may be useful, for example, when you want to rename a property in a backward-compatible way: introduce a new property, annotate the old one with the <code class="code ">@Deprecated</code> annotation, and delegate its implementation.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4" data-language="kotlin">class MyClass { var newName: Int = 0 @Deprecated("Use 'newName' instead", ReplaceWith("newName")) var oldName: Int by this::newName } fun main() { val myClass = MyClass() // Notification: 'oldName: Int' is deprecated. // Use 'newName' instead myClass.oldName = 42 println(myClass.newName) // 42 } </pre></section><section class="chapter"><h2 id="storing-properties-in-a-map" data-toc="delegated-properties#storing-properties-in-a-map">Storing properties in a map</h2>
<p id="16e04e4f">One common use case is storing the values of properties in a map. This comes up often in applications for things like parsing JSON or performing other dynamic tasks. In this case, you can use the map instance itself as the delegate for a delegated property.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class User(val map: Map&lt;String, Any?&gt;) { val name: String by map val age: Int by map } </pre>
<p id="c8862d78">In this example, the constructor takes a map:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val user = User(mapOf( "name" to "John Doe", "age" to 25 )) </pre>
<p id="e6bb1a6e">Delegated properties take values from this map through string keys, which are associated with the names of properties:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-language="kotlin">class User(val map: Map&lt;String, Any?&gt;) { val name: String by map val age: Int by map } fun main() { val user = User(mapOf( "name" to "John Doe", "age" to 25 )) //sampleStart println(user.name) // Prints "John Doe" println(user.age) // Prints 25 //sampleEnd } </pre>
<p id="59848f59">This also works for <code class="code ">var</code> ’s properties if you use a <code class="code ">MutableMap</code> instead of a read-only <code class="code ">Map</code>:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class MutableUser(val map: MutableMap&lt;String, Any?&gt;) { var name: String by map var age: Int by map } </pre></section><section class="chapter"><h2 id="local-delegated-properties" data-toc="delegated-properties#local-delegated-properties">Local delegated properties</h2>
<p id="eab56558">You can declare local variables as delegated properties. For example, you can make a local variable lazy:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun example(computeFoo: () -&gt; Foo) { val memoizedFoo by lazy(computeFoo) if (someCondition &amp;&amp; memoizedFoo.isValid()) { memoizedFoo.doSomething() } } </pre>
<p id="a8b59b62">The <code class="code ">memoizedFoo</code> variable will be computed on first access only. If <code class="code ">someCondition</code> fails, the variable won't be computed at all.</p></section><section class="chapter"><h2 id="property-delegate-requirements" data-toc="delegated-properties#property-delegate-requirements">Property delegate requirements</h2>
<p id="24ecde76">For a <em id="5b5dd6c6" class="">read-only</em> property (<code class="code ">val</code>), a delegate should provide an operator function <code class="code ">getValue()</code> with the following parameters:</p>
<ul class="list _ul" id="45a38a33">
<li class="list__item" id="86fcf53"><p><code class="code ">thisRef</code> must be the same type as, or a supertype of, the <em id="20db5ade" class="">property owner</em> (for extension properties, it should be the type being extended).</p></li>
<li class="list__item" id="cbd36c9d"><p><code class="code ">property</code> must be of type <code class="code ">KProperty&lt;*&gt;</code> or its supertype.</p></li>
</ul>
<p id="ad904a86"><code class="code ">getValue()</code> must return the same type as the property (or its subtype).</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class Resource class Owner { val valResource: Resource by ResourceDelegate() } class ResourceDelegate { operator fun getValue(thisRef: Owner, property: KProperty&lt;*&gt;): Resource { return Resource() } } </pre>
<p id="4e680db4">For a <em id="902b489a" class="">mutable</em> property (<code class="code ">var</code>), a delegate has to additionally provide an operator function <code class="code ">setValue()</code> with the following parameters:</p>
<ul class="list _ul" id="c70354c3">
<li class="list__item" id="c47ff029"><p><code class="code ">thisRef</code> must be the same type as, or a supertype of, the <em id="91cac576" class="">property owner</em> (for extension properties, it should be the type being extended).</p></li>
<li class="list__item" id="b4d87681"><p><code class="code ">property</code> must be of type <code class="code ">KProperty&lt;*&gt;</code> or its supertype.</p></li>
<li class="list__item" id="904065b5"><p><code class="code ">value</code> must be of the same type as the property (or its supertype).</p></li>
</ul>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class Resource class Owner { var varResource: Resource by ResourceDelegate() } class ResourceDelegate(private var resource: Resource = Resource()) { operator fun getValue(thisRef: Owner, property: KProperty&lt;*&gt;): Resource { return resource } operator fun setValue(thisRef: Owner, property: KProperty&lt;*&gt;, value: Any?) { if (value is Resource) { resource = value } } } </pre>
<p id="d2fe74ea"><code class="code ">getValue()</code> and/or <code class="code ">setValue()</code> functions can be provided either as member functions of the delegate class or as extension functions. The latter is handy when you need to delegate a property to an object that doesn't originally provide these functions. Both of the functions need to be marked with the <code class="code ">operator</code> keyword.</p>
<p id="c4cf858b">You can create delegates as anonymous objects without creating new classes, by using the interfaces <code class="code ">ReadOnlyProperty</code> and <code class="code ">ReadWriteProperty</code> from the Kotlin standard library. They provide the required methods: <code class="code ">getValue()</code> is declared in <code class="code ">ReadOnlyProperty</code>; <code class="code ">ReadWriteProperty</code> extends it and adds <code class="code ">setValue()</code>. This means you can pass a <code class="code ">ReadWriteProperty</code> whenever a <code class="code ">ReadOnlyProperty</code> is expected.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun resourceDelegate(): ReadWriteProperty&lt;Any?, Int&gt; = object : ReadWriteProperty&lt;Any?, Int&gt; { var curValue = 0 override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): Int = curValue override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: Int) { curValue = value } } val readOnly: Int by resourceDelegate() // ReadWriteProperty as val var readWrite: Int by resourceDelegate() </pre>
<section class="chapter"><h3 id="translation-rules-for-delegated-properties" data-toc="delegated-properties#translation-rules-for-delegated-properties">Translation rules for delegated properties</h3>
<p id="33985a11">Under the hood, the Kotlin compiler generates an auxiliary property for every delegated property and then delegates to it. For example, for the property <code class="code ">prop</code> it generates the hidden property <code class="code ">prop$delegate</code>, and the code of the accessors simply delegates to this additional property:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class C { var prop: Type by MyDelegate() } // this code is generated by the compiler instead: class C { private val prop$delegate = MyDelegate() var prop: Type get() = prop$delegate.getValue(this, this::prop) set(value: Type) = prop$delegate.setValue(this, this::prop, value) } </pre>
<p id="21261296">The Kotlin compiler provides all the necessary information about <code class="code ">prop</code> in the arguments: the first argument <code class="code ">this</code> refers to an instance of the outer class <code class="code ">C</code>, and <code class="code ">this::prop</code> is a reflection object of the <code class="code ">KProperty</code> type describing <code class="code ">prop</code> itself.</p></section><section class="chapter"><h3 id="translation-rules-when-delegating-to-another-property" data-toc="delegated-properties#translation-rules-when-delegating-to-another-property">Translation rules when delegating to another property</h3>
<p id="9a5f37ec">When delegating to another property, the Kotlin compiler generates immediate access to the referenced property. This means that the compiler doesn't generate the field <code class="code ">prop$delegate</code>. This optimization helps save memory.</p>
<p id="f2a9c335">Take the following code, for example:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class C&lt;Type&gt; { private var impl: Type = ... var prop: Type by ::impl } </pre>
<p id="d153dc7a">Property accessors of the <code class="code ">prop</code> variable invoke the <code class="code ">impl</code> variable directly, skipping the delegated property's <code class="code ">getValue</code>and <code class="code ">setValue</code> operators, and thus the <code class="code ">KProperty</code> reference object is not needed.</p>
<p id="d32bb017">For the code above, the compiler generates the following code:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class C&lt;Type&gt; { private var impl: Type = ... var prop: Type get() = impl set(value) { impl = value } fun getProp$delegate(): Type = impl // This method is needed only for reflection } </pre></section><section class="chapter"><h3 id="providing-a-delegate" data-toc="delegated-properties#providing-a-delegate">Providing a delegate</h3>
<p id="519c0d36">By defining the <code class="code ">provideDelegate</code> operator, you can extend the logic for creating the object to which the property implementation is delegated. If the object used on the right-hand side of <code class="code ">by</code> defines <code class="code ">provideDelegate</code> as a member or extension function, that function will be called to create the property delegate instance.</p>
<p id="7a6cadcf">One of the possible use cases of <code class="code ">provideDelegate</code> is to check the consistency of the property upon its initialization.</p>
<p id="76d4cfc0">For example, to check the property name before binding, you can write something like this:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class ResourceDelegate&lt;T&gt; : ReadOnlyProperty&lt;MyUI, T&gt; { override fun getValue(thisRef: MyUI, property: KProperty&lt;*&gt;): T { ... } } class ResourceLoader&lt;T&gt;(id: ResourceID&lt;T&gt;) { operator fun provideDelegate( thisRef: MyUI, prop: KProperty&lt;*&gt; ): ReadOnlyProperty&lt;MyUI, T&gt; { checkProperty(thisRef, prop.name) // create delegate return ResourceDelegate() } private fun checkProperty(thisRef: MyUI, name: String) { ... } } class MyUI { fun &lt;T&gt; bindResource(id: ResourceID&lt;T&gt;): ResourceLoader&lt;T&gt; { ... } val image by bindResource(ResourceID.image_id) val text by bindResource(ResourceID.text_id) } </pre>
<p id="3e473407">The parameters of <code class="code ">provideDelegate</code> are the same as those of <code class="code ">getValue</code>:</p>
<ul class="list _ul" id="315288eb">
<li class="list__item" id="4eb640a3"><p><code class="code ">thisRef</code> must be the same type as, or a supertype of, the <em id="dcc24afb" class="">property owner</em> (for extension properties, it should be the type being extended);</p></li>
<li class="list__item" id="feae4898"><p><code class="code ">property</code> must be of type <code class="code ">KProperty&lt;*&gt;</code> or its supertype.</p></li>
</ul>
<p id="a02dbb52">The <code class="code ">provideDelegate</code> method is called for each property during the creation of the <code class="code ">MyUI</code> instance, and it performs the necessary validation right away.</p>
<p id="aa308cf2">Without this ability to intercept the binding between the property and its delegate, to achieve the same functionality you'd have to pass the property name explicitly, which isn't very convenient:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">// Checking the property name without "provideDelegate" functionality class MyUI { val image by bindResource(ResourceID.image_id, "image") val text by bindResource(ResourceID.text_id, "text") } fun &lt;T&gt; MyUI.bindResource( id: ResourceID&lt;T&gt;, propertyName: String ): ReadOnlyProperty&lt;MyUI, T&gt; { checkProperty(this, propertyName) // create delegate } </pre>
<p id="7be22f02">In the generated code, the <code class="code ">provideDelegate</code> method is called to initialize the auxiliary <code class="code ">prop$delegate</code> property. Compare the generated code for the property declaration <code class="code ">val prop: Type by MyDelegate()</code> with the generated code <a href="#translation-rules-for-delegated-properties" id="316bf259">above</a> (when the <code class="code ">provideDelegate</code> method is not present):</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class C { var prop: Type by MyDelegate() } // this code is generated by the compiler // when the 'provideDelegate' function is available: class C { // calling "provideDelegate" to create the additional "delegate" property private val prop$delegate = MyDelegate().provideDelegate(this, this::prop) var prop: Type get() = prop$delegate.getValue(this, this::prop) set(value: Type) = prop$delegate.setValue(this, this::prop, value) } </pre>
<p id="3e0ec6cf">Note that the <code class="code ">provideDelegate</code> method affects only the creation of the auxiliary property and doesn't affect the code generated for the getter or the setter.</p>
<p id="7dd21d49">With the <code class="code ">PropertyDelegateProvider</code> interface from the standard library, you can create delegate providers without creating new classes.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val provider = PropertyDelegateProvider { thisRef: Any?, property -&gt; ReadOnlyProperty&lt;Any?, Int&gt; {_, property -&gt; 42 } } val delegate: Int by provider </pre></section></section><div class="last-modified"> Last modified: 16 November 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="delegation">Delegation</a> <a class="navigation-links__next" href="type-aliases">Type aliases</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/delegated-properties.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/delegated-properties.html</a>
  </p>
</div>
