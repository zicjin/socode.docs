<h1 data-toc="migrating-multiplatform-project-to-14" id="migrating-multiplatform-project-to-14.md">Migrating multiplatform projects to Kotlin 1.4.0</h1>
<p id="6f76e383">Kotlin 1.4.0 comes with lots of features and improvements in the tooling for multiplatform programming. Some of them just work out of the box on existing projects, and some require additional configuration steps. This guide will help you migrate your multiplatform projects to 1.4.0 or higher and get the benefits of all its new features.</p>
<section class="chapter"><h2 id="for-multiplatform-project-authors" data-toc="migrating-multiplatform-project-to-14#for-multiplatform-project-authors">For multiplatform project authors</h2>
<section class="chapter"><h3 id="update-gradle" data-toc="migrating-multiplatform-project-to-14#update-gradle">Update Gradle</h3>
<p id="fb1c1bd1">Starting with 1.4.0, Kotlin multiplatform projects require Gradle 6.0 or later. Make sure that your projects use the proper version of Gradle and upgrade it if needed. See the <a href="https://docs.gradle.org/current/userguide/upgrading_version_5.html" id="d522d073" data-external="true" rel="noopener noreferrer">Gradle documentation</a> for non-Kotlin-specific migration instructions.</p></section><section class="chapter"><h3 id="simplify-your-build-configuration" data-toc="migrating-multiplatform-project-to-14#simplify-your-build-configuration">Simplify your build configuration</h3>
<p id="5243c612">Gradle module metadata provides rich publishing and dependency resolution features that are used in Kotlin Multiplatform Projects. In Gradle 6.0 and above, module metadata is used in dependency resolution and included in publications by default. Thus, once you update to such a version, you can remove <code class="code ">enableFeaturePreview("GRADLE_METADATA")</code> from the project’s <code class="code ">settings.gradle</code> file.</p>
<p id="1dc6ed31">If you use libraries published with metadata, you only have to specify dependencies on them only once in the shared source set, as opposed to specifying dependencies on different variants of the same library in the shared and platform-specific source sets prior to 1.4.0.</p>
<p id="dda3f2cf">Starting from 1.4.0, you also no longer need to declare a dependency on <code class="code ">stdlib</code> in each source set manually – it <a href="mpp-add-dependencies#dependency-on-the-standard-library" id="37c22ca4">will now be added by default</a>. The version of the automatically added standard library will be the same as the version of the Kotlin Gradle plugin, since they have the same versioning.</p>
<p id="e5cc36fd">With these features, you can make your Gradle build file much more concise and easy to read:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">//... android() ios() js() sourceSets { commonMain { dependencies { implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:$coroutinesVersion") } } } //... </pre>
<p id="2eb63b6a">Don’t use kotlinx library artifact names with suffixes <code class="code ">-common</code> or <code class="code ">-native</code>, as they are no longer supported. Instead, use the library root artifact name, which in the example above is <code class="code ">kotlinx-coroutines-core</code>.</p></section><section class="chapter"><h3 id="try-the-hierarchical-project-structure" data-toc="migrating-multiplatform-project-to-14#try-the-hierarchical-project-structure">Try the hierarchical project structure</h3>
<p id="6480da4">With <a href="mpp-share-on-platforms#share-code-on-similar-platforms" id="74371bdb">the new hierarchical project structure support</a>, you can share code among several targets in a multiplatform project. You can use platform-dependent libraries, such as <code class="code ">Foundation</code>, <code class="code ">UIKit</code>, and <code class="code ">posix</code> in source sets shared among several native targets. This can help you share more native code without being limited by platform-specific dependencies.</p>
<p id="b467478d">By enabling the hierarchical structure along with its ability to use platform-dependent libraries in shared source sets, you can eliminate the need to use certain workarounds to get IDE support for sharing source sets among several native targets, for example <code class="code ">iosArm64</code> and <code class="code ">iosX64</code>:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">kotlin { // workaround 1: select iOS target platform depending on the Xcode environment variables val iOSTarget: (String, KotlinNativeTarget.() -&gt; Unit) -&gt; KotlinNativeTarget = if (System.getenv("SDK_NAME")?.startsWith("iphoneos") == true) ::iosArm64 else ::iosX64 iOSTarget("ios") } </pre>
<pre class="code-block" data-lang="bash" data-language="bash"># workaround 2: make symbolic links to use one source set for two targets ln -s iosMain iosArm64Main &amp;&amp; ln -s iosMain iosX64Main </pre>
<p id="eb54135d">Instead of doing this, you can create a hierarchical structure with <a href="mpp-share-on-platforms#use-target-shortcuts" id="ceb23b85">target shortcuts</a> available for typical multi-target scenarios, or you can manually declare and connect the source sets. For example, you can create two iOS targets and a shared source set with the <code class="code ">ios()</code> shortcut:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">kotlin { ios() // iOS device and simulator targets; iosMain and iosTest source sets } </pre>
<p id="b35d68ba">To enable the hierarchical project structure along with the use of platform-dependent libraries in shared source sets, just add the following to your <code class="code ">gradle.properties</code>:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">kotlin.mpp.enableGranularSourceSetsMetadata=true kotlin.native.enableDependencyPropagation=false </pre>
<p id="5ab274c1">In future versions, the hierarchical project structure will become default for Kotlin multiplatform project, so we strongly encourage you to start using it now.</p></section></section><section class="chapter"><h2 id="for-library-authors" data-toc="migrating-multiplatform-project-to-14#for-library-authors">For library authors</h2>
<section class="chapter"><h3 id="migrate-from-gradle-bintray-plugin-to-maven-publish-plugin" data-toc="migrating-multiplatform-project-to-14#migrate-from-gradle-bintray-plugin-to-maven-publish-plugin">Migrate from Gradle Bintray plugin to Maven Publish plugin</h3>
<p id="52ae3ba7">If you're using <code class="code ">gradle-bintray-plugin</code> for library publication, migrate your projects to <code class="code ">maven-publish</code> plugin instead. <a href="https://github.com/Kotlin/kotlinx.serialization/commit/c5f1af6ad78a77fe5861588d9fb00b7d3a9bc3e5#diff-439aadfed1f3c340acdcc871c00258aeL5" id="f8f3fec2" data-external="true" rel="noopener noreferrer">See how we've done this for <code class="code ">kotlinx.serialization</code></a>. Learn more about <a href="mpp-publish-lib" id="6dd96884">publishing multiplatform libraries</a>.</p>
<p id="45251f6f">If for some reason you need to publish to Bintray and use the Gradle Bintray plugin, remember that this plugin doesn’t support publishing Gradle module metadata. Use <a href="https://github.com/bintray/gradle-bintray-plugin/issues/229#issuecomment-473123891" id="df4e6a71" data-external="true" rel="noopener noreferrer">this workaround</a> to fix this.</p></section><section class="chapter"><h3 id="follow-the-default-libraries-layout" data-toc="migrating-multiplatform-project-to-14#follow-the-default-libraries-layout">Follow the default libraries’ layout</h3>
<p id="67bdf2b1">The layout of kotlinx libraries has changed and now corresponds to the default layout, which we recommend using: The <em id="fa6014a9" class="">root</em> or <em id="58111e57" class="">umbrella</em> library module now has a name without a suffix (for example, <code class="code ">kotlinx-coroutines-core</code> instead of <code class="code ">kotlinx-coroutines-core-native</code>). Publishing libraries with <a href="https://docs.gradle.org/current/userguide/publishing_maven.html" id="81e6264a" data-external="true" rel="noopener noreferrer">maven-publish Gradle plugin</a> follows this layout by default. Learn more about <a href="mpp-publish-lib" id="d4b44638">publishing multiplatform libraries</a>.</p></section><section class="chapter"><h3 id="migrate-to-the-hierarchical-project-structure" data-toc="migrating-multiplatform-project-to-14#migrate-to-the-hierarchical-project-structure">Migrate to the hierarchical project structure</h3>
<p id="a8ed6785">A hierarchical project structure allows reusing code in similar targets, as well as publishing and consuming libraries with granular APIs targeting similar platforms. We recommend that you switch to the hierarchical project structure in your libraries when migrating to Kotlin 1.4.0 or higher:</p>
<ul class="list _ul" id="a2273d06">
<li class="list__item" id="cbc591fd">
<p id="17d692a2">By default, libraries published with the hierarchical project structure are compatible only with projects that have hierarchical project structure. To enable compatibility with non-hierarchical projects, add the following to the <code class="code ">gradle.properties</code> file in your library project:</p>
<pre class="code-block" data-lang="none" data-disable-link-processing="true" data-language="none">kotlin.mpp.enableCompatibilityMetadataVariant=true </pre>
</li>
<li class="list__item" id="e74655b7"><p id="5fda433a">Libraries published without the hierarchical project structure can’t be used in a shared native source set. For example, users with <code class="code ">ios()</code> shortcuts in their <code class="code ">build.gradle.(kts)</code> files won’t be able to use your library in their iOS-shared code.</p></li>
</ul>
<p id="60e1ce05">The compatibility between multiplatform projects and libraries is as follows:</p>
<div class="table-wrapper"><table class=" wide" id="8bb241aa">
<thead><tr class="ijRowHead" id="506ede62">
<th id="9f40d269"><p>Library with hierarchical project structure</p></th>
<th id="c0f9b96"><p>Project with hierarchical project structure</p></th>
<th id="2b0472d9"><p>Compatibility</p></th>
</tr></thead>
<tbody>
<tr class="" id="840d7769">
<td id="dd899563"><p>Yes</p></td>
<td id="41bcdcfc"><p>Yes</p></td>
<td id="6d83675c"><p>✅</p></td>
</tr>
<tr class="" id="4e418186">
<td id="bfc875ca"><p>Yes</p></td>
<td id="4e56c0b3"><p>No</p></td>
<td id="904e1f2b"><p>Need to enable with <code class="code ">enableCompatibilityMetadataVariant</code></p></td>
</tr>
<tr class="" id="e987a7a8">
<td id="a15db361"><p>No</p></td>
<td id="f9dbd497"><p>Yes</p></td>
<td id="5d7d9e20"><p>Library can’t be used in a shared native source set</p></td>
</tr>
<tr class="" id="9f80b54e">
<td id="2406ae5f"><p>No</p></td>
<td id="e2e5027b"><p>Yes</p></td>
<td id="7f1379ec"><p>✅</p></td>
</tr>
</tbody>
</table></div>
<p id="cee12ad">In future versions, the hierarchical project structure with the usage of platform-dependent libraries in shared source sets will be the default in multiplatform projects. So the sooner you support it, the sooner users will be able to migrate. We’ll also be very grateful if you report any bugs you find to our issue tracker.</p>
<p id="b0c46a78">To enable hierarchical project structure support, add the following to your <code class="code ">gradle.properties</code> file:</p>
<pre class="code-block" data-lang="none" data-disable-link-processing="true" data-language="none">kotlin.mpp.enableGranularSourceSetsMetadata=true kotlin.mpp.enableCompatibilityMetadataVariant=true // to enable compatibility with projects without hierarchical structure </pre></section></section><section class="chapter"><h2 id="for-build-authors" data-toc="migrating-multiplatform-project-to-14#for-build-authors">For build authors</h2>
<section class="chapter"><h3 id="check-task-names" data-toc="migrating-multiplatform-project-to-14#check-task-names">Check task names</h3>
<p id="821211e8">The introduction of the hierarchical project structure in multiplatform projects resulted in a couple of changes to the names of some Gradle tasks:</p>
<ul class="list _ul" id="c2ea7aef">
<li class="list__item" id="888b99c8"><p>The <code class="code ">metadataJar</code> task has been renamed to <code class="code ">allMetadataJar</code>.</p></li>
<li class="list__item" id="283894c6"><p>There are new <code class="code ">compile&lt;SourceSet&gt;KotlinMetadata</code> tasks for all published intermediate source sets.</p></li>
</ul>
<p id="578b97b8">These changes are relevant only for projects with the hierarchical project structure.</p></section></section><section class="chapter"><h2 id="for-using-the-kotlin-js-target" data-toc="migrating-multiplatform-project-to-14#for-using-the-kotlin-js-target">For using the Kotlin/JS target</h2>
<section class="chapter"><h3 id="changes-related-to-npm-dependency-management" data-toc="migrating-multiplatform-project-to-14#changes-related-to-npm-dependency-management">Changes related to npm dependency management</h3>
<p id="fa2dd9a2">When declaring dependencies on npm packages, you are now required to explicitly specify a version or version range based on <a href="https://docs.npmjs.com/misc/semver#versions" id="563c863d" data-external="true" rel="noopener noreferrer">npm’s semver syntax</a>. Specifying multiple version ranges is also supported.</p>
<p id="a1234743">While we don’t recommend it, you can use a wildcard <code class="code ">*</code> in place of a version number if you do not want to specify a version or version range explicitly.</p></section><section class="chapter"><h3 id="changes-related-to-the-kotlin-js-ir-compiler" data-toc="migrating-multiplatform-project-to-14#changes-related-to-the-kotlin-js-ir-compiler">Changes related to the Kotlin/JS IR compiler</h3>
<p id="9fa0d810">Kotlin 1.4.0 introduces the Alpha IR compiler for Kotlin/JS. Learn more about the <a href="js-ir-compiler" id="575da298">Kotlin/JS IR compiler’s backend and how to configure it</a>.</p>
<p id="1014d918">To choose between the different Kotlin/JS compiler options, set the key <code class="code ">kotlin.js.compiler</code> in your <code class="code ">gradle.properties</code> to <code class="code ">legacy</code>, <code class="code ">ir</code>, or <code class="code ">both</code>. Alternatively, pass <code class="code ">LEGACY</code>, <code class="code ">IR</code>, or <code class="code ">BOTH</code> to the <code class="code ">js</code> function in your <code class="code ">build.gradle(.kts)</code>.</p>
<pre class="code-block" data-lang="groovy" data-language="groovy">kotlin { js(IR) { // or: LEGACY, BOTH // . . . } binaries.executable() } </pre>
<section class="chapter"><h4 id="changes-in-both-mode" data-toc="migrating-multiplatform-project-to-14#changes-in-both-mode">Changes in both mode</h4>
<p id="f1496696">Choosing <code class="code ">both</code> as the compiler option (so that it will compile with both the legacy and the IR backend) means that some Gradle tasks are renamed to explicitly mark them as only affecting the legacy compilation. <code class="code ">compileKotlinJs</code> is renamed to <code class="code ">compileKotlinJsLegacy</code>, and <code class="code ">compileTestKotlinJs</code> is renamed to <code class="code ">compileTestKotlinJsLegacy</code>.</p></section><section class="chapter"><h4 id="explicitly-toggling-the-creation-of-executable-files" data-toc="migrating-multiplatform-project-to-14#explicitly-toggling-the-creation-of-executable-files">Explicitly toggling the creation of executable files</h4>
<p id="63e424a2">When using the IR compiler, the <code class="code ">binaries.executable()</code> instruction must be present in the <code class="code ">js</code> target configuration block of your <code class="code ">build.gradle(.kts)</code>. If this option is omitted, only Kotlin-internal library files are generated. These files can be used from other projects, but not run on their own.</p>
<p id="a1762921">For backwards compatibility, when using the legacy compiler for Kotlin/JS, including or omitting <code class="code ">binaries.executable()</code> will have no effect – executable files will be generated in either case. To make the legacy backend stop producing executable files without the presence of <code class="code ">binaries.executable()</code> (for example, to improve build times where runnable artifacts aren't required), set <code class="code ">kotlin.js.generate.executable.default=false</code> in your <code class="code ">gradle.properties</code>.</p></section></section><section class="chapter"><h3 id="changes-related-to-dukat" data-toc="migrating-multiplatform-project-to-14#changes-related-to-dukat">Changes related to Dukat</h3>
<p id="9d412cdd">The Dukat integration for Gradle has received minor naming and functionality changes with Kotlin 1.4.0.</p>
<ul class="list _ul" id="2779a919">
<li class="list__item" id="5515a9ff"><p>The <code class="code ">kotlin.js.experimental.generateKotlinExternals</code> flag has been renamed to <code class="code ">kotlin.js.generate.externals</code>. It controls the default behavior of Dukat for all specified npm dependencies.</p></li>
<li class="list__item" id="c009712e"><p>The <code class="code ">npm</code> dependency function now takes a third parameter after the package name and version: <code class="code ">generateExternals</code>. This allows you to individually control whether Dukat should generate declarations for a specific dependency, and it overrides the <code class="code ">generateKotlinExternals</code> setting.</p></li>
</ul>
<p id="bd46ab94">Learn how to <a href="js-external-declarations-with-dukat" id="b0616a92">manually trigger the generation of Kotlin externals</a>.</p></section><section class="chapter"><h3 id="using-artifacts-built-with-kotlin-1-4-x-in-a-kotlin-1-3-x-project" data-toc="migrating-multiplatform-project-to-14#using-artifacts-built-with-kotlin-1-4-x-in-a-kotlin-1-3-x-project">Using artifacts built with Kotlin 1.4.x in a Kotlin 1.3.x project</h3>
<p id="d6364efb">The choice between the <code class="code ">IR</code> and <code class="code ">LEGACY</code> compilers was not yet available in Kotlin 1.3.xx. Because of this, you may encounter a Gradle error <code class="code ">Cannot choose between the following variants...</code> if one of your dependencies (or any transitive dependency) was built using Kotlin 1.4+ but your project uses Kotlin 1.3.xx. A workaround is provided <a href="https://youtrack.jetbrains.com/issue/KT-40226" id="694f39a2" data-external="true" rel="noopener noreferrer">here</a>.</p></section></section><div class="last-modified"> Last modified: 05 May 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="mpp-dsl-reference">Multiplatform Gradle DSL reference</a> <a class="navigation-links__next" href="mpp-tutorials">Tutorials for Kotlin Multiplatform</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/migrating-multiplatform-project-to-14.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/migrating-multiplatform-project-to-14.html</a>
  </p>
</div>
