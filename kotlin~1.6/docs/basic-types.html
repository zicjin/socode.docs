<h1 data-toc="basic-types" id="basic-types.md">Basic types</h1>
<p id="3ec3f276">In Kotlin, everything is an object in the sense that we can call member functions and properties on any variable. Some types can have a special internal representation - for example, numbers, characters and booleans can be represented as primitive values at runtime - but to the user they look like ordinary classes. In this section we describe the basic types used in Kotlin: <a href="#numbers" id="43df522a">numbers</a>, <a href="#booleans" id="4c6a8f0b">booleans</a>, <a href="#characters" id="2e669a95">characters</a>, <a href="#strings" id="339596c">strings</a>, and <a href="#arrays" id="c1d4c6cc">arrays</a>.</p>
<section class="chapter"><h2 id="numbers" data-toc="basic-types#numbers">Numbers</h2>
<section class="chapter"><h3 id="integer-types" data-toc="basic-types#integer-types">Integer types</h3>
<p id="9fc2a246">Kotlin provides a set of built-in types that represent numbers. <br> For integer numbers, there are four types with different sizes and, hence, value ranges.</p>
<div class="table-wrapper"><table class=" wide" id="7ae75a4e">
<thead><tr class="ijRowHead" id="ef549894">
<th id="21987d63"><p>Type</p></th>
<th id="6541f647"><p>Size (bits)</p></th>
<th id="6c7ec59a"><p>Min value</p></th>
<th id="5c53b8d4"><p>Max value</p></th>
</tr></thead>
<tbody>
<tr class="" id="87c8935">
<td id="2207b934"><p><code class="code ">Byte</code></p></td>
<td id="b4949151"><p>8</p></td>
<td id="1e255d66"><p>-128</p></td>
<td id="7f72fcea"><p>127</p></td>
</tr>
<tr class="" id="2b16c1dd">
<td id="69b665e"><p><code class="code ">Short</code></p></td>
<td id="cec09006"><p>16</p></td>
<td id="a9747abe"><p>-32768</p></td>
<td id="d6d89f0b"><p>32767</p></td>
</tr>
<tr class="" id="7a115804">
<td id="5bfadadb"><p><code class="code ">Int</code></p></td>
<td id="5969cca9"><p>32</p></td>
<td id="b0969356"><p>-2,147,483,648 (-2<sup class="superscript" id="49f11c98">31</sup>)</p></td>
<td id="cacea721"><p>2,147,483,647 (2<sup class="superscript" id="9065268c">31</sup> - 1)</p></td>
</tr>
<tr class="" id="280b567a">
<td id="2b82d6aa"><p><code class="code ">Long</code></p></td>
<td id="b37a7e12"><p>64</p></td>
<td id="4b9d07a2"><p>-9,223,372,036,854,775,808 (-2<sup class="superscript" id="1fac0a5f">63</sup>)</p></td>
<td id="67ca0125"><p>9,223,372,036,854,775,807 (2<sup class="superscript" id="98e0eee4">63</sup> - 1)</p></td>
</tr>
</tbody>
</table></div>
<p id="709f30f9">All variables initialized with integer values not exceeding the maximum value of <code class="code ">Int</code> have the inferred type <code class="code ">Int</code>. If the initial value exceeds this value, then the type is <code class="code ">Long</code>. To specify the <code class="code ">Long</code> value explicitly, append the suffix <code class="code ">L</code> to the value.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val one = 1 // Int val threeBillion = 3000000000 // Long val oneLong = 1L // Long val oneByte: Byte = 1 </pre></section><section class="chapter"><h3 id="floating-point-types" data-toc="basic-types#floating-point-types">Floating-point types</h3>
<p id="5c7da5e6">For real numbers, Kotlin provides floating-point types <code class="code ">Float</code> and <code class="code ">Double</code>. According to the <a href="https://en.wikipedia.org/wiki/IEEE_754" id="d8ecf006" data-external="true" rel="noopener noreferrer">IEEE 754 standard</a>, floating point types differ by their <em id="9d9c24c9" class="">decimal place</em>, that is, how many decimal digits they can store. <code class="code ">Float</code> reflects the IEEE 754 <em id="3d53c882" class="">single precision</em>, while <code class="code ">Double</code> provides <em id="e8fc74a8" class="">double precision</em>.</p>
<div class="table-wrapper"><table class=" wide" id="bdebd496">
<thead><tr class="ijRowHead" id="bbbd4a48">
<th id="b352a041"><p>Type</p></th>
<th id="f8914d65"><p>Size (bits)</p></th>
<th id="56ff6e4f"><p>Significant bits</p></th>
<th id="e932b278"><p>Exponent bits</p></th>
<th id="c522294d"><p>Decimal digits</p></th>
</tr></thead>
<tbody>
<tr class="" id="4a00a407">
<td id="2f9bc75a"><p><code class="code ">Float</code></p></td>
<td id="78d2198d"><p>32</p></td>
<td id="f982f0bc"><p>24</p></td>
<td id="ac95f954"><p>8</p></td>
<td id="3485a1d1"><p>6-7</p></td>
</tr>
<tr class="" id="c61d914f">
<td id="a625120"><p><code class="code ">Double</code></p></td>
<td id="bf477fc2"><p>64</p></td>
<td id="e85b076b"><p>53</p></td>
<td id="e4d30abf"><p>11</p></td>
<td id="593eebb0"><p>15-16</p></td>
</tr>
</tbody>
</table></div>
<p id="44057b5">You can initialize <code class="code ">Double</code> and <code class="code ">Float</code> variables with numbers having a fractional part. It's separated from the integer part by a period (<code class="code ">.</code>) For variables initialized with fractional numbers, the compiler infers the <code class="code ">Double</code> type.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val pi = 3.14 // Double // val one: Double = 1 // Error: type mismatch val oneDouble = 1.0 // Double </pre>
<p id="93577864">To explicitly specify the <code class="code ">Float</code> type for a value, add the suffix <code class="code ">f</code> or <code class="code ">F</code>. If such a value contains more than 6-7 decimal digits, it will be rounded.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val e = 2.7182818284 // Double val eFloat = 2.7182818284f // Float, actual value is 2.7182817 </pre>
<p id="f2a5b95f">Note that unlike some other languages, there are no implicit widening conversions for numbers in Kotlin. For example, a function with a <code class="code ">Double</code> parameter can be called only on <code class="code ">Double</code> values, but not <code class="code ">Float</code>, <code class="code ">Int</code>, or other numeric values.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun main() { fun printDouble(d: Double) { print(d) } val i = 1 val d = 1.0 val f = 1.0f printDouble(d) // printDouble(i) // Error: Type mismatch // printDouble(f) // Error: Type mismatch } </pre>
<p id="f40f1a78">To convert numeric values to different types, use <a href="#explicit-conversions" id="6c546c83">Explicit conversions</a>.</p></section><section class="chapter"><h3 id="literal-constants" data-toc="basic-types#literal-constants">Literal constants</h3>
<p id="a0cec27b">There are the following kinds of literal constants for integral values:</p>
<ul class="list _ul" id="6c6a8ace">
<li class="list__item" id="6a01d2f">
<p>Decimals: <code class="code ">123</code></p>
<ul class="list _ul" id="367be684"><li class="list__item" id="a29516b5"><p>Longs are tagged by a capital <code class="code ">L</code>: <code class="code ">123L</code></p></li></ul>
</li>
<li class="list__item" id="fc228f74"><p>Hexadecimals: <code class="code ">0x0F</code></p></li>
<li class="list__item" id="999e8d76"><p>Binaries: <code class="code ">0b00001011</code></p></li>
</ul>
<aside data-type="note" class="prompt" data-title="" id="a916f5f5"><p id="66a19e8e">Octal literals are not supported.</p></aside><p id="28918867">Kotlin also supports a conventional notation for floating-point numbers:</p>
<ul class="list _ul" id="36b90d71">
<li class="list__item" id="cb389790"><p>Doubles by default: <code class="code ">123.5</code>, <code class="code ">123.5e10</code></p></li>
<li class="list__item" id="77f175f5"><p>Floats are tagged by <code class="code ">f</code> or <code class="code ">F</code>: <code class="code ">123.5f</code></p></li>
</ul>
<p id="c295165b">You can use underscores to make number constants more readable:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val oneMillion = 1_000_000 val creditCardNumber = 1234_5678_9012_3456L val socialSecurityNumber = 999_99_9999L val hexBytes = 0xFF_EC_DE_5E val bytes = 0b11010010_01101001_10010100_10010010 </pre></section><section class="chapter"><h3 id="numbers-representation-on-the-jvm" data-toc="basic-types#numbers-representation-on-the-jvm">Numbers representation on the JVM</h3>
<p id="f1e9f24d">On the JVM platform, numbers are stored as primitive types: <code class="code ">int</code>, <code class="code ">double</code>, and so on. Exceptions are cases when you create a nullable number reference such as <code class="code ">Int?</code> or use generics. In these cases numbers are boxed in Java classes <code class="code ">Integer</code>, <code class="code ">Double</code>, and so on.</p>
<p id="2aeafa4a">Note that nullable references to the same number can be different objects:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val a: Int = 100 val boxedA: Int? = a val anotherBoxedA: Int? = a val b: Int = 10000 val boxedB: Int? = b val anotherBoxedB: Int? = b println(boxedA === anotherBoxedA) // true println(boxedB === anotherBoxedB) // false //sampleEnd } </pre>
<p id="ac41a11d">All nullable references to <code class="code ">a</code> are actually the same object because of the memory optimization that JVM applies to <code class="code ">Integer</code>s between <code class="code ">-128</code> and <code class="code ">127</code>. It doesn't apply to the <code class="code ">b</code> references, so they are different objects.</p>
<p id="b9565a7d">On the other hand, they are still equal:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val b: Int = 10000 println(b == b) // Prints 'true' val boxedB: Int? = b val anotherBoxedB: Int? = b println(boxedB == anotherBoxedB) // Prints 'true' //sampleEnd } </pre></section><section class="chapter"><h3 id="explicit-conversions" data-toc="basic-types#explicit-conversions">Explicit conversions</h3>
<p id="7d045128">Due to different representations, smaller types <em id="33505d79" class="">are not subtypes</em> of bigger ones. If they were, we would have troubles of the following sort:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">// Hypothetical code, does not actually compile: val a: Int? = 1 // A boxed Int (java.lang.Integer) val b: Long? = a // implicit conversion yields a boxed Long (java.lang.Long) print(b == a) // Surprise! This prints "false" as Long's equals() checks whether the other is Long as well </pre>
<p id="3e0cffca">So equality would have been lost silently, not to mention identity.</p>
<p id="8957aa84">As a consequence, smaller types <em id="20f4e056" class="">are NOT implicitly converted</em> to bigger types. This means that assigning a value of type <code class="code ">Byte</code> to an <code class="code ">Int</code> variable requires an explicit conversion.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val b: Byte = 1 // OK, literals are checked statically // val i: Int = b // ERROR val i1: Int = b.toInt() //sampleEnd } </pre>
<p id="9f3974a9">All number types support conversions to other types:</p>
<ul class="list _ul" id="cc603646">
<li class="list__item" id="af2f9f6"><p><code class="code ">toByte(): Byte</code></p></li>
<li class="list__item" id="5acd22d2"><p><code class="code ">toShort(): Short</code></p></li>
<li class="list__item" id="f29e7e35"><p><code class="code ">toInt(): Int</code></p></li>
<li class="list__item" id="e04319c8"><p><code class="code ">toLong(): Long</code></p></li>
<li class="list__item" id="21fa5ccf"><p><code class="code ">toFloat(): Float</code></p></li>
<li class="list__item" id="e3bef771"><p><code class="code ">toDouble(): Double</code></p></li>
<li class="list__item" id="d4dcce1e"><p><code class="code ">toChar(): Char</code></p></li>
</ul>
<p id="6cacc233">In many cases, there is no need for explicit conversions because the type is inferred from the context, and arithmetical operations are overloaded for appropriate conversions, for example:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val l = 1L + 3 // Long + Int =&gt; Long </pre></section><section class="chapter"><h3 id="operations" data-toc="basic-types#operations">Operations</h3>
<p id="555bf3fc">Kotlin supports the standard set of arithmetical operations over numbers: <code class="code ">+</code>, <code class="code ">-</code>, <code class="code ">*</code>, <code class="code ">/</code>, <code class="code ">%</code>. They are declared as members of appropriate classes.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart println(1 + 2) println(2_500_000_000L - 1L) println(3.14 * 2.71) println(10.0 / 3) //sampleEnd } </pre>
<p id="f34e1209">You can also override these operators for custom classes. See <a href="operator-overloading" id="f15b9d57">Operator overloading</a> for details.</p>
<section class="chapter"><h4 id="division-of-integers" data-toc="basic-types#division-of-integers">Division of integers</h4>
<p id="d04f809c">Division between integers numbers always returns an integer number. Any fractional part is discarded.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val x = 5 / 2 //println(x == 2.5) // ERROR: Operator '==' cannot be applied to 'Int' and 'Double' println(x == 2) //sampleEnd } </pre>
<p id="36d7e8b5">This is true for a division between any two integer types.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val x = 5L / 2 println(x == 2L) //sampleEnd } </pre>
<p id="c7ce9626">To return a floating-point type, explicitly convert one of the arguments to a floating-point type.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val x = 5 / 2.toDouble() println(x == 2.5) //sampleEnd } </pre></section><section class="chapter"><h4 id="bitwise-operations" data-toc="basic-types#bitwise-operations">Bitwise operations</h4>
<p id="87bdd61e">Kotlin provides a set of <em id="cb7cdb70" class="">bitwise operations</em> on integer numbers. They operate on the binary level directly with bits of the numbers' representation. Bitwise operations are represented by functions that can be called in infix form. They can be applied only to <code class="code ">Int</code> and <code class="code ">Long</code>.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val x = (1 shl 2) and 0x000FF000 </pre>
<p id="5af62192">Here is the complete list of bitwise operations:</p>
<ul class="list _ul" id="b58fb6d">
<li class="list__item" id="588afb11"><p><code class="code ">shl(bits)</code> – signed shift left</p></li>
<li class="list__item" id="8bc73807"><p><code class="code ">shr(bits)</code> – signed shift right</p></li>
<li class="list__item" id="7ad10c0d"><p><code class="code ">ushr(bits)</code> – unsigned shift right</p></li>
<li class="list__item" id="23c7bbf2"><p><code class="code ">and(bits)</code> – bitwise <b id="94124965" class="">and</b></p></li>
<li class="list__item" id="586129f3"><p><code class="code ">or(bits)</code> – bitwise <b id="a582ea5b" class="">or</b></p></li>
<li class="list__item" id="24fd6f4d"><p><code class="code ">xor(bits)</code> – bitwise <b id="a582344e" class="">xor</b></p></li>
<li class="list__item" id="cb42feb9"><p><code class="code ">inv()</code> – bitwise inversion</p></li>
</ul></section></section><section class="chapter"><h3 id="floating-point-numbers-comparison" data-toc="basic-types#floating-point-numbers-comparison">Floating-point numbers comparison</h3>
<p id="a2ded92">The operations on floating-point numbers discussed in this section are:</p>
<ul class="list _ul" id="862296c4">
<li class="list__item" id="12c549e1"><p>Equality checks: <code class="code ">a == b</code> and <code class="code ">a != b</code></p></li>
<li class="list__item" id="87c7565d"><p>Comparison operators: <code class="code ">a &lt; b</code>, <code class="code ">a &gt; b</code>, <code class="code ">a &lt;= b</code>, <code class="code ">a &gt;= b</code></p></li>
<li class="list__item" id="74749f7d"><p>Range instantiation and range checks: <code class="code ">a..b</code>, <code class="code ">x in a..b</code>, <code class="code ">x !in a..b</code></p></li>
</ul>
<p id="9bd4fb3b">When the operands <code class="code ">a</code> and <code class="code ">b</code> are statically known to be <code class="code ">Float</code> or <code class="code ">Double</code> or their nullable counterparts (the type is declared or inferred or is a result of a <a href="typecasts#smart-casts" id="f88ee14a">smart cast</a>), the operations on the numbers and the range that they form follow the <a href="https://en.wikipedia.org/wiki/IEEE_754" id="4c8d862b" data-external="true" rel="noopener noreferrer">IEEE 754 Standard for Floating-Point Arithmetic</a>.</p>
<p id="b908eea6">However, to support generic use cases and provide total ordering, when the operands are <b id="112f4b5d" class="">not</b> statically typed as floating point numbers (e.g. <code class="code ">Any</code>, <code class="code ">Comparable&lt;...&gt;</code>, a type parameter), the operations use the <code class="code ">equals</code> and <code class="code ">compareTo</code> implementations for <code class="code ">Float</code> and <code class="code ">Double</code>, which disagree with the standard, so that:</p>
<ul class="list _ul" id="89d5d40d">
<li class="list__item" id="a941fbe5"><p><code class="code ">NaN</code> is considered equal to itself</p></li>
<li class="list__item" id="523e089f"><p><code class="code ">NaN</code> is considered greater than any other element including <code class="code ">POSITIVE_INFINITY</code></p></li>
<li class="list__item" id="9bfc78dd"><p><code class="code ">-0.0</code> is considered less than <code class="code ">0.0</code></p></li>
</ul></section><section class="chapter"><h3 id="unsigned-integers" data-toc="basic-types#unsigned-integers">Unsigned integers</h3>
<p id="76292709">In addition to <a href="#integer-types" id="16418b90">integer types</a>, Kotlin provides the following types for unsigned integer numbers:</p>
<ul class="list _ul" id="754e3b82">
<li class="list__item" id="37dab5a7"><p><code class="code ">UByte</code>: an unsigned 8-bit integer, ranges from 0 to 255</p></li>
<li class="list__item" id="3a317bc3"><p><code class="code ">UShort</code>: an unsigned 16-bit integer, ranges from 0 to 65535</p></li>
<li class="list__item" id="6132f879"><p><code class="code ">UInt</code>: an unsigned 32-bit integer, ranges from 0 to 2^32 - 1</p></li>
<li class="list__item" id="17369c3c"><p><code class="code ">ULong</code>: an unsigned 64-bit integer, ranges from 0 to 2^64 - 1</p></li>
</ul>
<p id="b5fb3efa">Unsigned types support most of the operations of their signed counterparts.</p>
<aside data-type="note" class="prompt" data-title="" id="d4398612"><p id="d16f5d8f">Changing type from unsigned type to signed counterpart (and vice versa) is a <em id="d0fd3fea" class="">binary incompatible</em> change.</p></aside><section class="chapter"><h4 id="unsigned-arrays-and-ranges" data-toc="basic-types#unsigned-arrays-and-ranges">Unsigned arrays and ranges</h4>
<aside data-type="warning" class="prompt" data-title="" id="8564f6e2"><p id="fce91cff">Unsigned arrays and operations on them are in <a href="components-stability" id="c0655b0">Beta</a>. They can be changed incompatibly at any time. Opt-in is required (see the details below).</p></aside><p id="87bff6a0">As with primitives, each unsigned type has a corresponding type that represents arrays of that type:</p>
<ul class="list _ul" id="198aaf49">
<li class="list__item" id="a6957de9"><p><code class="code ">UByteArray</code>: an array of unsigned bytes</p></li>
<li class="list__item" id="451948a8"><p><code class="code ">UShortArray</code>: an array of unsigned shorts</p></li>
<li class="list__item" id="e51c5cb3"><p><code class="code ">UIntArray</code>: an array of unsigned ints</p></li>
<li class="list__item" id="55645af9"><p><code class="code ">ULongArray</code>: an array of unsigned longs</p></li>
</ul>
<p id="fef30e0c">Like signed integer arrays, they provide an API similar to the <code class="code ">Array</code> class without boxing overhead.</p>
<p id="324d2c00">When you use unsigned arrays, you'll get a warning that indicates that this feature is not stable yet. To remove the warning, opt in using the <code class="code ">@ExperimentalUnsignedTypes</code> annotation. It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but keep in mind that unsigned array are not a stable feature, so an API which uses them can be broken by changes in the language. <a href="opt-in-requirements" id="41cea1ce">Learn more about opt-in requirements</a>.</p>
<p id="46721f0a"><a href="ranges" id="824b4e9f">Ranges and progressions</a> are supported for <code class="code ">UInt</code> and <code class="code ">ULong</code> by classes <code class="code ">UIntRange</code>, <code class="code ">UIntProgression</code>, <code class="code ">ULongRange</code>, and <code class="code ">ULongProgression</code>. Together with the unsigned integer types, these classes are stable.</p></section><section class="chapter"><h4 id="literals" data-toc="basic-types#literals">Literals</h4>
<p id="c38e0fef">To make unsigned integers easier to use, Kotlin provides an ability to tag an integer literal with a suffix indicating a specific unsigned type (similarly to <code class="code ">Float</code> or <code class="code ">Long</code>):</p>
<ul class="list _ul" id="fa860b07"><li class="list__item" id="5da4bb45"><p><code class="code ">u</code> and <code class="code ">U</code> tag unsigned literals. The exact type is determined based on the expected type. If no expected type is provided, compiler will use <code class="code ">UInt</code> or <code class="code ">ULong</code> depending on the size of literal.</p></li></ul>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val b: UByte = 1u // UByte, expected type provided val s: UShort = 1u // UShort, expected type provided val l: ULong = 1u // ULong, expected type provided val a1 = 42u // UInt: no expected type provided, constant fits in UInt val a2 = 0xFFFF_FFFF_FFFFu // ULong: no expected type provided, constant doesn't fit in UInt </pre>
<ul class="list _ul" id="5020ffb3"><li class="list__item" id="fd6c981e"><p><code class="code ">uL</code> and <code class="code ">UL</code> explicitly tag literal as unsigned long.</p></li></ul>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val a = 1UL // ULong, even though no expected type provided and constant fits into UInt </pre></section><section class="chapter"><h4 id="further-discussion" data-toc="basic-types#further-discussion">Further discussion</h4>
<p id="736bf5ac">See <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/unsigned-types.md" id="609b55bd" data-external="true" rel="noopener noreferrer">language proposal for unsigned types</a> for technical details and further discussion.</p></section></section></section><section class="chapter"><h2 id="booleans" data-toc="basic-types#booleans">Booleans</h2>
<p id="7d93741c">The type <code class="code ">Boolean</code> represents boolean objects that can have two values: <code class="code ">true</code> and <code class="code ">false</code>.</p>
<p id="1ae3fac"><code class="code ">Boolean</code> has a nullable counterpart <code class="code ">Boolean?</code> that also has the <code class="code ">null</code> value.</p>
<p id="c042000">Built-in operations on booleans include:</p>
<ul class="list _ul" id="5348c3be">
<li class="list__item" id="8a09997f"><p><code class="code ">||</code> – disjunction (logical <em id="ad6fdc63" class="">OR</em>)</p></li>
<li class="list__item" id="b58b8546"><p><code class="code ">&amp;&amp;</code> – conjunction (logical <em id="c325d231" class="">AND</em>)</p></li>
<li class="list__item" id="150b4375"><p><code class="code ">!</code> - negation (logical <em id="717981fb" class="">NOT</em>)</p></li>
</ul>
<p id="87bc58bb"><code class="code ">||</code> and <code class="code ">&amp;&amp;</code> work lazily.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val myTrue: Boolean = true val myFalse: Boolean = false val boolNull: Boolean? = null println(myTrue || myFalse) println(myTrue &amp;&amp; myFalse) println(!myTrue) //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="87cf9f54"><p id="3af848fd"><b id="422f2e42" class="">On JVM</b>: nullable references to boolean objects are boxed similarly to <a href="#numbers-representation-on-the-jvm" id="1d5688d3">numbers</a>.</p></aside></section><section class="chapter"><h2 id="characters" data-toc="basic-types#characters">Characters</h2>
<p id="98a208db">Characters are represented by the type <code class="code ">Char</code>. Character literals go in single quotes: <code class="code ">'1'</code>.</p>
<p id="be099acf">Special characters start from an escaping backslash <code class="code ">\</code>. The following escape sequences are supported: <code class="code ">\t</code>, <code class="code ">\b</code>, <code class="code ">\n</code>, <code class="code ">\r</code>, <code class="code ">\'</code>, <code class="code ">\"</code>, <code class="code ">\\</code> and <code class="code ">\$</code>.</p>
<p id="befa7be5">To encode any other character, use the Unicode escape sequence syntax: <code class="code ">'\uFF00'</code>.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val aChar: Char = 'a' println(aChar) println('\n') //prints an extra newline character println('\uFF00') //sampleEnd } </pre>
<p id="e3175a21">If a value of character variable is a digit, you can explicitly convert it to an <code class="code ">Int</code> number using the <a href="../api/latest/jvm/stdlib/kotlin.text/digit-to-int" id="c1f3d255" data-external="true" rel="noopener noreferrer"><code class="code ">digitToInt()</code></a> function.</p>
<aside data-type="note" class="prompt" data-title="" id="c6346d0e"><p id="212a9103"><b id="fec88468" class="">On JVM</b>: Like <a href="#numbers-representation-on-the-jvm" id="986ebdb7">numbers</a>, characters are boxed when a nullable reference is needed. Identity is not preserved by the boxing operation.</p></aside></section><section class="chapter"><h2 id="strings" data-toc="basic-types#strings">Strings</h2>
<p id="657fa7dd">Strings in Kotlin are represented by the type <code class="code ">String</code>. Generally, a string value is a sequence of characters in double quotes (<code class="code ">"</code>).</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val str = "abcd 123" </pre>
<p id="6f565a5f">Elements of a string are characters that you can access via the indexing operation: <code class="code ">s[i]</code>. You can iterate over these characters with a <code class="code ">for</code> loop:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { val str = "abcd" //sampleStart for (c in str) { println(c) } //sampleEnd } </pre>
<p id="266980fc">Strings are immutable. Once you initialize a string, you can't change its value or assign a new value to it. All operations that transform strings return their results in a new <code class="code ">String</code> object, leaving the original string unchanged.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val str = "abcd" println(str.uppercase()) // Create and print a new String object println(str) // the original string remains the same //sampleEnd } </pre>
<p id="78b0dd2c">To concatenate strings, use the <code class="code ">+</code> operator. This also works for concatenating strings with values of other types, as long as the first element in the expression is a string:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val s = "abc" + 1 println(s + "def") //sampleEnd } </pre>
<p id="84b735b4">Note that in most cases using <a href="#string-templates" id="655b0ec3">string templates</a> or raw strings is preferable to string concatenation.</p>
<section class="chapter"><h3 id="string-literals" data-toc="basic-types#string-literals">String literals</h3>
<p id="ea75e61a">Kotlin has two types of string literals:</p>
<ul class="list _ul" id="50529c73">
<li class="list__item" id="ef771517"><p><em id="a47d9ff5" class="">escaped</em> strings that may contain escaped characters</p></li>
<li class="list__item" id="709b2b08"><p><em id="f5c1face" class="">raw</em> strings that can contain newlines and arbitrary text</p></li>
</ul>
<p id="a1dba8a1">Here's an example of an escaped string:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val s = "Hello, world!\n" </pre>
<p id="213d835e">Escaping is done in the conventional way, with a backslash (<code class="code ">\</code>). See <a href="#characters" id="9c3bf87e">Characters</a> above for the list of supported escape sequences.</p>
<p id="d6f444d0">A raw string is delimited by a triple quote (<code class="code ">"""</code>), contains no escaping and can contain newlines and any other characters:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val text = """ for (c in "foo") print(c) """ </pre>
<p id="1a425446">To remove leading whitespace from raw strings, use the <a href="../api/latest/jvm/stdlib/kotlin.text/trim-margin" id="bcc62727" data-external="true" rel="noopener noreferrer"><code class="code ">trimMargin()</code></a> function:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val text = """ |Tell me and I forget. |Teach me and I remember. |Involve me and I learn. |(Benjamin Franklin) """.trimMargin() </pre>
<p id="236bccba">By default, <code class="code ">|</code> is used as margin prefix, but you can choose another character and pass it as a parameter, like <code class="code ">trimMargin("&gt;")</code>.</p></section><section class="chapter"><h3 id="string-templates" data-toc="basic-types#string-templates">String templates</h3>
<p id="208cebdc">String literals may contain <em id="9db99518" class="">template</em> expressions - pieces of code that are evaluated and whose results are concatenated into the string. A template expression starts with a dollar sign (<code class="code ">$</code>) and consists of either a name:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val i = 10 println("i = $i") // prints "i = 10" //sampleEnd } </pre>
<p id="6df069c7">or an expression in curly braces:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val s = "abc" println("$s.length is ${s.length}") // prints "abc.length is 3" //sampleEnd } </pre>
<p id="7bb02f00">You can use templates both in raw and escaped strings. To insert the <code class="code ">$</code> character in a raw string (which doesn't support backslash escaping) before any symbol, which is allowed as a beginning of an <a href="grammar#identifiers" id="aaad5593" data-external="true" rel="noopener noreferrer">identifier</a>, use the following syntax:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val price = """ ${'$'}_9.99 """ </pre></section></section><section class="chapter"><h2 id="arrays" data-toc="basic-types#arrays">Arrays</h2>
<p id="8791c699">Arrays in Kotlin are represented by the <code class="code ">Array</code> class. It has <code class="code ">get</code> and <code class="code ">set</code> functions that turn into <code class="code ">[]</code> by operator overloading conventions, and the <code class="code ">size</code> property, along with other useful member functions:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class Array&lt;T&gt; private constructor() { val size: Int operator fun get(index: Int): T operator fun set(index: Int, value: T): Unit operator fun iterator(): Iterator&lt;T&gt; // ... } </pre>
<p id="91d8632d">To create an array, use the function <code class="code ">arrayOf()</code> and pass the item values to it, so that <code class="code ">arrayOf(1, 2, 3)</code> creates an array <code class="code ">[1, 2, 3]</code>. Alternatively, the <code class="code ">arrayOfNulls()</code> function can be used to create an array of a given size filled with <code class="code ">null</code> elements.</p>
<p id="447ea104">Another option is to use the <code class="code ">Array</code> constructor that takes the array size and the function that returns values of array elements given its index:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart // Creates an Array&lt;String&gt; with values ["0", "1", "4", "9", "16"] val asc = Array(5) { i -&gt; (i * i).toString() } asc.forEach { println(it) } //sampleEnd } </pre>
<p id="eb02bb2c">As we said above, the <code class="code ">[]</code> operation stands for calls to member functions <code class="code ">get()</code> and <code class="code ">set()</code>.</p>
<p id="bf2e68f6">Arrays in Kotlin are <em id="ca4614d7" class="">invariant</em>. This means that Kotlin does not let us assign an <code class="code ">Array&lt;String&gt;</code> to an <code class="code ">Array&lt;Any&gt;</code>, which prevents a possible runtime failure (but you can use <code class="code ">Array&lt;out Any&gt;</code>, see <a href="generics#type-projections" id="8109bae7">Type Projections</a>).</p>
<section class="chapter"><h3 id="primitive-type-arrays" data-toc="basic-types#primitive-type-arrays">Primitive type arrays</h3>
<p id="72d7b117">Kotlin also has classes that represent arrays of primitive types without boxing overhead: <code class="code ">ByteArray</code>, <code class="code ">ShortArray</code>, <code class="code ">IntArray</code>, and so on. These classes have no inheritance relation to the <code class="code ">Array</code> class, but they have the same set of methods and properties. Each of them also has a corresponding factory function:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val x: IntArray = intArrayOf(1, 2, 3) x[0] = x[1] + x[2] </pre>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">// Array of int of size 5 with values [0, 0, 0, 0, 0] val arr = IntArray(5) // e.g. initialise the values in the array with a constant // Array of int of size 5 with values [42, 42, 42, 42, 42] val arr = IntArray(5) { 42 } // e.g. initialise the values in the array using a lambda // Array of int of size 5 with values [0, 1, 2, 3, 4] (values initialised to their index value) var arr = IntArray(5) { it * 1 } </pre></section></section><div class="last-modified"> Last modified: 25 October 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="coding-conventions">Coding conventions</a> <a class="navigation-links__next" href="typecasts">Type checks and casts</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/basic-types.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/basic-types.html</a>
  </p>
</div>
