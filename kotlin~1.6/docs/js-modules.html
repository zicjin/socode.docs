<h1 data-toc="js-modules" id="js-modules.md">JavaScript modules</h1>
<p id="f61f89df">You can compile your Kotlin projects to JavaScript modules for various popular module systems. We currently support the following configurations for JavaScript modules:</p>
<ul class="list _ul" id="e15376cd">
<li class="list__item" id="caef6a16"><p><a href="https://github.com/umdjs/umd" id="ef4f4b82" data-external="true" rel="noopener noreferrer">Unified Module Definitions (UMD)</a>, which is compatible with both <em id="9e02a031" class="">AMD</em> and <em id="e103d1f6" class="">CommonJS</em>. UMD modules are also able to be executed without being imported or when no module system is present. This is the default option for the <code class="code ">browser</code> and <code class="code ">nodejs</code> targets.</p></li>
<li class="list__item" id="a41adfc6"><p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" id="d1a837d1" data-external="true" rel="noopener noreferrer">Asynchronous Module Definitions (AMD)</a>, which is in particular used by the <a href="https://requirejs.org/" id="ed1d0b58" data-external="true" rel="noopener noreferrer">RequireJS</a> library.</p></li>
<li class="list__item" id="d6b56049"><p><a href="http://wiki.commonjs.org/wiki/Modules/1.1" id="47f5019e" data-external="true" rel="noopener noreferrer">CommonJS</a>, widely used by Node.js/npm (<code class="code ">require</code> function and <code class="code ">module.exports</code> object)</p></li>
<li class="list__item" id="60ae2f8"><p>Plain. Don't compile for any module system. You can access a module by its name in the global scope.</p></li>
</ul>
<section class="chapter"><h2 id="browser-targets" data-toc="js-modules#browser-targets">Browser targets</h2>
<p id="61691164">If you're targeting the browser and want to use a different module system than UMD, you can specify the desired module type in the <code class="code ">webpackTask</code> configuration block. For example, to switch to CommonJS, use:</p>
<pre class="code-block" data-lang="groovy" data-language="groovy">kotlin { js { browser { webpackTask { output.libraryTarget = "commonjs2" } } binaries.executable() } } </pre>
<p id="9e3def0d">Webpack provides two different "flavors" of CommonJS, <code class="code ">commonjs</code> and <code class="code ">commonjs2</code>, which affect the way your declarations are made available. While in most cases, you probably want <code class="code ">commonjs2</code>, which adds the <code class="code ">module.exports</code> syntax to the generated library, you can also opt for the "pure" <code class="code ">commonjs</code> option, which implements the CommonJS specification exactly. To learn more about the difference between <code class="code ">commonjs</code> and <code class="code ">commonjs2</code>, check <a href="https://github.com/webpack/webpack/issues/1114" id="e1b73f81" data-external="true" rel="noopener noreferrer">here</a>.</p></section><section class="chapter"><h2 id="javascript-libraries-and-node-js-files" data-toc="js-modules#javascript-libraries-and-node-js-files">JavaScript libraries and Node.js files</h2>
<p id="204f17fb">If you are creating a library that will be consumed from JavaScript or a Node.js file, and want to use a different module system, the instructions are slightly different.</p>
<section class="chapter"><h3 id="choose-the-target-module-system" data-toc="js-modules#choose-the-target-module-system">Choose the target module system</h3>
<p id="34fce48d">To select module kind, set the <code class="code ">moduleKind</code> compiler option in the Gradle build script.</p>
<div class="tabs" id="9a0eb6bb" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="c2c81de5" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code-block" data-lang="kotlin" data-title="Kotlin" data-language="kotlin">tasks.named&lt;KotlinJsCompile&gt;("compileKotlinJs").configure { kotlinOptions.moduleKind = "commonjs" } </pre></div>
<div class="tabs__content" data-gtm="tab" id="da3df332" data-sync-tabs="groovy" data-title="Groovy"><pre class="code-block" data-lang="groovy" data-title="Groovy" data-language="groovy">compileKotlinJs.kotlinOptions.moduleKind = "commonjs" </pre></div>
</div>
<p id="5f2e7862">Available values are: <code class="code ">umd</code> (default), <code class="code ">commonjs</code>, <code class="code ">amd</code>, <code class="code ">plain</code>.</p>
<aside data-type="note" class="prompt" data-title="" id="ceff0c2a"><p id="a6b3b306">This is different from adjusting <code class="code ">webpackTask.output.libraryTarget</code>. The library target changes the output <em id="958b2acd" class="">generated by webpack</em> (after your code has already been compiled). <code class="code ">kotlinOptions.moduleKind</code> changes the output generated <em id="fbfd1f17" class="">by the Kotlin compiler</em>.</p></aside><p id="2a52305b">In the Kotlin Gradle DSL, there is also a shortcut for setting the CommonJS module kind:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">kotlin { js { useCommonJs() // . . . } } </pre></section></section><section class="chapter"><h2 id="jsmodule-annotation" data-toc="js-modules#jsmodule-annotation">@JsModule annotation</h2>
<p id="522d4f10">To tell Kotlin that an <code class="code ">external</code> class, package, function or property is a JavaScript module, you can use <code class="code ">@JsModule</code> annotation. Consider you have the following CommonJS module called "hello":</p>
<pre class="code-block" data-lang="javascript" data-language="javascript">module.exports.sayHello = function(name) { alert("Hello, " + name); } </pre>
<p id="1c50017e">You should declare it like this in Kotlin:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">@JsModule("hello") external fun sayHello(name: String) </pre>
<section class="chapter"><h3 id="apply-jsmodule-to-packages" data-toc="js-modules#apply-jsmodule-to-packages">Apply @JsModule to packages</h3>
<p id="6331d52d">Some JavaScript libraries export packages (namespaces) instead of functions and classes. In terms of JavaScript, it's an <em id="d8b868d3" class="">object</em> that has <em id="25a6f874" class="">members</em> that are classes, functions and properties. Importing these packages as Kotlin objects often looks unnatural. The compiler can map imported JavaScript packages to Kotlin packages, using the following notation:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">@file:JsModule("extModule") package ext.jspackage.name external fun foo() external class C </pre>
<p id="5f7b0503">where the corresponding JavaScript module is declared like this:</p>
<pre class="code-block" data-lang="javascript" data-language="javascript">module.exports = { foo: { /* some code here */ }, C: { /* some code here */ } } </pre>
<p id="8479cdf8">Files marked with <code class="code ">@file:JsModule</code> annotation can't declare non-external members. The example below produces a compile-time error:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">@file:JsModule("extModule") package ext.jspackage.name external fun foo() fun bar() = "!" + foo() + "!" // error here </pre></section><section class="chapter"><h3 id="import-deeper-package-hierarchies" data-toc="js-modules#import-deeper-package-hierarchies">Import deeper package hierarchies</h3>
<p id="8928991a">In the previous example the JavaScript module exports a single package. However, some JavaScript libraries export multiple packages from within a module. This case is also supported by Kotlin, though you have to declare a new <code class="code ">.kt</code> file for each package you import.</p>
<p id="3742a35a">For example, let's make the example a bit more complicated:</p>
<pre class="code-block" data-lang="javascript" data-language="javascript">module.exports = { mylib: { pkg1: { foo: function() { /* some code here */ }, bar: function() { /* some code here */ } }, pkg2: { baz: function() { /* some code here */ } } } } </pre>
<p id="c696f447">To import this module in Kotlin, you have to write two Kotlin source files:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">@file:JsModule("extModule") @file:JsQualifier("mylib.pkg1") package extlib.pkg1 external fun foo() external fun bar() </pre>
<p id="ab628ab5">and</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">@file:JsModule("extModule") @file:JsQualifier("mylib.pkg2") package extlib.pkg2 external fun baz() </pre></section><section class="chapter"><h3 id="jsnonmodule-annotation" data-toc="js-modules#jsnonmodule-annotation">@JsNonModule annotation</h3>
<p id="d7abf55a">When a declaration is marked as <code class="code ">@JsModule</code>, you can't use it from Kotlin code when you don't compile it to a JavaScript module. Usually, developers distribute their libraries both as JavaScript modules and downloadable <code class="code ">.js</code> files that you can copy to your project's static resources and include via a <code class="code ">&lt;script&gt;</code> tag. To tell Kotlin that it's okay to use a <code class="code ">@JsModule</code> declaration from a non-module environment, add the <code class="code ">@JsNonModule</code> annotation. For example, consider the following JavaScript code:</p>
<pre class="code-block" data-lang="javascript" data-language="javascript">function topLevelSayHello(name) { alert("Hello, " + name); } if (module &amp;&amp; module.exports) { module.exports = topLevelSayHello; } </pre>
<p id="f9caee73">You could describe it from Kotlin as follows:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">@JsModule("hello") @JsNonModule @JsName("topLevelSayHello") external fun sayHello(name: String) </pre></section><section class="chapter"><h3 id="module-system-used-by-the-kotlin-standard-library" data-toc="js-modules#module-system-used-by-the-kotlin-standard-library">Module system used by the Kotlin Standard Library</h3>
<p id="44996881">Kotlin is distributed with the Kotlin/JS standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. While for most use cases of Kotlin/JS, it is recommended to use a Gradle dependency on <code class="code ">kotlin-stdlib-js</code>, it is also available on NPM as the <a href="https://www.npmjs.com/package/kotlin" id="9923fe7f" data-external="true" rel="noopener noreferrer"><code class="code ">kotlin</code></a> package.</p></section></section><div class="last-modified"> Last modified: 08 September 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="js-to-kotlin-interop">Use Kotlin code from JavaScript</a> <a class="navigation-links__next" href="js-reflection">Kotlin/JS reflection</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/js-modules.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/js-modules.html</a>
  </p>
</div>
