<h1 data-toc="fun-interfaces" id="fun-interfaces.md">Functional (SAM) interfaces</h1>
<p id="6fe64d8f">An interface with only one abstract method is called a <em id="3ec02052" class="">functional interface</em>, or a <em id="a927bce4" class="">Single Abstract Method (SAM) interface</em>. The functional interface can have several non-abstract members but only one abstract member.</p>
<p id="813c37ee">To declare a functional interface in Kotlin, use the <code class="code ">fun</code> modifier.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun interface KRunnable { fun invoke() } </pre>
<section class="chapter"><h2 id="sam-conversions" data-toc="fun-interfaces#sam-conversions">SAM conversions</h2>
<p id="a2de5c04">For functional interfaces, you can use SAM conversions that help make your code more concise and readable by using <a href="lambdas#lambda-expressions-and-anonymous-functions" id="46a5abab">lambda expressions</a>.</p>
<p id="e362824b">Instead of creating a class that implements a functional interface manually, you can use a lambda expression. With a SAM conversion, Kotlin can convert any lambda expression whose signature matches the signature of the interface's single method into the code, which dynamically instantiates the interface implementation.</p>
<p id="b817828d">For example, consider the following Kotlin functional interface:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun interface IntPredicate { fun accept(i: Int): Boolean } </pre>
<p id="6b72b57b">If you don't use a SAM conversion, you will need to write code like this:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">// Creating an instance of a class val isEven = object : IntPredicate { override fun accept(i: Int): Boolean { return i % 2 == 0 } } </pre>
<p id="d458cc0f">By leveraging Kotlin's SAM conversion, you can write the following equivalent code instead:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">// Creating an instance using lambda val isEven = IntPredicate { it % 2 == 0 } </pre>
<p id="e590cdde">A short lambda expression replaces all the unnecessary code.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4" data-language="kotlin">fun interface IntPredicate { fun accept(i: Int): Boolean } val isEven = IntPredicate { it % 2 == 0 } fun main() { println("Is 7 even? - ${isEven.accept(7)}") } </pre>
<p id="d8a5f11">You can also use <a href="java-interop#sam-conversions" id="c7476a3a">SAM conversions for Java interfaces</a>.</p></section><section class="chapter"><h2 id="functional-interfaces-vs-type-aliases" data-toc="fun-interfaces#functional-interfaces-vs-type-aliases">Functional interfaces vs. type aliases</h2>
<p id="186bdc58">Functional interfaces and <a href="type-aliases" id="db5fc17c">type aliases</a> serve different purposes. Type aliases are just names for existing types – they don't create a new type, while functional interfaces do. You can provide extensions that are specific to a particular functional interface to be inapplicable for plain functions or their type aliases.</p>
<p id="6e8a88b1">Type aliases can have only one member, while functional interfaces can have multiple non-abstract members and one abstract member. Functional interfaces can also implement and extend other interfaces.</p>
<p id="261d0389">Functional interfaces are more flexible and provide more capabilities than type aliases, but they can be more costly both syntactically and at runtime because they can require conversions to a specific interface. When you choose which one to use in your code, consider your needs:</p>
<ul class="list _ul" id="8629179a">
<li class="list__item" id="b8bb23dd"><p>If your API needs to accept a function (any function) with some specific parameter and return types – use a simple functional type or define a type alias to give a shorter name to the corresponding functional type.</p></li>
<li class="list__item" id="60773c30"><p>If your API accepts a more complex entity than a function – for example, it has non-trivial contracts and/or operations on it that can't be expressed in a functional type's signature – declare a separate functional interface for it.</p></li>
</ul></section><div class="last-modified"> Last modified: 02 June 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="interfaces">Interfaces</a> <a class="navigation-links__next" href="visibility-modifiers">Visibility modifiers</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/fun-interfaces.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/fun-interfaces.html</a>
  </p>
</div>
