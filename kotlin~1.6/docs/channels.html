<h1 data-toc="channels" id="channels.md">Channels</h1>
<p id="3201aa4f">Deferred values provide a convenient way to transfer a single value between coroutines. Channels provide a way to transfer a stream of values.</p>
<section class="chapter"><h2 id="channel-basics" data-toc="channels#channel-basics">Channel basics</h2>
<p id="a887cfa8">A <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/index.html" id="3a9651c6" data-external="true" rel="noopener noreferrer">Channel</a> is conceptually very similar to <code class="code ">BlockingQueue</code>. One key difference is that instead of a blocking <code class="code ">put</code> operation it has a suspending <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/send.html" id="7b128ca3" data-external="true" rel="noopener noreferrer">send</a>, and instead of a blocking <code class="code ">take</code> operation it has a suspending <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html" id="4503068f" data-external="true" rel="noopener noreferrer">receive</a>.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.channels.* fun main() = runBlocking { //sampleStart val channel = Channel&lt;Int&gt;() launch { // this might be heavy CPU-consuming computation or async logic, we'll just send five squares for (x in 1..5) channel.send(x * x) } // here we print five received integers: repeat(5) { println(channel.receive()) } println("Done!") //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="5be0ab00"><p id="e3e548e5">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-channel-01.kt" id="d63f404d" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="ae8b7fe4">The output of this code is:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">1 4 9 16 25 Done! </pre></section><section class="chapter"><h2 id="closing-and-iteration-over-channels" data-toc="channels#closing-and-iteration-over-channels">Closing and iteration over channels</h2>
<p id="7ccf91e8">Unlike a queue, a channel can be closed to indicate that no more elements are coming. On the receiver side it is convenient to use a regular <code class="code ">for</code> loop to receive elements from the channel.</p>
<p id="21ea9467">Conceptually, a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/close.html" id="e06b2efd" data-external="true" rel="noopener noreferrer">close</a> is like sending a special close token to the channel. The iteration stops as soon as this close token is received, so there is a guarantee that all previously sent elements before the close are received:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.channels.* fun main() = runBlocking { //sampleStart val channel = Channel&lt;Int&gt;() launch { for (x in 1..5) channel.send(x * x) channel.close() // we're done sending } // here we print received values using `for` loop (until the channel is closed) for (y in channel) println(y) println("Done!") //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="cfd45f0d"><p id="50dfd4c4">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-channel-02.kt" id="d4513966" data-external="true" rel="noopener noreferrer">here</a>.</p></aside></section><section class="chapter"><h2 id="building-channel-producers" data-toc="channels#building-channel-producers">Building channel producers</h2>
<p id="f63b0a9">The pattern where a coroutine is producing a sequence of elements is quite common. This is a part of <em id="7ef3dff7" class="">producer-consumer</em> pattern that is often found in concurrent code. You could abstract such a producer into a function that takes channel as its parameter, but this goes contrary to common sense that results must be returned from functions.</p>
<p id="af1b8399">There is a convenient coroutine builder named <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html" id="fb709c17" data-external="true" rel="noopener noreferrer">produce</a> that makes it easy to do it right on producer side, and an extension function <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html" id="947bb7d0" data-external="true" rel="noopener noreferrer">consumeEach</a>, that replaces a <code class="code ">for</code> loop on the consumer side:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.channels.* fun CoroutineScope.produceSquares(): ReceiveChannel&lt;Int&gt; = produce { for (x in 1..5) send(x * x) } fun main() = runBlocking { //sampleStart val squares = produceSquares() squares.consumeEach { println(it) } println("Done!") //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="81742698"><p id="9da0951">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-channel-03.kt" id="55b2783d" data-external="true" rel="noopener noreferrer">here</a>.</p></aside></section><section class="chapter"><h2 id="pipelines" data-toc="channels#pipelines">Pipelines</h2>
<p id="a5858adb">A pipeline is a pattern where one coroutine is producing, possibly infinite, stream of values:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun CoroutineScope.produceNumbers() = produce&lt;Int&gt; { var x = 1 while (true) send(x++) // infinite stream of integers starting from 1 } </pre>
<p id="78d52cec">And another coroutine or coroutines are consuming that stream, doing some processing, and producing some other results. In the example below, the numbers are just squared:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun CoroutineScope.square(numbers: ReceiveChannel&lt;Int&gt;): ReceiveChannel&lt;Int&gt; = produce { for (x in numbers) send(x * x) } </pre>
<p id="edf7313f">The main code starts and connects the whole pipeline:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.channels.* fun main() = runBlocking { //sampleStart val numbers = produceNumbers() // produces integers from 1 and on val squares = square(numbers) // squares integers repeat(5) { println(squares.receive()) // print first five } println("Done!") // we are done coroutineContext.cancelChildren() // cancel children coroutines //sampleEnd } fun CoroutineScope.produceNumbers() = produce&lt;Int&gt; { var x = 1 while (true) send(x++) // infinite stream of integers starting from 1 } fun CoroutineScope.square(numbers: ReceiveChannel&lt;Int&gt;): ReceiveChannel&lt;Int&gt; = produce { for (x in numbers) send(x * x) } </pre>
<aside data-type="note" class="prompt" data-title="" id="3fd36233"><p id="70b03bb0">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-channel-04.kt" id="1eb325a1" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><aside data-type="note" class="prompt" data-title="" id="47831021"><p id="429dbe2a">All functions that create coroutines are defined as extensions on <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html" id="2139c049" data-external="true" rel="noopener noreferrer">CoroutineScope</a>, so that we can rely on <a href="composing-suspending-functions#structured-concurrency-with-async" id="9cbd0402">structured concurrency</a> to make sure that we don't have lingering global coroutines in our application.</p></aside></section><section class="chapter"><h2 id="prime-numbers-with-pipeline" data-toc="channels#prime-numbers-with-pipeline">Prime numbers with pipeline</h2>
<p id="28108d10">Let's take pipelines to the extreme with an example that generates prime numbers using a pipeline of coroutines. We start with an infinite sequence of numbers.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun CoroutineScope.numbersFrom(start: Int) = produce&lt;Int&gt; { var x = start while (true) send(x++) // infinite stream of integers from start } </pre>
<p id="ad066ea1">The following pipeline stage filters an incoming stream of numbers, removing all the numbers that are divisible by the given prime number:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun CoroutineScope.filter(numbers: ReceiveChannel&lt;Int&gt;, prime: Int) = produce&lt;Int&gt; { for (x in numbers) if (x % prime != 0) send(x) } </pre>
<p id="861a475">Now we build our pipeline by starting a stream of numbers from 2, taking a prime number from the current channel, and launching new pipeline stage for each prime number found:</p>
<pre class="code-block" data-lang="none" data-disable-link-processing="true" data-language="none">numbersFrom(2) -&gt; filter(2) -&gt; filter(3) -&gt; filter(5) -&gt; filter(7) ... </pre>
<p id="64d9f7bf">The following example prints the first ten prime numbers, running the whole pipeline in the context of the main thread. Since all the coroutines are launched in the scope of the main <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html" id="126ac4" data-external="true" rel="noopener noreferrer">runBlocking</a> coroutine we don't have to keep an explicit list of all the coroutines we have started. We use <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel-children.html" id="441adc99" data-external="true" rel="noopener noreferrer">cancelChildren</a> extension function to cancel all the children coroutines after we have printed the first ten prime numbers.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.channels.* fun main() = runBlocking { //sampleStart var cur = numbersFrom(2) repeat(10) { val prime = cur.receive() println(prime) cur = filter(cur, prime) } coroutineContext.cancelChildren() // cancel all children to let main finish //sampleEnd } fun CoroutineScope.numbersFrom(start: Int) = produce&lt;Int&gt; { var x = start while (true) send(x++) // infinite stream of integers from start } fun CoroutineScope.filter(numbers: ReceiveChannel&lt;Int&gt;, prime: Int) = produce&lt;Int&gt; { for (x in numbers) if (x % prime != 0) send(x) } </pre>
<aside data-type="note" class="prompt" data-title="" id="ced0323c"><p id="a6212803">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-channel-05.kt" id="7dd68bc6" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="e7b97e81">The output of this code is:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">2 3 5 7 11 13 17 19 23 29 </pre>
<p id="bfd75258">Note that you can build the same pipeline using <a href="../api/latest/jvm/stdlib/kotlin.sequences/iterator" id="6d4c3f40" data-external="true" rel="noopener noreferrer"><code class="code ">iterator</code></a> coroutine builder from the standard library. Replace <code class="code ">produce</code> with <code class="code ">iterator</code>, <code class="code ">send</code> with <code class="code ">yield</code>, <code class="code ">receive</code> with <code class="code ">next</code>, <code class="code ">ReceiveChannel</code> with <code class="code ">Iterator</code>, and get rid of the coroutine scope. You will not need <code class="code ">runBlocking</code> either. However, the benefit of a pipeline that uses channels as shown above is that it can actually use multiple CPU cores if you run it in <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html" id="cf0b3463" data-external="true" rel="noopener noreferrer">Dispatchers.Default</a> context.</p>
<p id="78ca84c9">Anyway, this is an extremely impractical way to find prime numbers. In practice, pipelines do involve some other suspending invocations (like asynchronous calls to remote services) and these pipelines cannot be built using <code class="code ">sequence</code>/<code class="code ">iterator</code>, because they do not allow arbitrary suspension, unlike <code class="code ">produce</code>, which is fully asynchronous.</p></section><section class="chapter"><h2 id="fan-out" data-toc="channels#fan-out">Fan-out</h2>
<p id="7de2d057">Multiple coroutines may receive from the same channel, distributing work between themselves. Let us start with a producer coroutine that is periodically producing integers (ten numbers per second):</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun CoroutineScope.produceNumbers() = produce&lt;Int&gt; { var x = 1 // start from 1 while (true) { send(x++) // produce next delay(100) // wait 0.1s } } </pre>
<p id="66a78109">Then we can have several processor coroutines. In this example, they just print their id and received number:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun CoroutineScope.launchProcessor(id: Int, channel: ReceiveChannel&lt;Int&gt;) = launch { for (msg in channel) { println("Processor #$id received $msg") } } </pre>
<p id="d40f6004">Now let us launch five processors and let them work for almost a second. See what happens:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.channels.* fun main() = runBlocking&lt;Unit&gt; { //sampleStart val producer = produceNumbers() repeat(5) { launchProcessor(it, producer) } delay(950) producer.cancel() // cancel producer coroutine and thus kill them all //sampleEnd } fun CoroutineScope.produceNumbers() = produce&lt;Int&gt; { var x = 1 // start from 1 while (true) { send(x++) // produce next delay(100) // wait 0.1s } } fun CoroutineScope.launchProcessor(id: Int, channel: ReceiveChannel&lt;Int&gt;) = launch { for (msg in channel) { println("Processor #$id received $msg") } } </pre>
<aside data-type="note" class="prompt" data-title="" id="1ab55663"><p id="b3d66de6">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-channel-06.kt" id="b2ece547" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="bb55a031">The output will be similar to the the following one, albeit the processor ids that receive each specific integer may be different:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">Processor #2 received 1 Processor #4 received 2 Processor #0 received 3 Processor #1 received 4 Processor #3 received 5 Processor #2 received 6 Processor #4 received 7 Processor #0 received 8 Processor #1 received 9 Processor #3 received 10 </pre>
<p id="ff12b328">Note that cancelling a producer coroutine closes its channel, thus eventually terminating iteration over the channel that processor coroutines are doing.</p>
<p id="b45884e">Also, pay attention to how we explicitly iterate over channel with <code class="code ">for</code> loop to perform fan-out in <code class="code ">launchProcessor</code> code. Unlike <code class="code ">consumeEach</code>, this <code class="code ">for</code> loop pattern is perfectly safe to use from multiple coroutines. If one of the processor coroutines fails, then others would still be processing the channel, while a processor that is written via <code class="code ">consumeEach</code> always consumes (cancels) the underlying channel on its normal or abnormal completion.</p></section><section class="chapter"><h2 id="fan-in" data-toc="channels#fan-in">Fan-in</h2>
<p id="5fd873dc">Multiple coroutines may send to the same channel. For example, let us have a channel of strings, and a suspending function that repeatedly sends a specified string to this channel with a specified delay:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">suspend fun sendString(channel: SendChannel&lt;String&gt;, s: String, time: Long) { while (true) { delay(time) channel.send(s) } } </pre>
<p id="939f46b7">Now, let us see what happens if we launch a couple of coroutines sending strings (in this example we launch them in the context of the main thread as main coroutine's children):</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.channels.* fun main() = runBlocking { //sampleStart val channel = Channel&lt;String&gt;() launch { sendString(channel, "foo", 200L) } launch { sendString(channel, "BAR!", 500L) } repeat(6) { // receive first six println(channel.receive()) } coroutineContext.cancelChildren() // cancel all children to let main finish //sampleEnd } suspend fun sendString(channel: SendChannel&lt;String&gt;, s: String, time: Long) { while (true) { delay(time) channel.send(s) } } </pre>
<aside data-type="note" class="prompt" data-title="" id="c1469296"><p id="e5c17548">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-channel-07.kt" id="a1701ca4" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="48fa61d7">The output is:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">foo foo BAR! foo foo BAR! </pre></section><section class="chapter"><h2 id="buffered-channels" data-toc="channels#buffered-channels">Buffered channels</h2>
<p id="3231bcea">The channels shown so far had no buffer. Unbuffered channels transfer elements when sender and receiver meet each other (aka rendezvous). If send is invoked first, then it is suspended until receive is invoked, if receive is invoked first, it is suspended until send is invoked.</p>
<p id="b90f32c1">Both <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel.html" id="f359bee" data-external="true" rel="noopener noreferrer">Channel()</a> factory function and <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html" id="a0e15ec" data-external="true" rel="noopener noreferrer">produce</a> builder take an optional <code class="code ">capacity</code> parameter to specify <em id="259b02c9" class="">buffer size</em>. Buffer allows senders to send multiple elements before suspending, similar to the <code class="code ">BlockingQueue</code> with a specified capacity, which blocks when buffer is full.</p>
<p id="3a3bb0ca">Take a look at the behavior of the following code:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.channels.* fun main() = runBlocking&lt;Unit&gt; { //sampleStart val channel = Channel&lt;Int&gt;(4) // create buffered channel val sender = launch { // launch sender coroutine repeat(10) { println("Sending $it") // print before sending each element channel.send(it) // will suspend when buffer is full } } // don't receive anything... just wait.... delay(1000) sender.cancel() // cancel sender coroutine //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="8dfd15a8"><p id="6d3c71e2">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-channel-08.kt" id="867a1137" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="a6291053">It prints "sending" <em id="66a8cef5" class="">five</em> times using a buffered channel with capacity of <em id="55e5a179" class="">four</em>:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">Sending 0 Sending 1 Sending 2 Sending 3 Sending 4 </pre>
<p id="8d01a01b">The first four elements are added to the buffer and the sender suspends when trying to send the fifth one.</p></section><section class="chapter"><h2 id="channels-are-fair" data-toc="channels#channels-are-fair">Channels are fair</h2>
<p id="b907ceda">Send and receive operations to channels are <em id="d891b5ae" class="">fair</em> with respect to the order of their invocation from multiple coroutines. They are served in first-in first-out order, e.g. the first coroutine to invoke <code class="code ">receive</code> gets the element. In the following example two coroutines "ping" and "pong" are receiving the "ball" object from the shared "table" channel.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.channels.* //sampleStart data class Ball(var hits: Int) fun main() = runBlocking { val table = Channel&lt;Ball&gt;() // a shared table launch { player("ping", table) } launch { player("pong", table) } table.send(Ball(0)) // serve the ball delay(1000) // delay 1 second coroutineContext.cancelChildren() // game over, cancel them } suspend fun player(name: String, table: Channel&lt;Ball&gt;) { for (ball in table) { // receive the ball in a loop ball.hits++ println("$name $ball") delay(300) // wait a bit table.send(ball) // send the ball back } } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="7c07708c"><p id="98f82448">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-channel-09.kt" id="51c0c316" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="ce65823f">The "ping" coroutine is started first, so it is the first one to receive the ball. Even though "ping" coroutine immediately starts receiving the ball again after sending it back to the table, the ball gets received by the "pong" coroutine, because it was already waiting for it:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">ping Ball(hits=1) pong Ball(hits=2) ping Ball(hits=3) pong Ball(hits=4) </pre>
<p id="54c800ba">Note that sometimes channels may produce executions that look unfair due to the nature of the executor that is being used. See <a href="https://github.com/Kotlin/kotlinx.coroutines/issues/111" id="818ba4ec" data-external="true" rel="noopener noreferrer">this issue</a> for details.</p></section><section class="chapter"><h2 id="ticker-channels" data-toc="channels#ticker-channels">Ticker channels</h2>
<p id="3cdcb468">Ticker channel is a special rendezvous channel that produces <code class="code ">Unit</code> every time given delay passes since last consumption from this channel. Though it may seem to be useless standalone, it is a useful building block to create complex time-based <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html" id="58be2ed" data-external="true" rel="noopener noreferrer">produce</a> pipelines and operators that do windowing and other time-dependent processing. Ticker channel can be used in <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html" id="6aa79938" data-external="true" rel="noopener noreferrer">select</a> to perform "on tick" action.</p>
<p id="69b7ddfe">To create such channel use a factory method <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html" id="c6bf494c" data-external="true" rel="noopener noreferrer">ticker</a>. To indicate that no further elements are needed use <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/cancel.html" id="da583787" data-external="true" rel="noopener noreferrer">ReceiveChannel.cancel</a> method on it.</p>
<p id="899d449e">Now let's see how it works in practice:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.channels.* fun main() = runBlocking&lt;Unit&gt; { val tickerChannel = ticker(delayMillis = 100, initialDelayMillis = 0) // create ticker channel var nextElement = withTimeoutOrNull(1) { tickerChannel.receive() } println("Initial element is available immediately: $nextElement") // no initial delay nextElement = withTimeoutOrNull(50) { tickerChannel.receive() } // all subsequent elements have 100ms delay println("Next element is not ready in 50 ms: $nextElement") nextElement = withTimeoutOrNull(60) { tickerChannel.receive() } println("Next element is ready in 100 ms: $nextElement") // Emulate large consumption delays println("Consumer pauses for 150ms") delay(150) // Next element is available immediately nextElement = withTimeoutOrNull(1) { tickerChannel.receive() } println("Next element is available immediately after large consumer delay: $nextElement") // Note that the pause between `receive` calls is taken into account and next element arrives faster nextElement = withTimeoutOrNull(60) { tickerChannel.receive() } println("Next element is ready in 50ms after consumer pause in 150ms: $nextElement") tickerChannel.cancel() // indicate that no more elements are needed } </pre>
<aside data-type="note" class="prompt" data-title="" id="936fd175"><p id="6bc74a35">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-channel-10.kt" id="769dfc9c" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="44140776">It prints following lines:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">Initial element is available immediately: kotlin.Unit Next element is not ready in 50 ms: null Next element is ready in 100 ms: kotlin.Unit Consumer pauses for 150ms Next element is available immediately after large consumer delay: kotlin.Unit Next element is ready in 50ms after consumer pause in 150ms: kotlin.Unit </pre>
<p id="98fd688f">Note that <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html" id="bcd85b4e" data-external="true" rel="noopener noreferrer">ticker</a> is aware of possible consumer pauses and, by default, adjusts next produced element delay if a pause occurs, trying to maintain a fixed rate of produced elements.</p>
<p id="f5adc177">Optionally, a <code class="code ">mode</code> parameter equal to <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-ticker-mode/-f-i-x-e-d_-d-e-l-a-y/index.html" id="e9c79904" data-external="true" rel="noopener noreferrer">TickerMode.FIXED_DELAY</a> can be specified to maintain a fixed delay between elements.</p></section><div class="last-modified"> Last modified: 21 October 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="flow">Asynchronous Flow</a> <a class="navigation-links__next" href="exception-handling">Coroutine exceptions handling</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/channels.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/channels.html</a>
  </p>
</div>
