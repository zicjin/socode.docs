<h1 data-toc="competitive-programming" id="competitive-programming.md">Kotlin for competitive programming</h1>
<p id="1ae79a0c">This tutorial is designed both for competitive programmers that did not use Kotlin before and for Kotlin developers that did not participate in any competitive programming events before. It assumes the corresponding programming skills.</p>
<p id="4b956af6"><a href="https://en.wikipedia.org/wiki/Competitive_programming" id="d5a9524c" data-external="true" rel="noopener noreferrer">Competitive programming</a> is a mind sport where contestants write programs to solve precisely specified algorithmic problems within strict constraints. Problems can range from simple ones that can be solved by any software developer and require little code to get a correct solution, to complex ones that require knowledge of special algorithms, data structures, and a lot of practice. While not being specifically designed for competitive programming, Kotlin incidentally fits well in this domain, reducing the typical amount of boilerplate that a programmer needs to write and read while working with the code almost to the level offered by dynamically-typed scripting languages, while having tooling and performance of a statically-typed language.</p>
<p id="c880698c">See <a href="jvm-get-started" id="8312ff4f">Get started with Kotlin/JVM</a> on how to set up development environment for Kotlin. In competitive programming, a single project is usually created and each problem's solution is written in a single source file.</p>
<section class="chapter"><h2 id="simple-example-reachable-numbers-problem" data-toc="competitive-programming#simple-example-reachable-numbers-problem">Simple example: Reachable Numbers problem</h2>
<p id="f2d2ac68">Let's take a look at a concrete example.</p>
<p id="a7ffa042"><a href="https://codeforces.com/" id="346c5d70" data-external="true" rel="noopener noreferrer">Codeforces</a> Round 555 was held on April 26th for 3rd Division, which means it had problems fit for any developer to try. You can use <a href="https://codeforces.com/contest/1157" id="9c25882" data-external="true" rel="noopener noreferrer">this link</a> to read the problems. The simplest problem in the set is the <a href="https://codeforces.com/contest/1157/problem/A" id="979a5a75" data-external="true" rel="noopener noreferrer">Problem A: Reachable Numbers</a>. It asks to implement a straightforward algorithm described in the problem statement.</p>
<p id="b7fa6a5c">We'd start solving it by creating a Kotlin source file with an arbitrary name. <code class="code ">A.kt</code> will do well. First, you need to implement a function specified in the problem statement as:</p>
<p id="9e5192fa">Let's denote a function f(x) in such a way: we add 1 to x, then, while there is at least one trailing zero in the resulting number, we remove that zero.</p>
<p id="ca21782b">Kotlin is a pragmatic and unopinionated language, supporting both imperative and function programming styles without pushing the developer towards either one. You can implement the function <code class="code ">f</code> in functional style, using such Kotlin features as <a href="functions#tail-recursive-functions" id="6f777e60">tail recursion</a>:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">tailrec fun removeZeroes(x: Int): Int = if (x % 10 == 0) removeZeroes(x / 10) else x fun f(x: Int) = removeZeroes(x + 1) </pre>
<p id="c96c75fc">Alternatively, you can write an imperative implementation of the function <code class="code ">f</code> using the traditional <a href="control-flow" id="8d2f3fc1">while loop</a> and mutable variables that are denoted in Kotlin with <a href="basic-syntax#variables" id="f4704e91">var</a>:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun f(x: Int): Int { var cur = x + 1 while (cur % 10 == 0) cur /= 10 return cur } </pre>
<p id="d2d6c92c">Types in Kotlin are optional in many places due to pervasive use of type-inference, but every declaration still has a well-defined static type that is known at compilation.</p>
<p id="1ec7a2ad">Now, all is left is to write the main function that reads the input and implements the rest of the algorithm that the problem statement asks for â€” to compute the number of different integers that are produced while repeatedly applying function <code class="code ">f</code> to the initial number <code class="code ">n</code> that is given in the standard input.</p>
<p id="863a5d93">By default, Kotlin runs on JVM and gives direct access to a rich and efficient collections library with general-purpose collections and data-structures like dynamically-sized arrays (<code class="code ">ArrayList</code>), hash-based maps and sets (<code class="code ">HashMap</code>/<code class="code ">HashSet</code>), tree-based ordered maps and sets (<code class="code ">TreeMap</code>/<code class="code ">TreeSet</code>), etc. Using a hash-set of integers to track values that were already reached while applying function <code class="code ">f</code>, the straightforward imperative version of a solution to the problem can be written as shown below:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun main() { var n = readln().toInt() // read integer from the input val reached = HashSet&lt;Int&gt;() // a mutable hash set while (reached.add(n)) n = f(n) // iterate function f println(reached.size) // print answer to the output } </pre>
<aside data-type="note" class="prompt" data-title="" id="ff67472"><p id="471dbcae">The readln() function is available since <a href="whatsnew16#new-readline-functions" id="349bdc1d">Kotlin 1.6.0</a>.</p></aside><p id="9fa41e08">There is no need to handle the case of misformatted input in competitive programming. An input format is always precisely specified in competitive programming, and the actual input cannot deviate from the input specification in the problem statement. That's why you can use Kotlin's <a href="../api/latest/jvm/stdlib/kotlin.io/readln" id="1f159a55" data-external="true" rel="noopener noreferrer"><code class="code ">readln()</code></a> function. It asserts that the input string is present and throws an exception otherwise. Likewise, the <a href="../api/latest/jvm/stdlib/kotlin.text/to-int" id="b8a936d5" data-external="true" rel="noopener noreferrer"><code class="code ">String.toInt()</code></a> function throws an exception if the input string is not an integer.</p>
<p id="4d3c24ae">All online competitive programming events allow the use of pre-written code, so you can define your own library of utility functions that are geared towards competitive programming to make your actual solution code somewhat easier to read and write. You would then use this code as a template for your solutions. For example, you can define the following helper functions for reading inputs in competitive programming:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">private fun readInt() = readln().toInt() private fun readStr() = readln().toString() // etc for other types you'd use in your solutions </pre>
<p id="b21cef05">Note the use of <code class="code ">private</code><a href="visibility-modifiers" id="f6e81d87">visibility modifier</a> here. While the concept of visibility modifier is not relevant for competitive programming at all, it allows you to place multiple solution files based on the same template without getting an error for conflicting public declarations in the same package.</p></section><section class="chapter"><h2 id="functional-operators-example-long-number-problem" data-toc="competitive-programming#functional-operators-example-long-number-problem">Functional operators example: Long Number problem</h2>
<p id="2c92f21">For more complicated problems, Kotlin's extensive library of functional operations on collections comes in handy to minimize the boilerplate and turn the code into a linear top-to-bottom and left-to-right fluent data transformation pipeline. For example, the <a href="https://codeforces.com/contest/1157/problem/B" id="e6a6535b" data-external="true" rel="noopener noreferrer">Problem B: Long Number</a> problem takes a simple greedy algorithm to implement and it can be written using this style without a single mutable variable:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun main() { // read input val n = readln().toInt() val s = readln() val fl = readln().split(" ").map { it.toInt() } // define local function f fun f(c: Char) = '0' + fl[c - '1'] // greedily find first and last indices val i = s.indexOfFirst { c -&gt; f(c) &gt; c } .takeIf { it &gt;= 0 } ?: s.length val j = s.withIndex().indexOfFirst { (j, c) -&gt; j &gt; i &amp;&amp; f(c) &lt; c } .takeIf { it &gt;= 0 } ?: s.length // compose and write the answer val ans = s.substring(0, i) + s.substring(i, j).map { c -&gt; f(c) }.joinToString("") + s.substring(j) println(ans) } </pre>
<p id="df616d3e">In this dense code, in addition to collection transformations, you can see such handy Kotlin features as local functions and the <a href="null-safety#elvis-operator" id="562f9a29">elvis operator</a><code class="code ">?:</code> that allow to express <a href="idioms" id="96273c7f">idioms</a> like "take the value if it is positive or else use length" with a concise and readable expressions like <code class="code ">.takeIf { it &gt;= 0 } ?: s.length</code>, yet it is perfectly fine with Kotlin to create additional mutable variables and express the same code in imperative style, too.</p>
<p id="346aff2d">To make reading the input in competitive programming tasks like this more concise, you can have the following list of helper input-reading functions:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">private fun readInt() = readln().toInt() // single int private fun readStrings() = readln().split(" ") // list of strings private fun readInts() = readStrings().map { it.toInt() } // list of ints </pre>
<p id="662caf57">With these helpers, the part of code for reading input becomes simpler, closely following the input specification in the problem statement line by line:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin"> // read input val n = readInt() val s = readln() val fl = readInts() </pre>
<p id="5fdeccdf">Note that in competitive programming it is customary to give variables shorter names than it is typical in industrial programming practice, since the code is to be written just once and not supported thereafter. However, these names are usually still mnemonic â€” <code class="code ">a</code> for arrays, <code class="code ">i</code>, <code class="code ">j</code>, etc for indices, <code class="code ">r</code>, and <code class="code ">c</code> for row and column numbers in tables, <code class="code ">x</code> and <code class="code ">y</code> for coordinates, etc. It is easier to keep the same names for input data as it is given in the problem statement. However, more complex problems require more code which leads to using longer self-explanatory variable and function names.</p></section><section class="chapter"><h2 id="more-tips-and-tricks" data-toc="competitive-programming#more-tips-and-tricks">More tips and tricks</h2>
<p id="f79fd81f">Competitive programming problems often have input like this:</p>
<p id="26987dec">The first line of the input contains two integers <code class="code ">n</code> and <code class="code ">k</code></p>
<p id="e7317a2b">In Kotlin this line can be concisely parsed with the following statement using <a href="destructuring-declarations" id="36f3d5ce">destructuring declaration</a> from a list of integers:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val (n, k) = readInts() </pre>
<p id="68c35a3a">It might be temping to use JVM's <code class="code ">java.util.Scanner</code> class to parse less structured input formats. Kotlin is designed to interoperate well with JVM libraries, so that their use feels quite natural in Kotlin. However, beware that <code class="code ">java.util.Scanner</code> is extremely slow. So slow, in fact, that parsing 10<sup class="superscript" id="87c5bfc0">5</sup> or more integers with it might not fit into a typical 2 second time-limit, which a simple Kotlin's <code class="code ">split(" ").map { it.toInt() }</code> would handle.</p>
<p id="5c4f367e">Writing output in Kotlin is usually straightforward with <a href="../api/latest/jvm/stdlib/kotlin.io/println" id="4b047c7b" data-external="true" rel="noopener noreferrer">println(...)</a> calls and using Kotlin's <a href="basic-types#string-templates" id="8e4efab9">string templates</a>. However, care must be taken when output contains on order of 10<sup class="superscript" id="88698e23">5</sup> lines or more. Issuing so many <code class="code ">println</code> calls is too slow, since the output in Kotlin is automatically flushed after each line. A faster way to write many lines from an array or a list is using <a href="../api/latest/jvm/stdlib/kotlin.collections/join-to-string" id="b4ade404" data-external="true" rel="noopener noreferrer">joinToString()</a> function with <code class="code ">"\n"</code> as the separator, like this:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">println(a.joinToString("\n")) // each element of array/list of a separate line </pre></section><section class="chapter"><h2 id="learning-kotlin" data-toc="competitive-programming#learning-kotlin">Learning Kotlin</h2>
<p id="a5c4069c">Kotlin is easy to learn, especially for those who already know Java. A short introduction to the basic syntax of Kotlin for software developers can be found directly in the reference section of the web site starting from <a href="basic-syntax" id="5b6b4f66">basic syntax</a>.</p>
<p id="74bbb40a">IDEA has built-in <a href="https://www.jetbrains.com/help/idea/converting-a-java-file-to-kotlin-file.html" id="431905fd" data-external="true" rel="noopener noreferrer">Java-to-Kotlin converter</a>. It can be used by people familiar with Java to learn the corresponding Kotlin syntactic constructions, but it is not perfect and it is still worth familiarizing yourself with Kotlin and learning the <a href="idioms" id="afe3aabf">Kotlin idioms</a>.</p>
<p id="d855a5be">A great resource to study Kotlin syntax and API of the Kotlin standard library are <a href="koans" id="dfd59a8a">Kotlin Koans</a>.</p></section><div class="last-modified"> Last modified: 27 January 2022</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="data-science-overview">Kotlin for data science</a> <a class="navigation-links__next" href="whatsnew16">What's new in Kotlin 1.6.0</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/competitive-programming.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/competitive-programming.html</a>
  </p>
</div>
