<h1 data-toc="native-objc-interop" id="native-objc-interop.md">Interoperability with Swift/Objective-C</h1>
<p id="57631f7f">This document covers some details of Kotlin/Native interoperability with Swift/Objective-C.</p>
<section class="chapter"><h2 id="usage" data-toc="native-objc-interop#usage">Usage</h2>
<p id="f2e5df47">Kotlin/Native provides bidirectional interoperability with Objective-C. Objective-C frameworks and libraries can be used in Kotlin code if properly imported to the build (system frameworks are imported by default). See <a href="mpp-configure-compilations#configure-interop-with-native-languages" id="c57af4ff">compilation configurations</a> for more details. A Swift library can be used in Kotlin code if its API is exported to Objective-C with <code class="code ">@objc</code>. Pure Swift modules are not yet supported.</p>
<p id="7963a96d">Kotlin modules can be used in Swift/Objective-C code if compiled into a framework (<a href="mpp-build-native-binaries#declare-binaries" id="d8086cde">see here for how to declare binaries</a>). See <a href="https://github.com/JetBrains/kotlin/tree/master/kotlin-native/samples/calculator" id="50b7e1a5" data-external="true" rel="noopener noreferrer">calculator sample</a> for an example.</p></section><section class="chapter"><h2 id="mappings" data-toc="native-objc-interop#mappings">Mappings</h2>
<p id="518e009c">The table below shows how Kotlin concepts are mapped to Swift/Objective-C and vice versa.</p>
<p id="cd69c575">"-&gt;" and "&lt;-" indicate that mapping only goes one way.</p>
<div class="table-wrapper"><table class=" wide" id="69d4c19e">
<thead><tr class="ijRowHead" id="ea4f72e5">
<th id="1cb32345"><p>Kotlin</p></th>
<th id="fd9b4fe"><p>Swift</p></th>
<th id="d770b853"><p>Objective-C</p></th>
<th id="b3a02a65"><p>Notes</p></th>
</tr></thead>
<tbody>
<tr class="" id="6666fd95">
<td id="463375cc"><p><code class="code ">class</code></p></td>
<td id="9fddbe47"><p><code class="code ">class</code></p></td>
<td id="2f19c760"><p><code class="code ">@interface</code></p></td>
<td id="cdd88af6"><p><a href="#name-translation" id="a0a4bf9e">note</a></p></td>
</tr>
<tr class="" id="b4ec3bdf">
<td id="86738d05"><p><code class="code ">interface</code></p></td>
<td id="3d948480"><p><code class="code ">protocol</code></p></td>
<td id="29a67635"><p><code class="code ">@protocol</code></p></td>
<td id="725af17e"></td>
</tr>
<tr class="" id="3bd407cb">
<td id="29936b3a"><p><code class="code ">constructor</code>/<code class="code ">create</code></p></td>
<td id="45af4fa3"><p>Initializer</p></td>
<td id="a203f568"><p>Initializer</p></td>
<td id="1414813"><p><a href="#initializers" id="ca218715">note</a></p></td>
</tr>
<tr class="" id="d5a01987">
<td id="f45f3319"><p>Property</p></td>
<td id="ac8f8288"><p>Property</p></td>
<td id="dc4248e1"><p>Property</p></td>
<td id="f27e0694"><p><a href="#top-level-functions-and-properties" id="57cfd8e3">note</a><a href="#setters" id="b00fe1f8">note</a></p></td>
</tr>
<tr class="" id="edb8f497">
<td id="21ffcccd"><p>Method</p></td>
<td id="e72c920d"><p>Method</p></td>
<td id="b9a8a92f"><p>Method</p></td>
<td id="f2de003c"><p><a href="#top-level-functions-and-properties" id="9068391e">note</a><a href="#method-names-translation" id="4921743e">note</a></p></td>
</tr>
<tr class="" id="23b292b8">
<td id="3ef2650a"><p><code class="code ">suspend</code>-&gt;</p></td>
<td id="cbd07a76"><p><code class="code ">completionHandler:</code>/<code class="code ">async</code></p></td>
<td id="aa758014"><p><code class="code ">completionHandler:</code></p></td>
<td id="72b3359"><p><a href="#errors-and-exceptions" id="37f840cb">note</a><a href="#suspending-functions" id="a9015cbc">note</a></p></td>
</tr>
<tr class="" id="f49f4e2b">
<td id="9748de99"><p><code class="code ">@Throws fun</code></p></td>
<td id="dda4114b"><p><code class="code ">throws</code></p></td>
<td id="b7442b85"><p><code class="code ">error:(NSError**)error</code></p></td>
<td id="4008a42f"><p><a href="#errors-and-exceptions" id="9a57d8f3">note</a></p></td>
</tr>
<tr class="" id="846ca0d1">
<td id="ad4710c8"><p>Extension</p></td>
<td id="70d5dc1a"><p>Extension</p></td>
<td id="6a437b77"><p>Category member</p></td>
<td id="85ee220b"><p><a href="#extensions-and-category-members" id="9c366549">note</a></p></td>
</tr>
<tr class="" id="5e8d1bc1">
<td id="9d831b0b"><p><code class="code ">companion</code> member &lt;-</p></td>
<td id="1a4fd96a"><p>Class method or property</p></td>
<td id="cd94b5e0"><p>Class method or property</p></td>
<td id="5b573c1"></td>
</tr>
<tr class="" id="9c733d5c">
<td id="829acbe0"><p><code class="code ">null</code></p></td>
<td id="b712e3a3"><p><code class="code ">nil</code></p></td>
<td id="172db248"><p><code class="code ">nil</code></p></td>
<td id="ba614ae7"></td>
</tr>
<tr class="" id="cba1f40f">
<td id="2877167c"><p><code class="code ">Singleton</code></p></td>
<td id="13493b61"><p><code class="code ">shared</code> or <code class="code ">companion</code> property</p></td>
<td id="4872e4d9"><p><code class="code ">shared</code> or <code class="code ">companion</code> property</p></td>
<td id="e2fab19c"><p><a href="#kotlin-singletons" id="c3b7de1f">note</a></p></td>
</tr>
<tr class="" id="e9329edc">
<td id="e3667449"><p>Primitive type</p></td>
<td id="81992e2"><p>Primitive type / <code class="code ">NSNumber</code></p></td>
<td id="f2dc7e37"></td>
<td id="f4e171a5"><p><a href="#nsnumber" id="1477fe13">note</a></p></td>
</tr>
<tr class="" id="5b6f14ef">
<td id="e03d0922"><p><code class="code ">Unit</code> return type</p></td>
<td id="140721e6"><p><code class="code ">Void</code></p></td>
<td id="d05b1f1a"><p><code class="code ">void</code></p></td>
<td id="2a70789"></td>
</tr>
<tr class="" id="750f7ed1">
<td id="fcb5ce32"><p><code class="code ">String</code></p></td>
<td id="3b0cbcb3"><p><code class="code ">String</code></p></td>
<td id="ad05d4b"><p><code class="code ">NSString</code></p></td>
<td id="c5188afa"></td>
</tr>
<tr class="" id="afbb24aa">
<td id="5b384583"><p><code class="code ">String</code></p></td>
<td id="1687d061"><p><code class="code ">NSMutableString</code></p></td>
<td id="4c6cceeb"><p><code class="code ">NSMutableString</code></p></td>
<td id="e3934d35"><p><a href="#nsmutablestring" id="c0ddca0">note</a></p></td>
</tr>
<tr class="" id="3a57447c">
<td id="6fba8778"><p><code class="code ">List</code></p></td>
<td id="40dd0e1a"><p><code class="code ">Array</code></p></td>
<td id="e4c87bcf"><p><code class="code ">NSArray</code></p></td>
<td id="a8a82e9e"></td>
</tr>
<tr class="" id="b10b68f9">
<td id="ef6e7579"><p><code class="code ">MutableList</code></p></td>
<td id="eefd0f8d"><p><code class="code ">NSMutableArray</code></p></td>
<td id="b2369f68"><p><code class="code ">NSMutableArray</code></p></td>
<td id="da8248d5"></td>
</tr>
<tr class="" id="f7b033cd">
<td id="762e0e96"><p><code class="code ">Set</code></p></td>
<td id="420cad71"><p><code class="code ">Set</code></p></td>
<td id="88beb424"><p><code class="code ">NSSet</code></p></td>
<td id="abf90435"></td>
</tr>
<tr class="" id="5899f33a">
<td id="3233cdc6"><p><code class="code ">MutableSet</code></p></td>
<td id="c6208cb"><p><code class="code ">NSMutableSet</code></p></td>
<td id="76a785d"><p><code class="code ">NSMutableSet</code></p></td>
<td id="79c6f8f8"><p><a href="#collections" id="b48e7d7a">note</a></p></td>
</tr>
<tr class="" id="4d2648e5">
<td id="c19c8952"><p><code class="code ">Map</code></p></td>
<td id="d80720d9"><p><code class="code ">Dictionary</code></p></td>
<td id="84210590"><p><code class="code ">NSDictionary</code></p></td>
<td id="6aabb3a"></td>
</tr>
<tr class="" id="fd432933">
<td id="def39865"><p><code class="code ">MutableMap</code></p></td>
<td id="5afae9ed"><p><code class="code ">NSMutableDictionary</code></p></td>
<td id="fe366ef1"><p><code class="code ">NSMutableDictionary</code></p></td>
<td id="7a7f021a"><p><a href="#collections" id="d6c0b3d5">note</a></p></td>
</tr>
<tr class="" id="964a8620">
<td id="78bb798a"><p>Function type</p></td>
<td id="cd176ef4"><p>Function type</p></td>
<td id="4ed195"><p>Block pointer type</p></td>
<td id="ba2f55fa"><p><a href="#function-types" id="e88cc52f">note</a></p></td>
</tr>
<tr class="" id="766c3f2e">
<td id="17a7e253"><p>Inline classes</p></td>
<td id="16e15e38"><p>Unsupported</p></td>
<td id="936606bf"><p>Unsupported</p></td>
<td id="28b295ad"><p><a href="#unsupported" id="9ca01195">note</a></p></td>
</tr>
</tbody>
</table></div>
<section class="chapter"><h3 id="name-translation" data-toc="native-objc-interop#name-translation">Name translation</h3>
<p id="f03c6819">Objective-C classes are imported into Kotlin with their original names. Protocols are imported as interfaces with <code class="code ">Protocol</code> name suffix, i.e. <code class="code ">@protocol Foo</code>-&gt; <code class="code ">interface FooProtocol</code>. These classes and interfaces are placed into a package <a href="#usage" id="bedf9176">specified in build configuration</a> (<code class="code ">platform.*</code> packages for preconfigured system frameworks).</p>
<p id="a67d810c">The names of Kotlin classes and interfaces are prefixed when imported to Objective-C. The prefix is derived from the framework name.</p>
<p id="ba511ff1">Objective-C does not support packages in a framework. Thus, the Kotlin compiler renames Kotlin classes which have the same name but different package in the same framework. This algorithm is not stable yet and can change between Kotlin releases. As a workaround, you can rename the conflicting Kotlin classes in the framework.</p></section><section class="chapter"><h3 id="initializers" data-toc="native-objc-interop#initializers">Initializers</h3>
<p id="7fde7514">Swift/Objective-C initializers are imported to Kotlin as constructors and factory methods named <code class="code ">create</code>. The latter happens with initializers declared in the Objective-C category or as a Swift extension, because Kotlin has no concept of extension constructors.</p>
<p id="9bacf48b">Kotlin constructors are imported as initializers to Swift/Objective-C.</p></section><section class="chapter"><h3 id="setters" data-toc="native-objc-interop#setters">Setters</h3>
<p id="8bad19f6">Writeable Objective-C properties overriding read-only properties of the superclass are represented as <code class="code ">setFoo()</code> method for the property <code class="code ">foo</code>. Same goes for a protocol's read-only properties that are implemented as mutable.</p></section><section class="chapter"><h3 id="top-level-functions-and-properties" data-toc="native-objc-interop#top-level-functions-and-properties">Top-level functions and properties</h3>
<p id="587383b7">Top-level Kotlin functions and properties are accessible as members of special classes. Each Kotlin file is translated into such a class. E.g.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">// MyLibraryUtils.kt package my.library fun foo() {} </pre>
<p id="c160e581">can be called from Swift like</p>
<pre class="code-block" data-lang="swift" data-language="swift">MyLibraryUtilsKt.foo() </pre></section><section class="chapter"><h3 id="method-names-translation" data-toc="native-objc-interop#method-names-translation">Method names translation</h3>
<p id="ed2f1ac1">Generally Swift argument labels and Objective-C selector pieces are mapped to Kotlin parameter names. Anyway these two concepts have different semantics, so sometimes Swift/Objective-C methods can be imported with a clashing Kotlin signature. In this case the clashing methods can be called from Kotlin using named arguments, e.g.:</p>
<pre class="code-block" data-lang="swift" data-language="swift">[player moveTo:LEFT byMeters:17] [player moveTo:UP byInches:42] </pre>
<p id="30486cf1">in Kotlin it would be:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">player.moveTo(LEFT, byMeters = 17) player.moveTo(UP, byInches = 42) </pre></section><section class="chapter"><h3 id="errors-and-exceptions" data-toc="native-objc-interop#errors-and-exceptions">Errors and exceptions</h3>
<p id="17c4e288">Kotlin has no concept of checked exceptions, all Kotlin exceptions are unchecked. Swift has only checked errors. So if Swift or Objective-C code calls a Kotlin method which throws an exception to be handled, then the Kotlin method should be marked with a <code class="code ">@Throws</code> annotation specifying a list of "expected" exception classes.</p>
<p id="36bc814c">When compiling to Objective-C/Swift framework, non-<code class="code ">suspend</code> functions having or inheriting <code class="code ">@Throws</code> annotation are represented as <code class="code ">NSError*</code>-producing methods in Objective-C and as <code class="code ">throws</code> methods in Swift. Representations for <code class="code ">suspend</code> functions always have <code class="code ">NSError*</code>/<code class="code ">Error</code> parameter in completion handler.</p>
<p id="629c8635">When Kotlin function called from Swift/Objective-C code throws an exception which is an instance of one of the <code class="code ">@Throws</code>-specified classes or their subclasses, it is propagated as <code class="code ">NSError</code>. Other Kotlin exceptions reaching Swift/Objective-C are considered unhandled and cause program termination.</p>
<p id="f146049a"><code class="code ">suspend</code> functions without <code class="code ">@Throws</code> propagate only <code class="code ">CancellationException</code> as <code class="code ">NSError</code>. Non-<code class="code ">suspend</code> functions without <code class="code ">@Throws</code> don't propagate Kotlin exceptions at all.</p>
<p id="ea437d95">Note that the opposite reversed translation is not implemented yet: Swift/Objective-C error-throwing methods aren't imported to Kotlin as exception-throwing.</p></section><section class="chapter"><h3 id="suspending-functions" data-toc="native-objc-interop#suspending-functions">Suspending functions</h3>
<aside data-type="warning" class="prompt" data-title="" id="309cc749"><p id="51645afa">Support for calling <code class="code ">suspend</code> functions from Swift code as <code class="code ">async</code> is <a href="components-stability" id="4986aadf">Experimental</a>. It may be dropped or changed at any time. Use it only for evaluation purposes. We would appreciate your feedback on it in <a href="https://youtrack.jetbrains.com/issue/KT-47610" id="e631c683" data-external="true" rel="noopener noreferrer">YouTrack</a>.</p></aside><p id="fab6ffe7">Kotlin's <a href="coroutines-basics" id="3867536c">suspending functions</a> (<code class="code ">suspend</code>) are presented in the generated Objective-C headers as functions with callbacks, or <a href="https://developer.apple.com/documentation/swift/calling_objective-c_apis_asynchronously" id="e6a9910a" data-external="true" rel="noopener noreferrer">completion handlers</a> in Swift/Objective-C terminology.</p>
<p id="1f2c6de4">Starting from Swift 5.5, Kotlin's <code class="code ">suspend</code> functions are also available for calling from Swift as <code class="code ">async</code> functions without using the completion handlers. Currently, this functionality is highly experimental and has certain limitations. See <a href="https://youtrack.jetbrains.com/issue/KT-47610" id="880ff50b" data-external="true" rel="noopener noreferrer">this YouTrack issue</a> for details.</p>
<p id="793c308d">Learn more about the <a href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html" id="628e06c" data-external="true" rel="noopener noreferrer"><code class="code ">async</code>/<code class="code ">await</code> mechanism in Swift</a>.</p></section><section class="chapter"><h3 id="extensions-and-category-members" data-toc="native-objc-interop#extensions-and-category-members">Extensions and category members</h3>
<p id="2ba32a83">Members of Objective-C categories and Swift extensions are imported to Kotlin as extensions. That's why these declarations can't be overridden in Kotlin. And the extension initializers aren't available as Kotlin constructors.</p>
<p id="784a21f8">Kotlin extensions to "regular" Kotlin classes are imported to Swift and Objective-C as extensions and category members respectively. Kotlin extensions to other types are treated as <a href="#top-level-functions-and-properties" id="319419f">top-level declarations</a> with an additional receiver parameter. These types include:</p>
<ul class="list _ul" id="a6decff7">
<li class="list__item" id="9e6279e2"><p>Kotlin <code class="code ">String</code> type</p></li>
<li class="list__item" id="7fc64ff3"><p>Kotlin collection types and subtypes</p></li>
<li class="list__item" id="7db0c321"><p>Kotlin <code class="code ">interface</code> types</p></li>
<li class="list__item" id="1702c5fe"><p>Kotlin primitive types</p></li>
<li class="list__item" id="286c36b2"><p>Kotlin <code class="code ">inline</code> classes</p></li>
<li class="list__item" id="1339e412"><p>Kotlin <code class="code ">Any</code> type</p></li>
<li class="list__item" id="a52114b4"><p>Kotlin function types and subtypes</p></li>
<li class="list__item" id="887fad90"><p>Objective-C classes and protocols</p></li>
</ul></section><section class="chapter"><h3 id="kotlin-singletons" data-toc="native-objc-interop#kotlin-singletons">Kotlin singletons</h3>
<p id="3d38dd6c">Kotlin singleton (made with an <code class="code ">object</code> declaration, including <code class="code ">companion object</code>) is imported to Swift/Objective-C as a class with a single instance.</p>
<p id="df23495f">The instance is available through the <code class="code ">shared</code> and <code class="code ">companion</code> properties.</p>
<p id="a9e326f2">For the following Kotlin code:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">object MyObject { val x = "Some value" } class MyClass { companion object { val x = "Some value" } } </pre>
<p id="5ddd79b4">Access these objects as follows:</p>
<pre class="code-block" data-lang="swift" data-language="swift">MyObject.shared MyObject.shared.x MyClass.companion MyClass.Companion.shared </pre>
<aside data-type="note" class="prompt" data-title="" id="bfd6c7db"><p id="f25c6d9e">Access objects through <code class="code ">[MySingleton mySingleton]</code> in Objective-C and <code class="code ">MySingleton()</code> in Swift has been deprecated.</p></aside></section><section class="chapter"><h3 id="nsnumber" data-toc="native-objc-interop#nsnumber">NSNumber</h3>
<p id="7c02be6">Kotlin primitive type boxes are mapped to special Swift/Objective-C classes. For example, <code class="code ">kotlin.Int</code> box is represented as <code class="code ">KotlinInt</code> class instance in Swift (or <code class="code ">${prefix}Int</code> instance in Objective-C, where <code class="code ">prefix</code> is the framework names prefix). These classes are derived from <code class="code ">NSNumber</code>, so the instances are proper <code class="code ">NSNumber</code>s supporting all corresponding operations.</p>
<p id="66448849"><code class="code ">NSNumber</code> type is not automatically translated to Kotlin primitive types when used as a Swift/Objective-C parameter type or return value. The reason is that <code class="code ">NSNumber</code> type doesn't provide enough information about a wrapped primitive value type, i.e. <code class="code ">NSNumber</code> is statically not known to be a e.g. <code class="code ">Byte</code>, <code class="code ">Boolean</code>, or <code class="code ">Double</code>. So Kotlin primitive values should be cast to/from <code class="code ">NSNumber</code> manually (see <a href="#casting-between-mapped-types" id="7ccc6574">below</a>).</p></section><section class="chapter"><h3 id="nsmutablestring" data-toc="native-objc-interop#nsmutablestring">NSMutableString</h3>
<p id="486949c0"><code class="code ">NSMutableString</code> Objective-C class is not available from Kotlin. All instances of <code class="code ">NSMutableString</code> are copied when passed to Kotlin.</p></section><section class="chapter"><h3 id="collections" data-toc="native-objc-interop#collections">Collections</h3>
<p id="13cfc479">Kotlin collections are converted to Swift/Objective-C collections as described in the table above. Swift/Objective-C collections are mapped to Kotlin in the same way, except for <code class="code ">NSMutableSet</code> and <code class="code ">NSMutableDictionary</code>. <code class="code ">NSMutableSet</code> isn't converted to a Kotlin <code class="code ">MutableSet</code>. To pass an object for Kotlin <code class="code ">MutableSet</code>, you can create this kind of Kotlin collection explicitly by either creating it in Kotlin with e.g. <code class="code ">mutableSetOf()</code>, or using the <code class="code ">KotlinMutableSet</code> class in Swift (or <code class="code ">${prefix}MutableSet</code> in Objective-C, where <code class="code ">prefix</code> is the framework names prefix). The same holds for <code class="code ">MutableMap</code>.</p></section><section class="chapter"><h3 id="function-types" data-toc="native-objc-interop#function-types">Function types</h3>
<p id="f36b9903">Kotlin function-typed objects (e.g. lambdas) are converted to Swift functions / Objective-C blocks. However there is a difference in how types of parameters and return values are mapped when translating a function and a function type. In the latter case primitive types are mapped to their boxed representation. Kotlin <code class="code ">Unit</code> return value is represented as a corresponding <code class="code ">Unit</code> singleton in Swift/Objective-C. The value of this singleton can be retrieved in the same way as it is for any other Kotlin <code class="code ">object</code> (see singletons in the table above). To sum the things up:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun foo(block: (Int) -&gt; Unit) { ... } </pre>
<p id="74c96d09">would be represented in Swift as</p>
<pre class="code-block" data-lang="swift" data-language="swift">func foo(block: (KotlinInt) -&gt; KotlinUnit) </pre>
<p id="f9ba400e">and can be called like</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">foo { bar($0 as! Int32) return KotlinUnit() } </pre></section><section class="chapter"><h3 id="generics" data-toc="native-objc-interop#generics">Generics</h3>
<p id="af9884f9">Objective-C supports "lightweight generics" defined on classes, with a relatively limited feature set. Swift can import generics defined on classes to help provide additional type information to the compiler.</p>
<p id="c5feba48">Generic feature support for Objective-C and Swift differ from Kotlin, so the translation will inevitably lose some information, but the features supported retain meaningful information.</p>
<section class="chapter"><h4 id="limitations" data-toc="native-objc-interop#limitations">Limitations</h4>
<p id="8cefbf59">Objective-C generics do not support all features of either Kotlin or Swift, so there will be some information lost in the translation.</p>
<p id="641553f4">Generics can only be defined on classes, not on interfaces (protocols in Objective-C and Swift) or functions.</p></section><section class="chapter"><h4 id="nullability" data-toc="native-objc-interop#nullability">Nullability</h4>
<p id="1471a35f">Kotlin and Swift both define nullability as part of the type specification, while Objective-C defines nullability on methods and properties of a type. As such, the following:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class Sample&lt;T&gt;() { fun myVal(): T } </pre>
<p id="b8dbb064">will (logically) look like this:</p>
<pre class="code-block" data-lang="swift" data-language="swift">class Sample&lt;T&gt;() { fun myVal(): T? } </pre>
<p id="c358d999">In order to support a potentially nullable type, the Objective-C header needs to define <code class="code ">myVal</code> with a nullable return value.</p>
<p id="e9326ddc">To mitigate this, when defining your generic classes, if the generic type should <em id="76d65e1e" class="">never</em> be null, provide a non-null type constraint:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class Sample&lt;T : Any&gt;() { fun myVal(): T } </pre>
<p id="145b05f3">That will force the Objective-C header to mark <code class="code ">myVal</code> as non-null.</p></section><section class="chapter"><h4 id="variance" data-toc="native-objc-interop#variance">Variance</h4>
<p id="65d28b6f">Objective-C allows generics to be declared covariant or contravariant. Swift has no support for variance. Generic classes coming from Objective-C can be force-cast as needed.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">data class SomeData(val num: Int = 42) : BaseData() class GenVarOut&lt;out T : Any&gt;(val arg: T) </pre>
<pre class="code-block" data-lang="swift" data-language="swift">let variOut = GenVarOut&lt;SomeData&gt;(arg: sd) let variOutAny : GenVarOut&lt;BaseData&gt; = variOut as! GenVarOut&lt;BaseData&gt; </pre></section><section class="chapter"><h4 id="constraints" data-toc="native-objc-interop#constraints">Constraints</h4>
<p id="6f248c0f">In Kotlin you can provide upper bounds for a generic type. Objective-C also supports this, but that support is unavailable in more complex cases, and is currently not supported in the Kotlin - Objective-C interop. The exception here being a non-null upper bound will make Objective-C methods/properties non-null.</p></section><section class="chapter"><h4 id="to-disable" data-toc="native-objc-interop#to-disable">To disable</h4>
<p id="81704b84">To have the framework header written without generics, add the flag to the compiler config:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">binaries.framework { freeCompilerArgs += "-Xno-objc-generics" } </pre></section></section></section><section class="chapter"><h2 id="casting-between-mapped-types" data-toc="native-objc-interop#casting-between-mapped-types">Casting between mapped types</h2>
<p id="57494b20">When writing Kotlin code, an object may need to be converted from a Kotlin type to the equivalent Swift/Objective-C type (or vice versa). In this case a plain old Kotlin cast can be used, e.g.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val nsArray = listOf(1, 2, 3) as NSArray val string = nsString as String val nsNumber = 42 as NSNumber </pre></section><section class="chapter"><h2 id="subclassing" data-toc="native-objc-interop#subclassing">Subclassing</h2>
<section class="chapter"><h3 id="subclassing-kotlin-classes-and-interfaces-from-swift-objective-c" data-toc="native-objc-interop#subclassing-kotlin-classes-and-interfaces-from-swift-objective-c">Subclassing Kotlin classes and interfaces from Swift/Objective-C</h3>
<p id="e361cbfb">Kotlin classes and interfaces can be subclassed by Swift/Objective-C classes and protocols.</p></section><section class="chapter"><h3 id="subclassing-swift-objective-c-classes-and-protocols-from-kotlin" data-toc="native-objc-interop#subclassing-swift-objective-c-classes-and-protocols-from-kotlin">Subclassing Swift/Objective-C classes and protocols from Kotlin</h3>
<p id="323d02e1">Swift/Objective-C classes and protocols can be subclassed with a Kotlin <code class="code ">final</code> class. Non-<code class="code ">final</code> Kotlin classes inheriting Swift/Objective-C types aren't supported yet, so it is not possible to declare a complex class hierarchy inheriting Swift/Objective-C types.</p>
<p id="fce13831">Normal methods can be overridden using the <code class="code ">override</code> Kotlin keyword. In this case the overriding method must have the same parameter names as the overridden one.</p>
<p id="e6b12b8b">Sometimes it is required to override initializers, e.g. when subclassing <code class="code ">UIViewController</code>. Initializers imported as Kotlin constructors can be overridden by Kotlin constructors marked with the <code class="code ">@OverrideInit</code> annotation:</p>
<pre class="code-block" data-lang="swift" data-language="swift">class ViewController : UIViewController { @OverrideInit constructor(coder: NSCoder) : super(coder) ... } </pre>
<p id="b0141585">The overriding constructor must have the same parameter names and types as the overridden one.</p>
<p id="17d74ef9">To override different methods with clashing Kotlin signatures, you can add a <code class="code ">@Suppress("CONFLICTING_OVERLOADS")</code> annotation to the class.</p>
<p id="9460cfae">By default the Kotlin/Native compiler doesn't allow calling a non-designated Objective-C initializer as a <code class="code ">super(...)</code> constructor. This behaviour can be inconvenient if the designated initializers aren't marked properly in the Objective-C library. Adding a <code class="code ">disableDesignatedInitializerChecks = true</code> to the <code class="code ">.def</code> file for this library would disable these compiler checks.</p></section></section><section class="chapter"><h2 id="c-features" data-toc="native-objc-interop#c-features">C features</h2>
<p id="42c19e77">See <a href="native-c-interop" id="a1fa7091">Interoperability with C</a> for an example case where the library uses some plain C features, such as unsafe pointers, structs, and so on.</p></section><section class="chapter"><h2 id="unsupported" data-toc="native-objc-interop#unsupported">Unsupported</h2>
<p id="584fc96a">Some features of Kotlin programming language are not yet mapped into respective features of Objective-C or Swift. Currently, following features are not properly exposed in generated framework headers:</p>
<ul class="list _ul" id="9b535472">
<li class="list__item" id="15a70846"><p>inline classes (arguments are mapped as either underlying primitive type or <code class="code ">id</code>)</p></li>
<li class="list__item" id="7b07cda"><p>custom classes implementing standard Kotlin collection interfaces (<code class="code ">List</code>, <code class="code ">Map</code>, <code class="code ">Set</code>) and other special classes</p></li>
<li class="list__item" id="44b22bed"><p>Kotlin subclasses of Objective-C classes</p></li>
</ul></section><div class="last-modified"> Last modified: 11 November 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="mapping-strings-from-c">Mapping Strings from C â€“ tutorial</a> <a class="navigation-links__next" href="native-cocoapods">CocoaPods overview</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/native-objc-interop.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/native-objc-interop.html</a>
  </p>
</div>
