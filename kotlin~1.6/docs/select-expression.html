<h1 data-toc="select-expression" id="select-expression.md">Select expression (experimental)</h1>
<p id="370d72dd">Select expression makes it possible to await multiple suspending functions simultaneously and <em id="f1ddd24b" class="">select</em> the first one that becomes available.</p>
<aside data-type="note" class="prompt" data-title="" id="a160bf49"><p id="e62d0a0a">Select expressions are an experimental feature of <code class="code ">kotlinx.coroutines</code>. Their API is expected to evolve in the upcoming updates of the <code class="code ">kotlinx.coroutines</code> library with potentially breaking changes.</p></aside><section class="chapter"><h2 id="selecting-from-channels" data-toc="select-expression#selecting-from-channels">Selecting from channels</h2>
<p id="ae1698f6">Let us have two producers of strings: <code class="code ">fizz</code> and <code class="code ">buzz</code>. The <code class="code ">fizz</code> produces "Fizz" string every 300 ms:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun CoroutineScope.fizz() = produce&lt;String&gt; { while (true) { // sends "Fizz" every 300 ms delay(300) send("Fizz") } } </pre>
<p id="218b7c3c">And the <code class="code ">buzz</code> produces "Buzz!" string every 500 ms:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun CoroutineScope.buzz() = produce&lt;String&gt; { while (true) { // sends "Buzz!" every 500 ms delay(500) send("Buzz!") } } </pre>
<p id="18a62535">Using <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html" id="a262270d" data-external="true" rel="noopener noreferrer">receive</a> suspending function we can receive <em id="7d9c9fde" class="">either</em> from one channel or the other. But <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html" id="cca2c450" data-external="true" rel="noopener noreferrer">select</a> expression allows us to receive from <em id="6bd0f554" class="">both</em> simultaneously using its <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/on-receive.html" id="beaddfe3" data-external="true" rel="noopener noreferrer">onReceive</a> clauses:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">suspend fun selectFizzBuzz(fizz: ReceiveChannel&lt;String&gt;, buzz: ReceiveChannel&lt;String&gt;) { select&lt;Unit&gt; { // &lt;Unit&gt; means that this select expression does not produce any result fizz.onReceive { value -&gt; // this is the first select clause println("fizz -&gt; '$value'") } buzz.onReceive { value -&gt; // this is the second select clause println("buzz -&gt; '$value'") } } } </pre>
<p id="7cd25364">Let us run it all seven times:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.channels.* import kotlinx.coroutines.selects.* fun CoroutineScope.fizz() = produce&lt;String&gt; { while (true) { // sends "Fizz" every 300 ms delay(300) send("Fizz") } } fun CoroutineScope.buzz() = produce&lt;String&gt; { while (true) { // sends "Buzz!" every 500 ms delay(500) send("Buzz!") } } suspend fun selectFizzBuzz(fizz: ReceiveChannel&lt;String&gt;, buzz: ReceiveChannel&lt;String&gt;) { select&lt;Unit&gt; { // &lt;Unit&gt; means that this select expression does not produce any result fizz.onReceive { value -&gt; // this is the first select clause println("fizz -&gt; '$value'") } buzz.onReceive { value -&gt; // this is the second select clause println("buzz -&gt; '$value'") } } } fun main() = runBlocking&lt;Unit&gt; { //sampleStart val fizz = fizz() val buzz = buzz() repeat(7) { selectFizzBuzz(fizz, buzz) } coroutineContext.cancelChildren() // cancel fizz &amp; buzz coroutines //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="4e6bf8a3"><p id="d086424d">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-select-01.kt" id="1142924b" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="a87e6626">The result of this code is:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">fizz -&gt; 'Fizz' buzz -&gt; 'Buzz!' fizz -&gt; 'Fizz' fizz -&gt; 'Fizz' buzz -&gt; 'Buzz!' fizz -&gt; 'Fizz' buzz -&gt; 'Buzz!' </pre></section><section class="chapter"><h2 id="selecting-on-close" data-toc="select-expression#selecting-on-close">Selecting on close</h2>
<p id="a3a22274">The <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/on-receive.html" id="b49f8a3b" data-external="true" rel="noopener noreferrer">onReceive</a> clause in <code class="code ">select</code> fails when the channel is closed causing the corresponding <code class="code ">select</code> to throw an exception. We can use <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/on-receive-catching.html" id="f450fa68" data-external="true" rel="noopener noreferrer">onReceiveCatching</a> clause to perform a specific action when the channel is closed. The following example also shows that <code class="code ">select</code> is an expression that returns the result of its selected clause:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">suspend fun selectAorB(a: ReceiveChannel&lt;String&gt;, b: ReceiveChannel&lt;String&gt;): String = select&lt;String&gt; { a.onReceiveCatching { it -&gt; val value = it.getOrNull() if (value != null) { "a -&gt; '$value'" } else { "Channel 'a' is closed" } } b.onReceiveCatching { it -&gt; val value = it.getOrNull() if (value != null) { "b -&gt; '$value'" } else { "Channel 'b' is closed" } } } </pre>
<p id="d9a583a5">Let's use it with channel <code class="code ">a</code> that produces "Hello" string four times and channel <code class="code ">b</code> that produces "World" four times:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.channels.* import kotlinx.coroutines.selects.* suspend fun selectAorB(a: ReceiveChannel&lt;String&gt;, b: ReceiveChannel&lt;String&gt;): String = select&lt;String&gt; { a.onReceiveCatching { it -&gt; val value = it.getOrNull() if (value != null) { "a -&gt; '$value'" } else { "Channel 'a' is closed" } } b.onReceiveCatching { it -&gt; val value = it.getOrNull() if (value != null) { "b -&gt; '$value'" } else { "Channel 'b' is closed" } } } fun main() = runBlocking&lt;Unit&gt; { //sampleStart val a = produce&lt;String&gt; { repeat(4) { send("Hello $it") } } val b = produce&lt;String&gt; { repeat(4) { send("World $it") } } repeat(8) { // print first eight results println(selectAorB(a, b)) } coroutineContext.cancelChildren() //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="f31ed139"><p id="5a17343e">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-select-02.kt" id="bb00cf88" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="5dd4f46f">The result of this code is quite interesting, so we'll analyze it in more detail:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">a -&gt; 'Hello 0' a -&gt; 'Hello 1' b -&gt; 'World 0' a -&gt; 'Hello 2' a -&gt; 'Hello 3' b -&gt; 'World 1' Channel 'a' is closed Channel 'a' is closed </pre>
<p id="7f47ec6">There are a couple of observations to make out of it.</p>
<p id="1d3329de">First of all, <code class="code ">select</code> is <em id="f2d361d5" class="">biased</em> to the first clause. When several clauses are selectable at the same time, the first one among them gets selected. Here, both channels are constantly producing strings, so <code class="code ">a</code> channel, being the first clause in select, wins. However, because we are using unbuffered channel, the <code class="code ">a</code> gets suspended from time to time on its <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/send.html" id="919ddaa9" data-external="true" rel="noopener noreferrer">send</a> invocation and gives a chance for <code class="code ">b</code> to send, too.</p>
<p id="a81d7ef4">The second observation, is that <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/on-receive-catching.html" id="bc1ce641" data-external="true" rel="noopener noreferrer">onReceiveCatching</a> gets immediately selected when the channel is already closed.</p></section><section class="chapter"><h2 id="selecting-to-send" data-toc="select-expression#selecting-to-send">Selecting to send</h2>
<p id="3920a7d">Select expression has <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/on-send.html" id="7ede35c4" data-external="true" rel="noopener noreferrer">onSend</a> clause that can be used for a great good in combination with a biased nature of selection.</p>
<p id="68b83a3e">Let us write an example of a producer of integers that sends its values to a <code class="code ">side</code> channel when the consumers on its primary channel cannot keep up with it:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun CoroutineScope.produceNumbers(side: SendChannel&lt;Int&gt;) = produce&lt;Int&gt; { for (num in 1..10) { // produce 10 numbers from 1 to 10 delay(100) // every 100 ms select&lt;Unit&gt; { onSend(num) {} // Send to the primary channel side.onSend(num) {} // or to the side channel } } } </pre>
<p id="5918f520">Consumer is going to be quite slow, taking 250 ms to process each number:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.channels.* import kotlinx.coroutines.selects.* fun CoroutineScope.produceNumbers(side: SendChannel&lt;Int&gt;) = produce&lt;Int&gt; { for (num in 1..10) { // produce 10 numbers from 1 to 10 delay(100) // every 100 ms select&lt;Unit&gt; { onSend(num) {} // Send to the primary channel side.onSend(num) {} // or to the side channel } } } fun main() = runBlocking&lt;Unit&gt; { //sampleStart val side = Channel&lt;Int&gt;() // allocate side channel launch { // this is a very fast consumer for the side channel side.consumeEach { println("Side channel has $it") } } produceNumbers(side).consumeEach { println("Consuming $it") delay(250) // let us digest the consumed number properly, do not hurry } println("Done consuming") coroutineContext.cancelChildren() //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="e6435bfc"><p id="557208f2">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-select-03.kt" id="7c586aab" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="50d629b5">So let us see what happens:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">Consuming 1 Side channel has 2 Side channel has 3 Consuming 4 Side channel has 5 Side channel has 6 Consuming 7 Side channel has 8 Side channel has 9 Consuming 10 Done consuming </pre></section><section class="chapter"><h2 id="selecting-deferred-values" data-toc="select-expression#selecting-deferred-values">Selecting deferred values</h2>
<p id="90e21e96">Deferred values can be selected using <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html" id="9b22a827" data-external="true" rel="noopener noreferrer">onAwait</a> clause. Let us start with an async function that returns a deferred string value after a random delay:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun CoroutineScope.asyncString(time: Int) = async { delay(time.toLong()) "Waited for $time ms" } </pre>
<p id="6051d403">Let us start a dozen of them with a random delay.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun CoroutineScope.asyncStringsList(): List&lt;Deferred&lt;String&gt;&gt; { val random = Random(3) return List(12) { asyncString(random.nextInt(1000)) } } </pre>
<p id="6c52421e">Now the main function awaits for the first of them to complete and counts the number of deferred values that are still active. Note that we've used here the fact that <code class="code ">select</code> expression is a Kotlin DSL, so we can provide clauses for it using an arbitrary code. In this case we iterate over a list of deferred values to provide <code class="code ">onAwait</code> clause for each deferred value.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.selects.* import java.util.* fun CoroutineScope.asyncString(time: Int) = async { delay(time.toLong()) "Waited for $time ms" } fun CoroutineScope.asyncStringsList(): List&lt;Deferred&lt;String&gt;&gt; { val random = Random(3) return List(12) { asyncString(random.nextInt(1000)) } } fun main() = runBlocking&lt;Unit&gt; { //sampleStart val list = asyncStringsList() val result = select&lt;String&gt; { list.withIndex().forEach { (index, deferred) -&gt; deferred.onAwait { answer -&gt; "Deferred $index produced answer '$answer'" } } } println(result) val countActive = list.count { it.isActive } println("$countActive coroutines are still active") //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="f0ed8bad"><p id="f1c41ae">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-select-04.kt" id="93ed4100" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="e7cfe376">The output is:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">Deferred 4 produced answer 'Waited for 128 ms' 11 coroutines are still active </pre></section><section class="chapter"><h2 id="switch-over-a-channel-of-deferred-values" data-toc="select-expression#switch-over-a-channel-of-deferred-values">Switch over a channel of deferred values</h2>
<p id="a4a0c6">Let us write a channel producer function that consumes a channel of deferred string values, waits for each received deferred value, but only until the next deferred value comes over or the channel is closed. This example puts together <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/on-receive-catching.html" id="678fb97c" data-external="true" rel="noopener noreferrer">onReceiveCatching</a> and <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html" id="fe8faec8" data-external="true" rel="noopener noreferrer">onAwait</a> clauses in the same <code class="code ">select</code>:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun CoroutineScope.switchMapDeferreds(input: ReceiveChannel&lt;Deferred&lt;String&gt;&gt;) = produce&lt;String&gt; { var current = input.receive() // start with first received deferred value while (isActive) { // loop while not cancelled/closed val next = select&lt;Deferred&lt;String&gt;?&gt; { // return next deferred value from this select or null input.onReceiveCatching { update -&gt; update.getOrNull() } current.onAwait { value -&gt; send(value) // send value that current deferred has produced input.receiveCatching().getOrNull() // and use the next deferred from the input channel } } if (next == null) { println("Channel was closed") break // out of loop } else { current = next } } } </pre>
<p id="dc3ca9ce">To test it, we'll use a simple async function that resolves to a specified string after a specified time:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun CoroutineScope.asyncString(str: String, time: Long) = async { delay(time) str } </pre>
<p id="712f4006">The main function just launches a coroutine to print results of <code class="code ">switchMapDeferreds</code> and sends some test data to it:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.channels.* import kotlinx.coroutines.selects.* fun CoroutineScope.switchMapDeferreds(input: ReceiveChannel&lt;Deferred&lt;String&gt;&gt;) = produce&lt;String&gt; { var current = input.receive() // start with first received deferred value while (isActive) { // loop while not cancelled/closed val next = select&lt;Deferred&lt;String&gt;?&gt; { // return next deferred value from this select or null input.onReceiveCatching { update -&gt; update.getOrNull() } current.onAwait { value -&gt; send(value) // send value that current deferred has produced input.receiveCatching().getOrNull() // and use the next deferred from the input channel } } if (next == null) { println("Channel was closed") break // out of loop } else { current = next } } } fun CoroutineScope.asyncString(str: String, time: Long) = async { delay(time) str } fun main() = runBlocking&lt;Unit&gt; { //sampleStart val chan = Channel&lt;Deferred&lt;String&gt;&gt;() // the channel for test launch { // launch printing coroutine for (s in switchMapDeferreds(chan)) println(s) // print each received string } chan.send(asyncString("BEGIN", 100)) delay(200) // enough time for "BEGIN" to be produced chan.send(asyncString("Slow", 500)) delay(100) // not enough time to produce slow chan.send(asyncString("Replace", 100)) delay(500) // give it time before the last one chan.send(asyncString("END", 500)) delay(1000) // give it time to process chan.close() // close the channel ... delay(500) // and wait some time to let it finish //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="c5f37b3"><p id="a54a2aea">You can get the full code <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-select-05.kt" id="fa2957bd" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="dcd78851">The result of this code:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">BEGIN Replace END Channel was closed </pre></section><div class="last-modified"> Last modified: 07 September 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="shared-mutable-state-and-concurrency">Shared mutable state and concurrency</a> <a class="navigation-links__next" href="debug-coroutines-with-idea">Debug coroutines using IntelliJ IDEA – tutorial</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/select-expression.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/select-expression.html</a>
  </p>
</div>
