<h1 data-toc="collection-aggregate" id="collection-aggregate.md">Aggregate operations</h1>
<p id="594b5bed">Kotlin collections contain functions for commonly used <em id="c63ee281" class="">aggregate operations</em> – operations that return a single value based on the collection content. Most of them are well known and work the same way as they do in other languages:</p>
<ul class="list _ul" id="8ca9773d">
<li class="list__item" id="aa23c91f"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/min-or-null" id="c86187b9" data-external="true" rel="noopener noreferrer"><code class="code ">minOrNull()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/max-or-null" id="ea62777b" data-external="true" rel="noopener noreferrer"><code class="code ">maxOrNull()</code></a> return the smallest and the largest element respectively. On empty collections, they return <code class="code ">null</code>.</p></li>
<li class="list__item" id="38d9c1b"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/average" id="7a7990b1" data-external="true" rel="noopener noreferrer"><code class="code ">average()</code></a> returns the average value of elements in the collection of numbers.</p></li>
<li class="list__item" id="1acca031"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/sum" id="25486d4a" data-external="true" rel="noopener noreferrer"><code class="code ">sum()</code></a> returns the sum of elements in the collection of numbers.</p></li>
<li class="list__item" id="4a992a85"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/count" id="ad2a75ba" data-external="true" rel="noopener noreferrer"><code class="code ">count()</code></a> returns the number of elements in a collection.</p></li>
</ul>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin"> fun main() { val numbers = listOf(6, 42, 10, 4) println("Count: ${numbers.count()}") println("Max: ${numbers.maxOrNull()}") println("Min: ${numbers.minOrNull()}") println("Average: ${numbers.average()}") println("Sum: ${numbers.sum()}") } </pre>
<p id="64b11467">There are also functions for retrieving the smallest and the largest elements by certain selector function or custom <a href="../api/latest/jvm/stdlib/kotlin/-comparator/index" id="5e700998" data-external="true" rel="noopener noreferrer"><code class="code ">Comparator</code></a>:</p>
<ul class="list _ul" id="dc6c0d26">
<li class="list__item" id="c69f4de4"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/max-by-or-null" id="af219d64" data-external="true" rel="noopener noreferrer"><code class="code ">maxByOrNull()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/min-by-or-null" id="f713360b" data-external="true" rel="noopener noreferrer"><code class="code ">minByOrNull()</code></a> take a selector function and return the element for which it returns the largest or the smallest value.</p></li>
<li class="list__item" id="f02b3008"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/max-with-or-null" id="f9b55190" data-external="true" rel="noopener noreferrer"><code class="code ">maxWithOrNull()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/min-with-or-null" id="1f8f1681" data-external="true" rel="noopener noreferrer"><code class="code ">minWithOrNull()</code></a> take a <code class="code ">Comparator</code> object and return the largest or smallest element according to that <code class="code ">Comparator</code>.</p></li>
<li class="list__item" id="6836577e"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/max-of-or-null" id="5a06dfb7" data-external="true" rel="noopener noreferrer"><code class="code ">maxOfOrNull()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/min-of-or-null" id="1604b847" data-external="true" rel="noopener noreferrer"><code class="code ">minOfOrNull()</code></a> take a selector function and return the largest or the smallest return value of the selector itself.</p></li>
<li class="list__item" id="93a2afe2"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/max-of-with-or-null" id="19d72c61" data-external="true" rel="noopener noreferrer"><code class="code ">maxOfWithOrNull()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/min-of-with-or-null" id="9afd3e3" data-external="true" rel="noopener noreferrer"><code class="code ">minOfWithOrNull()</code></a> take a <code class="code ">Comparator</code> object and return the largest or smallest selector return value according to that <code class="code ">Comparator</code>.</p></li>
</ul>
<p id="a54970b8">These functions return <code class="code ">null</code> on empty collections. There are also alternatives – <a href="../api/latest/jvm/stdlib/kotlin.collections/max-of" id="d04f38a8" data-external="true" rel="noopener noreferrer"><code class="code ">maxOf</code></a>, <a href="../api/latest/jvm/stdlib/kotlin.collections/min-of" id="b7758163" data-external="true" rel="noopener noreferrer"><code class="code ">minOf</code></a>, <a href="../api/latest/jvm/stdlib/kotlin.collections/max-of-with" id="6d8435bb" data-external="true" rel="noopener noreferrer"><code class="code ">maxOfWith</code></a>, and <a href="../api/latest/jvm/stdlib/kotlin.collections/min-of-with" id="74a1f8b" data-external="true" rel="noopener noreferrer"><code class="code ">minOfWith</code></a> – which do the same as their counterparts but throw a <code class="code ">NoSuchElementException</code> on empty collections.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin"> fun main() { //sampleStart val numbers = listOf(5, 42, 10, 4) val min3Remainder = numbers.minByOrNull { it % 3 } println(min3Remainder) val strings = listOf("one", "two", "three", "four") val longestString = strings.maxWithOrNull(compareBy { it.length }) println(longestString) //sampleEnd } </pre>
<p id="5d460630">Besides regular <code class="code ">sum()</code>, there is an advanced summation function <a href="../api/latest/jvm/stdlib/kotlin.collections/sum-of" id="badb571c" data-external="true" rel="noopener noreferrer"><code class="code ">sumOf()</code></a> that takes a selector function and returns the sum of its application to all collection elements. Selector can return different numeric types: <code class="code ">Int</code>, <code class="code ">Long</code>, <code class="code ">Double</code>, <code class="code ">UInt</code>, and <code class="code ">ULong</code> (also <code class="code ">BigInteger</code> and <code class="code ">BigDecimal</code> on the JVM).</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4" data-language="kotlin"> fun main() { //sampleStart val numbers = listOf(5, 42, 10, 4) println(numbers.sumOf { it * 2 }) println(numbers.sumOf { it.toDouble() / 2 }) //sampleEnd } </pre>
<section class="chapter"><h2 id="fold-and-reduce" data-toc="collection-aggregate#fold-and-reduce">Fold and reduce</h2>
<p id="49ccb541">For more specific cases, there are the functions <a href="../api/latest/jvm/stdlib/kotlin.collections/reduce" id="c6383ca6" data-external="true" rel="noopener noreferrer"><code class="code ">reduce()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/fold" id="63284321" data-external="true" rel="noopener noreferrer"><code class="code ">fold()</code></a> that apply the provided operation to the collection elements sequentially and return the accumulated result. The operation takes two arguments: the previously accumulated value and the collection element.</p>
<p id="96126147">The difference between the two functions is that <code class="code ">fold()</code> takes an initial value and uses it as the accumulated value on the first step, whereas the first step of <code class="code ">reduce()</code> uses the first and the second elements as operation arguments on the first step.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val numbers = listOf(5, 2, 10, 4) val simpleSum = numbers.reduce { sum, element -&gt; sum + element } println(simpleSum) val sumDoubled = numbers.fold(0) { sum, element -&gt; sum + element * 2 } println(sumDoubled) //incorrect: the first element isn't doubled in the result //val sumDoubledReduce = numbers.reduce { sum, element -&gt; sum + element * 2 } //println(sumDoubledReduce) //sampleEnd } </pre>
<p id="f1c92734">The example above shows the difference: <code class="code ">fold()</code> is used for calculating the sum of doubled elements. If you pass the same function to <code class="code ">reduce()</code>, it will return another result because it uses the list's first and second elements as arguments on the first step, so the first element won't be doubled.</p>
<p id="2b3b152">To apply a function to elements in the reverse order, use functions <a href="../api/latest/jvm/stdlib/kotlin.collections/reduce-right" id="f89082dc" data-external="true" rel="noopener noreferrer"><code class="code ">reduceRight()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/fold-right" id="69c852d8" data-external="true" rel="noopener noreferrer"><code class="code ">foldRight()</code></a>. They work in a way similar to <code class="code ">fold()</code> and <code class="code ">reduce()</code> but start from the last element and then continue to previous. Note that when folding or reducing right, the operation arguments change their order: first goes the element, and then the accumulated value.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin"> fun main() { //sampleStart val numbers = listOf(5, 2, 10, 4) val sumDoubledRight = numbers.foldRight(0) { element, sum -&gt; sum + element * 2 } println(sumDoubledRight) //sampleEnd } </pre>
<p id="ecef6537">You can also apply operations that take element indices as parameters. For this purpose, use functions <a href="../api/latest/jvm/stdlib/kotlin.collections/reduce-indexed" id="511ddd4d" data-external="true" rel="noopener noreferrer"><code class="code ">reduceIndexed()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/fold-indexed" id="8390670c" data-external="true" rel="noopener noreferrer"><code class="code ">foldIndexed()</code></a> passing element index as the first argument of the operation.</p>
<p id="2e573b3">Finally, there are functions that apply such operations to collection elements from right to left - <a href="../api/latest/jvm/stdlib/kotlin.collections/reduce-right-indexed" id="1038c450" data-external="true" rel="noopener noreferrer"><code class="code ">reduceRightIndexed()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/fold-right-indexed" id="6a83c9cb" data-external="true" rel="noopener noreferrer"><code class="code ">foldRightIndexed()</code></a>.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin"> fun main() { //sampleStart val numbers = listOf(5, 2, 10, 4) val sumEven = numbers.foldIndexed(0) { idx, sum, element -&gt; if (idx % 2 == 0) sum + element else sum } println(sumEven) val sumEvenRight = numbers.foldRightIndexed(0) { idx, element, sum -&gt; if (idx % 2 == 0) sum + element else sum } println(sumEvenRight) //sampleEnd } </pre>
<p id="7870f88">All reduce operations throw an exception on empty collections. To receive <code class="code ">null</code> instead, use their <code class="code ">*OrNull()</code> counterparts:</p>
<ul class="list _ul" id="5a1728e0">
<li class="list__item" id="87ad1cbd"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/reduce-or-null" id="d199cbc5" data-external="true" rel="noopener noreferrer"><code class="code ">reduceOrNull()</code></a></p></li>
<li class="list__item" id="c10d12bb"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/reduce-right-or-null" id="6f95bb5a" data-external="true" rel="noopener noreferrer"><code class="code ">reduceRightOrNull()</code></a></p></li>
<li class="list__item" id="e4dbcd10"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/reduce-indexed-or-null" id="6b7f7171" data-external="true" rel="noopener noreferrer"><code class="code ">reduceIndexedOrNull()</code></a></p></li>
<li class="list__item" id="50774c57"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/reduce-right-indexed-or-null" id="b258b53d" data-external="true" rel="noopener noreferrer"><code class="code ">reduceRightIndexedOrNull()</code></a></p></li>
</ul>
<p id="ffc9393a">For cases where you want to save intermediate accumulator values, there are functions <a href="../api/latest/jvm/stdlib/kotlin.collections/running-fold" id="1685ad3a" data-external="true" rel="noopener noreferrer"><code class="code ">runningFold()</code></a> (or its synonym <a href="../api/latest/jvm/stdlib/kotlin.collections/scan" id="72a56d87" data-external="true" rel="noopener noreferrer"><code class="code ">scan()</code></a>) and <a href="../api/latest/jvm/stdlib/kotlin.collections/running-reduce" id="d2048389" data-external="true" rel="noopener noreferrer"><code class="code ">runningReduce()</code></a>.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4" data-language="kotlin"> fun main() { //sampleStart val numbers = listOf(0, 1, 2, 3, 4, 5) val runningReduceSum = numbers.runningReduce { sum, item -&gt; sum + item } val runningFoldSum = numbers.runningFold(10) { sum, item -&gt; sum + item } //sampleEnd val transform = { index: Int, element: Int -&gt; "N = ${index + 1}: $element" } println(runningReduceSum.mapIndexed(transform).joinToString("\n", "Sum of first N elements with runningReduce:\n")) println(runningFoldSum.mapIndexed(transform).joinToString("\n", "Sum of first N elements with runningFold:\n")) } </pre>
<p id="f3ea4b86">If you need an index in the operation parameter, use <a href="../api/latest/jvm/stdlib/kotlin.collections/running-fold-indexed" id="fce09082" data-external="true" rel="noopener noreferrer"><code class="code ">runningFoldIndexed()</code></a> or <a href="../api/latest/jvm/stdlib/kotlin.collections/running-reduce-indexed" id="372e80c4" data-external="true" rel="noopener noreferrer"><code class="code ">runningReduceIndexed()</code></a>.</p></section><div class="last-modified"> Last modified: 07 December 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="collection-ordering">Ordering</a> <a class="navigation-links__next" href="collection-write">Collection write operations</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/collection-aggregate.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/collection-aggregate.html</a>
  </p>
</div>
