<h1 data-toc="js-ir-compiler" id="js-ir-compiler.md">Kotlin/JS IR compiler</h1>
<aside data-type="warning" class="prompt" data-title="" id="b9a2bab7"><p id="4371ca3c">The Kotlin/JS IR compiler is in <a href="components-stability" id="daf45021">Beta</a>. It is almost stable, but migration steps may be required in the future. We'll do our best to minimize any changes you have to make.</p></aside><p id="f192d882">The Kotlin/JS IR compiler backend is the main focus of innovation around Kotlin/JS, and paves the way forward for the technology.</p>
<p id="2b6fb0d1">Rather than directly generating JavaScript code from Kotlin source code, the Kotlin/JS IR compiler backend leverages a new approach. Kotlin source code is first transformed into a <a href="whatsnew14#unified-backends-and-extensibility" id="97963ecf">Kotlin intermediate representation (IR)</a>, which is subsequently compiled into JavaScript. For Kotlin/JS, this enables aggressive optimizations, and allows improvements on pain points that were present in the previous compiler, such as generated code size (through dead code elimination), and JavaScript and TypeScript ecosystem interoperability, to name some examples.</p>
<p id="1dc6e52">The IR compiler backend is available starting with Kotlin 1.4.0 through the Kotlin/JS Gradle plugin. To enable it in your project, pass a compiler type to the <code class="code ">js</code> function in your Gradle build script:</p>
<pre class="code-block" data-lang="groovy" data-language="groovy">kotlin { js(IR) { // or: LEGACY, BOTH // ... binaries.executable() // not applicable to BOTH, see details below } } </pre>
<ul class="list _ul" id="7fbcdc23">
<li class="list__item" id="8bea2e40"><p><code class="code ">IR</code> uses the new IR compiler backend for Kotlin/JS.</p></li>
<li class="list__item" id="7761093e"><p><code class="code ">LEGACY</code> uses the default compiler backend.</p></li>
<li class="list__item" id="24c91aee"><p><code class="code ">BOTH</code> compiles your project with the new IR compiler as well as the default compiler backend. Use this mode for <a href="#authoring-libraries-for-the-ir-compiler-with-backwards-compatibility" id="7a44e257">authoring libraries compatible with both backends</a>.</p></li>
</ul>
<p id="22fab454">The compiler type can also be set in the <code class="code ">gradle.properties</code> file, with the key <code class="code ">kotlin.js.compiler=ir</code>. This behaviour is overwritten by any settings in the <code class="code ">build.gradle(.kts)</code>, however.</p>
<section class="chapter"><h2 id="ignoring-compilation-errors" data-toc="js-ir-compiler#ignoring-compilation-errors">Ignoring compilation errors</h2>
<aside data-type="warning" class="prompt" data-title="" id="db44f7a4"><p id="1786966c"><em id="f3fbdef" class="">Ignore compilation errors</em> mode is <a href="components-stability" id="a1e39b55">Experimental</a>. It may be dropped or changed at any time. Opt-in is required (see the details below), and you should use it only for evaluation purposes. We would appreciate your feedback on it in <a href="https://youtrack.jetbrains.com/issues/KT" id="7e85c4f8" data-external="true" rel="noopener noreferrer">YouTrack</a>.</p></aside><p id="ccef9bba">Kotlin/JS IR compiler provides a new compilation mode unavailable in the default backend – <em id="55eb4614" class="">ignoring compilation errors</em>. In this mode, you can try out your application even while its code contains errors. For example, when you’re doing a complex refactoring or working on a part of the system that is completely unrelated to a compilation error in another part.</p>
<p id="3331854d">With this new compiler mode, the compiler ignores all broken code. Thus, you can run the application and try its parts that don't use the broken code. If you try to run the code that was broken during compilation, you'll get a runtime exception.</p>
<p id="b0065aae">Choose between two tolerance policies for ignoring compilation errors in your code:</p>
<ul class="list _ul" id="ece62984">
<li class="list__item" id="c5eb8e87"><p><code class="code ">SEMANTIC</code>. The compiler will accept code that is syntactically correct but doesn't make sense semantically. For example, assigning a number to a string variable (type mismatch).</p></li>
<li class="list__item" id="5b62ef02"><p><code class="code ">SYNTAX</code>. The compiler will accept any code, even if it contains syntax errors. Regardless of what you write, the compiler will still try to generate a runnable executable.</p></li>
</ul>
<p id="97aa8275">As an experimental feature, ignoring compilation errors requires an opt-in. To enable this mode, add the <code class="code ">-Xerror-tolerance-policy={SEMANTIC|SYNTAX}</code> compiler option:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">kotlin { js(IR) { compilations.all { compileKotlinTask.kotlinOptions.freeCompilerArgs += listOf("-Xerror-tolerance-policy=SYNTAX") } } } </pre></section><section class="chapter"><h2 id="lazy-initialization-of-top-level-properties" data-toc="js-ir-compiler#lazy-initialization-of-top-level-properties">Lazy initialization of top-level properties</h2>
<aside data-type="warning" class="prompt" data-title="" id="831ffa27"><p id="118c04bc">Lazy initialization of top-level properties is <a href="components-stability" id="2a137383">Experimental</a>. It may be dropped or changed at any time. Opt-in is required (see the details below), and you should use it only for evaluation purposes. We would appreciate your feedback on it in <a href="https://youtrack.jetbrains.com/issue/KT-44320" id="693cbd24" data-external="true" rel="noopener noreferrer">YouTrack</a>.</p></aside><p id="c6e99a6a">For better application startup performance, the Kotlin/JS IR compiler offers an option to initialize top-level properties lazily. This way, the application loads without initializing all the top-level properties used in its code. It initializes only the ones needed at startup; other properties receive their values later when the code that uses them actually runs.</p>
<p id="2a5479b0">As an experimental feature, lazy initialization of top-level properties requires an opt-in. To use the lazy initialization of top-level properties, add the <code class="code ">-Xir-property-lazy-initialization</code> option when compiling the code with the JS IR compiler:</p>
<div class="tabs" id="367c1177" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="53942d39" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code-block" data-lang="kotlin" data-title="Kotlin" data-language="kotlin">tasks.withType&lt;Kotlin2JsCompile&gt; { kotlinOptions { freeCompilerArgs += "-Xir-property-lazy-initialization" } } </pre></div>
<div class="tabs__content" data-gtm="tab" id="7927871e" data-sync-tabs="groovy" data-title="Groovy"><pre class="code-block" data-lang="groovy" data-title="Groovy" data-language="groovy">tasks.withType(Kotlin2JsCompile) { kotlinOptions { freeCompilerArgs += "-Xir-property-lazy-initialization" } } </pre></div>
</div></section><section class="chapter"><h2 id="preview-generation-of-typescript-declaration-files-d-ts" data-toc="js-ir-compiler#preview-generation-of-typescript-declaration-files-d-ts">Preview: generation of TypeScript declaration files (d.ts)</h2>
<aside data-type="warning" class="prompt" data-title="" id="5ba5f93b"><p id="bc56576">The generation of TypeScript declaration files (<code class="code ">d.ts</code>) is <a href="components-stability" id="54dcbd98">Experimental</a>. It may be dropped or changed at any time. Opt-in is required (see the details below), and you should use it only for evaluation purposes. We would appreciate your feedback on it in <a href="https://youtrack.jetbrains.com/issues?q=%23%7BKJS:%20d.ts%20generation%7D" id="5d7e0078" data-external="true" rel="noopener noreferrer">YouTrack</a>.</p></aside><p id="a8e42ae8">The Kotlin/JS IR compiler is capable of generating TypeScript definitions from your Kotlin code. These definitions can be used by JavaScript tools and IDEs when working on hybrid apps to provide autocompletion, support static analyzers, and make it easier to include Kotlin code in JavaScript and TypeScript projects.</p>
<p id="b33d00bb">Top-level declarations marked with <a href="js-to-kotlin-interop#jsexport-annotation" id="5f85507"><code class="code ">@JsExport</code></a> in a project that produces executable files (<code class="code ">binaries.executable()</code>) will get a <code class="code ">.d.ts</code> file generated, which contains the TypeScript definitions for the exported Kotlin declarations. These declarations can be found in <code class="code ">build/js/packages/&lt;package_name&gt;/kotlin</code> alongside the corresponding un-webpacked JavaScript code.</p></section><section class="chapter"><h2 id="current-limitations-of-the-ir-compiler" data-toc="js-ir-compiler#current-limitations-of-the-ir-compiler">Current limitations of the IR compiler</h2>
<p id="6ff3349f">A major change with the new IR compiler backend is the <b id="9bbb934f" class="">absence of binary compatibility</b> with the default backend. A lack of such compatibility between the two backends for Kotlin/JS means that a library created with the new IR compiler backend can’t be used from the default backend, and vice versa.</p>
<p id="2e2e3516">If you want to use the IR compiler backend for your project, you need to <b id="7881f13" class="">update all Kotlin dependencies to versions that support this new backend</b>. Libraries published by JetBrains for Kotlin 1.4+ targeting Kotlin/JS already contain all artifacts required for usage with the new IR compiler backend.</p>
<p id="f91dabfa"><b id="5d43fec0" class="">If you are a library author</b> looking to provide compatibility with the current compiler backend as well as the new IR compiler backend, additionally check out the <a href="#authoring-libraries-for-the-ir-compiler-with-backwards-compatibility" id="76b06aad">section about authoring libraries for the IR compiler</a> section.</p>
<p id="411d1ced">The IR compiler backend also has some discrepancies in comparison to the default backend. When trying out the new backend, it's good to be mindful of these possible pitfalls.</p>
<ul class="list _ul" id="3148c6f9">
<li class="list__item" id="d58bf3bd"><p>Some <b id="ee02345f" class="">libraries that rely on specific characteristics</b> of the default backend, such as <code class="code ">kotlin-wrappers</code>, can display some problems. You can follow the investigation and progress <a href="https://youtrack.jetbrains.com/issue/KT-40525" id="7ff69e5a" data-external="true" rel="noopener noreferrer">on YouTrack</a>.</p></li>
<li class="list__item" id="b6faa7"><p>The IR backend <b id="bd65ceeb" class="">does not make Kotlin declarations available to JavaScript</b> by default at all. To make Kotlin declarations visible to JavaScript, they <b id="35b75b88" class="">must be</b> annotated with <a href="js-to-kotlin-interop#jsexport-annotation" id="bff528f4"><code class="code ">@JsExport</code></a>.</p></li>
</ul></section><section class="chapter"><h2 id="migrating-existing-projects-to-the-ir-compiler" data-toc="js-ir-compiler#migrating-existing-projects-to-the-ir-compiler">Migrating existing projects to the IR compiler</h2>
<p id="586aad26">Due to significant differences between the two Kotlin/JS compilers, making your Kotlin/JS code work with the IR compiler may require some adjustments. Learn how to migrate existing Kotlin/JS projects to the IR compiler in the <a href="js-ir-migration" id="802d45ae">Kotlin/JS IR compiler migration guide</a>.</p></section><section class="chapter"><h2 id="authoring-libraries-for-the-ir-compiler-with-backwards-compatibility" data-toc="js-ir-compiler#authoring-libraries-for-the-ir-compiler-with-backwards-compatibility">Authoring libraries for the IR compiler with backwards compatibility</h2>
<p id="f27f709f">If you're a library maintainer who is looking to provide compatibility with the default backend as well as the new IR compiler backend, a setting for the compiler selection is available that allows you to create artifacts for both backends, allowing you to keep compatibility for your existing users while providing support for the next generation of Kotlin compiler. This so-called <code class="code ">both</code>-mode can be turned on using the <code class="code ">kotlin.js.compiler=both</code> setting in your <code class="code ">gradle.properties</code> file, or can be set as one of the project-specific options inside your <code class="code ">js</code> block inside the <code class="code ">build.gradle(.kts)</code> file:</p>
<pre class="code-block" data-lang="groovy" data-language="groovy">kotlin { js(BOTH) { // ... } } </pre>
<p id="60f544b7">When in <code class="code ">both</code> mode, the IR compiler backend and default compiler backend are both used when building a library from your sources (hence the name). This means that both <code class="code ">klib</code> files with Kotlin IR as well as <code class="code ">jar</code> files for the default compiler will be generated. When published under the same Maven coordinate, Gradle will automatically choose the right artifact depending on the use case – <code class="code ">js</code> for the old compiler, <code class="code ">klib</code> for the new one. This enables you to compile and publish your library for projects that are using either of the two compiler backends.</p></section><div class="last-modified"> Last modified: 10 January 2022</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="javascript-dce">Kotlin/JS dead code elimination</a> <a class="navigation-links__next" href="js-ir-migration">Migrating Kotlin/JS projects to the IR compiler</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/js-ir-compiler.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/js-ir-compiler.html</a>
  </p>
</div>
