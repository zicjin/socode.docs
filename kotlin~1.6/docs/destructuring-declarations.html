<h1 data-toc="destructuring-declarations" id="destructuring-declarations.md">Destructuring declarations</h1>
<p id="5ecdb5d">Sometimes it is convenient to <em id="1eecc8f" class="">destructure</em> an object into a number of variables, for example:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val (name, age) = person </pre>
<p id="368d3c5b">This syntax is called a <em id="de8b2020" class="">destructuring declaration</em>. A destructuring declaration creates multiple variables at once. You have declared two new variables: <code class="code ">name</code> and <code class="code ">age</code>, and can use them independently:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">println(name) println(age) </pre>
<p id="e93c4bd3">A destructuring declaration is compiled down to the following code:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val name = person.component1() val age = person.component2() </pre>
<p id="77ac5f44">The <code class="code ">component1()</code> and <code class="code ">component2()</code> functions are another example of the <em id="f10dc502" class="">principle of conventions</em> widely used in Kotlin (see operators like <code class="code ">+</code> and <code class="code ">*</code>, <code class="code ">for</code>-loops as an example). Anything can be on the right-hand side of a destructuring declaration, as long as the required number of component functions can be called on it. And, of course, there can be <code class="code ">component3()</code> and <code class="code ">component4()</code> and so on.</p>
<aside data-type="note" class="prompt" data-title="" id="b8b09ce3"><p id="617c92d4">The <code class="code ">componentN()</code> functions need to be marked with the <code class="code ">operator</code> keyword to allow using them in a destructuring declaration.</p></aside><p id="ed40aa04">Destructuring declarations also work in <code class="code ">for</code>-loops:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">for ((a, b) in collection) { ... } </pre>
<p id="2a69408a">Variables <code class="code ">a</code> and <code class="code ">b</code> get the values returned by <code class="code ">component1()</code> and <code class="code ">component2()</code> called on elements of the collection.</p>
<section class="chapter"><h2 id="example-returning-two-values-from-a-function" data-toc="destructuring-declarations#example-returning-two-values-from-a-function">Example: returning two values from a function</h2>
<p id="72314326">Assume that you need to return two things from a function - for example, a result object and a status of some sort. A compact way of doing this in Kotlin is to declare a <a href="data-classes" id="a43326a6">data class</a> and return its instance:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">data class Result(val result: Int, val status: Status) fun function(...): Result { // computations return Result(result, status) } // Now, to use this function: val (result, status) = function(...) </pre>
<p id="8e31edba">Since data classes automatically declare <code class="code ">componentN()</code> functions, destructuring declarations work here.</p>
<aside data-type="note" class="prompt" data-title="" id="1e18b812"><p id="85617665">You could also use the standard class <code class="code ">Pair</code> and have <code class="code ">function()</code> return <code class="code ">Pair&lt;Int, Status&gt;</code>, but it's often better to have your data named properly.</p></aside></section><section class="chapter"><h2 id="example-destructuring-declarations-and-maps" data-toc="destructuring-declarations#example-destructuring-declarations-and-maps">Example: destructuring declarations and maps</h2>
<p id="52b32621">Probably the nicest way to traverse a map is this:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">for ((key, value) in map) { // do something with the key and the value } </pre>
<p id="935e2af8">To make this work, you should</p>
<ul class="list _ul" id="8620275b">
<li class="list__item" id="4699bd04"><p>Present the map as a sequence of values by providing an <code class="code ">iterator()</code> function.</p></li>
<li class="list__item" id="d970cd08"><p>Present each of the elements as a pair by providing functions <code class="code ">component1()</code> and <code class="code ">component2()</code>.</p></li>
</ul>
<p id="77e9f240">And indeed, the standard library provides such extensions:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">operator fun &lt;K, V&gt; Map&lt;K, V&gt;.iterator(): Iterator&lt;Map.Entry&lt;K, V&gt;&gt; = entrySet().iterator() operator fun &lt;K, V&gt; Map.Entry&lt;K, V&gt;.component1() = getKey() operator fun &lt;K, V&gt; Map.Entry&lt;K, V&gt;.component2() = getValue() </pre>
<p id="995b1e84">So you can freely use destructuring declarations in <code class="code ">for</code>-loops with maps (as well as collections of data class instances or similar).</p></section><section class="chapter"><h2 id="underscore-for-unused-variables" data-toc="destructuring-declarations#underscore-for-unused-variables">Underscore for unused variables</h2>
<p id="d61872c1">If you don't need a variable in the destructuring declaration, you can place an underscore instead of its name:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val (_, status) = getResult() </pre>
<p id="f7fc0bd7">The <code class="code ">componentN()</code> operator functions are not called for the components that are skipped in this way.</p></section><section class="chapter"><h2 id="destructuring-in-lambdas" data-toc="destructuring-declarations#destructuring-in-lambdas">Destructuring in lambdas</h2>
<p id="43251a9b">You can use the destructuring declarations syntax for lambda parameters. If a lambda has a parameter of the <code class="code ">Pair</code> type (or <code class="code ">Map.Entry</code>, or any other type that has the appropriate <code class="code ">componentN</code> functions), you can introduce several new parameters instead of one by putting them in parentheses:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">map.mapValues { entry -&gt; "${entry.value}!" } map.mapValues { (key, value) -&gt; "$value!" } </pre>
<p id="1a35ff9e">Note the difference between declaring two parameters and declaring a destructuring pair instead of a parameter:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">{ a -&gt; ... } // one parameter { a, b -&gt; ... } // two parameters { (a, b) -&gt; ... } // a destructured pair { (a, b), c -&gt; ... } // a destructured pair and another parameter </pre>
<p id="b4f185a0">If a component of the destructured parameter is unused, you can replace it with the underscore to avoid inventing its name:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">map.mapValues { (_, value) -&gt; "$value!" } </pre>
<p id="e6fd3984">You can specify the type for the whole destructured parameter or for a specific component separately:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">map.mapValues { (_, value): Map.Entry&lt;Int, String&gt; -&gt; "$value!" } map.mapValues { (_, value: String) -&gt; "$value!" } </pre></section><div class="last-modified"> Last modified: 11 February 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="annotations">Annotations</a> <a class="navigation-links__next" href="reflection">Reflection</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/destructuring-declarations.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/destructuring-declarations.html</a>
  </p>
</div>
