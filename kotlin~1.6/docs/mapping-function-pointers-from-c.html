<h1 data-toc="mapping-function-pointers-from-c" id="mapping-function-pointers-from-c.md">Mapping function pointers from C – tutorial</h1>
<p id="4315ec15">This is the third post in the series. The very first tutorial is <a href="mapping-primitive-data-types-from-c" id="5134c898">Mapping primitive data types from C</a>. There are also <a href="mapping-struct-union-types-from-c" id="792c403b">Mapping struct and union types from C</a> and <a href="mapping-strings-from-c" id="3dfbf7cd">Mapping strings from C</a> tutorials.</p>
<p id="7fd4f256">In this tutorial We will learn how to:</p>
<ul class="list _ul" id="2d4f6b58">
<li class="list__item" id="2b704c5c"><p><a href="#pass-kotlin-function-as-c-function-pointer" id="7a579efb">Pass Kotlin function as C function pointer</a></p></li>
<li class="list__item" id="bed95731"><p><a href="#use-the-c-function-pointer-from-kotlin" id="a28f2090">Use C function pointer from Kotlin</a></p></li>
</ul>
<section class="chapter"><h2 id="mapping-function-pointer-types-from-c" data-toc="mapping-function-pointers-from-c#mapping-function-pointer-types-from-c">Mapping function pointer types from C</h2>
<p id="8d02a41a">The best way to understand the mapping between Kotlin and C is to try a tiny example. Declare a function that accepts a function pointer as a parameter and another function that returns a function pointer.</p>
<p id="d53a5aab">Kotlin/Native comes with the <code class="code ">cinterop</code> tool; the tool generates bindings between the C language and Kotlin. It uses a <code class="code ">.def</code> file to specify a C library to import. More details on this are in <a href="native-c-interop" id="a341025f">Interop with C Libraries</a>.</p>
<p id="e7ad1c6a">The quickest way to try out C API mapping is to have all C declarations in the <code class="code ">interop.def</code> file, without creating any <code class="code ">.h</code> of <code class="code ">.c</code> files at all. Then place the C declarations in a <code class="code ">.def</code> file after the special <code class="code ">---</code> separator line:</p>
<pre class="code-block" data-lang="c" data-language="c"> --- int myFun(int i) { return i+1; } typedef int (*MyFun)(int); void accept_fun(MyFun f) { f(42); } MyFun supply_fun() { return myFun; } </pre>
<p id="f3bd06e0">The <code class="code ">interop.def</code> file is enough to compile and run the application or open it in an IDE. Now it is time to create project files, open the project in <a href="https://jetbrains.com/idea" id="d96d0074" data-external="true" rel="noopener noreferrer">IntelliJ IDEA</a> and run it.</p></section><section class="chapter"><h2 id="inspect-generated-kotlin-apis-for-a-c-library" data-toc="mapping-function-pointers-from-c#inspect-generated-kotlin-apis-for-a-c-library">Inspect generated Kotlin APIs for a C library</h2>
<p id="67f524e6">While it is possible to use the command line, either directly or by combining it with a script file (such as <code class="code ">.sh</code> or <code class="code ">.bat</code> file), this approach doesn't scale well for big projects that have hundreds of files and libraries. It is then better to use the Kotlin/Native compiler with a build system, as it helps to download and cache the Kotlin/Native compiler binaries and libraries with transitive dependencies and run the compiler and tests. Kotlin/Native can use the <a href="https://gradle.org" id="79cfce92" data-external="true" rel="noopener noreferrer">Gradle</a> build system through the <a href="mpp-discover-project#multiplatform-plugin" id="18068d1e">kotlin-multiplatform</a> plugin.</p>
<p id="75277dc5">We covered the basics of setting up an IDE compatible project with Gradle in the <a href="native-gradle" id="69806024">A Basic Kotlin/Native Application</a> tutorial. Please check it out if you are looking for detailed first steps and instructions on how to start a new Kotlin/Native project and open it in IntelliJ IDEA. In this tutorial, we'll look at the advanced C interop related usages of Kotlin/Native and <a href="mpp-discover-project#multiplatform-plugin" id="30ead2e3">multiplatform</a> builds with Gradle.</p>
<p id="7df3279a">First, create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes the missing directories will have to be created before any new files can be added.</p>
<p id="f8fb9499">Use the following <code class="code ">build.gradle(.kts)</code> Gradle build file:</p>
<div class="tabs" id="8fd3f8cf" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="3e15b41c" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code-block" data-lang="kotlin" data-title="Kotlin" data-language="kotlin">plugins { kotlin("multiplatform") version "1.6.10" } repositories { mavenCentral() } kotlin { linuxX64("native") { // on Linux // macosX64("native") { // on x86_64 macOS // macosArm64("native") { // on Apple Silicon macOS // mingwX64("native") { // on Windows val main by compilations.getting val interop by main.cinterops.creating binaries { executable() } } } tasks.wrapper { gradleVersion = "6.7.1" distributionType = Wrapper.DistributionType.BIN } </pre></div>
<div class="tabs__content" data-gtm="tab" id="ca6caa" data-sync-tabs="groovy" data-title="Groovy"><pre class="code-block" data-lang="groovy" data-title="Groovy" data-language="groovy">plugins { id 'org.jetbrains.kotlin.multiplatform' version '1.6.10' } repositories { mavenCentral() } kotlin { linuxX64('native') { // on Linux // macosX64("native") { // on x86_64 macOS // macosArm64("native") { // on Apple Silicon macOS // mingwX64('native') { // on Windows compilations.main.cinterops { interop } binaries { executable() } } } wrapper { gradleVersion = '6.7.1' distributionType = 'BIN' } </pre></div>
</div>
<p id="54394d83">The project file configures the C interop as an additional step of the build. Let's move the <code class="code ">interop.def</code> file to the <code class="code ">src/nativeInterop/cinterop</code> directory. Gradle recommends using conventions instead of configurations, for example, the source files are expected to be in the <code class="code ">src/nativeMain/kotlin</code> folder. By default, all the symbols from C are imported to the <code class="code ">interop</code> package, you may want to import the whole package in our <code class="code ">.kt</code> files. Check out the <a href="mpp-discover-project#multiplatform-plugin" id="9eae8816">kotlin-multiplatform</a> plugin documentation to learn about all the different ways you could configure it.</p>
<p id="b5c22b51">Let's create a <code class="code ">src/nativeMain/kotlin/hello.kt</code> stub file with the following content to see how C primitive type declarations are visible from Kotlin:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">import interop.* fun main() { println("Hello Kotlin/Native!") accept_fun(https://kotlinlang.org/*fix me */) val useMe = supply_fun() } </pre>
<p id="978ab36f">Now you are ready to <a href="native-get-started" id="78b4ad08">open the project in IntelliJ IDEA</a> and to see how to fix the example project. While doing that, see how C functions are mapped into Kotlin/Native declarations.</p></section><section class="chapter"><h2 id="c-function-pointers-in-kotlin" data-toc="mapping-function-pointers-from-c#c-function-pointers-in-kotlin">C function pointers in Kotlin</h2>
<p id="39e2d3ba">With the help of IntelliJ IDEA's <b id="39562460" class="">Go To</b> | <b id="9ad85273" class="">Declaration or Usages</b> or compiler errors, see the following declarations for the C functions:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun accept_fun(f: MyFun? /* = CPointer&lt;CFunction&lt;(Int) -&gt; Int&gt;&gt;? */) fun supply_fun(): MyFun? /* = CPointer&lt;CFunction&lt;(Int) -&gt; Int&gt;&gt;? */ fun myFun(i: kotlin.Int): kotlin.Int typealias MyFun = kotlinx.cinterop.CPointer&lt;kotlinx.cinterop.CFunction&lt;(kotlin.Int) -&gt; kotlin.Int&gt;&gt; typealias MyFunVar = kotlinx.cinterop.CPointerVarOf&lt;lib.MyFun&gt; </pre>
<p id="404d68df">You see that the function's <code class="code ">typedef</code> from C has been turned into Kotlin <code class="code ">typealias</code>. It uses <code class="code ">CPointer&lt;..&gt;</code> type to represent the pointer parameters, and <code class="code ">CFunction&lt;(Int)-&gt;Int&gt;</code> to represent the function signature. There is an <code class="code ">invoke</code> operator extension function available for all <code class="code ">CPointer&lt;CFunction&lt;..&gt;</code> types, so that it is possible to call it as you would call any other function in Kotlin.</p></section><section class="chapter"><h2 id="pass-kotlin-function-as-c-function-pointer" data-toc="mapping-function-pointers-from-c#pass-kotlin-function-as-c-function-pointer">Pass Kotlin function as C function pointer</h2>
<p id="d67a772b">It is the time to try using C functions from the Kotlin program. Call the <code class="code ">accept_fun</code> function and pass the C function pointer to a Kotlin lambda:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun myFun() { accept_fun(staticCFunction&lt;Int, Int&gt; { it + 1 }) } </pre>
<p id="5ac41592">This call uses the <code class="code ">staticCFunction{..}</code> helper function from Kotlin/Native to wrap a Kotlin lambda function into a C function pointer. It only allows having unbound and non-capturing lambda functions. For example, it is not able to use a local variable from the function. You may only use globally visible declarations. Throwing exceptions from a <code class="code ">staticCFunction{..}</code> will end up in non-deterministic side-effects. It is vital to make sure that you code is not throwing any sudden exceptions from it.</p></section><section class="chapter"><h2 id="use-the-c-function-pointer-from-kotlin" data-toc="mapping-function-pointers-from-c#use-the-c-function-pointer-from-kotlin">Use the C function pointer from Kotlin</h2>
<p id="ca674277">The next step is to call a C function pointer from a C pointer that you have from the <code class="code ">supply_fun()</code> call:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun myFun2() { val functionFromC = supply_fun() ?: error("No function is returned") functionFromC(42) } </pre>
<p id="cc88b428">Kotlin turns the function pointer return type into a nullable <code class="code ">CPointer&lt;CFunction&lt;..&gt;</code> object. There is the need to explicitly check for <code class="code ">null</code> first. The <a href="null-safety" id="6572c5a4">elvis operator</a> for that in the code above. The <code class="code ">cinterop</code> tool helps us to turn a C function pointer into an easy to call object in Kotlin. This is what we did on the last line.</p></section><section class="chapter"><h2 id="fix-the-code" data-toc="mapping-function-pointers-from-c#fix-the-code">Fix the code</h2>
<p id="a37cf054">You've seen all definitions and it is time to fix and run the code. Run the <code class="code ">runDebugExecutableNative</code> Gradle task <a href="native-get-started" id="a5e01e67">in the IDE</a> or use the following command to run the code:</p>
<pre class="code-block" data-lang="bash" data-language="bash">./gradlew runDebugExecutableNative </pre>
<p id="3deb297f">The code in the <code class="code ">hello.kt</code> file may look like this:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">import interop.* import kotlinx.cinterop.* fun main() { println("Hello Kotlin/Native!") val cFunctionPointer = staticCFunction&lt;Int, Int&gt; { it + 1 } accept_fun(cFunctionPointer) val funFromC = supply_fun() ?: error("No function is returned") funFromC(42) } </pre></section><section class="chapter"><h2 id="next-steps" data-toc="mapping-function-pointers-from-c#next-steps">Next Steps</h2>
<p id="46b4d84a">Continue exploring more C language types and their representation in Kotlin/Native in next tutorials:</p>
<ul class="list _ul" id="85492d03">
<li class="list__item" id="8901196c"><p><a href="mapping-primitive-data-types-from-c" id="ecf420a8">Mapping primitive data types from C</a></p></li>
<li class="list__item" id="b68701c8"><p><a href="mapping-struct-union-types-from-c" id="bcb636a9">Mapping struct and union types from C</a></p></li>
<li class="list__item" id="9460be80"><p><a href="mapping-strings-from-c" id="d2de3862">Mapping strings from C</a></p></li>
</ul>
<p id="fefdd8d1">The <a href="native-c-interop" id="5dcaf0de">C Interop documentation</a> covers more advanced scenarios of the interop.</p></section><div class="last-modified"> Last modified: 01 December 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="mapping-struct-union-types-from-c">Mapping struct and union types from C – tutorial</a> <a class="navigation-links__next" href="mapping-strings-from-c">Mapping Strings from C – tutorial</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/mapping-function-pointers-from-c.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/mapping-function-pointers-from-c.html</a>
  </p>
</div>
