<h1 data-toc="apple-framework" id="apple-framework.md">Kotlin/Native as an Apple framework â€“ tutorial</h1>
<p id="fda6a146">Kotlin/Native provides bi-directional interoperability with Objective-C/Swift. Objective-C frameworks and libraries can be used in Kotlin code. Kotlin modules can be used in Swift/Objective-C code too. Besides that, Kotlin/Native has <a href="native-c-interop" id="5e16efc7">C Interop</a>. There is also the <a href="native-dynamic-libraries" id="50a5171c">Kotlin/Native as a Dynamic Library</a> tutorial for more information.</p>
<p id="d088a16c">In this tutorial, you will see how to use Kotlin/Native code from Objective-C and Swift applications on macOS and iOS.</p>
<p id="5e25bd5e">In this tutorial you'll:</p>
<ul class="list _ul" id="36af83f9">
<li class="list__item" id="5fd03117"><p><a href="#create-a-kotlin-library" id="2fde363d">create a Kotlin Library</a> and compile it to a framework</p></li>
<li class="list__item" id="380864cf"><p>examine the generated <a href="#generated-framework-headers" id="d2f7a4c">Objective-C and Swift API</a> code</p></li>
<li class="list__item" id="fd78daa"><p>use the framework from <a href="#use-the-code-from-objective-c" id="5c592a5e">Objective-C</a> and <a href="#use-the-code-from-swift" id="34c940ee">Swift</a></p></li>
<li class="list__item" id="a27ac511"><p><a href="#xcode-and-framework-dependencies" id="7b477cca">Configure Xcode</a> to use the framework for <a href="#xcode-for-macos-target" id="940ece04">macOS</a> and <a href="#xcode-for-ios-targets" id="6e87a34e">iOS</a></p></li>
</ul>
<section class="chapter"><h2 id="create-a-kotlin-library" data-toc="apple-framework#create-a-kotlin-library">Create a Kotlin library</h2>
<p id="e1708138">The Kotlin/Native compiler can produce a framework for macOS and iOS out of the Kotlin code. The created framework contains all declarations and binaries needed to use it with Objective-C and Swift. The best way to understand the techniques is to try it for ourselves. Let's create a tiny Kotlin library first and use it from an Objective-C program.</p>
<p id="5f2ce3b2">Create the <code class="code ">hello.kt</code> file with the library contents:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">package example object Object { val field = "A" } interface Interface { fun iMember() {} } class Clazz : Interface { fun member(p: Int): ULong? = 42UL } fun forIntegers(b: Byte, s: UShort, i: Int, l: ULong?) { } fun forFloats(f: Float, d: Double?) { } fun strings(str: String?) : String { return "That is '$str' from C" } fun acceptFun(f: (String) -&gt; String?) = f("Kotlin/Native rocks!") fun supplyFun() : (String) -&gt; String? = { "$it is cool!" } </pre>
<p id="9c9c8488">While it is possible to use the command line, either directly or by combining it with a script file (such as <code class="code ">.sh</code> or <code class="code ">.bat</code> file), this approach doesn't scale well for big projects that have hundreds of files and libraries. It is therefore better to use the Kotlin/Native compiler with a build system, as it helps to download and cache the Kotlin/Native compiler binaries and libraries with transitive dependencies and run the compiler and tests. Kotlin/Native can use the <a href="https://gradle.org" id="ccbe9322" data-external="true" rel="noopener noreferrer">Gradle</a> build system through the <a href="mpp-discover-project#multiplatform-plugin" id="7378ec22">kotlin-multiplatform</a> plugin.</p>
<p id="46997807">We covered the basics of setting up an IDE compatible project with Gradle in the <a href="native-gradle" id="3e98873f">A Basic Kotlin/Native Application</a> tutorial. Please check it out if you are looking for detailed first steps and instructions on how to start a new Kotlin/Native project and open it in IntelliJ IDEA. In this tutorial, we'll look at the advanced C interop related usages of Kotlin/Native and <a href="mpp-discover-project#multiplatform-plugin" id="990ee499">multiplatform</a> builds with Gradle.</p>
<p id="15ab46c7">First, create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes the missing directories will have to be created before any new files can be added.</p>
<p id="f8d1838">Use the following <code class="code ">build.gradle(.kts)</code> Gradle build file:</p>
<div class="tabs" id="578ae78a" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="3bb9969d" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code-block" data-lang="kotlin" data-title="Kotlin" data-language="kotlin">plugins { kotlin("multiplatform") version "1.6.10" } repositories { mavenCentral() } kotlin { macosX64("native") { binaries { framework { baseName = "Demo" } } } } tasks.wrapper { gradleVersion = "6.7.1" distributionType = Wrapper.DistributionType.ALL } </pre></div>
<div class="tabs__content" data-gtm="tab" id="31117955" data-sync-tabs="groovy" data-title="Groovy"><pre class="code-block" data-lang="groovy" data-title="Groovy" data-language="groovy">plugins { id 'org.jetbrains.kotlin.multiplatform' version '1.6.10' } repositories { mavenCentral() } kotlin { macosX64("native") { binaries { framework { baseName = "Demo" } } } } wrapper { gradleVersion = "6.7.1" distributionType = "ALL" } </pre></div>
</div>
<p id="81714e70">Move the sources file into the <code class="code ">src/nativeMain/kotlin</code> folder under the project. That is the default path, where sources are located, when the <a href="mpp-discover-project#multiplatform-plugin" id="d3d8b27">kotlin-multiplatform</a> plugin is used. Use the following block to configure the project to generate a dynamic or shared library:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">binaries { framework { baseName = "Demo" } } </pre>
<p id="b59cdf48">Along with macOS <code class="code ">X64</code>, Kotlin/Native supports macos <code class="code ">arm64</code> and iOS <code class="code ">arm32</code>, <code class="code ">arm64</code> and <code class="code ">X64</code> targets. You may replace the <code class="code ">macosX64</code> with respective functions as shown in the table:</p>
<div class="table-wrapper"><table class=" wide" id="3da5c7d8">
<thead><tr class="ijRowHead" id="dfbed67d">
<th id="a4580cf6"><p>Target platform/device</p></th>
<th id="69366e2b"><p>Gradle function</p></th>
</tr></thead>
<tbody>
<tr class="" id="9ab6e229">
<td id="51a6796f"><p>macOS x86_64</p></td>
<td id="9d8ea5cd"><p><code class="code ">macosX64()</code></p></td>
</tr>
<tr class="" id="5731059c">
<td id="9f5796af"><p>macOS ARM 64</p></td>
<td id="cab9af16"><p><code class="code ">macosArm64()</code></p></td>
</tr>
<tr class="" id="c55f8079">
<td id="113ed433"><p>iOS ARM 32</p></td>
<td id="3b173087"><p><code class="code ">iosArm32()</code></p></td>
</tr>
<tr class="" id="aa2405b2">
<td id="238ba432"><p>iOS ARM 64</p></td>
<td id="c9c67c63"><p><code class="code ">iosArm64()</code></p></td>
</tr>
<tr class="" id="e5697579">
<td id="a1a55d2e"><p>iOS Simulator (x86_64)</p></td>
<td id="9de70131"><p><code class="code ">iosX64()</code></p></td>
</tr>
</tbody>
</table></div>
<p id="50e21ed9">Run the <code class="code ">linkNative</code> Gradle task to build the library <a href="native-get-started" id="e98b4e35">in the IDE</a> or by calling the following console command:</p>
<pre class="code-block" data-lang="bash" data-language="bash">./gradlew linkNative </pre>
<p id="23cbab52">Depending on the variant, the build generates the framework into the <code class="code ">build/bin/native/debugFramework</code> and <code class="code ">build/bin/native/releaseFramework</code> folders. Let's see what is inside.</p></section><section class="chapter"><h2 id="generated-framework-headers" data-toc="apple-framework#generated-framework-headers">Generated framework headers</h2>
<p id="cb68beef">Each of the created frameworks contains the header file in <code class="code ">&lt;Framework&gt;/Headers/Demo.h</code>. The headers do not depend on the target platform (at least with Kotlin/Native v.0.9.2). It contains the definitions for our Kotlin code and a few Kotlin-wide declarations.</p>
<aside data-type="note" class="prompt" data-title="" id="9b1afb75"><p id="246b5363">The way Kotlin/Native exports symbols is subject to change without notice.</p></aside><section class="chapter"><h3 id="kotlin-native-runtime-declarations" data-toc="apple-framework#kotlin-native-runtime-declarations">Kotlin/Native runtime declarations</h3>
<p id="3e3a6e04">Take a look at Kotlin runtime declarations:</p>
<pre class="code-block" data-lang="none" data-disable-link-processing="true" data-language="none">NS_ASSUME_NONNULL_BEGIN @interface KotlinBase : NSObject - (instancetype)init __attribute__((unavailable)); + (instancetype)new __attribute__((unavailable)); + (void)initialize __attribute__((objc_requires_super)); @end; @interface KotlinBase (KotlinBaseCopying) &lt;NSCopying&gt; @end; __attribute__((objc_runtime_name("KotlinMutableSet"))) __attribute__((swift_name("KotlinMutableSet"))) @interface DemoMutableSet&lt;ObjectType&gt; : NSMutableSet&lt;ObjectType&gt; @end; __attribute__((objc_runtime_name("KotlinMutableDictionary"))) __attribute__((swift_name("KotlinMutableDictionary"))) @interface DemoMutableDictionary&lt;KeyType, ObjectType&gt; : NSMutableDictionary&lt;KeyType, ObjectType&gt; @end; @interface NSError (NSErrorKotlinException) @property (readonly) id _Nullable kotlinException; @end; </pre>
<p id="c6c95512">Kotlin classes have a <code class="code ">KotlinBase</code> base class in Objective-C, the class extends the <code class="code ">NSObject</code> class there. There are also have wrappers for collections and exceptions. Most of the collection types are mapped to similar collection types from the other side:</p>
<div class="table-wrapper"><table class=" wide" id="26f203fc">
<thead><tr class="ijRowHead" id="a671360">
<th id="f17528d5"><p>Kotlin</p></th>
<th id="f5401dee"><p>Swift</p></th>
<th id="b9c1bbfe"><p>Objective-C</p></th>
</tr></thead>
<tbody>
<tr class="" id="13b916c8">
<td id="c372bec9"><p>List</p></td>
<td id="372b4f42"><p>Array</p></td>
<td id="65bf5272"><p>NSArray</p></td>
</tr>
<tr class="" id="d9142227">
<td id="e9a45f0e"><p>MutableList</p></td>
<td id="1186eb14"><p>NSMutableArray</p></td>
<td id="ab7b5dac"><p>NSMutableArray</p></td>
</tr>
<tr class="" id="3fe0ffaa">
<td id="ce147b8d"><p>Set</p></td>
<td id="7b830e71"><p>Set</p></td>
<td id="bb8b429e"><p>NSSet</p></td>
</tr>
<tr class="" id="6699a05c">
<td id="fd30739b"><p>Map</p></td>
<td id="7555954a"><p>Dictionary</p></td>
<td id="1275d87e"><p>NSDictionary</p></td>
</tr>
<tr class="" id="b6c02100">
<td id="5bc1a35"><p>MutableMap</p></td>
<td id="ec3b5d68"><p>NSMutableDictionary</p></td>
<td id="5422a7"><p>NSMutableDictionary</p></td>
</tr>
</tbody>
</table></div></section><section class="chapter"><h3 id="kotlin-numbers-and-nsnumber" data-toc="apple-framework#kotlin-numbers-and-nsnumber">Kotlin numbers and NSNumber</h3>
<p id="2180c820">The next part of the <code class="code ">&lt;Framework&gt;/Headers/Demo.h</code> contains number type mappings between Kotlin/Native and <code class="code ">NSNumber</code>. There is the base class called <code class="code ">DemoNumber</code> in Objective-C and <code class="code ">KotlinNumber</code> in Swift. It extends <code class="code ">NSNumber</code>. There are also child classes per Kotlin number type:</p>
<div class="table-wrapper"><table class=" wide" id="beb0563b">
<thead><tr class="ijRowHead" id="b9831513">
<th id="cdd11a29"><p>Kotlin</p></th>
<th id="a29a14f9"><p>Swift</p></th>
<th id="293fdbca"><p>Objective-C</p></th>
<th id="a626f14f"><p>Simple type</p></th>
</tr></thead>
<tbody>
<tr class="" id="703034a">
<td id="199683"><p><code class="code ">-</code></p></td>
<td id="efa4b94e"><p><code class="code ">KotlinNumber</code></p></td>
<td id="806fb979"><p><code class="code ">&lt;Package&gt;Number</code></p></td>
<td id="12e41446"><p><code class="code ">-</code></p></td>
</tr>
<tr class="" id="b0c5b07a">
<td id="9707720f"><p><code class="code ">Byte</code></p></td>
<td id="817c67c5"><p><code class="code ">KotlinByte</code></p></td>
<td id="bf619132"><p><code class="code ">&lt;Package&gt;Byte</code></p></td>
<td id="d312f774"><p><code class="code ">char</code></p></td>
</tr>
<tr class="" id="7e19bcfd">
<td id="ba1e859"><p><code class="code ">UByte</code></p></td>
<td id="5fca7bac"><p><code class="code ">KotlinUByte</code></p></td>
<td id="f97e2c49"><p><code class="code ">&lt;Package&gt;UByte</code></p></td>
<td id="b4901116"><p><code class="code ">unsigned char</code></p></td>
</tr>
<tr class="" id="d161eef5">
<td id="8736296c"><p><code class="code ">Short</code></p></td>
<td id="8948d087"><p><code class="code ">KotlinShort</code></p></td>
<td id="c127448b"><p><code class="code ">&lt;Package&gt;Short</code></p></td>
<td id="afed6bd6"><p><code class="code ">short</code></p></td>
</tr>
<tr class="" id="5cea16ae">
<td id="fcabd13e"><p><code class="code ">UShort</code></p></td>
<td id="9d95ef07"><p><code class="code ">KotlinUShort</code></p></td>
<td id="47f64541"><p><code class="code ">&lt;Package&gt;UShort</code></p></td>
<td id="18345ac6"><p><code class="code ">unsigned short</code></p></td>
</tr>
<tr class="" id="3c1cff24">
<td id="7684800f"><p><code class="code ">Int</code></p></td>
<td id="85bb0edb"><p><code class="code ">KotlinInt</code></p></td>
<td id="c8973714"><p><code class="code ">&lt;Package&gt;Int</code></p></td>
<td id="dc5643f4"><p><code class="code ">int</code></p></td>
</tr>
<tr class="" id="a8858b1e">
<td id="941ad101"><p><code class="code ">UInt</code></p></td>
<td id="401c1fe5"><p><code class="code ">KotlinUInt</code></p></td>
<td id="d824432d"><p><code class="code ">&lt;Package&gt;UInt</code></p></td>
<td id="e9591aa0"><p><code class="code ">unsigned int</code></p></td>
</tr>
<tr class="" id="4f789b0b">
<td id="3d3f27f2"><p><code class="code ">Long</code></p></td>
<td id="936c938e"><p><code class="code ">KotlinLong</code></p></td>
<td id="5fe0cd56"><p><code class="code ">&lt;Package&gt;Long</code></p></td>
<td id="fa36c62f"><p><code class="code ">long long</code></p></td>
</tr>
<tr class="" id="3e84e614">
<td id="f454002a"><p><code class="code ">ULong</code></p></td>
<td id="9d1249fa"><p><code class="code ">KotlinULong</code></p></td>
<td id="fbfd35d1"><p><code class="code ">&lt;Package&gt;ULong</code></p></td>
<td id="6507679c"><p><code class="code ">unsigned long long</code></p></td>
</tr>
<tr class="" id="c9965def">
<td id="2c8dd557"><p><code class="code ">Float</code></p></td>
<td id="fff50171"><p><code class="code ">KotlinFloat</code></p></td>
<td id="db69bf57"><p><code class="code ">&lt;Package&gt;Float</code></p></td>
<td id="19cee319"><p><code class="code ">float</code></p></td>
</tr>
<tr class="" id="752a2c3b">
<td id="5eff2741"><p><code class="code ">Double</code></p></td>
<td id="2de579b1"><p><code class="code ">KotlinDouble</code></p></td>
<td id="9a7b3785"><p><code class="code ">&lt;Package&gt;Double</code></p></td>
<td id="ca98dc40"><p><code class="code ">double</code></p></td>
</tr>
<tr class="" id="5f52badb">
<td id="45931021"><p><code class="code ">Boolean</code></p></td>
<td id="d5f0ba3b"><p><code class="code ">KotlinBoolean</code></p></td>
<td id="eeaa6dbd"><p><code class="code ">&lt;Package&gt;Boolean</code></p></td>
<td id="e5f360df"><p><code class="code ">BOOL/Bool</code></p></td>
</tr>
</tbody>
</table></div>
<p id="b1feae2e">Every number type has a class method to create a new instance from the related simple type. Also, there is an instance method to extract a simple value back. Schematically, declarations look like that:</p>
<pre class="code-block" data-lang="none" data-disable-link-processing="true" data-language="none">__attribute__((objc_runtime_name("Kotlin__TYPE__"))) __attribute__((swift_name("Kotlin__TYPE__"))) @interface Demo__TYPE__ : DemoNumber - (instancetype)initWith__TYPE__:(__CTYPE__)value; + (instancetype)numberWith__TYPE__:(__CTYPE__)value; @end; </pre>
<p id="acbee74a">Where <code class="code ">__TYPE__</code> is one of the simple type names and <code class="code ">__CTYPE__</code> is the related Objective-C type, for example, <code class="code ">initWithChar(char)</code>.</p>
<p id="125956c">These types are used to map boxed Kotlin number types into Objective-C and Swift. In Swift, you may simply call the constructor to create an instance, for example, <code class="code ">KotlinLong(value: 42)</code>.</p></section><section class="chapter"><h3 id="classes-and-objects-from-kotlin" data-toc="apple-framework#classes-and-objects-from-kotlin">Classes and objects from Kotlin</h3>
<p id="8a4ada85">Let's see how <code class="code ">class</code> and <code class="code ">object</code> are mapped to Objective-C and Swift. The generated <code class="code ">&lt;Framework&gt;/Headers/Demo.h</code> file contains the exact definitions for <code class="code ">Class</code>, <code class="code ">Interface</code>, and <code class="code ">Object</code>:</p>
<pre class="code-block" data-lang="none" data-disable-link-processing="true" data-language="none">NS_ASSUME_NONNULL_BEGIN __attribute__((objc_subclassing_restricted)) __attribute__((swift_name("Object"))) @interface DemoObject : KotlinBase + (instancetype)alloc __attribute__((unavailable)); + (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable)); + (instancetype)object __attribute__((swift_name("init()"))); @property (readonly) NSString *field; @end; __attribute__((swift_name("Interface"))) @protocol DemoInterface @required - (void)iMember __attribute__((swift_name("iMember()"))); @end; __attribute__((objc_subclassing_restricted)) __attribute__((swift_name("Clazz"))) @interface DemoClazz : KotlinBase &lt;DemoInterface&gt; - (instancetype)init __attribute__((swift_name("init()"))) __attribute__((objc_designated_initializer)); + (instancetype)new __attribute__((availability(swift, unavailable, message="use object initializers instead"))); - (DemoLong * _Nullable)memberP:(int32_t)p __attribute__((swift_name("member(p:)"))); @end; </pre>
<p id="c74d331a">The code is full of Objective-C attributes, which are intended to help the use of the framework from both Objective-C and Swift languages. <code class="code ">DemoClazz</code>, <code class="code ">DemoInterface</code>, and <code class="code ">DemoObject</code> are created for <code class="code ">Clazz</code>, <code class="code ">Interface</code>, and <code class="code ">Object</code> respectively. The <code class="code ">Interface</code> is turned into <code class="code ">@protocol</code>, both a <code class="code ">class</code> and an <code class="code ">object</code> are represented as <code class="code ">@interface</code>. The <code class="code ">Demo</code> prefix comes from the <code class="code ">-output</code> parameter of the <code class="code ">kotlinc-native</code> compiler and the framework name. You can see here that the nullable return type <code class="code ">ULong?</code> is turned into <code class="code ">DemoLong*</code> in Objective-C.</p></section><section class="chapter"><h3 id="global-declarations-from-kotlin" data-toc="apple-framework#global-declarations-from-kotlin">Global declarations from Kotlin</h3>
<p id="d17306e5">All global functions from Kotlin are turned into <code class="code ">DemoLibKt</code> in Objective-C and into <code class="code ">LibKt</code> in Swift, where <code class="code ">Demo</code> is the framework name and set by the <code class="code ">-output</code> parameter of <code class="code ">kotlinc-native</code>.</p>
<pre class="code-block" data-lang="none" data-disable-link-processing="true" data-language="none">NS_ASSUME_NONNULL_BEGIN __attribute__((objc_subclassing_restricted)) __attribute__((swift_name("LibKt"))) @interface DemoLibKt : KotlinBase + (void)forIntegersB:(int8_t)b s:(int16_t)s i:(int32_t)i l:(DemoLong * _Nullable)l __attribute__((swift_name("forIntegers(b:s:i:l:)"))); + (void)forFloatsF:(float)f d:(DemoDouble * _Nullable)d __attribute__((swift_name("forFloats(f:d:)"))); + (NSString *)stringsStr:(NSString * _Nullable)str __attribute__((swift_name("strings(str:)"))); + (NSString * _Nullable)acceptFunF:(NSString * _Nullable (^)(NSString *))f __attribute__((swift_name("acceptFun(f:)"))); + (NSString * _Nullable (^)(NSString *))supplyFun __attribute__((swift_name("supplyFun()"))); @end; </pre>
<p id="f5427d18">You see that Kotlin <code class="code ">String</code> and Objective-C <code class="code ">NSString*</code> are mapped transparently. Similarly, <code class="code ">Unit</code> type from Kotlin is mapped to <code class="code ">void</code>. We see primitive types are mapped directly. Non-nullable primitive types are mapped transparently. Nullable primitive types are mapped into <code class="code ">Kotlin&lt;TYPE&gt;*</code> types, as shown in the table <a href="#kotlin-numbers-and-nsnumber" id="da33348">above</a>. Both higher order functions <code class="code ">acceptFunF</code> and <code class="code ">supplyFun</code> are included, and accept Objective-C blocks.</p>
<p id="e6bdbc3a">More information about all other types mapping details can be found in the <a href="native-objc-interop" id="41933b6e">Objective-C Interop</a> documentation article</p></section></section><section class="chapter"><h2 id="garbage-collection-and-reference-counting" data-toc="apple-framework#garbage-collection-and-reference-counting">Garbage collection and reference counting</h2>
<p id="3dcf4a4">Objective-C and Swift use reference counting. Kotlin/Native has its own garbage collection too. Kotlin/Native garbage collection is integrated with Objective-C/Swift reference counting. You do not need to use anything special to control the lifetime of Kotlin/Native instances from Swift or Objective-C.</p></section><section class="chapter"><h2 id="use-the-code-from-objective-c" data-toc="apple-framework#use-the-code-from-objective-c">Use the code from Objective-C</h2>
<p id="46d74ad">Let's call the framework from Objective-C. For that, create the <code class="code ">main.m</code> file with the following content:</p>
<pre class="code-block" data-lang="none" data-disable-link-processing="true" data-language="none">#import &lt;Foundation/Foundation.h&gt; #import &lt;Demo/Demo.h&gt; int main(int argc, const char * argv[]) { @autoreleasepool { [[DemoObject object] field]; DemoClazz* clazz = [[ DemoClazz alloc] init]; [clazz memberP:42]; [DemoLibKt forIntegersB:1 s:1 i:3 l:[DemoULong numberWithUnsignedLongLong:4]]; [DemoLibKt forIntegersB:1 s:1 i:3 l:nil]; [DemoLibKt forFloatsF:2.71 d:[DemoDouble numberWithDouble:2.71]]; [DemoLibKt forFloatsF:2.71 d:nil]; NSString* ret = [DemoLibKt acceptFunF:^NSString * _Nullable(NSString * it) { return [it stringByAppendingString:@" Kotlin is fun"]; }]; NSLog(@"%@", ret); return 0; } } </pre>
<p id="39db95da">Here you call Kotlin classes directly from Objective-C code. A Kotlin <code class="code ">object</code> has the class method function <code class="code ">object</code>, which allows us to get the only instance of the object and to call <code class="code ">Object</code> methods on it. The widespread pattern is used to create an instance of the <code class="code ">Clazz</code> class. You call the <code class="code ">[[ DemoClazz alloc] init]</code> on Objective-C. You may also use <code class="code ">[DemoClazz new]</code> for constructors without parameters. Global declarations from the Kotlin sources are scoped under the <code class="code ">DemoLibKt</code> class in Objective-C. All methods are turned into class methods of that class. The <code class="code ">strings</code> function is turned into <code class="code ">DemoLibKt.stringsStr</code> function in Objective-C, you can pass <code class="code ">NSString</code> directly to it. The return is visible as <code class="code ">NSString</code> too.</p></section><section class="chapter"><h2 id="use-the-code-from-swift" data-toc="apple-framework#use-the-code-from-swift">Use the code from Swift</h2>
<p id="233a03e5">The framework that you compiled with Kotlin/Native has helper attributes to make it easier to use with Swift. Convert the previous Objective-C example into Swift. As a result, you'll have the following code in <code class="code ">main.swift</code>:</p>
<pre class="code-block" data-lang="swift" data-language="swift">import Foundation import Demo let kotlinObject = Object() assert(kotlinObject === Object(), "Kotlin object has only one instance") let field = Object().field let clazz = Clazz() clazz.member(p: 42) LibKt.forIntegers(b: 1, s: 2, i: 3, l: 4) LibKt.forFloats(f: 2.71, d: nil) let ret = LibKt.acceptFun { "\($0) Kotlin is fun" } if (ret != nil) { print(ret!) } </pre>
<p id="e42c60a4">The Kotlin code is turned into very similar looking code in Swift. There are some small differences, though. In Kotlin any <code class="code ">object</code> has only one instance. Kotlin <code class="code ">object Object</code> now has a constructor in Swift, and we use the <code class="code ">Object()</code> syntax to access the only instance of it. The instance is always the same in Swift, so that <code class="code ">Object() === Object()</code> is true. Methods and property names are translated as-is. Kotlin <code class="code ">String</code> is turned into Swift <code class="code ">String</code> too. Swift hides <code class="code ">NSNumber*</code> boxing from us too. We can pass a Swift closure to Kotlin and call a Kotlin lambda function from Swift too.</p>
<p id="381a4bd1">More documentation on the types mapping can be found in the <a href="native-objc-interop" id="ea86940e">Objective-C Interop</a> article.</p></section><section class="chapter"><h2 id="xcode-and-framework-dependencies" data-toc="apple-framework#xcode-and-framework-dependencies">Xcode and framework dependencies</h2>
<p id="5d78580a">You need to configure an Xcode project to use our framework. The configuration depends on the target platform.</p>
<section class="chapter"><h3 id="xcode-for-macos-target" data-toc="apple-framework#xcode-for-macos-target">Xcode for macOS target</h3>
<p id="157bab13">First, in the <b id="34c8b4fc" class="">General</b> tab of the <b id="665e7dc0" class="">target</b> configuration, under the <b id="f553e836" class="">Linked Frameworks and Libraries</b> section, you need to include our framework. This will make Xcode look at our framework and resolve imports both from Objective-C and Swift.</p>
<p id="be18066b">The second step is to configure the framework search path of the produced binary. It is also known as <code class="code ">rpath</code> or <a href="https://en.wikipedia.org/wiki/Rpath" id="edcf07e" data-external="true" rel="noopener noreferrer">run-time search path</a>. The binary uses the path to look for the required frameworks. We do not recommend installing additional frameworks to the OS if it is not needed. You should understand the layout of your future application, for example, you may have the <code class="code ">Frameworks</code> folder under the application bundle with all the frameworks you use. The <code class="code ">@rpath</code> parameter can be configured in Xcode. You need to open the <b id="778dfd41" class="">project</b> configuration and find the <b id="fb9ffec" class="">Runpath Search Paths</b> section. Here you specify the relative path to the compiled framework.</p></section><section class="chapter"><h3 id="xcode-for-ios-targets" data-toc="apple-framework#xcode-for-ios-targets">Xcode for iOS targets</h3>
<p id="684b8fc4">First, you need to include the compiled framework in the Xcode project. To do this, add the framework to the <b id="22ea132d" class="">Frameworks, Libraries, and Embedded Content</b> section of the <b id="78b5ecbd" class="">General</b> tab of the <b id="ad26cff2" class="">target</b> configuration page.</p>
<p id="c21a6b04">The second step is to then include the framework path into the <b id="1cb46c68" class="">Framework Search Paths</b> section of the <b id="efb1faa5" class="">Build Settings</b> tab of the <b id="1c302594" class="">target</b> configuration page. It is possible to use the <code class="code ">$(PROJECT_DIR)</code> macro to simplify the setup.</p>
<p id="6afae6fa">The iOS simulator requires a framework compiled for the <code class="code ">ios_x64</code> target, the <code class="code ">iOS_sim</code> folder in our case.</p>
<p id="cd382f63"><a href="https://stackoverflow.com/questions/30963294/creating-ios-osx-frameworks-is-it-necessary-to-codesign-them-before-distributin" id="bd0db5e8" data-external="true" rel="noopener noreferrer">This Stackoverflow thread</a> contains a few more recommendations. Also, the <a href="https://cocoapods.org/" id="f91e8e25" data-external="true" rel="noopener noreferrer">CocoaPods</a> package manager may be helpful to automate the process too.</p></section></section><section class="chapter"><h2 id="next-steps" data-toc="apple-framework#next-steps">Next steps</h2>
<p id="e585448c">Kotlin/Native has bidirectional interop with Objective-C and Swift languages. Kotlin objects integrate with Objective-C/Swift reference counting. Unused Kotlin objects are automatically removed. The <a href="native-objc-interop" id="5992a53f">Objective-C Interop</a> article contains more information on the interop implementation details. Of course, it is possible to import an existing framework and use it from Kotlin. Kotlin/Native comes with a good set of pre-imported system frameworks.</p>
<p id="942240a1">Kotlin/Native supports C interop too. Check out the <a href="native-dynamic-libraries" id="9abb97a5">Kotlin/Native as a Dynamic Library</a> tutorial for that.</p></section><div class="last-modified"> Last modified: 08 September 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="native-cocoapods-xcode">Use a Kotlin Gradle project as a CocoaPods dependency</a> <a class="navigation-links__next" href="native-debugging">Debugging Kotlin/Native</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/apple-framework.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/apple-framework.html</a>
  </p>
</div>
