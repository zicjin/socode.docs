<h1 data-toc="exceptions" id="exceptions.md">Exceptions</h1>
<section class="chapter"><h2 id="exception-classes" data-toc="exceptions#exception-classes">Exception classes</h2>
<p id="5c271f74">All exception classes in Kotlin inherit the <code class="code ">Throwable</code> class. Every exception has a message, a stack trace, and an optional cause.</p>
<p id="2a42f073">To throw an exception object, use the <code class="code ">throw</code> expression:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart throw Exception("Hi There!") //sampleEnd } </pre>
<p id="9d5a4f5c">To catch an exception, use the <code class="code ">try</code>... <code class="code ">catch</code> expression:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">try { // some code } catch (e: SomeException) { // handler } finally { // optional finally block } </pre>
<p id="a0969acf">There may be zero or more <code class="code ">catch</code> blocks, and the <code class="code ">finally</code> block may be omitted. However, at least one <code class="code ">catch</code> or <code class="code ">finally</code> block is required.</p>
<section class="chapter"><h3 id="try-is-an-expression" data-toc="exceptions#try-is-an-expression">Try is an expression</h3>
<p id="7209a647"><code class="code ">try</code> is an expression, which means it can have a return value:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val a: Int? = try { input.toInt() } catch (e: NumberFormatException) { null } </pre>
<p id="7d4129bd">The returned value of a <code class="code ">try</code> expression is either the last expression in the <code class="code ">try</code> block or the last expression in the <code class="code ">catch</code> block (or blocks). The contents of the <code class="code ">finally</code> block don't affect the result of the expression.</p></section></section><section class="chapter"><h2 id="checked-exceptions" data-toc="exceptions#checked-exceptions">Checked exceptions</h2>
<p id="cb1800da">Kotlin does not have checked exceptions. There are many reasons for this, but we will provide a simple example that illustrates why it is the case.</p>
<p id="ade5739">The following is an example interface from the JDK implemented by the <code class="code ">StringBuilder</code> class:</p>
<pre class="code-block" data-lang="java" data-language="java">Appendable append(CharSequence csq) throws IOException; </pre>
<p id="10d07f1c">This signature says that every time I append a string to something (a <code class="code ">StringBuilder</code>, some kind of a log, a console, etc.), I have to catch the <code class="code ">IOExceptions</code>. Why? Because the implementation might be performing IO operations (<code class="code ">Writer</code> also implements <code class="code ">Appendable</code>). The result is code like this all over the place.:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">try { log.append(message) } catch (IOException e) { // Must be safe } </pre>
<p id="9a4ee3e3">And that’s not good. Just take a look at <a href="https://www.oracle.com/technetwork/java/effectivejava-136174.html" id="f518188" data-external="true" rel="noopener noreferrer">Effective Java, 3rd Edition</a>, Item 77: <em id="69c9c28d" class="">Don't ignore exceptions</em>.</p>
<p id="ae8cc10c">Bruce Eckel says this about checked exceptions:</p>
<aside data-type="tip" class="prompt" data-title="" id="5603f4db"><p id="3f423324">Examination of small programs leads to the conclusion that requiring exception specifications could both enhance developer productivity and enhance code quality, but experience with large software projects suggests a different result – decreased productivity and little or no increase in code quality.</p></aside><p id="da81a026">And here are some additional thoughts on the matter:</p>
<ul class="list _ul" id="51635a50">
<li class="list__item" id="d3c7cfd0"><p><a href="https://radio-weblogs.com/0122027/stories/2003/04/01/JavasCheckedExceptionsWereAMistake.html" id="b0173df5" data-external="true" rel="noopener noreferrer">Java's checked exceptions were a mistake</a> (Rod Waldhoff)</p></li>
<li class="list__item" id="41b60d92"><p><a href="https://www.artima.com/intv/handcuffs.html" id="fcddaf91" data-external="true" rel="noopener noreferrer">The Trouble with Checked Exceptions</a> (Anders Hejlsberg)</p></li>
</ul>
<p id="32a1d8d">If you want to alert callers about possible exceptions when calling Kotlin code from Java, Swift, or Objective-C, you can use the <code class="code ">@Throws</code> annotation. Read more about using this annotation <a href="java-to-kotlin-interop#checked-exceptions" id="231122ef">for Java</a> and <a href="native-objc-interop#errors-and-exceptions" id="df501bba">for Swift and Objective-C</a>.</p></section><section class="chapter"><h2 id="the-nothing-type" data-toc="exceptions#the-nothing-type">The Nothing type</h2>
<p id="d0b488e8"><code class="code ">throw</code> is an expression in Kotlin, so you can use it, for example, as part of an Elvis expression:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val s = person.name ?: throw IllegalArgumentException("Name required") </pre>
<p id="9b46b1a1">The <code class="code ">throw</code> expression has the type <code class="code ">Nothing</code>. This type has no values and is used to mark code locations that can never be reached. In your own code, you can use <code class="code ">Nothing</code> to mark a function that never returns:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun fail(message: String): Nothing { throw IllegalArgumentException(message) } </pre>
<p id="1d9a4d26">When you call this function, the compiler will know that the execution doesn't continue beyond the call:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val s = person.name ?: fail("Name required") println(s) // 's' is known to be initialized at this point </pre>
<p id="17b8855f">You may also encounter this type when dealing with type inference. The nullable variant of this type, <code class="code ">Nothing?</code>, has exactly one possible value, which is <code class="code ">null</code>. If you use <code class="code ">null</code> to initialize a value of an inferred type and there's no other information that can be used to determine a more specific type, the compiler will infer the <code class="code ">Nothing?</code> type:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val x = null // 'x' has type `Nothing?` val l = listOf(null) // 'l' has type `List&lt;Nothing?&gt; </pre></section><section class="chapter"><h2 id="java-interoperability" data-toc="exceptions#java-interoperability">Java interoperability</h2>
<p id="fe68fe5a">Please see the section on exceptions in the <a href="java-interop" id="30038563">Java interoperability page</a> for information about Java interoperability.</p></section><div class="last-modified"> Last modified: 10 September 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="returns">Returns and jumps</a> <a class="navigation-links__next" href="packages">Packages and imports</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/exceptions.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/exceptions.html</a>
  </p>
</div>
