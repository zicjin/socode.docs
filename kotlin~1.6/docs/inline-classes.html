<h1 data-toc="inline-classes" id="inline-classes.md">Inline classes</h1>
<p id="90b4b954">Sometimes it is necessary for business logic to create a wrapper around some type. However, it introduces runtime overhead due to additional heap allocations. Moreover, if the wrapped type is primitive, the performance hit is terrible, because primitive types are usually heavily optimized by the runtime, while their wrappers don't get any special treatment.</p>
<p id="3408c83c">To solve such issues, Kotlin introduces a special kind of class called an <em id="5c0f5e57" class="">inline class</em>. Inline classes are a subset of <a href="https://github.com/Kotlin/KEEP/blob/master/notes/value-classes.md" id="39ce9a23" data-external="true" rel="noopener noreferrer">value-based classes</a>. They don't have an identity and can only hold values.</p>
<p id="4852da96">To declare an inline class, use the <code class="code ">value</code> modifier before the name of the class:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">value class Password(private val s: String) </pre>
<p id="5f4842d2">To declare an inline class for the JVM backend, use the <code class="code ">value</code> modifier along with the <code class="code ">@JvmInline</code> annotation before the class declaration:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">// For JVM backends @JvmInline value class Password(private val s: String) </pre>
<aside data-type="warning" class="prompt" data-title="" id="19388c74"><p id="907d0c25">The <code class="code ">inline</code> modifier for inline classes is deprecated.</p></aside><p id="7622b74f">An inline class must have a single property initialized in the primary constructor. At runtime, instances of the inline class will be represented using this single property (see details about runtime representation <a href="#representation" id="f261fba">below</a>):</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">// No actual instantiation of class 'Password' happens // At runtime 'securePassword' contains just 'String' val securePassword = Password("Don't try this in production") </pre>
<p id="64c3396b">This is the main feature of inline classes, which inspired the name <em id="c6f26cfd" class="">inline</em>: data of the class is <em id="236025f4" class="">inlined</em> into its usages (similar to how content of <a href="inline-functions" id="7314572f">inline functions</a> is inlined to call sites).</p>
<section class="chapter"><h2 id="members" data-toc="inline-classes#members">Members</h2>
<p id="d7e51dc1">Inline classes support some functionality of regular classes. In particular, they are allowed to declare properties and functions, and have the <code class="code ">init</code> block:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">@JvmInline value class Name(val s: String) { init { require(s.length &gt; 0) { } } val length: Int get() = s.length fun greet() { println("Hello, $s") } } fun main() { val name = Name("Kotlin") name.greet() // method `greet` is called as a static method println(name.length) // property getter is called as a static method } </pre>
<p id="ca80fc07">Inline class properties cannot have <a href="properties#backing-fields" id="25c4e3fc">backing fields</a>. They can only have simple computable properties (no <code class="code ">lateinit</code> /delegated properties).</p></section><section class="chapter"><h2 id="inheritance" data-toc="inline-classes#inheritance">Inheritance</h2>
<p id="a03cecbe">Inline classes are allowed to inherit from interfaces:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">interface Printable { fun prettyPrint(): String } @JvmInline value class Name(val s: String) : Printable { override fun prettyPrint(): String = "Let's $s!" } fun main() { val name = Name("Kotlin") println(name.prettyPrint()) // Still called as a static method } </pre>
<p id="80601689">It is forbidden for inline classes to participate in a class hierarchy. This means that inline classes cannot extend other classes and must be <code class="code ">final</code>.</p></section><section class="chapter"><h2 id="representation" data-toc="inline-classes#representation">Representation</h2>
<p id="77383fd3">In generated code, the Kotlin compiler keeps a <em id="65c6094d" class="">wrapper</em> for each inline class. Inline class instances can be represented at runtime either as wrappers or as the underlying type. This is similar to how <code class="code ">Int</code> can be <a href="basic-types#numbers-representation-on-the-jvm" id="fa44dad4">represented</a> either as a primitive <code class="code ">int</code> or as the wrapper <code class="code ">Integer</code>.</p>
<p id="c0de7716">The Kotlin compiler will prefer using underlying types instead of wrappers to produce the most performant and optimized code. However, sometimes it is necessary to keep wrappers around. As a rule of thumb, inline classes are boxed whenever they are used as another type.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">interface I @JvmInline value class Foo(val i: Int) : I fun asInline(f: Foo) {} fun &lt;T&gt; asGeneric(x: T) {} fun asInterface(i: I) {} fun asNullable(i: Foo?) {} fun &lt;T&gt; id(x: T): T = x fun main() { val f = Foo(42) asInline(f) // unboxed: used as Foo itself asGeneric(f) // boxed: used as generic type T asInterface(f) // boxed: used as type I asNullable(f) // boxed: used as Foo?, which is different from Foo // below, 'f' first is boxed (while being passed to 'id') and then unboxed (when returned from 'id') // In the end, 'c' contains unboxed representation (just '42'), as 'f' val c = id(f) } </pre>
<p id="bfdbd76a">Because inline classes may be represented both as the underlying value and as a wrapper, <a href="equality#referential-equality" id="36b3a4ce">referential equality</a> is pointless for them and is therefore prohibited.</p>
<section class="chapter"><h3 id="mangling" data-toc="inline-classes#mangling">Mangling</h3>
<p id="9e4ecfe6">Since inline classes are compiled to their underlying type, it may lead to various obscure errors, for example unexpected platform signature clashes:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">@JvmInline value class UInt(val x: Int) // Represented as 'public final void compute(int x)' on the JVM fun compute(x: Int) { } // Also represented as 'public final void compute(int x)' on the JVM! fun compute(x: UInt) { } </pre>
<p id="c16b0b6b">To mitigate such issues, functions using inline classes are <em id="2c76409e" class="">mangled</em> by adding some stable hashcode to the function name. Therefore, <code class="code ">fun compute(x: UInt)</code> will be represented as <code class="code ">public final void compute-&lt;hashcode&gt;(int x)</code>, which solves the clash problem.</p>
<aside data-type="note" class="prompt" data-title="" id="1d06928d"><p id="ba263cbb">The mangling scheme has been changed in Kotlin 1.4.30. Use the <code class="code ">-Xuse-14-inline-classes-mangling-scheme</code> compiler flag to force the compiler to use the old 1.4.0 mangling scheme and preserve binary compatibility.</p></aside></section><section class="chapter"><h3 id="calling-from-java-code" data-toc="inline-classes#calling-from-java-code">Calling from Java code</h3>
<p id="129c07e2">You can call functions that accept inline classes from Java code. To do so, you should manually disable mangling: add the <code class="code ">@JvmName</code> annotation before the function declaration:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">@JvmInline value class UInt(val x: Int) fun compute(x: Int) { } @JvmName("computeUInt") fun compute(x: UInt) { } </pre></section></section><section class="chapter"><h2 id="inline-classes-vs-type-aliases" data-toc="inline-classes#inline-classes-vs-type-aliases">Inline classes vs type aliases</h2>
<p id="fd1053c0">At first sight, inline classes seem very similar to <a href="type-aliases" id="863c29a2">type aliases</a>. Indeed, both seem to introduce a new type and both will be represented as the underlying type at runtime.</p>
<p id="d5748352">However, the crucial difference is that type aliases are <em id="f6dd0321" class="">assignment-compatible</em> with their underlying type (and with other type aliases with the same underlying type), while inline classes are not.</p>
<p id="ff2c32fb">In other words, inline classes introduce a truly <em id="769fe54c" class="">new</em> type, contrary to type aliases which only introduce an alternative name (alias) for an existing type:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">typealias NameTypeAlias = String @JvmInline value class NameInlineClass(val s: String) fun acceptString(s: String) {} fun acceptNameTypeAlias(n: NameTypeAlias) {} fun acceptNameInlineClass(p: NameInlineClass) {} fun main() { val nameAlias: NameTypeAlias = "" val nameInlineClass: NameInlineClass = NameInlineClass("") val string: String = "" acceptString(nameAlias) // OK: pass alias instead of underlying type acceptString(nameInlineClass) // Not OK: can't pass inline class instead of underlying type // And vice versa: acceptNameTypeAlias(string) // OK: pass underlying type instead of alias acceptNameInlineClass(string) // Not OK: can't pass underlying type instead of inline class } </pre></section><div class="last-modified"> Last modified: 05 May 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="enum-classes">Enum classes</a> <a class="navigation-links__next" href="object-declarations">Object expressions and declarations</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/inline-classes.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/inline-classes.html</a>
  </p>
</div>
