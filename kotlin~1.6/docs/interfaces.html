<h1 data-toc="interfaces" id="interfaces.md">Interfaces</h1>
<p id="8f8095de">Interfaces in Kotlin can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store a state. They can have properties, but these need to be abstract or provide accessor implementations.</p>
<p id="c44c4441">An interface is defined using the keyword <code class="code ">interface</code>:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">interface MyInterface { fun bar() fun foo() { // optional body } } </pre>
<section class="chapter"><h2 id="implementing-interfaces" data-toc="interfaces#implementing-interfaces">Implementing interfaces</h2>
<p id="975889f8">A class or object can implement one or more interfaces:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class Child : MyInterface { override fun bar() { // body } } </pre></section><section class="chapter"><h2 id="properties-in-interfaces" data-toc="interfaces#properties-in-interfaces">Properties in interfaces</h2>
<p id="cd0f4c87">You can declare properties in interfaces. A property declared in an interface can either be abstract or provide implementations for accessors. Properties declared in interfaces can't have backing fields, and therefore accessors declared in interfaces can't reference them:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">interface MyInterface { val prop: Int // abstract val propertyWithImplementation: String get() = "foo" fun foo() { print(prop) } } class Child : MyInterface { override val prop: Int = 29 } </pre></section><section class="chapter"><h2 id="interfaces-inheritance" data-toc="interfaces#interfaces-inheritance">Interfaces Inheritance</h2>
<p id="c41b87f2">An interface can derive from other interfaces, meaning it can both provide implementations for their members and declare new functions and properties. Quite naturally, classes implementing such an interface are only required to define the missing implementations:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">interface Named { val name: String } interface Person : Named { val firstName: String val lastName: String override val name: String get() = "$firstName $lastName" } data class Employee( // implementing 'name' is not required override val firstName: String, override val lastName: String, val position: Position ) : Person </pre></section><section class="chapter"><h2 id="resolving-overriding-conflicts" data-toc="interfaces#resolving-overriding-conflicts">Resolving overriding conflicts</h2>
<p id="f1334ce9">When you declare many types in your supertype list, you may inherit more than one implementation of the same method:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">interface A { fun foo() { print("A") } fun bar() } interface B { fun foo() { print("B") } fun bar() { print("bar") } } class C : A { override fun bar() { print("bar") } } class D : A, B { override fun foo() { super&lt;A&gt;.foo() super&lt;B&gt;.foo() } override fun bar() { super&lt;B&gt;.bar() } } </pre>
<p id="f1c863d">Interfaces <em id="6864a91" class="">A</em> and <em id="22481120" class="">B</em> both declare functions <em id="c004d2ea" class="">foo()</em> and <em id="2fad6158" class="">bar()</em>. Both of them implement <em id="2b53dbf3" class="">foo()</em>, but only <em id="65cc0426" class="">B</em> implements <em id="daec0e84" class="">bar()</em> (<em id="8370dc68" class="">bar()</em> is not marked as abstract in <em id="d70dcf6" class="">A</em>, because this is the default for interfaces if the function has no body). Now, if you derive a concrete class <em id="f7f5873c" class="">C</em> from <em id="2d60cdb9" class="">A</em>, you have to override <em id="b22c1861" class="">bar()</em> and provide an implementation.</p>
<p id="68bedd65">However, if you derive <em id="6b9a19cd" class="">D</em> from <em id="14c719b3" class="">A</em> and <em id="7d1c52dd" class="">B</em>, you need to implement all the methods that you have inherited from multiple interfaces, and you need to specify how exactly <em id="e2b809de" class="">D</em> should implement them. This rule applies both to methods for which you've inherited a single implementation (<em id="10fe9e0b" class="">bar()</em>) and to those for which you've inherited multiple implementations (<em id="ed0096c6" class="">foo()</em>).</p></section><div class="last-modified"> Last modified: 02 September 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="properties">Properties</a> <a class="navigation-links__next" href="fun-interfaces">Functional (SAM) interfaces</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/interfaces.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/interfaces.html</a>
  </p>
</div>
