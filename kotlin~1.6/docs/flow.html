<h1 data-toc="flow" id="flow.md">Asynchronous Flow</h1>
<p id="e28f09f3">A suspending function asynchronously returns a single value, but how can we return multiple asynchronously computed values? This is where Kotlin Flows come in.</p>
<section class="chapter"><h2 id="representing-multiple-values" data-toc="flow#representing-multiple-values">Representing multiple values</h2>
<p id="1ae3006b">Multiple values can be represented in Kotlin using <a href="collections-overview" id="4a0b404d" data-external="true" rel="noopener noreferrer">collections</a>. For example, we can have a <code class="code ">simple</code> function that returns a <a href="../api/latest/jvm/stdlib/kotlin.collections/-list/index" id="fe24e80e" data-external="true" rel="noopener noreferrer">List</a> of three numbers and then print them all using <a href="../api/latest/jvm/stdlib/kotlin.collections/for-each" id="912eb183" data-external="true" rel="noopener noreferrer">forEach</a>:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun simple(): List&lt;Int&gt; = listOf(1, 2, 3) fun main() { simple().forEach { value -&gt; println(value) } } </pre>
<aside data-type="note" class="prompt" data-title="" id="1fa32b63"><p id="24d75b1a">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-01.kt" id="92424064" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="f3b58a0b">This code outputs:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">1 2 3 </pre>
<section class="chapter"><h3 id="sequences" data-toc="flow#sequences">Sequences</h3>
<p id="dbbfa5c2">If we are computing the numbers with some CPU-consuming blocking code (each computation taking 100ms), then we can represent the numbers using a <a href="../api/latest/jvm/stdlib/kotlin.sequences/index" id="f0cc2b41" data-external="true" rel="noopener noreferrer">Sequence</a>:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun simple(): Sequence&lt;Int&gt; = sequence { // sequence builder for (i in 1..3) { Thread.sleep(100) // pretend we are computing it yield(i) // yield next value } } fun main() { simple().forEach { value -&gt; println(value) } } </pre>
<aside data-type="note" class="prompt" data-title="" id="90c307c5"><p id="d449b550">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-02.kt" id="aff05d85" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="37326b5f">This code outputs the same numbers, but it waits 100ms before printing each one.</p></section><section class="chapter"><h3 id="suspending-functions" data-toc="flow#suspending-functions">Suspending functions</h3>
<p id="f2eb8ab8">However, this computation blocks the main thread that is running the code. When these values are computed by asynchronous code we can mark the <code class="code ">simple</code> function with a <code class="code ">suspend</code> modifier, so that it can perform its work without blocking and return the result as a list:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* //sampleStart suspend fun simple(): List&lt;Int&gt; { delay(1000) // pretend we are doing something asynchronous here return listOf(1, 2, 3) } fun main() = runBlocking&lt;Unit&gt; { simple().forEach { value -&gt; println(value) } } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="fe326700"><p id="b381e2cf">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-03.kt" id="18c34469" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="8a1d3924">This code prints the numbers after waiting for a second.</p></section><section class="chapter"><h3 id="flows" data-toc="flow#flows">Flows</h3>
<p id="c464250c">Using the <code class="code ">List&lt;Int&gt;</code> result type, means we can only return all the values at once. To represent the stream of values that are being asynchronously computed, we can use a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html" id="d9f59a78" data-external="true" rel="noopener noreferrer"><code class="code ">Flow&lt;Int&gt;</code></a> type just like we would use the <code class="code ">Sequence&lt;Int&gt;</code> type for synchronously computed values:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* //sampleStart fun simple(): Flow&lt;Int&gt; = flow { // flow builder for (i in 1..3) { delay(100) // pretend we are doing something useful here emit(i) // emit next value } } fun main() = runBlocking&lt;Unit&gt; { // Launch a concurrent coroutine to check if the main thread is blocked launch { for (k in 1..3) { println("I'm not blocked $k") delay(100) } } // Collect the flow simple().collect { value -&gt; println(value) } } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="68b79f3"><p id="c4ddb085">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-04.kt" id="cfc9e8e4" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="8809b887">This code waits 100ms before printing each number without blocking the main thread. This is verified by printing "I'm not blocked" every 100ms from a separate coroutine that is running in the main thread:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">I'm not blocked 1 1 I'm not blocked 2 2 I'm not blocked 3 3 </pre>
<p id="3b617e93">Notice the following differences in the code with the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html" id="92a0d8ce" data-external="true" rel="noopener noreferrer">Flow</a> from the earlier examples:</p>
<ul class="list _ul" id="4f424f63">
<li class="list__item" id="a27a388f"><p>A builder function for <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html" id="2d7a8972" data-external="true" rel="noopener noreferrer">Flow</a> type is called <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow.html" id="6ce1f105" data-external="true" rel="noopener noreferrer">flow</a>.</p></li>
<li class="list__item" id="4d21f306"><p>Code inside the <code class="code ">flow { ... }</code> builder block can suspend.</p></li>
<li class="list__item" id="c33d54c8"><p>The <code class="code ">simple</code> function is no longer marked with <code class="code ">suspend</code> modifier.</p></li>
<li class="list__item" id="2a6691cb"><p>Values are <em id="61116e2d" class="">emitted</em> from the flow using <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html" id="e35dfdfc" data-external="true" rel="noopener noreferrer">emit</a> function.</p></li>
<li class="list__item" id="9dd8fa53"><p>Values are <em id="bd01e8a0" class="">collected</em> from the flow using <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html" id="fb1816b5" data-external="true" rel="noopener noreferrer">collect</a> function.</p></li>
</ul>
<aside data-type="note" class="prompt" data-title="" id="3d31445f"><p id="f876d98f">We can replace <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html" id="fa5baed7" data-external="true" rel="noopener noreferrer">delay</a> with <code class="code ">Thread.sleep</code> in the body of <code class="code ">simple</code>'s <code class="code ">flow { ... }</code> and see that the main thread is blocked in this case.</p></aside></section></section><section class="chapter"><h2 id="flows-are-cold" data-toc="flow#flows-are-cold">Flows are cold</h2>
<p id="9388a5a">Flows are <em id="8277c5fe" class="">cold</em> streams similar to sequences â€” the code inside a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow.html" id="99c14d4d" data-external="true" rel="noopener noreferrer">flow</a> builder does not run until the flow is collected. This becomes clear in the following example:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* //sampleStart fun simple(): Flow&lt;Int&gt; = flow { println("Flow started") for (i in 1..3) { delay(100) emit(i) } } fun main() = runBlocking&lt;Unit&gt; { println("Calling simple function...") val flow = simple() println("Calling collect...") flow.collect { value -&gt; println(value) } println("Calling collect again...") flow.collect { value -&gt; println(value) } } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="25a7a633"><p id="5784745b">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-05.kt" id="294f5af0" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="53c3bb4b">Which prints:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">Calling simple function... Calling collect... Flow started 1 2 3 Calling collect again... Flow started 1 2 3 </pre>
<p id="77ebb87b">This is a key reason the <code class="code ">simple</code> function (which returns a flow) is not marked with <code class="code ">suspend</code> modifier. By itself, <code class="code ">simple()</code> call returns quickly and does not wait for anything. The flow starts every time it is collected, that is why we see "Flow started" when we call <code class="code ">collect</code> again.</p></section><section class="chapter"><h2 id="flow-cancellation-basics" data-toc="flow#flow-cancellation-basics">Flow cancellation basics</h2>
<p id="402b2ca3">Flow adheres to the general cooperative cancellation of coroutines. As usual, flow collection can be cancelled when the flow is suspended in a cancellable suspending function (like <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html" id="94ffc8c5" data-external="true" rel="noopener noreferrer">delay</a>). The following example shows how the flow gets cancelled on a timeout when running in a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout-or-null.html" id="f353d213" data-external="true" rel="noopener noreferrer">withTimeoutOrNull</a> block and stops executing its code:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* //sampleStart fun simple(): Flow&lt;Int&gt; = flow { for (i in 1..3) { delay(100) println("Emitting $i") emit(i) } } fun main() = runBlocking&lt;Unit&gt; { withTimeoutOrNull(250) { // Timeout after 250ms simple().collect { value -&gt; println(value) } } println("Done") } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="1c24b7f1"><p id="27a26daa">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-06.kt" id="70f6a85a" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="9230f432">Notice how only two numbers get emitted by the flow in the <code class="code ">simple</code> function, producing the following output:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">Emitting 1 1 Emitting 2 2 Done </pre>
<p id="6fc95590">See <a href="#flow-cancellation-checks" id="c652548">Flow cancellation checks</a> section for more details.</p></section><section class="chapter"><h2 id="flow-builders" data-toc="flow#flow-builders">Flow builders</h2>
<p id="3d95986c">The <code class="code ">flow { ... }</code> builder from the previous examples is the most basic one. There are other builders for easier declaration of flows:</p>
<ul class="list _ul" id="512bb066">
<li class="list__item" id="4bb51839"><p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-of.html" id="7d9f3c70" data-external="true" rel="noopener noreferrer">flowOf</a> builder that defines a flow emitting a fixed set of values.</p></li>
<li class="list__item" id="fb0fcda3"><p>Various collections and sequences can be converted to flows using <code class="code ">.asFlow()</code> extension functions.</p></li>
</ul>
<p id="199737f3">So, the example that prints the numbers from 1 to 3 from a flow can be written as:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* fun main() = runBlocking&lt;Unit&gt; { //sampleStart // Convert an integer range to a flow (1..3).asFlow().collect { value -&gt; println(value) } //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="f2d8712d"><p id="546f690f">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-07.kt" id="77ba5f8" data-external="true" rel="noopener noreferrer">here</a>.</p></aside></section><section class="chapter"><h2 id="intermediate-flow-operators" data-toc="flow#intermediate-flow-operators">Intermediate flow operators</h2>
<p id="aa141cd1">Flows can be transformed with operators, just as you would with collections and sequences. Intermediate operators are applied to an upstream flow and return a downstream flow. These operators are cold, just like flows are. A call to such an operator is not a suspending function itself. It works quickly, returning the definition of a new transformed flow.</p>
<p id="e79886ee">The basic operators have familiar names like <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html" id="4e1891f3" data-external="true" rel="noopener noreferrer">map</a> and <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/filter.html" id="43cf52db" data-external="true" rel="noopener noreferrer">filter</a>. The important difference to sequences is that blocks of code inside these operators can call suspending functions.</p>
<p id="b2a7fb9c">For example, a flow of incoming requests can be mapped to the results with the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html" id="9e6ebf2c" data-external="true" rel="noopener noreferrer">map</a> operator, even when performing a request is a long-running operation that is implemented by a suspending function:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* //sampleStart suspend fun performRequest(request: Int): String { delay(1000) // imitate long-running asynchronous work return "response $request" } fun main() = runBlocking&lt;Unit&gt; { (1..3).asFlow() // a flow of requests .map { request -&gt; performRequest(request) } .collect { response -&gt; println(response) } } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="2be12c3f"><p id="30b793df">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-08.kt" id="2e060629" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="995d94ec">It produces the following three lines, each line appearing after each second:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">response 1 response 2 response 3 </pre>
<section class="chapter"><h3 id="transform-operator" data-toc="flow#transform-operator">Transform operator</h3>
<p id="95c008e8">Among the flow transformation operators, the most general one is called <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/transform.html" id="2cf4ae06" data-external="true" rel="noopener noreferrer">transform</a>. It can be used to imitate simple transformations like <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html" id="ee679890" data-external="true" rel="noopener noreferrer">map</a> and <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/filter.html" id="5ad3b42b" data-external="true" rel="noopener noreferrer">filter</a>, as well as implement more complex transformations. Using the <code class="code ">transform</code> operator, we can <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html" id="60cf3f28" data-external="true" rel="noopener noreferrer">emit</a> arbitrary values an arbitrary number of times.</p>
<p id="837671d7">For example, using <code class="code ">transform</code> we can emit a string before performing a long-running asynchronous request and follow it with a response:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* suspend fun performRequest(request: Int): String { delay(1000) // imitate long-running asynchronous work return "response $request" } fun main() = runBlocking&lt;Unit&gt; { //sampleStart (1..3).asFlow() // a flow of requests .transform { request -&gt; emit("Making request $request") emit(performRequest(request)) } .collect { response -&gt; println(response) } //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="cbb1f46a"><p id="9575b110">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-09.kt" id="98cc8cab" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="44c63432">The output of this code is:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">Making request 1 response 1 Making request 2 response 2 Making request 3 response 3 </pre></section><section class="chapter"><h3 id="size-limiting-operators" data-toc="flow#size-limiting-operators">Size-limiting operators</h3>
<p id="9f0e4180">Size-limiting intermediate operators like <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/take.html" id="b0c461b4" data-external="true" rel="noopener noreferrer">take</a> cancel the execution of the flow when the corresponding limit is reached. Cancellation in coroutines is always performed by throwing an exception, so that all the resource-management functions (like <code class="code ">try { ... } finally { ... }</code> blocks) operate normally in case of cancellation:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* //sampleStart fun numbers(): Flow&lt;Int&gt; = flow { try { emit(1) emit(2) println("This line will not execute") emit(3) } finally { println("Finally in numbers") } } fun main() = runBlocking&lt;Unit&gt; { numbers() .take(2) // take only the first two .collect { value -&gt; println(value) } } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="e0887102"><p id="62ebdc04">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-10.kt" id="4aab2788" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="78fa4502">The output of this code clearly shows that the execution of the <code class="code ">flow { ... }</code> body in the <code class="code ">numbers()</code> function stopped after emitting the second number:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">1 2 Finally in numbers </pre></section></section><section class="chapter"><h2 id="terminal-flow-operators" data-toc="flow#terminal-flow-operators">Terminal flow operators</h2>
<p id="ef3a1ca">Terminal operators on flows are <em id="5fcf5628" class="">suspending functions</em> that start a collection of the flow. The <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html" id="611df514" data-external="true" rel="noopener noreferrer">collect</a> operator is the most basic one, but there are other terminal operators, which can make it easier:</p>
<ul class="list _ul" id="c2f66e40">
<li class="list__item" id="9edc919"><p>Conversion to various collections like <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-list.html" id="c9912f9b" data-external="true" rel="noopener noreferrer">toList</a> and <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-set.html" id="7aaa39a6" data-external="true" rel="noopener noreferrer">toSet</a>.</p></li>
<li class="list__item" id="ffc9cf77"><p>Operators to get the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/first.html" id="1f91bcb2" data-external="true" rel="noopener noreferrer">first</a> value and to ensure that a flow emits a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/single.html" id="6b5f7765" data-external="true" rel="noopener noreferrer">single</a> value.</p></li>
<li class="list__item" id="5e2dff5a"><p>Reducing a flow to a value with <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/reduce.html" id="7752b599" data-external="true" rel="noopener noreferrer">reduce</a> and <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/fold.html" id="d180d7a1" data-external="true" rel="noopener noreferrer">fold</a>.</p></li>
</ul>
<p id="e3eaa768">For example:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* fun main() = runBlocking&lt;Unit&gt; { //sampleStart val sum = (1..5).asFlow() .map { it * it } // squares of numbers from 1 to 5 .reduce { a, b -&gt; a + b } // sum them (terminal operator) println(sum) //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="5fa4ba05"><p id="2724db5d">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-11.kt" id="e80549dc" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="52695018">Prints a single number:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">55 </pre></section><section class="chapter"><h2 id="flows-are-sequential" data-toc="flow#flows-are-sequential">Flows are sequential</h2>
<p id="e94a2966">Each individual collection of a flow is performed sequentially unless special operators that operate on multiple flows are used. The collection works directly in the coroutine that calls a terminal operator. No new coroutines are launched by default. Each emitted value is processed by all the intermediate operators from upstream to downstream and is then delivered to the terminal operator after.</p>
<p id="2b3c40a">See the following example that filters the even integers and maps them to strings:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* fun main() = runBlocking&lt;Unit&gt; { //sampleStart (1..5).asFlow() .filter { println("Filter $it") it % 2 == 0 } .map { println("Map $it") "string $it" }.collect { println("Collect $it") } //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="e5ca9e86"><p id="27478a8b">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-12.kt" id="9cdd24f2" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="c4e2233e">Producing:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">Filter 1 Filter 2 Map 2 Collect string 2 Filter 3 Filter 4 Map 4 Collect string 4 Filter 5 </pre></section><section class="chapter"><h2 id="flow-context" data-toc="flow#flow-context">Flow context</h2>
<p id="bdf33575">Collection of a flow always happens in the context of the calling coroutine. For example, if there is a <code class="code ">simple</code> flow, then the following code runs in the context specified by the author of this code, regardless of the implementation details of the <code class="code ">simple</code> flow:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">withContext(context) { simple().collect { value -&gt; println(value) // run in the specified context } } </pre>
<p id="25b75ff8">This property of a flow is called <em id="9b4bd707" class="">context preservation</em>.</p>
<p id="f53dad32">So, by default, code in the <code class="code ">flow { ... }</code> builder runs in the context that is provided by a collector of the corresponding flow. For example, consider the implementation of a <code class="code ">simple</code> function that prints the thread it is called on and emits three numbers:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* fun log(msg: String) = println("[${Thread.currentThread().name}] $msg") //sampleStart fun simple(): Flow&lt;Int&gt; = flow { log("Started simple flow") for (i in 1..3) { emit(i) } } fun main() = runBlocking&lt;Unit&gt; { simple().collect { value -&gt; log("Collected $value") } } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="1498e3"><p id="c575edab">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-13.kt" id="52df51d7" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="242127c0">Running this code produces:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">[main @coroutine#1] Started simple flow [main @coroutine#1] Collected 1 [main @coroutine#1] Collected 2 [main @coroutine#1] Collected 3 </pre>
<p id="ddf5a5cf">Since <code class="code ">simple().collect</code> is called from the main thread, the body of <code class="code ">simple</code>'s flow is also called in the main thread. This is the perfect default for fast-running or asynchronous code that does not care about the execution context and does not block the caller.</p>
<section class="chapter"><h3 id="wrong-emission-withcontext" data-toc="flow#wrong-emission-withcontext">Wrong emission withContext</h3>
<p id="931f7cc">However, the long-running CPU-consuming code might need to be executed in the context of <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html" id="fe6b0a77" data-external="true" rel="noopener noreferrer">Dispatchers.Default</a> and UI-updating code might need to be executed in the context of <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html" id="b38e2f0f" data-external="true" rel="noopener noreferrer">Dispatchers.Main</a>. Usually, <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html" id="b8fb7bf9" data-external="true" rel="noopener noreferrer">withContext</a> is used to change the context in the code using Kotlin coroutines, but code in the <code class="code ">flow { ... }</code> builder has to honor the context preservation property and is not allowed to <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html" id="2419f9" data-external="true" rel="noopener noreferrer">emit</a> from a different context.</p>
<p id="f66ef231">Try running the following code:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* //sampleStart fun simple(): Flow&lt;Int&gt; = flow { // The WRONG way to change context for CPU-consuming code in flow builder kotlinx.coroutines.withContext(Dispatchers.Default) { for (i in 1..3) { Thread.sleep(100) // pretend we are computing it in CPU-consuming way emit(i) // emit next value } } } fun main() = runBlocking&lt;Unit&gt; { simple().collect { value -&gt; println(value) } } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="4886319d"><p id="7dedfe28">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-14.kt" id="e4685a08" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="f46dfe86">This code produces the following exception:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">Exception in thread "main" java.lang.IllegalStateException: Flow invariant is violated: Flow was collected in [CoroutineId(1), "coroutine#1":BlockingCoroutine{Active}@5511c7f8, BlockingEventLoop@2eac3323], but emission happened in [CoroutineId(1), "coroutine#1":DispatchedCoroutine{Active}@2dae0000, Dispatchers.Default]. Please refer to 'flow' documentation or use 'flowOn' instead at ... </pre></section><section class="chapter"><h3 id="flowon-operator" data-toc="flow#flowon-operator">flowOn operator</h3>
<p id="f76502f0">The exception refers to the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html" id="72077f38" data-external="true" rel="noopener noreferrer">flowOn</a> function that shall be used to change the context of the flow emission. The correct way to change the context of a flow is shown in the example below, which also prints the names of the corresponding threads to show how it all works:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* fun log(msg: String) = println("[${Thread.currentThread().name}] $msg") //sampleStart fun simple(): Flow&lt;Int&gt; = flow { for (i in 1..3) { Thread.sleep(100) // pretend we are computing it in CPU-consuming way log("Emitting $i") emit(i) // emit next value } }.flowOn(Dispatchers.Default) // RIGHT way to change context for CPU-consuming code in flow builder fun main() = runBlocking&lt;Unit&gt; { simple().collect { value -&gt; log("Collected $value") } } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="f1c20b5"><p id="b2db5dfd">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-15.kt" id="d1e5879b" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="4f19925">Notice how <code class="code ">flow { ... }</code> works in the background thread, while collection happens in the main thread:</p>
<p id="e399e0a1">Another thing to observe here is that the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html" id="94363c53" data-external="true" rel="noopener noreferrer">flowOn</a> operator has changed the default sequential nature of the flow. Now collection happens in one coroutine ("coroutine#1") and emission happens in another coroutine ("coroutine#2") that is running in another thread concurrently with the collecting coroutine. The <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html" id="eebf5e05" data-external="true" rel="noopener noreferrer">flowOn</a> operator creates another coroutine for an upstream flow when it has to change the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html" id="aef07dde" data-external="true" rel="noopener noreferrer">CoroutineDispatcher</a> in its context.</p></section></section><section class="chapter"><h2 id="buffering" data-toc="flow#buffering">Buffering</h2>
<p id="a9248e8a">Running different parts of a flow in different coroutines can be helpful from the standpoint of the overall time it takes to collect the flow, especially when long-running asynchronous operations are involved. For example, consider a case when the emission by a <code class="code ">simple</code> flow is slow, taking 100 ms to produce an element; and collector is also slow, taking 300 ms to process an element. Let's see how long it takes to collect such a flow with three numbers:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* import kotlin.system.* //sampleStart fun simple(): Flow&lt;Int&gt; = flow { for (i in 1..3) { delay(100) // pretend we are asynchronously waiting 100 ms emit(i) // emit next value } } fun main() = runBlocking&lt;Unit&gt; { val time = measureTimeMillis { simple().collect { value -&gt; delay(300) // pretend we are processing it for 300 ms println(value) } } println("Collected in $time ms") } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="94a46a0a"><p id="c0616d23">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-16.kt" id="2fba5599" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="c4769a3f">It produces something like this, with the whole collection taking around 1200 ms (three numbers, 400 ms for each):</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">1 2 3 Collected in 1220 ms </pre>
<p id="cc6bbae0">We can use a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html" id="9e71ac11" data-external="true" rel="noopener noreferrer">buffer</a> operator on a flow to run emitting code of the <code class="code ">simple</code> flow concurrently with collecting code, as opposed to running them sequentially:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* import kotlin.system.* fun simple(): Flow&lt;Int&gt; = flow { for (i in 1..3) { delay(100) // pretend we are asynchronously waiting 100 ms emit(i) // emit next value } } fun main() = runBlocking&lt;Unit&gt; { //sampleStart val time = measureTimeMillis { simple() .buffer() // buffer emissions, don't wait .collect { value -&gt; delay(300) // pretend we are processing it for 300 ms println(value) } } println("Collected in $time ms") //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="e1b1a513"><p id="927eb4fa">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-17.kt" id="cc30f3b6" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="460700d8">It produces the same numbers just faster, as we have effectively created a processing pipeline, having to only wait 100 ms for the first number and then spending only 300 ms to process each number. This way it takes around 1000 ms to run:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">1 2 3 Collected in 1071 ms </pre>
<aside data-type="note" class="prompt" data-title="" id="ea3f2b61"><p id="3f061498">Note that the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html" id="8bf9f8ca" data-external="true" rel="noopener noreferrer">flowOn</a> operator uses the same buffering mechanism when it has to change a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html" id="93f073d0" data-external="true" rel="noopener noreferrer">CoroutineDispatcher</a>, but here we explicitly request buffering without changing the execution context.</p></aside><section class="chapter"><h3 id="conflation" data-toc="flow#conflation">Conflation</h3>
<p id="4ca146ea">When a flow represents partial results of the operation or operation status updates, it may not be necessary to process each value, but instead, only most recent ones. In this case, the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html" id="cb6637fa" data-external="true" rel="noopener noreferrer">conflate</a> operator can be used to skip intermediate values when a collector is too slow to process them. Building on the previous example:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* import kotlin.system.* fun simple(): Flow&lt;Int&gt; = flow { for (i in 1..3) { delay(100) // pretend we are asynchronously waiting 100 ms emit(i) // emit next value } } fun main() = runBlocking&lt;Unit&gt; { //sampleStart val time = measureTimeMillis { simple() .conflate() // conflate emissions, don't process each one .collect { value -&gt; delay(300) // pretend we are processing it for 300 ms println(value) } } println("Collected in $time ms") //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="3cd411b5"><p id="85398008">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-18.kt" id="81c9e596" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="6920643c">We see that while the first number was still being processed the second, and third were already produced, so the second one was <em id="28cadf27" class="">conflated</em> and only the most recent (the third one) was delivered to the collector:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">1 3 Collected in 758 ms </pre></section><section class="chapter"><h3 id="processing-the-latest-value" data-toc="flow#processing-the-latest-value">Processing the latest value</h3>
<p id="528f861b">Conflation is one way to speed up processing when both the emitter and collector are slow. It does it by dropping emitted values. The other way is to cancel a slow collector and restart it every time a new value is emitted. There is a family of <code class="code ">xxxLatest</code> operators that perform the same essential logic of a <code class="code ">xxx</code> operator, but cancel the code in their block on a new value. Let's try changing <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html" id="26a7158" data-external="true" rel="noopener noreferrer">conflate</a> to <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html" id="45e9193d" data-external="true" rel="noopener noreferrer">collectLatest</a> in the previous example:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* import kotlin.system.* fun simple(): Flow&lt;Int&gt; = flow { for (i in 1..3) { delay(100) // pretend we are asynchronously waiting 100 ms emit(i) // emit next value } } fun main() = runBlocking&lt;Unit&gt; { //sampleStart val time = measureTimeMillis { simple() .collectLatest { value -&gt; // cancel &amp; restart on the latest value println("Collecting $value") delay(300) // pretend we are processing it for 300 ms println("Done $value") } } println("Collected in $time ms") //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="5686437e"><p id="e065ad91">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-19.kt" id="b56edaa5" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="bb728a1">Since the body of <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html" id="36dd1f4" data-external="true" rel="noopener noreferrer">collectLatest</a> takes 300 ms, but new values are emitted every 100 ms, we see that the block is run on every value, but completes only for the last value:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">Collecting 1 Collecting 2 Collecting 3 Done 3 Collected in 741 ms </pre></section></section><section class="chapter"><h2 id="composing-multiple-flows" data-toc="flow#composing-multiple-flows">Composing multiple flows</h2>
<p id="d42de743">There are lots of ways to compose multiple flows.</p>
<section class="chapter"><h3 id="zip" data-toc="flow#zip">Zip</h3>
<p id="5002c228">Just like the <a href="../api/latest/jvm/stdlib/kotlin.sequences/zip" id="34f3ccf0" data-external="true" rel="noopener noreferrer">Sequence.zip</a> extension function in the Kotlin standard library, flows have a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html" id="ab974c81" data-external="true" rel="noopener noreferrer">zip</a> operator that combines the corresponding values of two flows:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* fun main() = runBlocking&lt;Unit&gt; { //sampleStart val nums = (1..3).asFlow() // numbers 1..3 val strs = flowOf("one", "two", "three") // strings nums.zip(strs) { a, b -&gt; "$a -&gt; $b" } // compose a single string .collect { println(it) } // collect and print //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="fd6f533b"><p id="db32037c">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-20.kt" id="f770aa6f" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="f123d57d">This example prints:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">1 -&gt; one 2 -&gt; two 3 -&gt; three </pre></section><section class="chapter"><h3 id="combine" data-toc="flow#combine">Combine</h3>
<p id="9abf4a03">When flow represents the most recent value of a variable or operation (see also the related section on <a href="#conflation" id="63d5d3b0">conflation</a>), it might be needed to perform a computation that depends on the most recent values of the corresponding flows and to recompute it whenever any of the upstream flows emit a value. The corresponding family of operators is called <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html" id="7ec899a4" data-external="true" rel="noopener noreferrer">combine</a>.</p>
<p id="70f42178">For example, if the numbers in the previous example update every 300ms, but strings update every 400 ms, then zipping them using the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html" id="d497481c" data-external="true" rel="noopener noreferrer">zip</a> operator will still produce the same result, albeit results that are printed every 400 ms:</p>
<aside data-type="note" class="prompt" data-title="" id="4263fded"><p id="14d9b3a0">We use a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html" id="a718903a" data-external="true" rel="noopener noreferrer">onEach</a> intermediate operator in this example to delay each element and make the code that emits sample flows more declarative and shorter.</p></aside><pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* fun main() = runBlocking&lt;Unit&gt; { //sampleStart val nums = (1..3).asFlow().onEach { delay(300) } // numbers 1..3 every 300 ms val strs = flowOf("one", "two", "three").onEach { delay(400) } // strings every 400 ms val startTime = System.currentTimeMillis() // remember the start time nums.zip(strs) { a, b -&gt; "$a -&gt; $b" } // compose a single string with "zip" .collect { value -&gt; // collect and print println("$value at ${System.currentTimeMillis() - startTime} ms from start") } //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="f9fd46de"><p id="ac29eff9">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-21.kt" id="b5039567" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="c5e5e3a3">However, when using a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html" id="b83b1fdc" data-external="true" rel="noopener noreferrer">combine</a> operator here instead of a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html" id="bce4965e" data-external="true" rel="noopener noreferrer">zip</a>:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* fun main() = runBlocking&lt;Unit&gt; { //sampleStart val nums = (1..3).asFlow().onEach { delay(300) } // numbers 1..3 every 300 ms val strs = flowOf("one", "two", "three").onEach { delay(400) } // strings every 400 ms val startTime = System.currentTimeMillis() // remember the start time nums.combine(strs) { a, b -&gt; "$a -&gt; $b" } // compose a single string with "combine" .collect { value -&gt; // collect and print println("$value at ${System.currentTimeMillis() - startTime} ms from start") } //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="2727e4f0"><p id="f9635eb3">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-22.kt" id="aa740bea" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="6458f809">We get quite a different output, where a line is printed at each emission from either <code class="code ">nums</code> or <code class="code ">strs</code> flows:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">1 -&gt; one at 452 ms from start 2 -&gt; one at 651 ms from start 2 -&gt; two at 854 ms from start 3 -&gt; two at 952 ms from start 3 -&gt; three at 1256 ms from start </pre></section></section><section class="chapter"><h2 id="flattening-flows" data-toc="flow#flattening-flows">Flattening flows</h2>
<p id="50b1ebf7">Flows represent asynchronously received sequences of values, so it is quite easy to get in a situation where each value triggers a request for another sequence of values. For example, we can have the following function that returns a flow of two strings 500 ms apart:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun requestFlow(i: Int): Flow&lt;String&gt; = flow { emit("$i: First") delay(500) // wait 500 ms emit("$i: Second") } </pre>
<p id="88938a5">Now if we have a flow of three integers and call <code class="code ">requestFlow</code> for each of them like this:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">(1..3).asFlow().map { requestFlow(it) } </pre>
<p id="af09e7dc">Then we end up with a flow of flows (<code class="code ">Flow&lt;Flow&lt;String&gt;&gt;</code>) that needs to be <em id="625f252b" class="">flattened</em> into a single flow for further processing. Collections and sequences have <a href="../api/latest/jvm/stdlib/kotlin.sequences/flatten" id="5a65bf59" data-external="true" rel="noopener noreferrer">flatten</a> and <a href="../api/latest/jvm/stdlib/kotlin.sequences/flat-map" id="b3e735d3" data-external="true" rel="noopener noreferrer">flatMap</a> operators for this. However, due to the asynchronous nature of flows they call for different <em id="f05a83d9" class="">modes</em> of flattening, as such, there is a family of flattening operators on flows.</p>
<section class="chapter"><h3 id="flatmapconcat" data-toc="flow#flatmapconcat">flatMapConcat</h3>
<p id="cee53fa5">Concatenating mode is implemented by <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-concat.html" id="acd22a74" data-external="true" rel="noopener noreferrer">flatMapConcat</a> and <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flatten-concat.html" id="a547de1e" data-external="true" rel="noopener noreferrer">flattenConcat</a> operators. They are the most direct analogues of the corresponding sequence operators. They wait for the inner flow to complete before starting to collect the next one as the following example shows:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* fun requestFlow(i: Int): Flow&lt;String&gt; = flow { emit("$i: First") delay(500) // wait 500 ms emit("$i: Second") } fun main() = runBlocking&lt;Unit&gt; { //sampleStart val startTime = System.currentTimeMillis() // remember the start time (1..3).asFlow().onEach { delay(100) } // a number every 100 ms .flatMapConcat { requestFlow(it) } .collect { value -&gt; // collect and print println("$value at ${System.currentTimeMillis() - startTime} ms from start") } //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="91a4c16"><p id="9fa7c96d">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-23.kt" id="f416592d" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="5c7d6c3c">The sequential nature of <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-concat.html" id="d3a422c0" data-external="true" rel="noopener noreferrer">flatMapConcat</a> is clearly seen in the output:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">1: First at 121 ms from start 1: Second at 622 ms from start 2: First at 727 ms from start 2: Second at 1227 ms from start 3: First at 1328 ms from start 3: Second at 1829 ms from start </pre></section><section class="chapter"><h3 id="flatmapmerge" data-toc="flow#flatmapmerge">flatMapMerge</h3>
<p id="686283b3">Another flattening mode is to concurrently collect all the incoming flows and merge their values into a single flow so that values are emitted as soon as possible. It is implemented by <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-merge.html" id="ecaf8782" data-external="true" rel="noopener noreferrer">flatMapMerge</a> and <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flatten-merge.html" id="d3c6d396" data-external="true" rel="noopener noreferrer">flattenMerge</a> operators. They both accept an optional <code class="code ">concurrency</code> parameter that limits the number of concurrent flows that are collected at the same time (it is equal to <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-d-e-f-a-u-l-t_-c-o-n-c-u-r-r-e-n-c-y.html" id="9d45d4f4" data-external="true" rel="noopener noreferrer">DEFAULT_CONCURRENCY</a> by default).</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* fun requestFlow(i: Int): Flow&lt;String&gt; = flow { emit("$i: First") delay(500) // wait 500 ms emit("$i: Second") } fun main() = runBlocking&lt;Unit&gt; { //sampleStart val startTime = System.currentTimeMillis() // remember the start time (1..3).asFlow().onEach { delay(100) } // a number every 100 ms .flatMapMerge { requestFlow(it) } .collect { value -&gt; // collect and print println("$value at ${System.currentTimeMillis() - startTime} ms from start") } //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="4c786bca"><p id="2b309877">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-24.kt" id="a9373076" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="4437a790">The concurrent nature of <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-merge.html" id="a27300a3" data-external="true" rel="noopener noreferrer">flatMapMerge</a> is obvious:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">1: First at 136 ms from start 2: First at 231 ms from start 3: First at 333 ms from start 1: Second at 639 ms from start 2: Second at 732 ms from start 3: Second at 833 ms from start </pre>
<aside data-type="note" class="prompt" data-title="" id="1d5d9ef8"><p id="ed0bd482">Note that the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-merge.html" id="3bdc1394" data-external="true" rel="noopener noreferrer">flatMapMerge</a> calls its block of code (<code class="code ">{ requestFlow(it) }</code> in this example) sequentially, but collects the resulting flows concurrently, it is the equivalent of performing a sequential <code class="code ">map { requestFlow(it) }</code> first and then calling <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flatten-merge.html" id="bc72bb08" data-external="true" rel="noopener noreferrer">flattenMerge</a> on the result.</p></aside></section><section class="chapter"><h3 id="flatmaplatest" data-toc="flow#flatmaplatest">flatMapLatest</h3>
<p id="f7f5a38a">In a similar way to the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html" id="d79f7c8d" data-external="true" rel="noopener noreferrer">collectLatest</a> operator, that was shown in <a href="#processing-the-latest-value" id="cb781a7f">"Processing the latest value"</a> section, there is the corresponding "Latest" flattening mode where a collection of the previous flow is cancelled as soon as new flow is emitted. It is implemented by the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html" id="dc9759f2" data-external="true" rel="noopener noreferrer">flatMapLatest</a> operator.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* fun requestFlow(i: Int): Flow&lt;String&gt; = flow { emit("$i: First") delay(500) // wait 500 ms emit("$i: Second") } fun main() = runBlocking&lt;Unit&gt; { //sampleStart val startTime = System.currentTimeMillis() // remember the start time (1..3).asFlow().onEach { delay(100) } // a number every 100 ms .flatMapLatest { requestFlow(it) } .collect { value -&gt; // collect and print println("$value at ${System.currentTimeMillis() - startTime} ms from start") } //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="27270761"><p id="7e62e928">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-25.kt" id="fc5d8145" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="30acae6a">The output here in this example is a good demonstration of how <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html" id="1cf16f8f" data-external="true" rel="noopener noreferrer">flatMapLatest</a> works:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">1: First at 142 ms from start 2: First at 322 ms from start 3: First at 425 ms from start 3: Second at 931 ms from start </pre>
<aside data-type="note" class="prompt" data-title="" id="40f38b1a"><p id="62060016">Note that <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html" id="468c2c9c" data-external="true" rel="noopener noreferrer">flatMapLatest</a> cancels all the code in its block (<code class="code ">{ requestFlow(it) }</code> in this example) on a new value. It makes no difference in this particular example, because the call to <code class="code ">requestFlow</code> itself is fast, not-suspending, and cannot be cancelled. However, it would show up if we were to use suspending functions like <code class="code ">delay</code> in there.</p></aside></section></section><section class="chapter"><h2 id="flow-exceptions" data-toc="flow#flow-exceptions">Flow exceptions</h2>
<p id="49fe9725">Flow collection can complete with an exception when an emitter or code inside the operators throw an exception. There are several ways to handle these exceptions.</p>
<section class="chapter"><h3 id="collector-try-and-catch" data-toc="flow#collector-try-and-catch">Collector try and catch</h3>
<p id="c831c975">A collector can use Kotlin's <a href="exceptions" id="be540569" data-external="true" rel="noopener noreferrer"><code class="code ">try/catch</code></a> block to handle exceptions:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* //sampleStart fun simple(): Flow&lt;Int&gt; = flow { for (i in 1..3) { println("Emitting $i") emit(i) // emit next value } } fun main() = runBlocking&lt;Unit&gt; { try { simple().collect { value -&gt; println(value) check(value &lt;= 1) { "Collected $value" } } } catch (e: Throwable) { println("Caught $e") } } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="b0c84e6b"><p id="c0b9e178">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-26.kt" id="5dc0bda9" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="fb1b24b6">This code successfully catches an exception in <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html" id="bcdc77f" data-external="true" rel="noopener noreferrer">collect</a> terminal operator and, as we see, no more values are emitted after that:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">Emitting 1 1 Emitting 2 2 Caught java.lang.IllegalStateException: Collected 2 </pre></section><section class="chapter"><h3 id="everything-is-caught" data-toc="flow#everything-is-caught">Everything is caught</h3>
<p id="e32f1573">The previous example actually catches any exception happening in the emitter or in any intermediate or terminal operators. For example, let's change the code so that emitted values are <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html" id="88dc3f63" data-external="true" rel="noopener noreferrer">mapped</a> to strings, but the corresponding code produces an exception:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* //sampleStart fun simple(): Flow&lt;String&gt; = flow { for (i in 1..3) { println("Emitting $i") emit(i) // emit next value } } .map { value -&gt; check(value &lt;= 1) { "Crashed on $value" } "string $value" } fun main() = runBlocking&lt;Unit&gt; { try { simple().collect { value -&gt; println(value) } } catch (e: Throwable) { println("Caught $e") } } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="eed0cb24"><p id="d5cfde39">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-27.kt" id="87adc805" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="4fe423b0">This exception is still caught and collection is stopped:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">Emitting 1 string 1 Emitting 2 Caught java.lang.IllegalStateException: Crashed on 2 </pre></section></section><section class="chapter"><h2 id="exception-transparency" data-toc="flow#exception-transparency">Exception transparency</h2>
<p id="c6204287">But how can code of the emitter encapsulate its exception handling behavior?</p>
<p id="fd6f0f85">Flows must be <em id="49f76f51" class="">transparent to exceptions</em> and it is a violation of the exception transparency to <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html" id="2b8608f6" data-external="true" rel="noopener noreferrer">emit</a> values in the <code class="code ">flow { ... }</code> builder from inside of a <code class="code ">try/catch</code> block. This guarantees that a collector throwing an exception can always catch it using <code class="code ">try/catch</code> as in the previous example.</p>
<p id="e2b8d195">The emitter can use a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html" id="9488a014" data-external="true" rel="noopener noreferrer">catch</a> operator that preserves this exception transparency and allows encapsulation of its exception handling. The body of the <code class="code ">catch</code> operator can analyze an exception and react to it in different ways depending on which exception was caught:</p>
<ul class="list _ul" id="4b15d06e">
<li class="list__item" id="922a75db"><p>Exceptions can be rethrown using <code class="code ">throw</code>.</p></li>
<li class="list__item" id="6f8129d8"><p>Exceptions can be turned into emission of values using <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html" id="97e8c190" data-external="true" rel="noopener noreferrer">emit</a> from the body of <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html" id="78e091bf" data-external="true" rel="noopener noreferrer">catch</a>.</p></li>
<li class="list__item" id="538f4727"><p>Exceptions can be ignored, logged, or processed by some other code.</p></li>
</ul>
<p id="968ff6d5">For example, let us emit the text on catching an exception:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* fun simple(): Flow&lt;String&gt; = flow { for (i in 1..3) { println("Emitting $i") emit(i) // emit next value } } .map { value -&gt; check(value &lt;= 1) { "Crashed on $value" } "string $value" } fun main() = runBlocking&lt;Unit&gt; { //sampleStart simple() .catch { e -&gt; emit("Caught $e") } // emit on exception .collect { value -&gt; println(value) } //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="b70c675d"><p id="d6f509a6">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-28.kt" id="3aa05969" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="b228e121">The output of the example is the same, even though we do not have <code class="code ">try/catch</code> around the code anymore.</p>
<section class="chapter"><h3 id="transparent-catch" data-toc="flow#transparent-catch">Transparent catch</h3>
<p id="26bd0a0c">The <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html" id="5918e366" data-external="true" rel="noopener noreferrer">catch</a> intermediate operator, honoring exception transparency, catches only upstream exceptions (that is an exception from all the operators above <code class="code ">catch</code>, but not below it). If the block in <code class="code ">collect { ... }</code> (placed below <code class="code ">catch</code>) throws an exception then it escapes:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* //sampleStart fun simple(): Flow&lt;Int&gt; = flow { for (i in 1..3) { println("Emitting $i") emit(i) } } fun main() = runBlocking&lt;Unit&gt; { simple() .catch { e -&gt; println("Caught $e") } // does not catch downstream exceptions .collect { value -&gt; check(value &lt;= 1) { "Collected $value" } println(value) } } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="78775f4b"><p id="c77f3417">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-29.kt" id="a279026e" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="cc81e911">A "Caught ..." message is not printed despite there being a <code class="code ">catch</code> operator:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">Emitting 1 1 Emitting 2 Exception in thread "main" java.lang.IllegalStateException: Collected 2 at ... </pre></section><section class="chapter"><h3 id="catching-declaratively" data-toc="flow#catching-declaratively">Catching declaratively</h3>
<p id="4f57198e">We can combine the declarative nature of the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html" id="c2aae705" data-external="true" rel="noopener noreferrer">catch</a> operator with a desire to handle all the exceptions, by moving the body of the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html" id="ecf41509" data-external="true" rel="noopener noreferrer">collect</a> operator into <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html" id="1bdc48b5" data-external="true" rel="noopener noreferrer">onEach</a> and putting it before the <code class="code ">catch</code> operator. Collection of this flow must be triggered by a call to <code class="code ">collect()</code> without parameters:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* fun simple(): Flow&lt;Int&gt; = flow { for (i in 1..3) { println("Emitting $i") emit(i) } } fun main() = runBlocking&lt;Unit&gt; { //sampleStart simple() .onEach { value -&gt; check(value &lt;= 1) { "Collected $value" } println(value) } .catch { e -&gt; println("Caught $e") } .collect() //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="95bb7d90"><p id="9092f07d">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-30.kt" id="c6b09a7d" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="84a7d7fa">Now we can see that a "Caught ..." message is printed and so we can catch all the exceptions without explicitly using a <code class="code ">try/catch</code> block:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">Emitting 1 1 Emitting 2 Caught java.lang.IllegalStateException: Collected 2 </pre></section></section><section class="chapter"><h2 id="flow-completion" data-toc="flow#flow-completion">Flow completion</h2>
<p id="7ebf2dd2">When flow collection completes (normally or exceptionally) it may need to execute an action. As you may have already noticed, it can be done in two ways: imperative or declarative.</p>
<section class="chapter"><h3 id="imperative-finally-block" data-toc="flow#imperative-finally-block">Imperative finally block</h3>
<p id="cf2d47ed">In addition to <code class="code ">try</code>/<code class="code ">catch</code>, a collector can also use a <code class="code ">finally</code> block to execute an action upon <code class="code ">collect</code> completion.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* //sampleStart fun simple(): Flow&lt;Int&gt; = (1..3).asFlow() fun main() = runBlocking&lt;Unit&gt; { try { simple().collect { value -&gt; println(value) } } finally { println("Done") } } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="f5e07faf"><p id="dfc46af0">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-31.kt" id="13a8f4e3" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="59db4504">This code prints three numbers produced by the <code class="code ">simple</code> flow followed by a "Done" string:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">1 2 3 Done </pre></section><section class="chapter"><h3 id="declarative-handling" data-toc="flow#declarative-handling">Declarative handling</h3>
<p id="3fd804e1">For the declarative approach, flow has <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-completion.html" id="af5bb624" data-external="true" rel="noopener noreferrer">onCompletion</a> intermediate operator that is invoked when the flow has completely collected.</p>
<p id="98825997">The previous example can be rewritten using an <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-completion.html" id="bf17c3fb" data-external="true" rel="noopener noreferrer">onCompletion</a> operator and produces the same output:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* fun simple(): Flow&lt;Int&gt; = (1..3).asFlow() fun main() = runBlocking&lt;Unit&gt; { //sampleStart simple() .onCompletion { println("Done") } .collect { value -&gt; println(value) } //sampleEnd } </pre>
<aside data-type="note" class="prompt" data-title="" id="e45c6beb"><p id="aa86f176">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-32.kt" id="5083960e" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="e29aa8f0">The key advantage of <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-completion.html" id="b2ed74e0" data-external="true" rel="noopener noreferrer">onCompletion</a> is a nullable <code class="code ">Throwable</code> parameter of the lambda that can be used to determine whether the flow collection was completed normally or exceptionally. In the following example the <code class="code ">simple</code> flow throws an exception after emitting the number 1:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* //sampleStart fun simple(): Flow&lt;Int&gt; = flow { emit(1) throw RuntimeException() } fun main() = runBlocking&lt;Unit&gt; { simple() .onCompletion { cause -&gt; if (cause != null) println("Flow completed exceptionally") } .catch { cause -&gt; println("Caught exception") } .collect { value -&gt; println(value) } } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="f2f5d9c4"><p id="557a9d3f">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-33.kt" id="c3306eaa" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="127eb0c">As you may expect, it prints:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">1 Flow completed exceptionally Caught exception </pre>
<p id="55719b44">The <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-completion.html" id="d566f57b" data-external="true" rel="noopener noreferrer">onCompletion</a> operator, unlike <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html" id="3adc163d" data-external="true" rel="noopener noreferrer">catch</a>, does not handle the exception. As we can see from the above example code, the exception still flows downstream. It will be delivered to further <code class="code ">onCompletion</code> operators and can be handled with a <code class="code ">catch</code> operator.</p></section><section class="chapter"><h3 id="successful-completion" data-toc="flow#successful-completion">Successful completion</h3>
<p id="af45cb69">Another difference with <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html" id="cb9e2497" data-external="true" rel="noopener noreferrer">catch</a> operator is that <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-completion.html" id="b621cb29" data-external="true" rel="noopener noreferrer">onCompletion</a> sees all exceptions and receives a <code class="code ">null</code> exception only on successful completion of the upstream flow (without cancellation or failure).</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* //sampleStart fun simple(): Flow&lt;Int&gt; = (1..3).asFlow() fun main() = runBlocking&lt;Unit&gt; { simple() .onCompletion { cause -&gt; println("Flow completed with $cause") } .collect { value -&gt; check(value &lt;= 1) { "Collected $value" } println(value) } } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="d54924b7"><p id="18d9473a">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-34.kt" id="3f80bbef" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="e06ea11f">We can see the completion cause is not null, because the flow was aborted due to downstream exception:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">1 Flow completed with java.lang.IllegalStateException: Collected 2 Exception in thread "main" java.lang.IllegalStateException: Collected 2 </pre></section></section><section class="chapter"><h2 id="imperative-versus-declarative" data-toc="flow#imperative-versus-declarative">Imperative versus declarative</h2>
<p id="54d4d804">Now we know how to collect flow, and handle its completion and exceptions in both imperative and declarative ways. The natural question here is, which approach is preferred and why? As a library, we do not advocate for any particular approach and believe that both options are valid and should be selected according to your own preferences and code style.</p></section><section class="chapter"><h2 id="launching-flow" data-toc="flow#launching-flow">Launching flow</h2>
<p id="9f778542">It is easy to use flows to represent asynchronous events that are coming from some source. In this case, we need an analogue of the <code class="code ">addEventListener</code> function that registers a piece of code with a reaction for incoming events and continues further work. The <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html" id="f6807741" data-external="true" rel="noopener noreferrer">onEach</a> operator can serve this role. However, <code class="code ">onEach</code> is an intermediate operator. We also need a terminal operator to collect the flow. Otherwise, just calling <code class="code ">onEach</code> has no effect.</p>
<p id="bd9eec67">If we use the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html" id="e1983ed4" data-external="true" rel="noopener noreferrer">collect</a> terminal operator after <code class="code ">onEach</code>, then the code after it will wait until the flow is collected:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* //sampleStart // Imitate a flow of events fun events(): Flow&lt;Int&gt; = (1..3).asFlow().onEach { delay(100) } fun main() = runBlocking&lt;Unit&gt; { events() .onEach { event -&gt; println("Event: $event") } .collect() // &lt;--- Collecting the flow waits println("Done") } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="ff66ace0"><p id="aa01a0c2">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-35.kt" id="816f0a30" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="9bd80808">As you can see, it prints:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">Event: 1 Event: 2 Event: 3 Done </pre>
<p id="9227b519">The <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/launch-in.html" id="767e2b7d" data-external="true" rel="noopener noreferrer">launchIn</a> terminal operator comes in handy here. By replacing <code class="code ">collect</code> with <code class="code ">launchIn</code> we can launch a collection of the flow in a separate coroutine, so that execution of further code immediately continues:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* // Imitate a flow of events fun events(): Flow&lt;Int&gt; = (1..3).asFlow().onEach { delay(100) } //sampleStart fun main() = runBlocking&lt;Unit&gt; { events() .onEach { event -&gt; println("Event: $event") } .launchIn(this) // &lt;--- Launching the flow in a separate coroutine println("Done") } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="4b7d7a4d"><p id="57063fc1">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-36.kt" id="7349f65e" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="874c715">It prints:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">Done Event: 1 Event: 2 Event: 3 </pre>
<p id="2d4e0f97">The required parameter to <code class="code ">launchIn</code> must specify a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html" id="138717ec" data-external="true" rel="noopener noreferrer">CoroutineScope</a> in which the coroutine to collect the flow is launched. In the above example this scope comes from the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html" id="7aecb329" data-external="true" rel="noopener noreferrer">runBlocking</a> coroutine builder, so while the flow is running, this <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html" id="8521ed25" data-external="true" rel="noopener noreferrer">runBlocking</a> scope waits for completion of its child coroutine and keeps the main function from returning and terminating this example.</p>
<p id="290aefed">In actual applications a scope will come from an entity with a limited lifetime. As soon as the lifetime of this entity is terminated the corresponding scope is cancelled, cancelling the collection of the corresponding flow. This way the pair of <code class="code ">onEach { ... }.launchIn(scope)</code> works like the <code class="code ">addEventListener</code>. However, there is no need for the corresponding <code class="code ">removeEventListener</code> function, as cancellation and structured concurrency serve this purpose.</p>
<p id="516986d9">Note that <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/launch-in.html" id="29f493a1" data-external="true" rel="noopener noreferrer">launchIn</a> also returns a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html" id="7e4efcee" data-external="true" rel="noopener noreferrer">Job</a>, which can be used to <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel.html" id="aeea615a" data-external="true" rel="noopener noreferrer">cancel</a> the corresponding flow collection coroutine only without cancelling the whole scope or to <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html" id="c36cca69" data-external="true" rel="noopener noreferrer">join</a> it.</p>
<section class="chapter"><h3 id="flow-cancellation-checks" data-toc="flow#flow-cancellation-checks">Flow cancellation checks</h3>
<p id="145cfd84">For convenience, the <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow.html" id="4ff81977" data-external="true" rel="noopener noreferrer">flow</a> builder performs additional <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/ensure-active.html" id="12e2ea0a" data-external="true" rel="noopener noreferrer">ensureActive</a> checks for cancellation on each emitted value. It means that a busy loop emitting from a <code class="code ">flow { ... }</code> is cancellable:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* //sampleStart fun foo(): Flow&lt;Int&gt; = flow { for (i in 1..5) { println("Emitting $i") emit(i) } } fun main() = runBlocking&lt;Unit&gt; { foo().collect { value -&gt; if (value == 3) cancel() println(value) } } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="6eed6f17"><p id="ac38e56f">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-37.kt" id="cea26a76" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="830f021a">We get only numbers up to 3 and a <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html" id="621b8abe" data-external="true" rel="noopener noreferrer">CancellationException</a> after trying to emit number 4:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">Emitting 1 1 Emitting 2 2 Emitting 3 3 Emitting 4 Exception in thread "main" kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job="coroutine#1":BlockingCoroutine{Cancelled}@6d7b4f4c </pre>
<p id="c9dfb068">However, most other flow operators do not do additional cancellation checks on their own for performance reasons. For example, if you use <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/as-flow.html" id="68cf670a" data-external="true" rel="noopener noreferrer">IntRange.asFlow</a> extension to write the same busy loop and don't suspend anywhere, then there are no checks for cancellation:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* //sampleStart fun main() = runBlocking&lt;Unit&gt; { (1..5).asFlow().collect { value -&gt; if (value == 3) cancel() println(value) } } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="9910aab2"><p id="d6185b2d">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-38.kt" id="d415e528" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="9568920c">All numbers from 1 to 5 are collected and cancellation gets detected only before return from <code class="code ">runBlocking</code>:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">1 2 3 4 5 Exception in thread "main" kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job="coroutine#1":BlockingCoroutine{Cancelled}@3327bd23 </pre>
<section class="chapter"><h4 id="making-busy-flow-cancellable" data-toc="flow#making-busy-flow-cancellable">Making busy flow cancellable</h4>
<p id="88123ed7">In the case where you have a busy loop with coroutines you must explicitly check for cancellation. You can add <code class="code ">.onEach { currentCoroutineContext().ensureActive() }</code>, but there is a ready-to-use <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/cancellable.html" id="1c20764b" data-external="true" rel="noopener noreferrer">cancellable</a> operator provided to do that:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">import kotlinx.coroutines.* import kotlinx.coroutines.flow.* //sampleStart fun main() = runBlocking&lt;Unit&gt; { (1..5).asFlow().cancellable().collect { value -&gt; if (value == 3) cancel() println(value) } } //sampleEnd </pre>
<aside data-type="note" class="prompt" data-title="" id="c7202a37"><p id="5faa16a8">You can get the full code from <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-39.kt" id="2e550b32" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="73c7172f">With the <code class="code ">cancellable</code> operator only the numbers from 1 to 3 are collected:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">1 2 3 Exception in thread "main" kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job="coroutine#1":BlockingCoroutine{Cancelled}@5ec0a365 </pre></section></section></section><section class="chapter"><h2 id="flow-and-reactive-streams" data-toc="flow#flow-and-reactive-streams">Flow and Reactive Streams</h2>
<p id="4e40163c">For those who are familiar with <a href="https://www.reactive-streams.org/" id="e75b7c8a" data-external="true" rel="noopener noreferrer">Reactive Streams</a> or reactive frameworks such as RxJava and project Reactor, design of the Flow may look very familiar.</p>
<p id="31b4ca35">Indeed, its design was inspired by Reactive Streams and its various implementations. But Flow main goal is to have as simple design as possible, be Kotlin and suspension friendly and respect structured concurrency. Achieving this goal would be impossible without reactive pioneers and their tremendous work. You can read the complete story in <a href="https://medium.com/@elizarov/reactive-streams-and-kotlin-flows-bfd12772cda4" id="6f8007aa" data-external="true" rel="noopener noreferrer">Reactive Streams and Kotlin Flows</a> article.</p>
<p id="8610b3a7">While being different, conceptually, Flow <em id="64c55291" class="">is</em> a reactive stream and it is possible to convert it to the reactive (spec and TCK compliant) Publisher and vice versa. Such converters are provided by <code class="code ">kotlinx.coroutines</code> out-of-the-box and can be found in corresponding reactive modules (<code class="code ">kotlinx-coroutines-reactive</code> for Reactive Streams, <code class="code ">kotlinx-coroutines-reactor</code> for Project Reactor and <code class="code ">kotlinx-coroutines-rx2</code>/<code class="code ">kotlinx-coroutines-rx3</code> for RxJava2/RxJava3). Integration modules include conversions from and to <code class="code ">Flow</code>, integration with Reactor's <code class="code ">Context</code> and suspension-friendly ways to work with various reactive entities.</p></section><div class="last-modified"> Last modified: 15 July 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="coroutine-context-and-dispatchers">Coroutine context and dispatchers</a> <a class="navigation-links__next" href="channels">Channels</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/flow.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/flow.html</a>
  </p>
</div>
