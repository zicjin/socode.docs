<h1 data-toc="whatsnew16" id="whatsnew16.md">What's new in Kotlin 1.6.0</h1>
<p id="c4c811de"><em id="757e4491" class=""><a href="releases#release-details" id="3ec3cdac">Release date: 16 November 2021</a></em></p>
<p id="a569837c">Kotlin 1.6.0 introduces new language features, optimizations and improvements to existing features, and a lot of improvements to the Kotlin standard library.</p>
<p id="d0747fe">You can also find an overview of the changes in the <a href="https://blog.jetbrains.com/kotlin/2021/11/kotlin-1-6-0-is-released/" id="719137c0" data-external="true" rel="noopener noreferrer">release blog post</a>.</p>
<section class="chapter"><h2 id="language" data-toc="whatsnew16#language">Language</h2>
<p id="d4085f8f">Kotlin 1.6.0 brings stabilization to several language features introduced for preview in the previous 1.5.30 release:</p>
<ul class="list _ul" id="e9d075ab">
<li class="list__item" id="5513fce3"><p><a href="#stable-exhaustive-when-statements-for-enum-sealed-and-boolean-subjects" id="ee0d8306">Stable exhaustive when statements for enum, sealed and Boolean subjects</a></p></li>
<li class="list__item" id="7aef1ab0"><p><a href="#stable-suspending-functions-as-supertypes" id="1cf62b92">Stable suspending functions as supertypes</a></p></li>
<li class="list__item" id="a1c1e771"><p><a href="#stable-suspend-conversions" id="8cbe4f11">Stable suspend conversions</a></p></li>
<li class="list__item" id="3495b6d2"><p><a href="#stable-instantiation-of-annotation-classes" id="dad2e6c7">Stable instantiation of annotation classes</a></p></li>
</ul>
<p id="56739dbf">It also includes various type inference improvements and support for annotations on class type parameters:</p>
<ul class="list _ul" id="f6159ae">
<li class="list__item" id="eb087862"><p><a href="#improved-type-inference-for-recursive-generic-types" id="a049f7ac">Improved type inference for recursive generic types</a></p></li>
<li class="list__item" id="dd8c8163"><p><a href="#changes-to-builder-inference" id="1ccfefe1">Changes to builder inference</a></p></li>
<li class="list__item" id="2a50458b"><p><a href="#support-for-annotations-on-class-type-parameters" id="95557a2a">Support for annotations on class type parameters</a></p></li>
</ul>
<section class="chapter"><h3 id="stable-exhaustive-when-statements-for-enum-sealed-and-boolean-subjects" data-toc="whatsnew16#stable-exhaustive-when-statements-for-enum-sealed-and-boolean-subjects">Stable exhaustive when statements for enum, sealed, and Boolean subjects</h3>
<p id="2fbccded">An <em id="b729eb6f" class="">exhaustive</em><a href="control-flow#when-expression" id="85957564"><code class="code ">when</code></a> statement contains branches for all possible types or values of its subject, or for some types plus an <code class="code ">else</code> branch. It covers all possible cases, making your code safer.</p>
<p id="f2aff04a">We will soon prohibit non-exhaustive <code class="code ">when</code> statements to make the behavior consistent with <code class="code ">when</code> expressions. To ensure smooth migration, Kotlin 1.6.0 reports warnings about non-exhaustive <code class="code ">when</code> statements with an enum, sealed, or Boolean subject. These warnings will become errors in future releases.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">sealed class Contact { data class PhoneCall(val number: String) : Contact() data class TextMessage(val number: String) : Contact() } fun Contact.messageCost(): Int = when(this) { // Error: 'when' expression must be exhaustive is Contact.PhoneCall -&gt; 42 } fun sendMessage(contact: Contact, message: String) { // Starting with 1.6.0 // Warning: Non exhaustive 'when' statements on Boolean will be // prohibited in 1.7, add 'false' branch or 'else' branch instead when(message.isEmpty()) { true -&gt; return } // Warning: Non exhaustive 'when' statements on sealed class/interface will be // prohibited in 1.7, add 'is TextMessage' branch or 'else' branch instead when(contact) { is Contact.PhoneCall -&gt; TODO() } } </pre>
<p id="43d74cf6">See <a href="https://youtrack.jetbrains.com/issue/KT-47709" id="b5acf623" data-external="true" rel="noopener noreferrer">this YouTrack ticket</a> for a more detailed explanation of the change and its effects.</p></section><section class="chapter"><h3 id="stable-suspending-functions-as-supertypes" data-toc="whatsnew16#stable-suspending-functions-as-supertypes">Stable suspending functions as supertypes</h3>
<p id="eece2cc7">Implementation of suspending functional types has become <a href="components-stability" id="7cf26f92">Stable</a> in Kotlin 1.6.0. A preview was available <a href="whatsnew1530#suspending-functions-as-supertypes" id="5ea621e1">in 1.5.30</a>.</p>
<p id="e1876e57">The feature can be useful when designing APIs that use Kotlin coroutines and accept suspending functional types. You can now streamline your code by enclosing the desired behavior in a separate class that implements a suspending functional type.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class MyClickAction : suspend () -&gt; Unit { override suspend fun invoke() { TODO() } } fun launchOnClick(action: suspend () -&gt; Unit) {} </pre>
<p id="51022dac">You can use an instance of this class where only lambdas and suspending function references were allowed previously: <code class="code ">launchOnClick(MyClickAction())</code>.</p>
<p id="af5a82d5">There are currently two limitations coming from implementation details:</p>
<ul class="list _ul" id="3eac0ae1">
<li class="list__item" id="563025d6"><p>You can't mix ordinary functional types and suspending ones in the list of supertypes.</p></li>
<li class="list__item" id="3f239e60"><p>You can't use multiple suspending functional supertypes.</p></li>
</ul></section><section class="chapter"><h3 id="stable-suspend-conversions" data-toc="whatsnew16#stable-suspend-conversions">Stable suspend conversions</h3>
<p id="31a1ff20">Kotlin 1.6.0 introduces <a href="components-stability" id="ffcf39a7">Stable</a> conversions from regular to suspending functional types. Starting from 1.4.0, the feature supported functional literals and callable references. With 1.6.0, it works with any form of expression. As a call argument, you can now pass any expression of a suitable regular functional type where suspending is expected. The compiler will perform an implicit conversion automatically.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun getSuspending(suspending: suspend () -&gt; Unit) {} fun suspending() {} fun test(regular: () -&gt; Unit) { getSuspending { } // OK getSuspending(::suspending) // OK getSuspending(regular) // OK } </pre></section><section class="chapter"><h3 id="stable-instantiation-of-annotation-classes" data-toc="whatsnew16#stable-instantiation-of-annotation-classes">Stable instantiation of annotation classes</h3>
<p id="bb858712">Kotlin 1.5.30 <a href="whatsnew1530#instantiation-of-annotation-classes" id="ad73bfed">introduced</a> experimental support for instantiation of annotation classes on the JVM platform. With 1.6.0, the feature is available by default both for Kotlin/JVM and Kotlin/JS.</p>
<p id="20c154ec">Learn more about instantiation of annotation classes in <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/annotation-instantiation.md" id="ad01705" data-external="true" rel="noopener noreferrer">this KEEP</a>.</p></section><section class="chapter"><h3 id="improved-type-inference-for-recursive-generic-types" data-toc="whatsnew16#improved-type-inference-for-recursive-generic-types">Improved type inference for recursive generic types</h3>
<p id="791d2d08">Kotlin 1.5.30 introduced an improvement to type inference for recursive generic types, which allowed their type arguments to be inferred based only on the upper bounds of the corresponding type parameters. The improvement was available with the compiler option. In version 1.6.0 and later, it is enabled by default.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">// Before 1.5.30 val containerA = PostgreSQLContainer&lt;Nothing&gt;(DockerImageName.parse("postgres:13-alpine")).apply { withDatabaseName("db") withUsername("user") withPassword("password") withInitScript("sql/schema.sql") } // With compiler option in 1.5.30 or by default starting with 1.6.0 val containerB = PostgreSQLContainer(DockerImageName.parse("postgres:13-alpine")) .withDatabaseName("db") .withUsername("user") .withPassword("password") .withInitScript("sql/schema.sql") </pre></section><section class="chapter"><h3 id="changes-to-builder-inference" data-toc="whatsnew16#changes-to-builder-inference">Changes to builder inference</h3>
<p id="72c4ef9">Builder inference is a type inference flavor which is useful when calling generic builder functions. It can infer the type arguments of a call with the help of type information from calls inside its lambda argument.</p>
<p id="8c46b8c2">We're making multiple changes that are bringing us closer to fully stable builder inference. Starting with 1.6.0:</p>
<ul class="list _ul" id="86db684b">
<li class="list__item" id="6e7172de"><p id="bc4a9876">You can make calls returning an instance of a not yet inferred type inside a builder lambda without specifying the <code class="code ">-Xunrestricted-builder-inference</code> compiler option <a href="whatsnew1530#eliminating-builder-inference-restrictions" id="85bc6a66">introduced in 1.5.30</a>.</p></li>
<li class="list__item" id="4434f842">
<p id="301583c6">With <code class="code ">-Xenable-builder-inference</code>, you can write your own builders without applying the <a href="../api/latest/jvm/stdlib/kotlin/-builder-inference/index" id="9c306a70" data-external="true" rel="noopener noreferrer"><code class="code ">@BuilderInference</code></a> annotation.</p>
<aside data-type="warning" class="prompt" data-title="" id="776bfab2"><p id="cf2d6c08">Note that clients of these builders will need to specify the same <code class="code ">-Xenable-builder-inference</code> compiler option.</p></aside>
</li>
<li class="list__item" id="efa97389"><p id="be3c6a44">With the <code class="code ">-Xenable-builder-inference</code>, builder inference automatically activates if a regular type inference cannot get enough information about a type.</p></li>
</ul>
<p id="291b8e23"><a href="using-builders-with-builder-inference" id="1cae111b">Learn how to write custom generic builders</a>.</p></section><section class="chapter"><h3 id="support-for-annotations-on-class-type-parameters" data-toc="whatsnew16#support-for-annotations-on-class-type-parameters">Support for annotations on class type parameters</h3>
<p id="720708f5">Support for annotations on class type parameters looks like this:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">@Target(AnnotationTarget.TYPE_PARAMETER) annotation class BoxContent class Box&lt;@BoxContent T&gt; {} </pre>
<p id="779eb44">Annotations on all type parameters are emitted into JVM bytecode so annotation processors are able to use them.</p>
<p id="d01b5b53">For the motivating use case, read this <a href="https://youtrack.jetbrains.com/issue/KT-43714" id="36bbdb0a" data-external="true" rel="noopener noreferrer">YouTrack ticket</a>.</p>
<p id="cfbaf6a5">Learn more about <a href="annotations" id="1a19b09">annotations</a>.</p></section></section><section class="chapter"><h2 id="supporting-previous-api-versions-for-a-longer-period" data-toc="whatsnew16#supporting-previous-api-versions-for-a-longer-period">Supporting previous API versions for a longer period</h2>
<p id="eb6a9c82">Starting with Kotlin 1.6.0, we will support development for three previous API versions instead of two, along with the current stable one. Currently, we support versions 1.3, 1.4, 1.5, and 1.6.</p></section><section class="chapter"><h2 id="kotlin-jvm" data-toc="whatsnew16#kotlin-jvm">Kotlin/JVM</h2>
<p id="c69d6385">For Kotlin/JVM, starting with 1.6.0, the compiler can generate classes with a bytecode version corresponding to JVM 17. The new language version also includes optimized delegated properties and repeatable annotations, which we had on the roadmap:</p>
<ul class="list _ul" id="c063b588">
<li class="list__item" id="7b735fd0"><p><a href="#repeatable-annotations-with-runtime-retention-for-1-8-jvm-target" id="ca4a193a">Repeatable annotations with runtime retention for 1.8 JVM target</a></p></li>
<li class="list__item" id="de001a8"><p><a href="#optimize-delegated-properties-which-call-get-set-on-the-given-kproperty-instance" id="3b158d2d">Optimize delegated properties which call get/set on the given KProperty instance</a></p></li>
</ul>
<section class="chapter"><h3 id="repeatable-annotations-with-runtime-retention-for-1-8-jvm-target" data-toc="whatsnew16#repeatable-annotations-with-runtime-retention-for-1-8-jvm-target">Repeatable annotations with runtime retention for 1.8 JVM target</h3>
<p id="bb8639f9">Java 8 introduced <a href="https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html" id="386cdd94" data-external="true" rel="noopener noreferrer">repeatable annotations</a>, which can be applied multiple times to a single code element. The feature requires two declarations to be present in the Java code: the repeatable annotation itself marked with <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Repeatable.html" id="61e12128" data-external="true" rel="noopener noreferrer"><code class="code ">@java.lang.annotation.Repeatable</code></a> and the containing annotation to hold its values.</p>
<p id="c16ee030">Kotlin also has repeatable annotations, but requires only <a href="../api/latest/jvm/stdlib/kotlin.annotation/-repeatable/index" id="f29b3a9f" data-external="true" rel="noopener noreferrer"><code class="code ">@kotlin.annotation.Repeatable</code></a> to be present on an annotation declaration to make it repeatable. Before 1.6.0, the feature supported only <code class="code ">SOURCE</code> retention and was incompatible with Java's repeatable annotations. Kotlin 1.6.0 removes these limitations. <code class="code ">@kotlin.annotation.Repeatable</code> now accepts any retention and makes the annotation repeatable both in Kotlin and Java. Java's repeatable annotations are now also supported from the Kotlin side.</p>
<p id="35c020c2">While you can declare a containing annotation, it's not necessary. For example:</p>
<ul class="list _ul" id="15cf5401">
<li class="list__item" id="3a27ad16">
<p id="6a910f32">If an annotation <code class="code ">@Tag</code> is marked with <code class="code ">@kotlin.annotation.Repeatable</code>, the Kotlin compiler automatically generates a containing annotation class under the name of <code class="code ">@Tag.Container</code>:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">@Repeatable annotation class Tag(val name: String) // The compiler generates @Tag.Container containing annotation </pre>
</li>
<li class="list__item" id="661e0359">
<p id="58a79d73">To set a custom name for a containing annotation, apply the <a href="../api/latest/jvm/stdlib/kotlin.jvm/-jvmrepeatable/index" id="594eb51b" data-external="true" rel="noopener noreferrer"><code class="code ">@kotlin.jvm.JvmRepeatable</code></a> meta-annotation and pass the explicitly declared containing annotation class as an argument:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">@JvmRepeatable(Tags::class) annotation class Tag(val name: String) annotation class Tags(val value: Array&lt;Tag&gt;) </pre>
</li>
</ul>
<p id="80277a94">Kotlin reflection now supports both Kotlin's and Java's repeatable annotations via a new function, <a href="../api/latest/jvm/stdlib/kotlin.reflect.full/find-annotations" id="ee33d266" data-external="true" rel="noopener noreferrer"><code class="code ">KAnnotatedElement.findAnnotations()</code></a>.</p>
<p id="430f2c81">Learn more about Kotlin repeatable annotations in <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/repeatable-annotations.md" id="3484b652" data-external="true" rel="noopener noreferrer">this KEEP</a>.</p></section><section class="chapter"><h3 id="optimize-delegated-properties-which-call-get-set-on-the-given-kproperty-instance" data-toc="whatsnew16#optimize-delegated-properties-which-call-get-set-on-the-given-kproperty-instance">Optimize delegated properties which call get/set on the given KProperty instance</h3>
<p id="4eb2b50f">We optimized the generated JVM bytecode by omitting the <code class="code ">$delegate</code> field and generating immediate access to the referenced property.</p>
<p id="bd74f056">For example, in the following code</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class Box&lt;T&gt; { private var impl: T = ... var content: T by ::impl } </pre>
<p id="1b99ab43">Kotlin no longer generates the field <code class="code ">content$delegate</code>. Property accessors of the <code class="code ">content</code> variable invoke the <code class="code ">impl</code> variable directly, skipping the delegated property's <code class="code ">getValue</code>/<code class="code ">setValue</code> operators and thus avoiding the need for the property reference object of the <a href="../api/latest/jvm/stdlib/kotlin.reflect/-k-property/index" id="34a3c5b7" data-external="true" rel="noopener noreferrer"><code class="code ">KProperty</code></a> type.</p>
<p id="c62f22bd">Thanks to our Google colleagues for the implementation!</p>
<p id="62bbe3ec">Learn more about <a href="delegated-properties" id="d72edc16">delegated properties</a>.</p></section></section><section class="chapter"><h2 id="kotlin-native" data-toc="whatsnew16#kotlin-native">Kotlin/Native</h2>
<p id="ba04398a">Kotlin/Native is receiving multiple improvements and component updates, some of them in the preview state:</p>
<ul class="list _ul" id="2b4cb501">
<li class="list__item" id="7cd05596"><p><a href="#preview-of-the-new-memory-manager" id="b34d7af">Preview of the new memory manager</a></p></li>
<li class="list__item" id="f254a073"><p><a href="#support-for-xcode-13" id="1f87126c">Support for Xcode 13</a></p></li>
<li class="list__item" id="718cdb73"><p><a href="#compilation-of-windows-targets-on-any-host" id="ce7423c6">Compilation of Windows targets on any host</a></p></li>
<li class="list__item" id="ffaa0d5e"><p><a href="#llvm-and-linker-updates" id="d55d5748">LLVM and linker updates</a></p></li>
<li class="list__item" id="2e8d6509"><p><a href="#performance-improvements" id="b7760958">Performance improvements</a></p></li>
<li class="list__item" id="db78adaf"><p><a href="#unified-compiler-plugin-abi-with-jvm-and-js-ir-backends" id="8adc76e8">Unified compiler plugin ABI with JVM and JS IR backends</a></p></li>
<li class="list__item" id="a74539de"><p><a href="#detailed-error-messages-for-klib-linkage-failures" id="11401c0f">Detailed error messages for klib linkage failures</a></p></li>
<li class="list__item" id="a64396c8"><p><a href="#reworked-unhandled-exception-handling-api" id="7a8c2394">Reworked unhandled exception handling API</a></p></li>
</ul>
<section class="chapter"><h3 id="preview-of-the-new-memory-manager" data-toc="whatsnew16#preview-of-the-new-memory-manager">Preview of the new memory manager</h3>
<aside data-type="warning" class="prompt" data-title="" id="a6096309"><p id="2046d9ed">The new Kotlin/Native memory manager is <a href="components-stability" id="2c2def1a">Experimental</a>. It may be dropped or changed at any time. Opt-in is required (see details below), and you should use it only for evaluation purposes. We would appreciate your feedback on it in <a href="https://youtrack.jetbrains.com/issue/KT-48525" id="70b1a047" data-external="true" rel="noopener noreferrer">YouTrack</a>.</p></aside><p id="8ab8ab07">With Kotlin 1.6.0, you can try the development preview of the new Kotlin/Native memory manager. It moves us closer to eliminating the differences between the JVM and Native platforms to provide a consistent developer experience in multiplatform projects.</p>
<p id="ef3e1090">One of the notable changes is the lazy initialization of top-level properties, like in Kotlin/JVM. A top-level property gets initialized when a top-level property or function from the same file is accessed for the first time. This mode also includes global interprocedural optimization (enabled only for release binaries), which removes redundant initialization checks.</p>
<p id="a7612422">We've recently published a <a href="https://blog.jetbrains.com/kotlin/2021/08/try-the-new-kotlin-native-memory-manager-development-preview/" id="ba3df195" data-external="true" rel="noopener noreferrer">blog post</a> about the new memory manager. Read it to learn about the current state of the new memory manager and find some demo projects, or jump right to the <a href="https://github.com/JetBrains/kotlin/blob/master/kotlin-native/NEW_MM.md" id="d04346cf" data-external="true" rel="noopener noreferrer">migration instructions</a> to try it yourself. Please check how the new memory manager works on your projects and share feedback in our issue tracker, <a href="https://youtrack.jetbrains.com/issue/KT-48525" id="4233d2b7" data-external="true" rel="noopener noreferrer">YouTrack</a>.</p></section><section class="chapter"><h3 id="support-for-xcode-13" data-toc="whatsnew16#support-for-xcode-13">Support for Xcode 13</h3>
<p id="48cc0b96">Kotlin/Native 1.6.0 supports Xcode 13 – the latest version of Xcode. Feel free to update your Xcode and continue working on your Kotlin projects for Apple operating systems.</p>
<aside data-type="note" class="prompt" data-title="" id="c9f3b8c8"><p id="9ddb7c23">New libraries added in Xcode 13 aren't available for use in Kotlin 1.6.0, but we're going to add support for them in upcoming versions.</p></aside></section><section class="chapter"><h3 id="compilation-of-windows-targets-on-any-host" data-toc="whatsnew16#compilation-of-windows-targets-on-any-host">Compilation of Windows targets on any host</h3>
<p id="4b26c204">Starting from 1.6.0, you don't need a Windows host to compile the Windows targets <code class="code ">mingwX64</code> and <code class="code ">mingwX86</code>. They can be compiled on any host that supports Kotlin/Native.</p></section><section class="chapter"><h3 id="llvm-and-linker-updates" data-toc="whatsnew16#llvm-and-linker-updates">LLVM and linker updates</h3>
<p id="1b59d928">We've reworked the LLVM dependency that Kotlin/Native uses under the hood. This brings various benefits, including:</p>
<ul class="list _ul" id="3710b103">
<li class="list__item" id="716767b9"><p>Updated LLVM version to 11.1.0.</p></li>
<li class="list__item" id="ab4c684b"><p>Decreased dependency size. For example, on macOS it's now about 300 MB instead of 1200 MB in the previous version.</p></li>
<li class="list__item" id="95f4d138"><p><a href="https://youtrack.jetbrains.com/issue/KT-42693" id="326ae16a" data-external="true" rel="noopener noreferrer">Excluded dependency on the <code class="code ">ncurses5</code> library</a> that isn't available in modern Linux distributions.</p></li>
</ul>
<p id="df68369b">In addition to the LLVM update, Kotlin/Native now uses the <a href="https://lld.llvm.org/" id="9414d2f7" data-external="true" rel="noopener noreferrer">LLD</a> linker (a linker from the LLVM project) for MingGW targets. It provides various benefits over the previously used ld.bfd linker, and will allow us to improve runtime performance of produced binaries and support compiler caches for MinGW targets. Note that LLD <a href="whatsnew1530#deprecation-of-linkage-against-dlls-without-import-libraries-for-mingw-targets" id="18c162a2">requires import libraries for DLL linkage</a>. Learn more in <a href="https://stackoverflow.com/questions/3573475/how-does-the-import-library-work-details/3573527/#3573527" id="aa3fa84d" data-external="true" rel="noopener noreferrer">this Stack Overflow thread</a>.</p></section><section class="chapter"><h3 id="performance-improvements" data-toc="whatsnew16#performance-improvements">Performance improvements</h3>
<p id="d36e64d7">Kotlin/Native 1.6.0 delivers the following performance improvements:</p>
<ul class="list _ul" id="f20b2ba4">
<li class="list__item" id="683f5485"><p>Compilation time: compiler caches are enabled by default for <code class="code ">linuxX64</code> and <code class="code ">iosArm64</code> targets. This speeds up most compilations in debug mode (except the first one). Measurements showed about a 200% speed increase on our test projects. The compiler caches have been available for these targets since Kotlin 1.5.0 with <a href="whatsnew15#performance-improvements" id="c7034bb1">additional Gradle properties</a>; you can remove them now.</p></li>
<li class="list__item" id="10761269"><p>Runtime: iterating over arrays with <code class="code ">for</code> loops is now up to 12% faster thanks to optimizations in the produced LLVM code.</p></li>
</ul></section><section class="chapter"><h3 id="unified-compiler-plugin-abi-with-jvm-and-js-ir-backends" data-toc="whatsnew16#unified-compiler-plugin-abi-with-jvm-and-js-ir-backends">Unified compiler plugin ABI with JVM and JS IR backends</h3>
<aside data-type="warning" class="prompt" data-title="" id="f3339317"><p id="b6eb4094">The option to use the common IR compiler plugin ABI for Kotlin/Native is <a href="components-stability" id="573d8a5d">Experimental</a>. It may be dropped or changed at any time. Opt-in is required (see details below), and you should use it only for evaluation purposes. We would appreciate your feedback on it in <a href="https://youtrack.jetbrains.com/issue/KT-48595" id="6d94dabe" data-external="true" rel="noopener noreferrer">YouTrack</a>.</p></aside><p id="2c3a980b">In previous versions, authors of compiler plugins had to provide separate artifacts for Kotlin/Native because of the differences in the ABI.</p>
<p id="248977df">Starting from 1.6.0, the Kotlin Multiplatform Gradle plugin is able to use the embeddable compiler jar – the one used for the JVM and JS IR backends – for Kotlin/Native. This is a step toward unification of the compiler plugin development experience, as you can now use the same compiler plugin artifacts for Native and other supported platforms.</p>
<p id="e7ac44b2">This is a preview version of such support, and it requires an opt-in. To start using generic compiler plugin artifacts for Kotlin/Native, add the following line to <code class="code ">gradle.properties</code>: <code class="code ">kotlin.native.useEmbeddableCompilerJar=true</code>.</p>
<p id="6bc31f8e">We're planning to use the embeddable compiler jar for Kotlin/Native by default in the future, so it's vital for us to hear how the preview works for you.</p>
<p id="8209dfbc">If you are an author of a compiler plugin, please try this mode and check if it works for your plugin. Note that depending on your plugin's structure, migration steps may be required. See <a href="https://youtrack.jetbrains.com/issue/KT-48595" id="f356f4ba" data-external="true" rel="noopener noreferrer">this YouTrack issue</a> for migration instructions and leave your feedback in the comments.</p></section><section class="chapter"><h3 id="detailed-error-messages-for-klib-linkage-failures" data-toc="whatsnew16#detailed-error-messages-for-klib-linkage-failures">Detailed error messages for klib linkage failures</h3>
<p id="3838afe8">The Kotlin/Native compiler now provides detailed error messages for klib linkage errors. The messages now have clear error descriptions, and they also include information about possible causes and ways to fix them.</p>
<p id="7877b79f">For example:</p>
<ul class="list _ul" id="88703d9">
<li class="list__item" id="391e6c2d">
<p id="e492b38c">1.5.30:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">e: java.lang.IllegalStateException: IrTypeAliasSymbol expected: Unbound public symbol for public kotlinx.coroutines/CancellationException|null[0] &lt;stack trace&gt; </pre>
</li>
<li class="list__item" id="67b213b2">
<p id="8a2c957e">1.6.0:</p>
<pre class="code-block" data-lang="plaintext" data-language="plaintext">e: The symbol of unexpected type encountered during IR deserialization: IrClassPublicSymbolImpl, kotlinx.coroutines/CancellationException|null[0]. IrTypeAliasSymbol is expected. This could happen if there are two libraries, where one library was compiled against the different version of the other library than the one currently used in the project. Please check that the project configuration is correct and has consistent versions of dependencies. The list of libraries that depend on "org.jetbrains.kotlinx:kotlinx-coroutines-core (org.jetbrains.kotlinx:kotlinx-coroutines-core-macosx64)" and may lead to conflicts: &lt;list of libraries and potential version mismatches&gt; Project dependencies: &lt;dependencies tree&gt; </pre>
</li>
</ul></section><section class="chapter"><h3 id="reworked-unhandled-exception-handling-api" data-toc="whatsnew16#reworked-unhandled-exception-handling-api">Reworked unhandled exception handling API</h3>
<p id="bf04f524">We've unified the processing of unhandled exceptions throughout the Kotlin/Native runtime and exposed the default processing as the function <code class="code ">processUnhandledException(throwable: Throwable)</code> for use by custom execution environments, like <code class="code ">kotlinx.coroutines</code>. This processing is also applied to exceptions that escape operation in <code class="code ">Worker.executeAfter()</code>, but only for the new <a href="#preview-of-the-new-memory-manager" id="cba544e">memory manager</a>.</p>
<p id="f4b5cc12">API improvements also affected the hooks that have been set by <code class="code ">setUnhandledExceptionHook()</code>. Previously such hooks were reset after the Kotlin/Native runtime called the hook with an unhandled exception, and the program would always terminate right after. Now these hooks may be used more than once, and if you want the program to always terminate on an unhandled exception, either do not set an unhandled exception hook (<code class="code ">setUnhandledExceptionHook()</code>), or make sure to call <code class="code ">terminateWithUnhandledException()</code> at the end of your hook. This will help you send exceptions to a third-party crash reporting service (like Firebase Crashlytics) and then terminate the program. Exceptions that escape <code class="code ">main()</code> and exceptions that cross the interop boundary will always terminate the program, even if the hook did not call <code class="code ">terminateWithUnhandledException()</code>.</p></section></section><section class="chapter"><h2 id="kotlin-js" data-toc="whatsnew16#kotlin-js">Kotlin/JS</h2>
<p id="7bdf14ae">We're continuing to work on stabilizing the IR backend for the Kotlin/JS compiler. Kotlin/JS now has an <a href="#option-to-use-pre-installed-node-js-and-yarn" id="6b93d6cb">option to disable downloading of Node.js and Yarn</a>.</p>
<section class="chapter"><h3 id="option-to-use-pre-installed-node-js-and-yarn" data-toc="whatsnew16#option-to-use-pre-installed-node-js-and-yarn">Option to use pre-installed Node.js and Yarn</h3>
<p id="c5f54740">You can now disable downloading Node.js and Yarn when building Kotlin/JS projects and use the instances already installed on the host. This is useful for building on servers without internet connectivity, such as CI servers.</p>
<p id="5eb29f3">To disable downloading external components, add the following lines to your <code class="code ">build.gradle(.kts)</code>:</p>
<ul class="list _ul" id="3f648e30">
<li class="list__item" id="747e2ba2">
<p id="c8d36e6">Yarn:</p>
<div class="tabs" id="df7f650b" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="85ee86ef" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code-block" data-lang="kotlin" data-title="Kotlin" data-language="kotlin">rootProject.plugins.withType&lt;org.jetbrains.kotlin.gradle.targets.js.yarn.YarnPlugin&gt; { rootProject.the&lt;org.jetbrains.kotlin.gradle.targets.js.yarn.YarnRootExtension&gt;().download = false // or true for default behavior } </pre></div>
<div class="tabs__content" data-gtm="tab" id="36b16e2f" data-sync-tabs="groovy" data-title="Groovy"><pre class="code-block" data-lang="groovy" data-title="Groovy" data-language="groovy">rootProject.plugins.withType(org.jetbrains.kotlin.gradle.targets.js.yarn.YarnPlugin) { rootProject.extensions.getByType(org.jetbrains.kotlin.gradle.targets.js.yarn.YarnRootExtension).download = false } </pre></div>
</div>
</li>
<li class="list__item" id="2903c376">
<p id="6cdc5de4">Node.js:</p>
<div class="tabs" id="a7489efb" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="19e968f7" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code-block" data-lang="kotlin" data-title="Kotlin" data-language="kotlin">rootProject.plugins.withType&lt;org.jetbrains.kotlin.gradle.targets.js.nodejs.NodeJsRootPlugin&gt; { rootProject.the&lt;org.jetbrains.kotlin.gradle.targets.js.nodejs.NodeJsRootExtension&gt;().download = false // or true for default behavior } </pre></div>
<div class="tabs__content" data-gtm="tab" id="2074b5e9" data-sync-tabs="groovy" data-title="Groovy"><pre class="code-block" data-lang="groovy" data-title="Groovy" data-language="groovy">rootProject.plugins.withType(org.jetbrains.kotlin.gradle.targets.js.nodejs.NodeJsRootPlugin) { rootProject.extensions.getByType(org.jetbrains.kotlin.gradle.targets.js.nodejs.NodeJsRootExtension).download = false } </pre></div>
</div>
</li>
</ul></section></section><section class="chapter"><h2 id="kotlin-gradle-plugin" data-toc="whatsnew16#kotlin-gradle-plugin">Kotlin Gradle plugin</h2>
<p id="774dfef8">In Kotlin 1.6.0, we changed the deprecation level of the <code class="code ">KotlinGradleSubplugin</code> class to 'ERROR'. This class was used for writing compiler plugins. In the following releases, we'll remove this class. Use the class <code class="code ">KotlinCompilerPluginSupportPlugin</code> instead.</p>
<p id="e51ba074">We removed the <code class="code ">kotlin.useFallbackCompilerSearch</code> build option and the <code class="code ">noReflect</code> and <code class="code ">includeRuntime</code> compiler options. The <code class="code ">useIR</code> compiler option has been hidden and will be removed in upcoming releases.</p>
<p id="5ab6327b">Learn more about the <a href="gradle#compiler-options" id="fcb60c44">currently supported compiler options</a> in the Kotlin Gradle plugin.</p></section><section class="chapter"><h2 id="standard-library" data-toc="whatsnew16#standard-library">Standard library</h2>
<p id="91cdcca4">The new 1.6.0 version of the standard library stabilizes experimental features, introduces new ones, and unifies its behavior across the platforms:</p>
<ul class="list _ul" id="574bbb1e">
<li class="list__item" id="f33d96fd"><p><a href="#new-readline-functions" id="87c3f773">New readline functions</a></p></li>
<li class="list__item" id="372b5dc9"><p><a href="#stable-typeof" id="db19f074">Stable typeOf()</a></p></li>
<li class="list__item" id="dca3f55f"><p><a href="#stable-collection-builders" id="190d7230">Stable collection builders</a></p></li>
<li class="list__item" id="8f731d6d"><p><a href="#stable-duration-api" id="7c95bc71">Stable Duration API</a></p></li>
<li class="list__item" id="24244498"><p><a href="#splitting-regex-into-a-sequence" id="da6c0548">Splitting Regex into a sequence</a></p></li>
<li class="list__item" id="f6d89e8b"><p><a href="#bit-rotation-operations-on-integers" id="96b9ce01">Bit rotation operations on integers</a></p></li>
<li class="list__item" id="aa8f0b1c"><p><a href="#changes-for-replace-and-replacefirst-in-js" id="6f574ef0">Changes for replace() and replaceFirst() in JS</a></p></li>
<li class="list__item" id="a0a51416"><p><a href="#improvements-to-the-existing-api" id="69e79295">Improvements to the existing API</a></p></li>
<li class="list__item" id="310523a4"><p><a href="#deprecations" id="479b1fea">Deprecations</a></p></li>
</ul>
<section class="chapter"><h3 id="new-readline-functions" data-toc="whatsnew16#new-readline-functions">New readline functions</h3>
<p id="7af6eb7c">Kotlin 1.6.0 offers new functions for handling standard input: <a href="../api/latest/jvm/stdlib/kotlin.io/readln" id="fdbaccde" data-external="true" rel="noopener noreferrer"><code class="code ">readln()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.io/readln-or-null" id="aabccd3e" data-external="true" rel="noopener noreferrer"><code class="code ">readlnOrNull()</code></a>.</p>
<aside data-type="note" class="prompt" data-title="" id="f6491fa5"><p id="4b3ce74f">For now, new functions are available for the JVM and Native target platforms only.</p></aside><div class="table-wrapper"><table class=" wide" id="c9f7692a">
<thead><tr class="ijRowHead" id="f5b79a30">
<th id="ba4ef1dc"><p><b id="6ceb69e" class="">Earlier versions</b></p></th>
<th id="c10e1756"><p><b id="b099f2d9" class="">1.6.0 alternative</b></p></th>
<th id="243dffef"><p><b id="8db88d8d" class="">Usage</b></p></th>
</tr></thead>
<tbody>
<tr class="" id="5672f04b">
<td id="e1e6529f"><p><code class="code ">readLine()!!</code></p></td>
<td id="1c66c569"><p><code class="code ">readln()</code></p></td>
<td id="941bbd05"><p>Reads a line from stdin and returns it, or throws a <code class="code ">RuntimeException</code> if EOF has been reached.</p></td>
</tr>
<tr class="" id="57c27395">
<td id="ac086c88"><p><code class="code ">readLine()</code></p></td>
<td id="8c40dee4"><p><code class="code ">readlnOrNull()</code></p></td>
<td id="60eeadd0"><p>Reads a line from stdin and returns it, or returns <code class="code ">null</code> if EOF has been reached.</p></td>
</tr>
</tbody>
</table></div>
<p id="5ed23b01">We believe that eliminating the need to use <code class="code ">!!</code> when reading a line will improve the experience for newcomers and simplify teaching Kotlin. To make the read-line operation name consistent with its <code class="code ">println()</code> counterpart, we've decided to shorten the names of new functions to 'ln'.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">println("What is your nickname?") val nickname = readln() println("Hello, $nickname!") </pre>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.6" data-language="kotlin">fun main() { //sampleStart var sum = 0 while (true) { val nextLine = readlnOrNull().takeUnless { it.isNullOrEmpty() } ?: break sum += nextLine.toInt() } println(sum) //sampleEnd } </pre>
<p id="4dd5fd41">The existing <code class="code ">readLine()</code> function will get a lower priority than <code class="code ">readln()</code> and <code class="code ">readlnOrNull()</code> in your IDE code completion. IDE inspections will also recommend using new functions instead of the legacy <code class="code ">readLine()</code>.</p>
<p id="9d4777f8">We're planning to gradually deprecate the <code class="code ">readLine()</code> function in future releases.</p></section><section class="chapter"><h3 id="stable-typeof" data-toc="whatsnew16#stable-typeof">Stable typeOf()</h3>
<p id="5d984c36">Version 1.6.0 brings a <a href="components-stability" id="e04ce1ec">Stable</a><a href="../api/latest/jvm/stdlib/kotlin.reflect/type-of" id="f1934f43" data-external="true" rel="noopener noreferrer"><code class="code ">typeOf()</code></a> function, closing one of the <a href="https://youtrack.jetbrains.com/issue/KT-45396" id="ab282fb6" data-external="true" rel="noopener noreferrer">major roadmap items</a>.</p>
<p id="8e824c0c"><a href="https://blog.jetbrains.com/kotlin/2019/06/kotlin-1-3-40-released/" id="8da3abe0" data-external="true" rel="noopener noreferrer">Since 1.3.40</a>, <code class="code ">typeOf()</code> was available on the JVM platform as an experimental API. Now you can use it in any Kotlin platform and get <a href="../api/latest/jvm/stdlib/kotlin.reflect/-k-type/index#kotlin.reflect.KType" id="41eeabdc" data-external="true" rel="noopener noreferrer"><code class="code ">KType</code></a> representation of any Kotlin type that the compiler can infer:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">inline fun &lt;reified T&gt; renderType(): String { val type = typeOf&lt;T&gt;() return type.toString() } fun main() { val fromExplicitType = typeOf&lt;Int&gt;() val fromReifiedType = renderType&lt;List&lt;Int&gt;&gt;() } </pre></section><section class="chapter"><h3 id="stable-collection-builders" data-toc="whatsnew16#stable-collection-builders">Stable collection builders</h3>
<p id="1823af9b">In Kotlin 1.6.0, collection builder functions have been promoted to <a href="components-stability" id="c06e0c08">Stable</a>. Collections returned by collection builders are now serializable in their read-only state.</p>
<p id="eb0d9433">You can now use <a href="../api/latest/jvm/stdlib/kotlin.collections/build-map" id="78cc434e" data-external="true" rel="noopener noreferrer"><code class="code ">buildMap()</code></a>, <a href="../api/latest/jvm/stdlib/kotlin.collections/build-list" id="ac1df231" data-external="true" rel="noopener noreferrer"><code class="code ">buildList()</code></a>, and <a href="../api/latest/jvm/stdlib/kotlin.collections/build-set" id="68633bd4" data-external="true" rel="noopener noreferrer"><code class="code ">buildSet()</code></a> without the opt-in annotation:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.5" data-language="kotlin">fun main() { //sampleStart val x = listOf('b', 'c') val y = buildList { add('a') addAll(x) add('d') } println(y) // [a, b, c, d] //sampleEnd } </pre></section><section class="chapter"><h3 id="stable-duration-api" data-toc="whatsnew16#stable-duration-api">Stable Duration API</h3>
<p id="13c5b0b3">The <a href="../api/latest/jvm/stdlib/kotlin.time/-duration/index" id="7f349abe" data-external="true" rel="noopener noreferrer">Duration</a> class for representing duration amounts in different time units has been promoted to <a href="components-stability" id="6a93bb13">Stable</a>. In 1.6.0, the Duration API has received the following changes:</p>
<ul class="list _ul" id="bc4fec92">
<li class="list__item" id="ebde71f4"><p id="30620ce7">The first component of the <a href="../api/latest/jvm/stdlib/kotlin.time/-duration/to-components" id="5fbf92ff" data-external="true" rel="noopener noreferrer"><code class="code ">toComponents()</code></a> function that decomposes the duration into days, hours, minutes, seconds, and nanoseconds now has the <code class="code ">Long</code> type instead of <code class="code ">Int</code>. Веfore, if the value didn't fit into the <code class="code ">Int</code> range, it was coerced into that range. With the <code class="code ">Long</code> type, you can decompose any value in the duration range without cutting off the values that don't fit into <code class="code ">Int</code>.</p></li>
<li class="list__item" id="d3da06e8"><p id="cfcb157">The <code class="code ">DurationUnit</code> enum is now standalone and not a type alias of <code class="code ">java.util.concurrent.TimeUnit</code> on the JVM. We haven't found any convincing cases in which having <code class="code ">typealias DurationUnit = TimeUnit</code> could be useful. Also, exposing the <code class="code ">TimeUnit</code> API through a type alias might confuse <code class="code ">DurationUnit</code> users.</p></li>
<li class="list__item" id="25da9e81">
<p id="2092c466">In response to community feedback, we're bringing back extension properties like <code class="code ">Int.seconds</code>. But we'd like to limit their applicability, so we put them into the companion of the <code class="code ">Duration</code> class. While the IDE can still propose extensions in completion and automatically insert an import from the companion, in the future we plan to limit this behavior to cases when the <code class="code ">Duration</code> type is expected.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.5" data-language="kotlin">import kotlin.time.Duration.Companion.seconds fun main() { //sampleStart val duration = 10000 println("There are ${duration.seconds.inWholeMinutes} minutes in $duration seconds") // There are 166 minutes in 10000 seconds //sampleEnd } </pre>
<p id="2d7bb235">We suggest replacing previously introduced companion functions, such as <code class="code ">Duration.seconds(Int)</code>, and deprecated top-level extensions like <code class="code ">Int.seconds</code> with new extensions in <code class="code ">Duration.Companion</code>.</p>
<aside data-type="note" class="prompt" data-title="" id="c3387437"><p id="3ee4fdb1">Such a replacement may cause ambiguity between old top-level extensions and new companion extensions. Be sure to use the wildcard import of the kotlin.time package – <code class="code ">import kotlin.time.*</code> – before doing automated migration.</p></aside>
</li>
</ul></section><section class="chapter"><h3 id="splitting-regex-into-a-sequence" data-toc="whatsnew16#splitting-regex-into-a-sequence">Splitting Regex into a sequence</h3>
<p id="66b84229">The <code class="code ">Regex.splitToSequence(CharSequence)</code> and <code class="code ">CharSequence.splitToSequence(Regex)</code> functions are promoted to <a href="components-stability" id="ae4f9212">Stable</a>. They split the string around matches of the given regex, but return the result as a <a href="sequences" id="8c6e4a98">Sequence</a> so that all operations on this result are executed lazily:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.5" data-language="kotlin">fun main() { //sampleStart val colorsText = "green, red, brown&amp;blue, orange, pink&amp;green" val regex = "[,\\s]+".toRegex() val mixedColor = regex.splitToSequence(colorsText) // or // val mixedColor = colorsText.splitToSequence(regex) .onEach { println(it) } .firstOrNull { it.contains('&amp;') } println(mixedColor) // "brown&amp;blue" //sampleEnd } </pre></section><section class="chapter"><h3 id="bit-rotation-operations-on-integers" data-toc="whatsnew16#bit-rotation-operations-on-integers">Bit rotation operations on integers</h3>
<p id="352f7f47">In Kotlin 1.6.0, the <code class="code ">rotateLeft()</code> and <code class="code ">rotateRight()</code> functions for bit manipulations became <a href="components-stability" id="6819b75d">Stable</a>. The functions rotate the binary representation of the number left or right by a specified number of bits:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.6" data-language="kotlin">fun main() { //sampleStart val number: Short = 0b10001 println(number .rotateRight(2) .toString(radix = 2)) // 100000000000100 println(number .rotateLeft(2) .toString(radix = 2)) // 1000100 //sampleEnd } </pre></section><section class="chapter"><h3 id="changes-for-replace-and-replacefirst-in-js" data-toc="whatsnew16#changes-for-replace-and-replacefirst-in-js">Changes for replace() and replaceFirst() in JS</h3>
<p id="43b0102f">Before Kotlin 1.6.0, the <a href="../api/latest/jvm/stdlib/kotlin.text/-regex/replace" id="8de8066d" data-external="true" rel="noopener noreferrer"><code class="code ">replace()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.text/-regex/replace-first" id="89c6e939" data-external="true" rel="noopener noreferrer"><code class="code ">replaceFirst()</code></a> Regex functions behaved differently in Java and JS when the replacement string contained a group reference. To make the behavior consistent across all target platforms, we've changed their implementation in JS.</p>
<p id="7b2199e1">Occurrences of <code class="code ">${name}</code> or <code class="code ">$index</code> in the replacement string are substituted with the subsequences corresponding to the captured groups with the specified index or a name:</p>
<ul class="list _ul" id="3431e520">
<li class="list__item" id="30a24101"><p id="6fefa9de"><code class="code ">$index</code> – the first digit after '$' is always treated as a part of the group reference. Subsequent digits are incorporated into the <code class="code ">index</code> only if they form a valid group reference.Only digits '0'–'9' are considered potential components of the group reference. Note that indexes of captured groups start from '1'. The group with index '0' stands for the whole match.</p></li>
<li class="list__item" id="ff5ca20f">
<p id="2013e4bb"><code class="code ">${name}</code> – the <code class="code ">name</code> can consist of Latin letters 'a'–'z', 'A'–'Z', or digits '0'–'9'. The first character must be a letter.</p>
<aside data-type="note" class="prompt" data-title="" id="13b5d1e8"><p id="7705f3ed">Named groups in replacement patterns are currently supported only on the JVM.</p></aside>
</li>
<li class="list__item" id="b85ce8c6">
<p id="9a1c892b">To include the succeeding character as a literal in the replacement string, use the backslash character <code class="code ">\</code>:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.6" data-language="kotlin">fun main() { //sampleStart println(Regex("(.+)").replace("Kotlin", """\$ $1""")) // $ Kotlin println(Regex("(.+)").replaceFirst("1.6.0", """\\ $1""")) // \ 1.6.0 //sampleEnd } </pre>
<p id="1f36adfb">You can use <a href="../api/latest/jvm/stdlib/kotlin.text/-regex/escape-replacement" id="83a14063" data-external="true" rel="noopener noreferrer"><code class="code ">Regex.escapeReplacement()</code></a> if the replacement string has to be treated as a literal string.</p>
</li>
</ul></section><section class="chapter"><h3 id="improvements-to-the-existing-api" data-toc="whatsnew16#improvements-to-the-existing-api">Improvements to the existing API</h3>
<ul class="list _ul" id="141c71d2">
<li class="list__item" id="4e8f75fc">
<p id="b638a29a">Version 1.6.0 added the infix extension function for <code class="code ">Comparable.compareTo()</code>. You can now use the infix form for comparing two objects for order:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin"> class WrappedText(val text: String) : Comparable&lt;WrappedText&gt; { override fun compareTo(other: WrappedText): Int = this.text compareTo other.text } </pre>
</li>
<li class="list__item" id="e0536e23"><p id="5da676b4"><code class="code ">Regex.replace()</code> in JS is now also not inline to unify its implementation across all platforms.</p></li>
<li class="list__item" id="e2925083"><p id="41a117c5">The <code class="code ">compareTo()</code> and <code class="code ">equals()</code> String functions, as well as the <code class="code ">isBlank()</code> CharSequence function now behave in JS exactly the same way they do on the JVM. Previously there were deviations when it came to non-ASCII characters.</p></li>
</ul></section><section class="chapter"><h3 id="deprecations" data-toc="whatsnew16#deprecations">Deprecations</h3>
<p id="7b6082cb">In Kotlin 1.6.0, we're starting the deprecation cycle with a warning for some JS-only stdlib API.</p>
<section class="chapter"><h4 id="concat-match-and-matches-string-functions" data-toc="whatsnew16#concat-match-and-matches-string-functions">concat(), match(), and matches() string functions</h4>
<ul class="list _ul" id="83ccecd6">
<li class="list__item" id="3b286cce"><p>To concatenate the string with the string representation of a given other object, use <code class="code ">plus()</code> instead of <code class="code ">concat()</code>.</p></li>
<li class="list__item" id="449b409c"><p>To find all occurrences of a regular expression within the input, use <code class="code ">findAll()</code> of the Regex class instead of <code class="code ">String.match(regex: String)</code>.</p></li>
<li class="list__item" id="5a202dad"><p>To check if the regular expression matches the entire input, use <code class="code ">matches()</code> of the Regex class instead of <code class="code ">String.matches(regex: String)</code>.</p></li>
</ul></section><section class="chapter"><h4 id="sort-on-arrays-taking-comparison-functions" data-toc="whatsnew16#sort-on-arrays-taking-comparison-functions">sort() on arrays taking comparison functions</h4>
<p id="b593e3d9">We've deprecated the <code class="code ">Array&lt;out T&gt;.sort()</code> function and the inline functions <code class="code ">ByteArray.sort()</code>, <code class="code ">ShortArray.sort()</code>, <code class="code ">IntArray.sort()</code>, <code class="code ">LongArray.sort()</code>, <code class="code ">FloatArray.sort()</code>, <code class="code ">DoubleArray.sort()</code>, and <code class="code ">CharArray.sort()</code>, which sorted arrays following the order passed by the comparison function. Use other standard library functions for array sorting.</p>
<p id="256dfa74">See the <a href="collection-ordering" id="726c813f">collection ordering</a> section for reference.</p></section></section></section><section class="chapter"><h2 id="tools" data-toc="whatsnew16#tools">Tools</h2>
<section class="chapter"><h3 id="kover-a-code-coverage-tool-for-kotlin" data-toc="whatsnew16#kover-a-code-coverage-tool-for-kotlin">Kover – a code coverage tool for Kotlin</h3>
<aside data-type="warning" class="prompt" data-title="" id="6a4a844c"><p id="bb9e72c7">The Kover Gradle plugin is Experimental. We would appreciate your feedback on it in <a href="https://github.com/Kotlin/kotlinx-kover/issues" id="1edc936b" data-external="true" rel="noopener noreferrer">GitHub</a>.</p></aside><p id="b1d63087">With Kotlin 1.6.0, we're introducing Kover – a Gradle plugin for the <a href="https://github.com/JetBrains/intellij-coverage" id="dee701b6" data-external="true" rel="noopener noreferrer">IntelliJ</a> and <a href="https://github.com/jacoco/jacoco" id="e3c52b6f" data-external="true" rel="noopener noreferrer">JaCoCo</a> Kotlin code coverage agents. It works with all language constructs, including inline functions.</p>
<p id="ad9ccc0e">Learn more about Kover on its <a href="https://github.com/Kotlin/kotlinx-kover" id="d77b16f4" data-external="true" rel="noopener noreferrer">GitHub repository</a> or in this video:</p>

</section></section><section class="chapter"><h2 id="coroutines-1-6-0-rc" data-toc="whatsnew16#coroutines-1-6-0-rc">Coroutines 1.6.0-RC</h2>
<p id="22fbaa90"><code class="code ">kotlinx.coroutines</code><a href="https://github.com/Kotlin/kotlinx.coroutines/releases/tag/1.6.0-RC" id="569bde6a" data-external="true" rel="noopener noreferrer">1.6.0-RC</a> is out with multiple features and improvements:</p>
<ul class="list _ul" id="9cc8af">
<li class="list__item" id="206a54f5"><p>Support for the <a href="#preview-of-the-new-memory-manager" id="ba7bac77">new Kotlin/Native memory manager</a></p></li>
<li class="list__item" id="82c75361"><p>Introduction of dispatcher <em id="b29c1c8a" class="">views</em> API, which allows limiting parallelism without creating additional threads</p></li>
<li class="list__item" id="2eb36ecc"><p>Migrating from Java 6 to Java 8 target</p></li>
<li class="list__item" id="d11facea"><p><code class="code ">kotlinx-coroutines-test</code> with the new reworked API and multiplatform support</p></li>
<li class="list__item" id="3cc6ea33"><p>Introduction of <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-copyable-thread-context-element/index.html" id="8f4f26a" data-external="true" rel="noopener noreferrer"><code class="code ">CopyableThreadContextElement</code></a>, which gives coroutines a thread-safe write access to <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ThreadLocal.html" id="57e45271" data-external="true" rel="noopener noreferrer"><code class="code ">ThreadLocal</code></a> variables</p></li>
</ul>
<p id="3d9c0623">Learn more in the <a href="https://github.com/Kotlin/kotlinx.coroutines/releases/tag/1.6.0-RC" id="950c9450" data-external="true" rel="noopener noreferrer">changelog</a>.</p></section><section class="chapter"><h2 id="migrating-to-kotlin-1-6-0" data-toc="whatsnew16#migrating-to-kotlin-1-6-0">Migrating to Kotlin 1.6.0</h2>
<p id="d9849e08">IntelliJ IDEA and Android Studio will suggest updating the Kotlin plugin to 1.6.0 once it is available.</p>
<p id="3b198b0c">To migrate existing projects to Kotlin 1.6.0, change the Kotlin version to <code class="code ">1.6.0</code> and reimport your Gradle or Maven project. <a href="releases#update-to-a-new-release" id="d7f7e859">Learn how to update to Kotlin 1.6.0</a>.</p>
<p id="a0d96361">To start a new project with Kotlin 1.6.0, update the Kotlin plugin and run the Project Wizard from <b id="61ace6bf" class="">File</b> | <b id="1d828cfe" class="">New</b> | <b id="8a611b0b" class="">Project</b>.</p>
<p id="3a0d00ca">The new command-line compiler is available for download on the <a href="https://github.com/JetBrains/kotlin/releases/tag/v1.6.0" id="cc292c16" data-external="true" rel="noopener noreferrer">GitHub release page</a>.</p>
<p id="5aba7599">Kotlin 1.6.0 is a <a href="kotlin-evolution#feature-releases-and-incremental-releases" id="d78bdec7">feature release</a> and can, therefore, bring changes that are incompatible with your code written for earlier versions of the language. Find the detailed list of such changes in the <a href="compatibility-guide-16" id="d67e0df0">Compatibility Guide for Kotlin 1.6</a>.</p></section><div class="last-modified"> Last modified: 27 December 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="competitive-programming">Kotlin for competitive programming</a> <a class="navigation-links__next" href="whatsnew1530">What's new in Kotlin 1.5.30</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/whatsnew16.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/whatsnew16.html</a>
  </p>
</div>
