<h1 data-toc="mapping-struct-union-types-from-c" id="mapping-struct-union-types-from-c.md">Mapping struct and union types from C – tutorial</h1>
<p id="5dba6ad6">This is the second post in the series. The very first tutorial of the series is <a href="mapping-primitive-data-types-from-c" id="4b68554">Mapping primitive data types from C</a>. There are also the <a href="mapping-function-pointers-from-c" id="bbad6a0f">Mapping function pointers from C</a> and <a href="mapping-strings-from-c" id="4b2d35d9">Mapping Strings from C</a> tutorials.</p>
<p id="4b806386">In the tutorial, you will learn:</p>
<ul class="list _ul" id="d8916ae7">
<li class="list__item" id="946e9db0"><p><a href="#mapping-struct-and-union-c-types" id="85f4d177">How struct and union types are mapped</a></p></li>
<li class="list__item" id="3f6d7d4e"><p><a href="#use-struct-and-union-types-from-kotlin" id="70da5471">How to use struct and union type from Kotlin</a></p></li>
</ul>
<section class="chapter"><h2 id="mapping-struct-and-union-c-types" data-toc="mapping-struct-union-types-from-c#mapping-struct-and-union-c-types">Mapping struct and union C types</h2>
<p id="166bed9b">The best way to understand the mapping between Kotlin and C is to try a tiny example. We will declare a struct and a union in the C language, to see how they are mapped into Kotlin.</p>
<p id="e46ebd1a">Kotlin/Native comes with the <code class="code ">cinterop</code> tool, the tool generates bindings between the C language and Kotlin. It uses a <code class="code ">.def</code> file to specify a C library to import. More details are discussed in the <a href="native-c-interop" id="bebbcdde">Interop with C Libraries</a> tutorial.</p>
<p id="21763d2f">In <a href="mapping-primitive-data-types-from-c" id="53445c0">the previous tutorial</a>, you've created a <code class="code ">lib.h</code> file. This time, include those declarations directly into the <code class="code ">interop.def</code> file, after the <code class="code ">---</code> separator line:</p>
<pre class="code-block" data-lang="c" data-language="c"> --- typedef struct { int a; double b; } MyStruct; void struct_by_value(MyStruct s) {} void struct_by_pointer(MyStruct* s) {} typedef union { int a; MyStruct b; float c; } MyUnion; void union_by_value(MyUnion u) {} void union_by_pointer(MyUnion* u) {} </pre>
<p id="4c7ff84a">The <code class="code ">interop.def</code> file is enough to compile and run the application or open it in an IDE. Now it is time to create project files, open the project in <a href="https://jetbrains.com/idea" id="8eccbbfc" data-external="true" rel="noopener noreferrer">IntelliJ IDEA</a> and run it.</p></section><section class="chapter"><h2 id="inspect-generated-kotlin-apis-for-a-c-library" data-toc="mapping-struct-union-types-from-c#inspect-generated-kotlin-apis-for-a-c-library">Inspect Generated Kotlin APIs for a C library</h2>
<p id="18f20a4a">While it is possible to use the command line, either directly or by combining it with a script file (such as <code class="code ">.sh</code> or <code class="code ">.bat</code> file), this approach doesn't scale well for big projects that have hundreds of files and libraries. It is then better to use the Kotlin/Native compiler with a build system, as it helps to download and cache the Kotlin/Native compiler binaries and libraries with transitive dependencies and run the compiler and tests. Kotlin/Native can use the <a href="https://gradle.org" id="ab1caa32" data-external="true" rel="noopener noreferrer">Gradle</a> build system through the <a href="mpp-discover-project#multiplatform-plugin" id="4be47ffe">kotlin-multiplatform</a> plugin.</p>
<p id="2375f625">We covered the basics of setting up an IDE compatible project with Gradle in the <a href="native-gradle" id="acd7c4aa">A Basic Kotlin/Native Application</a> tutorial. Please check it out if you are looking for detailed first steps and instructions on how to start a new Kotlin/Native project and open it in IntelliJ IDEA. In this tutorial, we'll look at the advanced C interop related usages of Kotlin/Native and <a href="mpp-discover-project#multiplatform-plugin" id="1ad00017">multiplatform</a> builds with Gradle.</p>
<p id="108df836">First, create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes the missing directories will have to be created before any new files can be added.</p>
<p id="71c636b1">Use the following <code class="code ">build.gradle(.kts)</code> Gradle build file:</p>
<div class="tabs" id="3b17c113" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="be4598dc" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code-block" data-lang="kotlin" data-title="Kotlin" data-language="kotlin">plugins { kotlin("multiplatform") version "1.6.10" } repositories { mavenCentral() } kotlin { linuxX64("native") { // on Linux // macosX64("native") { // on x86_64 macOS // macosArm64("native") { // on Apple Silicon macOS // mingwX64("native") { // on Windows val main by compilations.getting val interop by main.cinterops.creating binaries { executable() } } } tasks.wrapper { gradleVersion = "6.7.1" distributionType = Wrapper.DistributionType.BIN } </pre></div>
<div class="tabs__content" data-gtm="tab" id="3feb8937" data-sync-tabs="groovy" data-title="Groovy"><pre class="code-block" data-lang="groovy" data-title="Groovy" data-language="groovy">plugins { id 'org.jetbrains.kotlin.multiplatform' version '1.6.10' } repositories { mavenCentral() } kotlin { linuxX64('native') { // on Linux // macosX64("native") { // on x86_64 macOS // macosArm64("native") { // on Apple Silicon macOS // mingwX64('native') { // on Windows compilations.main.cinterops { interop } binaries { executable() } } } wrapper { gradleVersion = '6.7.1' distributionType = 'BIN' } </pre></div>
</div>
<p id="b464f7c1">The project file configures the C interop as an additional step of the build. Let's move the <code class="code ">interop.def</code> file to the <code class="code ">src/nativeInterop/cinterop</code> directory. Gradle recommends using conventions instead of configurations, for example, the source files are expected to be in the <code class="code ">src/nativeMain/kotlin</code> folder. By default, all the symbols from C are imported to the <code class="code ">interop</code> package, you may want to import the whole package in our <code class="code ">.kt</code> files. Check out the <a href="mpp-discover-project#multiplatform-plugin" id="59f83473">kotlin-multiplatform</a> plugin documentation to learn about all the different ways you could configure it.</p>
<p id="7dd59732">Create a <code class="code ">src/nativeMain/kotlin/hello.kt</code> stub file with the following content to see how C declarations are visible from Kotlin:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">import interop.* fun main() { println("Hello Kotlin/Native!") struct_by_value(/* fix me*/) struct_by_pointer(/* fix me*/) union_by_value(/* fix me*/) union_by_pointer(/* fix me*/) } </pre>
<p id="e840eedf">Now you are ready to <a href="native-get-started" id="b57e8ea2">open the project in IntelliJ IDEA</a> and to see how to fix the example project. While doing that, see how C primitive types are mapped into Kotlin/Native.</p></section><section class="chapter"><h2 id="primitive-types-in-kotlin" data-toc="mapping-struct-union-types-from-c#primitive-types-in-kotlin">Primitive types in Kotlin</h2>
<p id="96290fc8">With the help of IntelliJ IDEA's <b id="26df151b" class="">Go to | Declaration</b> or compiler errors, you see the following generated API for the C functions, <code class="code ">struct</code>, and <code class="code ">union</code>:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun struct_by_value(s: CValue&lt;MyStruct&gt;) fun struct_by_pointer(s: CValuesRef&lt;MyStruct&gt;?) fun union_by_value(u: CValue&lt;MyUnion&gt;) fun union_by_pointer(u: CValuesRef&lt;MyUnion&gt;?) class MyStruct constructor(rawPtr: NativePtr /* = NativePtr */) : CStructVar { var a: Int var b: Double companion object : CStructVar.Type } class MyUnion constructor(rawPtr: NativePtr /* = NativePtr */) : CStructVar { var a: Int val b: MyStruct var c: Float companion object : CStructVar.Type } </pre>
<p id="f7e0db53">You see that <code class="code ">cinterop</code> generated wrapper types for our <code class="code ">struct</code> and <code class="code ">union</code> types. For <code class="code ">MyStruct</code> and <code class="code ">MyUnion</code> type declarations in C, there are the Kotlin classes <code class="code ">MyStruct</code> and <code class="code ">MyUnion</code> generated respectively. The wrappers inherit from the <code class="code ">CStructVar</code> base class and declare all fields as Kotlin properties. It uses <code class="code ">CValue&lt;T&gt;</code> to represent a by-value structure parameter and <code class="code ">CValuesRef&lt;T&gt;?</code> to represent passing a pointer to a structure or a union.</p>
<p id="c423d3c0">Technically, there is no difference between <code class="code ">struct</code> and <code class="code ">union</code> types on the Kotlin side. Note that <code class="code ">a</code>, <code class="code ">b</code>, and <code class="code ">c</code> properties of <code class="code ">MyUnion</code> class in Kotlin use the same memory location to read/write their value just like <code class="code ">union</code> does in C language.</p>
<p id="64613dc">More details and advanced use-cases are presented in the<br> <a href="native-c-interop" id="71b3eb2b">C Interop documentation</a></p></section><section class="chapter"><h2 id="use-struct-and-union-types-from-kotlin" data-toc="mapping-struct-union-types-from-c#use-struct-and-union-types-from-kotlin">Use struct and union types from Kotlin</h2>
<p id="b1738ab7">It is easy to use the generated wrapper classes for C <code class="code ">struct</code> and <code class="code ">union</code> types from Kotlin. Thanks to the generated properties, it feels natural to use them in Kotlin code. The only question, so far, is how to create a new instance on those classes. As you see from the declarations of <code class="code ">MyStruct</code> and <code class="code ">MyUnion</code>, their constructors require a <code class="code ">NativePtr</code>. Of course, you are not willing to deal with pointers manually. Instead, you can use Kotlin API to have those objects instantiated for us.</p>
<p id="d5265a23">Let's take a look at the generated functions that take our <code class="code ">MyStruct</code> and <code class="code ">MyUnion</code> as parameters. You see that by-value parameters are represented as <code class="code ">kotlinx.cinterop.CValue&lt;T&gt;</code>. And for typed pointer parameters you see <code class="code ">kotlinx.cinterop.CValuesRef&lt;T&gt;</code>. Kotlin provides us with an API to deal with both types easily, let's try it and see.</p>
<section class="chapter"><h3 id="create-a-cvalue-lt-t-gt" data-toc="mapping-struct-union-types-from-c#create-a-cvalue-lt-t-gt">Create a CValue
</h3>
<p id="17765f0c"><code class="code ">CValue&lt;T&gt;</code> type is used to pass by-value parameters to a C function call. Use <code class="code ">cValue</code> function to create <code class="code ">CValue&lt;T&gt;</code> object instance. The function requires a <a href="lambdas#function-literals-with-receiver" id="af0cec49">lambda function with a receiver</a> to initialize the underlying C type in-place. The function is declared as follows:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun &lt;reified T : CStructVar&gt; cValue(initialize: T.() -&gt; Unit): CValue&lt;T&gt; </pre>
<p id="dcca2f99">Now it is time to see how to use <code class="code ">cValue</code> and pass by-value parameters:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun callValue() { val cStruct = cValue&lt;MyStruct&gt; { a = 42 b = 3.14 } struct_by_value(cStruct) val cUnion = cValue&lt;MyUnion&gt; { b.a = 5 b.b = 2.7182 } union_by_value(cUnion) } </pre></section><section class="chapter"><h3 id="create-struct-and-union-as-cvaluesref-lt-t-gt" data-toc="mapping-struct-union-types-from-c#create-struct-and-union-as-cvaluesref-lt-t-gt">Create struct and union as CValuesRef
</h3>
<p id="e34312fe"><code class="code ">CValuesRef&lt;T&gt;</code> type is used in Kotlin to pass a typed pointer parameter of a C function. First, you need an instance of <code class="code ">MyStruct</code> and <code class="code ">MyUnion</code> classes. Create them directly in the native memory. Use the</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun &lt;reified T : kotlinx.cinterop.CVariable&gt; alloc(): T </pre>
<p id="63b96041">extension function on <code class="code ">kotlinx.cinterop.NativePlacement</code> type for this.</p>
<p id="f66ee2b1"><code class="code ">NativePlacement</code> represents native memory with functions similar to <code class="code ">malloc</code> and <code class="code ">free</code>. There are several implementations of <code class="code ">NativePlacement</code>. The global one is called with <code class="code ">kotlinx.cinterop.nativeHeap</code> and don't forget to call the <code class="code ">nativeHeap.free(..)</code> function to free the memory after use.</p>
<p id="62150a99">Another option is to use the</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun &lt;R&gt; memScoped(block: kotlinx.cinterop.MemScope.() -&gt; R): R </pre>
<p id="9ef87802">function. It creates a short-lived memory allocation scope, and all allocations will be cleaned up automatically at the end of the <code class="code ">block</code>.</p>
<p id="52fca8bd">Your code to call functions with pointers will look like this:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun callRef() { memScoped { val cStruct = alloc&lt;MyStruct&gt;() cStruct.a = 42 cStruct.b = 3.14 struct_by_pointer(cStruct.ptr) val cUnion = alloc&lt;MyUnion&gt;() cUnion.b.a = 5 cUnion.b.b = 2.7182 union_by_pointer(cUnion.ptr) } } </pre>
<p id="e1317f06">Note that this code uses the extension property <code class="code ">ptr</code> which comes from a <code class="code ">memScoped</code> lambda receiver type, to turn <code class="code ">MyStruct</code> and <code class="code ">MyUnion</code> instances into native pointers.</p>
<p id="2423ac6c">The <code class="code ">MyStruct</code> and <code class="code ">MyUnion</code> classes have the pointer to the native memory underneath. The memory will be released when a <code class="code ">memScoped</code> function ends, which is equal to the end of its <code class="code ">block</code>. Make sure that a pointer is not used outside of the <code class="code ">memScoped</code> call. You may use <code class="code ">Arena()</code> or <code class="code ">nativeHeap</code> for pointers that should be available longer, or are cached inside a C library.</p></section><section class="chapter"><h3 id="conversion-between-cvalue-lt-t-gt-and-cvaluesref-lt-t-gt" data-toc="mapping-struct-union-types-from-c#conversion-between-cvalue-lt-t-gt-and-cvaluesref-lt-t-gt">Conversion between CValue<t> and CValuesRef</t>
</h3>
<p id="55a61cea">Of course, there are use cases when you need to pass a struct as a value to one call, and then, to pass the same struct as a reference to another call. This is possible in Kotlin/Native too. A <code class="code ">NativePlacement</code> will be needed here.</p>
<p id="f488c44">Let's see now <code class="code ">CValue&lt;T&gt;</code> is turned to a pointer first:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun callMix_ref() { val cStruct = cValue&lt;MyStruct&gt; { a = 42 b = 3.14 } memScoped { struct_by_pointer(cStruct.ptr) } } </pre>
<p id="7200821b">This code uses the extension property <code class="code ">ptr</code> which comes from <code class="code ">memScoped</code> lambda receiver type to turn <code class="code ">MyStruct</code> and <code class="code ">MyUnion</code> instances into native pointers. Those pointers are only valid inside the <code class="code ">memScoped</code> block.</p>
<p id="bbf6a64a">For the opposite conversion, to turn a pointer into a by-value variable, we call the <code class="code ">readValue()</code> extension function:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun callMix_value() { memScoped { val cStruct = alloc&lt;MyStruct&gt;() cStruct.a = 42 cStruct.b = 3.14 struct_by_value(cStruct.readValue()) } } </pre></section></section><section class="chapter"><h2 id="run-the-code" data-toc="mapping-struct-union-types-from-c#run-the-code">Run the code</h2>
<p id="c1115f7f">Now when you have learned how to use C declarations in your code, you are ready to try it out on a real example. Let's fix the code and see how it runs by calling the <code class="code ">runDebugExecutableNative</code> Gradle task <a href="native-get-started" id="476e270f">in the IDE</a> or by using the following console command:</p>
<pre class="code-block" data-lang="bash" data-language="bash">./gradlew runDebugExecutableNative </pre>
<p id="25d20d18">The final code in the <code class="code ">hello.kt</code> file may look like this:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">import interop.* import kotlinx.cinterop.alloc import kotlinx.cinterop.cValue import kotlinx.cinterop.memScoped import kotlinx.cinterop.ptr import kotlinx.cinterop.readValue fun main() { println("Hello Kotlin/Native!") val cUnion = cValue&lt;MyUnion&gt; { b.a = 5 b.b = 2.7182 } memScoped { union_by_value(cUnion) union_by_pointer(cUnion.ptr) } memScoped { val cStruct = alloc&lt;MyStruct&gt; { a = 42 b = 3.14 } struct_by_value(cStruct.readValue()) struct_by_pointer(cStruct.ptr) } } </pre></section><section class="chapter"><h2 id="next-steps" data-toc="mapping-struct-union-types-from-c#next-steps">Next steps</h2>
<p id="816cebf5">Continue exploring the C language types and their representation in Kotlin/Native in the related tutorials:</p>
<ul class="list _ul" id="e4814b5a">
<li class="list__item" id="ad108a3b"><p><a href="mapping-primitive-data-types-from-c" id="7abc0662">Mapping primitive data types from C</a></p></li>
<li class="list__item" id="1d9158cb"><p><a href="mapping-function-pointers-from-c" id="838be6a7">Mapping function pointers from C</a></p></li>
<li class="list__item" id="64f6206"><p><a href="mapping-strings-from-c" id="611ac197">Mapping strings from C</a></p></li>
</ul>
<p id="9a19ecb6">The <a href="native-c-interop" id="906e19c">C Interop documentation</a> covers more advanced scenarios of the interop.</p></section><div class="last-modified"> Last modified: 08 September 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="mapping-primitive-data-types-from-c">Mapping primitive data types from C – tutorial</a> <a class="navigation-links__next" href="mapping-function-pointers-from-c">Mapping function pointers from C – tutorial</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/mapping-struct-union-types-from-c.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/mapping-struct-union-types-from-c.html</a>
  </p>
</div>
