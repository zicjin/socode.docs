<h1 data-toc="collection-filtering" id="collection-filtering.md">Filtering collections</h1>
<p id="8f31ab42">Filtering is one of the most popular tasks in collection processing. In Kotlin, filtering conditions are defined by <em id="a507e4dc" class="">predicates</em> – lambda functions that take a collection element and return a boolean value: <code class="code ">true</code> means that the given element matches the predicate, <code class="code ">false</code> means the opposite.</p>
<p id="bfee5339">The standard library contains a group of extension functions that let you filter collections in a single call. These functions leave the original collection unchanged, so they are available for both <a href="collections-overview#collection-types" id="53544542">mutable and read-only</a> collections. To operate the filtering result, you should assign it to a variable or chain the functions after filtering.</p>
<section class="chapter"><h2 id="filter-by-predicate" data-toc="collection-filtering#filter-by-predicate">Filter by predicate</h2>
<p id="6a57bfb2">The basic filtering function is <a href="../api/latest/jvm/stdlib/kotlin.collections/filter" id="31c0af8c" data-external="true" rel="noopener noreferrer"><code class="code ">filter()</code></a>. When called with a predicate, <code class="code ">filter()</code> returns the collection elements that match it. For both <code class="code ">List</code> and <code class="code ">Set</code>, the resulting collection is a <code class="code ">List</code>, for <code class="code ">Map</code> it's a <code class="code ">Map</code> as well.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val numbers = listOf("one", "two", "three", "four") val longerThan3 = numbers.filter { it.length &gt; 3 } println(longerThan3) val numbersMap = mapOf("key1" to 1, "key2" to 2, "key3" to 3, "key11" to 11) val filteredMap = numbersMap.filter { (key, value) -&gt; key.endsWith("1") &amp;&amp; value &gt; 10} println(filteredMap) //sampleEnd } </pre>
<p id="d7b3bdb9">The predicates in <code class="code ">filter()</code> can only check the values of the elements. If you want to use element positions in the filter, use <a href="../api/latest/jvm/stdlib/kotlin.collections/filter-indexed" id="147616" data-external="true" rel="noopener noreferrer"><code class="code ">filterIndexed()</code></a>. It takes a predicate with two arguments: the index and the value of an element.</p>
<p id="3a905338">To filter collections by negative conditions, use <a href="../api/latest/jvm/stdlib/kotlin.collections/filter-not" id="d9e40744" data-external="true" rel="noopener noreferrer"><code class="code ">filterNot()</code></a>. It returns a list of elements for which the predicate yields <code class="code ">false</code>.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val numbers = listOf("one", "two", "three", "four") val filteredIdx = numbers.filterIndexed { index, s -&gt; (index != 0) &amp;&amp; (s.length &lt; 5) } val filteredNot = numbers.filterNot { it.length &lt;= 3 } println(filteredIdx) println(filteredNot) //sampleEnd } </pre>
<p id="849a36">There are also functions that narrow the element type by filtering elements of a given type:</p>
<ul class="list _ul" id="f5e69320">
<li class="list__item" id="27123509">
<p id="cf26284f"><a href="../api/latest/jvm/stdlib/kotlin.collections/filter-is-instance" id="da37c0ac" data-external="true" rel="noopener noreferrer"><code class="code ">filterIsInstance()</code></a> returns collection elements of a given type. Being called on a <code class="code ">List&lt;Any&gt;</code>, <code class="code ">filterIsInstance&lt;T&gt;()</code> returns a <code class="code ">List&lt;T&gt;</code>, thus allowing you to call functions of the <code class="code ">T</code> type on its items.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val numbers = listOf(null, 1, "two", 3.0, "four") println("All String elements in upper case:") numbers.filterIsInstance&lt;String&gt;().forEach { println(it.uppercase()) } //sampleEnd } </pre>
</li>
<li class="list__item" id="f8f22b5a">
<p id="3e21e992"><a href="../api/latest/jvm/stdlib/kotlin.collections/filter-not-null" id="a45d8e35" data-external="true" rel="noopener noreferrer"><code class="code ">filterNotNull()</code></a> returns all non-null elements. Being called on a <code class="code ">List&lt;T?&gt;</code>, <code class="code ">filterNotNull()</code> returns a <code class="code ">List&lt;T: Any&gt;</code>, thus allowing you to treat the elements as non-null objects.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val numbers = listOf(null, "one", "two", null) numbers.filterNotNull().forEach { println(it.length) // length is unavailable for nullable Strings } //sampleEnd } </pre>
</li>
</ul></section><section class="chapter"><h2 id="partition" data-toc="collection-filtering#partition">Partition</h2>
<p id="a357c656">Another filtering function – <a href="../api/latest/jvm/stdlib/kotlin.collections/partition" id="19d3f768" data-external="true" rel="noopener noreferrer"><code class="code ">partition()</code></a> – filters a collection by a predicate and keeps the elements that don't match it in a separate list. So, you have a <code class="code ">Pair</code> of <code class="code ">List</code>s as a return value: the first list containing elements that match the predicate and the second one containing everything else from the original collection.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val numbers = listOf("one", "two", "three", "four") val (match, rest) = numbers.partition { it.length &gt; 3 } println(match) println(rest) //sampleEnd } </pre></section><section class="chapter"><h2 id="test-predicates" data-toc="collection-filtering#test-predicates">Test predicates</h2>
<p id="7d2a3b79">Finally, there are functions that simply test a predicate against collection elements:</p>
<ul class="list _ul" id="85be1e51">
<li class="list__item" id="59052ab4"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/any" id="3ea3c227" data-external="true" rel="noopener noreferrer"><code class="code ">any()</code></a> returns <code class="code ">true</code> if at least one element matches the given predicate.</p></li>
<li class="list__item" id="7140fd4f"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/none" id="123c9c01" data-external="true" rel="noopener noreferrer"><code class="code ">none()</code></a> returns <code class="code ">true</code> if none of the elements match the given predicate.</p></li>
<li class="list__item" id="2b52f81f"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/all" id="25aeb2e" data-external="true" rel="noopener noreferrer"><code class="code ">all()</code></a> returns <code class="code ">true</code> if all elements match the given predicate. Note that <code class="code ">all()</code> returns <code class="code ">true</code> when called with any valid predicate on an empty collection. Such behavior is known in logic as <em id="44ddfb31" class=""><a href="https://en.wikipedia.org/wiki/Vacuous_truth" id="e9a01da0" data-external="true" rel="noopener noreferrer">vacuous truth</a></em>.</p></li>
</ul>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val numbers = listOf("one", "two", "three", "four") println(numbers.any { it.endsWith("e") }) println(numbers.none { it.endsWith("a") }) println(numbers.all { it.endsWith("e") }) println(emptyList&lt;Int&gt;().all { it &gt; 5 }) // vacuous truth //sampleEnd } </pre>
<p id="28606d28"><code class="code ">any()</code> and <code class="code ">none()</code> can also be used without a predicate: in this case they just check the collection emptiness. <code class="code ">any()</code> returns <code class="code ">true</code> if there are elements and <code class="code ">false</code> if there aren't; <code class="code ">none()</code> does the opposite.</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val numbers = listOf("one", "two", "three", "four") val empty = emptyList&lt;String&gt;() println(numbers.any()) println(empty.any()) println(numbers.none()) println(empty.none()) //sampleEnd } </pre></section><div class="last-modified"> Last modified: 15 October 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="collection-transformations">Collection transformation operations</a> <a class="navigation-links__next" href="collection-plus-minus">Plus and minus operators</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/collection-filtering.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/collection-filtering.html</a>
  </p>
</div>
