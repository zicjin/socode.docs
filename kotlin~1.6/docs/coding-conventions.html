<h1 data-toc="coding-conventions" id="coding-conventions.md">Coding conventions</h1>
<p id="e08f319c">Commonly known and easy-to-follow coding conventions are vital for any programming language. Here we provide guidelines on the code style and code organization for projects that use Kotlin.</p>
<section class="chapter"><h2 id="configure-style-in-ide" data-toc="coding-conventions#configure-style-in-ide">Configure style in IDE</h2>
<p id="e12894b8">Two most popular IDEs for Kotlin - <a href="https://www.jetbrains.com/idea/" id="8089d300" data-external="true" rel="noopener noreferrer">IntelliJ IDEA</a> and <a href="https://developer.android.com/studio/" id="ba1ee100" data-external="true" rel="noopener noreferrer">Android Studio</a> provide powerful support for code styling. You can configure them to automatically format your code in consistence with the given code style.</p>
<section class="chapter"><h3 id="apply-the-style-guide" data-toc="coding-conventions#apply-the-style-guide">Apply the style guide</h3>
<ol class="list _decimal" id="b545113d">
<li class="list__item" id="ff3f33c6"><p>Go to <b id="7e19af58" class="">Settings/Preferences | Editor | Code Style | Kotlin</b>.</p></li>
<li class="list__item" id="c8c67d7f"><p>Click <b id="a2816752" class="">Set from...</b>.</p></li>
<li class="list__item" id="922b550d"><p>Select <b id="f1c5c0da" class="">Kotlin style guide</b>.</p></li>
</ol></section><section class="chapter"><h3 id="verify-that-your-code-follows-the-style-guide" data-toc="coding-conventions#verify-that-your-code-follows-the-style-guide">Verify that your code follows the style guide</h3>
<ol class="list _decimal" id="9f62e400">
<li class="list__item" id="5127e8e7"><p>Go to <b id="fa74c589" class="">Settings/Preferences | Editor | Inspections | Kotlin</b>.</p></li>
<li class="list__item" id="9c901ac2"><p>Open <b id="6f52f23b" class="">Kotlin | Style issues</b>.</p></li>
<li class="list__item" id="fc664416"><p>Switch on <b id="3c7b178c" class="">File is not formatted according to project settings</b> inspection. Additional inspections that verify other issues described in the style guide (such as naming conventions) are enabled by default.</p></li>
</ol></section></section><section class="chapter"><h2 id="source-code-organization" data-toc="coding-conventions#source-code-organization">Source code organization</h2>
<section class="chapter"><h3 id="directory-structure" data-toc="coding-conventions#directory-structure">Directory structure</h3>
<p id="e881bcc0">In pure Kotlin projects, the recommended directory structure follows the package structure with the common root package omitted. For example, if all the code in the project is in the <code class="code ">org.example.kotlin</code> package and its subpackages, files with the <code class="code ">org.example.kotlin</code> package should be placed directly under the source root, and files in <code class="code ">org.example.kotlin.network.socket</code> should be in the <code class="code ">network/socket</code> subdirectory of the source root.</p>
<aside data-type="note" class="prompt" data-title="" id="faf9ce3c"><p id="694ee018">On JVM: In projects where Kotlin is used together with Java, Kotlin source files should reside in the same source root as the Java source files, and follow the same directory structure: each file should be stored in the directory corresponding to each package statement.</p></aside></section><section class="chapter"><h3 id="source-file-names" data-toc="coding-conventions#source-file-names">Source file names</h3>
<p id="479538be">If a Kotlin file contains a single class (potentially with related top-level declarations), its name should be the same as the name of the class, with the <code class="code ">.kt</code> extension appended. If a file contains multiple classes, or only top-level declarations, choose a name describing what the file contains, and name the file accordingly. Use <a href="https://en.wikipedia.org/wiki/Camel_case" id="8602099d" data-external="true" rel="noopener noreferrer">upper camel case</a> with an uppercase first letter (also known as Pascal case), for example, <code class="code ">ProcessDeclarations.kt</code>.</p>
<p id="71aa1a72">The name of the file should describe what the code in the file does. Therefore, you should avoid using meaningless words such as <code class="code ">Util</code> in file names.</p></section><section class="chapter"><h3 id="source-file-organization" data-toc="coding-conventions#source-file-organization">Source file organization</h3>
<p id="65f712fa">Placing multiple declarations (classes, top-level functions or properties) in the same Kotlin source file is encouraged as long as these declarations are closely related to each other semantically, and the file size remains reasonable (not exceeding a few hundred lines).</p>
<p id="42711518">In particular, when defining extension functions for a class which are relevant for all clients of this class, put them in the same file with the class itself. When defining extension functions that make sense only for a specific client, put them next to the code of that client. Avoid creating files just to hold all extensions of some class.</p></section><section class="chapter"><h3 id="class-layout" data-toc="coding-conventions#class-layout">Class layout</h3>
<p id="1a7118fc">The contents of a class should go in the following order:</p>
<ol class="list _decimal" id="dde8ba30">
<li class="list__item" id="b46fe34e"><p>Property declarations and initializer blocks</p></li>
<li class="list__item" id="c14e0211"><p>Secondary constructors</p></li>
<li class="list__item" id="a15bf66"><p>Method declarations</p></li>
<li class="list__item" id="9cd15893"><p>Companion object</p></li>
</ol>
<p id="47786b13">Do not sort the method declarations alphabetically or by visibility, and do not separate regular methods from extension methods. Instead, put related stuff together, so that someone reading the class from top to bottom can follow the logic of what's happening. Choose an order (either higher-level stuff first, or vice versa) and stick to it.</p>
<p id="f70e192a">Put nested classes next to the code that uses those classes. If the classes are intended to be used externally and aren't referenced inside the class, put them in the end, after the companion object.</p></section><section class="chapter"><h3 id="interface-implementation-layout" data-toc="coding-conventions#interface-implementation-layout">Interface implementation layout</h3>
<p id="a93fe05f">When implementing an interface, keep the implementing members in the same order as members of the interface (if necessary, interspersed with additional private methods used for the implementation).</p></section><section class="chapter"><h3 id="overload-layout" data-toc="coding-conventions#overload-layout">Overload layout</h3>
<p id="343f79e1">Always put overloads next to each other in a class.</p></section></section><section class="chapter"><h2 id="naming-rules" data-toc="coding-conventions#naming-rules">Naming rules</h2>
<p id="8ec06cd8">Package and class naming rules in Kotlin are quite simple:</p>
<ul class="list _ul" id="4cc2ef87">
<li class="list__item" id="fd7a679f"><p id="12ec604">Names of packages are always lowercase and do not use underscores (<code class="code ">org.example.project</code>). Using multi-word names is generally discouraged, but if you do need to use multiple words, you can either just concatenate them together or use camel case (<code class="code ">org.example.myProject</code>).</p></li>
<li class="list__item" id="5813aacb"><p id="605a3534">Names of classes and objects start with an uppercase letter and use camel case:</p></li>
</ul>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">open class DeclarationProcessor { /*...*/ } object EmptyDeclarationProcessor : DeclarationProcessor() { /*...*/ } </pre>
<section class="chapter"><h3 id="function-names" data-toc="coding-conventions#function-names">Function names</h3>
<p id="9b0c3347">Names of functions, properties and local variables start with a lowercase letter and use camel case and no underscores:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun processDeclarations() { /*...*/ } var declarationCount = 1 </pre>
<p id="d516b8d5">Exception: factory functions used to create instances of classes can have the same name as the abstract return type:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">interface Foo { /*...*/ } class FooImpl : Foo { /*...*/ } fun Foo(): Foo { return FooImpl() } </pre></section><section class="chapter"><h3 id="names-for-test-methods" data-toc="coding-conventions#names-for-test-methods">Names for test methods</h3>
<p id="ea91a02d">In tests (and <b id="b175e961" class="">only</b> in tests), you can use method names with spaces enclosed in backticks. Note that such method names are currently not supported by the Android runtime. Underscores in method names are also allowed in test code.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class MyTestCase { @Test fun `ensure everything works`() { /*...*/ } @Test fun ensureEverythingWorks_onAndroid() { /*...*/ } } </pre></section><section class="chapter"><h3 id="property-names" data-toc="coding-conventions#property-names">Property names</h3>
<p id="5d34cb73">Names of constants (properties marked with <code class="code ">const</code>, or top-level or object <code class="code ">val</code> properties with no custom <code class="code ">get</code> function that hold deeply immutable data) should use uppercase underscore-separated (<a href="https://en.wikipedia.org/wiki/Snake_case" id="fecb096b" data-external="true" rel="noopener noreferrer">screaming snake case</a>) names:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">const val MAX_COUNT = 8 val USER_NAME_FIELD = "UserName" </pre>
<p id="2e8f0bdc">Names of top-level or object properties which hold objects with behavior or mutable data should use camel case names:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val mutableCollection: MutableSet&lt;String&gt; = HashSet() </pre>
<p id="a16aadf6">Names of properties holding references to singleton objects can use the same naming style as <code class="code ">object</code> declarations:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val PersonComparator: Comparator&lt;Person&gt; = /*...*/ </pre>
<p id="42348d73">For enum constants, it's OK to use either uppercase underscore-separated names (<a href="https://en.wikipedia.org/wiki/Snake_case" id="190ceea0" data-external="true" rel="noopener noreferrer">screaming snake case</a>) (<code class="code ">enum class Color { RED, GREEN }</code>) or upper camel case names, depending on the usage.</p></section><section class="chapter"><h3 id="names-for-backing-properties" data-toc="coding-conventions#names-for-backing-properties">Names for backing properties</h3>
<p id="ff8092c2">If a class has two properties which are conceptually the same but one is part of a public API and another is an implementation detail, use an underscore as the prefix for the name of the private property:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class C { private val _elementList = mutableListOf&lt;Element&gt;() val elementList: List&lt;Element&gt; get() = _elementList } </pre></section><section class="chapter"><h3 id="choose-good-names" data-toc="coding-conventions#choose-good-names">Choose good names</h3>
<p id="a17cc522">The name of a class is usually a noun or a noun phrase explaining what the class <em id="836eb353" class="">is</em>: <code class="code ">List</code>, <code class="code ">PersonReader</code>.</p>
<p id="b3c6fcf6">The name of a method is usually a verb or a verb phrase saying what the method <em id="32fbe8a7" class="">does</em>: <code class="code ">close</code>, <code class="code ">readPersons</code>. The name should also suggest if the method is mutating the object or returning a new one. For instance <code class="code ">sort</code> is sorting a collection in place, while <code class="code ">sorted</code> is returning a sorted copy of the collection.</p>
<p id="6ef5ecb8">The names should make it clear what the purpose of the entity is, so it's best to avoid using meaningless words (<code class="code ">Manager</code>, <code class="code ">Wrapper</code>) in names.</p>
<p id="f3db48aa">When using an acronym as part of a declaration name, capitalize it if it consists of two letters (<code class="code ">IOStream</code>); capitalize only the first letter if it is longer (<code class="code ">XmlFormatter</code>, <code class="code ">HttpInputStream</code>).</p></section></section><section class="chapter"><h2 id="formatting" data-toc="coding-conventions#formatting">Formatting</h2>
<section class="chapter"><h3 id="indentation" data-toc="coding-conventions#indentation">Indentation</h3>
<p id="a7ed6938">Use four spaces for indentation. Do not use tabs.</p>
<p id="2feec98c">For curly braces, put the opening brace in the end of the line where the construct begins, and the closing brace on a separate line aligned horizontally with the opening construct.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">if (elements != null) { for (element in elements) { // ... } } </pre>
<aside data-type="note" class="prompt" data-title="" id="e7cfddf"><p id="c8f744f5">In Kotlin, semicolons are optional, and therefore line breaks are significant. The language design assumes Java-style braces, and you may encounter surprising behavior if you try to use a different formatting style.</p></aside></section><section class="chapter"><h3 id="horizontal-whitespace" data-toc="coding-conventions#horizontal-whitespace">Horizontal whitespace</h3>
<ul class="list _ul" id="cc31f234">
<li class="list__item" id="12743e"><p id="f59f11e3">Put spaces around binary operators (<code class="code ">a + b</code>). Exception: don't put spaces around the "range to" operator (<code class="code ">0..i</code>).</p></li>
<li class="list__item" id="35a0ddf6"><p id="88b366d2">Do not put spaces around unary operators (<code class="code ">a++</code>).</p></li>
<li class="list__item" id="6d1a740c"><p id="f07b3353">Put spaces between control flow keywords (<code class="code ">if</code>, <code class="code ">when</code>, <code class="code ">for</code>, and <code class="code ">while</code>) and the corresponding opening parenthesis.</p></li>
<li class="list__item" id="683d32a5"><p id="a4d8198a">Do not put a space before an opening parenthesis in a primary constructor declaration, method declaration or method call.</p></li>
</ul>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class A(val x: Int) fun foo(x: Int) { ... } fun bar() { foo(1) } </pre>
<ul class="list _ul" id="d9ea3327">
<li class="list__item" id="2befc267"><p id="607f5183">Never put a space after <code class="code ">(</code>, <code class="code ">[</code>, or before <code class="code ">]</code>, <code class="code ">)</code></p></li>
<li class="list__item" id="949d5680"><p id="bf9f2540">Never put a space around <code class="code ">.</code> or <code class="code ">?.</code>: <code class="code ">foo.bar().filter { it &gt; 2 }.joinToString()</code>, <code class="code ">foo?.bar()</code></p></li>
<li class="list__item" id="5f525b05"><p id="fcf1d7e0">Put a space after <code class="code ">//</code>: <code class="code ">// This is a comment</code></p></li>
<li class="list__item" id="9bb0f645"><p id="893e1ea2">Do not put spaces around angle brackets used to specify type parameters: <code class="code ">class Map&lt;K, V&gt; { ... }</code></p></li>
<li class="list__item" id="7eb2b760"><p id="1e410e90">Do not put spaces around <code class="code ">::</code>: <code class="code ">Foo::class</code>, <code class="code ">String::length</code></p></li>
<li class="list__item" id="5e61f912"><p id="e3cb1d41">Do not put a space before <code class="code ">?</code> used to mark a nullable type: <code class="code ">String?</code></p></li>
</ul>
<p id="7bda9ffa">As a general rule, avoid horizontal alignment of any kind. Renaming an identifier to a name with a different length should not affect the formatting of either the declaration or any of the usages.</p></section><section class="chapter"><h3 id="colon" data-toc="coding-conventions#colon">Colon</h3>
<p id="e2b41b0">Put a space before <code class="code ">:</code> in the following cases:</p>
<ul class="list _ul" id="e0e91704">
<li class="list__item" id="2695494c"><p>when it's used to separate a type and a supertype</p></li>
<li class="list__item" id="bcc32e93"><p>when delegating to a superclass constructor or a different constructor of the same class</p></li>
<li class="list__item" id="e1ba65fb"><p>after the <code class="code ">object</code> keyword</p></li>
</ul>
<p id="695076f4">Don't put a space before <code class="code ">:</code> when it separates a declaration and its type.</p>
<p id="d6b489bf">Always put a space after <code class="code ">:</code>.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">abstract class Foo&lt;out T : Any&gt; : IFoo { abstract fun foo(a: Int): T } class FooImpl : Foo() { constructor(x: String) : this(x) { /*...*/ } val x = object : IFoo { /*...*/ } } </pre></section><section class="chapter"><h3 id="class-headers" data-toc="coding-conventions#class-headers">Class headers</h3>
<p id="4ff5dfea">Classes with a few primary constructor parameters can be written in a single line:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class Person(id: Int, name: String) </pre>
<p id="80c303d2">Classes with longer headers should be formatted so that each primary constructor parameter is in a separate line with indentation. Also, the closing parenthesis should be on a new line. If you use inheritance, the superclass constructor call or the list of implemented interfaces should be located on the same line as the parenthesis:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class Person( id: Int, name: String, surname: String ) : Human(id, name) { /*...*/ } </pre>
<p id="4472f8f3">For multiple interfaces, the superclass constructor call should be located first and then each interface should be located in a different line:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class Person( id: Int, name: String, surname: String ) : Human(id, name), KotlinMaker { /*...*/ } </pre>
<p id="2e3b13f9">For classes with a long supertype list, put a line break after the colon and align all supertype names horizontally:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class MyFavouriteVeryLongClassHolder : MyLongHolder&lt;MyFavouriteVeryLongClass&gt;(), SomeOtherInterface, AndAnotherOne { fun foo() { /*...*/ } } </pre>
<p id="49cea9df">To clearly separate the class header and body when the class header is long, either put a blank line following the class header (as in the example above), or put the opening curly brace on a separate line:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class MyFavouriteVeryLongClassHolder : MyLongHolder&lt;MyFavouriteVeryLongClass&gt;(), SomeOtherInterface, AndAnotherOne { fun foo() { /*...*/ } } </pre>
<p id="e9f3e038">Use regular indent (four spaces) for constructor parameters. This ensures that properties declared in the primary constructor have the same indentation as properties declared in the body of a class.</p></section><section class="chapter"><h3 id="modifiers-order" data-toc="coding-conventions#modifiers-order">Modifiers order</h3>
<p id="ae1d9dc1">If a declaration has multiple modifiers, always put them in the following order:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">public / protected / private / internal expect / actual final / open / abstract / sealed / const external override lateinit tailrec vararg suspend inner enum / annotation / fun // as a modifier in `fun interface` companion inline / value infix operator data </pre>
<p id="9f8b8894">Place all annotations before modifiers:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">@Named("Foo") private val foo: Foo </pre>
<p id="4c87c9db">Unless you're working on a library, omit redundant modifiers (for example, <code class="code ">public</code>).</p></section><section class="chapter"><h3 id="annotations" data-toc="coding-conventions#annotations">Annotations</h3>
<p id="4d055051">Place annotations on separate lines before the declaration to which they are attached, and with the same indentation:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">@Target(AnnotationTarget.PROPERTY) annotation class JsonExclude </pre>
<p id="67bf11dc">Annotations without arguments may be placed on the same line:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">@JsonExclude @JvmField var x: String </pre>
<p id="48220c68">A single annotation without arguments may be placed on the same line as the corresponding declaration:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">@Test fun foo() { /*...*/ } </pre></section><section class="chapter"><h3 id="file-annotations" data-toc="coding-conventions#file-annotations">File annotations</h3>
<p id="c11c4e43">File annotations are placed after the file comment (if any), before the <code class="code ">package</code> statement, and are separated from <code class="code ">package</code> with a blank line (to emphasize the fact that they target the file and not the package).</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">/** License, copyright and whatever */ @file:JvmName("FooBar") package foo.bar </pre></section><section class="chapter"><h3 id="functions" data-toc="coding-conventions#functions">Functions</h3>
<p id="77090116">If the function signature doesn't fit on a single line, use the following syntax:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun longMethodName( argument: ArgumentType = defaultValue, argument2: AnotherArgumentType, ): ReturnType { // body } </pre>
<p id="c6c61efe">Use regular indent (four spaces) for function parameters. It helps ensure consistency with constructor parameters.</p>
<p id="3edbe508">Prefer using an expression body for functions with the body consisting of a single expression.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun foo(): Int { // bad return 1 } fun foo() = 1 // good </pre></section><section class="chapter"><h3 id="expression-bodies" data-toc="coding-conventions#expression-bodies">Expression bodies</h3>
<p id="4e0308cd">If the function has an expression body whose first line doesn't fit on the same line as the declaration, put the <code class="code ">=</code> sign on the first line and indent the expression body by four spaces.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun f(x: String, y: String, z: String) = veryLongFunctionCallWithManyWords(andLongParametersToo(), x, y, z) </pre></section><section class="chapter"><h3 id="properties" data-toc="coding-conventions#properties">Properties</h3>
<p id="bfafef03">For very simple read-only properties, consider one-line formatting:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val isEmpty: Boolean get() = size == 0 </pre>
<p id="1a4190f6">For more complex properties, always put <code class="code ">get</code> and <code class="code ">set</code> keywords on separate lines:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val foo: String get() { /*...*/ } </pre>
<p id="deccc457">For properties with an initializer, if the initializer is long, add a line break after the <code class="code ">=</code> sign and indent the initializer by four spaces:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">private val defaultCharset: Charset? = EncodingRegistry.getInstance().getDefaultCharsetForPropertiesFiles(file) </pre></section><section class="chapter"><h3 id="control-flow-statements" data-toc="coding-conventions#control-flow-statements">Control flow statements</h3>
<p id="d751ba94">If the condition of an <code class="code ">if</code> or <code class="code ">when</code> statement is multiline, always use curly braces around the body of the statement. Indent each subsequent line of the condition by four spaces relative to statement begin. Put the closing parentheses of the condition together with the opening curly brace on a separate line:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">if (!component.isSyncing &amp;&amp; !hasAnyKotlinRuntimeInScope(module) ) { return createKotlinNotConfiguredPanel(module) } </pre>
<p id="38d81517">This helps align the condition and statement bodies.</p>
<p id="e7dafbcc">Put the <code class="code ">else</code>, <code class="code ">catch</code>, <code class="code ">finally</code> keywords, as well as the <code class="code ">while</code> keyword of a <code class="code ">do-while</code> loop, on the same line as the preceding curly brace:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">if (condition) { // body } else { // else part } try { // body } finally { // cleanup } </pre>
<p id="79e2a4ff">In a <code class="code ">when</code> statement, if a branch is more than a single line, consider separating it from adjacent case blocks with a blank line:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">private fun parsePropertyValue(propName: String, token: Token) { when (token) { is Token.ValueToken -&gt; callback.visitValue(propName, token.value) Token.LBRACE -&gt; { // ... } } } </pre>
<p id="366e0c07">Put short branches on the same line as the condition, without braces.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">when (foo) { true -&gt; bar() // good false -&gt; { baz() } // bad } </pre></section><section class="chapter"><h3 id="method-calls" data-toc="coding-conventions#method-calls">Method calls</h3>
<p id="659ea265">In long argument lists, put a line break after the opening parenthesis. Indent arguments by four spaces. Group multiple closely related arguments on the same line.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">drawSquare( x = 10, y = 10, width = 100, height = 100, fill = true ) </pre>
<p id="9ab3c2c9">Put spaces around the <code class="code ">=</code> sign separating the argument name and value.</p></section><section class="chapter"><h3 id="wrap-chained-calls" data-toc="coding-conventions#wrap-chained-calls">Wrap chained calls</h3>
<p id="7a978315">When wrapping chained calls, put the <code class="code ">.</code> character or the <code class="code ">?.</code> operator on the next line, with a single indent:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val anchor = owner ?.firstChild!! .siblings(forward = true) .dropWhile { it is PsiComment || it is PsiWhiteSpace } </pre>
<p id="67f1c5a5">The first call in the chain usually should have a line break before it, but it's OK to omit it if the code makes more sense that way.</p></section><section class="chapter"><h3 id="lambdas" data-toc="coding-conventions#lambdas">Lambdas</h3>
<p id="4842f26a">In lambda expressions, spaces should be used around the curly braces, as well as around the arrow which separates the parameters from the body. If a call takes a single lambda, pass it outside of parentheses whenever possible.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">list.filter { it &gt; 10 } </pre>
<p id="6974e811">If assigning a label for a lambda, do not put a space between the label and the opening curly brace:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun foo() { ints.forEach lit@{ // ... } } </pre>
<p id="5f72ae55">When declaring parameter names in a multiline lambda, put the names on the first line, followed by the arrow and the newline:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">appendCommaSeparated(properties) { prop -&gt; val propertyValue = prop.get(obj) // ... } </pre>
<p id="843890b2">If the parameter list is too long to fit on a line, put the arrow on a separate line:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">foo { context: Context, environment: Env -&gt; context.configureEnv(environment) } </pre></section><section class="chapter"><h3 id="trailing-commas" data-toc="coding-conventions#trailing-commas">Trailing commas</h3>
<p id="2501c90d">A trailing comma is a comma symbol after the last item of a series of elements:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class Person( val firstName: String, val lastName: String, val age: Int, // trailing comma ) </pre>
<p id="cafef86e">Using trailing commas has several benefits:</p>
<ul class="list _ul" id="db809cef">
<li class="list__item" id="44a0e0f6"><p>It makes version-control diffs cleaner – as all the focus is on the changed value.</p></li>
<li class="list__item" id="de291ae9"><p>It makes it easy to add and reorder elements – there is no need to add or delete the comma if you manipulate elements.</p></li>
<li class="list__item" id="a29e6d86"><p>It simplifies code generation, for example, for object initializers. The last element can also have a comma.</p></li>
</ul>
<p id="29dc7510">Trailing commas are entirely optional – your code will still work without them. The Kotlin style guide encourages the use of trailing commas at the declaration site and leaves it at your discretion for the call site.</p>
<p id="71362db2">To enable trailing commas in the IntelliJ IDEA formatter, go to <b id="74a0c408" class="">Settings/Preferences | Editor | Code Style | Kotlin</b>, open the <b id="8abdb0eb" class="">Other</b> tab and select the <b id="c9c2acc9" class="">Use trailing comma</b> option.</p>
<section class="chapter"><div class="collapse">
<div class="collapse__title"><h4 id="enumerations" data-toc="coding-conventions#enumerations">Enumerations</h4></div>
<div class="collapse__content"><pre class="code-block" data-lang="kotlin" data-language="kotlin">enum class Direction { NORTH, SOUTH, WEST, EAST, // trailing comma } </pre></div>
</div></section><section class="chapter"><div class="collapse">
<div class="collapse__title"><h4 id="value-arguments" data-toc="coding-conventions#value-arguments">Value arguments</h4></div>
<div class="collapse__content"><pre class="code-block" data-lang="kotlin" data-language="kotlin">fun shift(x: Int, y: Int) { /*...*/ } shift( 25, 20, // trailing comma ) val colors = listOf( "red", "green", "blue", // trailing comma ) </pre></div>
</div></section><section class="chapter"><div class="collapse">
<div class="collapse__title"><h4 id="class-properties-and-parameters" data-toc="coding-conventions#class-properties-and-parameters">Class properties and parameters</h4></div>
<div class="collapse__content"><pre class="code-block" data-lang="kotlin" data-language="kotlin">class Customer( val name: String, val lastName: String, // trailing comma ) class Customer( val name: String, lastName: String, // trailing comma ) </pre></div>
</div></section><section class="chapter"><div class="collapse">
<div class="collapse__title"><h4 id="function-value-parameters" data-toc="coding-conventions#function-value-parameters">Function value parameters</h4></div>
<div class="collapse__content"><pre class="code-block" data-lang="kotlin" data-language="kotlin">fun powerOf( number: Int, exponent: Int, // trailing comma ) { /*...*/ } constructor( x: Comparable&lt;Number&gt;, y: Iterable&lt;Number&gt;, // trailing comma ) {} fun print( vararg quantity: Int, description: String, // trailing comma ) {} </pre></div>
</div></section><section class="chapter"><div class="collapse">
<div class="collapse__title"><h4 id="parameters-with-optional-type-including-setters" data-toc="coding-conventions#parameters-with-optional-type-including-setters">Parameters with optional type (including setters)</h4></div>
<div class="collapse__content"><pre class="code-block" data-lang="kotlin" data-language="kotlin">val sum: (Int, Int, Int) -&gt; Int = fun( x, y, z, // trailing comma ): Int { return x + y + x } println(sum(8, 8, 8)) </pre></div>
</div></section><section class="chapter"><div class="collapse">
<div class="collapse__title"><h4 id="indexing-suffix" data-toc="coding-conventions#indexing-suffix">Indexing suffix</h4></div>
<div class="collapse__content"><pre class="code-block" data-lang="kotlin" data-language="kotlin">class Surface { operator fun get(x: Int, y: Int) = 2 * x + 4 * y - 10 } fun getZValue(mySurface: Surface, xValue: Int, yValue: Int) = mySurface[ xValue, yValue, // trailing comma ] </pre></div>
</div></section><section class="chapter"><div class="collapse">
<div class="collapse__title"><h4 id="parameters-in-lambdas" data-toc="coding-conventions#parameters-in-lambdas">Parameters in lambdas</h4></div>
<div class="collapse__content"><pre class="code-block" data-lang="kotlin" data-language="kotlin">fun main() { val x = { x: Comparable&lt;Number&gt;, y: Iterable&lt;Number&gt;, // trailing comma -&gt; println("1") } println(x) } </pre></div>
</div></section><section class="chapter"><div class="collapse">
<div class="collapse__title"><h4 id="when-entry" data-toc="coding-conventions#when-entry">when entry</h4></div>
<div class="collapse__content"><pre class="code-block" data-lang="kotlin" data-language="kotlin">fun isReferenceApplicable(myReference: KClass&lt;*&gt;) = when (myReference) { Comparable::class, Iterable::class, String::class, // trailing comma -&gt; true else -&gt; false } </pre></div>
</div></section><section class="chapter"><div class="collapse">
<div class="collapse__title"><h4 id="collection-literals-in-annotations" data-toc="coding-conventions#collection-literals-in-annotations">Collection literals (in annotations)</h4></div>
<div class="collapse__content"><pre class="code-block" data-lang="kotlin" data-language="kotlin">annotation class ApplicableFor(val services: Array&lt;String&gt;) @ApplicableFor([ "serializer", "balancer", "database", "inMemoryCache", // trailing comma ]) fun run() {} </pre></div>
</div></section><section class="chapter"><div class="collapse">
<div class="collapse__title"><h4 id="type-arguments" data-toc="coding-conventions#type-arguments">Type arguments</h4></div>
<div class="collapse__content"><pre class="code-block" data-lang="kotlin" data-language="kotlin">fun &lt;T1, T2&gt; foo() {} fun main() { foo&lt; Comparable&lt;Number&gt;, Iterable&lt;Number&gt;, // trailing comma &gt;() } </pre></div>
</div></section><section class="chapter"><div class="collapse">
<div class="collapse__title"><h4 id="type-parameters" data-toc="coding-conventions#type-parameters">Type parameters</h4></div>
<div class="collapse__content"><pre class="code-block" data-lang="kotlin" data-language="kotlin">class MyMap&lt; MyKey, MyValue, // trailing comma &gt; {} </pre></div>
</div></section><section class="chapter"><div class="collapse">
<div class="collapse__title"><h4 id="destructuring-declarations" data-toc="coding-conventions#destructuring-declarations">Destructuring declarations</h4></div>
<div class="collapse__content"><pre class="code-block" data-lang="kotlin" data-language="kotlin">data class Car(val manufacturer: String, val model: String, val year: Int) val myCar = Car("Tesla", "Y", 2019) val ( manufacturer, model, year, // trailing comma ) = myCar val cars = listOf&lt;Car&gt;() fun printMeanValue() { var meanValue: Int = 0 for (( _, _, year, // trailing comma ) in cars) { meanValue += year } println(meanValue/cars.size) } printMeanValue() </pre></div>
</div></section></section></section><section class="chapter"><h2 id="documentation-comments" data-toc="coding-conventions#documentation-comments">Documentation comments</h2>
<p id="f2bdc0a8">For longer documentation comments, place the opening <code class="code ">/**</code> on a separate line and begin each subsequent line with an asterisk:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">/** * This is a documentation comment * on multiple lines. */ </pre>
<p id="3e68d980">Short comments can be placed on a single line:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">/** This is a short documentation comment. */ </pre>
<p id="e374be04">Generally, avoid using <code class="code ">@param</code> and <code class="code ">@return</code> tags. Instead, incorporate the description of parameters and return values directly into the documentation comment, and add links to parameters wherever they are mentioned. Use <code class="code ">@param</code> and <code class="code ">@return</code> only when a lengthy description is required which doesn't fit into the flow of the main text.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">// Avoid doing this: /** * Returns the absolute value of the given number. * @param number The number to return the absolute value for. * @return The absolute value. */ fun abs(number: Int): Int { /*...*/ } // Do this instead: /** * Returns the absolute value of the given [number]. */ fun abs(number: Int): Int { /*...*/ } </pre></section><section class="chapter"><h2 id="avoid-redundant-constructs" data-toc="coding-conventions#avoid-redundant-constructs">Avoid redundant constructs</h2>
<p id="fd6452a4">In general, if a certain syntactic construction in Kotlin is optional and highlighted by the IDE as redundant, you should omit it in your code. Do not leave unnecessary syntactic elements in code just "for clarity".</p>
<section class="chapter"><h3 id="unit-return-type" data-toc="coding-conventions#unit-return-type">Unit return type</h3>
<p id="54551318">If a function returns Unit, the return type should be omitted:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun foo() { // ": Unit" is omitted here } </pre></section><section class="chapter"><h3 id="semicolons" data-toc="coding-conventions#semicolons">Semicolons</h3>
<p id="f6a9e49a">Omit semicolons whenever possible.</p></section><section class="chapter"><h3 id="string-templates" data-toc="coding-conventions#string-templates">String templates</h3>
<p id="4a8f0f17">Don't use curly braces when inserting a simple variable into a string template. Use curly braces only for longer expressions.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">println("$name has ${children.size} children") </pre></section></section><section class="chapter"><h2 id="idiomatic-use-of-language-features" data-toc="coding-conventions#idiomatic-use-of-language-features">Idiomatic use of language features</h2>
<section class="chapter"><h3 id="immutability" data-toc="coding-conventions#immutability">Immutability</h3>
<p id="48195d16">Prefer using immutable data to mutable. Always declare local variables and properties as <code class="code ">val</code> rather than <code class="code ">var</code> if they are not modified after initialization.</p>
<p id="f8c92fe3">Always use immutable collection interfaces (<code class="code ">Collection</code>, <code class="code ">List</code>, <code class="code ">Set</code>, <code class="code ">Map</code>) to declare collections which are not mutated. When using factory functions to create collection instances, always use functions that return immutable collection types when possible:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">// Bad: use of mutable collection type for value which will not be mutated fun validateValue(actualValue: String, allowedValues: HashSet&lt;String&gt;) { ... } // Good: immutable collection type used instead fun validateValue(actualValue: String, allowedValues: Set&lt;String&gt;) { ... } // Bad: arrayListOf() returns ArrayList&lt;T&gt;, which is a mutable collection type val allowedValues = arrayListOf("a", "b", "c") // Good: listOf() returns List&lt;T&gt; val allowedValues = listOf("a", "b", "c") </pre></section><section class="chapter"><h3 id="default-parameter-values" data-toc="coding-conventions#default-parameter-values">Default parameter values</h3>
<p id="7958e963">Prefer declaring functions with default parameter values to declaring overloaded functions.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">// Bad fun foo() = foo("a") fun foo(a: String) { /*...*/ } // Good fun foo(a: String = "a") { /*...*/ } </pre></section><section class="chapter"><h3 id="type-aliases" data-toc="coding-conventions#type-aliases">Type aliases</h3>
<p id="3b975ff7">If you have a functional type or a type with type parameters which is used multiple times in a codebase, prefer defining a type alias for it:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">typealias MouseClickHandler = (Any, MouseEvent) -&gt; Unit typealias PersonIndex = Map&lt;String, Person&gt; </pre>
<p id="8ac6a84a">If you use a private or internal type alias for avoiding name collision, prefer the <code class="code ">import … as …</code> mentioned in <a href="packages" id="1ed518e7">Packages and Imports</a>.</p></section><section class="chapter"><h3 id="lambda-parameters" data-toc="coding-conventions#lambda-parameters">Lambda parameters</h3>
<p id="88628f7">In lambdas which are short and not nested, it's recommended to use the <code class="code ">it</code> convention instead of declaring the parameter explicitly. In nested lambdas with parameters, always declare parameters explicitly.</p></section><section class="chapter"><h3 id="returns-in-a-lambda" data-toc="coding-conventions#returns-in-a-lambda">Returns in a lambda</h3>
<p id="83c02d50">Avoid using multiple labeled returns in a lambda. Consider restructuring the lambda so that it will have a single exit point. If that's not possible or not clear enough, consider converting the lambda into an anonymous function.</p>
<p id="66f3b0da">Do not use a labeled return for the last statement in a lambda.</p></section><section class="chapter"><h3 id="named-arguments" data-toc="coding-conventions#named-arguments">Named arguments</h3>
<p id="e1241666">Use the named argument syntax when a method takes multiple parameters of the same primitive type, or for parameters of <code class="code ">Boolean</code> type, unless the meaning of all parameters is absolutely clear from context.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">drawSquare(x = 10, y = 10, width = 100, height = 100, fill = true) </pre></section><section class="chapter"><h3 id="conditional-statements" data-toc="coding-conventions#conditional-statements">Conditional statements</h3>
<p id="a381b859">Prefer using the expression form of <code class="code ">try</code>, <code class="code ">if</code>, and <code class="code ">when</code>.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">return if (x) foo() else bar() </pre>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">return when(x) { 0 -&gt; "zero" else -&gt; "nonzero" } </pre>
<p id="c64be1d3">The above is preferable to:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">if (x) return foo() else return bar() </pre>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">when(x) { 0 -&gt; return "zero" else -&gt; return "nonzero" } </pre></section><section class="chapter"><h3 id="if-versus-when" data-toc="coding-conventions#if-versus-when">if versus when</h3>
<p id="99b2558">Prefer using <code class="code ">if</code> for binary conditions instead of <code class="code ">when</code>. For example, use this syntax with <code class="code ">if</code>:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">if (x == null) ... else ... </pre>
<p id="7a5d43ef">instead of this one with <code class="code ">when</code>:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">when (x) { null -&gt; // ... else -&gt; // ... } </pre>
<p id="a8dc8697">Prefer using <code class="code ">when</code> if there are three or more options.</p></section><section class="chapter"><h3 id="nullable-boolean-values-in-conditions" data-toc="coding-conventions#nullable-boolean-values-in-conditions">Nullable Boolean values in conditions</h3>
<p id="f8376075">If you need to use a nullable <code class="code ">Boolean</code> in a conditional statement, use <code class="code ">if (value == true)</code> or <code class="code ">if (value == false)</code> checks.</p></section><section class="chapter"><h3 id="loops" data-toc="coding-conventions#loops">Loops</h3>
<p id="e1e876c2">Prefer using higher-order functions (<code class="code ">filter</code>, <code class="code ">map</code> etc.) to loops. Exception: <code class="code ">forEach</code> (prefer using a regular <code class="code ">for</code> loop instead, unless the receiver of <code class="code ">forEach</code> is nullable or <code class="code ">forEach</code> is used as part of a longer call chain).</p>
<p id="7805fb2d">When making a choice between a complex expression using multiple higher-order functions and a loop, understand the cost of the operations being performed in each case and keep performance considerations in mind.</p></section><section class="chapter"><h3 id="loops-on-ranges" data-toc="coding-conventions#loops-on-ranges">Loops on ranges</h3>
<p id="919a0fb5">Use the <code class="code ">until</code> function to loop over an open range:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">for (i in 0..n - 1) { /*...*/ } // bad for (i in 0 until n) { /*...*/ } // good </pre></section><section class="chapter"><h3 id="strings" data-toc="coding-conventions#strings">Strings</h3>
<p id="77198ce4">Prefer string templates to string concatenation.</p>
<p id="8d91d085">Prefer multiline strings to embedding <code class="code ">\n</code> escape sequences into regular string literals.</p>
<p id="5ef41a13">To maintain indentation in multiline strings, use <code class="code ">trimIndent</code> when the resulting string does not require any internal indentation, or <code class="code ">trimMargin</code> when internal indentation is required:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-language="kotlin">fun main() { //sampleStart println(""" Not trimmed text """ ) println(""" Trimmed text """.trimIndent() ) println() val a = """Trimmed to margin text: |if(a &gt; 1) { | return a |}""".trimMargin() println(a) //sampleEnd } </pre>
<p id="7d3ef77d">Learn the difference between <a href="java-to-kotlin-idioms-strings#use-multiline-strings" id="9d1654dd">Java and Kotlin multiline strings</a>.</p></section><section class="chapter"><h3 id="functions-vs-properties" data-toc="coding-conventions#functions-vs-properties">Functions vs properties</h3>
<p id="4129a48">In some cases functions with no arguments might be interchangeable with read-only properties. Although the semantics are similar, there are some stylistic conventions on when to prefer one to another.</p>
<p id="46b00b47">Prefer a property over a function when the underlying algorithm:</p>
<ul class="list _ul" id="e011ced7">
<li class="list__item" id="f0bd0e18"><p>does not throw</p></li>
<li class="list__item" id="444607af"><p>is cheap to calculate (or cached on the first run)</p></li>
<li class="list__item" id="38e84961"><p>returns the same result over invocations if the object state hasn't changed</p></li>
</ul></section><section class="chapter"><h3 id="extension-functions" data-toc="coding-conventions#extension-functions">Extension functions</h3>
<p id="76c15ae7">Use extension functions liberally. Every time you have a function that works primarily on an object, consider making it an extension function accepting that object as a receiver. To minimize API pollution, restrict the visibility of extension functions as much as it makes sense. As necessary, use local extension functions, member extension functions, or top-level extension functions with private visibility.</p></section><section class="chapter"><h3 id="infix-functions" data-toc="coding-conventions#infix-functions">Infix functions</h3>
<p id="c5e36e08">Declare a function as <code class="code ">infix</code> only when it works on two objects which play a similar role. Good examples: <code class="code ">and</code>, <code class="code ">to</code>, <code class="code ">zip</code>. Bad example: <code class="code ">add</code>.</p>
<p id="3ae429b6">Do not declare a method as <code class="code ">infix</code> if it mutates the receiver object.</p></section><section class="chapter"><h3 id="factory-functions" data-toc="coding-conventions#factory-functions">Factory functions</h3>
<p id="1700646c">If you declare a factory function for a class, avoid giving it the same name as the class itself. Prefer using a distinct name making it clear why the behavior of the factory function is special. Only if there is really no special semantics, you can use the same name as the class.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class Point(val x: Double, val y: Double) { companion object { fun fromPolar(angle: Double, radius: Double) = Point(...) } } </pre>
<p id="e960268e">If you have an object with multiple overloaded constructors that don't call different superclass constructors and can't be reduced to a single constructor with default argument values, prefer to replace the overloaded constructors with factory functions.</p></section><section class="chapter"><h3 id="platform-types" data-toc="coding-conventions#platform-types">Platform types</h3>
<p id="3ab12c59">A public function/method returning an expression of a platform type must declare its Kotlin type explicitly:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun apiCall(): String = MyJavaApi.getProperty("name") </pre>
<p id="ab7bac6f">Any property (package-level or class-level) initialized with an expression of a platform type must declare its Kotlin type explicitly:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class Person { val name: String = MyJavaApi.getProperty("name") } </pre>
<p id="f67c9335">A local value initialized with an expression of a platform type may or may not have a type declaration:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun main() { val name = MyJavaApi.getProperty("name") println(name) } </pre></section><section class="chapter"><h3 id="scope-functions-apply-with-run-also-let" data-toc="coding-conventions#scope-functions-apply-with-run-also-let">Scope functions apply/with/run/also/let</h3>
<p id="8b51ff1d">Kotlin provides a set of functions to execute a block of code in the context of a given object: <code class="code ">let</code>, <code class="code ">run</code>, <code class="code ">with</code>, <code class="code ">apply</code>, and <code class="code ">also</code>. For the guidance on choosing the right scope function for your case, refer to <a href="scope-functions" id="43b83dcb">Scope Functions</a>.</p></section></section><section class="chapter"><h2 id="coding-conventions-for-libraries" data-toc="coding-conventions#coding-conventions-for-libraries">Coding conventions for libraries</h2>
<p id="d5a1ac0c">When writing libraries, it's recommended to follow an additional set of rules to ensure API stability:</p>
<ul class="list _ul" id="3c445691">
<li class="list__item" id="a1162333"><p>Always explicitly specify member visibility (to avoid accidentally exposing declarations as public API)</p></li>
<li class="list__item" id="104adc5"><p>Always explicitly specify function return types and property types (to avoid accidentally changing the return type when the implementation changes)</p></li>
<li class="list__item" id="e816c781"><p>Provide <a href="kotlin-doc" id="efe5b7b3">KDoc</a> comments for all public members, with the exception of overrides that do not require any new documentation (to support generating documentation for the library)</p></li>
</ul></section><div class="last-modified"> Last modified: 14 January 2022</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="idioms">Idioms</a> <a class="navigation-links__next" href="basic-types">Basic types</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/coding-conventions.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/coding-conventions.html</a>
  </p>
</div>
