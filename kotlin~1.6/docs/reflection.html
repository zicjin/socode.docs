<h1 data-toc="reflection" id="reflection.md">Reflection</h1>
<p id="80af72e7"><em id="9a5fc87e" class="">Reflection</em> is a set of language and library features that allows you to introspect the structure of your program at runtime. Functions and properties are first-class citizens in Kotlin, and the ability to introspect them (for example, learning the name or the type of a property or function at runtime) is essential when using a functional or reactive style.</p>
<aside data-type="note" class="prompt" data-title="" id="3aa47481"><p id="95d18d06">Kotlin/JS provides limited support for reflection features. <a href="js-reflection" id="6b7b43ed">Learn more about reflection in Kotlin/JS</a>.</p></aside><section class="chapter"><h2 id="jvm-dependency" data-toc="reflection#jvm-dependency">JVM dependency</h2>
<p id="e3b874d0">On the JVM platform, the Kotlin compiler distribution includes the runtime component required for using the reflection features as a separate artifact, <code class="code ">kotlin-reflect.jar</code>. This is done to reduce the required size of the runtime library for applications that do not use reflection features.</p>
<p id="b07f10d0">To use reflection in a Gradle or Maven project, add the dependency on <code class="code ">kotlin-reflect</code>:</p>
<ul class="list _ul" id="fc57f05d">
<li class="list__item" id="2fc948eb">
<p id="17c54b73">In Gradle:</p>
<div class="tabs" id="5b1b3b4c" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="43d13ce6" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code-block" data-lang="kotlin" data-title="Kotlin" data-language="kotlin">dependencies { implementation("org.jetbrains.kotlin:kotlin-reflect:1.6.10") } </pre></div>
<div class="tabs__content" data-gtm="tab" id="72f6383" data-sync-tabs="groovy" data-title="Groovy"><pre class="code-block" data-lang="groovy" data-title="Groovy" data-language="groovy">dependencies { implementation "org.jetbrains.kotlin:kotlin-reflect:1.6.10" } </pre></div>
</div>
</li>
<li class="list__item" id="956a89b6">
<p id="844eca5a">In Maven:</p>
<pre class="code-block" data-lang="markup" data-language="markup">&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt; &lt;artifactId&gt;kotlin-reflect&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; </pre>
</li>
</ul>
<p id="752ce96a">If you don't use Gradle or Maven, make sure you have <code class="code ">kotlin-reflect.jar</code> in the classpath of your project. In other supported cases (IntelliJ IDEA projects that use the command-line compiler or Ant), it is added by default. In the command-line compiler and Ant, you can use the <code class="code ">-no-reflect</code> compiler option to exclude <code class="code ">kotlin-reflect.jar</code> from the classpath.</p></section><section class="chapter"><h2 id="class-references" data-toc="reflection#class-references">Class references</h2>
<p id="e4f3fc18">The most basic reflection feature is getting the runtime reference to a Kotlin class. To obtain the reference to a statically known Kotlin class, you can use the <em id="64aeb07b" class="">class literal</em> syntax:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val c = MyClass::class </pre>
<p id="3d1bc59e">The reference is a <a href="../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index" id="12457baf" data-external="true" rel="noopener noreferrer">KClass</a> type value.</p>
<aside data-type="note" class="prompt" data-title="" id="7772b088"><p id="9430ba0a">On JVM: a Kotlin class reference is not the same as a Java class reference. To obtain a Java class reference, use the <code class="code ">.java</code> property on a <code class="code ">KClass</code> instance.</p></aside><section class="chapter"><h3 id="bound-class-references" data-toc="reflection#bound-class-references">Bound class references</h3>
<p id="aefc5bd">You can get the reference to the class of a specific object with the same <code class="code ">::class</code> syntax by using the object as a receiver:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val widget: Widget = ... assert(widget is GoodWidget) { "Bad widget: ${widget::class.qualifiedName}" } </pre>
<p id="422ee88b">You will obtain the reference to the exact class of an object, for example, <code class="code ">GoodWidget</code> or <code class="code ">BadWidget</code>, regardless of the type of the receiver expression (<code class="code ">Widget</code>).</p></section></section><section class="chapter"><h2 id="callable-references" data-toc="reflection#callable-references">Callable references</h2>
<p id="e400d86b">References to functions, properties, and constructors can also be called or used as instances of <a href="lambdas#function-types" id="e3701acb">function types</a>.</p>
<p id="df3c4795">The common supertype for all callable references is <a href="../api/latest/jvm/stdlib/kotlin.reflect/-k-callable/index" id="dee5e456" data-external="true" rel="noopener noreferrer"><code class="code ">KCallable&lt;out R&gt;</code></a>, where <code class="code ">R</code> is the return value type. It is the property type for properties, and the constructed type for constructors.</p>
<section class="chapter"><h3 id="function-references" data-toc="reflection#function-references">Function references</h3>
<p id="6f7e9eeb">When you have a named function declared as below, you can call it directly (<code class="code ">isOdd(5)</code>):</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun isOdd(x: Int) = x % 2 != 0 </pre>
<p id="69ca9ede">Alternatively, you can use the function as a function type value, that is, pass it to another function. To do so, use the <code class="code ">::</code> operator:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun isOdd(x: Int) = x % 2 != 0 fun main() { //sampleStart val numbers = listOf(1, 2, 3) println(numbers.filter(::isOdd)) //sampleEnd } </pre>
<p id="9cac336f">Here <code class="code ">::isOdd</code> is a value of function type <code class="code ">(Int) -&gt; Boolean</code>.</p>
<p id="5bc34f87">Function references belong to one of the <a href="../api/latest/jvm/stdlib/kotlin.reflect/-k-function/index" id="ea757fc0" data-external="true" rel="noopener noreferrer"><code class="code ">KFunction&lt;out R&gt;</code></a> subtypes, depending on the parameter count. For instance, <code class="code ">KFunction3&lt;T1, T2, T3, R&gt;</code>.</p>
<p id="77d62ddb"><code class="code ">::</code> can be used with overloaded functions when the expected type is known from the context. For example:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart fun isOdd(x: Int) = x % 2 != 0 fun isOdd(s: String) = s == "brillig" || s == "slithy" || s == "tove" val numbers = listOf(1, 2, 3) println(numbers.filter(::isOdd)) // refers to isOdd(x: Int) //sampleEnd } </pre>
<p id="7a21a15">Alternatively, you can provide the necessary context by storing the method reference in a variable with an explicitly specified type:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val predicate: (String) -&gt; Boolean = ::isOdd // refers to isOdd(x: String) </pre>
<p id="ae0e7822">If you need to use a member of a class or an extension function, it needs to be qualified: <code class="code ">String::toCharArray</code>.</p>
<p id="1b6ca335">Even if you initialize a variable with a reference to an extension function, the inferred function type will have no receiver, but it will have an additional parameter accepting a receiver object. To have a function type with a receiver instead, specify the type explicitly:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val isEmptyStringList: List&lt;String&gt;.() -&gt; Boolean = List&lt;String&gt;::isEmpty </pre>
<section class="chapter"><h4 id="example-function-composition" data-toc="reflection#example-function-composition">Example: function composition</h4>
<p id="e44acbf8">Consider the following function:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun &lt;A, B, C&gt; compose(f: (B) -&gt; C, g: (A) -&gt; B): (A) -&gt; C { return { x -&gt; f(g(x)) } } </pre>
<p id="8cc79165">It returns a composition of two functions passed to it: <code class="code ">compose(f, g) = f(g(*))</code>. You can apply this function to callable references:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun &lt;A, B, C&gt; compose(f: (B) -&gt; C, g: (A) -&gt; B): (A) -&gt; C { return { x -&gt; f(g(x)) } } fun isOdd(x: Int) = x % 2 != 0 fun main() { //sampleStart fun length(s: String) = s.length val oddLength = compose(::isOdd, ::length) val strings = listOf("a", "ab", "abc") println(strings.filter(oddLength)) //sampleEnd } </pre></section></section><section class="chapter"><h3 id="property-references" data-toc="reflection#property-references">Property references</h3>
<p id="cf28b852">To access properties as first-class objects in Kotlin, use the <code class="code ">::</code> operator:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val x = 1 fun main() { println(::x.get()) println(::x.name) } </pre>
<p id="713c2cda">The expression <code class="code ">::x</code> evaluates to a <code class="code ">KProperty&lt;Int&gt;</code> type property object. You can read its value using <code class="code ">get()</code> or retrieve the property name using the <code class="code ">name</code> property. For more information, see the <a href="../api/latest/jvm/stdlib/kotlin.reflect/-k-property/index" id="90b1b91a" data-external="true" rel="noopener noreferrer">docs on the <code class="code ">KProperty</code> class</a>.</p>
<p id="ff31cd32">For a mutable property such as <code class="code ">var y = 1</code>, <code class="code ">::y</code> returns a value with the <a href="../api/latest/jvm/stdlib/kotlin.reflect/-k-mutable-property/index" id="637e3f69" data-external="true" rel="noopener noreferrer"><code class="code ">KMutableProperty&lt;Int&gt;</code></a> type which has a <code class="code ">set()</code> method:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">var y = 1 fun main() { ::y.set(2) println(y) } </pre>
<p id="ebffbf16">A property reference can be used where a function with a single generic parameter is expected:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val strs = listOf("a", "bc", "def") println(strs.map(String::length)) //sampleEnd } </pre>
<p id="cb7b955a">To access a property that is a member of a class, qualify it as follows:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart class A(val p: Int) val prop = A::p println(prop.get(A(1))) //sampleEnd } </pre>
<p id="2e887b3c">For an extension property:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">val String.lastChar: Char get() = this[length - 1] fun main() { println(String::lastChar.get("abc")) } </pre></section><section class="chapter"><h3 id="interoperability-with-java-reflection" data-toc="reflection#interoperability-with-java-reflection">Interoperability with Java reflection</h3>
<p id="686541b6">On the JVM platform, the standard library contains extensions for reflection classes that provide a mapping to and from Java reflection objects (see package <code class="code ">kotlin.reflect.jvm</code>). For example, to find a backing field or a Java method that serves as a getter for a Kotlin property, you can write something like this:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">import kotlin.reflect.jvm.* class A(val p: Int) fun main() { println(A::p.javaGetter) // prints "public final int A.getP()" println(A::p.javaField) // prints "private final int A.p" } </pre>
<p id="d8e22d95">To get the Kotlin class that corresponds to a Java class, use the <code class="code ">.kotlin</code> extension property:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun getKClass(o: Any): KClass&lt;Any&gt; = o.javaClass.kotlin </pre></section><section class="chapter"><h3 id="constructor-references" data-toc="reflection#constructor-references">Constructor references</h3>
<p id="a5c6105f">Constructors can be referenced just like methods and properties. You can use them wherever the program expects a function type object that takes the same parameters as the constructor and returns an object of the appropriate type. Constructors are referenced by using the <code class="code ">::</code> operator and adding the class name. Consider the following function that expects a function parameter with no parameters and return type <code class="code ">Foo</code>:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class Foo fun function(factory: () -&gt; Foo) { val x: Foo = factory() } </pre>
<p id="f93fb1ff">Using <code class="code ">::Foo</code>, the zero-argument constructor of the class <code class="code ">Foo</code>, you can call it like this:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">function(::Foo) </pre>
<p id="c705c02b">Callable references to constructors are typed as one of the <a href="../api/latest/jvm/stdlib/kotlin.reflect/-k-function/index" id="49401d17" data-external="true" rel="noopener noreferrer"><code class="code ">KFunction&lt;out R&gt;</code></a> subtypes depending on the parameter count.</p></section><section class="chapter"><h3 id="bound-function-and-property-references" data-toc="reflection#bound-function-and-property-references">Bound function and property references</h3>
<p id="b0c87206">You can refer to an instance method of a particular object:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val numberRegex = "\\d+".toRegex() println(numberRegex.matches("29")) val isNumber = numberRegex::matches println(isNumber("29")) //sampleEnd } </pre>
<p id="27f939fa">Instead of calling the method <code class="code ">matches</code> directly, the example uses a reference to it. Such a reference is bound to its receiver. It can be called directly (like in the example above) or used whenever a function type expression is expected:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val numberRegex = "\\d+".toRegex() val strings = listOf("abc", "124", "a70") println(strings.filter(numberRegex::matches)) //sampleEnd } </pre>
<p id="c671fd">Compare the types of the bound and the unbound references. The bound callable reference has its receiver "attached" to it, so the type of the receiver is no longer a parameter:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val isNumber: (CharSequence) -&gt; Boolean = numberRegex::matches val matches: (Regex, CharSequence) -&gt; Boolean = Regex::matches </pre>
<p id="fee4076b">A property reference can be bound as well:</p>
<pre class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3" data-language="kotlin">fun main() { //sampleStart val prop = "abc"::length println(prop.get()) //sampleEnd } </pre>
<p id="dbb9efeb">You don't need to specify <code class="code ">this</code> as the receiver: <code class="code ">this::foo</code> and <code class="code ">::foo</code> are equivalent.</p></section><section class="chapter"><h3 id="bound-constructor-references" data-toc="reflection#bound-constructor-references">Bound constructor references</h3>
<p id="aa6c6fb8">A bound callable reference to a constructor of an <a href="nested-classes#inner-classes" id="9e124fc">inner class</a> can be obtained by providing an instance of the outer class:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class Outer { inner class Inner } val o = Outer() val boundInnerCtor = o::Inner </pre></section></section><div class="last-modified"> Last modified: 07 December 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="destructuring-declarations">Destructuring declarations</a> <a class="navigation-links__next" href="mpp-intro">Kotlin Multiplatform</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/reflection.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/reflection.html</a>
  </p>
</div>
