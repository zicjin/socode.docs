<h1 data-toc="native-dynamic-libraries" id="native-dynamic-libraries.md">Kotlin/Native as a dynamic library â€“ tutorial</h1>
<p id="ce02e687">Learn how you can use the Kotlin/Native code from existing native applications or libraries. For this, you need to compile the Kotlin code into a dynamic library, <code class="code ">.so</code>, <code class="code ">.dylib</code>, and <code class="code ">.dll</code>.</p>
<p id="c0abedb1">Kotlin/Native also has tight integration with Apple technologies. The <a href="apple-framework" id="8ba2adb6">Kotlin/Native as an Apple Framework</a> tutorial explains how to compile Kotlin code into a framework for Swift and Objective-C.</p>
<p id="ddcb6e55">In this tutorial, you will:</p>
<ul class="list _ul" id="82e028ce">
<li class="list__item" id="3ab23061"><p><a href="#create-a-kotlin-library" id="81e7c73c">Compile Kotlin code to a dynamic library</a></p></li>
<li class="list__item" id="e261ae15"><p><a href="#generated-headers-file" id="a778900d">Examine generated C headers</a></p></li>
<li class="list__item" id="7a2bfba3"><p><a href="#use-generated-headers-from-c" id="281e1867">Use the Kotlin dynamic library from C</a></p></li>
<li class="list__item" id="f7546c1d"><p>Compile and run the example on <a href="#compile-and-run-the-example-on-linux-and-macos" id="d0a94414">Linux and Mac</a> and <a href="#compile-and-run-the-example-on-windows" id="ca85fca1">Windows</a></p></li>
</ul>
<section class="chapter"><h2 id="create-a-kotlin-library" data-toc="native-dynamic-libraries#create-a-kotlin-library">Create a Kotlin library</h2>
<p id="8d9f417d">Kotlin/Native compiler can produce a dynamic library out of the Kotlin code. A dynamic library often comes with a header file, a <code class="code ">.h</code> file, which you will use to call the compiled code from C.</p>
<p id="8328d446">The best way to understand these techniques is to try them out. First, create a first tiny Kotlin library and use it from a C program.</p>
<p id="c24747e2">Start by creating a library file in Kotlin and save it as <code class="code ">hello.kt</code>:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">package example object Object { val field = "A" } class Clazz { fun memberFunction(p: Int): ULong = 42UL } fun forIntegers(b: Byte, s: Short, i: UInt, l: Long) { } fun forFloats(f: Float, d: Double) { } fun strings(str: String) : String? { return "That is '$str' from C" } val globalString = "A global String" </pre>
<p id="32f9a932">While it is possible to use the command line, either directly or by combining it with a script file (such as <code class="code ">.sh</code> or <code class="code ">.bat</code> file), this approach doesn't scale well for big projects that have hundreds of files and libraries. It is then better to use the Kotlin/Native compiler with a build system, as it helps to download and cache the Kotlin/Native compiler binaries and libraries with transitive dependencies and run the compiler and tests. Kotlin/Native can use the <a href="https://gradle.org" id="c3f6f5e2" data-external="true" rel="noopener noreferrer">Gradle</a> build system through the <a href="mpp-discover-project#multiplatform-plugin" id="683ca00f">kotlin-multiplatform</a> plugin.</p>
<p id="f5b2a03e">We covered the basics of setting up an IDE compatible project with Gradle in the <a href="native-gradle" id="489f92b6">A Basic Kotlin/Native Application</a> tutorial. Please check it out if you are looking for detailed first steps and instructions on how to start a new Kotlin/Native project and open it in IntelliJ IDEA. In this tutorial, we'll look at the advanced C interop related usages of Kotlin/Native and <a href="mpp-discover-project#multiplatform-plugin" id="d993eb12">multiplatform</a> builds with Gradle.</p>
<p id="f0c26e64">First, create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes the missing directories will have to be created before any new files can be added.</p>
<p id="ba2492fa">Use the following <code class="code ">build.gradle(.kts)</code> Gradle build file:</p>
<div class="tabs" id="baec4b18" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="f857ec12" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code-block" data-lang="kotlin" data-title="Kotlin" data-language="kotlin">plugins { kotlin("multiplatform") version "1.6.10" } repositories { mavenCentral() } kotlin { linuxX64("native") { // on Linux // macosX64("native") { // on x86_64 macOS // macosArm64("native") { // on Apple Silicon macOS // mingwX64("native") { // on Windows binaries { sharedLib { baseName = "native" // on Linux and macOS // baseName = "libnative" // on Windows } } } } tasks.wrapper { gradleVersion = "6.7.1" distributionType = Wrapper.DistributionType.ALL } </pre></div>
<div class="tabs__content" data-gtm="tab" id="3c633f83" data-sync-tabs="groovy" data-title="Groovy"><pre class="code-block" data-lang="groovy" data-title="Groovy" data-language="groovy">plugins { id 'org.jetbrains.kotlin.multiplatform' version '1.6.10' } repositories { mavenCentral() } kotlin { linuxX64("native") { // on Linux // macosX64("native") { // on x86_64 macOS // macosArm64("native") { // on Apple Silicon macOS // mingwX64("native") { // on Windows binaries { sharedLib { baseName = "native" // on Linux and macOS // baseName = "libnative" // on Windows } } } } wrapper { gradleVersion = "6.7.1" distributionType = "ALL" } </pre></div>
</div>
<p id="b948f3b0">Move the sources file into the <code class="code ">src/nativeMain/kotlin</code> folder under the project. This is the default path, for where sources are located, when the <a href="mpp-discover-project#multiplatform-plugin" id="7cd77f7a">kotlin-multiplatform</a> plugin is used. Use the following block to instruct and configure the project to generate a dynamic or shared library:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">binaries { sharedLib { baseName = "native" // on Linux and macOS // baseName = "libnative" // on Windows } } </pre>
<p id="69040e41">The <code class="code ">libnative</code> is used as the library name, the generated header file name prefix. It is also prefixes all declarations in the header file.</p>
<p id="e7b8a94">Now you can <a href="native-get-started" id="f3a462d2">open the project in IntelliJ IDEA</a> and to see how to fix the example project. While doing this, we'll examine how C functions are mapped into Kotlin/Native declarations.</p>
<p id="7847689f">Run the <code class="code ">linkNative</code> Gradle task to build the library in the IDE or by calling the following console command:</p>
<pre class="code-block" data-lang="bash" data-language="bash">./gradlew linkNative </pre>
<p id="b935a127">The build generates the following files under the <code class="code ">build/bin/native/debugShared</code> folder, depending on the host OS:</p>
<ul class="list _ul" id="4abdd17e">
<li class="list__item" id="8c71d706"><p>macOS: <code class="code ">libnative_api.h</code> and <code class="code ">libnative.dylib</code></p></li>
<li class="list__item" id="aa00d3f9"><p>Linux: <code class="code ">libnative_api.h</code> and <code class="code ">libnative.so</code></p></li>
<li class="list__item" id="b8be3147"><p>Windows: <code class="code ">libnative_api.h</code>, <code class="code ">libnative_symbols.def</code> and <code class="code ">libnative.dll</code></p></li>
</ul>
<p id="7f53fd34">The same rules are used by the Kotlin/Native compiler to generate the <code class="code ">.h</code> file for all platforms. <br> Let's check out the C API of our Kotlin library.`</p></section><section class="chapter"><h2 id="generated-headers-file" data-toc="native-dynamic-libraries#generated-headers-file">Generated headers file</h2>
<p id="78d58732">In the <code class="code ">libnative_api.h</code>, you'll find the following code. Let's discuss the code in parts to make it easier to understand.</p>
<aside data-type="note" class="prompt" data-title="" id="1b1ba2b4"><p id="9c87aa1e">The way Kotlin/Native exports symbols is subject to change without notice.</p></aside><p id="a9c35d03">The very first part contains the standard C/C++ header and footer:</p>
<pre class="code-block" data-lang="c" data-language="c">#ifndef KONAN_DEMO_H #define KONAN_DEMO_H #ifdef __cplusplus extern "C" { #endif /// THE REST OF THE GENERATED CODE GOES HERE #ifdef __cplusplus } /* extern "C" */ #endif #endif /* KONAN_DEMO_H */ </pre>
<p id="c554d640">After the rituals in the <code class="code ">libnative_api.h</code>, there is a block with the common type definitions:</p>
<pre class="code-block" data-lang="c" data-language="c">#ifdef __cplusplus typedef bool libnative_KBoolean; #else typedef _Bool libnative_KBoolean; #endif typedef unsigned short libnative_KChar; typedef signed char libnative_KByte; typedef short libnative_KShort; typedef int libnative_KInt; typedef long long libnative_KLong; typedef unsigned char libnative_KUByte; typedef unsigned short libnative_KUShort; typedef unsigned int libnative_KUInt; typedef unsigned long long libnative_KULong; typedef float libnative_KFloat; typedef double libnative_KDouble; typedef void* libnative_KNativePtr; </pre>
<p id="323374cb">Kotlin uses the <code class="code ">libnative_</code> prefix for all declarations in the created <code class="code ">libnative_api.h</code> file. Let's present the mapping of the types in a more readable way:</p>
<div class="table-wrapper"><table class=" wide" id="f921ae65">
<thead><tr class="ijRowHead" id="3182f0da">
<th id="81cf8c76"><p>Kotlin Define</p></th>
<th id="7961bd22"><p>C Type</p></th>
</tr></thead>
<tbody>
<tr class="" id="dad8852c">
<td id="2c626217"><p><code class="code ">libnative_KBoolean</code></p></td>
<td id="d5d5efa2"><p><code class="code ">bool</code> or <code class="code ">_Bool</code></p></td>
</tr>
<tr class="" id="700d908">
<td id="e18d12"><p><code class="code ">libnative_KChar</code></p></td>
<td id="7a18d95d"><p><code class="code ">unsigned short</code></p></td>
</tr>
<tr class="" id="cfd0dedc">
<td id="d4e96160"><p><code class="code ">libnative_KByte</code></p></td>
<td id="2dbdf6de"><p><code class="code ">signed char</code></p></td>
</tr>
<tr class="" id="225c4612">
<td id="b116fc90"><p><code class="code ">libnative_KShort</code></p></td>
<td id="b1ede84c"><p><code class="code ">short</code></p></td>
</tr>
<tr class="" id="78dc69fe">
<td id="d81ffa7"><p><code class="code ">libnative_KInt</code></p></td>
<td id="4029338"><p><code class="code ">int</code></p></td>
</tr>
<tr class="" id="bff944c1">
<td id="4b250251"><p><code class="code ">libnative_KLong</code></p></td>
<td id="dbbb82e4"><p><code class="code ">long long</code></p></td>
</tr>
<tr class="" id="ff0a97cb">
<td id="d7c5a6"><p><code class="code ">libnative_KUByte</code></p></td>
<td id="fa2e500f"><p><code class="code ">unsigned char</code></p></td>
</tr>
<tr class="" id="7e1edd8d">
<td id="a228d8e7"><p><code class="code ">libnative_KUShort</code></p></td>
<td id="a3e18f7a"><p><code class="code ">unsigned short</code></p></td>
</tr>
<tr class="" id="b3e4cf77">
<td id="4259caf0"><p><code class="code ">libnative_KUInt</code></p></td>
<td id="e6be1d11"><p><code class="code ">unsigned int</code></p></td>
</tr>
<tr class="" id="1af618a7">
<td id="eb436e3d"><p><code class="code ">libnative_KULong</code></p></td>
<td id="d4778d6"><p><code class="code ">unsigned long long</code></p></td>
</tr>
<tr class="" id="ef53ea12">
<td id="19e3aa34"><p><code class="code ">libnative_KFloat</code></p></td>
<td id="42b1914"><p><code class="code ">float</code></p></td>
</tr>
<tr class="" id="7f7656db">
<td id="53c257d3"><p><code class="code ">libnative_KDouble</code></p></td>
<td id="e77ec8f3"><p><code class="code ">double</code></p></td>
</tr>
<tr class="" id="7688f889">
<td id="ba9b6c03"><p><code class="code ">libnative_KNativePtr</code></p></td>
<td id="beb7e8a7"><p><code class="code ">void*</code></p></td>
</tr>
</tbody>
</table></div>
<p id="568b2868">The definitions part shows how Kotlin primitive types map into C primitive types. The reverse mapping is described in the <a href="mapping-primitive-data-types-from-c" id="8efbb798">Mapping primitive data types from C</a> tutorial.</p>
<p id="8ea0a337">The next part of the <code class="code ">libnative_api.h</code> file contains definitions of the types that are used in the library:</p>
<pre class="code-block" data-lang="c" data-language="c">struct libnative_KType; typedef struct libnative_KType libnative_KType; typedef struct { libnative_KNativePtr pinned; } libnative_kref_example_Object; typedef struct { libnative_KNativePtr pinned; } libnative_kref_example_Clazz; </pre>
<p id="5f4bc002">The <code class="code ">typedef struct { .. } TYPE_NAME</code> syntax is used in C language to declare a structure. <a href="https://stackoverflow.com/questions/1675351/typedef-struct-vs-struct-definitions" id="57a362e0" data-external="true" rel="noopener noreferrer">This thread</a> on Stackoverflow provides more explanations of that pattern.</p>
<p id="8f9a23b1">As you can see from these definitions, the Kotlin object <code class="code ">Object</code> is mapped into <code class="code ">libnative_kref_example_Object</code>, and <code class="code ">Clazz</code> is mapped into <code class="code ">libnative_kref_example_Clazz</code>. Both structs contain nothing but the <code class="code ">pinned</code> field with a pointer, the field type <code class="code ">libnative_KNativePtr</code> is defined as <code class="code ">void*</code> above.</p>
<p id="5ef51e35">There is no namespaces support in C, so the Kotlin/Native compiler generates long names to avoid any possible clashes with other symbols in the existing native project.</p>
<p id="890e2ec2">A significant part of the definitions goes in the <code class="code ">libnative_api.h</code> file. It includes the definition of our Kotlin/Native library world:</p>
<pre class="code-block" data-lang="c" data-language="c">typedef struct { /* Service functions. */ void (*DisposeStablePointer)(libnative_KNativePtr ptr); void (*DisposeString)(const char* string); libnative_KBoolean (*IsInstance)(libnative_KNativePtr ref, const libnative_KType* type); /* User functions. */ struct { struct { struct { void (*forIntegers)(libnative_KByte b, libnative_KShort s, libnative_KUInt i, libnative_KLong l); void (*forFloats)(libnative_KFloat f, libnative_KDouble d); const char* (*strings)(const char* str); const char* (*get_globalString)(); struct { libnative_KType* (*_type)(void); libnative_kref_example_Object (*_instance)(); const char* (*get_field)(libnative_kref_example_Object thiz); } Object; struct { libnative_KType* (*_type)(void); libnative_kref_example_Clazz (*Clazz)(); libnative_KULong (*memberFunction)(libnative_kref_example_Clazz thiz, libnative_KInt p); } Clazz; } example; } root; } kotlin; } libnative_ExportedSymbols; </pre>
<p id="fa6b190f">The code uses anonymous structure declarations. The code <code class="code ">struct { .. } foo</code> declares a field in the outer struct of that anonymous structure type, the type with no name.</p>
<p id="6171868c">C does not support objects either. People use function pointers to mimic object semantics. A function pointer is declared as follows <code class="code ">RETURN_TYPE (* FIELD_NAME)(PARAMETERS)</code>. It is tricky to read, but we should be able to see function pointer fields in the structures above.</p>
<section class="chapter"><h3 id="runtime-functions" data-toc="native-dynamic-libraries#runtime-functions">Runtime functions</h3>
<p id="fe39c020">The code reads as follows. You have the <code class="code ">libnative_ExportedSymbols</code> structure, which defines all the functions that Kotlin/Native and our library provides us. It uses nested anonymous structures heavily to mimic packages. The <code class="code ">libnative_</code> prefix comes from the library name.</p>
<p id="13e34ec2">The <code class="code ">libnative_ExportedSymbols</code> structure contains several helper functions:</p>
<pre class="code-block" data-lang="c" data-language="c">void (*DisposeStablePointer)(libnative_KNativePtr ptr); void (*DisposeString)(const char* string); libnative_KBoolean (*IsInstance)(libnative_KNativePtr ref, const libnative_KType* type); </pre>
<p id="45c6f63d">These functions deal with Kotlin/Native objects. Call the <code class="code ">DisposeStablePointer</code> to release a Kotlin object and <code class="code ">DisposeString</code> to release a Kotlin String, which has the <code class="code ">char*</code> type in C. It is possible to use the <code class="code ">IsInstance</code> function to check if a Kotlin type or a <code class="code ">libnative_KNativePtr</code> is an instance of another type. The actual set of operations generated depends on the actual usages.</p>
<p id="986403d5">Kotlin/Native has garbage collection, but it does not help us deal with Kotlin objects from the C language. Kotlin/Native has interop with Objective-C and Swift and integrates with their reference counters. The <a href="native-objc-interop" id="f9dc8251">Objective-C Interop</a> documentation article contains more details on it. Also, there is the tutorial <a href="apple-framework" id="968afef8">Kotlin/Native as an Apple Framework</a>.</p></section><section class="chapter"><h3 id="your-library-functions" data-toc="native-dynamic-libraries#your-library-functions">Your library functions</h3>
<p id="8ab0b0f5">Let's take a look at the <code class="code ">kotlin.root.example</code> field, it mimics the package structure of our Kotlin code with a <code class="code ">kotlin.root.</code> prefix.</p>
<p id="b633e75d">There is a <code class="code ">kotlin.root.example.Clazz</code> field that represents the <code class="code ">Clazz</code> from Kotlin. The <code class="code ">Clazz#memberFunction</code> is accessible with the <code class="code ">memberFunction</code> field. The only difference is that the <code class="code ">memberFunction</code> accepts a <code class="code ">this</code> reference as the first parameter. The C language does not support objects, and this is the reason to pass a <code class="code ">this</code> pointer explicitly.</p>
<p id="8d887d73">There is a constructor in the <code class="code ">Clazz</code> field (aka <code class="code ">kotlin.root.example.Clazz.Clazz</code>), which is the constructor function to create an instance of the <code class="code ">Clazz</code>.</p>
<p id="2bf2920c">Kotlin <code class="code ">object Object</code> is accessible as <code class="code ">kotlin.root.example.Object</code>. There is the <code class="code ">_instance</code> function to get the only instance of the object.</p>
<p id="3034e86f">Properties are translated into functions. The <code class="code ">get_</code> and <code class="code ">set_</code> prefix is used to name the getter and the setter functions respectively. For example, the read-only property <code class="code ">globalString</code> from Kotlin is turned into a <code class="code ">get_globalString</code> function in C.</p>
<p id="33afadc0">Global functions <code class="code ">forInts</code>, <code class="code ">forFloats</code>, or <code class="code ">strings</code> are turned into the functions pointers in the <code class="code ">kotlin.root.example</code> anonymous struct.</p></section><section class="chapter"><h3 id="entry-point" data-toc="native-dynamic-libraries#entry-point">Entry point</h3>
<p id="451cbc9e">You can see how the API is created. To start with, you need to initialize the <code class="code ">libnative_ExportedSymbols</code> structure. Let's take a look at the latest part of the <code class="code ">libnative_api.h</code> for this:</p>
<pre class="code-block" data-lang="c" data-language="c">extern libnative_ExportedSymbols* libnative_symbols(void); </pre>
<p id="6b9bcae2">The function <code class="code ">libnative_symbols</code> allows you to open the way from the native code to the Kotlin/Native library. This is the entry point you'll use. The library name is used as a prefix for the function name.</p>
<aside data-type="note" class="prompt" data-title="" id="d3d5c3c7"><p id="8051d616">Kotlin/Native object references do not support multi-threaded access. Hosting the returned <code class="code ">libnative_ExportedSymbols*</code> pointer per thread might be necessary.</p></aside></section></section><section class="chapter"><h2 id="use-generated-headers-from-c" data-toc="native-dynamic-libraries#use-generated-headers-from-c">Use generated headers from C</h2>
<p id="9718e468">The usage from C is straightforward and uncomplicated. Create a <code class="code ">main.c</code> file with the following code:</p>
<pre class="code-block" data-lang="c" data-language="c">#include "libnative_api.h" #include "stdio.h" int main(int argc, char** argv) { //obtain reference for calling Kotlin/Native functions libnative_ExportedSymbols* lib = libnative_symbols(); lib-&gt;kotlin.root.example.forIntegers(1, 2, 3, 4); lib-&gt;kotlin.root.example.forFloats(1.0f, 2.0); //use C and Kotlin/Native strings const char* str = "Hello from Native!"; const char* response = lib-&gt;kotlin.root.example.strings(str); printf("in: %s\nout:%s\n", str, response); lib-&gt;DisposeString(response); //create Kotlin object instance libnative_kref_example_Clazz newInstance = lib-&gt;kotlin.root.example.Clazz.Clazz(); long x = lib-&gt;kotlin.root.example.Clazz.memberFunction(newInstance, 42); lib-&gt;DisposeStablePointer(newInstance.pinned); printf("DemoClazz returned %ld\n", x); return 0; } </pre></section><section class="chapter"><h2 id="compile-and-run-the-example-on-linux-and-macos" data-toc="native-dynamic-libraries#compile-and-run-the-example-on-linux-and-macos">Compile and run the example on Linux and macOS</h2>
<p id="bef25ee5">On macOS 10.13 with Xcode, compile the C code and link it with the dynamic library with the following command:</p>
<pre class="code-block" data-lang="bash" data-language="bash">clang main.c libnative.dylib </pre>
<p id="e53c6349">On Linux call a similar command:</p>
<pre class="code-block" data-lang="bash" data-language="bash">gcc main.c libnative.so </pre>
<p id="77ef4fca">The compiler generates an executable called <code class="code ">a.out</code>. Run it to see in action the Kotlin code being executed from C library. On Linux, you'll need to include <code class="code ">.</code> into the <code class="code ">LD_LIBRARY_PATH</code> to let the application know to load the <code class="code ">libnative.so</code> library from the current folder.</p></section><section class="chapter"><h2 id="compile-and-run-the-example-on-windows" data-toc="native-dynamic-libraries#compile-and-run-the-example-on-windows">Compile and run the example on Windows</h2>
<p id="e6345ee6">To start with, you'll need a Microsoft Visual C++ compiler installed that supports a x64_64 target. The easiest way to do this is to have a version of Microsoft Visual Studio installed on a Windows machine.</p>
<p id="9438414c">In this example, you'll be using the <code class="code ">x64 Native Tools Command Prompt &lt;VERSION&gt;</code> console. You'll see the shortcut to open the console in the start menu. It comes with a Microsoft Visual Studio package.</p>
<p id="f5d5aaf9">On Windows, Dynamic libraries are included either via a generated static library wrapper or with manual code, which deals with the <a href="https://docs.microsoft.com/en-gb/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya" id="ae675007" data-external="true" rel="noopener noreferrer">LoadLibrary</a> or similar Win32API functions. Follow the first option and generate the static wrapper library for the <code class="code ">libnative.dll</code> as described below.</p>
<p id="78e6f18f">Call <code class="code ">lib.exe</code> from the toolchain to generate the static library wrapper <code class="code ">libnative.lib</code> that automates the DLL usage from the code:</p>
<pre class="code-block" data-lang="bash" data-language="bash">lib /def:libnative_symbols.def /out:libnative.lib </pre>
<p id="8a780eb">Now you are ready to compile our <code class="code ">main.c</code> into an executable. Include the generated <code class="code ">libnative.lib</code> into the build command and start:</p>
<pre class="code-block" data-lang="bash" data-language="bash">cl.exe main.c libnative.lib </pre>
<p id="8738881">The command produces the <code class="code ">main.exe</code> file, which you can run.</p></section><section class="chapter"><h2 id="next-steps" data-toc="native-dynamic-libraries#next-steps">Next steps</h2>
<p id="3a9b546f">Dynamic libraries are the main way to use Kotlin code from existing programs. You can use them to share your code with many platforms or languages, including JVM, <a href="https://github.com/JetBrains/kotlin/blob/master/kotlin-native/samples/python_extension/src/main/c/kotlin_bridge.c" id="a002a712" data-external="true" rel="noopener noreferrer">Python</a>, iOS, Android, and others.</p>
<p id="fae4a015">Kotlin/Native also has tight integration with Objective-C and Swift. It is covered in the <a href="apple-framework" id="37d3e00">Kotlin/Native as an Apple Framework</a> tutorial.</p></section><div class="last-modified"> Last modified: 22 November 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="native-platform-libs">Platform libraries</a> <a class="navigation-links__next" href="native-c-interop">Interoperability with C</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/native-dynamic-libraries.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/native-dynamic-libraries.html</a>
  </p>
</div>
