<h1 data-toc="kmm-use-ktor-for-networking" id="kmm-use-ktor-for-networking.md">Use Ktor for networking</h1>
<p id="2485c2f4">Conventionally, modern applications with client-server architecture use the HTTP protocol for transferring data between the server and the client. If your mobile app has a server to exchange data with, an HTTP client is an essential part of this app that enables its interaction with the server.</p>
<p id="ec8fc2be">For Kotlin projects, we recommend <a href="https://ktor.io/" id="62f16329" data-external="true" rel="noopener noreferrer">Ktor</a> - a framework for building asynchronous clients and servers. It’s written in Kotlin and leverages its core features such as coroutines or targeting multiple platforms. For more detailed information, see the <a href="https://ktor.io/" id="3c40ecb8" data-external="true" rel="noopener noreferrer">Ktor website</a>.</p>
<p id="bae94fca">In Kotlin Multiplatform Mobile (KMM) projects, you can use the <a href="https://ktor.io/clients/index.html" id="f91352ca" data-external="true" rel="noopener noreferrer">Ktor Http Client</a> for interactions with servers. On this page, we’ll take a brief tour on how to connect the Ktor client to a KMM project, create and configure an HTTP client, and perform network requests with it.</p>
<section class="chapter"><h2 id="connect-ktor" data-toc="kmm-use-ktor-for-networking#connect-ktor">Connect Ktor</h2>
<p id="7eee7368">To use the Ktor HTTP client in your project, connect the client as a Gradle dependency: add the corresponding entries in the <code class="code ">dependencies</code> block of a module’s build file (<code class="code ">build.gradle</code> or <code class="code ">build.gradle.kts</code>).</p>
<p id="56ebf8f3">Ktor provides separate artifacts for using the HTTP client: a common module and different engines that process the network request.</p>
<p id="2dd22349">To use Ktor KMM module in the common code, add the dependency to io.ktor:ktor-client-core to the <code class="code ">commonMain</code> source set in the <code class="code ">build.gradle</code> or <code class="code ">build.gradle.kts</code> file of the KMM module:</p>
<div class="tabs" id="9a6c3a39" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="aba2df65" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code-block" data-lang="kotlin" data-title="Kotlin" data-language="kotlin">val commonMain by getting { dependencies { implementation("io.ktor:ktor-client-core:$ktor_version") } } </pre></div>
<div class="tabs__content" data-gtm="tab" id="6e4bd8dc" data-sync-tabs="groovy" data-title="Groovy"><pre class="code-block" data-lang="groovy" data-title="Groovy" data-language="groovy">commonMain { dependencies { implementation "io.ktor:ktor-client-core:$ktor_version" } } </pre></div>
</div>
<p id="e2f1f4f7">Then connect the platform engines by adding the dependencies on them. For Android, add the <code class="code ">ktor-client-android</code> dependency to the corresponding source set:</p>
<div class="tabs" id="8c12c0aa" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="c1b719b9" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code-block" data-lang="kotlin" data-title="Kotlin" data-language="kotlin">val androidMain by getting { dependencies { implementation("io.ktor:ktor-client-android:$ktor_version") } } </pre></div>
<div class="tabs__content" data-gtm="tab" id="af2edf25" data-sync-tabs="groovy" data-title="Groovy"><pre class="code-block" data-lang="groovy" data-title="Groovy" data-language="groovy">androidMain { dependencies { implementation "io.ktor:ktor-client-android:$ktor_version" } } </pre></div>
</div>
<p id="4d56267d">For iOS, add the <code class="code ">ktor-client-ios</code> dependency to the corresponding source set:</p>
<div class="tabs" id="b3fd91f5" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="5b59210c" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code-block" data-lang="kotlin" data-title="Kotlin" data-language="kotlin">val iosMain by getting { dependencies { implementation("io.ktor:ktor-client-ios:$ktor_version") } } </pre></div>
<div class="tabs__content" data-gtm="tab" id="2a09d7c1" data-sync-tabs="groovy" data-title="Groovy"><pre class="code-block" data-lang="groovy" data-title="Groovy" data-language="groovy">iosMain { dependencies { implementation "io.ktor:ktor-client-ios:$ktor_version" } } </pre></div>
</div>
<p id="3d8749f">Instead of <code class="code ">$ktor_version</code>, use the required version of the library.</p>
<p id="36b0bd4">For more information about connecting the Ktor client to the multiplatform project, see the <a href="https://ktor.io/clients/http-client/multiplatform.html" id="3dc93e1f" data-external="true" rel="noopener noreferrer">Ktor documentation</a>.</p></section><section class="chapter"><h2 id="set-up-an-http-client" data-toc="kmm-use-ktor-for-networking#set-up-an-http-client">Set up an HTTP client</h2>
<p id="ed6c6ccd">In Ktor, HTTP clients are represented by the <code class="code ">HttpClient</code> class. To create an HTTP client with default settings, call the <code class="code ">HttpClient()</code> constructor:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val httpClient: HttpClient = HttpClient(CIO) </pre>
<p id="105864ab"><code class="code ">CIO</code> here is the class that represents an <em id="9b82f278" class="">HTTP engine</em> that the client will use. Let’s take a closer look at the available HTTP engines.</p>
<section class="chapter"><h3 id="select-an-engine" data-toc="kmm-use-ktor-for-networking#select-an-engine">Select an engine</h3>
<p id="60814eac">Ktor offers you multiple HTTP engines to use in your project: Apache, CIO, Android, iOS, and others. Engines differ by sets of supported features or platforms they work on. For the full list of supported HTTP engines, refer to the <a href="https://ktor.io/clients/http-client/engines.html" id="b2ae7cc2" data-external="true" rel="noopener noreferrer">Ktor documentation</a>.</p>
<p id="8adf67a0">To use a specific HTTP engine, connect the corresponding Ktor artifact as a dependency, for example:</p>
<div class="tabs" id="26e54378" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="ce6995b8" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code-block" data-lang="kotlin" data-title="Kotlin" data-language="kotlin">dependencies { implementation("io.ktor:ktor-client-cio:$ktor_version") } </pre></div>
<div class="tabs__content" data-gtm="tab" id="a6d375d0" data-sync-tabs="groovy" data-title="Groovy"><pre class="code-block" data-lang="groovy" data-title="Groovy" data-language="groovy">dependencies { implementation "io.ktor:ktor-client-cio:$ktor_version" } </pre></div>
</div>
<p id="66007124">Now you can create an HTTP client with this engine: just pass the engine class as an argument of the <code class="code ">HttpClient()</code> constructor.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val client = HttpClient(CIO) </pre>
<p id="6154289a">If you call the <code class="code ">HttpClient()</code> constructor without an argument, then one of the engines available to Ktor will be automatically selected at compile time.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val httpClient: HttpClient = HttpClient() </pre>
<section class="chapter"><h4 id="mock-engine" data-toc="kmm-use-ktor-for-networking#mock-engine">Mock engine</h4>
<p id="a3eb07d0">Ktor offers a special HTTP engine for testing purposes - <code class="code ">MockEngine</code>, which simulates HTTP calls without an actual connection to an API endpoint.</p>
<p id="c9b40516">There are several platform-specific implementations of <code class="code ">MockEngine</code>. To use them in your KMM project, connect the corresponding dependencies: <code class="code ">io.ktor:ktor-client-mock-jvm</code> for Android <code class="code ">io.ktor:ktor-client-mock-native</code> for iOS</p>
<div class="tabs" id="557593be" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="6210465e" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code-block" data-lang="kotlin" data-title="Kotlin" data-language="kotlin">dependencies { testImplementation("io.ktor:ktor-client-mock:$ktor_version") } </pre></div>
<div class="tabs__content" data-gtm="tab" id="2294ddc8" data-sync-tabs="groovy" data-title="Groovy"><pre class="code-block" data-lang="groovy" data-title="Groovy" data-language="groovy">dependencies { api "io.ktor:ktor-client-mock:$ktor_version" } </pre></div>
</div>
<p id="83418bd7">Then create an <code class="code ">HttpClient</code> instance with <code class="code ">MockEngine</code>:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val httpClient: HttpClient = HttpClient(MockEngine) </pre>
<p id="33722d86">For detailed information about testing with Ktor, refer to the <a href="https://ktor.io/clients/http-client/testing.html" id="4a16a101" data-external="true" rel="noopener noreferrer">Ktor documentation</a>.</p></section></section><section class="chapter"><h3 id="configure-the-client" data-toc="kmm-use-ktor-for-networking#configure-the-client">Configure the client</h3>
<p id="a9e876e9">Client configuration can be done through a lambda expression with the receiver. In other words, the receiver object of the <code class="code ">HttpClientConfig</code> class for a specific HTTP engine through which the entire configuration is performed will be transferred to the lambda, which is transferred as an argument to the <code class="code ">HttpClient()</code> function.</p>
<p id="7d638fa0">To configure the client, pass a lambda expression to the <code class="code ">HttpClient()</code> call.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val httpClient = HttpClient { expectSuccess = false ResponseObserver { response -&gt; println("HTTP status: ${response.status.value}") } } </pre>
<p id="4342becc">In this example, the following configuration is used: Receiving HTTP errors in response don’t cause exceptions A <code class="code ">ResponseObserver</code> is created that prints response statuses to the standard output.</p>
<section class="chapter"><h4 id="engine-configuration" data-toc="kmm-use-ktor-for-networking#engine-configuration">Engine configuration</h4>
<p id="f4f4e719">When you create an HTTP client with a specific engine, pass the engine configuration in the same lambda in the <code class="code ">engine</code> block.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val client = HttpClient(Android) { engine { connectTimeout = 100_000 socketTimeout = 100_000 proxy = Proxy(Proxy.Type.HTTP, InetSocketAddress("localhost", serverPort)) } } </pre>
<p id="49dc7810">For more information on engines configuration, see the <a href="https://ktor.io/clients/http-client/engines.html" id="9363bb7d" data-external="true" rel="noopener noreferrer">Ktor documentation</a>.</p></section><section class="chapter"><h4 id="features" data-toc="kmm-use-ktor-for-networking#features">Features</h4>
<p id="c7ed5629">Ktor lets you use additional HTTP client functionality (<em id="841211ab" class="">features</em>) that is not available by default, for example, logging, authorization, or serialization. Most of them are distributed in separate artifacts. To use them, you should connect them as dependencies to the common source set. For example:</p>
<div class="tabs" id="b8f74a0e" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="73da8f7c" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code-block" data-lang="kotlin" data-title="Kotlin" data-language="kotlin">val commonMain by getting { dependencies { implementation("io.ktor:ktor-client-auth:$ktor_version") } } </pre></div>
<div class="tabs__content" data-gtm="tab" id="ceeec4bf" data-sync-tabs="groovy" data-title="Groovy"><pre class="code-block" data-lang="groovy" data-title="Groovy" data-language="groovy">commonMain { dependencies { implementation "io.ktor:ktor-client-auth:$ktor_version" } } </pre></div>
</div>
<p id="fa80f405">Then, add the required features in the client configuration using the <code class="code ">install()</code> function.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val client = HttpClient() { install(Auth) { // providers config ... } } </pre>
<p id="934c6210">For example, you can use the <code class="code ">ResponseObserver</code> class to set up an observer for responses. At the beginning of the article, an observer was added using the <code class="code ">ResponseObserver{}</code> builder function, which internally calls up the <code class="code ">install</code> function. An observer as additional functionality can be explicitly added as follows:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val httpClient = HttpClient { install(ResponseObserver) { onResponse { response -&gt; println("HTTP status: ${response.status.value}") } } } </pre>
<p id="d54565ce">For the full list of available HTTP client features and instructions on their configuration, see the <a href="https://ktor.io/clients/http-client/features.html" id="db2ab9e3" data-external="true" rel="noopener noreferrer">Ktor documentation</a>.</p></section></section></section><section class="chapter"><h2 id="create-http-requests" data-toc="kmm-use-ktor-for-networking#create-http-requests">Create HTTP requests</h2>
<p id="50112d3a">The main function for creating HTTP requests is <code class="code ">request</code> - an extension function for the <code class="code ">HttpClient</code> class. All the request settings are generated using the <code class="code ">HttpRequestBuilder</code> class. The <code class="code ">request</code> function has the <code class="code ">suspend</code> modifier, so requests can be executed in coroutines. For detailed information about creating and sending requests with the Ktor client, see the <a href="https://ktor.io/clients/http-client/quick-start/requests.html" id="ec6ee30e" data-external="true" rel="noopener noreferrer">Ktor documentation</a>.</p>
<section class="chapter"><h3 id="method" data-toc="kmm-use-ktor-for-networking#method">Method</h3>
<p id="2b7be1eb">To define an HTTP method (for example, <code class="code ">GET</code> or <code class="code ">POST</code>) for a request, provide a value for the <code class="code ">method</code> property: a <code class="code ">GET</code> request whose result comes as a string:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val htmlContent = httpClient.request&lt;String&gt; { url("https://en.wikipedia.org/wiki/Main_Page") method = HttpMethod.Get } </pre>
<p id="97df1e2a">a <code class="code ">POST</code> request:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val response = httpClient.post&lt;HttpResponse&gt;("http://127.0.0.1:8080/") { headers { append("Authorization", "token") } body = "Command" } </pre>
<p id="a6edd070">Ktor provides extension functions for the <code class="code ">HttpClient</code> class for using basic HTTP methods: <code class="code ">get</code>, <code class="code ">post</code>, <code class="code ">put</code>, <code class="code ">patch</code>, <code class="code ">delete</code>, <code class="code ">options</code>, <code class="code ">head</code>. This is how you use them to send a <code class="code ">GET</code> request:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val response = httpClient.get&lt;HttpResponse&gt;("http://127.0.0.1:8080/") { headers { append("Accept", "application/json") } } </pre></section><section class="chapter"><h3 id="headers" data-toc="kmm-use-ktor-for-networking#headers">Headers</h3>
<p id="4171c757">To add headers to the request, use the <code class="code ">headers</code> extension function.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val htmlContent = httpClient.request&lt;String&gt; { url("https://en.wikipedia.org/wiki/Main_Page") method = HttpMethod.Get headers { append("Accept", "application/json") append("Authorization", "oauth token") } } </pre></section><section class="chapter"><h3 id="body" data-toc="kmm-use-ktor-for-networking#body">Body</h3>
<p id="12118e5d">To set the body of a request, assign a value to the <code class="code ">body</code> property in the <code class="code ">HttpRequestBuilder</code> class. You can assign a string or an <code class="code ">OutgoingContent</code> object to this property. For example, sending data with a <code class="code ">text/plain</code> text MIME type can be implemented as follows:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val htmlContent = httpClient.request&lt;String&gt; { url("http://127.0.0.1:8080/") method = HttpMethod.Post body = TextContent( text = "Body content", contentType = ContentType.Text.Plain ) } </pre></section><section class="chapter"><h3 id="response-type" data-toc="kmm-use-ktor-for-networking#response-type">Response type</h3>
<p id="b9882501">To obtain more information in the response, such as HTTP status, you can use the <code class="code ">HttpResponse</code> type as the request result:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val response = httpClient.request&lt;HttpResponse&gt; { url("https://en.wikipedia.org/wiki/Main_Page") method = HttpMethod.Get } if (response.status == HttpStatusCode.OK) { // HTTP-200 } </pre>
<p id="f0265028">For more information about the <code class="code ">HttpResponse</code>, refer to the <a href="https://ktor.io/clients/http-client/quick-start/responses.html" id="95c7d7b6" data-external="true" rel="noopener noreferrer">Documentation</a>.</p>
<p id="29589d8e">You can also obtain the request results in the form of a byte array:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val response = httpClient.request&lt;ByteArray&gt; { url("https://en.wikipedia.org/wiki/Main_Page") method = HttpMethod.Get } </pre></section><section class="chapter"><h3 id="multipart-requests" data-toc="kmm-use-ktor-for-networking#multipart-requests">Multipart requests</h3>
<p id="cd9ff751">To send a multipart request, pass a <code class="code ">MultiPartFormDataContent</code> object to the <code class="code ">body</code> property. Create this object by calling the <code class="code ">MultiPartFormDataContent()</code> constructor with the argument <code class="code ">parts: List&lt;PartData&gt;</code>. To create this list, use the <code class="code ">FormBuilder</code> builder class. It provides multiple variations of the <code class="code ">append</code> function for adding the data. There is also <code class="code ">formData</code> builder function, which accepts a lambda with the <code class="code ">FormBuilder</code> receiver.</p>
<p id="afdf3906">An example of creating a POST request with Multipart data may look as follows:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val request: String = httpClient.post("http://127.0.0.1:8080/") { body = MultiPartFormDataContent( formData { append("key", "value") } ) } </pre></section></section><section class="chapter"><h2 id="concurrency" data-toc="kmm-use-ktor-for-networking#concurrency">Concurrency</h2>
<p id="adfa575c">The Ktor API is based on <code class="code ">suspend</code> functions, so Kotlin coroutines are used when working with asynchronous requests. Therefore, all requests must be executed in coroutines, which will suspend their execution while awaiting a response.</p>
<p id="b9057529">For concurrent execution of two or more requests, you can use coroutine builders: <code class="code ">launch</code> or <code class="code ">async</code>. For example, sending two concurrent requests using <code class="code ">async</code> might look as follows:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">suspend fun parallelRequests() = coroutineScope&lt;Unit&gt; { val httpClient = HttpClient() val firstRequest = async { httpClient.get&lt;ByteArray&gt;("https://127.0.0.1:8080/a") } val secondRequest = async { httpClient.get&lt;ByteArray&gt;("https://127.0.0.1:8080/b") } val bytes1 = firstRequest.await() // Suspension point. val bytes2 = secondRequest.await() // Suspension point. httpClient.close() } </pre></section><section class="chapter"><h2 id="close-the-http-client" data-toc="kmm-use-ktor-for-networking#close-the-http-client">Close the HTTP client</h2>
<p id="26d29825">After you finish working with the HTTP client, don’t forget to free up the resources that it uses: threads, connections, and <code class="code ">CoroutineScope</code> for coroutines. To do this, call up the <code class="code ">close()</code> function in <code class="code ">HttpClient</code>:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">httpClient.close() </pre>
<p id="5009f3a3">If you need to use <code class="code ">HttpClient</code> for a single request, call the extension function <code class="code ">use()</code> that will automatically calls <code class="code ">close()</code> after executing the code block:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val status = HttpClient().use { httpClient -&gt; // ... } </pre>
<p id="8d9f9d58">Note that the <code class="code ">close</code> function prohibits the creation of new requests, but doesn’t terminate currently active ones. Resources will only be released after all client requests are completed</p>
<p id="dad21a9b"><em id="bc6e9910" class="">We'd like to thank the <a href="http://icerockdev.com/" id="4de42f39" data-external="true" rel="noopener noreferrer">IceRock team</a> for helping us write this article.</em></p></section><div class="last-modified"> Last modified: 05 October 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="kmm-configure-sqldelight-for-data-storage">Configure SQLDelight for data storage</a> <a class="navigation-links__next" href="kmm-publish-apps">Publish KMM apps</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/kmm-use-ktor-for-networking.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/kmm-use-ktor-for-networking.html</a>
  </p>
</div>
