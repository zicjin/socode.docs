<h1 data-toc="kmm-concurrency-and-coroutines" id="kmm-concurrency-and-coroutines.md">Concurrency and coroutines</h1>
<p id="6f1453a8">When working with mobile platforms, you may need to write multithreaded code that runs in parallel. For this, you can use the <a href="#coroutines" id="43b3c4c3">standard</a><code class="code ">kotlinx.coroutines</code> library or its <a href="#multithreaded-coroutines" id="69cfc83b">multithreaded version</a> and <a href="#alternatives-to-kotlinx-coroutines" id="1d4af5b7">alternative solutions</a>.</p>
<p id="d1687ce5">Review the pros and cons of each solution and choose the one that works best for your situation.</p>
<p id="6c18f2e1">Learn more about <a href="kmm-concurrency-overview" id="9f07616d">concurrency, the current approach, and future improvements</a>.</p>
<section class="chapter"><h2 id="coroutines" data-toc="kmm-concurrency-and-coroutines#coroutines">Coroutines</h2>
<p id="d7b06f4b">Coroutines are light-weight threads that allow you to write asynchronous non-blocking code. Kotlin provides the <a href="https://github.com/Kotlin/kotlinx.coroutines" id="59586464" data-external="true" rel="noopener noreferrer"><code class="code ">kotlinx.coroutines</code></a> library with a number of high-level coroutine-enabled primitives.</p>
<p id="7951cf4c">The current version of <code class="code ">kotlinx.coroutines</code>, which can be used for iOS, supports usage only in a single thread. You cannot send work to other threads by changing a <a href="#dispatcher-for-changing-threads" id="472a14d4">dispatcher</a>.</p>
<p id="5d3afd8c">For Kotlin 1.6.10, the recommended coroutines version is <code class="code ">1.6.0</code>.</p>
<p id="1b556de6">You can suspend execution and do work on other threads while using a different mechanism for scheduling and managing that work. However, this version of <code class="code ">kotlinx.coroutines</code> cannot change threads on its own.</p>
<p id="b2d2470">There is also <a href="#multithreaded-coroutines" id="920307f8">another version of <code class="code ">kotlinx.coroutines</code></a> that provides support for multiple threads.</p>
<p id="daae6d7c">Get acquainted with the main concepts for using coroutines:</p>
<ul class="list _ul" id="c21900ea">
<li class="list__item" id="d1d5799a"><p><a href="#asynchronous-vs-parallel-processing" id="3de86e01">Asynchronous vs. parallel processing</a></p></li>
<li class="list__item" id="7c3ffab8"><p><a href="#dispatcher-for-changing-threads" id="ed0feb1a">Dispatcher for changing threads</a></p></li>
<li class="list__item" id="fc38663e"><p><a href="#frozen-captured-data" id="20203c91">Frozen captured data</a></p></li>
<li class="list__item" id="f6a8a4fb"><p><a href="#frozen-returned-data" id="278079f">Frozen returned data</a></p></li>
</ul>
<section class="chapter"><h3 id="asynchronous-vs-parallel-processing" data-toc="kmm-concurrency-and-coroutines#asynchronous-vs-parallel-processing">Asynchronous vs. parallel processing</h3>
<p id="47e8c771">Asynchronous and parallel processing are different.</p>
<p id="c1cff4a5">Within a coroutine, the processing sequence may be suspended and resumed later. This allows for asynchronous, non-blocking code, without using callbacks or promises. That is asynchronous processing, but everything related to that coroutine can happen in a single thread.</p>
<p id="98b18e96">The following code makes a network call using <a href="https://ktor.io/" id="986312a7" data-external="true" rel="noopener noreferrer">Ktor</a>. In the main thread, the call is initiated and suspended, while another underlying process performs the actual networking. When completed, the code resumes in the main thread.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val client = HttpClient() //Running in the main thread, start a `get` call client.get&lt;String&gt;("https://example.com/some/rest/call") //The get call will suspend and let other work happen in the main thread, and resume when the get call completes </pre>
<p id="4eee54cc">That is different from parallel code that needs to be run in another thread. Depending on your purpose and the libraries you use, you may never need to use multiple threads.</p></section><section class="chapter"><h3 id="dispatcher-for-changing-threads" data-toc="kmm-concurrency-and-coroutines#dispatcher-for-changing-threads">Dispatcher for changing threads</h3>
<p id="deff001">Coroutines are executed by a dispatcher that defines which thread the coroutine will be executed on. There are a number of ways in which you can specify the dispatcher, or change the one for the coroutine. For example:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">suspend fun differentThread() = withContext(Dispatchers.Default){ println("Different thread") } </pre>
<p id="c5a6f1e6"><code class="code ">withContext</code> takes both a dispatcher as an argument and a code block that will be executed by the thread defined by the dispatcher. Learn more about <a href="coroutine-context-and-dispatchers" id="12fb3415">coroutine context and dispatchers</a>.</p>
<p id="3cd74ea7">To perform work on a different thread, specify a different dispatcher and a code block to execute. In general, switching dispatchers and threads works similar to the JVM, but there are differences related to freezing captured and returned data.</p></section><section class="chapter"><h3 id="frozen-captured-data" data-toc="kmm-concurrency-and-coroutines#frozen-captured-data">Frozen captured data</h3>
<p id="d57fe450">To run code on a different thread, you pass a <code class="code ">functionBlock</code>, which gets frozen and then runs in another thread.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">fun &lt;R&gt; runOnDifferentThread(functionBlock: () -&gt; R) </pre>
<p id="756f67fd">You will call that function as follows:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">runOnDifferentThread { //Code run in another thread } </pre>
<p id="26a1ac7e">As described in the <a href="kmm-concurrency-overview" id="acf643f4">concurrency overview</a>, a state shared between threads in Kotlin/Native must be frozen. A function argument is a state itself, which will be frozen along with anything it captures.</p>
<p id="d7a49f3b">Coroutine functions that cross threads use the same pattern. To allow function blocks to be executed on another thread, they are frozen.</p>
<p id="bb02589a">In the following example, the data class instance <code class="code ">dc</code> will be captured by the function block and will be frozen when crossing threads. The <code class="code ">println</code> statement will print <code class="code ">true</code>.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val dc = DataClass("Hello") withContext(Dispatchers.Default) { println("${dc.isFrozen}") } </pre>
<p id="330b7896">When running parallel code, be careful with the captured state. Sometimes it's obvious when the state will be captured, but not always. For example:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">class SomeModel(val id:IdRec){ suspend fun saveData() = withContext(Dispatchers.Default){ saveToDb(id) } } </pre>
<p id="1d2e6bf8">The code inside <code class="code ">saveData</code> runs on another thread. That will freeze <code class="code ">id</code>, but because <code class="code ">id</code> is a property of the parent class, it will also freeze the parent class.</p></section><section class="chapter"><h3 id="frozen-returned-data" data-toc="kmm-concurrency-and-coroutines#frozen-returned-data">Frozen returned data</h3>
<p id="b5c6ddb0">Data returned from a different thread is also frozen. Even though it's recommended that you return immutable data, you can return a mutable state in a way that doesn't allow a returned value to be changed.</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">val dc = withContext(Dispatchers.Default) { DataClass("Hello Again") } println("${dc.isFrozen}") </pre>
<p id="b58ce619">It may be a problem if a mutable state is isolated in a single thread and coroutine threading operations are used for communication. If you attempt to return data that retains a reference to the mutable state, it will also freeze the data by association.</p>
<p id="d8647a23">Learn more about the <a href="kmm-concurrent-mutability#thread-isolated-state" id="53757e66">thread-isolated state</a>.</p></section></section><section class="chapter"><h2 id="multithreaded-coroutines" data-toc="kmm-concurrency-and-coroutines#multithreaded-coroutines">Multithreaded coroutines</h2>
<p id="aaf5dcc">A <a href="https://github.com/Kotlin/kotlinx.coroutines/tree/native-mt" id="e119fe59" data-external="true" rel="noopener noreferrer">special branch</a> of the <code class="code ">kotlinx.coroutines</code> library provides support for using multiple threads. It is a separate branch for the reasons listed in the <a href="https://blog.jetbrains.com/kotlin/2020/07/kotlin-native-memory-management-roadmap/" id="8cbe17f8" data-external="true" rel="noopener noreferrer">future concurrency model blog post</a>.</p>
<p id="13226b52">However, you can still use the multithreaded version of <code class="code ">kotlinx.coroutines</code> in production, taking its specifics into account.</p>
<p id="77264d59">The current version for Kotlin 1.6.10 is <code class="code ">1.6.0-native-mt</code>.</p>
<p id="81327c46">To use the multithreaded version, add a dependency for the <code class="code ">commonMain</code> source set in <code class="code ">build.gradle.kts</code>:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">commonMain { dependencies { implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.0-native-mt" } } </pre>
<p id="6fc5e7dd">When using other libraries that also depend on <code class="code ">kotlinx.coroutines</code>, such as Ktor, make sure to specify the multithreaded version of <code class="code ">kotlinx-coroutines</code>. You can do this with <code class="code ">strictly</code>:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">implementation ("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.0-native-mt"){ version { strictly("1.6.0-native-mt") } } </pre>
<p id="a4fc6a16">Because the main version of <code class="code ">kotlinx.coroutines</code> is a single-threaded one, libraries will almost certainly rely on this version. If you see <code class="code ">InvalidMutabilityException</code> related to a coroutine operation, it's very likely that you are using the wrong version.</p>
<aside data-type="note" class="prompt" data-title="" id="f81a3d5a"><p id="306fa618">Using multithreaded coroutines may result in <em id="13a0a744" class="">memory leaks</em>. This can be a problem for complex coroutine scenarios under load. We are working on a solution for this.</p></aside><p id="45647da3">See a <a href="https://github.com/touchlab/KaMPKit" id="93d76c" data-external="true" rel="noopener noreferrer">complete example of using multithreaded coroutines in a KMM application</a>.</p></section><section class="chapter"><h2 id="alternatives-to-kotlinx-coroutines" data-toc="kmm-concurrency-and-coroutines#alternatives-to-kotlinx-coroutines">Alternatives to kotlinx-coroutines</h2>
<p id="7d32a5cb">There are a few alternative ways to run parallel code.</p>
<section class="chapter"><h3 id="coroutineworker" data-toc="kmm-concurrency-and-coroutines#coroutineworker">CoroutineWorker</h3>
<p id="a619133d"><a href="https://github.com/Autodesk/coroutineworker" id="b28331ec" data-external="true" rel="noopener noreferrer"><code class="code ">CoroutinesWorker</code></a> is a library published by AutoDesk that implements some features of coroutines across threads using the single-threaded version of <code class="code ">kotlinx.coroutines</code>.</p>
<p id="efc7337a">For simple suspend functions this is a pretty good option, but it does not support Flow and other structures.</p></section><section class="chapter"><h3 id="reaktive" data-toc="kmm-concurrency-and-coroutines#reaktive">Reaktive</h3>
<p id="c6972eff"><a href="https://github.com/badoo/Reaktive" id="77c086f" data-external="true" rel="noopener noreferrer">Reaktive</a> is an Rx-like library that implements Reactive extensions for Kotlin Multiplatform. It has some coroutine extensions but is primarily designed around RX and threads.</p></section><section class="chapter"><h3 id="custom-processor" data-toc="kmm-concurrency-and-coroutines#custom-processor">Custom processor</h3>
<p id="ba61eaab">For simpler background tasks, you can create your own processor with wrappers around platform specifics. See a <a href="https://github.com/touchlab/KMMWorker" id="ed2b40fb" data-external="true" rel="noopener noreferrer">simple example</a>.</p></section><section class="chapter"><h3 id="platform-concurrency" data-toc="kmm-concurrency-and-coroutines#platform-concurrency">Platform concurrency</h3>
<p id="f109a396">In production, you can also rely on the platform to handle concurrency. This could be helpful if the shared Kotlin code will be used for business logic or data operations rather than architecture.</p>
<p id="9f4bf0f">To share a state in iOS across threads, that state needs to be <a href="kmm-concurrency-overview#immutable-and-frozen-state" id="306a55c2">frozen</a>. The concurrency libraries mentioned here will freeze your data automatically. You will rarely need to do so explicitly, if ever.</p>
<p id="b16b362">If you return data to the iOS platform that should be shared across threads, ensure that data is frozen before leaving the iOS boundary.</p>
<p id="1d5ea68">Kotlin has the concept of frozen only for Kotlin/Native platforms including iOS. To make <code class="code ">freeze</code> available in common code, you can create expect and actual implementations for <code class="code ">freeze</code>, or use <a href="https://github.com/touchlab/Stately#stately-common" id="46f5b015" data-external="true" rel="noopener noreferrer"><code class="code ">stately-common</code></a>, which provides this functionality. In Kotlin/Native, <code class="code ">freeze</code> will freeze your state, while on the JVM it'll do nothing.</p>
<p id="87982908">To use <code class="code ">stately-common</code>, add a dependency for the <code class="code ">commonMain</code> source set in <code class="code ">build.gradle.kts</code>:</p>
<pre class="code-block" data-lang="kotlin" data-language="kotlin">commonMain { dependencies { implementation "co.touchlab:stately-common:1.0.x" } } </pre>
<p id="99b03157"><em id="ca8fa496" class="">This material was prepared by <a href="https://touchlab.co/" id="fde88a13" data-external="true" rel="noopener noreferrer">Touchlab</a> for publication by JetBrains.</em></p></section></section><div class="last-modified"> Last modified: 05 October 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="kmm-concurrent-mutability">Concurrent mutability</a> <a class="navigation-links__next" href="kmm-samples">Samples</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/kmm-concurrency-and-coroutines.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/kmm-concurrency-and-coroutines.html</a>
  </p>
</div>
