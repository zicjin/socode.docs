<h1 id="signals">Signals</h1> <p id="s-module-django.dispatch">Django includes a “signal dispatcher” which helps decoupled applications get notified when actions occur elsewhere in the framework. In a nutshell, signals allow certain <em>senders</em> to notify a set of <em>receivers</em> that some action has taken place. They’re especially useful when many pieces of code may be interested in the same events.</p> <p>Django provides a <a class="reference internal" href="../ref/signals"><span class="doc">set of built-in signals</span></a> that let user code get notified by Django itself of certain actions. These include some useful notifications:</p> <ul> <li>
<p class="first"><a class="reference internal" href="../ref/signals#django.db.models.signals.pre_save" title="django.db.models.signals.pre_save"><code>django.db.models.signals.pre_save</code></a> &amp; <a class="reference internal" href="../ref/signals#django.db.models.signals.post_save" title="django.db.models.signals.post_save"><code>django.db.models.signals.post_save</code></a></p> <p>Sent before or after a model’s <a class="reference internal" href="../ref/models/instances#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a> method is called.</p> </li> <li>
<p class="first"><a class="reference internal" href="../ref/signals#django.db.models.signals.pre_delete" title="django.db.models.signals.pre_delete"><code>django.db.models.signals.pre_delete</code></a> &amp; <a class="reference internal" href="../ref/signals#django.db.models.signals.post_delete" title="django.db.models.signals.post_delete"><code>django.db.models.signals.post_delete</code></a></p> <p>Sent before or after a model’s <a class="reference internal" href="../ref/models/instances#django.db.models.Model.delete" title="django.db.models.Model.delete"><code>delete()</code></a> method or queryset’s <a class="reference internal" href="../ref/models/querysets#django.db.models.query.QuerySet.delete" title="django.db.models.query.QuerySet.delete"><code>delete()</code></a> method is called.</p> </li> <li>
<p class="first"><a class="reference internal" href="../ref/signals#django.db.models.signals.m2m_changed" title="django.db.models.signals.m2m_changed"><code>django.db.models.signals.m2m_changed</code></a></p> <p>Sent when a <a class="reference internal" href="../ref/models/fields#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code>ManyToManyField</code></a> on a model is changed.</p> </li> <li>
<p class="first"><a class="reference internal" href="../ref/signals#django.core.signals.request_started" title="django.core.signals.request_started"><code>django.core.signals.request_started</code></a> &amp; <a class="reference internal" href="../ref/signals#django.core.signals.request_finished" title="django.core.signals.request_finished"><code>django.core.signals.request_finished</code></a></p> <p>Sent when Django starts or finishes an HTTP request.</p> </li> </ul> <p>See the <a class="reference internal" href="../ref/signals"><span class="doc">built-in signal documentation</span></a> for a complete list, and a complete explanation of each signal.</p> <p>You can also <a class="reference internal" href="#defining-and-sending-signals">define and send your own custom signals</a>; see below.</p>  <h2 id="listening-to-signals">Listening to signals</h2> <p id="s-listening-to-signals">To receive a signal, register a <em>receiver</em> function using the <a class="reference internal" href="#django.dispatch.Signal.connect" title="django.dispatch.Signal.connect"><code>Signal.connect()</code></a> method. The receiver function is called when the signal is sent. All of the signal’s receiver functions are called one at a time, in the order they were registered.</p> <dl class="method"> <dt id="django.dispatch.Signal.connect">
<code>Signal.connect(receiver, sender=None, weak=True, dispatch_uid=None)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/_modules/django/dispatch/dispatcher/#Signal.connect"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>receiver</strong> – The callback function which will be connected to this signal. See <a class="reference internal" href="#receiver-functions"><span class="std std-ref">Receiver functions</span></a> for more information.</li> <li>
<strong>sender</strong> – Specifies a particular sender to receive signals from. See <a class="reference internal" href="#connecting-to-specific-signals"><span class="std std-ref">Connecting to signals sent by specific senders</span></a> for more information.</li> <li>
<strong>weak</strong> – Django stores signal handlers as weak references by default. Thus, if your receiver is a local function, it may be garbage collected. To prevent this, pass <code>weak=False</code> when you call the signal’s <code>connect()</code> method.</li> <li>
<strong>dispatch_uid</strong> – A unique identifier for a signal receiver in cases where duplicate signals may be sent. See <a class="reference internal" href="#preventing-duplicate-signals"><span class="std std-ref">Preventing duplicate signals</span></a> for more information.</li> </ul> </td> </tr>  </table> </dd>
</dl> <p>Let’s see how this works by registering a signal that gets called after each HTTP request is finished. We’ll be connecting to the <a class="reference internal" href="../ref/signals#django.core.signals.request_finished" title="django.core.signals.request_finished"><code>request_finished</code></a> signal.</p>  <h3 id="id1">Receiver functions</h3> <p id="s-receiver-functions">First, we need to define a receiver function. A receiver can be any Python function or method:</p> <pre data-language="python">def my_callback(sender, **kwargs):
    print("Request finished!")
</pre> <p>Notice that the function takes a <code>sender</code> argument, along with wildcard keyword arguments (<code>**kwargs</code>); all signal handlers must take these arguments.</p> <p>We’ll look at senders <a class="reference internal" href="#connecting-to-specific-signals"><span class="std std-ref">a bit later</span></a>, but right now look at the <code>**kwargs</code> argument. All signals send keyword arguments, and may change those keyword arguments at any time. In the case of <a class="reference internal" href="../ref/signals#django.core.signals.request_finished" title="django.core.signals.request_finished"><code>request_finished</code></a>, it’s documented as sending no arguments, which means we might be tempted to write our signal handling as <code>my_callback(sender)</code>.</p> <p>This would be wrong – in fact, Django will throw an error if you do so. That’s because at any point arguments could get added to the signal and your receiver must be able to handle those new arguments.</p>   <h3 id="id2">Connecting receiver functions</h3> <p id="s-connecting-receiver-functions">There are two ways you can connect a receiver to a signal. You can take the manual connect route:</p> <pre data-language="python">from django.core.signals import request_finished

request_finished.connect(my_callback)
</pre> <p>Alternatively, you can use a <a class="reference internal" href="#django.dispatch.receiver" title="django.dispatch.receiver"><code>receiver()</code></a> decorator:</p> <dl class="function"> <dt id="django.dispatch.receiver">
<code>receiver(signal)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/_modules/django/dispatch/dispatcher/#receiver"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<strong>signal</strong> – A signal or a list of signals to connect a function to.</td> </tr>  </table> </dd>
</dl> <p>Here’s how you connect with the decorator:</p> <pre data-language="python">from django.core.signals import request_finished
from django.dispatch import receiver

@receiver(request_finished)
def my_callback(sender, **kwargs):
    print("Request finished!")
</pre> <p>Now, our <code>my_callback</code> function will be called each time a request finishes.</p> <div class="admonition-where-should-this-code-live admonition"> <p class="first admonition-title">Where should this code live?</p> <p>Strictly speaking, signal handling and registration code can live anywhere you like, although it’s recommended to avoid the application’s root module and its <code>models</code> module to minimize side-effects of importing code.</p> <p>In practice, signal handlers are usually defined in a <code>signals</code> submodule of the application they relate to. Signal receivers are connected in the <a class="reference internal" href="../ref/applications#django.apps.AppConfig.ready" title="django.apps.AppConfig.ready"><code>ready()</code></a> method of your application <a class="reference internal" href="../ref/applications#configuring-applications-ref"><span class="std std-ref">configuration class</span></a>. If you’re using the <a class="reference internal" href="#django.dispatch.receiver" title="django.dispatch.receiver"><code>receiver()</code></a> decorator, import the <code>signals</code> submodule inside <a class="reference internal" href="../ref/applications#django.apps.AppConfig.ready" title="django.apps.AppConfig.ready"><code>ready()</code></a>, this will implicitly connect signal handlers:</p> <pre data-language="python">from django.apps import AppConfig
from django.core.signals import request_finished

class MyAppConfig(AppConfig):
    ...

    def ready(self):
        # Implicitly connect a signal handlers decorated with @receiver.
        from . import signals
        # Explicitly connect a signal handler.
        request_finished.connect(signals.my_callback)
</pre> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The <a class="reference internal" href="../ref/applications#django.apps.AppConfig.ready" title="django.apps.AppConfig.ready"><code>ready()</code></a> method may be executed more than once during testing, so you may want to <a class="reference internal" href="#preventing-duplicate-signals"><span class="std std-ref">guard your signals from duplication</span></a>, especially if you’re planning to send them within tests.</p> </div>   <h3 id="connecting-to-specific-signals">Connecting to signals sent by specific senders</h3> <p id="s-connecting-to-signals-sent-by-specific-senders">Some signals get sent many times, but you’ll only be interested in receiving a certain subset of those signals. For example, consider the <a class="reference internal" href="../ref/signals#django.db.models.signals.pre_save" title="django.db.models.signals.pre_save"><code>django.db.models.signals.pre_save</code></a> signal sent before a model gets saved. Most of the time, you don’t need to know when <em>any</em> model gets saved – just when one <em>specific</em> model is saved.</p> <p>In these cases, you can register to receive signals sent only by particular senders. In the case of <a class="reference internal" href="../ref/signals#django.db.models.signals.pre_save" title="django.db.models.signals.pre_save"><code>django.db.models.signals.pre_save</code></a>, the sender will be the model class being saved, so you can indicate that you only want signals sent by some model:</p> <pre data-language="python">from django.db.models.signals import pre_save
from django.dispatch import receiver
from myapp.models import MyModel


@receiver(pre_save, sender=MyModel)
def my_handler(sender, **kwargs):
    ...
</pre> <p>The <code>my_handler</code> function will only be called when an instance of <code>MyModel</code> is saved.</p> <p>Different signals use different objects as their senders; you’ll need to consult the <a class="reference internal" href="../ref/signals"><span class="doc">built-in signal documentation</span></a> for details of each particular signal.</p>   <h3 id="id3">Preventing duplicate signals</h3> <p id="s-preventing-duplicate-signals">In some circumstances, the code connecting receivers to signals may run multiple times. This can cause your receiver function to be registered more than once, and thus called as many times for a signal event. For example, the <a class="reference internal" href="../ref/applications#django.apps.AppConfig.ready" title="django.apps.AppConfig.ready"><code>ready()</code></a> method may be executed more than once during testing. More generally, this occurs everywhere your project imports the module where you define the signals, because signal registration runs as many times as it is imported.</p> <p>If this behavior is problematic (such as when using signals to send an email whenever a model is saved), pass a unique identifier as the <code>dispatch_uid</code> argument to identify your receiver function. This identifier will usually be a string, although any hashable object will suffice. The end result is that your receiver function will only be bound to the signal once for each unique <code>dispatch_uid</code> value:</p> <pre data-language="python">from django.core.signals import request_finished

request_finished.connect(my_callback, dispatch_uid="my_unique_identifier")
</pre>    <h2 id="defining-and-sending-signals">Defining and sending signals</h2> <p id="s-defining-and-sending-signals">Your applications can take advantage of the signal infrastructure and provide its own signals.</p> <div class="admonition-when-to-use-custom-signals admonition"> <p class="first admonition-title">When to use custom signals</p> <p class="last">Signals are implicit function calls which make debugging harder. If the sender and receiver of your custom signal are both within your project, you’re better off using an explicit function call.</p> </div>  <h3 id="defining-signals">Defining signals</h3> <dl class="class" id="s-defining-signals"> <dt id="django.dispatch.Signal">
<code>class Signal</code> <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/_modules/django/dispatch/dispatcher/#Signal"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p>All signals are <a class="reference internal" href="#django.dispatch.Signal" title="django.dispatch.Signal"><code>django.dispatch.Signal</code></a> instances.</p> <p>For example:</p> <pre data-language="python">import django.dispatch

pizza_done = django.dispatch.Signal()
</pre> <p>This declares a <code>pizza_done</code> signal.</p>   <h3 id="sending-signals">Sending signals</h3> <p id="s-sending-signals">There are two ways to send signals in Django.</p> <dl class="method"> <dt id="django.dispatch.Signal.send">
<code>Signal.send(sender, **kwargs)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/_modules/django/dispatch/dispatcher/#Signal.send"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="django.dispatch.Signal.send_robust">
<code>Signal.send_robust(sender, **kwargs)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/_modules/django/dispatch/dispatcher/#Signal.send_robust"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p>To send a signal, call either <a class="reference internal" href="#django.dispatch.Signal.send" title="django.dispatch.Signal.send"><code>Signal.send()</code></a> (all built-in signals use this) or <a class="reference internal" href="#django.dispatch.Signal.send_robust" title="django.dispatch.Signal.send_robust"><code>Signal.send_robust()</code></a>. You must provide the <code>sender</code> argument (which is a class most of the time) and may provide as many other keyword arguments as you like.</p> <p>For example, here’s how sending our <code>pizza_done</code> signal might look:</p> <pre data-language="python">class PizzaStore:
    ...

    def send_pizza(self, toppings, size):
        pizza_done.send(sender=self.__class__, toppings=toppings, size=size)
        ...
</pre> <p>Both <code>send()</code> and <code>send_robust()</code> return a list of tuple pairs <code>[(receiver, response), ... ]</code>, representing the list of called receiver functions and their response values.</p> <p><code>send()</code> differs from <code>send_robust()</code> in how exceptions raised by receiver functions are handled. <code>send()</code> does <em>not</em> catch any exceptions raised by receivers; it simply allows errors to propagate. Thus not all receivers may be notified of a signal in the face of an error.</p> <p><code>send_robust()</code> catches all errors derived from Python’s <code>Exception</code> class, and ensures all receivers are notified of the signal. If an error occurs, the error instance is returned in the tuple pair for the receiver that raised the error.</p> <p>The tracebacks are present on the <code>__traceback__</code> attribute of the errors returned when calling <code>send_robust()</code>.</p>    <h2 id="disconnecting-signals">Disconnecting signals</h2> <dl class="method" id="s-disconnecting-signals"> <dt id="django.dispatch.Signal.disconnect">
<code>Signal.disconnect(receiver=None, sender=None, dispatch_uid=None)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/_modules/django/dispatch/dispatcher/#Signal.disconnect"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p>To disconnect a receiver from a signal, call <a class="reference internal" href="#django.dispatch.Signal.disconnect" title="django.dispatch.Signal.disconnect"><code>Signal.disconnect()</code></a>. The arguments are as described in <a class="reference internal" href="#django.dispatch.Signal.connect" title="django.dispatch.Signal.connect"><code>Signal.connect()</code></a>. The method returns <code>True</code> if a receiver was disconnected and <code>False</code> if not. When <code>sender</code> is passed as a lazy reference to <code>&lt;app label&gt;.&lt;model&gt;</code>, this method always returns <code>None</code>.</p> <p>The <code>receiver</code> argument indicates the registered receiver to disconnect. It may be <code>None</code> if <code>dispatch_uid</code> is used to identify the receiver.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/4.0/topics/signals/" class="_attribution-link">https://docs.djangoproject.com/en/4.0/topics/signals/</a>
  </p>
</div>
