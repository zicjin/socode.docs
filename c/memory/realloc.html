   <h1 id="firstHeading" class="firstHeading">realloc</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code>&lt;stdlib.h&gt;</code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="c">void *realloc( void *ptr, size_t new_size );</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>Reallocates the given area of memory. It must be previously allocated by <code><a href="malloc" title="c/memory/malloc">malloc()</a></code>, <code><a href="calloc" title="c/memory/calloc">calloc()</a></code> or <code>realloc()</code> and not yet freed with a call to <code><a href="free" title="c/memory/free">free</a></code> or <code>realloc</code>. Otherwise, the results are undefined.</p>
<p>The reallocation is done by either:</p>
<div class="t-li1">
<span class="t-li">a)</span> expanding or contracting the existing area pointed to by <code>ptr</code>, if possible. The contents of the area remain unchanged up to the lesser of the new and old sizes. If the area is expanded, the contents of the new part of the array are undefined. </div> <div class="t-li1">
<span class="t-li">b)</span> allocating a new memory block of size <code>new_size</code> bytes, copying memory area with size equal the lesser of the new and the old sizes, and freeing the old block.</div> <p>If there is not enough memory, the old memory block is not freed and null pointer is returned.</p>
<p>If <code>ptr</code> is <code><a href="../types/null" title="c/types/NULL">NULL</a></code>, the behavior is the same as calling <code><a href="malloc" title="c/memory/malloc">malloc</a></code>(<code>new_size</code>).</p>
<p>If <code>new_size</code> is zero, the behavior is implementation defined (null pointer may be returned (in which case the old memory block may or may not be freed), or some non-null pointer may be returned that may not be used to access storage).</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-c11">
<td> <p><code>realloc</code> is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.</p>
<p>A previous call to <code><a href="free" title="c/memory/free">free</a></code> or <code>realloc</code> that deallocates a region of memory <i>synchronizes-with</i> a call to any allocation function, including <code>realloc</code> that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by <code>realloc</code>. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</p>
</td> <td><span class="t-mark-rev t-since-c11">(since C11)</span></td>
</tr> </table> <h3 id="Parameters">Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> ptr </td> <td> - </td> <td> pointer to the memory area to be reallocated </td>
</tr> <tr class="t-par"> <td> new_size </td> <td> - </td> <td> new size of the array in bytes </td>
</tr>
</table> <h3 id="Return_value">Return value</h3> <p>On success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with <code><a href="free" title="c/memory/free">free()</a></code> or <code>realloc()</code>. The original pointer <code>ptr</code> is invalidated and any access to it is undefined behavior (even if reallocation was in-place).</p>
<p>On failure, returns a null pointer. The original pointer <code>ptr</code> remains valid and may need to be deallocated with <code><a href="free" title="c/memory/free">free()</a></code> or <code>realloc()</code>.</p>
<h3 id="Notes">Notes</h3> <p>Support for zero size is deprecated as of C11 DR 400.</p>
<p>Originally (in C89), support for zero size was added to accommodate code such as.</p>
<div class="c source-c"><pre data-language="c">OBJ *p = calloc(0, sizeof(OBJ)); // "zero-length" placeholder
...
while(1) { 
    p = realloc(p, c * sizeof(OBJ)); // reallocations until size settles
    ... // code that may change c or break out of loop
}</pre></div> <h3 id="Example">Example</h3> <div class="t-example"> <div class="c source-c"><pre data-language="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 
int main(void)
{
    int *pa = malloc(10 * sizeof *pa); // allocate an array of 10 int
    if(pa) {
        printf("%zu bytes allocated. Storing ints: ", 10*sizeof(int));
        for(int n = 0; n &lt; 10; ++n)
            printf("%d ", pa[n] = n);
    }
 
    int *pb = realloc(pa, 1000000 * sizeof *pb); // reallocate array to a larger size
    if(pb) {
        printf("\n%zu bytes allocated, first 10 ints are: ", 1000000*sizeof(int));
        for(int n = 0; n &lt; 10; ++n)
            printf("%d ", pb[n]); // show the array
        free(pb);
    } else { // if realloc failed, the original pointer needs to be freed
        free(pa);
    }
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">40 bytes allocated. Storing ints: 0 1 2 3 4 5 6 7 8 9
4000000 bytes allocated, first 10 ints are: 0 1 2 3 4 5 6 7 8 9</pre></div> </div> <h3 id="References">References</h3>  <ul>
<li> C11 standard (ISO/IEC 9899:2011): </li>
<ul><li> 7.22.3.5 The realloc function (p: 349) </li></ul>
<li> C99 standard (ISO/IEC 9899:1999): </li>
<ul><li> 7.20.3.4 The realloc function (p: 314) </li></ul>
<li> C89/C90 standard (ISO/IEC 9899:1990): </li>
<ul><li> 4.10.3.4 The realloc function </li></ul>
</ul>         <h3 id="See_also">See also</h3>            <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/c/memory/realloc" class="_attribution-link">http://en.cppreference.com/w/c/memory/realloc</a>
  </p>
</div>
