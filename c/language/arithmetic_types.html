   <h1 id="firstHeading" class="firstHeading">Arithmetic types</h1>            <p><small>(See also <a href="compatible_type" title="c/language/type">type</a> for type system overview and <a href="../types" title="c/types"> the list of type-related utilities</a> that are provided by the C library)</small>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-c99">
<td> <h3 id="Boolean_type"> Boolean type</h3> <ul><li> <code>_Bool</code> (also accessible as the macro <a href="../types/boolean" title="c/types/boolean">bool</a>) - type, capable of holding one of the two values: 1 and 0 (also accessible as the macros <a href="../types/boolean" title="c/types/boolean">true</a> and <a href="../types/boolean" title="c/types/boolean">false</a>). </li></ul> <p>Note that <a href="conversion" title="c/language/conversion">conversion</a> to _Bool does not work the same as conversion to other integer types: <code>(bool)0.5</code> evaluates to <code>1</code>, whereas <code>(int)0.5</code> evaluates to <code>​0​</code>.</p>
</td> <td><span class="t-mark-rev t-since-c99">(since C99)</span></td>
</tr> </table> <h3 id="Character_types">Character types</h3> <ul>
<li>
<code>signed char</code> - type for signed character representation. </li>
<li>
<code>unsigned char</code> - type for unsigned character representation. Also used to inspect <a href="object" title="c/language/object">object representations</a> (raw memory). </li>
<li>
<code>char</code> - type for character representation. Equivalent to either <code>signed char</code> or <code>unsigned char</code> (which one is implementation-defined and may be controlled by a compiler commandline switch), but <code>char</code> is a distinct type, different from both <code>signed char</code> both <code>unsigned char</code> </li>
</ul> <p>Note that the standard library also defines <a href="typedef" title="c/language/typedef">typedef</a> names <a href="../string/wide" title="c/string/wide">wchar_t</a> <span class="t-rev-inl t-since-c11"><span>, <a href="../string/multibyte" title="c/string/multibyte">char16_t</a>, and <a href="../string/multibyte" title="c/string/multibyte">char32_t</a></span> <span><span class="t-mark-rev t-since-c11">(since C11)</span></span></span> to represent wide characters.</p>
<h3 id="Integer_types">Integer types</h3> <ul>
<li>
<code>short int</code> (also accessible as <code>short</code>, may use the keyword <code>signed</code>) </li>
<li>
<code>unsigned short int</code> (also accessible as <code>unsigned short</code>) </li>
<li>
<code>int</code> (also accessible as <code>signed int</code>) </li>
<li>
<code>unsigned int</code> (also accessible as <code>unsigned</code>), the unsigned counterpart of <code>int</code>, implementing modulo arithmetic. Suitable for bit manipulations. </li>
<li>
<code>long int</code> (also accessible as <code>long</code>) </li>
<li>
<code>unsigned long int</code> (also accessible as <code>unsigned long</code>) </li>
</ul>  This is the most optimal integer type for the platform, and is guaranteed to be at least 16 bits. Most current systems use 32 bits (see Data models below).    <table class="t-rev-begin"> <tr class="t-rev t-since-c99">
<td> <ul>
<li>
<code>long long int</code> (also accessible as <code>long long</code>) </li>
<li>
<code>unsigned long long int</code> (also accessible as <code>unsigned long long</code>) </li>
</ul> </td> <td><span class="t-mark-rev t-since-c99">(since C99)</span></td>
</tr> </table> <p>Note: as with all type specifiers, any order is permitted: <code>unsigned long long int</code> and <code>long int unsigned long</code> name the same type.</p>
<p>The following table summarizes all available integer types and their properties:</p>
<table class="wikitable"> <tr> <th rowspan="2"> Type specifier </th> <th rowspan="2"> Equivalent type </th> <th colspan="5"> Width in bits by data model </th>
</tr> <tr> <th> C standard </th> <th> LP32 </th> <th> ILP32 </th> <th> LLP64 </th> <th> LP64 </th>
</tr> <tr> <td> <code>short</code> </td> <td rowspan="4"> <code>short int</code> </td> <td rowspan="6"> at least<br> <b>16</b> </td> <td rowspan="6"> <b>16</b> </td> <td rowspan="6"> <b>16</b> </td> <td rowspan="6"> <b>16</b> </td> <td rowspan="6"> <b>16</b> </td>
</tr> <tr> <td> <code>short int</code> </td>
</tr> <tr> <td> <code>signed short</code> </td>
</tr> <tr> <td> <code>signed short int</code> </td>
</tr> <tr> <td> <code>unsigned short</code> </td> <td rowspan="2"> <code>unsigned short int</code> </td>
</tr> <tr> <td> <code>unsigned short int</code> </td>
</tr> <tr> <td> <code>int</code> </td> <td rowspan="3"> <code>int</code> </td> <td rowspan="5"> at least<br> <b>16</b> </td> <td rowspan="5"> <b>16</b> </td> <td rowspan="5"> <b>32</b> </td> <td rowspan="5"> <b>32</b> </td> <td rowspan="5"> <b>32</b> </td>
</tr> <tr> <td> <code>signed</code> </td>
</tr> <tr> <td> <code>signed int</code> </td>
</tr> <tr> <td> <code>unsigned</code> </td> <td rowspan="2"> <code>unsigned int</code> </td>
</tr> <tr> <td> <code>unsigned int</code> </td>
</tr> <tr> <td> <code>long</code> </td> <td rowspan="4"> <code>long int</code> </td> <td rowspan="6"> at least<br> <b>32</b> </td> <td rowspan="6"> <b>32</b> </td> <td rowspan="6"> <b>32</b> </td> <td rowspan="6"> <b>32</b> </td> <td rowspan="6"> <b>64</b> </td>
</tr> <tr> <td> <code>long int</code> </td>
</tr> <tr> <td> <code>signed long</code> </td>
</tr> <tr> <td> <code>signed long int</code> </td>
</tr> <tr> <td> <code>unsigned long</code> </td> <td rowspan="2"> <code>unsigned long int</code> </td>
</tr> <tr> <td> <code>unsigned long int</code> </td>
</tr> <tr> <td> <code>long long</code> </td> <td rowspan="4"> <code>long long int</code> <br> <span class="t-mark-rev t-since-c99">(C99)</span> </td> <td rowspan="6"> at least<br> <b>64</b> </td> <td rowspan="6"> <b>64</b> </td> <td rowspan="6"> <b>64</b> </td> <td rowspan="6"> <b>64</b> </td> <td rowspan="6"> <b>64</b> </td>
</tr> <tr> <td> <code>long long int</code> </td>
</tr> <tr> <td> <code>signed long long</code> </td>
</tr> <tr> <td> <code>signed long long int</code> </td>
</tr> <tr> <td> <code>unsigned long long</code> </td> <td rowspan="2"> <code>unsigned long long int</code> <br> <span class="t-mark-rev t-since-c99">(C99)</span> </td>
</tr> <tr> <td> <code>unsigned long long int</code> </td>
</tr>
</table> <p>Besides the minimal bit counts, the C Standard guarantees that  <code>1 == sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)</code>.</p>
<p>Note: this allows the extreme case in which <a href="https://en.wikipedia.org/wiki/Byte" class="extiw" title="enwiki:Byte">bytes</a> are sized 64 bits, all types (including <code>char</code>) are 64 bits wide, and <code>sizeof</code> returns 1 for every type.</p>
<p>Note: integer arithmetic is defined differently for the signed and unsigned integer types. See <a href="operator_arithmetic" title="c/language/operator arithmetic">arithmetic operators</a>, in particular <a href="operator_arithmetic#Overflows" title="c/language/operator arithmetic">integer overflows</a>.</p>
<h4 id="Data_models">Data models</h4> <p>The choices made by each implementation about the sizes of the fundamental types are collectively known as <i>data model</i>. Four data models found wide acceptance:</p>
<p>32 bit systems:</p>
<ul>
<li>
<b>LP32</b> or <b>2/4/4</b> (int is 16-bit, long and pointer are 32-bit) </li>
<ul><li> Win16 API </li></ul>
<li>
<b>ILP32</b> or <b>4/4/4</b> (int, long, and pointer are 32-bit); </li>
<ul>
<li> Win32 API </li>
<li> Unix and Unix-like systems (Linux, Mac OS X) </li>
</ul>
</ul>     <p>64 bit systems:</p>
<ul>
<li> <b>LLP64</b> or <b>4/4/8</b> (int and long are 32-bit, pointer is 64-bit) </li>
<ul><li> Win64 API </li></ul>
<li> <b>LP64</b> or <b>4/8/8</b> (int is 32-bit, long and pointer are 64-bit) </li>
<ul><li> Unix and Unix-like systems (Linux, Mac OS X) </li></ul>
</ul>     <p>Other models are very rare. For example, <b>ILP64</b> (<b>8/8/8</b>: int, long, and pointer are 64-bit) only appeared in some early 64-bit Unix systems (e.g. Unicos on Cray).</p>
<p>Note that exact-width integer types are available in <a href="../types/integer" title="c/types/integer">&lt;stdint.h&gt;</a> since C99.</p>
<h3 id="Real_floating_types">Real floating types</h3> <p>C has three types for representing real floating-point values:</p>
<ul>
<li>
<code>float</code> - single precision floating point type. Matches IEEE-754 32 bit floating point type if supported. </li>
<li>
<code>double</code> - double precision floating point type. Matches IEEE-754 64 bit floating point type if supported </li>
<li>
<code>long double</code> - extended precision floating point type. Matches IEEE-754 extended floating-point type if supported, otherwise matches some non-standard extended floating-point type as long as its precision is better than <code>double</code> and range is at least as good as <code>double</code>, otherwise matches the type <code>double</code>. Some x86 and x86_64 implementations use the 80-bit x87 floating point type. </li>
</ul> <p>Floating-point types may support special values:</p>
<ul>
<li> <i>infinity</i> (positive and negative), see <a href="../numeric/math/infinity" title="c/numeric/math/INFINITY"><code>INFINITY</code></a> </li>
<li> the <i>negative zero</i>, <code>-0.0</code>. It compares equal to the positive zero, but is meaningful in some arithmetic operations, e.g. <code>1.0/0.0 == INFINITY</code>, but <code>1.0/-0.0 == -INFINITY</code>) </li>
<li> <i>not-a-number</i> (NaN), which does not compare equal with anything (including itself). Multiple bit patterns represent NaNs, see <code><a href="../numeric/math/nan.2" title="c/numeric/math/nan">nan</a></code>, <a href="../numeric/math/nan" title="c/numeric/math/NAN"><code>NAN</code></a>. Note that C takes no special notice of signalling NaNs (specified by IEEE-754), and treates all NaNs as quiet. </li>
</ul> <p>Real floating-point numbers may be used with <a href="operator_arithmetic" title="c/language/operator arithmetic">arithmetic operators</a> + - / * and various mathematical functions from <a href="../numeric/math" title="c/numeric/math">math.h</a>. Both built-in operators and library functions may raise floating-point exceptions and set <code><a href="../error/errno" title="c/error/errno">errno</a></code> as described in <a href="../numeric/math/math_errhandling" title="c/numeric/math/math errhandling"><code>math_errhandling</code></a>.</p>
<p>Floating-point expressions may have greater range and precision than indicated by their types, see <code><a href="../types/limits/flt_eval_method" title="c/types/limits/FLT EVAL METHOD">FLT_EVAL_METHOD</a></code>. <a href="operator_assignment" title="c/language/operator assignment">Assignment</a>, <a href="return" title="c/language/return">return</a>, and <a href="cast" title="c/language/cast">cast</a> force the range and precision to the one associated with the declared type.</p>
<p>Floating-point expressions may also be <i>contracted</i>, that is, calculated as if all intermediate values have infinite range and precision, see <a href="../preprocessor/impl#Standard_pragmas" title="c/preprocessor/impl">#pragma STDC FP_CONTRACT</a>.</p>
<p>Some operations on floating-point numbers are affected by and modify the state of <a href="../numeric/fenv" title="c/numeric/fenv">the floating-point environment</a> (most notably, the rounding direction).</p>
<p><a href="conversion" title="c/language/conversion">Implicit conversions</a> are defined between real floating types and integer, complex, and imaginary types.</p>
<p>See <a href="../types/limits#Limits_of_floating_point_types" title="c/types/limits">Limits of floating point types</a> and <a href="../numeric/math" title="c/numeric/math">the math.h library</a> for additional details, limits, and properties of the floating-point types.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-c99">
<td> <h3 id="Complex_floating_types"> Complex floating types</h3> <p>Complex floating types model the mathematical <a href="https://en.wikipedia.org/wiki/Complex_number" class="extiw" title="enwiki:Complex number">complex numbers</a>, that is the numbers that can be written as a sum of a real number and a real number multiplied by the imaginary unit: a + bi.</p>
<p>The three complex types are.</p>
<ul>
<li> <code>float _Complex</code> (also available as <code><span class="kw4">float</span> <a href="../numeric/complex/complex"><span class="kw743">complex</span></a></code> if <a href="../numeric/complex" title="c/numeric/complex">&lt;complex.h&gt;</a> is included) </li>
<li> <code>double _Complex</code> (also available as <code><span class="kw4">double</span> <a href="../numeric/complex/complex"><span class="kw743">complex</span></a></code> if <a href="../numeric/complex" title="c/numeric/complex">&lt;complex.h&gt;</a> is included) </li>
<li> <code>long double _Complex</code> (also available as <code><span class="kw4">long</span> <span class="kw4">double</span> <a href="../numeric/complex/complex"><span class="kw743">complex</span></a></code> if <a href="../numeric/complex" title="c/numeric/complex">&lt;complex.h&gt;</a> is included) </li>
</ul> <p>Note: as with all type specifiers, any order is permitted: <code><span class="kw4">long</span> <span class="kw4">double</span> <a href="../numeric/complex/complex"><span class="kw743">complex</span></a></code>, <code><a href="../numeric/complex/complex"><span class="kw743">complex</span></a> <span class="kw4">long</span> <span class="kw4">double</span></code>, and even <code><span class="kw4">double</span> <a href="../numeric/complex/complex"><span class="kw743">complex</span></a> <span class="kw4">long</span></code> name the same type.</p>
<div class="c source-c"><pre data-language="c">#include &lt;complex.h&gt;
#include &lt;stdio.h&gt;
int main(void)
{
    double complex z = 1 + 2*I;
    z = 1/z;
    printf("1/(1.0+2.0i) = %.1f%+.1fi\n", creal(z), cimag(z));
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">1/(1.0+2.0i) = 0.2-0.4i</pre></div>  <table class="t-rev-begin"> <tr class="t-rev t-since-c11">
<td> If the macro constant <code>__STDC_NO_COMPLEX__</code><span class="t-mark-rev t-since-c11">(C11)</span> is defined by the implementation, the complex types (as well as the library header <code>&lt;complex.h&gt;</code>) are not provided.</td> <td><span class="t-mark-rev t-since-c11">(since C11)</span></td>
</tr> </table> <p>Each complex type has the same <a href="object" title="c/language/object">object representation</a> and <a href="object" title="c/language/object">alignment requirements</a> as an <a href="array" title="c/language/array">array</a> of two elements of the corresponding real type (<code>float</code> for <code><span class="kw4">float</span> <a href="../numeric/complex/complex"><span class="kw743">complex</span></a></code>, <code>double</code> for <code><span class="kw4">double</span> <a href="../numeric/complex/complex"><span class="kw743">complex</span></a></code>, <code>long double</code> for <code><span class="kw4">long</span> <span class="kw4">double</span> <a href="../numeric/complex/complex"><span class="kw743">complex</span></a></code>). The first element of the array holds the real part, and the second element of the array holds the imaginary component.</p>
<div class="c source-c"><pre data-language="c">float a[4] = {1, 2, 3, 4};
float complex z1, z2;
memcpy(&amp;z1, a, sizeof z1); // z1 becomes 1.0 + 2.0i
memcpy(&amp;z2, a+2, sizeof z2); // z2 becomes 3.0 + 4.0i</pre></div> <p>Complex numbers may be used with <a href="operator_arithmetic" title="c/language/operator arithmetic">arithmetic operators</a> + - * and /, possibly mixed with imaginary and real numbers. There are many mathematical functions defined for complex numbers in <a href="../numeric/complex" title="c/numeric/complex">complex.h</a>. Both built-in operators and library functions may raise floating-point exceptions and set <code><a href="../error/errno" title="c/error/errno">errno</a></code> as described in <a href="../numeric/math/math_errhandling" title="c/numeric/math/math errhandling"><code>math_errhandling</code></a>.</p>
<p>Increment and decrement are not defined for complex types.</p>
<p>Relational operators are not defined for complex types (there is no notion of "less than")  <a href="conversion" title="c/language/conversion">Implicit conversions</a> are defined between complex types and other arithmetic types.</p>
<p>In order to support the one-infinity model of complex number arithmetic, C regards any complex value with at least one infinite part as an infinity even if its other part is a NaN, guarantees that all operators and functions honor basic properties of inifinities and provides <code><a href="../numeric/complex/cproj" title="c/numeric/complex/cproj">cproj</a></code> to map all infinities to the canonical one (see <a href="operator_arithmetic" title="c/language/operator arithmetic">arithmetic operators</a> for the exact rules).</p>
<div class="c source-c"><pre data-language="c">#include &lt;stdio.h&gt;
#include &lt;complex.h&gt;
#include &lt;math.h&gt;
int main(void)
{
   double complex z = (1 + 0*I) * (INFINITY + I*INFINITY);
// textbook formula would give
// (1+i0)(∞+i∞) ⇒ (1×∞ – 0×∞) + i(0×∞+1×∞) ⇒ NaN + I*NaN
// but C gives a complex infinity
   printf("%f + i*%f\n", creal(z), cimag(z));
 
// textbook formula would give
// cexp(∞+iNaN) ⇒ exp(∞)×(cis(NaN)) ⇒ NaN + I*NaN
// but C gives  ±∞+i*nan
   double complex y = cexp(INFINITY + I*NAN);
   printf("%f + i*%f\n", creal(y), cimag(y));
 
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">inf + i*inf 
inf + i*nan</pre></div>  <p>C also treats multiple infinities so as to preserve directional information where possible, despite the inherent limitations of the Cartesian representation:</p>
<p>multiplying the imaginary unit by real infinity gives the correctly-signed imaginary infinity: i × ∞ = i∞. Also, i × (∞ – i∞) = ∞ + i∞ indicates the reasonable quadrant.</p>
<h3 id="Imaginary_floating_types"> Imaginary floating types</h3> <p>Imaginary floating types model the mathematical <a href="https://en.wikipedia.org/wiki/Imaginary_number" class="extiw" title="enwiki:Imaginary number">imaginary numbers</a>, that is numbers that can be written as a real number multiplied by the imaginary unit: bi The three imaginary types are.</p>
<ul>
<li> <code>float _Imaginary</code> (also available as <code><span class="kw4">float</span> <a href="../numeric/complex/imaginary"><span class="kw745">imaginary</span></a></code> if <a href="../numeric/complex" title="c/numeric/complex">&lt;complex.h&gt;</a> is included) </li>
<li> <code>double _Imaginary</code> (also available as <code><span class="kw4">double</span> <a href="../numeric/complex/imaginary"><span class="kw745">imaginary</span></a></code> if <a href="../numeric/complex" title="c/numeric/complex">&lt;complex.h&gt;</a> is included) </li>
<li> <code>long double _Imaginary</code> (also available as <code><span class="kw4">long</span> <span class="kw4">double</span> <a href="../numeric/complex/imaginary"><span class="kw745">imaginary</span></a></code> if <a href="../numeric/complex" title="c/numeric/complex">&lt;complex.h&gt;</a> is included) </li>
</ul> <p>Note: as with all type specifiers, any order is permitted: <code><span class="kw4">long</span> <span class="kw4">double</span> <a href="../numeric/complex/imaginary"><span class="kw745">imaginary</span></a></code>, <code><a href="../numeric/complex/imaginary"><span class="kw745">imaginary</span></a> <span class="kw4">long</span> <span class="kw4">double</span></code>, and even <code><span class="kw4">double</span> <a href="../numeric/complex/imaginary"><span class="kw745">imaginary</span></a> <span class="kw4">long</span></code> name the same type.</p>
<div class="c source-c"><pre data-language="c">#include &lt;complex.h&gt;
#include &lt;stdio.h&gt;
int main(void)
{
    double imaginary z = 3*I;
    z = 1/z;
    printf("1/(3.0i) = %+.1fi\n", cimag(z));
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">1/(3.0i) = -0.3i</pre></div>  <table class="t-rev-begin"> <tr class="t-rev t-since-c99 t-until-c11">
<td> <p>A compiler that defines <code>__STDC_IEC_559_COMPLEX__</code> is recommended, but not required to support imaginary numbers. POSIX recommends checking if the macro <code><a href="../numeric/complex/imaginary_i" title="c/numeric/complex/Imaginary I">_Imaginary_I</a></code> is defined to identify imaginary number support.</p>
</td> <td>
<span class="t-mark-rev t-since-c99">(since C99)</span><br><span class="t-mark-rev t-until-c11">(until C11)</span>
</td>
</tr> <tr class="t-rev t-since-c11">
<td> <p>Imaginary numbers are supported if <code>__STDC_IEC_559_COMPLEX__</code> is defined.</p>
</td> <td><span class="t-mark-rev t-since-c11">(since C11)</span></td>
</tr> </table> <p>Each of the three imaginary types has the same <a href="object" title="c/language/object">object representation</a> and <a href="object" title="c/language/object">alignment requirement</a> as its <i>corresponding real type</i> (<code>float</code> for <code><span class="kw4">float</span> <a href="../numeric/complex/imaginary"><span class="kw745">imaginary</span></a></code>, <code>double</code> for <code><span class="kw4">double</span> <a href="../numeric/complex/imaginary"><span class="kw745">imaginary</span></a></code>, <code>long double</code> for <code><span class="kw4">long</span> <span class="kw4">double</span> <a href="../numeric/complex/imaginary"><span class="kw745">imaginary</span></a></code>).</p>
<p>Note: despite that, imaginary types are distinct and <a href="compatible_type#Compatible_types" title="c/language/type">not compatible</a> with their corresponding real types, which prohibits aliasing.</p>
<p>Imaginary numbers may be used with <a href="operator_arithmetic" title="c/language/operator arithmetic">arithmetic operators</a> + - * and /, possibly mixed with complex and real numbers. There are many mathematical functions defined for imaginary numbers in <a href="../numeric/complex" title="c/numeric/complex">complex.h</a>. Both built-in operators and library functions may raise floating-point exceptions and set <code><a href="../error/errno" title="c/error/errno">errno</a></code> as described in <a href="../numeric/math/math_errhandling" title="c/numeric/math/math errhandling"><code>math_errhandling</code></a>.</p>
<p>Increment and decrement are not defined for imaginary types  <a href="conversion" title="c/language/conversion">Implicit conversions</a> are defined between imaginary types and other arithmetic types.</p>
<p>The imaginary numbers make it possible to express all complex numbers using the natural notation <code>x + I*y</code> (where <code>I</code> is defined as <code><a href="../numeric/complex/imaginary_i" title="c/numeric/complex/Imaginary I">_Imaginary_I</a></code>). Without imaginary types, certain special complex values cannot be created naturally. For example, if <code>I</code> is defined as <code><a href="../numeric/complex/complex_i" title="c/numeric/complex/Complex I">_Complex_I</a></code>, then writing <code>0.0 + I*INFINITY</code> gives NaN as the real part, and <code><a href="../numeric/complex/cmplx"><span class="kw748">CMPLX</span></a><span class="br0">(</span><span class="nu16">0.0</span>, INFINITY<span class="br0">)</span></code> must be used instead. Same goes for the numbers with the negative zero imaginary component, which are meaningful when working with the library functions with branch cuts, such as <code><a href="../numeric/complex/csqrt" title="c/numeric/complex/csqrt">csqrt</a></code>: <code>1.0 - 0.0*I</code> results in the positive zero imaginary component if <code>I</code> is defined as <code><a href="../numeric/complex/complex_i" title="c/numeric/complex/Complex I">_Complex_I</a></code> and the negative zero imaginary part requires the use of <code><a href="../numeric/complex/cmplx" title="c/numeric/complex/CMPLX">CMPLX</a></code> or <code><a href="../numeric/complex/conj" title="c/numeric/complex/conj">conj</a></code>.</p>
<p>Imaginary types also simplify implementations; multiplication of an imaginary by a complex can be implemented straightforwardly with two multiplications if the imaginary types are supported, instead of four multiplications and two additions.</p>
</td> <td><span class="t-mark-rev t-since-c99">(since C99)</span></td>
</tr> </table> <h3 id="Keywords">Keywords</h3> <p><a href="../keyword/char" title="c/keyword/char"><code>char</code></a>, <a href="../keyword/int" title="c/keyword/int"><code>int</code></a>, <a href="../keyword/short" title="c/keyword/short"><code>short</code></a>, <a href="../keyword/long" title="c/keyword/long"><code>long</code></a>, <a href="../keyword/signed" title="c/keyword/signed"><code>signed</code></a>, <a href="../keyword/unsigned" title="c/keyword/unsigned"><code>unsigned</code></a>, <a href="../keyword/float" title="c/keyword/float"><code>float</code></a>, <a href="../keyword/double" title="c/keyword/double"><code>double</code></a>. <a href="../keyword/_bool" title="c/keyword/ Bool"><code>_Bool</code></a>, <a href="../keyword/_complex" title="c/keyword/ Complex"><code>_Complex</code></a>, <a href="../keyword/_imaginary" title="c/keyword/ Imaginary"><code>_Imaginary</code></a>.</p>
<h3 id="Range_of_values">Range of values</h3> <p>The following table provides a reference for the limits of common numeric representations. As the C Standard allows any signed integer representation, the table gives both the minimum guaranteed requirements (which correspond to the limits of <a href="https://en.wikipedia.org/wiki/One%27s_complement" class="extiw" title="enwiki:One's complement">one's complement</a> or <a href="https://en.wikipedia.org/wiki/Signed_number_representations#Sign-and-magnitude_method" class="extiw" title="enwiki:Signed number representations">sign-and-magnitude</a>) and the limits of the most commonly used implementation, <a href="https://en.wikipedia.org/wiki/Two%27s_complement" class="extiw" title="enwiki:Two's complement">two's complement</a>. All popular data models (including all of ILP32, LP32, LP64, LLP64) use two's complement representation, though.</p>
<table class="wikitable"> <tr> <th rowspan="2"> Type </th> <th rowspan="2"> Size in bits </th> <th rowspan="2"> Format </th> <th colspan="2"> Value range </th>
</tr> <tr> <th> Approximate </th> <th> Exact </th>
</tr> <tr> <th rowspan="3"> character </th> <td rowspan="3"> 8 </td> <td> signed (one's complement) </td> <td colspan="2"> <b>-127</b> to <b>127</b> </td>
</tr> <tr> <td> signed (two's complement) </td> <td colspan="2"> <b>-128</b> to <b>127</b> </td>
</tr> <tr> <td> unsigned </td> <td colspan="2"> <b>0</b> to <b>255</b> </td>
</tr> <tr> <th rowspan="9"> integral </th> <td rowspan="3"> 16 </td> <td> signed (one's complement) </td> <td rowspan="2"> <b>± 3.27 · 10<sup>4</sup></b> </td> <td> <b>-32767</b> to <b>32767</b> </td>
</tr> <tr> <td> signed (two's complement) </td> <td> <b>-32768</b> to <b>32767</b> </td>
</tr> <tr> <td> unsigned </td> <td> <b>0</b> to <b>6.55 · 10<sup>4</sup></b> </td> <td> <b>0</b> to <b>65535</b> </td>
</tr> <tr> <td rowspan="3"> 32 </td> <td> signed (one's complement) </td> <td rowspan="2"> <b>± 2.14 · 10<sup>9</sup></b> </td> <td> <b>-2,147,483,647</b> to <b>2,147,483,647</b> </td>
</tr> <tr> <td> signed (two's complement) </td> <td> <b>-2,147,483,648</b> to <b>2,147,483,647</b> </td>
</tr> <tr> <td> unsigned </td> <td> <b>0</b> to <b>4.29 · 10<sup>9</sup></b> </td> <td> <b>0</b> to <b>4,294,967,295</b> </td>
</tr> <tr> <td rowspan="3"> 64 </td> <td> signed (one's complement) </td> <td rowspan="2"> <b>± 9.22 · 10<sup>18</sup></b> </td> <td> <b>-9,223,372,036,854,775,807</b> to <b>9,223,372,036,854,775,807</b> </td>
</tr> <tr> <td> signed (two's complement) </td> <td> <b>-9,223,372,036,854,775,808</b> to <b>9,223,372,036,854,775,807</b> </td>
</tr> <tr> <td> unsigned </td> <td> <b>0</b> to <b>1.84 · 10<sup>19</sup></b> </td> <td> <b>0</b> to <b>18,446,744,073,709,551,615</b> </td>
</tr> <tr> <th rowspan="2"> floating<br> point </th> <td> 32 </td> <td> <a href="https://en.wikipedia.org/wiki/IEEE-754" class="extiw" title="enwiki:IEEE-754">IEEE-754</a> </td> <td>  <ul>
<li>min subnormal:<br><b>± 1.401,298,4 · 10<sup>-45</sup></b> </li>
<li>min normal:<br><b>± 1.175,494,3 · 10<sup>-38</sup></b> </li>
<li>max:<br><b>± 3.402,823,4 · 10<sup>38</sup></b> </li>
</ul>  </td> <td> <ul>
<li>min subnormal:<br><b>±0x1p-149</b> </li>
<li>min normal:<br><b>±0x1p-126</b> </li>
<li>max:<br><b>±0x1.fffffep+127</b> </li>
</ul>  </td>
</tr> <tr> <td> 64 </td> <td> IEEE-754 </td> <td>  <ul>
<li>min subnormal:<br><b>± 4.940,656,458,412 · 10<sup>-324</sup></b> </li>
<li>min normal:<br><b>± 2.225,073,858,507,201,4 · 10<sup>-308</sup></b> </li>
<li>max:<br><b>± 1.797,693,134,862,315,7 · 10<sup>308</sup></b> </li>
</ul>  </td> <td>  <ul>
<li>min subnormal:<br><b>±0x1p-1074</b> </li>
<li>min normal:<br><b>±0x1p-1022</b> </li>
<li>max:<br><b>±0x1.fffffffffffffp+1023</b> </li>
</ul>  </td>
</tr>
</table> <p>Note: actual (as opposed to guaranteed minimal) ranges are available in the library headers <a href="../types/limits" title="c/types/limits">&lt;limits.h&gt; and &lt;float.h&gt;</a></p>
<h3 id="See_also">See also</h3>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/c/language/arithmetic_types" class="_attribution-link">http://en.cppreference.com/w/c/language/arithmetic_types</a>
  </p>
</div>
