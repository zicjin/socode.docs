<h1 id="class-Symbol" class="class"> class Symbol </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="comparable">Comparable</a></dd>
</dl> <section class="description"> <p><a href="symbol"><code>Symbol</code></a> objects represent names inside the Ruby interpreter. They are generated using the <code>:name</code> and <code>:"string"</code> literals syntax, and by the various <code>to_sym</code> methods. The same <a href="symbol"><code>Symbol</code></a> object will be created for a given name or string for the duration of a program's execution, regardless of the context or meaning of that name. Thus if <code>Fred</code> is a constant in one context, a method in another, and a class in a third, the <a href="symbol"><code>Symbol</code></a> <code>:Fred</code> will be the same object in all three contexts.</p> <pre class="ruby" data-language="ruby">module One
  class Fred
  end
  $f1 = :Fred
end
module Two
  Fred = 1
  $f2 = :Fred
end
def Fred()
end
$f3 = :Fred
$f1.object_id   #=&gt; 2514190
$f2.object_id   #=&gt; 2514190
$f3.object_id   #=&gt; 2514190
</pre> </section> <section id="5Buntitled-5D" class="documentation-section"> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-all_symbols"> <span class="method-callseq"> all_symbols → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="all_symbols-source"> <pre class="c" data-language="c">static VALUE
sym_all_symbols(VALUE _)
{
    return rb_sym_all_symbols();
}</pre> </div> <p>Returns an array of all the symbols currently in Ruby's symbol table.</p> <pre>Symbol.all_symbols.size    #=&gt; 903
Symbol.all_symbols[1,20]   #=&gt; [:floor, :ARGV, :Binding, :symlink,
                                :chown, :EOFError, :$;, :String,
                                :LOCK_SH, :"setuid?", :$&lt;,
                                :default_proc, :compact, :extend,
                                :Tms, :getwd, :$=, :ThreadGroup,
                                :wait2, :$&gt;]</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-json_create"> <span class="method-name">json_create</span><span class="method-args">(o)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="json_create-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/symbol.rb, line 22
def self.json_create(o)
  o['s'].to_sym
end</pre> </div> <p>Deserializes <a href="json"><code>JSON</code></a> string by converting the <code>string</code> value stored in the object to a <a href="symbol"><code>Symbol</code></a></p>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-3C-3D-3E"> <span class="method-callseq"> symbol &lt;=&gt; other_symbol → -1, 0, +1, or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3C-3D-3E-source"> <pre class="c" data-language="c">static VALUE
sym_cmp(VALUE sym, VALUE other)
{
    if (!SYMBOL_P(other)) {
        return Qnil;
    }
    return rb_str_cmp_m(rb_sym2str(sym), rb_sym2str(other));
}</pre> </div> <p>Compares <code>symbol</code> with <code>other_symbol</code> after calling <a href="symbol#method-i-to_s"><code>to_s</code></a> on each of the symbols. Returns -1, 0, +1, or <code>nil</code> depending on whether <code>symbol</code> is less than, equal to, or greater than <code>other_symbol</code>.</p> <p><code>nil</code> is returned if the two values are incomparable.</p> <p>See String#&lt;=&gt; for more information.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3D-3D"> <span class="method-callseq"> sym == obj → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="c" data-language="c">#define sym_equal rb_obj_equal</pre> </div> <p>Equality—If <em>sym</em> and <em>obj</em> are exactly the same symbol, returns <code>true</code>.</p>  </div> <div class="aliases"> Also aliased as: <a href="symbol#method-i-3D-3D-3D">===</a> </div> </div> <div id="method-i-3D-3D-3D" class="method-detail method-alias"> <div class="method-description"> <p>Equality—If <em>sym</em> and <em>obj</em> are exactly the same symbol, returns <code>true</code>.</p> </div> <div class="aliases"> Alias for: <a href="symbol#method-i-3D-3D">==</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3D~"> <span class="method-callseq"> sym =~ obj → integer or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3D~-source"> <pre class="c" data-language="c">static VALUE
sym_match(VALUE sym, VALUE other)
{
    return rb_str_match(rb_sym2str(sym), other);
}</pre> </div> <p>Returns <code>sym.to_s =~ obj</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-5B-5D"> <span class="method-callseq"> sym[idx] → char </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> sym[b, n] → string </span> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="c" data-language="c">static VALUE
sym_aref(int argc, VALUE *argv, VALUE sym)
{
    return rb_str_aref_m(argc, argv, rb_sym2str(sym));
}</pre> </div> <p>Returns <code>sym.to_s[]</code>.</p>  </div> <div class="aliases"> Also aliased as: <a href="symbol#method-i-slice">slice</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-as_json"> <span class="method-name">as_json</span><span class="method-args">(*)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="as_json-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/symbol.rb, line 9
def as_json(*)
  {
    JSON.create_id =&gt; self.class.name,
    's'            =&gt; to_s,
  }
end</pre> </div> <p>Returns a hash, that will be turned into a <a href="json"><code>JSON</code></a> object and represent this object.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-capitalize"> <span class="method-callseq"> capitalize → symbol </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> capitalize([options]) → symbol </span> </div> <div class="method-description">
<div class="method-source-code" id="capitalize-source"> <pre class="c" data-language="c">static VALUE
sym_capitalize(int argc, VALUE *argv, VALUE sym)
{
    return rb_str_intern(rb_str_capitalize(argc, argv, rb_sym2str(sym)));
}</pre> </div> <p>Same as <code>sym.to_s.capitalize.intern</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-casecmp"> <span class="method-callseq"> casecmp(other_symbol) → -1, 0, +1, or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="casecmp-source"> <pre class="c" data-language="c">static VALUE
sym_casecmp(VALUE sym, VALUE other)
{
    if (!SYMBOL_P(other)) {
        return Qnil;
    }
    return str_casecmp(rb_sym2str(sym), rb_sym2str(other));
}</pre> </div> <p>Case-insensitive version of Symbol#&lt;=&gt;. Currently, case-insensitivity only works on characters A-Z/a-z, not all of Unicode. This is different from <a href="symbol#method-i-casecmp-3F"><code>Symbol#casecmp?</code></a>.</p> <pre class="ruby" data-language="ruby">:aBcDeF.casecmp(:abcde)     #=&gt; 1
:aBcDeF.casecmp(:abcdef)    #=&gt; 0
:aBcDeF.casecmp(:abcdefg)   #=&gt; -1
:abcdef.casecmp(:ABCDEF)    #=&gt; 0
</pre> <p><code>nil</code> is returned if the two symbols have incompatible encodings, or if <code>other_symbol</code> is not a symbol.</p> <pre class="ruby" data-language="ruby">:foo.casecmp(2)   #=&gt; nil
"\u{e4 f6 fc}".encode("ISO-8859-1").to_sym.casecmp(:"\u{c4 d6 dc}")   #=&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-casecmp-3F"> <span class="method-callseq"> casecmp?(other_symbol) → true, false, or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="casecmp-3F-source"> <pre class="c" data-language="c">static VALUE
sym_casecmp_p(VALUE sym, VALUE other)
{
    if (!SYMBOL_P(other)) {
        return Qnil;
    }
    return str_casecmp_p(rb_sym2str(sym), rb_sym2str(other));
}</pre> </div> <p>Returns <code>true</code> if <code>sym</code> and <code>other_symbol</code> are equal after Unicode case folding, <code>false</code> if they are not equal.</p> <pre class="ruby" data-language="ruby">:aBcDeF.casecmp?(:abcde)     #=&gt; false
:aBcDeF.casecmp?(:abcdef)    #=&gt; true
:aBcDeF.casecmp?(:abcdefg)   #=&gt; false
:abcdef.casecmp?(:ABCDEF)    #=&gt; true
:"\u{e4 f6 fc}".casecmp?(:"\u{c4 d6 dc}")   #=&gt; true
</pre> <p><code>nil</code> is returned if the two symbols have incompatible encodings, or if <code>other_symbol</code> is not a symbol.</p> <pre class="ruby" data-language="ruby">:foo.casecmp?(2)   #=&gt; nil
"\u{e4 f6 fc}".encode("ISO-8859-1").to_sym.casecmp?(:"\u{c4 d6 dc}")   #=&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-downcase"> <span class="method-callseq"> downcase → symbol </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> downcase([options]) → symbol </span> </div> <div class="method-description">
<div class="method-source-code" id="downcase-source"> <pre class="c" data-language="c">static VALUE
sym_downcase(int argc, VALUE *argv, VALUE sym)
{
    return rb_str_intern(rb_str_downcase(argc, argv, rb_sym2str(sym)));
}</pre> </div> <p>Same as <code>sym.to_s.downcase.intern</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-empty-3F"> <span class="method-callseq"> empty? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="empty-3F-source"> <pre class="c" data-language="c">static VALUE
sym_empty(VALUE sym)
{
    return rb_str_empty(rb_sym2str(sym));
}</pre> </div> <p>Returns whether <em>sym</em> is :“” or not.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-encoding"> <span class="method-callseq"> encoding → encoding </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="encoding-source"> <pre class="c" data-language="c">static VALUE
sym_encoding(VALUE sym)
{
    return rb_obj_encoding(rb_sym2str(sym));
}</pre> </div> <p>Returns the <a href="encoding"><code>Encoding</code></a> object that represents the encoding of <em>sym</em>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-end_with-3F"> <span class="method-callseq"> end_with?([suffixes]+) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="end_with-3F-source"> <pre class="c" data-language="c">static VALUE
sym_end_with(int argc, VALUE *argv, VALUE sym)
{
    return rb_str_end_with(argc, argv, rb_sym2str(sym));
}</pre> </div> <p>Returns true if <code>sym</code> ends with one of the <code>suffixes</code> given.</p> <pre class="ruby" data-language="ruby">:hello.end_with?("ello")               #=&gt; true

# returns true if one of the +suffixes+ matches.
:hello.end_with?("heaven", "ello")     #=&gt; true
:hello.end_with?("heaven", "paradise") #=&gt; false
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-id2name"> <span class="method-callseq"> id2name → string </span> </div> <div class="method-description"> <p>Returns the name or string corresponding to <em>sym</em>.</p> <pre class="ruby" data-language="ruby">:fred.id2name   #=&gt; "fred"
:ginger.to_s    #=&gt; "ginger"
</pre> <p>Note that this string is not frozen (unlike the symbol itself). To get a frozen string, use <a href="symbol#method-i-name"><code>name</code></a>.</p> </div> <div class="aliases"> Alias for: <a href="symbol#method-i-to_s">to_s</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inspect"> <span class="method-callseq"> inspect → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="c" data-language="c">static VALUE
sym_inspect(VALUE sym)
{
    VALUE str = rb_sym2str(sym);
    const char *ptr;
    long len;
    char *dest;

    if (!rb_str_symname_p(str)) {
        str = rb_str_inspect(str);
        len = RSTRING_LEN(str);
        rb_str_resize(str, len + 1);
        dest = RSTRING_PTR(str);
        memmove(dest + 1, dest, len);
    }
    else {
        rb_encoding *enc = STR_ENC_GET(str);
        RSTRING_GETMEM(str, ptr, len);
        str = rb_enc_str_new(0, len + 1, enc);
        dest = RSTRING_PTR(str);
        memcpy(dest + 1, ptr, len);
    }
    dest[0] = ':';
    return str;
}</pre> </div> <p>Returns the representation of <em>sym</em> as a symbol literal.</p> <pre class="ruby" data-language="ruby">:fred.inspect   #=&gt; ":fred"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-intern"> <span class="method-callseq"> intern → sym </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="intern-source"> <pre class="c" data-language="c">static VALUE
sym_to_sym(VALUE sym)
{
    return sym;
}</pre> </div> <p>In general, <code>to_sym</code> returns the <a href="symbol"><code>Symbol</code></a> corresponding to an object. As <em>sym</em> is already a symbol, <code>self</code> is returned in this case.</p>  </div> <div class="aliases"> Also aliased as: <a href="symbol#method-i-to_sym">to_sym</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-length"> <span class="method-callseq"> length → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="length-source"> <pre class="c" data-language="c">static VALUE
sym_length(VALUE sym)
{
    return rb_str_length(rb_sym2str(sym));
}</pre> </div> <p>Same as <code>sym.to_s.length</code>.</p>  </div> <div class="aliases"> Also aliased as: <a href="symbol#method-i-size">size</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-match"> <span class="method-callseq"> match(pattern) → matchdata or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> match(pattern, pos) → matchdata or nil </span> </div> <div class="method-description">
<div class="method-source-code" id="match-source"> <pre class="c" data-language="c">static VALUE
sym_match_m(int argc, VALUE *argv, VALUE sym)
{
    return rb_str_match_m(argc, argv, rb_sym2str(sym));
}</pre> </div> <p>Returns <code>sym.to_s.match</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-match-3F"> <span class="method-callseq"> match?(pattern) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> match?(pattern, pos) → true or false </span> </div> <div class="method-description">
<div class="method-source-code" id="match-3F-source"> <pre class="c" data-language="c">static VALUE
sym_match_m_p(int argc, VALUE *argv, VALUE sym)
{
    return rb_str_match_m_p(argc, argv, sym);
}</pre> </div> <p>Returns <code>sym.to_s.match?</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-name"> <span class="method-callseq"> name → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="name-source"> <pre class="c" data-language="c">VALUE
rb_sym2str(VALUE sym)
{

}</pre> </div> <p>Returns the name or string corresponding to <em>sym</em>. Unlike <a href="symbol#method-i-to_s"><code>to_s</code></a>, the returned string is frozen.</p> <pre class="ruby" data-language="ruby">:fred.name         #=&gt; "fred"
:fred.name.frozen? #=&gt; true
:fred.to_s         #=&gt; "fred"
:fred.to_s.frozen? #=&gt; false
</pre>  </div> </div> <div id="method-i-next" class="method-detail method-alias"> <div class="method-description"> <p>Same as <code>sym.to_s.succ.intern</code>.</p> </div> <div class="aliases"> Alias for: <a href="symbol#method-i-succ">succ</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-size"> <span class="method-callseq"> size → integer </span> </div> <div class="method-description"> <p>Same as <code>sym.to_s.length</code>.</p> </div> <div class="aliases"> Alias for: <a href="symbol#method-i-length">length</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-slice"> <span class="method-callseq"> slice(idx) → char </span> </div> <div class="method-heading"> <span class="method-callseq"> slice(b, n) → string </span> </div> <div class="method-description"> <p>Returns <code>sym.to_s[]</code>.</p> </div> <div class="aliases"> Alias for: <a href="symbol#method-i-5B-5D">[]</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-start_with-3F"> <span class="method-callseq"> start_with?([prefixes]+) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="start_with-3F-source"> <pre class="c" data-language="c">static VALUE
sym_start_with(int argc, VALUE *argv, VALUE sym)
{
    return rb_str_start_with(argc, argv, rb_sym2str(sym));
}</pre> </div> <p>Returns true if <code>sym</code> starts with one of the <code>prefixes</code> given. Each of the <code>prefixes</code> should be a <a href="string"><code>String</code></a> or a <a href="regexp"><code>Regexp</code></a>.</p> <pre class="ruby" data-language="ruby">:hello.start_with?("hell")               #=&gt; true
:hello.start_with?(/H/i)                 #=&gt; true

# returns true if one of the prefixes matches.
:hello.start_with?("heaven", "hell")     #=&gt; true
:hello.start_with?("heaven", "paradise") #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-succ"> <span class="method-callseq"> succ </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="succ-source"> <pre class="c" data-language="c">static VALUE
sym_succ(VALUE sym)
{
    return rb_str_intern(rb_str_succ(rb_sym2str(sym)));
}</pre> </div> <p>Same as <code>sym.to_s.succ.intern</code>.</p>  </div> <div class="aliases"> Also aliased as: <a href="symbol#method-i-next">next</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-swapcase"> <span class="method-callseq"> swapcase → symbol </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> swapcase([options]) → symbol </span> </div> <div class="method-description">
<div class="method-source-code" id="swapcase-source"> <pre class="c" data-language="c">static VALUE
sym_swapcase(int argc, VALUE *argv, VALUE sym)
{
    return rb_str_intern(rb_str_swapcase(argc, argv, rb_sym2str(sym)));
}</pre> </div> <p>Same as <code>sym.to_s.swapcase.intern</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_json"> <span class="method-name">to_json</span><span class="method-args">(*a)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_json-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/symbol.rb, line 17
def to_json(*a)
  as_json.to_json(*a)
end</pre> </div> <p>Stores class name (<a href="symbol"><code>Symbol</code></a>) with <a href="string"><code>String</code></a> representation of <a href="symbol"><code>Symbol</code></a> as a <a href="json"><code>JSON</code></a> string.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_proc"> <span class="method-callseq"> to_proc </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_proc-source"> <pre class="c" data-language="c">VALUE
rb_sym_to_proc(VALUE sym)
{
}</pre> </div> <p>Returns a <em>Proc</em> object which responds to the given method by <em>sym</em>.</p> <pre class="ruby" data-language="ruby">(1..3).collect(&amp;:to_s)  #=&gt; ["1", "2", "3"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_s"> <span class="method-callseq"> to_s → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_s-source"> <pre class="c" data-language="c">VALUE
rb_sym_to_s(VALUE sym)
{
    return str_new_shared(rb_cString, rb_sym2str(sym));
}</pre> </div> <p>Returns the name or string corresponding to <em>sym</em>.</p> <pre class="ruby" data-language="ruby">:fred.id2name   #=&gt; "fred"
:ginger.to_s    #=&gt; "ginger"
</pre> <p>Note that this string is not frozen (unlike the symbol itself). To get a frozen string, use <a href="symbol#method-i-name"><code>name</code></a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="symbol#method-i-id2name">id2name</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-to_sym"> <span class="method-callseq"> to_sym → sym </span> </div> <div class="method-description"> <p>In general, <code>to_sym</code> returns the <a href="symbol"><code>Symbol</code></a> corresponding to an object. As <em>sym</em> is already a symbol, <code>self</code> is returned in this case.</p> </div> <div class="aliases"> Alias for: <a href="symbol#method-i-intern">intern</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-upcase"> <span class="method-callseq"> upcase → symbol </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> upcase([options]) → symbol </span> </div> <div class="method-description">
<div class="method-source-code" id="upcase-source"> <pre class="c" data-language="c">static VALUE
sym_upcase(int argc, VALUE *argv, VALUE sym)
{
    return rb_str_intern(rb_str_upcase(argc, argv, rb_sym2str(sym)));
}</pre> </div> <p>Same as <code>sym.to_s.upcase.intern</code>.</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2020 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
