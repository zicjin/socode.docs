<h1 id="class-Integer" class="class"> class Integer </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="numeric">Numeric</a></dd>
</dl> <section class="description"> <p>Holds <a href="integer"><code>Integer</code></a> values. You cannot add a singleton method to an <a href="integer"><code>Integer</code></a> object, any attempt to do so will raise a <a href="typeerror"><code>TypeError</code></a>.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="GMP_VERSION">GMP_VERSION </dt>
<dd>
<p>The version of loaded GMP.</p> </dd>
<dt id="MILLER_RABIN_BASES">MILLER_RABIN_BASES </dt>

</dl> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-each_prime"> <span class="method-name">each_prime</span><span class="method-args">(ubound) { |prime| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="each_prime-source"> <pre class="ruby" data-language="ruby"># File lib/prime.rb, line 122
def Integer.each_prime(ubound, &amp;block) # :yields: prime
  Prime.each(ubound, &amp;block)
end</pre> </div> <p>Iterates the given block over all prime numbers.</p> <p>See <code>Prime</code>#each for more details.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-from_prime_division"> <span class="method-name">from_prime_division</span><span class="method-args">(pd)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="from_prime_division-source"> <pre class="ruby" data-language="ruby"># File lib/prime.rb, line 22
def Integer.from_prime_division(pd)
  Prime.int_from_prime_division(pd)
end</pre> </div> <p>Re-composes a prime factorization and returns the product.</p> <p>See <a href="prime#method-i-int_from_prime_division"><code>Prime#int_from_prime_division</code></a> for more details.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-sqrt"> <span class="method-callseq"> sqrt(n) → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="sqrt-source"> <pre class="c" data-language="c">static VALUE
rb_int_s_isqrt(VALUE self, VALUE num)
{
    unsigned long n, sq;
    num = rb_to_int(num);
    if (FIXNUM_P(num)) {
        if (FIXNUM_NEGATIVE_P(num)) {
            domain_error("isqrt");
        }
        n = FIX2ULONG(num);
        sq = rb_ulong_isqrt(n);
        return LONG2FIX(sq);
    }
    else {
        size_t biglen;
        if (RBIGNUM_NEGATIVE_P(num)) {
            domain_error("isqrt");
        }
        biglen = BIGNUM_LEN(num);
        if (biglen == 0) return INT2FIX(0);
#if SIZEOF_BDIGIT &lt;= SIZEOF_LONG
        /* short-circuit */
        if (biglen == 1) {
            n = BIGNUM_DIGITS(num)[0];
            sq = rb_ulong_isqrt(n);
            return ULONG2NUM(sq);
        }
#endif
        return rb_big_isqrt(num);
    }
}</pre> </div> <p>Returns the integer square root of the non-negative integer <code>n</code>, i.e. the largest non-negative integer less than or equal to the square root of <code>n</code>.</p> <pre class="ruby" data-language="ruby">Integer.sqrt(0)        #=&gt; 0
Integer.sqrt(1)        #=&gt; 1
Integer.sqrt(24)       #=&gt; 4
Integer.sqrt(25)       #=&gt; 5
Integer.sqrt(10**400)  #=&gt; 10**200
</pre> <p>Equivalent to <code>Math.sqrt(n).floor</code>, except that the result of the latter code may differ from the true value due to the limited precision of floating point arithmetic.</p> <pre class="ruby" data-language="ruby">Integer.sqrt(10**46)     #=&gt; 100000000000000000000000
Math.sqrt(10**46).floor  #=&gt;  99999999999999991611392 (!)
</pre> <p>If <code>n</code> is not an <a href="integer"><code>Integer</code></a>, it is converted to an <a href="integer"><code>Integer</code></a> first. If <code>n</code> is negative, a <a href="math/domainerror"><code>Math::DomainError</code></a> is raised.</p>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-25"> <span class="method-callseq"> int % other → real </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="25-source"> <pre class="c" data-language="c">VALUE
rb_int_modulo(VALUE x, VALUE y)
{
    if (FIXNUM_P(x)) {
        return fix_mod(x, y);
    }
    else if (RB_TYPE_P(x, T_BIGNUM)) {
        return rb_big_modulo(x, y);
    }
    return num_modulo(x, y);
}</pre> </div> <p>Returns <code>int</code> modulo <code>other</code>.</p> <p>See <a href="numeric#method-i-divmod"><code>Numeric#divmod</code></a> for more information.</p>  </div> <div class="aliases"> Also aliased as: <a href="integer#method-i-modulo">modulo</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-26"> <span class="method-callseq"> int &amp; other_int → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="26-source"> <pre class="c" data-language="c">VALUE
rb_int_and(VALUE x, VALUE y)
{
    if (FIXNUM_P(x)) {
        return fix_and(x, y);
    }
    else if (RB_TYPE_P(x, T_BIGNUM)) {
        return rb_big_and(x, y);
    }
    return Qnil;
}</pre> </div> <p>Bitwise AND.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-2A"> <span class="method-callseq"> int * numeric → numeric_result </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="2A-source"> <pre class="c" data-language="c">VALUE
rb_int_mul(VALUE x, VALUE y)
{
    if (FIXNUM_P(x)) {
        return fix_mul(x, y);
    }
    else if (RB_TYPE_P(x, T_BIGNUM)) {
        return rb_big_mul(x, y);
    }
    return rb_num_coerce_bin(x, y, '*');
}</pre> </div> <p>Performs multiplication: the class of the resulting object depends on the class of <code>numeric</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-2A-2A"> <span class="method-callseq"> int ** numeric → numeric_result </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="2A-2A-source"> <pre class="c" data-language="c">VALUE
rb_int_pow(VALUE x, VALUE y)
{
    if (FIXNUM_P(x)) {
        return fix_pow(x, y);
    }
    else if (RB_TYPE_P(x, T_BIGNUM)) {
        return rb_big_pow(x, y);
    }
    return Qnil;
}</pre> </div> <p>Raises <code>int</code> to the power of <code>numeric</code>, which may be negative or fractional. The result may be an <a href="integer"><code>Integer</code></a>, a <a href="float"><code>Float</code></a>, a <a href="rational"><code>Rational</code></a>, or a complex number.</p> <pre class="ruby" data-language="ruby">2 ** 3        #=&gt; 8
2 ** -1       #=&gt; (1/2)
2 ** 0.5      #=&gt; 1.4142135623730951
(-1) ** 0.5   #=&gt; (0.0+1.0i)

123456789 ** 2     #=&gt; 15241578750190521
123456789 ** 1.2   #=&gt; 5126464716.0993185
123456789 ** -2    #=&gt; (1/15241578750190521)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-2B"> <span class="method-callseq"> int + numeric → numeric_result </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="2B-source"> <pre class="c" data-language="c">VALUE
rb_int_plus(VALUE x, VALUE y)
{
    if (FIXNUM_P(x)) {
        return fix_plus(x, y);
    }
    else if (RB_TYPE_P(x, T_BIGNUM)) {
        return rb_big_plus(x, y);
    }
    return rb_num_coerce_bin(x, y, '+');
}</pre> </div> <p>Performs addition: the class of the resulting object depends on the class of <code>numeric</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-2D"> <span class="method-callseq"> int - numeric → numeric_result </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="2D-source"> <pre class="c" data-language="c">VALUE
rb_int_minus(VALUE x, VALUE y)
{
    if (FIXNUM_P(x)) {
        return fix_minus(x, y);
    }
    else if (RB_TYPE_P(x, T_BIGNUM)) {
        return rb_big_minus(x, y);
    }
    return rb_num_coerce_bin(x, y, '-');
}</pre> </div> <p>Performs subtraction: the class of the resulting object depends on the class of <code>numeric</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-2D-40"> <span class="method-callseq"> -int → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="2D-40-source"> <pre class="ruby" data-language="ruby"># File integer.rb, line 6
def -@
  Primitive.attr! 'inline'
  Primitive.cexpr! 'rb_int_uminus(self)'
end</pre> </div> <p>Returns <code>int</code>, negated.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-2F"> <span class="method-callseq"> int / numeric → numeric_result </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="2F-source"> <pre class="c" data-language="c">VALUE
rb_int_div(VALUE x, VALUE y)
{
    if (FIXNUM_P(x)) {
        return fix_div(x, y);
    }
    else if (RB_TYPE_P(x, T_BIGNUM)) {
        return rb_big_div(x, y);
    }
    return Qnil;
}</pre> </div> <p>Performs division: the class of the resulting object depends on the class of <code>numeric</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3C"> <span class="method-callseq"> int &lt; real → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3C-source"> <pre class="c" data-language="c">static VALUE
int_lt(VALUE x, VALUE y)
{
    if (FIXNUM_P(x)) {
        return fix_lt(x, y);
    }
    else if (RB_TYPE_P(x, T_BIGNUM)) {
        return rb_big_lt(x, y);
    }
    return Qnil;
}</pre> </div> <p>Returns <code>true</code> if the value of <code>int</code> is less than that of <code>real</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3C-3C"> <span class="method-callseq"> int &lt;&lt; count → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3C-3C-source"> <pre class="c" data-language="c">VALUE
rb_int_lshift(VALUE x, VALUE y)
{
    if (FIXNUM_P(x)) {
        return rb_fix_lshift(x, y);
    }
    else if (RB_TYPE_P(x, T_BIGNUM)) {
        return rb_big_lshift(x, y);
    }
    return Qnil;
}</pre> </div> <p>Returns <code>int</code> shifted left <code>count</code> positions, or right if <code>count</code> is negative.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3C-3D"> <span class="method-callseq"> int &lt;= real → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3C-3D-source"> <pre class="c" data-language="c">static VALUE
int_le(VALUE x, VALUE y)
{
    if (FIXNUM_P(x)) {
        return fix_le(x, y);
    }
    else if (RB_TYPE_P(x, T_BIGNUM)) {
        return rb_big_le(x, y);
    }
    return Qnil;
}</pre> </div> <p>Returns <code>true</code> if the value of <code>int</code> is less than or equal to that of <code>real</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3C-3D-3E"> <span class="method-callseq"> int &lt;=&gt; numeric → -1, 0, +1, or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3C-3D-3E-source"> <pre class="c" data-language="c">VALUE
rb_int_cmp(VALUE x, VALUE y)
{
    if (FIXNUM_P(x)) {
        return fix_cmp(x, y);
    }
    else if (RB_TYPE_P(x, T_BIGNUM)) {
        return rb_big_cmp(x, y);
    }
    else {
        rb_raise(rb_eNotImpError, "need to define `&lt;=&gt;' in %s", rb_obj_classname(x));
    }
}</pre> </div> <p>Comparison—Returns -1, 0, or +1 depending on whether <code>int</code> is less than, equal to, or greater than <code>numeric</code>.</p> <p>This is the basis for the tests in the <a href="comparable"><code>Comparable</code></a> module.</p> <p><code>nil</code> is returned if the two values are incomparable.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-3D-3D"> <span class="method-callseq"> int == other → true or false </span> </div> <div class="method-description"> <p>Returns <code>true</code> if <code>int</code> equals <code>other</code> numerically. Contrast this with <a href="numeric#method-i-eql-3F"><code>Integer#eql?</code></a>, which requires <code>other</code> to be an <a href="integer"><code>Integer</code></a>.</p> <pre class="ruby" data-language="ruby">1 == 2     #=&gt; false
1 == 1.0   #=&gt; true
</pre> </div> <div class="aliases"> Alias for: <a href="integer#method-i-3D-3D-3D">===</a> </div> </div> <div id="method-i-3D-3D-3D" class="method-detail "> <div class="method-description">
<div class="method-source-code" id="3D-3D-3D-source"> <pre class="c" data-language="c">VALUE
rb_int_equal(VALUE x, VALUE y)
{
    if (FIXNUM_P(x)) {
        return fix_equal(x, y);
    }
    else if (RB_TYPE_P(x, T_BIGNUM)) {
        return rb_big_eq(x, y);
    }
    return Qnil;
}</pre> </div> <p>Returns <code>true</code> if <code>int</code> equals <code>other</code> numerically. Contrast this with <a href="numeric#method-i-eql-3F"><code>Integer#eql?</code></a>, which requires <code>other</code> to be an <a href="integer"><code>Integer</code></a>.</p> <pre class="ruby" data-language="ruby">1 == 2     #=&gt; false
1 == 1.0   #=&gt; true
</pre>  </div> <div class="aliases"> Also aliased as: <a href="integer#method-i-3D-3D">==</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3E"> <span class="method-callseq"> int &gt; real → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3E-source"> <pre class="c" data-language="c">VALUE
rb_int_gt(VALUE x, VALUE y)
{
    if (FIXNUM_P(x)) {
        return fix_gt(x, y);
    }
    else if (RB_TYPE_P(x, T_BIGNUM)) {
        return rb_big_gt(x, y);
    }
    return Qnil;
}</pre> </div> <p>Returns <code>true</code> if the value of <code>int</code> is greater than that of <code>real</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3E-3D"> <span class="method-callseq"> int &gt;= real → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3E-3D-source"> <pre class="c" data-language="c">VALUE
rb_int_ge(VALUE x, VALUE y)
{
    if (FIXNUM_P(x)) {
        return fix_ge(x, y);
    }
    else if (RB_TYPE_P(x, T_BIGNUM)) {
        return rb_big_ge(x, y);
    }
    return Qnil;
}</pre> </div> <p>Returns <code>true</code> if the value of <code>int</code> is greater than or equal to that of <code>real</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3E-3E"> <span class="method-callseq"> int &gt;&gt; count → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3E-3E-source"> <pre class="c" data-language="c">static VALUE
rb_int_rshift(VALUE x, VALUE y)
{
    if (FIXNUM_P(x)) {
        return rb_fix_rshift(x, y);
    }
    else if (RB_TYPE_P(x, T_BIGNUM)) {
        return rb_big_rshift(x, y);
    }
    return Qnil;
}</pre> </div> <p>Returns <code>int</code> shifted right <code>count</code> positions, or left if <code>count</code> is negative.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-5B-5D"> <span class="method-callseq"> int[n] → 0, 1 </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> int[n, m] → num </span> </div> <div class="method-heading"> <span class="method-callseq"> int[range] → num </span> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="c" data-language="c">static VALUE
int_aref(int const argc, VALUE * const argv, VALUE const num)
{
    rb_check_arity(argc, 1, 2);
    if (argc == 2) {
        return int_aref2(num, argv[0], argv[1]);
    }
    return int_aref1(num, argv[0]);

    return Qnil;
}</pre> </div> <p>Bit Reference—Returns the <code>n</code>th bit in the binary representation of <code>int</code>, where <code>int[0]</code> is the least significant bit.</p> <pre class="ruby" data-language="ruby">a = 0b11001100101010
30.downto(0) {|n| print a[n] }
#=&gt; 0000000000000000011001100101010

a = 9**15
50.downto(0) {|n| print a[n] }
#=&gt; 000101110110100000111000011110010100111100010111001
</pre> <p>In principle, <code>n[i]</code> is equivalent to <code>(n &gt;&gt; i) &amp; 1</code>. Thus, any negative index always returns zero:</p> <pre class="ruby" data-language="ruby">p 255[-1] #=&gt; 0
</pre> <p><a href="range"><code>Range</code></a> operations <code>n[i, len]</code> and <code>n[i..j]</code> are naturally extended.</p> <ul>
<li> <p><code>n[i, len]</code> equals to <code>(n &gt;&gt; i) &amp; ((1 &lt;&lt; len) - 1)</code>.</p> </li>
<li> <p><code>n[i..j]</code> equals to <code>(n &gt;&gt; i) &amp; ((1 &lt;&lt; (j - i + 1)) - 1)</code>.</p> </li>
<li> <p><code>n[i...j]</code> equals to <code>(n &gt;&gt; i) &amp; ((1 &lt;&lt; (j - i)) - 1)</code>.</p> </li>
<li> <p><code>n[i..]</code> equals to <code>(n &gt;&gt; i)</code>.</p> </li>
<li> <p><code>n[..j]</code> is zero if <code>n &amp; ((1 &lt;&lt; (j + 1)) - 1)</code> is zero. Otherwise, raises an <a href="argumenterror"><code>ArgumentError</code></a>.</p> </li>
<li> <p><code>n[...j]</code> is zero if <code>n &amp; ((1 &lt;&lt; j) - 1)</code> is zero. Otherwise, raises an <a href="argumenterror"><code>ArgumentError</code></a>.</p> </li>
</ul> <p>Note that range operation may exhaust memory. For example, <code>-1[0, 1000000000000]</code> will raise <a href="nomemoryerror"><code>NoMemoryError</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-5E"> <span class="method-callseq"> int ^ other_int → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="5E-source"> <pre class="c" data-language="c">static VALUE
int_xor(VALUE x, VALUE y)
{
    if (FIXNUM_P(x)) {
        return fix_xor(x, y);
    }
    else if (RB_TYPE_P(x, T_BIGNUM)) {
        return rb_big_xor(x, y);
    }
    return Qnil;
}</pre> </div> <p>Bitwise EXCLUSIVE OR.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-abs"> <span class="method-name">abs</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="abs-source"> <pre class="ruby" data-language="ruby"># File integer.rb, line 27
def abs
  Primitive.attr! 'inline'
  Primitive.cexpr! 'rb_int_abs(self)'
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-allbits-3F"> <span class="method-callseq"> allbits?(mask) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="allbits-3F-source"> <pre class="c" data-language="c">static VALUE
int_allbits_p(VALUE num, VALUE mask)
{
    mask = rb_to_int(mask);
    return rb_int_equal(rb_int_and(num, mask), mask);
}</pre> </div> <p>Returns <code>true</code> if all bits of <code>int &amp; mask</code> are 1.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-anybits-3F"> <span class="method-callseq"> anybits?(mask) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="anybits-3F-source"> <pre class="c" data-language="c">static VALUE
int_anybits_p(VALUE num, VALUE mask)
{
    mask = rb_to_int(mask);
    return int_zero_p(rb_int_and(num, mask)) ? Qfalse : Qtrue;
}</pre> </div> <p>Returns <code>true</code> if any bits of <code>int &amp; mask</code> are 1.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-bit_length"> <span class="method-callseq"> bit_length → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="bit_length-source"> <pre class="ruby" data-language="ruby"># File integer.rb, line 73
def bit_length
  Primitive.attr! 'inline'
  Primitive.cexpr! 'rb_int_bit_length(self)'
end</pre> </div> <p>Returns the number of bits of the value of <code>int</code>.</p> <p>“Number of bits” means the bit position of the highest bit which is different from the sign bit (where the least significant bit has bit position 1). If there is no such bit (zero or minus one), zero is returned.</p> <p>I.e. this method returns <em>ceil(log2(int &lt; 0 ? -int : int+1))</em>.</p> <pre class="ruby" data-language="ruby">(-2**1000-1).bit_length   #=&gt; 1001
(-2**1000).bit_length     #=&gt; 1000
(-2**1000+1).bit_length   #=&gt; 1000
(-2**12-1).bit_length     #=&gt; 13
(-2**12).bit_length       #=&gt; 12
(-2**12+1).bit_length     #=&gt; 12
-0x101.bit_length         #=&gt; 9
-0x100.bit_length         #=&gt; 8
-0xff.bit_length          #=&gt; 8
-2.bit_length             #=&gt; 1
-1.bit_length             #=&gt; 0
0.bit_length              #=&gt; 0
1.bit_length              #=&gt; 1
0xff.bit_length           #=&gt; 8
0x100.bit_length          #=&gt; 9
(2**12-1).bit_length      #=&gt; 12
(2**12).bit_length        #=&gt; 13
(2**12+1).bit_length      #=&gt; 13
(2**1000-1).bit_length    #=&gt; 1000
(2**1000).bit_length      #=&gt; 1001
(2**1000+1).bit_length    #=&gt; 1001
</pre> <p>This method can be used to detect overflow in <a href="array#method-i-pack"><code>Array#pack</code></a> as follows:</p> <pre class="ruby" data-language="ruby">if n.bit_length &lt; 32
  [n].pack("l") # no overflow
else
  raise "overflow"
end
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ceil"> <span class="method-callseq"> ceil([ndigits]) → integer or float </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ceil-source"> <pre class="c" data-language="c">static VALUE
int_ceil(int argc, VALUE* argv, VALUE num)
{
    int ndigits;

    if (!rb_check_arity(argc, 0, 1)) return num;
    ndigits = NUM2INT(argv[0]);
    if (ndigits &gt;= 0) {
        return num;
    }
    return rb_int_ceil(num, ndigits);
}</pre> </div> <p>Returns the smallest number greater than or equal to <code>int</code> with a precision of <code>ndigits</code> decimal digits (default: 0).</p> <p>When the precision is negative, the returned value is an integer with at least <code>ndigits.abs</code> trailing zeros.</p> <p>Returns <code>self</code> when <code>ndigits</code> is zero or positive.</p> <pre class="ruby" data-language="ruby">1.ceil           #=&gt; 1
1.ceil(2)        #=&gt; 1
18.ceil(-1)      #=&gt; 20
(-18).ceil(-1)   #=&gt; -10
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-chr"> <span class="method-callseq"> chr([encoding]) → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="chr-source"> <pre class="c" data-language="c">static VALUE
int_chr(int argc, VALUE *argv, VALUE num)
{
    char c;
    unsigned int i;
    rb_encoding *enc;

    if (rb_num_to_uint(num, &amp;i) == 0) {
    }
    else if (FIXNUM_P(num)) {
        rb_raise(rb_eRangeError, "%ld out of char range", FIX2LONG(num));
    }
    else {
        rb_raise(rb_eRangeError, "bignum out of char range");
    }

    switch (argc) {
      case 0:
        if (0xff &lt; i) {
            enc = rb_default_internal_encoding();
            if (!enc) {
                rb_raise(rb_eRangeError, "%u out of char range", i);
            }
            goto decode;
        }
        c = (char)i;
        if (i &lt; 0x80) {
            return rb_usascii_str_new(&amp;c, 1);
        }
        else {
            return rb_str_new(&amp;c, 1);
        }
      case 1:
        break;
      default:
        rb_error_arity(argc, 0, 1);
    }
    enc = rb_to_encoding(argv[0]);
    if (!enc) enc = rb_ascii8bit_encoding();
  decode:
    return rb_enc_uint_chr(i, enc);
}</pre> </div> <p>Returns a string containing the character represented by the <code>int</code>'s value according to <code>encoding</code>.</p> <pre class="ruby" data-language="ruby">65.chr    #=&gt; "A"
230.chr   #=&gt; "\xE6"
255.chr(Encoding::UTF_8)   #=&gt; "\u00FF"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-coerce"> <span class="method-callseq"> coerce(numeric) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="coerce-source"> <pre class="c" data-language="c">static VALUE
rb_int_coerce(VALUE x, VALUE y)
{
    if (RB_INTEGER_TYPE_P(y)) {
        return rb_assoc_new(y, x);
    }
    else {
        x = rb_Float(x);
        y = rb_Float(y);
        return rb_assoc_new(y, x);
    }
}</pre> </div> <p>Returns an array with both a <code>numeric</code> and a <code>big</code> represented as Bignum objects.</p> <p>This is achieved by converting <code>numeric</code> to a Bignum.</p> <p>A <a href="typeerror"><code>TypeError</code></a> is raised if the <code>numeric</code> is not a Fixnum or Bignum type.</p> <pre class="ruby" data-language="ruby">(0x3FFFFFFFFFFFFFFF+1).coerce(42)   #=&gt; [42, 4611686018427387904]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-denominator"> <span class="method-callseq"> denominator → 1 </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="denominator-source"> <pre class="c" data-language="c">static VALUE
integer_denominator(VALUE self)
{
    return INT2FIX(1);
}</pre> </div> <p>Returns 1.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-digits"> <span class="method-callseq"> digits → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> digits(base) → array </span> </div> <div class="method-description">
<div class="method-source-code" id="digits-source"> <pre class="c" data-language="c">static VALUE
rb_int_digits(int argc, VALUE *argv, VALUE num)
{
    VALUE base_value;
    long base;

    if (rb_num_negative_p(num))
        rb_raise(rb_eMathDomainError, "out of domain");

    if (rb_check_arity(argc, 0, 1)) {
        base_value = rb_to_int(argv[0]);
        if (!RB_INTEGER_TYPE_P(base_value))
            rb_raise(rb_eTypeError, "wrong argument type %s (expected Integer)",
                     rb_obj_classname(argv[0]));
        if (RB_TYPE_P(base_value, T_BIGNUM))
            return rb_int_digits_bigbase(num, base_value);

        base = FIX2LONG(base_value);
        if (base &lt; 0)
            rb_raise(rb_eArgError, "negative radix");
        else if (base &lt; 2)
            rb_raise(rb_eArgError, "invalid radix %ld", base);
    }
    else
        base = 10;

    if (FIXNUM_P(num))
        return rb_fix_digits(num, base);
    else if (RB_TYPE_P(num, T_BIGNUM))
        return rb_int_digits_bigbase(num, LONG2FIX(base));

    return Qnil;
}</pre> </div> <p>Returns the digits of <code>int</code>'s place-value representation with radix <code>base</code> (default: 10). The digits are returned as an array with the least significant digit as the first array element.</p> <p><code>base</code> must be greater than or equal to 2.</p> <pre class="ruby" data-language="ruby">12345.digits      #=&gt; [5, 4, 3, 2, 1]
12345.digits(7)   #=&gt; [4, 6, 6, 0, 5]
12345.digits(100) #=&gt; [45, 23, 1]

-12345.digits(7)  #=&gt; Math::DomainError
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-div"> <span class="method-callseq"> div(numeric) → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="div-source"> <pre class="c" data-language="c">VALUE
rb_int_idiv(VALUE x, VALUE y)
{
    if (FIXNUM_P(x)) {
        return fix_idiv(x, y);
    }
    else if (RB_TYPE_P(x, T_BIGNUM)) {
        return rb_big_idiv(x, y);
    }
    return num_div(x, y);
}</pre> </div> <p>Performs integer division: returns the integer result of dividing <code>int</code> by <code>numeric</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-divmod"> <span class="method-callseq"> divmod(numeric) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="divmod-source"> <pre class="c" data-language="c">VALUE
rb_int_divmod(VALUE x, VALUE y)
{
    if (FIXNUM_P(x)) {
        return fix_divmod(x, y);
    }
    else if (RB_TYPE_P(x, T_BIGNUM)) {
        return rb_big_divmod(x, y);
    }
    return Qnil;
}</pre> </div> <p>See <a href="numeric#method-i-divmod"><code>Numeric#divmod</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-downto"> <span class="method-callseq"> downto(limit) {|i| block } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> downto(limit) → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="downto-source"> <pre class="c" data-language="c">static VALUE
int_downto(VALUE from, VALUE to)
{
    RETURN_SIZED_ENUMERATOR(from, 1, &amp;to, int_downto_size);
    if (FIXNUM_P(from) &amp;&amp; FIXNUM_P(to)) {
        long i, end;

        end = FIX2LONG(to);
        for (i=FIX2LONG(from); i &gt;= end; i--) {
            rb_yield(LONG2FIX(i));
        }
    }
    else {
        VALUE i = from, c;

        while (!(c = rb_funcall(i, '&lt;', 1, to))) {
            rb_yield(i);
            i = rb_funcall(i, '-', 1, INT2FIX(1));
        }
        if (NIL_P(c)) rb_cmperr(i, to);
    }
    return from;
}</pre> </div> <p>Iterates the given block, passing in decreasing values from <code>int</code> down to and including <code>limit</code>.</p> <p>If no block is given, an <a href="enumerator"><code>Enumerator</code></a> is returned instead.</p> <pre class="ruby" data-language="ruby">5.downto(1) { |n| print n, ".. " }
puts "Liftoff!"
#=&gt; "5.. 4.. 3.. 2.. 1.. Liftoff!"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-even-3F"> <span class="method-callseq"> even? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="even-3F-source"> <pre class="ruby" data-language="ruby"># File integer.rb, line 82
def even?
  Primitive.attr! 'inline'
  Primitive.cexpr! 'rb_int_even_p(self)'
end</pre> </div> <p>Returns <code>true</code> if <code>int</code> is an even number.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fdiv"> <span class="method-callseq"> fdiv(numeric) → float </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="fdiv-source"> <pre class="c" data-language="c">VALUE
rb_int_fdiv(VALUE x, VALUE y)
{
    if (RB_INTEGER_TYPE_P(x)) {
        return DBL2NUM(rb_int_fdiv_double(x, y));
    }
    return Qnil;
}</pre> </div> <p>Returns the floating point result of dividing <code>int</code> by <code>numeric</code>.</p> <pre class="ruby" data-language="ruby">654321.fdiv(13731)      #=&gt; 47.652829364212366
654321.fdiv(13731.24)   #=&gt; 47.65199646936475
-654321.fdiv(13731)     #=&gt; -47.652829364212366
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-floor"> <span class="method-callseq"> floor([ndigits]) → integer or float </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="floor-source"> <pre class="c" data-language="c">static VALUE
int_floor(int argc, VALUE* argv, VALUE num)
{
    int ndigits;

    if (!rb_check_arity(argc, 0, 1)) return num;
    ndigits = NUM2INT(argv[0]);
    if (ndigits &gt;= 0) {
        return num;
    }
    return rb_int_floor(num, ndigits);
}</pre> </div> <p>Returns the largest number less than or equal to <code>int</code> with a precision of <code>ndigits</code> decimal digits (default: 0).</p> <p>When the precision is negative, the returned value is an integer with at least <code>ndigits.abs</code> trailing zeros.</p> <p>Returns <code>self</code> when <code>ndigits</code> is zero or positive.</p> <pre class="ruby" data-language="ruby">1.floor           #=&gt; 1
1.floor(2)        #=&gt; 1
18.floor(-1)      #=&gt; 10
(-18).floor(-1)   #=&gt; -20
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-gcd"> <span class="method-callseq"> gcd(other_int) → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="gcd-source"> <pre class="c" data-language="c">VALUE
rb_gcd(VALUE self, VALUE other)
{
    other = nurat_int_value(other);
    return f_gcd(self, other);
}</pre> </div> <p>Returns the greatest common divisor of the two integers. The result is always positive. 0.gcd(x) and x.gcd(0) return x.abs.</p> <pre class="ruby" data-language="ruby">36.gcd(60)                  #=&gt; 12
2.gcd(2)                    #=&gt; 2
3.gcd(-7)                   #=&gt; 1
((1&lt;&lt;31)-1).gcd((1&lt;&lt;61)-1)  #=&gt; 1
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-gcdlcm"> <span class="method-callseq"> gcdlcm(other_int) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="gcdlcm-source"> <pre class="c" data-language="c">VALUE
rb_gcdlcm(VALUE self, VALUE other)
{
    other = nurat_int_value(other);
    return rb_assoc_new(f_gcd(self, other), f_lcm(self, other));
}</pre> </div> <p>Returns an array with the greatest common divisor and the least common multiple of the two integers, [gcd, lcm].</p> <pre class="ruby" data-language="ruby">36.gcdlcm(60)                  #=&gt; [12, 180]
2.gcdlcm(2)                    #=&gt; [2, 2]
3.gcdlcm(-7)                   #=&gt; [1, 21]
((1&lt;&lt;31)-1).gcdlcm((1&lt;&lt;61)-1)  #=&gt; [1, 4951760154835678088235319297]
</pre>  </div> </div> <div id="method-i-inspect" class="method-detail method-alias"> <div class="method-description"> <p>Returns a string containing the place-value representation of <code>int</code> with radix <code>base</code> (between 2 and 36).</p> <pre class="ruby" data-language="ruby">12345.to_s       #=&gt; "12345"
12345.to_s(2)    #=&gt; "11000000111001"
12345.to_s(8)    #=&gt; "30071"
12345.to_s(10)   #=&gt; "12345"
12345.to_s(16)   #=&gt; "3039"
12345.to_s(36)   #=&gt; "9ix"
78546939656932.to_s(36)  #=&gt; "rubyrules"
</pre> </div> <div class="aliases"> Alias for: <a href="integer#method-i-to_s">to_s</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-integer-3F"> <span class="method-callseq"> integer? → true </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="integer-3F-source"> <pre class="ruby" data-language="ruby"># File integer.rb, line 91
def integer?
  return true
end</pre> </div> <p>Since <code>int</code> is already an <a href="integer"><code>Integer</code></a>, this always returns <code>true</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-lcm"> <span class="method-callseq"> lcm(other_int) → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="lcm-source"> <pre class="c" data-language="c">VALUE
rb_lcm(VALUE self, VALUE other)
{
    other = nurat_int_value(other);
    return f_lcm(self, other);
}</pre> </div> <p>Returns the least common multiple of the two integers. The result is always positive. 0.lcm(x) and x.lcm(0) return zero.</p> <pre class="ruby" data-language="ruby">36.lcm(60)                  #=&gt; 180
2.lcm(2)                    #=&gt; 2
3.lcm(-7)                   #=&gt; 21
((1&lt;&lt;31)-1).lcm((1&lt;&lt;61)-1)  #=&gt; 4951760154835678088235319297
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-magnitude"> <span class="method-name">magnitude</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="magnitude-source"> <pre class="ruby" data-language="ruby"># File integer.rb, line 95
def magnitude
  Primitive.attr! 'inline'
  Primitive.cexpr! 'rb_int_abs(self)'
end</pre> </div>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-modulo"> <span class="method-callseq"> modulo(other) → real </span> </div> <div class="method-description"> <p>Returns <code>int</code> modulo <code>other</code>.</p> <p>See <a href="numeric#method-i-divmod"><code>Numeric#divmod</code></a> for more information.</p> </div> <div class="aliases"> Alias for: <a href="integer#method-i-25">%</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-next"> <span class="method-callseq"> next → integer </span> </div> <div class="method-description"> <p>Returns the successor of <code>int</code>, i.e. the <a href="integer"><code>Integer</code></a> equal to <code>int+1</code>.</p> <pre class="ruby" data-language="ruby">1.next      #=&gt; 2
(-1).next   #=&gt; 0
1.succ      #=&gt; 2
(-1).succ   #=&gt; 0
</pre> </div> <div class="aliases"> Alias for: <a href="integer#method-i-succ">succ</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-nobits-3F"> <span class="method-callseq"> nobits?(mask) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="nobits-3F-source"> <pre class="c" data-language="c">static VALUE
int_nobits_p(VALUE num, VALUE mask)
{
    mask = rb_to_int(mask);
    return int_zero_p(rb_int_and(num, mask));
}</pre> </div> <p>Returns <code>true</code> if no bits of <code>int &amp; mask</code> are 1.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-numerator"> <span class="method-callseq"> numerator → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="numerator-source"> <pre class="c" data-language="c">static VALUE
integer_numerator(VALUE self)
{
    return self;
}</pre> </div> <p>Returns self.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-odd-3F"> <span class="method-callseq"> odd? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="odd-3F-source"> <pre class="ruby" data-language="ruby"># File integer.rb, line 104
def odd?
  Primitive.attr! 'inline'
  Primitive.cexpr! 'rb_int_odd_p(self)'
end</pre> </div> <p>Returns <code>true</code> if <code>int</code> is an odd number.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ord"> <span class="method-callseq"> ord → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ord-source"> <pre class="ruby" data-language="ruby"># File integer.rb, line 120
def ord
  return self
end</pre> </div> <p>Returns the <code>int</code> itself.</p> <pre class="ruby" data-language="ruby">97.ord   #=&gt; 97
</pre> <p>This method is intended for compatibility to character literals in Ruby 1.9.</p> <p>For example, <code>?a.ord</code> returns 97 both in 1.8 and 1.9.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pow"> <span class="method-callseq"> pow(numeric) → numeric </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> pow(integer, integer) → integer </span> </div> <div class="method-description">
<div class="method-source-code" id="pow-source"> <pre class="c" data-language="c">VALUE
rb_int_powm(int const argc, VALUE * const argv, VALUE const num)
{
    rb_check_arity(argc, 1, 2);

    if (argc == 1) {
        return rb_int_pow(num, argv[0]);
    }
    else {
        VALUE const a = num;
        VALUE const b = argv[0];
        VALUE m = argv[1];
        int nega_flg = 0;
        if ( ! RB_INTEGER_TYPE_P(b)) {
            rb_raise(rb_eTypeError, "Integer#pow() 2nd argument not allowed unless a 1st argument is integer");
        }
        if (rb_int_negative_p(b)) {
            rb_raise(rb_eRangeError, "Integer#pow() 1st argument cannot be negative when 2nd argument specified");
        }
        if (!RB_INTEGER_TYPE_P(m)) {
            rb_raise(rb_eTypeError, "Integer#pow() 2nd argument not allowed unless all arguments are integers");
        }

        if (rb_int_negative_p(m)) {
            m = rb_int_uminus(m);
            nega_flg = 1;
        }

        if (FIXNUM_P(m)) {
            long const half_val = (long)HALF_LONG_MSB;
            long const mm = FIX2LONG(m);
            if (!mm) rb_num_zerodiv();
            if (mm == 1) return INT2FIX(0);
            if (mm &lt;= half_val) {
                return int_pow_tmp1(rb_int_modulo(a, m), b, mm, nega_flg);
            }
            else {
                return int_pow_tmp2(rb_int_modulo(a, m), b, mm, nega_flg);
            }
        }
        else {
            if (rb_bigzero_p(m)) rb_num_zerodiv();
	    if (bignorm(m) == INT2FIX(1)) return INT2FIX(0);
            return int_pow_tmp3(rb_int_modulo(a, m), b, m, nega_flg);
        }
    }
    UNREACHABLE_RETURN(Qnil);
}</pre> </div> <p>Returns (modular) exponentiation as:</p> <pre class="ruby" data-language="ruby">a.pow(b)     #=&gt; same as a**b
a.pow(b, m)  #=&gt; same as (a**b) % m, but avoids huge temporary values
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pred"> <span class="method-callseq"> pred → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pred-source"> <pre class="c" data-language="c">static VALUE
rb_int_pred(VALUE num)
{
    if (FIXNUM_P(num)) {
        long i = FIX2LONG(num) - 1;
        return LONG2NUM(i);
    }
    if (RB_TYPE_P(num, T_BIGNUM)) {
        return rb_big_minus(num, INT2FIX(1));
    }
    return num_funcall1(num, '-', INT2FIX(1));
}</pre> </div> <p>Returns the predecessor of <code>int</code>, i.e. the <a href="integer"><code>Integer</code></a> equal to <code>int-1</code>.</p> <pre class="ruby" data-language="ruby">1.pred      #=&gt; 0
(-1).pred   #=&gt; -2
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-prime-3F"> <span class="method-name">prime?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="prime-3F-source"> <pre class="ruby" data-language="ruby"># File lib/prime.rb, line 35
def prime?
  return self &gt;= 2 if self &lt;= 3

  if (bases = miller_rabin_bases)
    return miller_rabin_test(bases)
  end

  return true if self == 5
  return false unless 30.gcd(self) == 1
  (7..Integer.sqrt(self)).step(30) do |p|
    return false if
      self%(p)    == 0 || self%(p+4)  == 0 || self%(p+6)  == 0 || self%(p+10) == 0 ||
      self%(p+12) == 0 || self%(p+16) == 0 || self%(p+22) == 0 || self%(p+24) == 0
  end
  true
end</pre> </div> <p>Returns true if <code>self</code> is a prime number, else returns false. Not recommended for very big integers (&gt; 10**23).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-prime_division"> <span class="method-name">prime_division</span><span class="method-args">(generator = Prime::Generator23.new)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="prime_division-source"> <pre class="ruby" data-language="ruby"># File lib/prime.rb, line 29
def prime_division(generator = Prime::Generator23.new)
  Prime.prime_division(self, generator)
end</pre> </div> <p>Returns the factorization of <code>self</code>.</p> <p>See <a href="prime#method-i-prime_division"><code>Prime#prime_division</code></a> for more details.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rationalize"> <span class="method-callseq"> rationalize([eps]) → rational </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rationalize-source"> <pre class="c" data-language="c">static VALUE
integer_rationalize(int argc, VALUE *argv, VALUE self)
{
    rb_check_arity(argc, 0, 1);
    return integer_to_r(self);
}</pre> </div> <p>Returns the value as a rational. The optional argument <code>eps</code> is always ignored.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remainder"> <span class="method-callseq"> remainder(numeric) → real </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remainder-source"> <pre class="c" data-language="c">static VALUE
int_remainder(VALUE x, VALUE y)
{
    if (FIXNUM_P(x)) {
        return num_remainder(x, y);
    }
    else if (RB_TYPE_P(x, T_BIGNUM)) {
        return rb_big_remainder(x, y);
    }
    return Qnil;
}</pre> </div> <p>Returns the remainder after dividing <code>int</code> by <code>numeric</code>.</p> <p><code>x.remainder(y)</code> means <code>x-y*(x/y).truncate</code>.</p> <pre class="ruby" data-language="ruby">5.remainder(3)     #=&gt; 2
-5.remainder(3)    #=&gt; -2
5.remainder(-3)    #=&gt; 2
-5.remainder(-3)   #=&gt; -2
5.remainder(1.5)   #=&gt; 0.5
</pre> <p>See <a href="numeric#method-i-divmod"><code>Numeric#divmod</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-round"> <span class="method-callseq"> round([ndigits] [, half: mode]) → integer or float </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="round-source"> <pre class="c" data-language="c">static VALUE
int_round(int argc, VALUE* argv, VALUE num)
{
    int ndigits;
    int mode;
    VALUE nd, opt;

    if (!rb_scan_args(argc, argv, "01:", &amp;nd, &amp;opt)) return num;
    ndigits = NUM2INT(nd);
    mode = rb_num_get_rounding_option(opt);
    if (ndigits &gt;= 0) {
        return num;
    }
    return rb_int_round(num, ndigits, mode);
}</pre> </div> <p>Returns <code>int</code> rounded to the nearest value with a precision of <code>ndigits</code> decimal digits (default: 0).</p> <p>When the precision is negative, the returned value is an integer with at least <code>ndigits.abs</code> trailing zeros.</p> <p>Returns <code>self</code> when <code>ndigits</code> is zero or positive.</p> <pre class="ruby" data-language="ruby">1.round           #=&gt; 1
1.round(2)        #=&gt; 1
15.round(-1)      #=&gt; 20
(-15).round(-1)   #=&gt; -20
</pre> <p>The optional <code>half</code> keyword argument is available similar to <a href="float#method-i-round"><code>Float#round</code></a>.</p> <pre class="ruby" data-language="ruby">25.round(-1, half: :up)      #=&gt; 30
25.round(-1, half: :down)    #=&gt; 20
25.round(-1, half: :even)    #=&gt; 20
35.round(-1, half: :up)      #=&gt; 40
35.round(-1, half: :down)    #=&gt; 30
35.round(-1, half: :even)    #=&gt; 40
(-25).round(-1, half: :up)   #=&gt; -30
(-25).round(-1, half: :down) #=&gt; -20
(-25).round(-1, half: :even) #=&gt; -20
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-size"> <span class="method-callseq"> size → int </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="size-source"> <pre class="c" data-language="c">static VALUE
int_size(VALUE num)
{
    if (FIXNUM_P(num)) {
        return fix_size(num);
    }
    else if (RB_TYPE_P(num, T_BIGNUM)) {
        return rb_big_size_m(num);
    }
    return Qnil;
}</pre> </div> <p>Returns the number of bytes in the machine representation of <code>int</code> (machine dependent).</p> <pre class="ruby" data-language="ruby">1.size               #=&gt; 8
-1.size              #=&gt; 8
2147483647.size      #=&gt; 8
(256**10 - 1).size   #=&gt; 10
(256**20 - 1).size   #=&gt; 20
(256**40 - 1).size   #=&gt; 40
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-succ"> <span class="method-callseq"> succ → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="succ-source"> <pre class="c" data-language="c">VALUE
rb_int_succ(VALUE num)
{
    if (FIXNUM_P(num)) {
        long i = FIX2LONG(num) + 1;
        return LONG2NUM(i);
    }
    if (RB_TYPE_P(num, T_BIGNUM)) {
        return rb_big_plus(num, INT2FIX(1));
    }
    return num_funcall1(num, '+', INT2FIX(1));
}</pre> </div> <p>Returns the successor of <code>int</code>, i.e. the <a href="integer"><code>Integer</code></a> equal to <code>int+1</code>.</p> <pre class="ruby" data-language="ruby">1.next      #=&gt; 2
(-1).next   #=&gt; 0
1.succ      #=&gt; 2
(-1).succ   #=&gt; 0
</pre>  </div> <div class="aliases"> Also aliased as: <a href="integer#method-i-next">next</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-times"> <span class="method-callseq"> times {|i| block } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> times → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="times-source"> <pre class="c" data-language="c">static VALUE
int_dotimes(VALUE num)
{
    RETURN_SIZED_ENUMERATOR(num, 0, 0, int_dotimes_size);

    if (FIXNUM_P(num)) {
        long i, end;

        end = FIX2LONG(num);
        for (i=0; i&lt;end; i++) {
            rb_yield_1(LONG2FIX(i));
        }
    }
    else {
        VALUE i = INT2FIX(0);

        for (;;) {
            if (!RTEST(rb_funcall(i, '&lt;', 1, num))) break;
            rb_yield(i);
            i = rb_funcall(i, '+', 1, INT2FIX(1));
        }
    }
    return num;
}</pre> </div> <p>Iterates the given block <code>int</code> times, passing in values from zero to <code>int - 1</code>.</p> <p>If no block is given, an <a href="enumerator"><code>Enumerator</code></a> is returned instead.</p> <pre class="ruby" data-language="ruby">5.times {|i| print i, " " }   #=&gt; 0 1 2 3 4
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_bn"> <span class="method-name">to_bn</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_bn-source"> <pre class="ruby" data-language="ruby"># File ext/openssl/lib/openssl/bn.rb, line 37
def to_bn
  OpenSSL::BN::new(self)
end</pre> </div> <p>Casts an <a href="integer"><code>Integer</code></a> as an <a href="openssl/bn"><code>OpenSSL::BN</code></a></p> <p>See `man bn` for more info.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_d"> <span class="method-callseq"> to_d → bigdecimal </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_d-source"> <pre class="ruby" data-language="ruby"># File ext/bigdecimal/lib/bigdecimal/util.rb, line 23
def to_d
  BigDecimal(self)
end</pre> </div> <p>Returns the value of <code>int</code> as a <a href="bigdecimal"><code>BigDecimal</code></a>.</p> <pre class="ruby" data-language="ruby">require 'bigdecimal'
require 'bigdecimal/util'

42.to_d   # =&gt; 0.42e2
</pre> <p>See also <a href="basicobject#method-c-new"><code>BigDecimal::new</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_f"> <span class="method-callseq"> to_f → float </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_f-source"> <pre class="c" data-language="c">static VALUE
int_to_f(VALUE num)
{
    double val;

    if (FIXNUM_P(num)) {
        val = (double)FIX2LONG(num);
    }
    else if (RB_TYPE_P(num, T_BIGNUM)) {
        val = rb_big2dbl(num);
    }
    else {
        rb_raise(rb_eNotImpError, "Unknown subclass for to_f: %s", rb_obj_classname(num));
    }

    return DBL2NUM(val);
}</pre> </div> <p>Converts <code>int</code> to a <a href="float"><code>Float</code></a>. If <code>int</code> doesn't fit in a <a href="float"><code>Float</code></a>, the result is infinity.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_i"> <span class="method-callseq"> to_i → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_i-source"> <pre class="ruby" data-language="ruby"># File integer.rb, line 130
def to_i
  return self
end</pre> </div> <p>Since <code>int</code> is already an <a href="integer"><code>Integer</code></a>, returns <code>self</code>.</p> <p><a href="integer#method-i-to_int"><code>to_int</code></a> is an alias for <a href="integer#method-i-to_i"><code>to_i</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_int"> <span class="method-callseq"> to_int → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_int-source"> <pre class="ruby" data-language="ruby"># File integer.rb, line 138
def to_int
  return self
end</pre> </div> <p>Since <code>int</code> is already an <a href="integer"><code>Integer</code></a>, returns <code>self</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_r"> <span class="method-callseq"> to_r → rational </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_r-source"> <pre class="c" data-language="c">static VALUE
integer_to_r(VALUE self)
{
    return rb_rational_new1(self);
}</pre> </div> <p>Returns the value as a rational.</p> <pre class="ruby" data-language="ruby">1.to_r        #=&gt; (1/1)
(1&lt;&lt;64).to_r  #=&gt; (18446744073709551616/1)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_s"> <span class="method-callseq"> to_s(base=10) → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_s-source"> <pre class="c" data-language="c">static VALUE
int_to_s(int argc, VALUE *argv, VALUE x)
{
    int base;

    if (rb_check_arity(argc, 0, 1))
        base = NUM2INT(argv[0]);
    else
        base = 10;
    return rb_int2str(x, base);
}</pre> </div> <p>Returns a string containing the place-value representation of <code>int</code> with radix <code>base</code> (between 2 and 36).</p> <pre class="ruby" data-language="ruby">12345.to_s       #=&gt; "12345"
12345.to_s(2)    #=&gt; "11000000111001"
12345.to_s(8)    #=&gt; "30071"
12345.to_s(10)   #=&gt; "12345"
12345.to_s(16)   #=&gt; "3039"
12345.to_s(36)   #=&gt; "9ix"
78546939656932.to_s(36)  #=&gt; "rubyrules"
</pre>  </div> <div class="aliases"> Also aliased as: <a href="integer#method-i-inspect">inspect</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-truncate"> <span class="method-callseq"> truncate([ndigits]) → integer or float </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="truncate-source"> <pre class="c" data-language="c">static VALUE
int_truncate(int argc, VALUE* argv, VALUE num)
{
    int ndigits;

    if (!rb_check_arity(argc, 0, 1)) return num;
    ndigits = NUM2INT(argv[0]);
    if (ndigits &gt;= 0) {
        return num;
    }
    return rb_int_truncate(num, ndigits);
}</pre> </div> <p>Returns <code>int</code> truncated (toward zero) to a precision of <code>ndigits</code> decimal digits (default: 0).</p> <p>When the precision is negative, the returned value is an integer with at least <code>ndigits.abs</code> trailing zeros.</p> <p>Returns <code>self</code> when <code>ndigits</code> is zero or positive.</p> <pre class="ruby" data-language="ruby">1.truncate           #=&gt; 1
1.truncate(2)        #=&gt; 1
18.truncate(-1)      #=&gt; 10
(-18).truncate(-1)   #=&gt; -10
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-upto"> <span class="method-callseq"> upto(limit) {|i| block } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> upto(limit) → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="upto-source"> <pre class="c" data-language="c">static VALUE
int_upto(VALUE from, VALUE to)
{
    RETURN_SIZED_ENUMERATOR(from, 1, &amp;to, int_upto_size);
    if (FIXNUM_P(from) &amp;&amp; FIXNUM_P(to)) {
        long i, end;

        end = FIX2LONG(to);
        for (i = FIX2LONG(from); i &lt;= end; i++) {
            rb_yield(LONG2FIX(i));
        }
    }
    else {
        VALUE i = from, c;

        while (!(c = rb_funcall(i, '&gt;', 1, to))) {
            rb_yield(i);
            i = rb_funcall(i, '+', 1, INT2FIX(1));
        }
        ensure_cmp(c, i, to);
    }
    return from;
}</pre> </div> <p>Iterates the given block, passing in integer values from <code>int</code> up to and including <code>limit</code>.</p> <p>If no block is given, an <a href="enumerator"><code>Enumerator</code></a> is returned instead.</p> <pre class="ruby" data-language="ruby">5.upto(10) {|i| print i, " " }   #=&gt; 5 6 7 8 9 10
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-zero-3F"> <span class="method-callseq"> zero? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="zero-3F-source"> <pre class="ruby" data-language="ruby"># File integer.rb, line 146
def zero?
  Primitive.attr! 'inline'
  Primitive.cexpr! 'rb_int_zero_p(self)'
end</pre> </div> <p>Returns <code>true</code> if <code>int</code> has a zero value.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-7C"> <span class="method-callseq"> int | other_int → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="7C-source"> <pre class="c" data-language="c">static VALUE
int_or(VALUE x, VALUE y)
{
    if (FIXNUM_P(x)) {
        return fix_or(x, y);
    }
    else if (RB_TYPE_P(x, T_BIGNUM)) {
        return rb_big_or(x, y);
    }
    return Qnil;
}</pre> </div> <p>Bitwise OR.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-~"> <span class="method-callseq"> ~int → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="~-source"> <pre class="ruby" data-language="ruby"># File integer.rb, line 22
def ~
  Primitive.attr! 'inline'
  Primitive.cexpr! 'rb_int_comp(self)'
end</pre> </div> <p>One's complement: returns a number where each bit is flipped.</p> <p>Inverts the bits in an <a href="integer"><code>Integer</code></a>. As integers are conceptually of infinite length, the result acts as if it had an infinite number of one bits to the left. In hex representations, this is displayed as two periods to the left of the digits.</p> <pre class="ruby" data-language="ruby">sprintf("%X", ~0x1122334455)    #=&gt; "..FEEDDCCBBAA"
</pre>  </div> </div> </section> <section id="private-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Private Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-miller_rabin_bases"> <span class="method-name">miller_rabin_bases</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="miller_rabin_bases-source"> <pre class="ruby" data-language="ruby"># File lib/prime.rb, line 69
        def miller_rabin_bases
  # Miller-Rabin's complexity is O(k log^3n).
  # So we can reduce the complexity by reducing the number of bases tested.
  # Using values from https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test
  i = case
  when self &lt; 0xffff                            then
    # For small integers, Miller Rabin can be slower
    # There is no mathematical significance to 0xffff
    return nil
# when self &lt; 2_047                             then 0
  when self &lt; 1_373_653                         then 1
  when self &lt; 9_080_191                         then 2
  when self &lt; 25_326_001                        then 3
  when self &lt; 3_215_031_751                     then 4
  when self &lt; 4_759_123_141                     then 5
  when self &lt; 1_122_004_669_633                 then 6
  when self &lt; 2_152_302_898_747                 then 7
  when self &lt; 3_474_749_660_383                 then 8
  when self &lt; 341_550_071_728_321               then 9
  when self &lt; 3_825_123_056_546_413_051         then 10
  when self &lt; 318_665_857_834_031_151_167_461   then 11
  when self &lt; 3_317_044_064_679_887_385_961_981 then 12
  else return nil
  end
  MILLER_RABIN_BASES[i]
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-miller_rabin_test"> <span class="method-name">miller_rabin_test</span><span class="method-args">(bases)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="miller_rabin_test-source"> <pre class="ruby" data-language="ruby"># File lib/prime.rb, line 96
        def miller_rabin_test(bases)
  return false if even?

  r = 0
  d = self &gt;&gt; 1
  while d.even?
    d &gt;&gt;= 1
    r += 1
  end

  self_minus_1 = self-1
  bases.each do |a|
    x = a.pow(d, self)
    next if x == 1 || x == self_minus_1 || a == self

    return false if r.times do
      x = x.pow(2, self)
      break if x == self_minus_1
    end
  end
  true
end</pre> </div>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2020 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
