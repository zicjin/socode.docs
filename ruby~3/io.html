<h1 id="class-IO" class="class"> class IO </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes">
<a class="include" href="file/file/constants">File::File::Constants</a>, <a class="include" href="enumerable">Enumerable</a>
</dd>
</dl> <section class="description"> <p>Expect library adds the <a href="io"><code>IO</code></a> instance method <a href="io#method-i-expect"><code>expect</code></a>, which does similar act to tcl's expect extension.</p> <p>In order to use this method, you must require expect:</p> <pre class="ruby" data-language="ruby">require 'expect'
</pre> <p>Please see <a href="io#method-i-expect"><code>expect</code></a> for usage.</p> <p>The <a href="io"><code>IO</code></a> class is the basis for all input and output in Ruby. An I/O stream may be <em>duplexed</em> (that is, bidirectional), and so may use more than one native operating system stream.</p> <p>Many of the examples in this section use the <a href="file"><code>File</code></a> class, the only standard subclass of <a href="io"><code>IO</code></a>. The two classes are closely associated. Like the <a href="file"><code>File</code></a> class, the <a href="socket"><code>Socket</code></a> library subclasses from <a href="io"><code>IO</code></a> (such as <a href="tcpsocket"><code>TCPSocket</code></a> or <a href="udpsocket"><code>UDPSocket</code></a>).</p> <p>The <a href="kernel#method-i-open"><code>Kernel#open</code></a> method can create an <a href="io"><code>IO</code></a> (or <a href="file"><code>File</code></a>) object for these types of arguments:</p> <ul>
<li> <p>A plain string represents a filename suitable for the underlying operating system.</p> </li>
<li> <p>A string starting with <code>"|"</code> indicates a subprocess. The remainder of the string following the <code>"|"</code> is invoked as a process with appropriate input/output channels connected to it.</p> </li>
<li> <p>A string equal to <code>"|-"</code> will create another Ruby instance as a subprocess.</p> </li>
</ul> <p>The <a href="io"><code>IO</code></a> may be opened with different file modes (read-only, write-only) and encodings for proper conversion. See <a href="io#method-c-new"><code>IO.new</code></a> for these options. See <a href="kernel#method-i-open"><code>Kernel#open</code></a> for details of the various command formats described above.</p> <p><a href="io#method-c-popen"><code>IO.popen</code></a>, the <a href="open3"><code>Open3</code></a> library, or Process#spawn may also be used to communicate with subprocesses through an <a href="io"><code>IO</code></a>.</p> <p>Ruby will convert pathnames between different operating system conventions if possible. For instance, on a Windows system the filename <code>"/gumby/ruby/test.rb"</code> will be opened as <code>"\gumby\ruby\test.rb"</code>. When specifying a Windows-style filename in a Ruby string, remember to escape the backslashes:</p> <pre class="ruby" data-language="ruby">"C:\\gumby\\ruby\\test.rb"
</pre> <p>Our examples here will use the Unix-style forward slashes; File::ALT_SEPARATOR can be used to get the platform-specific separator character.</p> <p>The global constant <a href="argf"><code>ARGF</code></a> (also accessible as <code>$&lt;</code>) provides an IO-like stream which allows access to all files mentioned on the command line (or STDIN if no files are mentioned). <a href="argf#method-i-path"><code>ARGF#path</code></a> and its alias <a href="argf#method-i-filename"><code>ARGF#filename</code></a> are provided to access the name of the file currently being read.</p> <h2 id="class-IO-label-io-2Fconsole">io/console</h2> <p>The io/console extension provides methods for interacting with the console. The console can be accessed from <a href="io#method-c-console"><code>IO.console</code></a> or the standard input/output/error <a href="io"><code>IO</code></a> objects.</p> <p>Requiring io/console adds the following methods:</p> <ul>
<li> <p><a href="io#method-c-console"><code>IO::console</code></a></p> </li>
<li> <p><a href="io#method-i-raw"><code>IO#raw</code></a></p> </li>
<li> <p><a href="io#method-i-raw-21"><code>IO#raw!</code></a></p> </li>
<li> <p><a href="io#method-i-cooked"><code>IO#cooked</code></a></p> </li>
<li> <p><a href="io#method-i-cooked-21"><code>IO#cooked!</code></a></p> </li>
<li> <p><a href="io#method-i-getch"><code>IO#getch</code></a></p> </li>
<li> <p><a href="io#method-i-echo-3D"><code>IO#echo=</code></a></p> </li>
<li> <p><a href="io#method-i-echo-3F"><code>IO#echo?</code></a></p> </li>
<li> <p><a href="io#method-i-noecho"><code>IO#noecho</code></a></p> </li>
<li> <p><a href="io#method-i-winsize"><code>IO#winsize</code></a></p> </li>
<li> <p><a href="io#method-i-winsize-3D"><code>IO#winsize=</code></a></p> </li>
<li> <p><a href="io#method-i-iflush"><code>IO#iflush</code></a></p> </li>
<li> <p><a href="io#method-i-ioflush"><code>IO#ioflush</code></a></p> </li>
<li> <p><a href="io#method-i-oflush"><code>IO#oflush</code></a></p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">require 'io/console'
rows, columns = $stdout.winsize
puts "Your screen is #{columns} wide and #{rows} tall"
</pre> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="EWOULDBLOCKWaitReadable">EWOULDBLOCKWaitReadable </dt>
<dd>
<p><a href="io/eagainwaitreadable"><code>EAGAINWaitReadable</code></a></p> </dd>
<dt id="EWOULDBLOCKWaitWritable">EWOULDBLOCKWaitWritable </dt>
<dd>
<p><a href="io/eagainwaitwritable"><code>EAGAINWaitWritable</code></a></p> </dd>
<dt id="PRIORITY">PRIORITY </dt>

<dt id="READABLE">READABLE </dt>

<dt id="SEEK_CUR">SEEK_CUR </dt>
<dd>
<p><a href="set"><code>Set</code></a> I/O position from the current position</p> </dd>
<dt id="SEEK_DATA">SEEK_DATA </dt>
<dd>
<p><a href="set"><code>Set</code></a> I/O position to the next location containing data</p> </dd>
<dt id="SEEK_END">SEEK_END </dt>
<dd>
<p><a href="set"><code>Set</code></a> I/O position from the end</p> </dd>
<dt id="SEEK_HOLE">SEEK_HOLE </dt>
<dd>
<p><a href="set"><code>Set</code></a> I/O position to the next hole</p> </dd>
<dt id="SEEK_SET">SEEK_SET </dt>
<dd>
<p><a href="set"><code>Set</code></a> I/O position from the beginning</p> </dd>
<dt id="WRITABLE">WRITABLE </dt>

</dl> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-binread"> <span class="method-callseq"> binread(name, [length [, offset]] ) → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="binread-source"> <pre class="c" data-language="c">static VALUE
rb_io_s_binread(int argc, VALUE *argv, VALUE io)
{
    VALUE offset;
    struct foreach_arg arg;
    enum {
        fmode = FMODE_READABLE|FMODE_BINMODE,
        oflags = O_RDONLY
#ifdef O_BINARY
                |O_BINARY
#endif
    };
    convconfig_t convconfig = {NULL, NULL, 0, Qnil};

    rb_scan_args(argc, argv, "12", NULL, NULL, &amp;offset);
    FilePathValue(argv[0]);
    convconfig.enc = rb_ascii8bit_encoding();
    arg.io = rb_io_open_generic(io, argv[0], oflags, fmode, &amp;convconfig, 0);
    if (NIL_P(arg.io)) return Qnil;
    arg.argv = argv+1;
    arg.argc = (argc &gt; 1) ? 1 : 0;
    if (!NIL_P(offset)) {
        struct seek_arg sarg;
        int state = 0;
        sarg.io = arg.io;
        sarg.offset = offset;
        sarg.mode = SEEK_SET;
        rb_protect(seek_before_access, (VALUE)&amp;sarg, &amp;state);
        if (state) {
            rb_io_close(arg.io);
            rb_jump_tag(state);
        }
    }
    return rb_ensure(io_s_read, (VALUE)&amp;arg, rb_io_close, arg.io);
}</pre> </div> <p>Opens the file, optionally seeks to the given <em>offset</em>, then returns <em>length</em> bytes (defaulting to the rest of the file). binread ensures the file is closed before returning. The open mode would be <code>"rb:ASCII-8BIT"</code>.</p> <pre class="ruby" data-language="ruby">IO.binread("testfile")           #=&gt; "This is line one\nThis is line two\nThis is line three\nAnd so on...\n"
IO.binread("testfile", 20)       #=&gt; "This is line one\nThi"
IO.binread("testfile", 20, 10)   #=&gt; "ne one\nThis is line "
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-binwrite"> <span class="method-callseq"> binwrite(name, string, [offset] ) → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> binwrite(name, string, [offset], open_args ) → integer </span> </div> <div class="method-description">
<div class="method-source-code" id="binwrite-source"> <pre class="c" data-language="c">static VALUE
rb_io_s_binwrite(int argc, VALUE *argv, VALUE io)
{
    return io_s_write(argc, argv, io, 1);
}</pre> </div> <p>Same as <a href="io#method-c-write"><code>IO.write</code></a> except opening the file in binary mode and ASCII-8BIT encoding (<code>"wb:ASCII-8BIT"</code>).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-console"> <span class="method-callseq"> console → #&lt;File:/dev/tty&gt; </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> console(sym, *args) </span> </div> <div class="method-description">
<div class="method-source-code" id="console-source"> <pre class="c" data-language="c">static VALUE
console_dev(int argc, VALUE *argv, VALUE klass)
{
    VALUE con = 0;
    rb_io_t *fptr;
    VALUE sym = 0;

    rb_check_arity(argc, 0, UNLIMITED_ARGUMENTS);
    if (argc) {
        Check_Type(sym = argv[0], T_SYMBOL);
    }
    if (klass == rb_cIO) klass = rb_cFile;
    if (rb_const_defined(klass, id_console)) {
        con = rb_const_get(klass, id_console);
        if (!RB_TYPE_P(con, T_FILE) ||
            (!(fptr = RFILE(con)-&gt;fptr) || GetReadFD(fptr) == -1)) {
            rb_const_remove(klass, id_console);
            con = 0;
        }
    }
    if (sym) {
        if (sym == ID2SYM(id_close) &amp;&amp; argc == 1) {
            if (con) {
                rb_io_close(con);
                rb_const_remove(klass, id_console);
                con = 0;
            }
            return Qnil;
        }
    }
    if (!con) {
        VALUE args[2];
#if defined HAVE_TERMIOS_H || defined HAVE_TERMIO_H || defined HAVE_SGTTY_H
# define CONSOLE_DEVICE "/dev/tty"
#elif defined _WIN32
# define CONSOLE_DEVICE "con$"
# define CONSOLE_DEVICE_FOR_READING "conin$"
# define CONSOLE_DEVICE_FOR_WRITING "conout$"
#endif
#ifndef CONSOLE_DEVICE_FOR_READING
# define CONSOLE_DEVICE_FOR_READING CONSOLE_DEVICE
#endif
#ifdef CONSOLE_DEVICE_FOR_WRITING
        VALUE out;
        rb_io_t *ofptr;
#endif
        int fd;

#ifdef CONSOLE_DEVICE_FOR_WRITING
        fd = rb_cloexec_open(CONSOLE_DEVICE_FOR_WRITING, O_RDWR, 0);
        if (fd &lt; 0) return Qnil;
        rb_update_max_fd(fd);
        args[1] = INT2FIX(O_WRONLY);
        args[0] = INT2NUM(fd);
        out = rb_class_new_instance(2, args, klass);
#endif
        fd = rb_cloexec_open(CONSOLE_DEVICE_FOR_READING, O_RDWR, 0);
        if (fd &lt; 0) {
#ifdef CONSOLE_DEVICE_FOR_WRITING
            rb_io_close(out);
#endif
            return Qnil;
        }
        rb_update_max_fd(fd);
        args[1] = INT2FIX(O_RDWR);
        args[0] = INT2NUM(fd);
        con = rb_class_new_instance(2, args, klass);
        GetOpenFile(con, fptr);
        fptr-&gt;pathv = rb_obj_freeze(rb_str_new2(CONSOLE_DEVICE));
#ifdef CONSOLE_DEVICE_FOR_WRITING
        GetOpenFile(out, ofptr);
        ofptr-&gt;pathv = fptr-&gt;pathv;
        fptr-&gt;tied_io_for_writing = out;
        ofptr-&gt;mode |= FMODE_SYNC;
#endif
        fptr-&gt;mode |= FMODE_SYNC;
        rb_const_set(klass, id_console, con);
    }
    if (sym) {
        return rb_f_send(argc, argv, con);
    }
    return con;
}</pre> </div> <p>Returns an <a href="file"><code>File</code></a> instance opened console.</p> <p>If <code>sym</code> is given, it will be sent to the opened console with <code>args</code> and the result will be returned instead of the console <a href="io"><code>IO</code></a> itself.</p> <p>You must require 'io/console' to use this method.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-c-console_size"> <span class="method-name">console_size</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="io#method-c-default_console_size">default_console_size</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-copy_stream"> <span class="method-callseq"> copy_stream(src, dst) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> copy_stream(src, dst, copy_length) </span> </div> <div class="method-heading"> <span class="method-callseq"> copy_stream(src, dst, copy_length, src_offset) </span> </div> <div class="method-description">
<div class="method-source-code" id="copy_stream-source"> <pre class="c" data-language="c">static VALUE
rb_io_s_copy_stream(int argc, VALUE *argv, VALUE io)
{
    VALUE src, dst, length, src_offset;
    struct copy_stream_struct st;

    MEMZERO(&amp;st, struct copy_stream_struct, 1);

    rb_scan_args(argc, argv, "22", &amp;src, &amp;dst, &amp;length, &amp;src_offset);

    st.src = src;
    st.dst = dst;

    if (NIL_P(length))
        st.copy_length = (off_t)-1;
    else
        st.copy_length = NUM2OFFT(length);

    if (NIL_P(src_offset))
        st.src_offset = (off_t)-1;
    else
        st.src_offset = NUM2OFFT(src_offset);

    rb_ensure(copy_stream_body, (VALUE)&amp;st, copy_stream_finalize, (VALUE)&amp;st);

    return OFFT2NUM(st.total);
}</pre> </div> <p><a href="io#method-c-copy_stream"><code>IO.copy_stream</code></a> copies <em>src</em> to <em>dst</em>. <em>src</em> and <em>dst</em> is either a filename or an IO-like object. IO-like object for <em>src</em> should have <a href="io#method-i-readpartial"><code>readpartial</code></a> or <a href="io#method-i-read"><code>read</code></a> method. IO-like object for <em>dst</em> should have <a href="io#method-i-write"><code>write</code></a> method. (Specialized mechanisms, such as sendfile system call, may be used on appropriate situation.)</p> <p>This method returns the number of bytes copied.</p> <p>If optional arguments are not given, the start position of the copy is the beginning of the filename or the current file offset of the <a href="io"><code>IO</code></a>. The end position of the copy is the end of file.</p> <p>If <em>copy_length</em> is given, No more than <em>copy_length</em> bytes are copied.</p> <p>If <em>src_offset</em> is given, it specifies the start position of the copy.</p> <p>When <em>src_offset</em> is specified and <em>src</em> is an <a href="io"><code>IO</code></a>, <a href="io#method-c-copy_stream"><code>IO.copy_stream</code></a> doesn't move the current file offset.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-default_console_size"> <span class="method-name">default_console_size</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="default_console_size-source"> <pre class="ruby" data-language="ruby"># File ext/io/console/lib/console/size.rb, line 3
def IO.default_console_size
  [
    ENV["LINES"].to_i.nonzero? || 25,
    ENV["COLUMNS"].to_i.nonzero? || 80,
  ]
end</pre> </div> <p>fallback to console window size</p>  </div> <div class="aliases"> Also aliased as: <a href="io#method-c-console_size">console_size</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-for_fd"> <span class="method-callseq"> for_fd(fd, mode [, opt]) → io </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="for_fd-source"> <pre class="c" data-language="c">static VALUE
rb_io_s_for_fd(int argc, VALUE *argv, VALUE klass)
{
    VALUE io = rb_obj_alloc(klass);
    rb_io_initialize(argc, argv, io);
    return io;
}</pre> </div> <p>Synonym for <a href="io#method-c-new"><code>IO.new</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-foreach"> <span class="method-callseq"> foreach(name, sep=$/ [, getline_args, open_args]) {|line| block } → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> foreach(name, limit [, getline_args, open_args]) {|line| block } → nil </span> </div> <div class="method-heading"> <span class="method-callseq"> foreach(name, sep, limit [, getline_args, open_args]) {|line| block } → nil </span> </div> <div class="method-heading"> <span class="method-callseq"> foreach(...) → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="foreach-source"> <pre class="c" data-language="c">static VALUE
rb_io_s_foreach(int argc, VALUE *argv, VALUE self)
{
    VALUE opt;
    int orig_argc = argc;
    struct foreach_arg arg;
    struct getline_arg garg;

    argc = rb_scan_args(argc, argv, "13:", NULL, NULL, NULL, NULL, &amp;opt);
    RETURN_ENUMERATOR(self, orig_argc, argv);
    extract_getline_args(argc-1, argv+1, &amp;garg);
    open_key_args(self, argc, argv, opt, &amp;arg);
    if (NIL_P(arg.io)) return Qnil;
    extract_getline_opts(opt, &amp;garg);
    check_getline_args(&amp;garg.rs, &amp;garg.limit, garg.io = arg.io);
    return rb_ensure(io_s_foreach, (VALUE)&amp;garg, rb_io_close, arg.io);
}</pre> </div> <p>Executes the block for every line in the named I/O port, where lines are separated by <em>sep</em>.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">IO.foreach("testfile") {|x| print "GOT ", x }
</pre> <p><em>produces:</em></p> <pre class="ruby" data-language="ruby">GOT This is line one
GOT This is line two
GOT This is line three
GOT And so on...
</pre> <p>If the last argument is a hash, it's the keyword argument to open. See <a href="io#method-c-readlines"><code>IO.readlines</code></a> for details about getline_args. And see also <a href="io#method-c-read"><code>IO.read</code></a> for details about open_args.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new(fd [, mode] [, opt]) → io </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
rb_io_initialize(int argc, VALUE *argv, VALUE io)
{
    VALUE fnum, vmode;
    rb_io_t *fp;
    int fd, fmode, oflags = O_RDONLY;
    convconfig_t convconfig;
    VALUE opt;
#if defined(HAVE_FCNTL) &amp;&amp; defined(F_GETFL)
    int ofmode;
#else
    struct stat st;
#endif


    argc = rb_scan_args(argc, argv, "11:", &amp;fnum, &amp;vmode, &amp;opt);
    rb_io_extract_modeenc(&amp;vmode, 0, opt, &amp;oflags, &amp;fmode, &amp;convconfig);

    fd = NUM2INT(fnum);
    if (rb_reserved_fd_p(fd)) {
        rb_raise(rb_eArgError, "The given fd is not accessible because RubyVM reserves it");
    }
#if defined(HAVE_FCNTL) &amp;&amp; defined(F_GETFL)
    oflags = fcntl(fd, F_GETFL);
    if (oflags == -1) rb_sys_fail(0);
#else
    if (fstat(fd, &amp;st) &lt; 0) rb_sys_fail(0);
#endif
    rb_update_max_fd(fd);
#if defined(HAVE_FCNTL) &amp;&amp; defined(F_GETFL)
    ofmode = rb_io_oflags_fmode(oflags);
    if (NIL_P(vmode)) {
        fmode = ofmode;
    }
    else if ((~ofmode &amp; fmode) &amp; FMODE_READWRITE) {
        VALUE error = INT2FIX(EINVAL);
        rb_exc_raise(rb_class_new_instance(1, &amp;error, rb_eSystemCallError));
    }
#endif
    if (!NIL_P(opt) &amp;&amp; rb_hash_aref(opt, sym_autoclose) == Qfalse) {
        fmode |= FMODE_PREP;
    }
    MakeOpenFile(io, fp);
    fp-&gt;self = io;
    fp-&gt;fd = fd;
    fp-&gt;mode = fmode;
    fp-&gt;encs = convconfig;
    clear_codeconv(fp);
    io_check_tty(fp);
    if (fileno(stdin) == fd)
        fp-&gt;stdio_file = stdin;
    else if (fileno(stdout) == fd)
        fp-&gt;stdio_file = stdout;
    else if (fileno(stderr) == fd)
        fp-&gt;stdio_file = stderr;

    if (fmode &amp; FMODE_SETENC_BY_BOM) io_set_encoding_by_bom(io);
    return io;
}</pre> </div> <p>Returns a new <a href="io"><code>IO</code></a> object (a stream) for the given integer file descriptor <code>fd</code> and <code>mode</code> string. <code>opt</code> may be used to specify parts of <code>mode</code> in a more readable fashion. See also <a href="io#method-c-sysopen"><code>IO.sysopen</code></a> and <a href="io#method-c-for_fd"><code>IO.for_fd</code></a>.</p> <p><a href="io#method-c-new"><code>IO.new</code></a> is called by various <a href="file"><code>File</code></a> and <a href="io"><code>IO</code></a> opening methods such as <a href="io#method-c-open"><code>IO::open</code></a>, <a href="kernel#method-i-open"><code>Kernel#open</code></a>, and <a href="file#method-c-open"><code>File::open</code></a>.</p> <h3 id="method-c-new-label-Open+Mode">Open Mode</h3> <p>When <code>mode</code> is an integer it must be combination of the modes defined in <a href="file/file/constants"><code>File::Constants</code></a> (<code>File::RDONLY</code>, <code>File::WRONLY|File::CREAT</code>). See the open(2) man page for more information.</p> <p>When <code>mode</code> is a string it must be in one of the following forms:</p> <pre>fmode
fmode ":" ext_enc
fmode ":" ext_enc ":" int_enc
fmode ":" "BOM|UTF-*"</pre> <p><code>fmode</code> is an <a href="io"><code>IO</code></a> open mode string, <code>ext_enc</code> is the external encoding for the <a href="io"><code>IO</code></a> and <code>int_enc</code> is the internal encoding.</p> <h4 id="method-c-new-label-IO+Open+Mode">
<a href="io"><code>IO</code></a> Open Mode</h4> <p>Ruby allows the following open modes:</p> <pre>"r"  Read-only, starts at beginning of file  (default mode).

"r+" Read-write, starts at beginning of file.

"w"  Write-only, truncates existing file
     to zero length or creates a new file for writing.

"w+" Read-write, truncates existing file to zero length
     or creates a new file for reading and writing.

"a"  Write-only, each write call appends data at end of file.
     Creates a new file for writing if file does not exist.

"a+" Read-write, each write call appends data at end of file.
     Creates a new file for reading and writing if file does
     not exist.</pre> <p>The following modes must be used separately, and along with one or more of the modes seen above.</p> <pre>"b"  Binary file mode
     Suppresses EOL &lt;-&gt; CRLF conversion on Windows. And
     sets external encoding to ASCII-8BIT unless explicitly
     specified.

"t"  Text file mode</pre> <p>The exclusive access mode (“x”) can be used together with “w” to ensure the file is created. Errno::EEXIST is raised when it already exists. It may not be supported with all kinds of streams (e.g. pipes).</p> <p>When the open mode of original <a href="io"><code>IO</code></a> is read only, the mode cannot be changed to be writable. Similarly, the open mode cannot be changed from write only to readable.</p> <p>When such a change is attempted the error is raised in different locations according to the platform.</p> <h3 id="method-c-new-label-IO+Encoding">
<a href="io"><code>IO</code></a> <a href="encoding"><code>Encoding</code></a>
</h3> <p>When <code>ext_enc</code> is specified, strings read will be tagged by the encoding when reading, and strings output will be converted to the specified encoding when writing.</p> <p>When <code>ext_enc</code> and <code>int_enc</code> are specified read strings will be converted from <code>ext_enc</code> to <code>int_enc</code> upon input, and written strings will be converted from <code>int_enc</code> to <code>ext_enc</code> upon output. See <a href="encoding"><code>Encoding</code></a> for further details of transcoding on input and output.</p> <p>If “BOM|UTF-8”, “BOM|UTF-16LE” or “BOM|UTF16-BE” are used, Ruby checks for a Unicode BOM in the input document to help determine the encoding. For UTF-16 encodings the file open mode must be binary. When present, the BOM is stripped and the external encoding from the BOM is used. When the BOM is missing the given Unicode encoding is used as <code>ext_enc</code>. (The BOM-set encoding option is case insensitive, so “bom|utf-8” is also valid.)</p> <h3 id="method-c-new-label-Options">Options</h3> <p><code>opt</code> can be used instead of <code>mode</code> for improved readability. The following keys are supported:</p> <dl class="rdoc-list note-list">
<dt>:mode </dt>
<dd> <p>Same as <code>mode</code> parameter</p> </dd>
<dt>:flags </dt>
<dd> <p>Specifies file open flags as integer. If <code>mode</code> parameter is given, this parameter will be bitwise-ORed.</p> </dd>
<dt>:external_encoding </dt>
<dd> <p>External encoding for the <a href="io"><code>IO</code></a>.</p> </dd>
<dt>:internal_encoding </dt>
<dd> <p>Internal encoding for the <a href="io"><code>IO</code></a>. “-” is a synonym for the default internal encoding.</p> <p>If the value is <code>nil</code> no conversion occurs.</p> </dd>
<dt>:encoding </dt>
<dd> <p>Specifies external and internal encodings as “extern:intern”.</p> </dd>
<dt>:textmode </dt>
<dd> <p>If the value is truth value, same as “t” in argument <code>mode</code>.</p> </dd>
<dt>:binmode </dt>
<dd> <p>If the value is truth value, same as “b” in argument <code>mode</code>.</p> </dd>
<dt>:autoclose </dt>
<dd> <p>If the value is <code>false</code>, the <code>fd</code> will be kept open after this <a href="io"><code>IO</code></a> instance gets finalized.</p> </dd>
</dl> <p>Also, <code>opt</code> can have same keys in <a href="string#method-i-encode"><code>String#encode</code></a> for controlling conversion between the external encoding and the internal encoding.</p> <h3 id="method-c-new-label-Example+1">Example 1</h3> <pre class="ruby" data-language="ruby">fd = IO.sysopen("/dev/tty", "w")
a = IO.new(fd,"w")
$stderr.puts "Hello"
a.puts "World"
</pre> <p>Produces:</p> <pre class="ruby" data-language="ruby">Hello
World
</pre> <h3 id="method-c-new-label-Example+2">Example 2</h3> <pre class="ruby" data-language="ruby">require 'fcntl'

fd = STDERR.fcntl(Fcntl::F_DUPFD)
io = IO.new(fd, mode: 'w:UTF-16LE', cr_newline: true)
io.puts "Hello, World!"

fd = STDERR.fcntl(Fcntl::F_DUPFD)
io = IO.new(fd, mode: 'w', cr_newline: true,
            external_encoding: Encoding::UTF_16LE)
io.puts "Hello, World!"
</pre> <p>Both of above print “Hello, World!” in UTF-16LE to standard error output with converting EOL generated by <a href="io#method-i-puts"><code>puts</code></a> to CR.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-open"> <span class="method-callseq"> open(fd, mode="r" [, opt]) → io </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> open(fd, mode="r" [, opt]) {|io| block } → obj </span> </div> <div class="method-description">
<div class="method-source-code" id="open-source"> <pre class="c" data-language="c">static VALUE
rb_io_s_open(int argc, VALUE *argv, VALUE klass)
{
    VALUE io = rb_class_new_instance_kw(argc, argv, klass, RB_PASS_CALLED_KEYWORDS);

    if (rb_block_given_p()) {
        return rb_ensure(rb_yield, io, io_close, io);
    }

    return io;
}</pre> </div> <p>With no associated block, <a href="io#method-c-open"><code>IO.open</code></a> is a synonym for <a href="io#method-c-new"><code>IO.new</code></a>. If the optional code block is given, it will be passed <code>io</code> as an argument, and the <a href="io"><code>IO</code></a> object will automatically be closed when the block terminates. In this instance, <a href="io#method-c-open"><code>IO.open</code></a> returns the value of the block.</p> <p>See <a href="io#method-c-new"><code>IO.new</code></a> for a description of the <code>fd</code>, <code>mode</code> and <code>opt</code> parameters.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-pipe"> <span class="method-callseq"> pipe → [read_io, write_io] </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> pipe(ext_enc) → [read_io, write_io] </span> </div> <div class="method-heading"> <span class="method-callseq"> pipe("ext_enc:int_enc" [, opt]) → [read_io, write_io] </span> </div> <div class="method-heading"> <span class="method-callseq"> pipe(ext_enc, int_enc [, opt]) → [read_io, write_io] </span> </div> <div class="method-heading"> <span class="method-callseq"> pipe(...) {|read_io, write_io| ... } </span> </div> <div class="method-description">
<div class="method-source-code" id="pipe-source"> <pre class="c" data-language="c">static VALUE
rb_io_s_pipe(int argc, VALUE *argv, VALUE klass)
{
    int pipes[2], state;
    VALUE r, w, args[3], v1, v2;
    VALUE opt;
    rb_io_t *fptr, *fptr2;
    struct io_encoding_set_args ies_args;
    int fmode = 0;
    VALUE ret;

    argc = rb_scan_args(argc, argv, "02:", &amp;v1, &amp;v2, &amp;opt);
    if (rb_pipe(pipes) &lt; 0)
        rb_sys_fail(0);

    args[0] = klass;
    args[1] = INT2NUM(pipes[0]);
    args[2] = INT2FIX(O_RDONLY);
    r = rb_protect(io_new_instance, (VALUE)args, &amp;state);
    if (state) {
        close(pipes[0]);
        close(pipes[1]);
        rb_jump_tag(state);
    }
    GetOpenFile(r, fptr);

    ies_args.fptr = fptr;
    ies_args.v1 = v1;
    ies_args.v2 = v2;
    ies_args.opt = opt;
    rb_protect(io_encoding_set_v, (VALUE)&amp;ies_args, &amp;state);
    if (state) {
        close(pipes[1]);
        io_close(r);
        rb_jump_tag(state);
    }

    args[1] = INT2NUM(pipes[1]);
    args[2] = INT2FIX(O_WRONLY);
    w = rb_protect(io_new_instance, (VALUE)args, &amp;state);
    if (state) {
        close(pipes[1]);
        if (!NIL_P(r)) rb_io_close(r);
        rb_jump_tag(state);
    }
    GetOpenFile(w, fptr2);
    rb_io_synchronized(fptr2);

    extract_binmode(opt, &amp;fmode);

    if ((fmode &amp; FMODE_BINMODE) &amp;&amp; v1 == Qnil) {
        rb_io_ascii8bit_binmode(r);
        rb_io_ascii8bit_binmode(w);
    }

#if DEFAULT_TEXTMODE
    if ((fptr-&gt;mode &amp; FMODE_TEXTMODE) &amp;&amp; (fmode &amp; FMODE_BINMODE)) {
        fptr-&gt;mode &amp;= ~FMODE_TEXTMODE;
        setmode(fptr-&gt;fd, O_BINARY);
    }
#if defined(RUBY_TEST_CRLF_ENVIRONMENT) || defined(_WIN32)
    if (fptr-&gt;encs.ecflags &amp; ECONV_DEFAULT_NEWLINE_DECORATOR) {
        fptr-&gt;encs.ecflags |= ECONV_UNIVERSAL_NEWLINE_DECORATOR;
    }
#endif
#endif
    fptr-&gt;mode |= fmode;
#if DEFAULT_TEXTMODE
    if ((fptr2-&gt;mode &amp; FMODE_TEXTMODE) &amp;&amp; (fmode &amp; FMODE_BINMODE)) {
        fptr2-&gt;mode &amp;= ~FMODE_TEXTMODE;
        setmode(fptr2-&gt;fd, O_BINARY);
    }
#endif
    fptr2-&gt;mode |= fmode;

    ret = rb_assoc_new(r, w);
    if (rb_block_given_p()) {
        VALUE rw[2];
        rw[0] = r;
        rw[1] = w;
        return rb_ensure(rb_yield, ret, pipe_pair_close, (VALUE)rw);
    }
    return ret;
}</pre> </div> <p>Creates a pair of pipe endpoints (connected to each other) and returns them as a two-element array of <a href="io"><code>IO</code></a> objects: <code>[</code> <em>read_io</em>, <em>write_io</em> <code>]</code>.</p> <p>If a block is given, the block is called and returns the value of the block. <em>read_io</em> and <em>write_io</em> are sent to the block as arguments. If read_io and write_io are not closed when the block exits, they are closed. i.e. closing read_io and/or write_io doesn't cause an error.</p> <p>Not available on all platforms.</p> <p>If an encoding (encoding name or encoding object) is specified as an optional argument, read string from pipe is tagged with the encoding specified. If the argument is a colon separated two encoding names “A:B”, the read string is converted from encoding A (external encoding) to encoding B (internal encoding), then tagged with B. If two optional arguments are specified, those must be encoding objects or encoding names, and the first one is the external encoding, and the second one is the internal encoding. If the external encoding and the internal encoding is specified, optional hash argument specify the conversion option.</p> <p>In the example below, the two processes close the ends of the pipe that they are not using. This is not just a cosmetic nicety. The read end of a pipe will not generate an end of file condition if there are any writers with the pipe still open. In the case of the parent process, the <code>rd.read</code> will never return if it does not first issue a <code>wr.close</code>.</p> <pre class="ruby" data-language="ruby">rd, wr = IO.pipe

if fork
  wr.close
  puts "Parent got: &lt;#{rd.read}&gt;"
  rd.close
  Process.wait
else
  rd.close
  puts "Sending message to parent"
  wr.write "Hi Dad"
  wr.close
end
</pre> <p><em>produces:</em></p> <pre>Sending message to parent
Parent got: &lt;Hi Dad&gt;</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-popen"> <span class="method-callseq"> popen([env,] cmd, mode="r" [, opt]) → io </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> popen([env,] cmd, mode="r" [, opt]) {|io| block } → obj </span> </div> <div class="method-description">
<div class="method-source-code" id="popen-source"> <pre class="c" data-language="c">static VALUE
rb_io_s_popen(int argc, VALUE *argv, VALUE klass)
{
    VALUE pname, pmode = Qnil, opt = Qnil, env = Qnil;

    if (argc &gt; 1 &amp;&amp; !NIL_P(opt = rb_check_hash_type(argv[argc-1]))) --argc;
    if (argc &gt; 1 &amp;&amp; !NIL_P(env = rb_check_hash_type(argv[0]))) --argc, ++argv;
    switch (argc) {
      case 2:
        pmode = argv[1];
      case 1:
        pname = argv[0];
        break;
      default:
        {
            int ex = !NIL_P(opt);
            rb_error_arity(argc + ex, 1 + ex, 2 + ex);
        }
    }
    return popen_finish(rb_io_popen(pname, pmode, env, opt), klass);
}</pre> </div> <p>Runs the specified command as a subprocess; the subprocess's standard input and output will be connected to the returned <a href="io"><code>IO</code></a> object.</p> <p>The PID of the started process can be obtained by <a href="io#method-i-pid"><code>IO#pid</code></a> method.</p> <p><em>cmd</em> is a string or an array as follows.</p> <pre>cmd:
  "-"                                      : fork
  commandline                              : command line string which is passed to a shell
  [env, cmdname, arg1, ..., opts]          : command name and zero or more arguments (no shell)
  [env, [cmdname, argv0], arg1, ..., opts] : command name, argv[0] and zero or more arguments (no shell)
(env and opts are optional.)</pre> <p>If <em>cmd</em> is a <code>String</code> “<code>-</code>'', then a new instance of Ruby is started as the subprocess.</p> <p>If <em>cmd</em> is an <code>Array</code> of <code>String</code>, then it will be used as the subprocess's <code>argv</code> bypassing a shell. The array can contain a hash at first for environments and a hash at last for options similar to <a href="kernel#method-i-spawn"><code>spawn</code></a>.</p> <p>The default mode for the new file object is “r'', but <em>mode</em> may be set to any of the modes listed in the description for class <a href="io"><code>IO</code></a>. The last argument <em>opt</em> qualifies <em>mode</em>.</p> <pre class="ruby" data-language="ruby"># set IO encoding
IO.popen("nkf -e filename", :external_encoding=&gt;"EUC-JP") {|nkf_io|
  euc_jp_string = nkf_io.read
}

# merge standard output and standard error using
# spawn option.  See the document of Kernel.spawn.
IO.popen(["ls", "/", :err=&gt;[:child, :out]]) {|ls_io|
  ls_result_with_error = ls_io.read
}

# spawn options can be mixed with IO options
IO.popen(["ls", "/"], :err=&gt;[:child, :out]) {|ls_io|
  ls_result_with_error = ls_io.read
}
</pre> <p>Raises exceptions which <a href="io#method-c-pipe"><code>IO.pipe</code></a> and <a href="kernel#method-i-spawn"><code>Kernel.spawn</code></a> raise.</p> <p>If a block is given, Ruby will run the command as a child connected to Ruby with a pipe. Ruby's end of the pipe will be passed as a parameter to the block. At the end of block, Ruby closes the pipe and sets <code>$?</code>. In this case <a href="io#method-c-popen"><code>IO.popen</code></a> returns the value of the block.</p> <p>If a block is given with a <em>cmd</em> of “<code>-</code>'', the block will be run in two separate processes: once in the parent, and once in a child. The parent process will be passed the pipe object as a parameter to the block, the child version of the block will be passed <code>nil</code>, and the child's standard in and standard out will be connected to the parent through the pipe. Not available on all platforms.</p> <pre class="ruby" data-language="ruby">f = IO.popen("uname")
p f.readlines
f.close
puts "Parent is #{Process.pid}"
IO.popen("date") {|f| puts f.gets }
IO.popen("-") {|f| $stderr.puts "#{Process.pid} is here, f is #{f.inspect}"}
p $?
IO.popen(%w"sed -e s|^|&lt;foo&gt;| -e s&amp;$&amp;;zot;&amp;", "r+") {|f|
  f.puts "bar"; f.close_write; puts f.gets
}
</pre> <p><em>produces:</em></p> <pre>["Linux\n"]
Parent is 21346
Thu Jan 15 22:41:19 JST 2009
21346 is here, f is #&lt;IO:fd 3&gt;
21352 is here, f is nil
#&lt;Process::Status: pid 21352 exit 0&gt;
&lt;foo&gt;bar;zot;</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-read"> <span class="method-callseq"> read(name, [length [, offset]] [, opt] ) → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="read-source"> <pre class="c" data-language="c">static VALUE
rb_io_s_read(int argc, VALUE *argv, VALUE io)
{
    VALUE opt, offset;
    struct foreach_arg arg;

    argc = rb_scan_args(argc, argv, "13:", NULL, NULL, &amp;offset, NULL, &amp;opt);
    open_key_args(io, argc, argv, opt, &amp;arg);
    if (NIL_P(arg.io)) return Qnil;
    if (!NIL_P(offset)) {
        struct seek_arg sarg;
        int state = 0;
        sarg.io = arg.io;
        sarg.offset = offset;
        sarg.mode = SEEK_SET;
        rb_protect(seek_before_access, (VALUE)&amp;sarg, &amp;state);
        if (state) {
            rb_io_close(arg.io);
            rb_jump_tag(state);
        }
        if (arg.argc == 2) arg.argc = 1;
    }
    return rb_ensure(io_s_read, (VALUE)&amp;arg, rb_io_close, arg.io);
}</pre> </div> <p>Opens the file, optionally seeks to the given <code>offset</code>, then returns <code>length</code> bytes (defaulting to the rest of the file). <a href="io#method-i-read"><code>read</code></a> ensures the file is closed before returning.</p> <p>If <code>name</code> starts with a pipe character (<code>"|"</code>), a subprocess is created in the same way as <a href="kernel#method-i-open"><code>Kernel#open</code></a>, and its output is returned.</p> <h3 id="method-c-read-label-Options">Options</h3> <p>The options hash accepts the following keys:</p> <dl class="rdoc-list note-list">
<dt>:encoding </dt>
<dd> <p>string or encoding</p> <p>Specifies the encoding of the read string. <code>:encoding</code> will be ignored if <code>length</code> is specified. See <a href="encoding#method-c-aliases"><code>Encoding.aliases</code></a> for possible encodings.</p> </dd>
<dt>:mode </dt>
<dd> <p>string or integer</p> <p>Specifies the <em>mode</em> argument for open(). It must start with an “r”, otherwise it will cause an error. See <a href="io#method-c-new"><code>IO.new</code></a> for the list of possible modes.</p> </dd>
<dt>:open_args </dt>
<dd> <p>array</p> <p>Specifies arguments for open() as an array. This key can not be used in combination with either <code>:encoding</code> or <code>:mode</code>.</p> </dd>
</dl> <p>Examples:</p> <pre class="ruby" data-language="ruby">IO.read("testfile")              #=&gt; "This is line one\nThis is line two\nThis is line three\nAnd so on...\n"
IO.read("testfile", 20)          #=&gt; "This is line one\nThi"
IO.read("testfile", 20, 10)      #=&gt; "ne one\nThis is line "
IO.read("binfile", mode: "rb")   #=&gt; "\xF7\x00\x00\x0E\x12"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-readlines"> <span class="method-callseq"> readlines(name, sep=$/ [, getline_args, open_args]) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> readlines(name, limit [, getline_args, open_args]) → array </span> </div> <div class="method-heading"> <span class="method-callseq"> readlines(name, sep, limit [, getline_args, open_args]) → array </span> </div> <div class="method-description">
<div class="method-source-code" id="readlines-source"> <pre class="c" data-language="c">static VALUE
rb_io_s_readlines(int argc, VALUE *argv, VALUE io)
{
    VALUE opt;
    struct foreach_arg arg;
    struct getline_arg garg;

    argc = rb_scan_args(argc, argv, "13:", NULL, NULL, NULL, NULL, &amp;opt);
    extract_getline_args(argc-1, argv+1, &amp;garg);
    open_key_args(io, argc, argv, opt, &amp;arg);
    if (NIL_P(arg.io)) return Qnil;
    extract_getline_opts(opt, &amp;garg);
    check_getline_args(&amp;garg.rs, &amp;garg.limit, garg.io = arg.io);
    return rb_ensure(io_s_readlines, (VALUE)&amp;garg, rb_io_close, arg.io);
}</pre> </div> <p>Reads the entire file specified by <em>name</em> as individual lines, and returns those lines in an array. Lines are separated by <em>sep</em>.</p> <pre class="ruby" data-language="ruby">a = IO.readlines("testfile")
a[0]   #=&gt; "This is line one\n"

b = IO.readlines("testfile", chomp: true)
b[0]   #=&gt; "This is line one"
</pre> <p>If the last argument is a hash, it's the keyword argument to open.</p> <h3 id="method-c-readlines-label-Options+for+getline">Options for getline</h3> <p>The options hash accepts the following keys:</p> <dl class="rdoc-list note-list">
<dt>:chomp </dt>
<dd> <p>When the optional <code>chomp</code> keyword argument has a true value, <code>\n</code>, <code>\r</code>, and <code>\r\n</code> will be removed from the end of each line.</p> </dd>
</dl> <p>See also <a href="io#method-c-read"><code>IO.read</code></a> for details about open_args.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-select"> <span class="method-callseq"> select(read_array [, write_array [, error_array [, timeout]]]) → array or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="select-source"> <pre class="c" data-language="c">static VALUE
rb_f_select(int argc, VALUE *argv, VALUE obj)
{
    VALUE timeout;
    struct select_args args;
    struct timeval timerec;
    int i;

    rb_scan_args(argc, argv, "13", &amp;args.read, &amp;args.write, &amp;args.except, &amp;timeout);
    if (NIL_P(timeout)) {
        args.timeout = 0;
    }
    else {
        timerec = rb_time_interval(timeout);
        args.timeout = &amp;timerec;
    }

    for (i = 0; i &lt; numberof(args.fdsets); ++i)
        rb_fd_init(&amp;args.fdsets[i]);

    return rb_ensure(select_call, (VALUE)&amp;args, select_end, (VALUE)&amp;args);
}</pre> </div> <p>Calls select(2) system call. It monitors given arrays of <a href="io"><code>IO</code></a> objects, waits until one or more of <a href="io"><code>IO</code></a> objects are ready for reading, are ready for writing, and have pending exceptions respectively, and returns an array that contains arrays of those <a href="io"><code>IO</code></a> objects. It will return <code>nil</code> if optional <em>timeout</em> value is given and no <a href="io"><code>IO</code></a> object is ready in <em>timeout</em> seconds.</p> <p><a href="io#method-c-select"><code>IO.select</code></a> peeks the buffer of <a href="io"><code>IO</code></a> objects for testing readability. If the <a href="io"><code>IO</code></a> buffer is not empty, <a href="io#method-c-select"><code>IO.select</code></a> immediately notifies readability. This “peek” only happens for <a href="io"><code>IO</code></a> objects. It does not happen for IO-like objects such as <a href="openssl/ssl/sslsocket"><code>OpenSSL::SSL::SSLSocket</code></a>.</p> <p>The best way to use <a href="io#method-c-select"><code>IO.select</code></a> is invoking it after nonblocking methods such as <a href="io#method-i-read_nonblock"><code>read_nonblock</code></a>, <a href="io#method-i-write_nonblock"><code>write_nonblock</code></a>, etc. The methods raise an exception which is extended by <a href="io/waitreadable"><code>IO::WaitReadable</code></a> or <a href="io/waitwritable"><code>IO::WaitWritable</code></a>. The modules notify how the caller should wait with <a href="io#method-c-select"><code>IO.select</code></a>. If <a href="io/waitreadable"><code>IO::WaitReadable</code></a> is raised, the caller should wait for reading. If <a href="io/waitwritable"><code>IO::WaitWritable</code></a> is raised, the caller should wait for writing.</p> <p>So, blocking read (<a href="io#method-i-readpartial"><code>readpartial</code></a>) can be emulated using <a href="io#method-i-read_nonblock"><code>read_nonblock</code></a> and <a href="io#method-c-select"><code>IO.select</code></a> as follows:</p> <pre class="ruby" data-language="ruby">begin
  result = io_like.read_nonblock(maxlen)
rescue IO::WaitReadable
  IO.select([io_like])
  retry
rescue IO::WaitWritable
  IO.select(nil, [io_like])
  retry
end
</pre> <p>Especially, the combination of nonblocking methods and <a href="io#method-c-select"><code>IO.select</code></a> is preferred for <a href="io"><code>IO</code></a> like objects such as <a href="openssl/ssl/sslsocket"><code>OpenSSL::SSL::SSLSocket</code></a>. It has <a href="io#method-i-to_io"><code>to_io</code></a> method to return underlying <a href="io"><code>IO</code></a> object. <a href="io#method-c-select"><code>IO.select</code></a> calls <a href="io#method-i-to_io"><code>to_io</code></a> to obtain the file descriptor to wait.</p> <p>This means that readability notified by <a href="io#method-c-select"><code>IO.select</code></a> doesn't mean readability from <a href="openssl/ssl/sslsocket"><code>OpenSSL::SSL::SSLSocket</code></a> object.</p> <p>The most likely situation is that <a href="openssl/ssl/sslsocket"><code>OpenSSL::SSL::SSLSocket</code></a> buffers some data. <a href="io#method-c-select"><code>IO.select</code></a> doesn't see the buffer. So <a href="io#method-c-select"><code>IO.select</code></a> can block when <a href="openssl/buffering#method-i-readpartial"><code>OpenSSL::SSL::SSLSocket#readpartial</code></a> doesn't block.</p> <p>However, several more complicated situations exist.</p> <p>SSL is a protocol which is sequence of records. The record consists of multiple bytes. So, the remote side of SSL sends a partial record, <a href="io#method-c-select"><code>IO.select</code></a> notifies readability but <a href="openssl/ssl/sslsocket"><code>OpenSSL::SSL::SSLSocket</code></a> cannot decrypt a byte and <a href="openssl/buffering#method-i-readpartial"><code>OpenSSL::SSL::SSLSocket#readpartial</code></a> will block.</p> <p>Also, the remote side can request SSL renegotiation which forces the local SSL engine to write some data. This means <a href="openssl/buffering#method-i-readpartial"><code>OpenSSL::SSL::SSLSocket#readpartial</code></a> may invoke <a href="io#method-i-write"><code>write</code></a> system call and it can block. In such a situation, <a href="openssl/buffering#method-i-read_nonblock"><code>OpenSSL::SSL::SSLSocket#read_nonblock</code></a> raises <a href="io/waitwritable"><code>IO::WaitWritable</code></a> instead of blocking. So, the caller should wait for ready for writability as above example.</p> <p>The combination of nonblocking methods and <a href="io#method-c-select"><code>IO.select</code></a> is also useful for streams such as tty, pipe socket socket when multiple processes read from a stream.</p> <p>Finally, Linux kernel developers don't guarantee that readability of select(2) means readability of following read(2) even for a single process. See select(2) manual on GNU/Linux system.</p> <p>Invoking <a href="io#method-c-select"><code>IO.select</code></a> before <a href="io#method-i-readpartial"><code>IO#readpartial</code></a> works well as usual. However it is not the best way to use <a href="io#method-c-select"><code>IO.select</code></a>.</p> <p>The writability notified by select(2) doesn't show how many bytes are writable. <a href="io#method-i-write"><code>IO#write</code></a> method blocks until given whole string is written. So, <code>IO#write(two or more bytes)</code> can block after writability is notified by <a href="io#method-c-select"><code>IO.select</code></a>. <a href="io#method-i-write_nonblock"><code>IO#write_nonblock</code></a> is required to avoid the blocking.</p> <p>Blocking write (<a href="io#method-i-write"><code>write</code></a>) can be emulated using <a href="io#method-i-write_nonblock"><code>write_nonblock</code></a> and <a href="io#method-c-select"><code>IO.select</code></a> as follows: <a href="io/waitreadable"><code>IO::WaitReadable</code></a> should also be rescued for SSL renegotiation in <a href="openssl/ssl/sslsocket"><code>OpenSSL::SSL::SSLSocket</code></a>.</p> <pre class="ruby" data-language="ruby">while 0 &lt; string.bytesize
  begin
    written = io_like.write_nonblock(string)
  rescue IO::WaitReadable
    IO.select([io_like])
    retry
  rescue IO::WaitWritable
    IO.select(nil, [io_like])
    retry
  end
  string = string.byteslice(written..-1)
end
</pre> <h3 id="method-c-select-label-Parameters">Parameters</h3> <dl class="rdoc-list note-list">
<dt>read_array </dt>
<dd> <p>an array of <a href="io"><code>IO</code></a> objects that wait until ready for read</p> </dd>
<dt>write_array </dt>
<dd> <p>an array of <a href="io"><code>IO</code></a> objects that wait until ready for write</p> </dd>
<dt>error_array </dt>
<dd> <p>an array of <a href="io"><code>IO</code></a> objects that wait for exceptions</p> </dd>
<dt>timeout </dt>
<dd> <p>a numeric value in second</p> </dd>
</dl> <h3 id="method-c-select-label-Example">Example</h3> <pre class="ruby" data-language="ruby">rp, wp = IO.pipe
mesg = "ping "
100.times {
  # IO.select follows IO#read.  Not the best way to use IO.select.
  rs, ws, = IO.select([rp], [wp])
  if r = rs[0]
    ret = r.read(5)
    print ret
    case ret
    when /ping/
      mesg = "pong\n"
    when /pong/
      mesg = "ping "
    end
  end
  if w = ws[0]
    w.write(mesg)
  end
}
</pre> <p><em>produces:</em></p> <pre class="ruby" data-language="ruby">ping pong
ping pong
ping pong
(snipped)
ping
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-sysopen"> <span class="method-callseq"> sysopen(path, [mode, [perm]]) → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="sysopen-source"> <pre class="c" data-language="c">static VALUE
rb_io_s_sysopen(int argc, VALUE *argv, VALUE _)
{
    VALUE fname, vmode, vperm;
    VALUE intmode;
    int oflags, fd;
    mode_t perm;

    rb_scan_args(argc, argv, "12", &amp;fname, &amp;vmode, &amp;vperm);
    FilePathValue(fname);

    if (NIL_P(vmode))
        oflags = O_RDONLY;
    else if (!NIL_P(intmode = rb_check_to_integer(vmode, "to_int")))
        oflags = NUM2INT(intmode);
    else {
        SafeStringValue(vmode);
        oflags = rb_io_modestr_oflags(StringValueCStr(vmode));
    }
    if (NIL_P(vperm)) perm = 0666;
    else              perm = NUM2MODET(vperm);

    RB_GC_GUARD(fname) = rb_str_new4(fname);
    fd = rb_sysopen(fname, oflags, perm);
    return INT2NUM(fd);
}</pre> </div> <p>Opens the given path, returning the underlying file descriptor as a <a href="integer"><code>Integer</code></a>.</p> <pre class="ruby" data-language="ruby">IO.sysopen("testfile")   #=&gt; 3
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-try_convert"> <span class="method-callseq"> try_convert(obj) → io or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="try_convert-source"> <pre class="c" data-language="c">static VALUE
rb_io_s_try_convert(VALUE dummy, VALUE io)
{
    return rb_io_check_io(io);
}</pre> </div> <p>Try to convert <em>obj</em> into an <a href="io"><code>IO</code></a>, using <a href="io#method-i-to_io"><code>to_io</code></a> method. Returns converted <a href="io"><code>IO</code></a> or <code>nil</code> if <em>obj</em> cannot be converted for any reason.</p> <pre class="ruby" data-language="ruby">IO.try_convert(STDOUT)     #=&gt; STDOUT
IO.try_convert("STDOUT")   #=&gt; nil

require 'zlib'
f = open("/tmp/zz.gz")       #=&gt; #&lt;File:/tmp/zz.gz&gt;
z = Zlib::GzipReader.open(f) #=&gt; #&lt;Zlib::GzipReader:0x81d8744&gt;
IO.try_convert(z)            #=&gt; #&lt;File:/tmp/zz.gz&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-write"> <span class="method-callseq"> write(name, string [, offset]) → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> write(name, string [, offset] [, opt]) → integer </span> </div> <div class="method-description">
<div class="method-source-code" id="write-source"> <pre class="c" data-language="c">static VALUE
rb_io_s_write(int argc, VALUE *argv, VALUE io)
{
    return io_s_write(argc, argv, io, 0);
}</pre> </div> <p>Opens the file, optionally seeks to the given <em>offset</em>, writes <em>string</em>, then returns the length written. <a href="io#method-i-write"><code>write</code></a> ensures the file is closed before returning. If <em>offset</em> is not given in write mode, the file is truncated. Otherwise, it is not truncated.</p> <pre class="ruby" data-language="ruby">IO.write("testfile", "0123456789", 20)  #=&gt; 10
# File could contain:  "This is line one\nThi0123456789two\nThis is line three\nAnd so on...\n"
IO.write("testfile", "0123456789")      #=&gt; 10
# File would now read: "0123456789"
</pre> <p>If the last argument is a hash, it specifies options for the internal open(). It accepts the following keys:</p> <dl class="rdoc-list note-list">
<dt>:encoding </dt>
<dd> <p>string or encoding</p> <p>Specifies the encoding of the read string. See <a href="encoding#method-c-aliases"><code>Encoding.aliases</code></a> for possible encodings.</p> </dd>
<dt>:mode </dt>
<dd> <p>string or integer</p> <p>Specifies the <em>mode</em> argument for open(). It must start with “w”, “a”, or “r+”, otherwise it will cause an error. See <a href="io#method-c-new"><code>IO.new</code></a> for the list of possible modes.</p> </dd>
<dt>:perm </dt>
<dd> <p>integer</p> <p>Specifies the <em>perm</em> argument for open().</p> </dd>
<dt>:open_args </dt>
<dd> <p>array</p> <p>Specifies arguments for open() as an array. This key can not be used in combination with other keys.</p> </dd>
</dl>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-3C-3C"> <span class="method-callseq"> ios &lt;&lt; obj → ios </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3C-3C-source"> <pre class="c" data-language="c">VALUE
rb_io_addstr(VALUE io, VALUE str)
{
    rb_io_write(io, str);
    return io;
}</pre> </div> <p><a href="string"><code>String</code></a> Output—Writes <em>obj</em> to <em>ios</em>. <em>obj</em> will be converted to a string using <code>to_s</code>.</p> <pre class="ruby" data-language="ruby">$stdout &lt;&lt; "Hello " &lt;&lt; "world!\n"
</pre> <p><em>produces:</em></p> <pre class="ruby" data-language="ruby">Hello world!
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-advise"> <span class="method-callseq"> advise(advice, offset=0, len=0) → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="advise-source"> <pre class="c" data-language="c">static VALUE
rb_io_advise(int argc, VALUE *argv, VALUE io)
{
    VALUE advice, offset, len;
    off_t off, l;
    rb_io_t *fptr;

    rb_scan_args(argc, argv, "12", &amp;advice, &amp;offset, &amp;len);
    advice_arg_check(advice);

    io = GetWriteIO(io);
    GetOpenFile(io, fptr);

    off = NIL_P(offset) ? 0 : NUM2OFFT(offset);
    l   = NIL_P(len)    ? 0 : NUM2OFFT(len);

#ifdef HAVE_POSIX_FADVISE
    return do_io_advise(fptr, advice, off, l);
#else
    ((void)off, (void)l);       /* Ignore all hint */
    return Qnil;
#endif
}</pre> </div> <p>Announce an intention to access data from the current file in a specific pattern. On platforms that do not support the <em>posix_fadvise(2)</em> system call, this method is a no-op.</p> <p><em>advice</em> is one of the following symbols:</p> <dl class="rdoc-list note-list">
<dt>:normal </dt>
<dd> <p>No advice to give; the default assumption for an open file.</p> </dd>
<dt>:sequential </dt>
<dd> <p>The data will be accessed sequentially with lower offsets read before higher ones.</p> </dd>
<dt>:random </dt>
<dd> <p>The data will be accessed in random order.</p> </dd>
<dt>:willneed </dt>
<dd> <p>The data will be accessed in the near future.</p> </dd>
<dt>:dontneed </dt>
<dd> <p>The data will not be accessed in the near future.</p> </dd>
<dt>:noreuse </dt>
<dd> <p>The data will only be accessed once.</p> </dd>
</dl> <p>The semantics of a piece of advice are platform-dependent. See <em>man 2 posix_fadvise</em> for details.</p> <p>“data” means the region of the current file that begins at <em>offset</em> and extends for <em>len</em> bytes. If <em>len</em> is 0, the region ends at the last byte of the file. By default, both <em>offset</em> and <em>len</em> are 0, meaning that the advice applies to the entire file.</p> <p>If an error occurs, one of the following exceptions will be raised:</p> <dl class="rdoc-list note-list">
<dt>
<a href="ioerror"><code>IOError</code></a> </dt>
<dd> <p>The <a href="io"><code>IO</code></a> stream is closed.</p> </dd>
<dt>Errno::EBADF </dt>
<dd> <p>The file descriptor of the current file is invalid.</p> </dd>
<dt>Errno::EINVAL </dt>
<dd> <p>An invalid value for <em>advice</em> was given.</p> </dd>
<dt>Errno::ESPIPE </dt>
<dd> <p>The file descriptor of the current file refers to a FIFO or pipe. (Linux raises Errno::EINVAL in this case).</p> </dd>
<dt>
<a href="typeerror"><code>TypeError</code></a> </dt>
<dd> <p>Either <em>advice</em> was not a <a href="symbol"><code>Symbol</code></a>, or one of the other arguments was not an <a href="integer"><code>Integer</code></a>.</p> </dd>
<dt>
<a href="rangeerror"><code>RangeError</code></a> </dt>
<dd> <p>One of the arguments given was too big/small.</p> </dd>
<dt>This list is not exhaustive; other <a href="errno"><code>Errno</code></a> </dt>
<dd> <p>exceptions are also possible.</p> </dd>
</dl>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-autoclose-3D"> <span class="method-callseq"> autoclose = bool → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="autoclose-3D-source"> <pre class="c" data-language="c">static VALUE
rb_io_set_autoclose(VALUE io, VALUE autoclose)
{
    rb_io_t *fptr;
    GetOpenFile(io, fptr);
    if (!RTEST(autoclose))
        fptr-&gt;mode |= FMODE_PREP;
    else
        fptr-&gt;mode &amp;= ~FMODE_PREP;
    return autoclose;
}</pre> </div> <p>Sets auto-close flag.</p> <pre class="ruby" data-language="ruby">f = open("/dev/null")
IO.for_fd(f.fileno)
# ...
f.gets # may cause Errno::EBADF

f = open("/dev/null")
IO.for_fd(f.fileno).autoclose = false
# ...
f.gets # won't cause Errno::EBADF
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-autoclose-3F"> <span class="method-callseq"> autoclose? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="autoclose-3F-source"> <pre class="c" data-language="c">static VALUE
rb_io_autoclose_p(VALUE io)
{
    rb_io_t *fptr = RFILE(io)-&gt;fptr;
    rb_io_check_closed(fptr);
    return (fptr-&gt;mode &amp; FMODE_PREP) ? Qfalse : Qtrue;
}</pre> </div> <p>Returns <code>true</code> if the underlying file descriptor of <em>ios</em> will be closed automatically at its finalization, otherwise <code>false</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-beep"> <span class="method-name">beep</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="beep-source"> <pre class="c" data-language="c">static VALUE
console_beep(VALUE io)
{
    rb_io_t *fptr;
    int fd;

    GetOpenFile(io, fptr);
    fd = GetWriteFD(fptr);
#ifdef _WIN32
    (void)fd;
    MessageBeep(0);
#else
    if (write(fd, "\a", 1) &lt; 0)
        sys_fail_fptr(fptr);
#endif
    return io;
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-binmode"> <span class="method-callseq"> binmode → ios </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="binmode-source"> <pre class="c" data-language="c">static VALUE
rb_io_binmode_m(VALUE io)
{
    VALUE write_io;

    rb_io_ascii8bit_binmode(io);

    write_io = GetWriteIO(io);
    if (write_io != io)
        rb_io_ascii8bit_binmode(write_io);
    return io;
}</pre> </div> <p>Puts <em>ios</em> into binary mode. Once a stream is in binary mode, it cannot be reset to nonbinary mode.</p> <ul>
<li> <p>newline conversion disabled</p> </li>
<li> <p>encoding conversion disabled</p> </li>
<li> <p>content is treated as ASCII-8BIT</p> </li>
</ul>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-binmode-3F"> <span class="method-callseq"> binmode? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="binmode-3F-source"> <pre class="c" data-language="c">static VALUE
rb_io_binmode_p(VALUE io)
{
    rb_io_t *fptr;
    GetOpenFile(io, fptr);
    return fptr-&gt;mode &amp; FMODE_BINMODE ? Qtrue : Qfalse;
}</pre> </div> <p>Returns <code>true</code> if <em>ios</em> is binmode.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-check_winsize_changed"> <span class="method-name">check_winsize_changed</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="check_winsize_changed-source"> <pre class="c" data-language="c">static VALUE
console_check_winsize_changed(VALUE io)
{
    rb_io_t *fptr;
    HANDLE h;
    DWORD num;

    GetOpenFile(io, fptr);
    h = (HANDLE)rb_w32_get_osfhandle(GetReadFD(fptr));
    while (GetNumberOfConsoleInputEvents(h, &amp;num) &amp;&amp; num &gt; 0) {
        INPUT_RECORD rec;
        if (ReadConsoleInput(h, &amp;rec, 1, &amp;num)) {
            if (rec.EventType == WINDOW_BUFFER_SIZE_EVENT) {
                rb_yield(Qnil);
            }
        }
    }
    return io;
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-clear_screen"> <span class="method-name">clear_screen</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="clear_screen-source"> <pre class="c" data-language="c">static VALUE
console_clear_screen(VALUE io)
{
    console_erase_screen(io, INT2FIX(2));
    console_goto(io, INT2FIX(0), INT2FIX(0));
    return io;
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-close"> <span class="method-callseq"> close → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="close-source"> <pre class="c" data-language="c">static VALUE
rb_io_close_m(VALUE io)
{
    rb_io_t *fptr = rb_io_get_fptr(io);
    if (fptr-&gt;fd &lt; 0) {
        return Qnil;
    }
    rb_io_close(io);
    return Qnil;
}</pre> </div> <p>Closes <em>ios</em> and flushes any pending writes to the operating system. The stream is unavailable for any further data operations; an <a href="ioerror"><code>IOError</code></a> is raised if such an attempt is made. I/O streams are automatically closed when they are claimed by the garbage collector.</p> <p>If <em>ios</em> is opened by <a href="io#method-c-popen"><code>IO.popen</code></a>, <a href="io#method-i-close"><code>close</code></a> sets <code>$?</code>.</p> <p>Calling this method on closed <a href="io"><code>IO</code></a> object is just ignored since Ruby 2.3.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-close_on_exec-3D"> <span class="method-callseq"> close_on_exec = bool → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="close_on_exec-3D-source"> <pre class="c" data-language="c">static VALUE
rb_io_set_close_on_exec(VALUE io, VALUE arg)
{
    int flag = RTEST(arg) ? FD_CLOEXEC : 0;
    rb_io_t *fptr;
    VALUE write_io;
    int fd, ret;

    write_io = GetWriteIO(io);
    if (io != write_io) {
        GetOpenFile(write_io, fptr);
        if (fptr &amp;&amp; 0 &lt;= (fd = fptr-&gt;fd)) {
            if ((ret = fcntl(fptr-&gt;fd, F_GETFD)) == -1) rb_sys_fail_path(fptr-&gt;pathv);
            if ((ret &amp; FD_CLOEXEC) != flag) {
                ret = (ret &amp; ~FD_CLOEXEC) | flag;
                ret = fcntl(fd, F_SETFD, ret);
                if (ret != 0) rb_sys_fail_path(fptr-&gt;pathv);
            }
        }

    }

    GetOpenFile(io, fptr);
    if (fptr &amp;&amp; 0 &lt;= (fd = fptr-&gt;fd)) {
        if ((ret = fcntl(fd, F_GETFD)) == -1) rb_sys_fail_path(fptr-&gt;pathv);
        if ((ret &amp; FD_CLOEXEC) != flag) {
            ret = (ret &amp; ~FD_CLOEXEC) | flag;
            ret = fcntl(fd, F_SETFD, ret);
            if (ret != 0) rb_sys_fail_path(fptr-&gt;pathv);
        }
    }
    return Qnil;
}</pre> </div> <p>Sets a close-on-exec flag.</p> <pre class="ruby" data-language="ruby">f = open("/dev/null")
f.close_on_exec = true
system("cat", "/proc/self/fd/#{f.fileno}") # cat: /proc/self/fd/3: No such file or directory
f.closed?                #=&gt; false
</pre> <p>Ruby sets close-on-exec flags of all file descriptors by default since Ruby 2.0.0. So you don't need to set by yourself. Also, unsetting a close-on-exec flag can cause file descriptor leak if another thread use fork() and exec() (via system() method for example). If you really needs file descriptor inheritance to child process, use spawn()'s argument such as fd=&gt;fd.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-close_on_exec-3F"> <span class="method-callseq"> close_on_exec? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="close_on_exec-3F-source"> <pre class="c" data-language="c">static VALUE
rb_io_close_on_exec_p(VALUE io)
{
    rb_io_t *fptr;
    VALUE write_io;
    int fd, ret;

    write_io = GetWriteIO(io);
    if (io != write_io) {
        GetOpenFile(write_io, fptr);
        if (fptr &amp;&amp; 0 &lt;= (fd = fptr-&gt;fd)) {
            if ((ret = fcntl(fd, F_GETFD)) == -1) rb_sys_fail_path(fptr-&gt;pathv);
            if (!(ret &amp; FD_CLOEXEC)) return Qfalse;
        }
    }

    GetOpenFile(io, fptr);
    if (fptr &amp;&amp; 0 &lt;= (fd = fptr-&gt;fd)) {
        if ((ret = fcntl(fd, F_GETFD)) == -1) rb_sys_fail_path(fptr-&gt;pathv);
        if (!(ret &amp; FD_CLOEXEC)) return Qfalse;
    }
    return Qtrue;
}</pre> </div> <p>Returns <code>true</code> if <em>ios</em> will be closed on exec.</p> <pre class="ruby" data-language="ruby">f = open("/dev/null")
f.close_on_exec?                 #=&gt; false
f.close_on_exec = true
f.close_on_exec?                 #=&gt; true
f.close_on_exec = false
f.close_on_exec?                 #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-close_read"> <span class="method-callseq"> close_read → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="close_read-source"> <pre class="c" data-language="c">static VALUE
rb_io_close_read(VALUE io)
{
    rb_io_t *fptr;
    VALUE write_io;

    fptr = rb_io_get_fptr(rb_io_taint_check(io));
    if (fptr-&gt;fd &lt; 0) return Qnil;
    if (is_socket(fptr-&gt;fd, fptr-&gt;pathv)) {
#ifndef SHUT_RD
# define SHUT_RD 0
#endif
        if (shutdown(fptr-&gt;fd, SHUT_RD) &lt; 0)
            rb_sys_fail_path(fptr-&gt;pathv);
        fptr-&gt;mode &amp;= ~FMODE_READABLE;
        if (!(fptr-&gt;mode &amp; FMODE_WRITABLE))
            return rb_io_close(io);
        return Qnil;
    }

    write_io = GetWriteIO(io);
    if (io != write_io) {
        rb_io_t *wfptr;
        wfptr = rb_io_get_fptr(rb_io_taint_check(write_io));
        wfptr-&gt;pid = fptr-&gt;pid;
        fptr-&gt;pid = 0;
        RFILE(io)-&gt;fptr = wfptr;
        /* bind to write_io temporarily to get rid of memory/fd leak */
        fptr-&gt;tied_io_for_writing = 0;
        RFILE(write_io)-&gt;fptr = fptr;
        rb_io_fptr_cleanup(fptr, FALSE);
        /* should not finalize fptr because another thread may be reading it */
        return Qnil;
    }

    if ((fptr-&gt;mode &amp; (FMODE_DUPLEX|FMODE_WRITABLE)) == FMODE_WRITABLE) {
        rb_raise(rb_eIOError, "closing non-duplex IO for reading");
    }
    return rb_io_close(io);
}</pre> </div> <p>Closes the read end of a duplex I/O stream (i.e., one that contains both a read and a write stream, such as a pipe). Will raise an <a href="ioerror"><code>IOError</code></a> if the stream is not duplexed.</p> <pre class="ruby" data-language="ruby">f = IO.popen("/bin/sh","r+")
f.close_read
f.readlines
</pre> <p><em>produces:</em></p> <pre>prog.rb:3:in `readlines': not opened for reading (IOError)
 from prog.rb:3</pre> <p>Calling this method on closed <a href="io"><code>IO</code></a> object is just ignored since Ruby 2.3.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-close_write"> <span class="method-callseq"> close_write → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="close_write-source"> <pre class="c" data-language="c">static VALUE
rb_io_close_write(VALUE io)
{
    rb_io_t *fptr;
    VALUE write_io;

    write_io = GetWriteIO(io);
    fptr = rb_io_get_fptr(rb_io_taint_check(write_io));
    if (fptr-&gt;fd &lt; 0) return Qnil;
    if (is_socket(fptr-&gt;fd, fptr-&gt;pathv)) {
#ifndef SHUT_WR
# define SHUT_WR 1
#endif
        if (shutdown(fptr-&gt;fd, SHUT_WR) &lt; 0)
            rb_sys_fail_path(fptr-&gt;pathv);
        fptr-&gt;mode &amp;= ~FMODE_WRITABLE;
        if (!(fptr-&gt;mode &amp; FMODE_READABLE))
            return rb_io_close(write_io);
        return Qnil;
    }

    if ((fptr-&gt;mode &amp; (FMODE_DUPLEX|FMODE_READABLE)) == FMODE_READABLE) {
        rb_raise(rb_eIOError, "closing non-duplex IO for writing");
    }

    if (io != write_io) {
        fptr = rb_io_get_fptr(rb_io_taint_check(io));
        fptr-&gt;tied_io_for_writing = 0;
    }
    rb_io_close(write_io);
    return Qnil;
}</pre> </div> <p>Closes the write end of a duplex I/O stream (i.e., one that contains both a read and a write stream, such as a pipe). Will raise an <a href="ioerror"><code>IOError</code></a> if the stream is not duplexed.</p> <pre class="ruby" data-language="ruby">f = IO.popen("/bin/sh","r+")
f.close_write
f.print "nowhere"
</pre> <p><em>produces:</em></p> <pre>prog.rb:3:in `write': not opened for writing (IOError)
 from prog.rb:3:in `print'
 from prog.rb:3</pre> <p>Calling this method on closed <a href="io"><code>IO</code></a> object is just ignored since Ruby 2.3.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-closed-3F"> <span class="method-callseq"> closed? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="closed-3F-source"> <pre class="c" data-language="c">static VALUE
rb_io_closed(VALUE io)
{
    rb_io_t *fptr;
    VALUE write_io;
    rb_io_t *write_fptr;

    write_io = GetWriteIO(io);
    if (io != write_io) {
        write_fptr = RFILE(write_io)-&gt;fptr;
        if (write_fptr &amp;&amp; 0 &lt;= write_fptr-&gt;fd) {
            return Qfalse;
        }
    }

    fptr = rb_io_get_fptr(io);
    return 0 &lt;= fptr-&gt;fd ? Qfalse : Qtrue;
}</pre> </div> <p>Returns <code>true</code> if <em>ios</em> is completely closed (for duplex streams, both reader and writer), <code>false</code> otherwise.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
f.close         #=&gt; nil
f.closed?       #=&gt; true
f = IO.popen("/bin/sh","r+")
f.close_write   #=&gt; nil
f.closed?       #=&gt; false
f.close_read    #=&gt; nil
f.closed?       #=&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-console_mode"> <span class="method-callseq"> console_mode → mode </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="console_mode-source"> <pre class="c" data-language="c">static VALUE
console_conmode_get(VALUE io)
{
    conmode t;
    rb_io_t *fptr;
    int fd;

    GetOpenFile(io, fptr);
    fd = GetReadFD(fptr);
    if (!getattr(fd, &amp;t)) sys_fail_fptr(fptr);

    return conmode_new(cConmode, &amp;t);
}</pre> </div> <p>Returns a data represents the current console mode.</p> <p>You must require 'io/console' to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-console_mode-3D"> <span class="method-callseq"> console_mode = mode </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="console_mode-3D-source"> <pre class="c" data-language="c">static VALUE
console_conmode_set(VALUE io, VALUE mode)
{
    conmode *t, r;
    rb_io_t *fptr;
    int fd;

    TypedData_Get_Struct(mode, conmode, &amp;conmode_type, t);
    r = *t;
    GetOpenFile(io, fptr);
    fd = GetReadFD(fptr);
    if (!setattr(fd, &amp;r)) sys_fail_fptr(fptr);

    return mode;
}</pre> </div> <p>Sets the console mode to <code>mode</code>.</p> <p>You must require 'io/console' to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-cooked"> <span class="method-callseq"> cooked {|io| } </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="cooked-source"> <pre class="c" data-language="c">static VALUE
console_cooked(VALUE io)
{
    return ttymode(io, rb_yield, io, set_cookedmode, NULL);
}</pre> </div> <p>Yields <code>self</code> within cooked mode.</p> <pre class="ruby" data-language="ruby">STDIN.cooked(&amp;:gets)
</pre> <p>will read and return a line with echo back and line editing.</p> <p>You must require 'io/console' to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-cooked-21"> <span class="method-callseq"> cooked! </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="cooked-21-source"> <pre class="c" data-language="c">static VALUE
console_set_cooked(VALUE io)
{
    conmode t;
    rb_io_t *fptr;
    int fd;

    GetOpenFile(io, fptr);
    fd = GetReadFD(fptr);
    if (!getattr(fd, &amp;t)) sys_fail_fptr(fptr);
    set_cookedmode(&amp;t, NULL);
    if (!setattr(fd, &amp;t)) sys_fail_fptr(fptr);
    return io;
}</pre> </div> <p>Enables cooked mode.</p> <p>If the terminal mode needs to be back, use io.cooked { … }.</p> <p>You must require 'io/console' to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-cursor"> <span class="method-name">cursor</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="cursor-source"> <pre class="c" data-language="c">static VALUE
console_cursor_pos(VALUE io)
{
    rb_io_t *fptr;
    int fd;
    rb_console_size_t ws;

    GetOpenFile(io, fptr);
    fd = GetWriteFD(fptr);
    if (!GetConsoleScreenBufferInfo((HANDLE)rb_w32_get_osfhandle(fd), &amp;ws)) {
        rb_syserr_fail(LAST_ERROR, 0);
    }
    return rb_assoc_new(UINT2NUM(ws.dwCursorPosition.Y), UINT2NUM(ws.dwCursorPosition.X));
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-cursor-3D"> <span class="method-name">cursor=</span><span class="method-args">(p1)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="cursor-3D-source"> <pre class="c" data-language="c">static VALUE
console_cursor_set(VALUE io, VALUE cpos)
{
    cpos = rb_convert_type(cpos, T_ARRAY, "Array", "to_ary");
    if (RARRAY_LEN(cpos) != 2) rb_raise(rb_eArgError, "expected 2D coordinate");
    return console_goto(io, RARRAY_AREF(cpos, 0), RARRAY_AREF(cpos, 1));
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-cursor_down"> <span class="method-name">cursor_down</span><span class="method-args">(p1)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="cursor_down-source"> <pre class="c" data-language="c">static VALUE
console_cursor_down(VALUE io, VALUE val)
{
    return console_move(io, +NUM2INT(val), 0);
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-cursor_left"> <span class="method-name">cursor_left</span><span class="method-args">(p1)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="cursor_left-source"> <pre class="c" data-language="c">static VALUE
console_cursor_left(VALUE io, VALUE val)
{
    return console_move(io, 0, -NUM2INT(val));
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-cursor_right"> <span class="method-name">cursor_right</span><span class="method-args">(p1)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="cursor_right-source"> <pre class="c" data-language="c">static VALUE
console_cursor_right(VALUE io, VALUE val)
{
    return console_move(io, 0, +NUM2INT(val));
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-cursor_up"> <span class="method-name">cursor_up</span><span class="method-args">(p1)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="cursor_up-source"> <pre class="c" data-language="c">static VALUE
console_cursor_up(VALUE io, VALUE val)
{
    return console_move(io, -NUM2INT(val), 0);
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each"> <span class="method-callseq"> each(sep=$/ [, getline_args]) {|line| block } → ios </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each(limit [, getline_args]) {|line| block } → ios </span> </div> <div class="method-heading"> <span class="method-callseq"> each(sep, limit [, getline_args]) {|line| block } → ios </span> </div> <div class="method-heading"> <span class="method-callseq"> each(...) → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each-source"> <pre class="c" data-language="c">static VALUE
rb_io_each_line(int argc, VALUE *argv, VALUE io)
{
    VALUE str;
    struct getline_arg args;

    RETURN_ENUMERATOR(io, argc, argv);
    prepare_getline_args(argc, argv, &amp;args, io);
    if (args.limit == 0)
        rb_raise(rb_eArgError, "invalid limit: 0 for each_line");
    while (!NIL_P(str = rb_io_getline_1(args.rs, args.limit, args.chomp, io))) {
        rb_yield(str);
    }
    return io;
}</pre> </div> <p>Executes the block for every line in <em>ios</em>, where lines are separated by <em>sep</em>. <em>ios</em> must be opened for reading or an <a href="ioerror"><code>IOError</code></a> will be raised.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
f.each {|line| puts "#{f.lineno}: #{line}" }
</pre> <p><em>produces:</em></p> <pre>1: This is line one
2: This is line two
3: This is line three
4: And so on...</pre> <p>See <a href="io#method-c-readlines"><code>IO.readlines</code></a> for details about getline_args.</p>  </div> <div class="aliases"> Also aliased as: <a href="io#method-i-each_line">each_line</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_byte"> <span class="method-callseq"> each_byte {|byte| block } → ios </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_byte → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_byte-source"> <pre class="c" data-language="c">static VALUE
rb_io_each_byte(VALUE io)
{
    rb_io_t *fptr;

    RETURN_ENUMERATOR(io, 0, 0);
    GetOpenFile(io, fptr);

    do {
        while (fptr-&gt;rbuf.len &gt; 0) {
            char *p = fptr-&gt;rbuf.ptr + fptr-&gt;rbuf.off++;
            fptr-&gt;rbuf.len--;
            rb_yield(INT2FIX(*p &amp; 0xff));
            errno = 0;
        }
        rb_io_check_byte_readable(fptr);
        READ_CHECK(fptr);
    } while (io_fillbuf(fptr) &gt;= 0);
    return io;
}</pre> </div> <p>Calls the given block once for each byte (0..255) in <em>ios</em>, passing the byte as an argument. The stream must be opened for reading or an <a href="ioerror"><code>IOError</code></a> will be raised.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
checksum = 0
f.each_byte {|x| checksum ^= x }   #=&gt; #&lt;File:testfile&gt;
checksum                           #=&gt; 12
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_char"> <span class="method-callseq"> each_char {|c| block } → ios </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_char → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_char-source"> <pre class="c" data-language="c">static VALUE
rb_io_each_char(VALUE io)
{
    rb_io_t *fptr;
    rb_encoding *enc;
    VALUE c;

    RETURN_ENUMERATOR(io, 0, 0);
    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);

    enc = io_input_encoding(fptr);
    READ_CHECK(fptr);
    while (!NIL_P(c = io_getc(fptr, enc))) {
        rb_yield(c);
    }
    return io;
}</pre> </div> <p>Calls the given block once for each character in <em>ios</em>, passing the character as an argument. The stream must be opened for reading or an <a href="ioerror"><code>IOError</code></a> will be raised.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
f.each_char {|c| print c, ' ' }   #=&gt; #&lt;File:testfile&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_codepoint"> <span class="method-callseq"> each_codepoint {|c| block } → ios </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> codepoints {|c| block } → ios </span> </div> <div class="method-heading"> <span class="method-callseq"> each_codepoint → an_enumerator </span> </div> <div class="method-heading"> <span class="method-callseq"> codepoints → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_codepoint-source"> <pre class="c" data-language="c">static VALUE
rb_io_each_codepoint(VALUE io)
{
    rb_io_t *fptr;
    rb_encoding *enc;
    unsigned int c;
    int r, n;

    RETURN_ENUMERATOR(io, 0, 0);
    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);

    READ_CHECK(fptr);
    if (NEED_READCONV(fptr)) {
        SET_BINARY_MODE(fptr);
        r = 1;         /* no invalid char yet */
        for (;;) {
            make_readconv(fptr, 0);
            for (;;) {
                if (fptr-&gt;cbuf.len) {
                    if (fptr-&gt;encs.enc)
                        r = rb_enc_precise_mbclen(fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off,
                                                  fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off+fptr-&gt;cbuf.len,
                                                  fptr-&gt;encs.enc);
                    else
                        r = ONIGENC_CONSTRUCT_MBCLEN_CHARFOUND(1);
                    if (!MBCLEN_NEEDMORE_P(r))
                        break;
                    if (fptr-&gt;cbuf.len == fptr-&gt;cbuf.capa) {
                        rb_raise(rb_eIOError, "too long character");
                    }
                }
                if (more_char(fptr) == MORE_CHAR_FINISHED) {
                    clear_readconv(fptr);
                    if (!MBCLEN_CHARFOUND_P(r)) {
                        enc = fptr-&gt;encs.enc;
                        goto invalid;
                    }
                    return io;
                }
            }
            if (MBCLEN_INVALID_P(r)) {
                enc = fptr-&gt;encs.enc;
                goto invalid;
            }
            n = MBCLEN_CHARFOUND_LEN(r);
            if (fptr-&gt;encs.enc) {
                c = rb_enc_codepoint(fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off,
                                     fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off+fptr-&gt;cbuf.len,
                                     fptr-&gt;encs.enc);
            }
            else {
                c = (unsigned char)fptr-&gt;cbuf.ptr[fptr-&gt;cbuf.off];
            }
            fptr-&gt;cbuf.off += n;
            fptr-&gt;cbuf.len -= n;
            rb_yield(UINT2NUM(c));
        }
    }
    NEED_NEWLINE_DECORATOR_ON_READ_CHECK(fptr);
    enc = io_input_encoding(fptr);
    while (io_fillbuf(fptr) &gt;= 0) {
        r = rb_enc_precise_mbclen(fptr-&gt;rbuf.ptr+fptr-&gt;rbuf.off,
                                  fptr-&gt;rbuf.ptr+fptr-&gt;rbuf.off+fptr-&gt;rbuf.len, enc);
        if (MBCLEN_CHARFOUND_P(r) &amp;&amp;
            (n = MBCLEN_CHARFOUND_LEN(r)) &lt;= fptr-&gt;rbuf.len) {
            c = rb_enc_codepoint(fptr-&gt;rbuf.ptr+fptr-&gt;rbuf.off,
                                 fptr-&gt;rbuf.ptr+fptr-&gt;rbuf.off+fptr-&gt;rbuf.len, enc);
            fptr-&gt;rbuf.off += n;
            fptr-&gt;rbuf.len -= n;
            rb_yield(UINT2NUM(c));
        }
        else if (MBCLEN_INVALID_P(r)) {
            goto invalid;
        }
        else if (MBCLEN_NEEDMORE_P(r)) {
            char cbuf[8], *p = cbuf;
            int more = MBCLEN_NEEDMORE_LEN(r);
            if (more &gt; numberof(cbuf)) goto invalid;
            more += n = fptr-&gt;rbuf.len;
            if (more &gt; numberof(cbuf)) goto invalid;
            while ((n = (int)read_buffered_data(p, more, fptr)) &gt; 0 &amp;&amp;
                   (p += n, (more -= n) &gt; 0)) {
                if (io_fillbuf(fptr) &lt; 0) goto invalid;
                if ((n = fptr-&gt;rbuf.len) &gt; more) n = more;
            }
            r = rb_enc_precise_mbclen(cbuf, p, enc);
            if (!MBCLEN_CHARFOUND_P(r)) goto invalid;
            c = rb_enc_codepoint(cbuf, p, enc);
            rb_yield(UINT2NUM(c));
        }
        else {
            continue;
        }
    }
    return io;

  invalid:
    rb_raise(rb_eArgError, "invalid byte sequence in %s", rb_enc_name(enc));
    UNREACHABLE_RETURN(Qundef);
}</pre> </div> <p>Passes the <a href="integer"><code>Integer</code></a> ordinal of each character in <em>ios</em>, passing the codepoint as an argument. The stream must be opened for reading or an <a href="ioerror"><code>IOError</code></a> will be raised.</p> <p>If no block is given, an enumerator is returned instead.</p>  </div> </div> <div id="method-i-each_line" class="method-detail method-alias"> <div class="method-description"> <p>Executes the block for every line in <em>ios</em>, where lines are separated by <em>sep</em>. <em>ios</em> must be opened for reading or an <a href="ioerror"><code>IOError</code></a> will be raised.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
f.each {|line| puts "#{f.lineno}: #{line}" }
</pre> <p><em>produces:</em></p> <pre>1: This is line one
2: This is line two
3: This is line three
4: And so on...</pre> <p>See <a href="io#method-c-readlines"><code>IO.readlines</code></a> for details about getline_args.</p> </div> <div class="aliases"> Alias for: <a href="io#method-i-each">each</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-echo-3D"> <span class="method-callseq"> echo = flag </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="echo-3D-source"> <pre class="c" data-language="c">static VALUE
console_set_echo(VALUE io, VALUE f)
{
    conmode t;
    rb_io_t *fptr;
    int fd;

    GetOpenFile(io, fptr);
    fd = GetReadFD(fptr);
    if (!getattr(fd, &amp;t)) sys_fail_fptr(fptr);
    if (RTEST(f))
        set_echo(&amp;t, NULL);
    else
        set_noecho(&amp;t, NULL);
    if (!setattr(fd, &amp;t)) sys_fail_fptr(fptr);
    return io;
}</pre> </div> <p>Enables/disables echo back. On some platforms, all combinations of this flags and raw/cooked mode may not be valid.</p> <p>You must require 'io/console' to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-echo-3F"> <span class="method-callseq"> echo? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="echo-3F-source"> <pre class="c" data-language="c">static VALUE
console_echo_p(VALUE io)
{
    conmode t;
    rb_io_t *fptr;
    int fd;

    GetOpenFile(io, fptr);
    fd = GetReadFD(fptr);
    if (!getattr(fd, &amp;t)) sys_fail_fptr(fptr);
    return echo_p(&amp;t) ? Qtrue : Qfalse;
}</pre> </div> <p>Returns <code>true</code> if echo back is enabled.</p> <p>You must require 'io/console' to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-eof"> <span class="method-callseq"> eof → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="eof-source"> <pre class="c" data-language="c">VALUE
rb_io_eof(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);

    if (READ_CHAR_PENDING(fptr)) return Qfalse;
    if (READ_DATA_PENDING(fptr)) return Qfalse;
    READ_CHECK(fptr);
#if defined(RUBY_TEST_CRLF_ENVIRONMENT) || defined(_WIN32)
    if (!NEED_READCONV(fptr) &amp;&amp; NEED_NEWLINE_DECORATOR_ON_READ(fptr)) {
        return eof(fptr-&gt;fd) ? Qtrue : Qfalse;
    }
#endif
    if (io_fillbuf(fptr) &lt; 0) {
        return Qtrue;
    }
    return Qfalse;
}</pre> </div> <p>Returns true if <em>ios</em> is at end of file that means there are no more data to read. The stream must be opened for reading or an <a href="ioerror"><code>IOError</code></a> will be raised.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
dummy = f.readlines
f.eof   #=&gt; true
</pre> <p>If <em>ios</em> is a stream such as pipe or socket, <a href="io#method-i-eof-3F"><code>IO#eof?</code></a> blocks until the other end sends some data or closes it.</p> <pre class="ruby" data-language="ruby">r, w = IO.pipe
Thread.new { sleep 1; w.close }
r.eof?  #=&gt; true after 1 second blocking

r, w = IO.pipe
Thread.new { sleep 1; w.puts "a" }
r.eof?  #=&gt; false after 1 second blocking

r, w = IO.pipe
r.eof?  # blocks forever
</pre> <p>Note that <a href="io#method-i-eof-3F"><code>IO#eof?</code></a> reads data to the input byte buffer. So <a href="io#method-i-sysread"><code>IO#sysread</code></a> may not behave as you intend with <a href="io#method-i-eof-3F"><code>IO#eof?</code></a>, unless you call <a href="io#method-i-rewind"><code>IO#rewind</code></a> first (which is not available for some streams).</p>  </div> <div class="aliases"> Also aliased as: <a href="io#method-i-eof-3F">eof?</a> </div> </div> <div id="method-i-eof-3F" class="method-detail method-alias"> <div class="method-description"> <p>Returns true if <em>ios</em> is at end of file that means there are no more data to read. The stream must be opened for reading or an <a href="ioerror"><code>IOError</code></a> will be raised.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
dummy = f.readlines
f.eof   #=&gt; true
</pre> <p>If <em>ios</em> is a stream such as pipe or socket, <a href="io#method-i-eof-3F"><code>IO#eof?</code></a> blocks until the other end sends some data or closes it.</p> <pre class="ruby" data-language="ruby">r, w = IO.pipe
Thread.new { sleep 1; w.close }
r.eof?  #=&gt; true after 1 second blocking

r, w = IO.pipe
Thread.new { sleep 1; w.puts "a" }
r.eof?  #=&gt; false after 1 second blocking

r, w = IO.pipe
r.eof?  # blocks forever
</pre> <p>Note that <a href="io#method-i-eof-3F"><code>IO#eof?</code></a> reads data to the input byte buffer. So <a href="io#method-i-sysread"><code>IO#sysread</code></a> may not behave as you intend with <a href="io#method-i-eof-3F"><code>IO#eof?</code></a>, unless you call <a href="io#method-i-rewind"><code>IO#rewind</code></a> first (which is not available for some streams).</p> </div> <div class="aliases"> Alias for: <a href="io#method-i-eof">eof</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-erase_line"> <span class="method-name">erase_line</span><span class="method-args">(p1)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="erase_line-source"> <pre class="c" data-language="c">static VALUE
console_erase_line(VALUE io, VALUE val)
{
    rb_io_t *fptr;
    HANDLE h;
    rb_console_size_t ws;
    COORD *pos = &amp;ws.dwCursorPosition;
    DWORD w;
    int mode = mode_in_range(val, 2, "line erase");

    GetOpenFile(io, fptr);
    h = (HANDLE)rb_w32_get_osfhandle(GetWriteFD(fptr));
    if (!GetConsoleScreenBufferInfo(h, &amp;ws)) {
        rb_syserr_fail(LAST_ERROR, 0);
    }
    w = winsize_col(&amp;ws);
    switch (mode) {
      case 0:                   /* after cursor */
        w -= pos-&gt;X;
        break;
      case 1:                   /* before *and* cursor */
        w = pos-&gt;X + 1;
        pos-&gt;X = 0;
        break;
      case 2:                   /* entire line */
        pos-&gt;X = 0;
        break;
    }
    constat_clear(h, ws.wAttributes, w, *pos);
    return io;
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-erase_screen"> <span class="method-name">erase_screen</span><span class="method-args">(p1)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="erase_screen-source"> <pre class="c" data-language="c">static VALUE
console_erase_screen(VALUE io, VALUE val)
{
    rb_io_t *fptr;
    HANDLE h;
    rb_console_size_t ws;
    COORD *pos = &amp;ws.dwCursorPosition;
    DWORD w;
    int mode = mode_in_range(val, 3, "screen erase");

    GetOpenFile(io, fptr);
    h = (HANDLE)rb_w32_get_osfhandle(GetWriteFD(fptr));
    if (!GetConsoleScreenBufferInfo(h, &amp;ws)) {
        rb_syserr_fail(LAST_ERROR, 0);
    }
    w = winsize_col(&amp;ws);
    switch (mode) {
      case 0:   /* erase after cursor */
        w = (w * (ws.srWindow.Bottom - pos-&gt;Y + 1) - pos-&gt;X);
        break;
      case 1:   /* erase before *and* cursor */
        w = (w * (pos-&gt;Y - ws.srWindow.Top) + pos-&gt;X + 1);
        pos-&gt;X = 0;
        pos-&gt;Y = ws.srWindow.Top;
        break;
      case 2:   /* erase entire screen */
        w = (w * winsize_row(&amp;ws));
        pos-&gt;X = 0;
        pos-&gt;Y = ws.srWindow.Top;
        break;
      case 3:   /* erase entire screen */
        w = (w * ws.dwSize.Y);
        pos-&gt;X = 0;
        pos-&gt;Y = 0;
        break;
    }
    constat_clear(h, ws.wAttributes, w, *pos);
    return io;
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-expect"> <span class="method-callseq"> IO#expect(pattern,timeout=9999999) → Array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> IO#expect(pattern,timeout=9999999) { |result| ... } → nil </span> </div> <div class="method-description">
<div class="method-source-code" id="expect-source"> <pre class="ruby" data-language="ruby"># File ext/pty/lib/expect.rb, line 33
def expect(pat,timeout=9999999)
  buf = ''.dup
  case pat
  when String
    e_pat = Regexp.new(Regexp.quote(pat))
  when Regexp
    e_pat = pat
  else
    raise TypeError, "unsupported pattern class: #{pat.class}"
  end
  @unusedBuf ||= ''
  while true
    if not @unusedBuf.empty?
      c = @unusedBuf.slice!(0)
    elsif !IO.select([self],nil,nil,timeout) or eof? then
      result = nil
      @unusedBuf = buf
      break
    else
      c = getc
    end
    buf &lt;&lt; c
    if $expect_verbose
      STDOUT.print c
      STDOUT.flush
    end
    if mat=e_pat.match(buf) then
      result = [buf,*mat.captures]
      break
    end
  end
  if block_given? then
    yield result
  else
    return result
  end
  nil
end</pre> </div> <p>Reads from the <a href="io"><code>IO</code></a> until the given <code>pattern</code> matches or the <code>timeout</code> is over.</p> <p>It returns an array with the read buffer, followed by the matches. If a block is given, the result is yielded to the block and returns nil.</p> <p>When called without a block, it waits until the input that matches the given <code>pattern</code> is obtained from the <a href="io"><code>IO</code></a> or the time specified as the timeout passes. An array is returned when the pattern is obtained from the <a href="io"><code>IO</code></a>. The first element of the array is the entire string obtained from the <a href="io"><code>IO</code></a> until the pattern matches, followed by elements indicating which the pattern which matched to the anchor in the regular expression.</p> <p>The optional timeout parameter defines, in seconds, the total time to wait for the pattern. If the timeout expires or eof is found, nil is returned or yielded. However, the buffer in a timeout session is kept for the next expect call. The default timeout is 9999999 seconds.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-external_encoding"> <span class="method-callseq"> external_encoding → encoding </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="external_encoding-source"> <pre class="c" data-language="c">static VALUE
rb_io_external_encoding(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (fptr-&gt;encs.enc2) {
        return rb_enc_from_encoding(fptr-&gt;encs.enc2);
    }
    if (fptr-&gt;mode &amp; FMODE_WRITABLE) {
        if (fptr-&gt;encs.enc)
            return rb_enc_from_encoding(fptr-&gt;encs.enc);
        return Qnil;
    }
    return rb_enc_from_encoding(io_read_encoding(fptr));
}</pre> </div> <p>Returns the <a href="encoding"><code>Encoding</code></a> object that represents the encoding of the file. If <em>io</em> is in write mode and no encoding is specified, returns <code>nil</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fcntl"> <span class="method-callseq"> fcntl(integer_cmd, arg) → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="fcntl-source"> <pre class="c" data-language="c">static VALUE
rb_io_fcntl(int argc, VALUE *argv, VALUE io)
{
    VALUE req, arg;

    rb_scan_args(argc, argv, "11", &amp;req, &amp;arg);
    return rb_fcntl(io, req, arg);
}</pre> </div> <p>Provides a mechanism for issuing low-level commands to control or query file-oriented I/O streams. Arguments and results are platform dependent. If <em>arg</em> is a number, its value is passed directly. If it is a string, it is interpreted as a binary sequence of bytes (<a href="array#method-i-pack"><code>Array#pack</code></a> might be a useful way to build this string). On Unix platforms, see <code>fcntl(2)</code> for details. Not implemented on all platforms.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fdatasync"> <span class="method-callseq"> fdatasync → 0 or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="fdatasync-source"> <pre class="c" data-language="c">static VALUE
rb_io_fdatasync(VALUE io)
{
    rb_io_t *fptr;

    io = GetWriteIO(io);
    GetOpenFile(io, fptr);

    if (io_fflush(fptr) &lt; 0)
        rb_sys_fail_on_write(fptr);

    if ((int)rb_thread_io_blocking_region(nogvl_fdatasync, fptr, fptr-&gt;fd) == 0)
        return INT2FIX(0);

    /* fall back */
    return rb_io_fsync(io);
}</pre> </div> <p>Immediately writes all buffered data in <em>ios</em> to disk.</p> <p>If the underlying operating system does not support <em>fdatasync(2)</em>, <a href="io#method-i-fsync"><code>IO#fsync</code></a> is called instead (which might raise a <a href="notimplementederror"><code>NotImplementedError</code></a>).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fileno"> <span class="method-callseq"> fileno → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="fileno-source"> <pre class="c" data-language="c">static VALUE
rb_io_fileno(VALUE io)
{
    rb_io_t *fptr = RFILE(io)-&gt;fptr;
    int fd;

    rb_io_check_closed(fptr);
    fd = fptr-&gt;fd;
    return INT2FIX(fd);
}</pre> </div> <p>Returns an integer representing the numeric file descriptor for <em>ios</em>.</p> <pre class="ruby" data-language="ruby">$stdin.fileno    #=&gt; 0
$stdout.fileno   #=&gt; 1
</pre>  </div> <div class="aliases"> Also aliased as: <a href="io#method-i-to_i">to_i</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-flush"> <span class="method-callseq"> flush → ios </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="flush-source"> <pre class="c" data-language="c">VALUE
rb_io_flush(VALUE io)
{
    return rb_io_flush_raw(io, 1);
}</pre> </div> <p>Flushes any buffered data within <em>ios</em> to the underlying operating system (note that this is Ruby internal buffering only; the OS may buffer the data as well).</p> <pre class="ruby" data-language="ruby">$stdout.print "no newline"
$stdout.flush
</pre> <p><em>produces:</em></p> <pre class="ruby" data-language="ruby">no newline
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fsync"> <span class="method-callseq"> fsync → 0 or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="fsync-source"> <pre class="c" data-language="c">static VALUE
rb_io_fsync(VALUE io)
{
    rb_io_t *fptr;

    io = GetWriteIO(io);
    GetOpenFile(io, fptr);

    if (io_fflush(fptr) &lt; 0)
        rb_sys_fail_on_write(fptr);
    if ((int)rb_thread_io_blocking_region(nogvl_fsync, fptr, fptr-&gt;fd) &lt; 0)
        rb_sys_fail_path(fptr-&gt;pathv);
    return INT2FIX(0);
}</pre> </div> <p>Immediately writes all buffered data in <em>ios</em> to disk. Note that <a href="io#method-i-fsync"><code>fsync</code></a> differs from using <a href="io#method-i-sync-3D"><code>IO#sync=</code></a>. The latter ensures that data is flushed from Ruby's buffers, but does not guarantee that the underlying operating system actually writes it to disk.</p> <p><a href="notimplementederror"><code>NotImplementedError</code></a> is raised if the underlying operating system does not support <em>fsync(2)</em>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-getbyte"> <span class="method-callseq"> getbyte → integer or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="getbyte-source"> <pre class="c" data-language="c">VALUE
rb_io_getbyte(VALUE io)
{
    rb_io_t *fptr;
    int c;

    GetOpenFile(io, fptr);
    rb_io_check_byte_readable(fptr);
    READ_CHECK(fptr);
    VALUE r_stdout = rb_ractor_stdout();
    if (fptr-&gt;fd == 0 &amp;&amp; (fptr-&gt;mode &amp; FMODE_TTY) &amp;&amp; RB_TYPE_P(r_stdout, T_FILE)) {
        rb_io_t *ofp;
        GetOpenFile(r_stdout, ofp);
        if (ofp-&gt;mode &amp; FMODE_TTY) {
            rb_io_flush(r_stdout);
        }
    }
    if (io_fillbuf(fptr) &lt; 0) {
        return Qnil;
    }
    fptr-&gt;rbuf.off++;
    fptr-&gt;rbuf.len--;
    c = (unsigned char)fptr-&gt;rbuf.ptr[fptr-&gt;rbuf.off-1];
    return INT2FIX(c &amp; 0xff);
}</pre> </div> <p>Gets the next 8-bit byte (0..255) from <em>ios</em>. Returns <code>nil</code> if called at end of file.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
f.getbyte   #=&gt; 84
f.getbyte   #=&gt; 104
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-getc"> <span class="method-callseq"> getc → string or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="getc-source"> <pre class="c" data-language="c">static VALUE
rb_io_getc(VALUE io)
{
    rb_io_t *fptr;
    rb_encoding *enc;

    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);

    enc = io_input_encoding(fptr);
    READ_CHECK(fptr);
    return io_getc(fptr, enc);
}</pre> </div> <p>Reads a one-character string from <em>ios</em>. Returns <code>nil</code> if called at end of file.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
f.getc   #=&gt; "h"
f.getc   #=&gt; "e"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-getch"> <span class="method-callseq"> getch(min: nil, time: nil, intr: nil) → char </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="getch-source"> <pre class="c" data-language="c">static VALUE
console_getch(int argc, VALUE *argv, VALUE io)
{
    rawmode_arg_t opts, *optp = rawmode_opt(&amp;argc, argv, 0, 0, &amp;opts);
#ifndef _WIN32
    return ttymode(io, getc_call, io, set_rawmode, optp);
#else
    rb_io_t *fptr;
    VALUE str;
    wint_t c;
    int len;
    char buf[8];
    wint_t wbuf[2];
# ifndef HAVE_RB_IO_WAIT
    struct timeval *to = NULL, tv;
# else
    VALUE timeout = Qnil;
# endif

    GetOpenFile(io, fptr);
    if (optp) {
        if (optp-&gt;vtime) {
# ifndef HAVE_RB_IO_WAIT
            to = &amp;tv;
# else
            struct timeval tv;
# endif
            tv.tv_sec = optp-&gt;vtime / 10;
            tv.tv_usec = (optp-&gt;vtime % 10) * 100000;
# ifdef HAVE_RB_IO_WAIT
            timeout = rb_scheduler_timeout(&amp;tv);
# endif
        }
        switch (optp-&gt;vmin) {
          case 1: /* default */
            break;
          case 0: /* return nil when timed out */
            if (optp-&gt;vtime) break;
            /* fallthru */
          default:
            rb_warning("min option larger than 1 ignored");
        }
        if (optp-&gt;intr) {
# ifndef HAVE_RB_IO_WAIT
            int w = rb_wait_for_single_fd(fptr-&gt;fd, RB_WAITFD_IN, to);
            if (w &lt; 0) rb_eof_error();
            if (!(w &amp; RB_WAITFD_IN)) return Qnil;
# else
            VALUE result = rb_io_wait(io, RUBY_IO_READABLE, timeout);
            if (result == Qfalse) return Qnil;
# endif
        }
        else if (optp-&gt;vtime) {
            rb_warning("Non-zero vtime option ignored if intr flag is unset");
        }
    }
    len = (int)(VALUE)rb_thread_call_without_gvl(nogvl_getch, wbuf, RUBY_UBF_IO, 0);
    switch (len) {
      case 0:
        return Qnil;
      case 2:
        buf[0] = (char)wbuf[0];
        c = wbuf[1];
        len = 1;
        do {
            buf[len++] = (unsigned char)c;
        } while ((c &gt;&gt;= CHAR_BIT) &amp;&amp; len &lt; (int)sizeof(buf));
        return rb_str_new(buf, len);
      default:
        c = wbuf[0];
        len = rb_uv_to_utf8(buf, c);
        str = rb_utf8_str_new(buf, len);
        return rb_str_conv_enc(str, NULL, rb_default_external_encoding());
    }
#endif
}</pre> </div> <p>Reads and returns a character in raw mode.</p> <p>See <a href="io#method-i-raw"><code>IO#raw</code></a> for details on the parameters.</p> <p>You must require 'io/console' to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-getpass"> <span class="method-callseq"> getpass(prompt=nil) → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="getpass-source"> <pre class="c" data-language="c">static VALUE
console_getpass(int argc, VALUE *argv, VALUE io)
{
    VALUE str, wio;

    rb_check_arity(argc, 0, 1);
    wio = rb_io_get_write_io(io);
    if (wio == io &amp;&amp; io == rb_stdin) wio = rb_stderr;
    prompt(argc, argv, wio);
    str = rb_ensure(getpass_call, io, puts_call, wio);
    return str_chomp(str);
}</pre> </div> <p>Reads and returns a line without echo back. Prints <code>prompt</code> unless it is <code>nil</code>.</p> <p>You must require 'io/console' to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-gets"> <span class="method-callseq"> gets(sep=$/ [, getline_args]) → string or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> gets(limit [, getline_args]) → string or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> gets(sep, limit [, getline_args]) → string or nil </span> </div> <div class="method-description">
<div class="method-source-code" id="gets-source"> <pre class="c" data-language="c">static VALUE
rb_io_gets_m(int argc, VALUE *argv, VALUE io)
{
    VALUE str;

    str = rb_io_getline(argc, argv, io);
    rb_lastline_set(str);

    return str;
}</pre> </div> <p>Reads the next “line'' from the I/O stream; lines are separated by <em>sep</em>. A separator of <code>nil</code> reads the entire contents, and a zero-length separator reads the input a paragraph at a time (two successive newlines in the input separate paragraphs). The stream must be opened for reading or an <a href="ioerror"><code>IOError</code></a> will be raised. The line read in will be returned and also assigned to <code>$_</code>. Returns <code>nil</code> if called at end of file. If the first argument is an integer, or optional second argument is given, the returning string would not be longer than the given value in bytes.</p> <pre class="ruby" data-language="ruby">File.new("testfile").gets   #=&gt; "This is line one\n"
$_                          #=&gt; "This is line one\n"

File.new("testfile").gets(4)#=&gt; "This"
</pre> <p>If <a href="io"><code>IO</code></a> contains multibyte characters byte then <code>gets(1)</code> returns character entirely:</p> <pre class="ruby" data-language="ruby"># Russian characters take 2 bytes
File.write("testfile", "\u{442 435 441 442}")
File.open("testfile") {|f|f.gets(1)} #=&gt; "\u0442"
File.open("testfile") {|f|f.gets(2)} #=&gt; "\u0442"
File.open("testfile") {|f|f.gets(3)} #=&gt; "\u0442\u0435"
File.open("testfile") {|f|f.gets(4)} #=&gt; "\u0442\u0435"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-goto"> <span class="method-name">goto</span><span class="method-args">(p1, p2)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="goto-source"> <pre class="c" data-language="c">static VALUE
console_goto(VALUE io, VALUE y, VALUE x)
{
    rb_io_t *fptr;
    int fd;
    COORD pos;

    GetOpenFile(io, fptr);
    fd = GetWriteFD(fptr);
    pos.X = NUM2UINT(x);
    pos.Y = NUM2UINT(y);
    if (!SetConsoleCursorPosition((HANDLE)rb_w32_get_osfhandle(fd), pos)) {
        rb_syserr_fail(LAST_ERROR, 0);
    }
    return io;
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-goto_column"> <span class="method-name">goto_column</span><span class="method-args">(p1)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="goto_column-source"> <pre class="c" data-language="c">static VALUE
console_goto_column(VALUE io, VALUE val)
{
    rb_io_t *fptr;
    HANDLE h;
    rb_console_size_t ws;
    COORD *pos = &amp;ws.dwCursorPosition;

    GetOpenFile(io, fptr);
    h = (HANDLE)rb_w32_get_osfhandle(GetWriteFD(fptr));
    if (!GetConsoleScreenBufferInfo(h, &amp;ws)) {
        rb_syserr_fail(LAST_ERROR, 0);
    }
    pos-&gt;X = NUM2INT(val);
    if (!SetConsoleCursorPosition(h, *pos)) {
        rb_syserr_fail(LAST_ERROR, 0);
    }
    return io;
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-iflush"> <span class="method-callseq"> iflush </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="iflush-source"> <pre class="c" data-language="c">static VALUE
console_iflush(VALUE io)
{
    rb_io_t *fptr;
    int fd;

    GetOpenFile(io, fptr);
    fd = GetReadFD(fptr);
#if defined HAVE_TERMIOS_H || defined HAVE_TERMIO_H
    if (tcflush(fd, TCIFLUSH)) sys_fail_fptr(fptr);
#endif
    (void)fd;
    return io;
}</pre> </div> <p>Flushes input buffer in kernel.</p> <p>You must require 'io/console' to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inspect"> <span class="method-callseq"> inspect → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="c" data-language="c">static VALUE
rb_io_inspect(VALUE obj)
{
    rb_io_t *fptr;
    VALUE result;
    static const char closed[] = " (closed)";

    fptr = RFILE(obj)-&gt;fptr;
    if (!fptr) return rb_any_to_s(obj);
    result = rb_str_new_cstr("#&lt;");
    rb_str_append(result, rb_class_name(CLASS_OF(obj)));
    rb_str_cat2(result, ":");
    if (NIL_P(fptr-&gt;pathv)) {
        if (fptr-&gt;fd &lt; 0) {
            rb_str_cat(result, closed+1, strlen(closed)-1);
        }
        else {
            rb_str_catf(result, "fd %d", fptr-&gt;fd);
        }
    }
    else {
        rb_str_append(result, fptr-&gt;pathv);
        if (fptr-&gt;fd &lt; 0) {
            rb_str_cat(result, closed, strlen(closed));
        }
    }
    return rb_str_cat2(result, "&gt;");
}</pre> </div> <p>Return a string describing this <a href="io"><code>IO</code></a> object.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-internal_encoding"> <span class="method-callseq"> internal_encoding → encoding </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="internal_encoding-source"> <pre class="c" data-language="c">static VALUE
rb_io_internal_encoding(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (!fptr-&gt;encs.enc2) return Qnil;
    return rb_enc_from_encoding(io_read_encoding(fptr));
}</pre> </div> <p>Returns the <a href="encoding"><code>Encoding</code></a> of the internal string if conversion is specified. Otherwise returns <code>nil</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ioctl"> <span class="method-callseq"> ioctl(integer_cmd, arg) → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ioctl-source"> <pre class="c" data-language="c">static VALUE
rb_io_ioctl(int argc, VALUE *argv, VALUE io)
{
    VALUE req, arg;

    rb_scan_args(argc, argv, "11", &amp;req, &amp;arg);
    return rb_ioctl(io, req, arg);
}</pre> </div> <p>Provides a mechanism for issuing low-level commands to control or query I/O devices. Arguments and results are platform dependent. If <em>arg</em> is a number, its value is passed directly. If it is a string, it is interpreted as a binary sequence of bytes. On Unix platforms, see <code>ioctl(2)</code> for details. Not implemented on all platforms.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ioflush"> <span class="method-callseq"> ioflush </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ioflush-source"> <pre class="c" data-language="c">static VALUE
console_ioflush(VALUE io)
{
    rb_io_t *fptr;
#if defined HAVE_TERMIOS_H || defined HAVE_TERMIO_H
    int fd1, fd2;
#endif

    GetOpenFile(io, fptr);
#if defined HAVE_TERMIOS_H || defined HAVE_TERMIO_H
    fd1 = GetReadFD(fptr);
    fd2 = GetWriteFD(fptr);
    if (fd2 != -1 &amp;&amp; fd1 != fd2) {
        if (tcflush(fd1, TCIFLUSH)) sys_fail_fptr(fptr);
        if (tcflush(fd2, TCOFLUSH)) sys_fail_fptr(fptr);
    }
    else {
        if (tcflush(fd1, TCIOFLUSH)) sys_fail_fptr(fptr);
    }
#endif
    return io;
}</pre> </div> <p>Flushes input and output buffers in kernel.</p> <p>You must require 'io/console' to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-isatty"> <span class="method-callseq"> isatty → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="isatty-source"> <pre class="c" data-language="c">static VALUE
rb_io_isatty(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (isatty(fptr-&gt;fd) == 0)
        return Qfalse;
    return Qtrue;
}</pre> </div> <p>Returns <code>true</code> if <em>ios</em> is associated with a terminal device (tty), <code>false</code> otherwise.</p> <pre class="ruby" data-language="ruby">File.new("testfile").isatty   #=&gt; false
File.new("/dev/tty").isatty   #=&gt; true
</pre>  </div> <div class="aliases"> Also aliased as: <a href="io#method-i-tty-3F">tty?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-lineno"> <span class="method-callseq"> lineno → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="lineno-source"> <pre class="c" data-language="c">static VALUE
rb_io_lineno(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);
    return INT2NUM(fptr-&gt;lineno);
}</pre> </div> <p>Returns the current line number in <em>ios</em>. The stream must be opened for reading. <a href="io#method-i-lineno"><code>lineno</code></a> counts the number of times <a href="io#method-i-gets"><code>gets</code></a> is called rather than the number of newlines encountered. The two values will differ if <a href="io#method-i-gets"><code>gets</code></a> is called with a separator other than newline.</p> <p>Methods that use <code>$/</code> like <a href="io#method-i-each"><code>each</code></a>, lines and <a href="io#method-i-readline"><code>readline</code></a> will also increment <a href="io#method-i-lineno"><code>lineno</code></a>.</p> <p>See also the <code>$.</code> variable.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
f.lineno   #=&gt; 0
f.gets     #=&gt; "This is line one\n"
f.lineno   #=&gt; 1
f.gets     #=&gt; "This is line two\n"
f.lineno   #=&gt; 2
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-lineno-3D"> <span class="method-callseq"> lineno = integer → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="lineno-3D-source"> <pre class="c" data-language="c">static VALUE
rb_io_set_lineno(VALUE io, VALUE lineno)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);
    fptr-&gt;lineno = NUM2INT(lineno);
    return lineno;
}</pre> </div> <p>Manually sets the current line number to the given value. <code>$.</code> is updated only on the next read.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
f.gets                     #=&gt; "This is line one\n"
$.                         #=&gt; 1
f.lineno = 1000
f.lineno                   #=&gt; 1000
$.                         #=&gt; 1         # lineno of last read
f.gets                     #=&gt; "This is line two\n"
$.                         #=&gt; 1001      # lineno of last read
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-noecho"> <span class="method-callseq"> noecho {|io| } </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="noecho-source"> <pre class="c" data-language="c">static VALUE
console_noecho(VALUE io)
{
    return ttymode(io, rb_yield, io, set_noecho, NULL);
}</pre> </div> <p>Yields <code>self</code> with disabling echo back.</p> <pre class="ruby" data-language="ruby">STDIN.noecho(&amp;:gets)
</pre> <p>will read and return a line without echo back.</p> <p>You must require 'io/console' to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-nonblock"> <span class="method-callseq"> nonblock {|io| } → io </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> nonblock(boolean) {|io| } → io </span> </div> <div class="method-description">
<div class="method-source-code" id="nonblock-source"> <pre class="c" data-language="c">static VALUE
rb_io_nonblock_block(int argc, VALUE *argv, VALUE io)
{
    int nb = 1;
    rb_io_t *fptr;
    int f, restore[2];

    GetOpenFile(io, fptr);
    if (argc &gt; 0) {
        VALUE v;
        rb_scan_args(argc, argv, "01", &amp;v);
        nb = RTEST(v);
    }
    f = io_nonblock_mode(fptr-&gt;fd);
    restore[0] = fptr-&gt;fd;
    restore[1] = f;
    if (!io_nonblock_set(fptr-&gt;fd, f, nb))
        return rb_yield(io);
    return rb_ensure(rb_yield, io, io_nonblock_restore, (VALUE)restore);
}</pre> </div> <p>Yields <code>self</code> in non-blocking mode.</p> <p>When <code>false</code> is given as an argument, <code>self</code> is yielded in blocking mode. The original mode is restored after the block is executed.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-nonblock-3D"> <span class="method-callseq"> nonblock = boolean → boolean </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="nonblock-3D-source"> <pre class="c" data-language="c">static VALUE
rb_io_nonblock_set(VALUE io, VALUE nb)
{
    rb_io_t *fptr;
    GetOpenFile(io, fptr);
    if (RTEST(nb))
        rb_io_set_nonblock(fptr);
    else
        io_nonblock_set(fptr-&gt;fd, io_nonblock_mode(fptr-&gt;fd), RTEST(nb));
    return io;
}</pre> </div> <p>Enables non-blocking mode on a stream when set to <code>true</code>, and blocking mode when set to <code>false</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-nonblock-3F"> <span class="method-callseq"> nonblock? → boolean </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="nonblock-3F-source"> <pre class="c" data-language="c">static VALUE
rb_io_nonblock_p(VALUE io)
{
    rb_io_t *fptr;
    GetOpenFile(io, fptr);
    if (io_nonblock_mode(fptr-&gt;fd) &amp; O_NONBLOCK)
        return Qtrue;
    return Qfalse;
}</pre> </div> <p>Returns <code>true</code> if an <a href="io"><code>IO</code></a> object is in non-blocking mode.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-nread"> <span class="method-callseq"> nread → int </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="nread-source"> <pre class="c" data-language="c">static VALUE
io_nread(VALUE io)
{
    rb_io_t *fptr = NULL;
    ioctl_arg n;

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    int len = rb_io_read_pending(fptr);
    if (len &gt; 0) return INT2FIX(len);
    if (!FIONREAD_POSSIBLE_P(fptr-&gt;fd)) return INT2FIX(0);
    if (ioctl(fptr-&gt;fd, FIONREAD, &amp;n)) return INT2FIX(0);
    if (n &gt; 0) return ioctl_arg2num(n);
    return INT2FIX(0);
}</pre> </div> <p>Returns number of bytes that can be read without blocking. Returns zero if no information available.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-oflush"> <span class="method-callseq"> oflush </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="oflush-source"> <pre class="c" data-language="c">static VALUE
console_oflush(VALUE io)
{
    rb_io_t *fptr;
    int fd;

    GetOpenFile(io, fptr);
    fd = GetWriteFD(fptr);
#if defined HAVE_TERMIOS_H || defined HAVE_TERMIO_H
    if (tcflush(fd, TCOFLUSH)) sys_fail_fptr(fptr);
#endif
    (void)fd;
    return io;
}</pre> </div> <p>Flushes output buffer in kernel.</p> <p>You must require 'io/console' to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pathconf"> <span class="method-name">pathconf</span><span class="method-args">(p1)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pathconf-source"> <pre class="c" data-language="c">static VALUE
io_pathconf(VALUE io, VALUE arg)
{
    int name;
    long ret;
    rb_io_t *fptr;

    name = NUM2INT(arg);

    GetOpenFile(io, fptr);

    errno = 0;
    ret = fpathconf(fptr-&gt;fd, name);
    if (ret == -1) {
        if (errno == 0) /* no limit */
            return Qnil;
        rb_sys_fail("fpathconf");
    }
    return LONG2NUM(ret);
}</pre> </div> <p>Returns pathname configuration variable using fpathconf().</p> <p><em>name</em> should be a constant under <code>Etc</code> which begins with <code>PC_</code>.</p> <p>The return value is an integer or nil. nil means indefinite limit. (fpathconf() returns -1 but errno is not set.)</p> <pre class="ruby" data-language="ruby">require 'etc'
IO.pipe {|r, w|
  p w.pathconf(Etc::PC_PIPE_BUF) #=&gt; 4096
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pid"> <span class="method-callseq"> pid → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pid-source"> <pre class="c" data-language="c">static VALUE
rb_io_pid(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (!fptr-&gt;pid)
        return Qnil;
    return PIDT2NUM(fptr-&gt;pid);
}</pre> </div> <p>Returns the process ID of a child process associated with <em>ios</em>. This will be set by <a href="io#method-c-popen"><code>IO.popen</code></a>.</p> <pre class="ruby" data-language="ruby">pipe = IO.popen("-")
if pipe
  $stderr.puts "In parent, child pid is #{pipe.pid}"
else
  $stderr.puts "In child, pid is #{$$}"
end
</pre> <p><em>produces:</em></p> <pre>In child, pid is 26209
In parent, child pid is 26209</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-pos"> <span class="method-callseq"> pos → integer </span> </div> <div class="method-description"> <p>Returns the current offset (in bytes) of <em>ios</em>.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
f.pos    #=&gt; 0
f.gets   #=&gt; "This is line one\n"
f.pos    #=&gt; 17
</pre> </div> <div class="aliases"> Alias for: <a href="io#method-i-tell">tell</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pos-3D"> <span class="method-callseq"> pos = integer → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pos-3D-source"> <pre class="c" data-language="c">static VALUE
rb_io_set_pos(VALUE io, VALUE offset)
{
    rb_io_t *fptr;
    off_t pos;

    pos = NUM2OFFT(offset);
    GetOpenFile(io, fptr);
    pos = io_seek(fptr, pos, SEEK_SET);
    if (pos &lt; 0 &amp;&amp; errno) rb_sys_fail_path(fptr-&gt;pathv);

    return OFFT2NUM(pos);
}</pre> </div> <p>Seeks to the given position (in bytes) in <em>ios</em>. It is not guaranteed that seeking to the right position when <em>ios</em> is textmode.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
f.pos = 17
f.gets   #=&gt; "This is line two\n"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pread"> <span class="method-callseq"> pread(maxlen, offset[, outbuf]) → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pread-source"> <pre class="c" data-language="c">static VALUE
rb_io_pread(int argc, VALUE *argv, VALUE io)
{
    VALUE len, offset, str;
    rb_io_t *fptr;
    ssize_t n;
    struct prdwr_internal_arg arg;
    int shrinkable;

    rb_scan_args(argc, argv, "21", &amp;len, &amp;offset, &amp;str);
    arg.count = NUM2SIZET(len);
    arg.offset = NUM2OFFT(offset);

    shrinkable = io_setstrbuf(&amp;str, (long)arg.count);
    if (arg.count == 0) return str;
    arg.buf = RSTRING_PTR(str);

    GetOpenFile(io, fptr);
    rb_io_check_byte_readable(fptr);

    arg.fd = fptr-&gt;fd;
    rb_io_check_closed(fptr);

    rb_str_locktmp(str);
    n = (ssize_t)rb_ensure(pread_internal_call, (VALUE)&amp;arg, rb_str_unlocktmp, str);

    if (n &lt; 0) {
        rb_sys_fail_path(fptr-&gt;pathv);
    }
    io_set_read_length(str, n, shrinkable);
    if (n == 0 &amp;&amp; arg.count &gt; 0) {
        rb_eof_error();
    }

    return str;
}</pre> </div> <p>Reads <em>maxlen</em> bytes from <em>ios</em> using the pread system call and returns them as a string without modifying the underlying descriptor offset. This is advantageous compared to combining <a href="io#method-i-seek"><code>IO#seek</code></a> and <a href="io#method-i-read"><code>IO#read</code></a> in that it is atomic, allowing multiple threads/process to share the same <a href="io"><code>IO</code></a> object for reading the file at various locations. This bypasses any userspace buffering of the <a href="io"><code>IO</code></a> layer. If the optional <em>outbuf</em> argument is present, it must reference a <a href="string"><code>String</code></a>, which will receive the data. Raises <a href="systemcallerror"><code>SystemCallError</code></a> on error, <a href="eoferror"><code>EOFError</code></a> at end of file and <a href="notimplementederror"><code>NotImplementedError</code></a> if platform does not implement the system call.</p> <pre class="ruby" data-language="ruby">File.write("testfile", "This is line one\nThis is line two\n")
File.open("testfile") do |f|
  p f.read           # =&gt; "This is line one\nThis is line two\n"
  p f.pread(12, 0)   # =&gt; "This is line"
  p f.pread(9, 8)    # =&gt; "line one\n"
end
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pressed-3F"> <span class="method-name">pressed?</span><span class="method-args">(p1)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pressed-3F-source"> <pre class="c" data-language="c">static VALUE
console_key_pressed_p(VALUE io, VALUE k)
{
    int vk = -1;

    if (FIXNUM_P(k)) {
        vk = NUM2UINT(k);
    }
    else {
        const struct vktable *t;
        const char *kn;
        if (SYMBOL_P(k)) {
            k = rb_sym2str(k);
            kn = RSTRING_PTR(k);
        }
        else {
            kn = StringValuePtr(k);
        }
        t = console_win32_vk(kn, RSTRING_LEN(k));
        if (!t || (vk = (short)t-&gt;vk) == -1) {
            rb_raise(rb_eArgError, "unknown virtual key code: % "PRIsVALUE, k);
        }
    }
    return GetKeyState(vk) &amp; 0x80 ? Qtrue : Qfalse;
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-print"> <span class="method-callseq"> print → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> print(obj, ...) → nil </span> </div> <div class="method-description">
<div class="method-source-code" id="print-source"> <pre class="c" data-language="c">VALUE
rb_io_print(int argc, const VALUE *argv, VALUE out)
{
    int i;
    VALUE line;

    /* if no argument given, print `$_' */
    if (argc == 0) {
        argc = 1;
        line = rb_lastline_get();
        argv = &amp;line;
    }
    if (argc &gt; 1 &amp;&amp; !NIL_P(rb_output_fs)) {
        rb_category_warn(RB_WARN_CATEGORY_DEPRECATED, "$, is set to non-nil value");
    }
    for (i=0; i&lt;argc; i++) {
        if (!NIL_P(rb_output_fs) &amp;&amp; i&gt;0) {
            rb_io_write(out, rb_output_fs);
        }
        rb_io_write(out, argv[i]);
    }
    if (argc &gt; 0 &amp;&amp; !NIL_P(rb_output_rs)) {
        rb_io_write(out, rb_output_rs);
    }

    return Qnil;
}</pre> </div> <p>Writes the given object(s) to <em>ios</em>. Returns <code>nil</code>.</p> <p>The stream must be opened for writing. Each given object that isn't a string will be converted by calling its <code>to_s</code> method. When called without arguments, prints the contents of <code>$_</code>.</p> <p>If the output field separator (<code>$,</code>) is not <code>nil</code>, it is inserted between objects. If the output record separator (<code>$\</code>) is not <code>nil</code>, it is appended to the output.</p> <pre class="ruby" data-language="ruby">$stdout.print("This is ", 100, " percent.\n")
</pre> <p><em>produces:</em></p> <pre>This is 100 percent.</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-printf"> <span class="method-callseq"> printf(format_string [, obj, ...]) → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="printf-source"> <pre class="c" data-language="c">VALUE
rb_io_printf(int argc, const VALUE *argv, VALUE out)
{
    rb_io_write(out, rb_f_sprintf(argc, argv));
    return Qnil;
}</pre> </div> <p>Formats and writes to <em>ios</em>, converting parameters under control of the format string. See <a href="kernel#method-i-sprintf"><code>Kernel#sprintf</code></a> for details.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-putc"> <span class="method-callseq"> putc(obj) → obj </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="putc-source"> <pre class="c" data-language="c">static VALUE
rb_io_putc(VALUE io, VALUE ch)
{
    VALUE str;
    if (RB_TYPE_P(ch, T_STRING)) {
        str = rb_str_substr(ch, 0, 1);
    }
    else {
        char c = NUM2CHR(ch);
        str = rb_str_new(&amp;c, 1);
    }
    rb_io_write(io, str);
    return ch;
}</pre> </div> <p>If <em>obj</em> is <a href="numeric"><code>Numeric</code></a>, write the character whose code is the least-significant byte of <em>obj</em>. If <em>obj</em> is <a href="string"><code>String</code></a>, write the first character of <em>obj</em> to <em>ios</em>. Otherwise, raise <a href="typeerror"><code>TypeError</code></a>.</p> <pre class="ruby" data-language="ruby">$stdout.putc "A"
$stdout.putc 65
</pre> <p><em>produces:</em></p> <pre class="ruby" data-language="ruby">AA
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-puts"> <span class="method-callseq"> puts(obj, ...) → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="puts-source"> <pre class="c" data-language="c">VALUE
rb_io_puts(int argc, const VALUE *argv, VALUE out)
{
    int i, n;
    VALUE line, args[2];

    /* if no argument given, print newline. */
    if (argc == 0) {
        rb_io_write(out, rb_default_rs);
        return Qnil;
    }
    for (i=0; i&lt;argc; i++) {
        if (RB_TYPE_P(argv[i], T_STRING)) {
            line = argv[i];
            goto string;
        }
        if (rb_exec_recursive(io_puts_ary, argv[i], out)) {
            continue;
        }
        line = rb_obj_as_string(argv[i]);
      string:
        n = 0;
        args[n++] = line;
        if (RSTRING_LEN(line) == 0 ||
            !rb_str_end_with_asciichar(line, '\n')) {
            args[n++] = rb_default_rs;
        }
        rb_io_writev(out, n, args);
    }

    return Qnil;
}</pre> </div> <p>Writes the given object(s) to <em>ios</em>. Writes a newline after any that do not already end with a newline sequence. Returns <code>nil</code>.</p> <p>The stream must be opened for writing. If called with an array argument, writes each element on a new line. Each given object that isn't a string or array will be converted by calling its <code>to_s</code> method. If called without arguments, outputs a single newline.</p> <pre class="ruby" data-language="ruby">$stdout.puts("this", "is", ["a", "test"])
</pre> <p><em>produces:</em></p> <pre class="ruby" data-language="ruby">this
is
a
test
</pre> <p>Note that <code>puts</code> always uses newlines and is not affected by the output record separator (<code>$\</code>).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pwrite"> <span class="method-callseq"> pwrite(string, offset) → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pwrite-source"> <pre class="c" data-language="c">static VALUE
rb_io_pwrite(VALUE io, VALUE str, VALUE offset)
{
    rb_io_t *fptr;
    ssize_t n;
    struct prdwr_internal_arg arg;
    VALUE tmp;

    if (!RB_TYPE_P(str, T_STRING))
        str = rb_obj_as_string(str);

    arg.offset = NUM2OFFT(offset);

    io = GetWriteIO(io);
    GetOpenFile(io, fptr);
    rb_io_check_writable(fptr);
    arg.fd = fptr-&gt;fd;

    tmp = rb_str_tmp_frozen_acquire(str);
    arg.buf = RSTRING_PTR(tmp);
    arg.count = (size_t)RSTRING_LEN(tmp);

    n = (ssize_t)rb_thread_io_blocking_region(internal_pwrite_func, &amp;arg, fptr-&gt;fd);
    if (n &lt; 0) rb_sys_fail_path(fptr-&gt;pathv);
    rb_str_tmp_frozen_release(str, tmp);

    return SSIZET2NUM(n);
}</pre> </div> <p>Writes the given string to <em>ios</em> at <em>offset</em> using pwrite() system call. This is advantageous to combining <a href="io#method-i-seek"><code>IO#seek</code></a> and <a href="io#method-i-write"><code>IO#write</code></a> in that it is atomic, allowing multiple threads/process to share the same <a href="io"><code>IO</code></a> object for reading the file at various locations. This bypasses any userspace buffering of the <a href="io"><code>IO</code></a> layer. Returns the number of bytes written. Raises <a href="systemcallerror"><code>SystemCallError</code></a> on error and <a href="notimplementederror"><code>NotImplementedError</code></a> if platform does not implement the system call.</p> <pre class="ruby" data-language="ruby">File.open("out", "w") do |f|
  f.pwrite("ABCDEF", 3)   #=&gt; 6
end

File.read("out")          #=&gt; "\u0000\u0000\u0000ABCDEF"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-raw"> <span class="method-callseq"> raw(min: nil, time: nil, intr: nil) {|io| } </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="raw-source"> <pre class="c" data-language="c">static VALUE
console_raw(int argc, VALUE *argv, VALUE io)
{
    rawmode_arg_t opts, *optp = rawmode_opt(&amp;argc, argv, 0, 0, &amp;opts);
    return ttymode(io, rb_yield, io, set_rawmode, optp);
}</pre> </div> <p>Yields <code>self</code> within raw mode, and returns the result of the block.</p> <pre class="ruby" data-language="ruby">STDIN.raw(&amp;:gets)
</pre> <p>will read and return a line without echo back and line editing.</p> <p>The parameter <code>min</code> specifies the minimum number of bytes that should be received when a read operation is performed. (default: 1)</p> <p>The parameter <code>time</code> specifies the timeout in <em>seconds</em> with a precision of 1/10 of a second. (default: 0)</p> <p>If the parameter <code>intr</code> is <code>true</code>, enables break, interrupt, quit, and suspend special characters.</p> <p>Refer to the manual page of termios for further details.</p> <p>You must require 'io/console' to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-raw-21"> <span class="method-callseq"> raw!(min: nil, time: nil, intr: nil) → io </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="raw-21-source"> <pre class="c" data-language="c">static VALUE
console_set_raw(int argc, VALUE *argv, VALUE io)
{
    conmode t;
    rb_io_t *fptr;
    int fd;
    rawmode_arg_t opts, *optp = rawmode_opt(&amp;argc, argv, 0, 0, &amp;opts);

    GetOpenFile(io, fptr);
    fd = GetReadFD(fptr);
    if (!getattr(fd, &amp;t)) sys_fail_fptr(fptr);
    set_rawmode(&amp;t, optp);
    if (!setattr(fd, &amp;t)) sys_fail_fptr(fptr);
    return io;
}</pre> </div> <p>Enables raw mode, and returns <code>io</code>.</p> <p>If the terminal mode needs to be back, use <code>io.raw { ... }</code>.</p> <p>See <a href="io#method-i-raw"><code>IO#raw</code></a> for details on the parameters.</p> <p>You must require 'io/console' to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-read"> <span class="method-callseq"> read([length [, outbuf]]) → string, outbuf, or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="read-source"> <pre class="c" data-language="c">static VALUE
io_read(int argc, VALUE *argv, VALUE io)
{
    rb_io_t *fptr;
    long n, len;
    VALUE length, str;
    int shrinkable;
#if defined(RUBY_TEST_CRLF_ENVIRONMENT) || defined(_WIN32)
    int previous_mode;
#endif

    rb_scan_args(argc, argv, "02", &amp;length, &amp;str);

    if (NIL_P(length)) {
        GetOpenFile(io, fptr);
        rb_io_check_char_readable(fptr);
        return read_all(fptr, remain_size(fptr), str);
    }
    len = NUM2LONG(length);
    if (len &lt; 0) {
        rb_raise(rb_eArgError, "negative length %ld given", len);
    }

    shrinkable = io_setstrbuf(&amp;str,len);

    GetOpenFile(io, fptr);
    rb_io_check_byte_readable(fptr);
    if (len == 0) {
        io_set_read_length(str, 0, shrinkable);
        return str;
    }

    READ_CHECK(fptr);
#if defined(RUBY_TEST_CRLF_ENVIRONMENT) || defined(_WIN32)
    previous_mode = set_binary_mode_with_seek_cur(fptr);
#endif
    n = io_fread(str, 0, len, fptr);
    io_set_read_length(str, n, shrinkable);
#if defined(RUBY_TEST_CRLF_ENVIRONMENT) || defined(_WIN32)
    if (previous_mode == O_TEXT) {
        setmode(fptr-&gt;fd, O_TEXT);
    }
#endif
    if (n == 0) return Qnil;

    return str;
}</pre> </div> <p>Reads <em>length</em> bytes from the I/O stream.</p> <p><em>length</em> must be a non-negative integer or <code>nil</code>.</p> <p>If <em>length</em> is a positive integer, <code>read</code> tries to read <em>length</em> bytes without any conversion (binary mode). It returns <code>nil</code> if an EOF is encountered before anything can be read. Fewer than <em>length</em> bytes are returned if an EOF is encountered during the read. In the case of an integer <em>length</em>, the resulting string is always in ASCII-8BIT encoding.</p> <p>If <em>length</em> is omitted or is <code>nil</code>, it reads until EOF and the encoding conversion is applied, if applicable. A string is returned even if EOF is encountered before any data is read.</p> <p>If <em>length</em> is zero, it returns an empty string (<code>""</code>).</p> <p>If the optional <em>outbuf</em> argument is present, it must reference a <a href="string"><code>String</code></a>, which will receive the data. The <em>outbuf</em> will contain only the received data after the method call even if it is not empty at the beginning.</p> <p>When this method is called at end of file, it returns <code>nil</code> or <code>""</code>, depending on <em>length</em>: <code>read</code>, <code>read(nil)</code>, and <code>read(0)</code> return <code>""</code>, <code>read(<em>positive_integer</em>)</code> returns <code>nil</code>.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
f.read(16)   #=&gt; "This is line one"

# read whole file
open("file") do |f|
  data = f.read   # This returns a string even if the file is empty.
  # ...
end

# iterate over fixed length records
open("fixed-record-file") do |f|
  while record = f.read(256)
    # ...
  end
end

# iterate over variable length records,
# each record is prefixed by its 32-bit length
open("variable-record-file") do |f|
  while len = f.read(4)
    len = len.unpack("N")[0]   # 32-bit length
    record = f.read(len)       # This returns a string even if len is 0.
  end
end
</pre> <p>Note that this method behaves like the fread() function in C. This means it retries to invoke read(2) system calls to read data with the specified length (or until EOF). This behavior is preserved even if <em>ios</em> is in non-blocking mode. (This method is non-blocking flag insensitive as other methods.) If you need the behavior like a single read(2) system call, consider <a href="io#method-i-readpartial"><code>readpartial</code></a>, <a href="io#method-i-read_nonblock"><code>read_nonblock</code></a>, and <a href="io#method-i-sysread"><code>sysread</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-read_nonblock"> <span class="method-callseq"> read_nonblock(maxlen [, options]) → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> read_nonblock(maxlen, outbuf [, options]) → outbuf </span> </div> <div class="method-description">
<div class="method-source-code" id="read_nonblock-source"> <pre class="ruby" data-language="ruby"># File io.rb, line 62
def read_nonblock(len, buf = nil, exception: true)
  Primitive.io_read_nonblock(len, buf, exception)
end</pre> </div> <p>Reads at most <em>maxlen</em> bytes from <em>ios</em> using the read(2) system call after O_NONBLOCK is set for the underlying file descriptor.</p> <p>If the optional <em>outbuf</em> argument is present, it must reference a <a href="string"><code>String</code></a>, which will receive the data. The <em>outbuf</em> will contain only the received data after the method call even if it is not empty at the beginning.</p> <p><a href="io#method-i-read_nonblock"><code>read_nonblock</code></a> just calls the read(2) system call. It causes all errors the read(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. The caller should care such errors.</p> <p>If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by <a href="io/waitreadable"><code>IO::WaitReadable</code></a>. So <a href="io/waitreadable"><code>IO::WaitReadable</code></a> can be used to rescue the exceptions for retrying read_nonblock.</p> <p><a href="io#method-i-read_nonblock"><code>read_nonblock</code></a> causes <a href="eoferror"><code>EOFError</code></a> on EOF.</p> <p>On some platforms, such as Windows, non-blocking mode is not supported on <a href="io"><code>IO</code></a> objects other than sockets. In such cases, Errno::EBADF will be raised.</p> <p>If the read byte buffer is not empty, <a href="io#method-i-read_nonblock"><code>read_nonblock</code></a> reads from the buffer like readpartial. In this case, the read(2) system call is not called.</p> <p>When <a href="io#method-i-read_nonblock"><code>read_nonblock</code></a> raises an exception kind of <a href="io/waitreadable"><code>IO::WaitReadable</code></a>, <a href="io#method-i-read_nonblock"><code>read_nonblock</code></a> should not be called until io is readable for avoiding busy loop. This can be done as follows.</p> <pre class="ruby" data-language="ruby"># emulates blocking read (readpartial).
begin
  result = io.read_nonblock(maxlen)
rescue IO::WaitReadable
  IO.select([io])
  retry
end
</pre> <p>Although <a href="io#method-i-read_nonblock"><code>IO#read_nonblock</code></a> doesn't raise <a href="io/waitwritable"><code>IO::WaitWritable</code></a>. <a href="openssl/buffering#method-i-read_nonblock"><code>OpenSSL::Buffering#read_nonblock</code></a> can raise <a href="io/waitwritable"><code>IO::WaitWritable</code></a>. If <a href="io"><code>IO</code></a> and SSL should be used polymorphically, <a href="io/waitwritable"><code>IO::WaitWritable</code></a> should be rescued too. See the document of <a href="openssl/buffering#method-i-read_nonblock"><code>OpenSSL::Buffering#read_nonblock</code></a> for sample code.</p> <p>Note that this method is identical to readpartial except the non-blocking flag is set.</p> <p>By specifying a keyword argument <em>exception</em> to <code>false</code>, you can indicate that <a href="io#method-i-read_nonblock"><code>read_nonblock</code></a> should not raise an <a href="io/waitreadable"><code>IO::WaitReadable</code></a> exception, but return the symbol <code>:wait_readable</code> instead. At EOF, it will return nil instead of raising <a href="eoferror"><code>EOFError</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-readbyte"> <span class="method-callseq"> readbyte → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="readbyte-source"> <pre class="c" data-language="c">static VALUE
rb_io_readbyte(VALUE io)
{
    VALUE c = rb_io_getbyte(io);

    if (NIL_P(c)) {
        rb_eof_error();
    }
    return c;
}</pre> </div> <p>Reads a byte as with <a href="io#method-i-getbyte"><code>IO#getbyte</code></a>, but raises an <a href="eoferror"><code>EOFError</code></a> on end of file.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-readchar"> <span class="method-callseq"> readchar → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="readchar-source"> <pre class="c" data-language="c">static VALUE
rb_io_readchar(VALUE io)
{
    VALUE c = rb_io_getc(io);

    if (NIL_P(c)) {
        rb_eof_error();
    }
    return c;
}</pre> </div> <p>Reads a one-character string from <em>ios</em>. Raises an <a href="eoferror"><code>EOFError</code></a> on end of file.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
f.readchar   #=&gt; "h"
f.readchar   #=&gt; "e"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-readline"> <span class="method-callseq"> readline(sep=$/ [, getline_args]) → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> readline(limit [, getline_args]) → string </span> </div> <div class="method-heading"> <span class="method-callseq"> readline(sep, limit [, getline_args]) → string </span> </div> <div class="method-description">
<div class="method-source-code" id="readline-source"> <pre class="c" data-language="c">static VALUE
rb_io_readline(int argc, VALUE *argv, VALUE io)
{
    VALUE line = rb_io_gets_m(argc, argv, io);

    if (NIL_P(line)) {
        rb_eof_error();
    }
    return line;
}</pre> </div> <p>Reads a line as with <a href="io#method-i-gets"><code>IO#gets</code></a>, but raises an <a href="eoferror"><code>EOFError</code></a> on end of file.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-readlines"> <span class="method-callseq"> readlines(sep=$/ [, getline_args]) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> readlines(limit [, getline_args]) → array </span> </div> <div class="method-heading"> <span class="method-callseq"> readlines(sep, limit [, getline_args]) → array </span> </div> <div class="method-description">
<div class="method-source-code" id="readlines-source"> <pre class="c" data-language="c">static VALUE
rb_io_readlines(int argc, VALUE *argv, VALUE io)
{
    struct getline_arg args;

    prepare_getline_args(argc, argv, &amp;args, io);
    return io_readlines(&amp;args, io);
}</pre> </div> <p>Reads all of the lines in <em>ios</em>, and returns them in an array. Lines are separated by the optional <em>sep</em>. If <em>sep</em> is <code>nil</code>, the rest of the stream is returned as a single record. If the first argument is an integer, or an optional second argument is given, the returning string would not be longer than the given value in bytes. The stream must be opened for reading or an <a href="ioerror"><code>IOError</code></a> will be raised.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
f.readlines[0]   #=&gt; "This is line one\n"

f = File.new("testfile", chomp: true)
f.readlines[0]   #=&gt; "This is line one"
</pre> <p>See <a href="io#method-c-readlines"><code>IO.readlines</code></a> for details about getline_args.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-readpartial"> <span class="method-callseq"> readpartial(maxlen) → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> readpartial(maxlen, outbuf) → outbuf </span> </div> <div class="method-description">
<div class="method-source-code" id="readpartial-source"> <pre class="c" data-language="c">static VALUE
io_readpartial(int argc, VALUE *argv, VALUE io)
{
    VALUE ret;

    ret = io_getpartial(argc, argv, io, Qnil, 0);
    if (NIL_P(ret))
        rb_eof_error();
    return ret;
}</pre> </div> <p>Reads at most <em>maxlen</em> bytes from the I/O stream. It blocks only if <em>ios</em> has no data immediately available. It doesn't block if some data available.</p> <p>If the optional <em>outbuf</em> argument is present, it must reference a <a href="string"><code>String</code></a>, which will receive the data. The <em>outbuf</em> will contain only the received data after the method call even if it is not empty at the beginning.</p> <p>It raises <a href="eoferror"><code>EOFError</code></a> on end of file.</p> <p>readpartial is designed for streams such as pipe, socket, tty, etc. It blocks only when no data immediately available. This means that it blocks only when following all conditions hold.</p> <ul>
<li> <p>the byte buffer in the <a href="io"><code>IO</code></a> object is empty.</p> </li>
<li> <p>the content of the stream is empty.</p> </li>
<li> <p>the stream is not reached to EOF.</p> </li>
</ul> <p>When readpartial blocks, it waits data or EOF on the stream. If some data is reached, readpartial returns with the data. If EOF is reached, readpartial raises <a href="eoferror"><code>EOFError</code></a>.</p> <p>When readpartial doesn't blocks, it returns or raises immediately. If the byte buffer is not empty, it returns the data in the buffer. Otherwise if the stream has some content, it returns the data in the stream. Otherwise if the stream is reached to EOF, it raises <a href="eoferror"><code>EOFError</code></a>.</p> <pre class="ruby" data-language="ruby">r, w = IO.pipe           #               buffer          pipe content
w &lt;&lt; "abc"               #               ""              "abc".
r.readpartial(4096)      #=&gt; "abc"       ""              ""
r.readpartial(4096)      # blocks because buffer and pipe is empty.

r, w = IO.pipe           #               buffer          pipe content
w &lt;&lt; "abc"               #               ""              "abc"
w.close                  #               ""              "abc" EOF
r.readpartial(4096)      #=&gt; "abc"       ""              EOF
r.readpartial(4096)      # raises EOFError

r, w = IO.pipe           #               buffer          pipe content
w &lt;&lt; "abc\ndef\n"        #               ""              "abc\ndef\n"
r.gets                   #=&gt; "abc\n"     "def\n"         ""
w &lt;&lt; "ghi\n"             #               "def\n"         "ghi\n"
r.readpartial(4096)      #=&gt; "def\n"     ""              "ghi\n"
r.readpartial(4096)      #=&gt; "ghi\n"     ""              ""
</pre> <p>Note that readpartial behaves similar to sysread. The differences are:</p> <ul>
<li> <p>If the byte buffer is not empty, read from the byte buffer instead of “sysread for buffered <a href="io"><code>IO</code></a> (<a href="ioerror"><code>IOError</code></a>)”.</p> </li>
<li> <p>It doesn't cause Errno::EWOULDBLOCK and Errno::EINTR. When readpartial meets EWOULDBLOCK and EINTR by read system call, readpartial retry the system call.</p> </li>
</ul> <p>The latter means that readpartial is nonblocking-flag insensitive. It blocks on the situation <a href="io#method-i-sysread"><code>IO#sysread</code></a> causes Errno::EWOULDBLOCK as if the fd is blocking mode.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ready-3F"> <span class="method-callseq"> ready? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ready-3F-source"> <pre class="c" data-language="c">static VALUE
io_ready_p(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    if (rb_io_read_pending(fptr)) return Qtrue;

    return io_wait_event(io, RUBY_IO_READABLE, RB_INT2NUM(0));
}</pre> </div> <p>Returns <code>true</code> if input available without blocking, or <code>false</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-reopen"> <span class="method-callseq"> reopen(other_IO) → ios </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> reopen(path, mode [, opt]) → ios </span> </div> <div class="method-description">
<div class="method-source-code" id="reopen-source"> <pre class="c" data-language="c">static VALUE
rb_io_reopen(int argc, VALUE *argv, VALUE file)
{
    VALUE fname, nmode, opt;
    int oflags;
    rb_io_t *fptr;

    if (rb_scan_args(argc, argv, "11:", &amp;fname, &amp;nmode, &amp;opt) == 1) {
        VALUE tmp = rb_io_check_io(fname);
        if (!NIL_P(tmp)) {
            return io_reopen(file, tmp);
        }
    }

    FilePathValue(fname);
    rb_io_taint_check(file);
    fptr = RFILE(file)-&gt;fptr;
    if (!fptr) {
        fptr = RFILE(file)-&gt;fptr = ZALLOC(rb_io_t);
    }

    if (!NIL_P(nmode) || !NIL_P(opt)) {
        int fmode;
        convconfig_t convconfig;

        rb_io_extract_modeenc(&amp;nmode, 0, opt, &amp;oflags, &amp;fmode, &amp;convconfig);
        if (IS_PREP_STDIO(fptr) &amp;&amp;
            ((fptr-&gt;mode &amp; FMODE_READWRITE) &amp; (fmode &amp; FMODE_READWRITE)) !=
            (fptr-&gt;mode &amp; FMODE_READWRITE)) {
            rb_raise(rb_eArgError,
                     "%s can't change access mode from \"%s\" to \"%s\"",
                     PREP_STDIO_NAME(fptr), rb_io_fmode_modestr(fptr-&gt;mode),
                     rb_io_fmode_modestr(fmode));
        }
        fptr-&gt;mode = fmode;
        fptr-&gt;encs = convconfig;
    }
    else {
        oflags = rb_io_fmode_oflags(fptr-&gt;mode);
    }

    fptr-&gt;pathv = fname;
    if (fptr-&gt;fd &lt; 0) {
        fptr-&gt;fd = rb_sysopen(fptr-&gt;pathv, oflags, 0666);
        fptr-&gt;stdio_file = 0;
        return file;
    }

    if (fptr-&gt;mode &amp; FMODE_WRITABLE) {
        if (io_fflush(fptr) &lt; 0)
            rb_sys_fail_on_write(fptr);
    }
    fptr-&gt;rbuf.off = fptr-&gt;rbuf.len = 0;

    if (fptr-&gt;stdio_file) {
        int e = rb_freopen(rb_str_encode_ospath(fptr-&gt;pathv),
                           rb_io_oflags_modestr(oflags),
                           fptr-&gt;stdio_file);
        if (e) rb_syserr_fail_path(e, fptr-&gt;pathv);
        fptr-&gt;fd = fileno(fptr-&gt;stdio_file);
        rb_fd_fix_cloexec(fptr-&gt;fd);
#ifdef USE_SETVBUF
        if (setvbuf(fptr-&gt;stdio_file, NULL, _IOFBF, 0) != 0)
            rb_warn("setvbuf() can't be honoured for %"PRIsVALUE, fptr-&gt;pathv);
#endif
        if (fptr-&gt;stdio_file == stderr) {
            if (setvbuf(fptr-&gt;stdio_file, NULL, _IONBF, BUFSIZ) != 0)
                rb_warn("setvbuf() can't be honoured for %"PRIsVALUE, fptr-&gt;pathv);
        }
        else if (fptr-&gt;stdio_file == stdout &amp;&amp; isatty(fptr-&gt;fd)) {
            if (setvbuf(fptr-&gt;stdio_file, NULL, _IOLBF, BUFSIZ) != 0)
                rb_warn("setvbuf() can't be honoured for %"PRIsVALUE, fptr-&gt;pathv);
        }
    }
    else {
        int tmpfd = rb_sysopen(fptr-&gt;pathv, oflags, 0666);
        int err = 0;
        if (rb_cloexec_dup2(tmpfd, fptr-&gt;fd) &lt; 0)
            err = errno;
        (void)close(tmpfd);
        if (err) {
            rb_syserr_fail_path(err, fptr-&gt;pathv);
        }
    }

    return file;
}</pre> </div> <p>Reassociates <em>ios</em> with the I/O stream given in <em>other_IO</em> or to a new stream opened on <em>path</em>. This may dynamically change the actual class of this stream. The <code>mode</code> and <code>opt</code> parameters accept the same values as <a href="io#method-c-open"><code>IO.open</code></a>.</p> <pre class="ruby" data-language="ruby">f1 = File.new("testfile")
f2 = File.new("testfile")
f2.readlines[0]   #=&gt; "This is line one\n"
f2.reopen(f1)     #=&gt; #&lt;File:testfile&gt;
f2.readlines[0]   #=&gt; "This is line one\n"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rewind"> <span class="method-callseq"> rewind → 0 </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rewind-source"> <pre class="c" data-language="c">static VALUE
rb_io_rewind(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (io_seek(fptr, 0L, 0) &lt; 0 &amp;&amp; errno) rb_sys_fail_path(fptr-&gt;pathv);
    if (io == ARGF.current_file) {
        ARGF.lineno -= fptr-&gt;lineno;
    }
    fptr-&gt;lineno = 0;
    if (fptr-&gt;readconv) {
        clear_readconv(fptr);
    }

    return INT2FIX(0);
}</pre> </div> <p>Positions <em>ios</em> to the beginning of input, resetting <a href="io#method-i-lineno"><code>lineno</code></a> to zero.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
f.readline   #=&gt; "This is line one\n"
f.rewind     #=&gt; 0
f.lineno     #=&gt; 0
f.readline   #=&gt; "This is line one\n"
</pre> <p>Note that it cannot be used with streams such as pipes, ttys, and sockets.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-scroll_backward"> <span class="method-name">scroll_backward</span><span class="method-args">(p1)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="scroll_backward-source"> <pre class="c" data-language="c">static VALUE
console_scroll_backward(VALUE io, VALUE val)
{
    return console_scroll(io, -NUM2INT(val));
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-scroll_forward"> <span class="method-name">scroll_forward</span><span class="method-args">(p1)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="scroll_forward-source"> <pre class="c" data-language="c">static VALUE
console_scroll_forward(VALUE io, VALUE val)
{
    return console_scroll(io, +NUM2INT(val));
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-seek"> <span class="method-callseq"> seek(amount, whence=IO::SEEK_SET) → 0 </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="seek-source"> <pre class="c" data-language="c">static VALUE
rb_io_seek_m(int argc, VALUE *argv, VALUE io)
{
    VALUE offset, ptrname;
    int whence = SEEK_SET;

    if (rb_scan_args(argc, argv, "11", &amp;offset, &amp;ptrname) == 2) {
        whence = interpret_seek_whence(ptrname);
    }

    return rb_io_seek(io, offset, whence);
}</pre> </div> <p>Seeks to a given offset <em>anInteger</em> in the stream according to the value of <em>whence</em>:</p> <pre>:CUR or IO::SEEK_CUR  | Seeks to _amount_ plus current position
----------------------+--------------------------------------------------
:END or IO::SEEK_END  | Seeks to _amount_ plus end of stream (you
                      | probably want a negative value for _amount_)
----------------------+--------------------------------------------------
:SET or IO::SEEK_SET  | Seeks to the absolute location given by _amount_</pre> <p>Example:</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
f.seek(-13, IO::SEEK_END)   #=&gt; 0
f.readline                  #=&gt; "And so on...\n"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-set_encoding"> <span class="method-callseq"> set_encoding(ext_enc) → io </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> set_encoding("ext_enc:int_enc") → io </span> </div> <div class="method-heading"> <span class="method-callseq"> set_encoding(ext_enc, int_enc) → io </span> </div> <div class="method-heading"> <span class="method-callseq"> set_encoding("ext_enc:int_enc", opt) → io </span> </div> <div class="method-heading"> <span class="method-callseq"> set_encoding(ext_enc, int_enc, opt) → io </span> </div> <div class="method-description">
<div class="method-source-code" id="set_encoding-source"> <pre class="c" data-language="c">static VALUE
rb_io_set_encoding(int argc, VALUE *argv, VALUE io)
{
    rb_io_t *fptr;
    VALUE v1, v2, opt;

    if (!RB_TYPE_P(io, T_FILE)) {
        return rb_funcallv(io, id_set_encoding, argc, argv);
    }

    argc = rb_scan_args(argc, argv, "11:", &amp;v1, &amp;v2, &amp;opt);
    GetOpenFile(io, fptr);
    io_encoding_set(fptr, v1, v2, opt);
    return io;
}</pre> </div> <p>If single argument is specified, read string from io is tagged with the encoding specified. If encoding is a colon separated two encoding names “A:B”, the read string is converted from encoding A (external encoding) to encoding B (internal encoding), then tagged with B. If two arguments are specified, those must be encoding objects or encoding names, and the first one is the external encoding, and the second one is the internal encoding. If the external encoding and the internal encoding is specified, optional hash argument specify the conversion option.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-set_encoding_by_bom"> <span class="method-callseq"> set_encoding_by_bom → encoding or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="set_encoding_by_bom-source"> <pre class="c" data-language="c">static VALUE
rb_io_set_encoding_by_bom(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (!(fptr-&gt;mode &amp; FMODE_BINMODE)) {
        rb_raise(rb_eArgError, "ASCII incompatible encoding needs binmode");
    }
    if (fptr-&gt;encs.enc2) {
        rb_raise(rb_eArgError, "encoding conversion is set");
    }
    else if (fptr-&gt;encs.enc &amp;&amp; fptr-&gt;encs.enc != rb_ascii8bit_encoding()) {
        rb_raise(rb_eArgError, "encoding is set to %s already",
                 rb_enc_name(fptr-&gt;encs.enc));
    }
    if (!io_set_encoding_by_bom(io)) return Qnil;
    return rb_enc_from_encoding(fptr-&gt;encs.enc);
}</pre> </div> <p>Checks if <code>ios</code> starts with a BOM, and then consumes it and sets the external encoding. Returns the result encoding if found, or nil. If <code>ios</code> is not binmode or its encoding has been set already, an exception will be raised.</p> <pre class="ruby" data-language="ruby">File.write("bom.txt", "\u{FEFF}abc")
ios = File.open("bom.txt", "rb")
ios.set_encoding_by_bom    #=&gt;  #&lt;Encoding:UTF-8&gt;

File.write("nobom.txt", "abc")
ios = File.open("nobom.txt", "rb")
ios.set_encoding_by_bom    #=&gt;  nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-stat"> <span class="method-callseq"> stat → stat </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="stat-source"> <pre class="c" data-language="c">static VALUE
rb_io_stat(VALUE obj)
{
    rb_io_t *fptr;
    struct stat st;

    GetOpenFile(obj, fptr);
    if (fstat(fptr-&gt;fd, &amp;st) == -1) {
        rb_sys_fail_path(fptr-&gt;pathv);
    }
    return rb_stat_new(&amp;st);
}</pre> </div> <p>Returns status information for <em>ios</em> as an object of type <a href="file/stat"><code>File::Stat</code></a>.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
s = f.stat
"%o" % s.mode   #=&gt; "100644"
s.blksize       #=&gt; 4096
s.atime         #=&gt; Wed Apr 09 08:53:54 CDT 2003
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-sync"> <span class="method-callseq"> sync → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="sync-source"> <pre class="c" data-language="c">static VALUE
rb_io_sync(VALUE io)
{
    rb_io_t *fptr;

    io = GetWriteIO(io);
    GetOpenFile(io, fptr);
    return (fptr-&gt;mode &amp; FMODE_SYNC) ? Qtrue : Qfalse;
}</pre> </div> <p>Returns the current “sync mode'' of <em>ios</em>. When sync mode is true, all output is immediately flushed to the underlying operating system and is not buffered by Ruby internally. See also <a href="io#method-i-fsync"><code>IO#fsync</code></a>.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
f.sync   #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-sync-3D"> <span class="method-callseq"> sync = boolean → boolean </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="sync-3D-source"> <pre class="c" data-language="c">static VALUE
rb_io_set_sync(VALUE io, VALUE sync)
{
    rb_io_t *fptr;

    io = GetWriteIO(io);
    GetOpenFile(io, fptr);
    if (RTEST(sync)) {
        fptr-&gt;mode |= FMODE_SYNC;
    }
    else {
        fptr-&gt;mode &amp;= ~FMODE_SYNC;
    }
    return sync;
}</pre> </div> <p>Sets the “sync mode'' to <code>true</code> or <code>false</code>. When sync mode is true, all output is immediately flushed to the underlying operating system and is not buffered internally. Returns the new state. See also <a href="io#method-i-fsync"><code>IO#fsync</code></a>.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
f.sync = true
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-sysread"> <span class="method-callseq"> sysread(maxlen[, outbuf]) → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="sysread-source"> <pre class="c" data-language="c">static VALUE
rb_io_sysread(int argc, VALUE *argv, VALUE io)
{
    VALUE len, str;
    rb_io_t *fptr;
    long n, ilen;
    struct io_internal_read_struct iis;
    int shrinkable;

    rb_scan_args(argc, argv, "11", &amp;len, &amp;str);
    ilen = NUM2LONG(len);

    shrinkable = io_setstrbuf(&amp;str, ilen);
    if (ilen == 0) return str;

    GetOpenFile(io, fptr);
    rb_io_check_byte_readable(fptr);

    if (READ_DATA_BUFFERED(fptr)) {
        rb_raise(rb_eIOError, "sysread for buffered IO");
    }

    /*
     * FIXME: removing rb_thread_wait_fd() here changes sysread semantics
     * on non-blocking IOs.  However, it's still currently possible
     * for sysread to raise Errno::EAGAIN if another thread read()s
     * the IO after we return from rb_thread_wait_fd() but before
     * we call read()
     */
    rb_thread_wait_fd(fptr-&gt;fd);

    rb_io_check_closed(fptr);

    io_setstrbuf(&amp;str, ilen);
    iis.fd = fptr-&gt;fd;
    iis.nonblock = 1; /* for historical reasons, maybe (see above) */
    iis.buf = RSTRING_PTR(str);
    iis.capa = ilen;
    n = read_internal_locktmp(str, &amp;iis);

    if (n &lt; 0) {
        rb_sys_fail_path(fptr-&gt;pathv);
    }
    io_set_read_length(str, n, shrinkable);
    if (n == 0 &amp;&amp; ilen &gt; 0) {
        rb_eof_error();
    }

    return str;
}</pre> </div> <p>Reads <em>maxlen</em> bytes from <em>ios</em> using a low-level read and returns them as a string. Do not mix with other methods that read from <em>ios</em> or you may get unpredictable results.</p> <p>If the optional <em>outbuf</em> argument is present, it must reference a <a href="string"><code>String</code></a>, which will receive the data. The <em>outbuf</em> will contain only the received data after the method call even if it is not empty at the beginning.</p> <p>Raises <a href="systemcallerror"><code>SystemCallError</code></a> on error and <a href="eoferror"><code>EOFError</code></a> at end of file.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
f.sysread(16)   #=&gt; "This is line one"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-sysseek"> <span class="method-callseq"> sysseek(offset, whence=IO::SEEK_SET) → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="sysseek-source"> <pre class="c" data-language="c">static VALUE
rb_io_sysseek(int argc, VALUE *argv, VALUE io)
{
    VALUE offset, ptrname;
    int whence = SEEK_SET;
    rb_io_t *fptr;
    off_t pos;

    if (rb_scan_args(argc, argv, "11", &amp;offset, &amp;ptrname) == 2) {
        whence = interpret_seek_whence(ptrname);
    }
    pos = NUM2OFFT(offset);
    GetOpenFile(io, fptr);
    if ((fptr-&gt;mode &amp; FMODE_READABLE) &amp;&amp;
        (READ_DATA_BUFFERED(fptr) || READ_CHAR_PENDING(fptr))) {
        rb_raise(rb_eIOError, "sysseek for buffered IO");
    }
    if ((fptr-&gt;mode &amp; FMODE_WRITABLE) &amp;&amp; fptr-&gt;wbuf.len) {
        rb_warn("sysseek for buffered IO");
    }
    errno = 0;
    pos = lseek(fptr-&gt;fd, pos, whence);
    if (pos &lt; 0 &amp;&amp; errno) rb_sys_fail_path(fptr-&gt;pathv);

    return OFFT2NUM(pos);
}</pre> </div> <p>Seeks to a given <em>offset</em> in the stream according to the value of <em>whence</em> (see <a href="io#method-i-seek"><code>IO#seek</code></a> for values of <em>whence</em>). Returns the new offset into the file.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
f.sysseek(-13, IO::SEEK_END)   #=&gt; 53
f.sysread(10)                  #=&gt; "And so on."
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-syswrite"> <span class="method-callseq"> syswrite(string) → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="syswrite-source"> <pre class="c" data-language="c">static VALUE
rb_io_syswrite(VALUE io, VALUE str)
{
    VALUE tmp;
    rb_io_t *fptr;
    long n, len;
    const char *ptr;

    if (!RB_TYPE_P(str, T_STRING))
        str = rb_obj_as_string(str);

    io = GetWriteIO(io);
    GetOpenFile(io, fptr);
    rb_io_check_writable(fptr);

    if (fptr-&gt;wbuf.len) {
        rb_warn("syswrite for buffered IO");
    }

    tmp = rb_str_tmp_frozen_acquire(str);
    RSTRING_GETMEM(tmp, ptr, len);
    n = rb_write_internal(fptr-&gt;fd, ptr, len);
    if (n &lt; 0) rb_sys_fail_path(fptr-&gt;pathv);
    rb_str_tmp_frozen_release(str, tmp);

    return LONG2FIX(n);
}</pre> </div> <p>Writes the given string to <em>ios</em> using a low-level write. Returns the number of bytes written. Do not mix with other methods that write to <em>ios</em> or you may get unpredictable results. Raises <a href="systemcallerror"><code>SystemCallError</code></a> on error.</p> <pre class="ruby" data-language="ruby">f = File.new("out", "w")
f.syswrite("ABCDEF")   #=&gt; 6
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-tell"> <span class="method-callseq"> tell → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="tell-source"> <pre class="c" data-language="c">static VALUE
rb_io_tell(VALUE io)
{
    rb_io_t *fptr;
    off_t pos;

    GetOpenFile(io, fptr);
    pos = io_tell(fptr);
    if (pos &lt; 0 &amp;&amp; errno) rb_sys_fail_path(fptr-&gt;pathv);
    pos -= fptr-&gt;rbuf.len;
    return OFFT2NUM(pos);
}</pre> </div> <p>Returns the current offset (in bytes) of <em>ios</em>.</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")
f.pos    #=&gt; 0
f.gets   #=&gt; "This is line one\n"
f.pos    #=&gt; 17
</pre>  </div> <div class="aliases"> Also aliased as: <a href="io#method-i-pos">pos</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-to_i"> <span class="method-callseq"> to_i → integer </span> </div> <div class="method-description"> <p>Returns an integer representing the numeric file descriptor for <em>ios</em>.</p> <pre class="ruby" data-language="ruby">$stdin.fileno    #=&gt; 0
$stdout.fileno   #=&gt; 1
</pre> </div> <div class="aliases"> Alias for: <a href="io#method-i-fileno">fileno</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_io"> <span class="method-callseq"> to_io → ios </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_io-source"> <pre class="c" data-language="c">static VALUE
rb_io_to_io(VALUE io)
{
    return io;
}</pre> </div> <p>Returns <em>ios</em>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-tty-3F"> <span class="method-callseq"> tty? → true or false </span> </div> <div class="method-description"> <p>Returns <code>true</code> if <em>ios</em> is associated with a terminal device (tty), <code>false</code> otherwise.</p> <pre class="ruby" data-language="ruby">File.new("testfile").isatty   #=&gt; false
File.new("/dev/tty").isatty   #=&gt; true
</pre> </div> <div class="aliases"> Alias for: <a href="io#method-i-isatty">isatty</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ungetbyte"> <span class="method-callseq"> ungetbyte(string) → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> ungetbyte(integer) → nil </span> </div> <div class="method-description">
<div class="method-source-code" id="ungetbyte-source"> <pre class="c" data-language="c">VALUE
rb_io_ungetbyte(VALUE io, VALUE b)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_byte_readable(fptr);
    switch (TYPE(b)) {
      case T_NIL:
        return Qnil;
      case T_FIXNUM:
      case T_BIGNUM: ;
        VALUE v = rb_int_modulo(b, INT2FIX(256));
        unsigned char c = NUM2INT(v) &amp; 0xFF;
        b = rb_str_new((const char *)&amp;c, 1);
        break;
      default:
        SafeStringValue(b);
    }
    io_ungetbyte(b, fptr);
    return Qnil;
}</pre> </div> <p>Pushes back bytes (passed as a parameter) onto <em>ios</em>, such that a subsequent buffered read will return it. Only one byte may be pushed back before a subsequent read operation (that is, you will be able to read only the last of several bytes that have been pushed back). Has no effect with unbuffered reads (such as <a href="io#method-i-sysread"><code>IO#sysread</code></a>).</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")   #=&gt; #&lt;File:testfile&gt;
b = f.getbyte              #=&gt; 0x38
f.ungetbyte(b)             #=&gt; nil
f.getbyte                  #=&gt; 0x38
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ungetc"> <span class="method-callseq"> ungetc(string) → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ungetc-source"> <pre class="c" data-language="c">VALUE
rb_io_ungetc(VALUE io, VALUE c)
{
    rb_io_t *fptr;
    long len;

    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);
    if (FIXNUM_P(c)) {
        c = rb_enc_uint_chr(FIX2UINT(c), io_read_encoding(fptr));
    }
    else if (RB_TYPE_P(c, T_BIGNUM)) {
        c = rb_enc_uint_chr(NUM2UINT(c), io_read_encoding(fptr));
    }
    else {
        SafeStringValue(c);
    }
    if (NEED_READCONV(fptr)) {
        SET_BINARY_MODE(fptr);
        len = RSTRING_LEN(c);
#if SIZEOF_LONG &gt; SIZEOF_INT
        if (len &gt; INT_MAX)
            rb_raise(rb_eIOError, "ungetc failed");
#endif
        make_readconv(fptr, (int)len);
        if (fptr-&gt;cbuf.capa - fptr-&gt;cbuf.len &lt; len)
            rb_raise(rb_eIOError, "ungetc failed");
        if (fptr-&gt;cbuf.off &lt; len) {
            MEMMOVE(fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.capa-fptr-&gt;cbuf.len,
                    fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off,
                    char, fptr-&gt;cbuf.len);
            fptr-&gt;cbuf.off = fptr-&gt;cbuf.capa-fptr-&gt;cbuf.len;
        }
        fptr-&gt;cbuf.off -= (int)len;
        fptr-&gt;cbuf.len += (int)len;
        MEMMOVE(fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off, RSTRING_PTR(c), char, len);
    }
    else {
        NEED_NEWLINE_DECORATOR_ON_READ_CHECK(fptr);
        io_ungetbyte(c, fptr);
    }
    return Qnil;
}</pre> </div> <p>Pushes back one character (passed as a parameter) onto <em>ios</em>, such that a subsequent buffered character read will return it. Only one character may be pushed back before a subsequent read operation (that is, you will be able to read only the last of several characters that have been pushed back). Has no effect with unbuffered reads (such as <a href="io#method-i-sysread"><code>IO#sysread</code></a>).</p> <pre class="ruby" data-language="ruby">f = File.new("testfile")   #=&gt; #&lt;File:testfile&gt;
c = f.getc                 #=&gt; "8"
f.ungetc(c)                #=&gt; nil
f.getc                     #=&gt; "8"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-wait"> <span class="method-callseq"> wait(events, timeout) → event mask or false. </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> wait(timeout = nil, mode = :read) → event mask or false (deprecated) </span> </div> <div class="method-description">
<div class="method-source-code" id="wait-source"> <pre class="c" data-language="c">static VALUE
io_wait(int argc, VALUE *argv, VALUE io)
{
    VALUE timeout = Qnil;
    rb_io_event_t events = 0;

    if (argc &lt; 2 || (argc &gt;= 2 &amp;&amp; RB_SYMBOL_P(argv[1]))) {
        if (argc &gt; 0) {
            timeout = argv[0];
        }

        for (int i = 1; i &lt; argc; i += 1) {
            events |= wait_mode_sym(argv[i]);
        }
    }
    else if (argc == 2) {
        events = RB_NUM2UINT(argv[0]);

        if (argv[1] != Qnil) {
            timeout = argv[1];
        }
    }
    else {
        // TODO error
        return Qnil;
    }

    if (events == 0) {
        events = RUBY_IO_READABLE;
    }

    if (events &amp; RUBY_IO_READABLE) {
        rb_io_t *fptr = NULL;
        RB_IO_POINTER(io, fptr);

        if (rb_io_read_pending(fptr)) {
            return Qtrue;
        }
    }

    return io_wait_event(io, events, timeout);
}</pre> </div> <p>Waits until the <a href="io"><code>IO</code></a> becomes ready for the specified events and returns the subset of events that become ready, or <code>false</code> when times out.</p> <p>The events can be a bit mask of <code>IO::READABLE</code>, <code>IO::WRITABLE</code> or <code>IO::PRIORITY</code>.</p> <p>Returns <code>true</code> immediately when buffered data is available.</p> <p>Optional parameter <code>mode</code> is one of <code>:read</code>, <code>:write</code>, or <code>:read_write</code> (deprecated).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-wait_priority"> <span class="method-callseq"> wait_priority → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> wait_priority(timeout) → true or false </span> </div> <div class="method-description">
<div class="method-source-code" id="wait_priority-source"> <pre class="c" data-language="c">static VALUE
io_wait_priority(int argc, VALUE *argv, VALUE io)
{
    rb_io_t *fptr = NULL;

    RB_IO_POINTER(io, fptr);
    rb_io_check_readable(fptr);

    if (rb_io_read_pending(fptr)) return Qtrue;

    rb_check_arity(argc, 0, 1);
    VALUE timeout = argc == 1 ? argv[0] : Qnil;

    return io_wait_event(io, RUBY_IO_PRIORITY, timeout);
}</pre> </div> <p>Waits until <a href="io"><code>IO</code></a> is priority and returns <code>true</code> or <code>false</code> when times out.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-wait_readable"> <span class="method-callseq"> wait_readable → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> wait_readable(timeout) → true or false </span> </div> <div class="method-description">
<div class="method-source-code" id="wait_readable-source"> <pre class="c" data-language="c">static VALUE
io_wait_readable(int argc, VALUE *argv, VALUE io)
{
    rb_io_t *fptr = NULL;

    RB_IO_POINTER(io, fptr);
    rb_io_check_readable(fptr);

    if (rb_io_read_pending(fptr)) return Qtrue;

    rb_check_arity(argc, 0, 1);
    VALUE timeout = (argc == 1 ? argv[0] : Qnil);

    return io_wait_event(io, RUBY_IO_READABLE, timeout);
}</pre> </div> <p>Waits until <a href="io"><code>IO</code></a> is readable and returns <code>true</code>, or <code>false</code> when times out. Returns <code>true</code> immediately when buffered data is available.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-wait_writable"> <span class="method-callseq"> wait_writable → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> wait_writable(timeout) → true or false </span> </div> <div class="method-description">
<div class="method-source-code" id="wait_writable-source"> <pre class="c" data-language="c">static VALUE
io_wait_writable(int argc, VALUE *argv, VALUE io)
{
    rb_io_t *fptr = NULL;

    RB_IO_POINTER(io, fptr);
    rb_io_check_writable(fptr);

    rb_check_arity(argc, 0, 1);
    VALUE timeout = (argc == 1 ? argv[0] : Qnil);

    return io_wait_event(io, RUBY_IO_WRITABLE, timeout);
}</pre> </div> <p>Waits until <a href="io"><code>IO</code></a> is writable and returns <code>true</code> or <code>false</code> when times out.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-winsize"> <span class="method-callseq"> winsize → [rows, columns] </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="winsize-source"> <pre class="c" data-language="c">static VALUE
console_winsize(VALUE io)
{
    rb_io_t *fptr;
    int fd;
    rb_console_size_t ws;

    GetOpenFile(io, fptr);
    fd = GetWriteFD(fptr);
    if (!getwinsize(fd, &amp;ws)) sys_fail_fptr(fptr);
    return rb_assoc_new(INT2NUM(winsize_row(&amp;ws)), INT2NUM(winsize_col(&amp;ws)));
}</pre> </div> <p>Returns console size.</p> <p>You must require 'io/console' to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-winsize-3D"> <span class="method-callseq"> winsize = [rows, columns] </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="winsize-3D-source"> <pre class="c" data-language="c">static VALUE
console_set_winsize(VALUE io, VALUE size)
{
    rb_io_t *fptr;
    rb_console_size_t ws;
#if defined _WIN32
    HANDLE wh;
    int newrow, newcol;
    BOOL ret;
#endif
    VALUE row, col, xpixel, ypixel;
    const VALUE *sz;
    int fd;
    long sizelen;

    GetOpenFile(io, fptr);
    size = rb_Array(size);
    if ((sizelen = RARRAY_LEN(size)) != 2 &amp;&amp; sizelen != 4) {
        rb_raise(rb_eArgError,
                 "wrong number of arguments (given %ld, expected 2 or 4)",
                 sizelen);
    }
    sz = RARRAY_CONST_PTR(size);
    row = sz[0], col = sz[1], xpixel = ypixel = Qnil;
    if (sizelen == 4) xpixel = sz[2], ypixel = sz[3];
    fd = GetWriteFD(fptr);
#if defined TIOCSWINSZ
    ws.ws_row = ws.ws_col = ws.ws_xpixel = ws.ws_ypixel = 0;
#define SET(m) ws.ws_##m = NIL_P(m) ? 0 : (unsigned short)NUM2UINT(m)
    SET(row);
    SET(col);
    SET(xpixel);
    SET(ypixel);
#undef SET
    if (!setwinsize(fd, &amp;ws)) sys_fail_fptr(fptr);
#elif defined _WIN32
    wh = (HANDLE)rb_w32_get_osfhandle(fd);
#define SET(m) new##m = NIL_P(m) ? 0 : (unsigned short)NUM2UINT(m)
    SET(row);
    SET(col);
#undef SET
    if (!NIL_P(xpixel)) (void)NUM2UINT(xpixel);
    if (!NIL_P(ypixel)) (void)NUM2UINT(ypixel);
    if (!GetConsoleScreenBufferInfo(wh, &amp;ws)) {
        rb_syserr_fail(LAST_ERROR, "GetConsoleScreenBufferInfo");
    }
    ws.dwSize.X = newcol;
    ret = SetConsoleScreenBufferSize(wh, ws.dwSize);
    ws.srWindow.Left = 0;
    ws.srWindow.Top = 0;
    ws.srWindow.Right = newcol-1;
    ws.srWindow.Bottom = newrow-1;
    if (!SetConsoleWindowInfo(wh, TRUE, &amp;ws.srWindow)) {
        rb_syserr_fail(LAST_ERROR, "SetConsoleWindowInfo");
    }
    /* retry when shrinking buffer after shrunk window */
    if (!ret &amp;&amp; !SetConsoleScreenBufferSize(wh, ws.dwSize)) {
        rb_syserr_fail(LAST_ERROR, "SetConsoleScreenBufferInfo");
    }
    /* remove scrollbar if possible */
    if (!SetConsoleWindowInfo(wh, TRUE, &amp;ws.srWindow)) {
        rb_syserr_fail(LAST_ERROR, "SetConsoleWindowInfo");
    }
#endif
    return io;
}</pre> </div> <p>Tries to set console size. The effect depends on the platform and the running environment.</p> <p>You must require 'io/console' to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-write"> <span class="method-callseq"> write(string, ...) → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="write-source"> <pre class="c" data-language="c">static VALUE
io_write_m(int argc, VALUE *argv, VALUE io)
{
    if (argc != 1) {
        return io_writev(argc, argv, io);
    }
    else {
        VALUE str = argv[0];
        return io_write(io, str, 0);
    }
}</pre> </div> <p>Writes the given strings to <em>ios</em>. The stream must be opened for writing. Arguments that are not a string will be converted to a string using <code>to_s</code>. Returns the number of bytes written in total.</p> <pre class="ruby" data-language="ruby">count = $stdout.write("This is", " a test\n")
puts "That was #{count} bytes of data"
</pre> <p><em>produces:</em></p> <pre>This is a test
That was 15 bytes of data</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-write_nonblock"> <span class="method-callseq"> write_nonblock(string) → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> write_nonblock(string [, options]) → integer </span> </div> <div class="method-description">
<div class="method-source-code" id="write_nonblock-source"> <pre class="ruby" data-language="ruby"># File io.rb, line 120
def write_nonblock(buf, exception: true)
  Primitive.io_write_nonblock(buf, exception)
end</pre> </div> <p>Writes the given string to <em>ios</em> using the write(2) system call after O_NONBLOCK is set for the underlying file descriptor.</p> <p>It returns the number of bytes written.</p> <p><a href="io#method-i-write_nonblock"><code>write_nonblock</code></a> just calls the write(2) system call. It causes all errors the write(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. The result may also be smaller than string.length (partial write). The caller should care such errors and partial write.</p> <p>If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by <a href="io/waitwritable"><code>IO::WaitWritable</code></a>. So <a href="io/waitwritable"><code>IO::WaitWritable</code></a> can be used to rescue the exceptions for retrying write_nonblock.</p> <pre class="ruby" data-language="ruby"># Creates a pipe.
r, w = IO.pipe

# write_nonblock writes only 65536 bytes and return 65536.
# (The pipe size is 65536 bytes on this environment.)
s = "a" * 100000
p w.write_nonblock(s)     #=&gt; 65536

# write_nonblock cannot write a byte and raise EWOULDBLOCK (EAGAIN).
p w.write_nonblock("b")   # Resource temporarily unavailable (Errno::EAGAIN)
</pre> <p>If the write buffer is not empty, it is flushed at first.</p> <p>When <a href="io#method-i-write_nonblock"><code>write_nonblock</code></a> raises an exception kind of <a href="io/waitwritable"><code>IO::WaitWritable</code></a>, <a href="io#method-i-write_nonblock"><code>write_nonblock</code></a> should not be called until io is writable for avoiding busy loop. This can be done as follows.</p> <pre class="ruby" data-language="ruby">begin
  result = io.write_nonblock(string)
rescue IO::WaitWritable, Errno::EINTR
  IO.select(nil, [io])
  retry
end
</pre> <p>Note that this doesn't guarantee to write all data in string. The length written is reported as result and it should be checked later.</p> <p>On some platforms such as Windows, <a href="io#method-i-write_nonblock"><code>write_nonblock</code></a> is not supported according to the kind of the <a href="io"><code>IO</code></a> object. In such cases, <a href="io#method-i-write_nonblock"><code>write_nonblock</code></a> raises <code>Errno::EBADF</code>.</p> <p>By specifying a keyword argument <em>exception</em> to <code>false</code>, you can indicate that <a href="io#method-i-write_nonblock"><code>write_nonblock</code></a> should not raise an <a href="io/waitwritable"><code>IO::WaitWritable</code></a> exception, but return the symbol <code>:wait_writable</code> instead.</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2020 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
