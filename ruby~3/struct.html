<h1 id="class-Struct" class="class"> class Struct </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="enumerable">Enumerable</a></dd>
</dl> <section class="description"> <p>A <a href="struct"><code>Struct</code></a> is a convenient way to bundle a number of attributes together, using accessor methods, without having to write an explicit class.</p> <p>The <a href="struct"><code>Struct</code></a> class generates new subclasses that hold a set of members and their values. For each member a reader and writer method is created similar to <a href="module#method-i-attr_accessor"><code>Module#attr_accessor</code></a>.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address) do
  def greeting
    "Hello #{name}!"
  end
end

dave = Customer.new("Dave", "123 Main")
dave.name     #=&gt; "Dave"
dave.greeting #=&gt; "Hello Dave!"
</pre> <p>See <a href="struct#method-c-new"><code>Struct::new</code></a> for further examples of creating struct subclasses and instances.</p> <p>In the method descriptions that follow, a “member” parameter refers to a struct member which is either a quoted string (<code>"name"</code>) or a <a href="symbol"><code>Symbol</code></a> (<code>:name</code>).</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="Group">Group </dt>
<dd>
<p><a href="struct#Group"><code>Group</code></a></p> <p><a href="struct#Group"><code>Group</code></a> is a <a href="struct"><code>Struct</code></a> that is only available when compiled with <code>HAVE_GETGRENT</code>.</p> <p>The struct contains the following members:</p> <dl class="rdoc-list note-list">
<dt>name </dt>
<dd> <p>contains the name of the group as a <a href="string"><code>String</code></a>.</p> </dd>
<dt>passwd </dt>
<dd> <p>contains the encrypted password as a <a href="string"><code>String</code></a>. An 'x' is returned if password access to the group is not available; an empty string is returned if no password is needed to obtain membership of the group.</p> <p>Must be compiled with <code>HAVE_STRUCT_GROUP_GR_PASSWD</code>.</p> </dd>
<dt>gid </dt>
<dd> <p>contains the group's numeric ID as an integer.</p> </dd>
<dt>mem </dt>
<dd> <p>is an <a href="array"><code>Array</code></a> of Strings containing the short login names of the members of the group.</p> </dd>
</dl> </dd>
<dt id="Passwd">Passwd </dt>
<dd>
<p><a href="struct#Passwd"><code>Passwd</code></a></p> <p><a href="struct#Passwd"><code>Passwd</code></a> is a <a href="struct"><code>Struct</code></a> that contains the following members:</p> <dl class="rdoc-list note-list">
<dt>name </dt>
<dd> <p>contains the short login name of the user as a <a href="string"><code>String</code></a>.</p> </dd>
<dt>passwd </dt>
<dd> <p>contains the encrypted password of the user as a <a href="string"><code>String</code></a>. an 'x' is returned if shadow passwords are in use. An '*' is returned if the user cannot log in using a password.</p> </dd>
<dt>uid </dt>
<dd> <p>contains the integer user ID (uid) of the user.</p> </dd>
<dt>gid </dt>
<dd> <p>contains the integer group ID (gid) of the user's primary group.</p> </dd>
<dt>dir </dt>
<dd> <p>contains the path to the home directory of the user as a <a href="string"><code>String</code></a>.</p> </dd>
<dt>shell </dt>
<dd> <p>contains the path to the login shell of the user as a <a href="string"><code>String</code></a>.</p> </dd>
</dl> <h3 id="label-The+following+members+below+are+optional-2C+and+must+be+compiled+with+special+flags-3A">The following members below are optional, and must be compiled with special flags:</h3> <dl class="rdoc-list note-list">
<dt>gecos </dt>
<dd> <p>contains a longer <a href="string"><code>String</code></a> description of the user, such as a full name. Some Unix systems provide structured information in the gecos field, but this is system-dependent. must be compiled with <code>HAVE_STRUCT_PASSWD_PW_GECOS</code></p> </dd>
<dt>change </dt>
<dd> <p>password change time(integer) must be compiled with <code>HAVE_STRUCT_PASSWD_PW_CHANGE</code></p> </dd>
<dt>quota </dt>
<dd> <p>quota value(integer) must be compiled with <code>HAVE_STRUCT_PASSWD_PW_QUOTA</code></p> </dd>
<dt>age </dt>
<dd> <p>password age(integer) must be compiled with <code>HAVE_STRUCT_PASSWD_PW_AGE</code></p> </dd>
<dt>class </dt>
<dd> <p>user access class(string) must be compiled with <code>HAVE_STRUCT_PASSWD_PW_CLASS</code></p> </dd>
<dt>comment </dt>
<dd> <p>comment(string) must be compiled with <code>HAVE_STRUCT_PASSWD_PW_COMMENT</code></p> </dd>
<dt>expire </dt>
<dd> <p>account expiration time(integer) must be compiled with <code>HAVE_STRUCT_PASSWD_PW_EXPIRE</code></p> </dd>
</dl> </dd>
</dl> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-json_create"> <span class="method-name">json_create</span><span class="method-args">(object)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="json_create-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/struct.rb, line 10
def self.json_create(object)
  new(*object['v'])
end</pre> </div> <p>Deserializes <a href="json"><code>JSON</code></a> string by constructing new <a href="struct"><code>Struct</code></a> object with values <code>v</code> serialized by <code>to_json</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new([class_name] [, member_name]+) → StructClass </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> new([class_name] [, member_name]+, keyword_init: true) → StructClass </span> </div> <div class="method-heading"> <span class="method-callseq"> new([class_name] [, member_name]+) {|StructClass| block } → StructClass </span> </div> <div class="method-heading"> <span class="method-callseq"> new(value, ...) → object </span> </div> <div class="method-heading"> <span class="method-callseq"> StructClass[value, ...] → object </span> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
rb_struct_s_def(int argc, VALUE *argv, VALUE klass)
{
    VALUE name, rest, keyword_init = Qfalse;
    long i;
    VALUE st;
    st_table *tbl;

    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    name = argv[0];
    if (SYMBOL_P(name)) {
        name = Qnil;
    }
    else {
        --argc;
        ++argv;
    }

    if (RB_TYPE_P(argv[argc-1], T_HASH)) {
        static ID keyword_ids[1];

        if (!keyword_ids[0]) {
            keyword_ids[0] = rb_intern("keyword_init");
        }
        rb_get_kwargs(argv[argc-1], keyword_ids, 0, 1, &amp;keyword_init);
        if (keyword_init == Qundef) {
            keyword_init = Qfalse;
        }
        --argc;
    }

    rest = rb_ident_hash_new();
    RBASIC_CLEAR_CLASS(rest);
    OBJ_WB_UNPROTECT(rest);
    tbl = RHASH_TBL_RAW(rest);
    for (i=0; i&lt;argc; i++) {
        VALUE mem = rb_to_symbol(argv[i]);
        if (rb_is_attrset_sym(mem)) {
            rb_raise(rb_eArgError, "invalid struct member: %"PRIsVALUE, mem);
        }
        if (st_insert(tbl, mem, Qtrue)) {
            rb_raise(rb_eArgError, "duplicate member: %"PRIsVALUE, mem);
        }
    }
    rest = rb_hash_keys(rest);
    st_clear(tbl);
    RBASIC_CLEAR_CLASS(rest);
    OBJ_FREEZE_RAW(rest);
    if (NIL_P(name)) {
        st = anonymous_struct(klass);
    }
    else {
        st = new_struct(name, klass);
    }
    setup_struct(st, rest);
    rb_ivar_set(st, id_keyword_init, keyword_init);
    if (rb_block_given_p()) {
        rb_mod_module_eval(0, 0, st);
    }

    return st;
}</pre> </div> <p>The first two forms are used to create a new <a href="struct"><code>Struct</code></a> subclass <code>class_name</code> that can contain a value for each <code>member_name</code>. This subclass can be used to create instances of the structure like any other <a href="class"><code>Class</code></a>.</p> <p>If the <code>class_name</code> is omitted an anonymous structure class will be created. Otherwise, the name of this struct will appear as a constant in class <a href="struct"><code>Struct</code></a>, so it must be unique for all Structs in the system and must start with a capital letter. Assigning a structure class to a constant also gives the class the name of the constant.</p> <pre class="ruby" data-language="ruby"># Create a structure with a name under Struct
Struct.new("Customer", :name, :address)
#=&gt; Struct::Customer
Struct::Customer.new("Dave", "123 Main")
#=&gt; #&lt;struct Struct::Customer name="Dave", address="123 Main"&gt;

# Create a structure named by its constant
Customer = Struct.new(:name, :address)
#=&gt; Customer
Customer.new("Dave", "123 Main")
#=&gt; #&lt;struct Customer name="Dave", address="123 Main"&gt;
</pre> <p>If the optional <code>keyword_init</code> keyword argument is set to <code>true</code>, .new takes keyword arguments instead of normal arguments.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, keyword_init: true)
Customer.new(name: "Dave", address: "123 Main")
#=&gt; #&lt;struct Customer name="Dave", address="123 Main"&gt;
</pre> <p>If a block is given it will be evaluated in the context of <code>StructClass</code>, passing the created class as a parameter:</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address) do
  def greeting
    "Hello #{name}!"
  end
end
Customer.new("Dave", "123 Main").greeting  #=&gt; "Hello Dave!"
</pre> <p>This is the recommended way to customize a struct. Subclassing an anonymous struct creates an extra anonymous class that will never be used.</p> <p>The last two forms create a new instance of a struct subclass. The number of <code>value</code> parameters must be less than or equal to the number of attributes defined for the structure. Unset parameters default to <code>nil</code>. Passing more parameters than number of attributes will raise an <a href="argumenterror"><code>ArgumentError</code></a>.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address)
Customer.new("Dave", "123 Main")
#=&gt; #&lt;struct Customer name="Dave", address="123 Main"&gt;
Customer["Dave"]
#=&gt; #&lt;struct Customer name="Dave", address=nil&gt;
</pre>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-3D-3D"> <span class="method-callseq"> struct == other → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="c" data-language="c">static VALUE
rb_struct_equal(VALUE s, VALUE s2)
{
    if (s == s2) return Qtrue;
    if (!RB_TYPE_P(s2, T_STRUCT)) return Qfalse;
    if (rb_obj_class(s) != rb_obj_class(s2)) return Qfalse;
    if (RSTRUCT_LEN(s) != RSTRUCT_LEN(s2)) {
        rb_bug("inconsistent struct"); /* should never happen */
    }

    return rb_exec_recursive_paired(recursive_equal, s, s2, s2);
}</pre> </div> <p>Equality—Returns <code>true</code> if <code>other</code> has the same struct subclass and has equal member values (according to Object#==).</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe   = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joejr = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
jane  = Customer.new("Jane Doe", "456 Elm, Anytown NC", 12345)
joe == joejr   #=&gt; true
joe == jane    #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-5B-5D"> <span class="method-callseq"> struct[member] → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> struct[index] → object </span> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="c" data-language="c">VALUE
rb_struct_aref(VALUE s, VALUE idx)
{
    int i = rb_struct_pos(s, &amp;idx);
    if (i &lt; 0) invalid_struct_pos(s, idx);
    return RSTRUCT_GET(s, i);
}</pre> </div> <p>Attribute Reference—Returns the value of the given struct <code>member</code> or the member at the given <code>index</code>. Raises <a href="nameerror"><code>NameError</code></a> if the <code>member</code> does not exist and <a href="indexerror"><code>IndexError</code></a> if the <code>index</code> is out of range.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)

joe["name"]   #=&gt; "Joe Smith"
joe[:name]    #=&gt; "Joe Smith"
joe[0]        #=&gt; "Joe Smith"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-5B-5D-3D"> <span class="method-callseq"> struct[member] = obj → obj </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> struct[index] = obj → obj </span> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-3D-source"> <pre class="c" data-language="c">VALUE
rb_struct_aset(VALUE s, VALUE idx, VALUE val)
{
    int i = rb_struct_pos(s, &amp;idx);
    if (i &lt; 0) invalid_struct_pos(s, idx);
    rb_struct_modify(s);
    RSTRUCT_SET(s, i, val);
    return val;
}</pre> </div> <p>Attribute Assignment—Sets the value of the given struct <code>member</code> or the member at the given <code>index</code>. Raises <a href="nameerror"><code>NameError</code></a> if the <code>member</code> does not exist and <a href="indexerror"><code>IndexError</code></a> if the <code>index</code> is out of range.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)

joe["name"] = "Luke"
joe[:zip]   = "90210"

joe.name   #=&gt; "Luke"
joe.zip    #=&gt; "90210"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-as_json"> <span class="method-name">as_json</span><span class="method-args">(*)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="as_json-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/struct.rb, line 16
def as_json(*)
  klass = self.class.name
  klass.to_s.empty? and raise JSON::JSONError, "Only named structs are supported!"
  {
    JSON.create_id =&gt; klass,
    'v'            =&gt; values,
  }
end</pre> </div> <p>Returns a hash, that will be turned into a <a href="json"><code>JSON</code></a> object and represent this object.</p>  </div> </div> <div id="method-i-deconstruct" class="method-detail method-alias"> <div class="method-description"> <p>Returns the values for this struct as an <a href="array"><code>Array</code></a>.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.to_a[1]   #=&gt; "123 Maple, Anytown NC"
</pre> </div> <div class="aliases"> Alias for: <a href="struct#method-i-to_a">to_a</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-deconstruct_keys"> <span class="method-name">deconstruct_keys</span><span class="method-args">(p1)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="deconstruct_keys-source"> <pre class="c" data-language="c">static VALUE
rb_struct_deconstruct_keys(VALUE s, VALUE keys)
{
    VALUE h;
    long i;

    if (NIL_P(keys)) {
        return rb_struct_to_h(s);
    }
    if (UNLIKELY(!RB_TYPE_P(keys, T_ARRAY))) {
        rb_raise(rb_eTypeError,
                 "wrong argument type %"PRIsVALUE" (expected Array or nil)",
                 rb_obj_class(keys));

    }
    if (RSTRUCT_LEN(s) &lt; RARRAY_LEN(keys)) {
        return rb_hash_new_with_size(0);
    }
    h = rb_hash_new_with_size(RARRAY_LEN(keys));
    for (i=0; i&lt;RARRAY_LEN(keys); i++) {
        VALUE key = RARRAY_AREF(keys, i);
        int i = rb_struct_pos(s, &amp;key);
        if (i &lt; 0) {
            return h;
        }
        rb_hash_aset(h, key, RSTRUCT_GET(s, i));
    }
    return h;
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-dig"> <span class="method-callseq"> dig(key, *identifiers) → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="dig-source"> <pre class="c" data-language="c">static VALUE
rb_struct_dig(int argc, VALUE *argv, VALUE self)
{
    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    self = rb_struct_lookup(self, *argv);
    if (!--argc) return self;
    ++argv;
    return rb_obj_dig(argc, argv, self, Qnil);
}</pre> </div> <p>Finds and returns the object in nested objects that is specified by <code>key</code> and <code>identifiers</code>. The nested objects may be instances of various classes. See Dig Methods.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby">Foo = Struct.new(:a)
f = Foo.new(Foo.new({b: [1, 2, 3]}))
f.dig(:a) # =&gt; #&lt;struct Foo a={:b=&gt;[1, 2, 3]}&gt;
f.dig(:a, :a) # =&gt; {:b=&gt;[1, 2, 3]}
f.dig(:a, :a, :b) # =&gt; [1, 2, 3]
f.dig(:a, :a, :b, 0) # =&gt; 1
f.dig(:b, 0) # =&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each"> <span class="method-callseq"> each {|obj| block } → struct </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each → enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each-source"> <pre class="c" data-language="c">static VALUE
rb_struct_each(VALUE s)
{
    long i;

    RETURN_SIZED_ENUMERATOR(s, 0, 0, struct_enum_size);
    for (i=0; i&lt;RSTRUCT_LEN(s); i++) {
        rb_yield(RSTRUCT_GET(s, i));
    }
    return s;
}</pre> </div> <p>Yields the value of each struct member in order. If no block is given an enumerator is returned.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.each {|x| puts(x) }
</pre> <p>Produces:</p> <pre>Joe Smith
123 Maple, Anytown NC
12345</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_pair"> <span class="method-callseq"> each_pair {|sym, obj| block } → struct </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_pair → enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_pair-source"> <pre class="c" data-language="c">static VALUE
rb_struct_each_pair(VALUE s)
{
    VALUE members;
    long i;

    RETURN_SIZED_ENUMERATOR(s, 0, 0, struct_enum_size);
    members = rb_struct_members(s);
    if (rb_block_pair_yield_optimizable()) {
        for (i=0; i&lt;RSTRUCT_LEN(s); i++) {
            VALUE key = rb_ary_entry(members, i);
            VALUE value = RSTRUCT_GET(s, i);
            rb_yield_values(2, key, value);
        }
    }
    else {
        for (i=0; i&lt;RSTRUCT_LEN(s); i++) {
            VALUE key = rb_ary_entry(members, i);
            VALUE value = RSTRUCT_GET(s, i);
            rb_yield(rb_assoc_new(key, value));
        }
    }
    return s;
}</pre> </div> <p>Yields the name and value of each struct member in order. If no block is given an enumerator is returned.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.each_pair {|name, value| puts("#{name} =&gt; #{value}") }
</pre> <p>Produces:</p> <pre>name =&gt; Joe Smith
address =&gt; 123 Maple, Anytown NC
zip =&gt; 12345</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-eql-3F"> <span class="method-callseq"> eql?(other) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="eql-3F-source"> <pre class="c" data-language="c">static VALUE
rb_struct_eql(VALUE s, VALUE s2)
{
    if (s == s2) return Qtrue;
    if (!RB_TYPE_P(s2, T_STRUCT)) return Qfalse;
    if (rb_obj_class(s) != rb_obj_class(s2)) return Qfalse;
    if (RSTRUCT_LEN(s) != RSTRUCT_LEN(s2)) {
        rb_bug("inconsistent struct"); /* should never happen */
    }

    return rb_exec_recursive_paired(recursive_eql, s, s2, s2);
}</pre> </div> <p><a href="hash"><code>Hash</code></a> equality—<code>other</code> and <code>struct</code> refer to the same hash key if they have the same struct subclass and have equal member values (according to <a href="object#method-i-eql-3F"><code>Object#eql?</code></a>).</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-filter"> <span class="method-callseq"> filter {|obj| block } → array </span> </div> <div class="method-heading"> <span class="method-callseq"> filter → enumerator </span> </div> <div class="method-description"> <p>Yields each member value from the struct to the block and returns an <a href="array"><code>Array</code></a> containing the member values from the <code>struct</code> for which the given block returns a true value (equivalent to <a href="enumerable#method-i-select"><code>Enumerable#select</code></a>).</p> <pre class="ruby" data-language="ruby">Lots = Struct.new(:a, :b, :c, :d, :e, :f)
l = Lots.new(11, 22, 33, 44, 55, 66)
l.select {|v| v.even? }   #=&gt; [22, 44, 66]
</pre> <p><a href="struct#method-i-filter"><code>Struct#filter</code></a> is an alias for <a href="struct#method-i-select"><code>Struct#select</code></a>.</p> </div> <div class="aliases"> Alias for: <a href="struct#method-i-select">select</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-hash"> <span class="method-callseq"> hash → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="hash-source"> <pre class="c" data-language="c">static VALUE
rb_struct_hash(VALUE s)
{
    long i, len;
    st_index_t h;
    VALUE n;

    h = rb_hash_start(rb_hash(rb_obj_class(s)));
    len = RSTRUCT_LEN(s);
    for (i = 0; i &lt; len; i++) {
        n = rb_hash(RSTRUCT_GET(s, i));
        h = rb_hash_uint(h, NUM2LONG(n));
    }
    h = rb_hash_end(h);
    return ST2FIX(h);
}</pre> </div> <p>Returns a hash value based on this struct's contents.</p> <p>See also <a href="object#method-i-hash"><code>Object#hash</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inspect"> <span class="method-callseq"> inspect → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="c" data-language="c">static VALUE
rb_struct_inspect(VALUE s)
{
    return rb_exec_recursive(inspect_struct, s, 0);
}</pre> </div> <p>Returns a description of this struct as a string.</p>  </div> <div class="aliases"> Also aliased as: <a href="struct#method-i-to_s">to_s</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-length"> <span class="method-callseq"> length → integer </span> </div> <div class="method-description"> <p>Returns the number of struct members.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.length   #=&gt; 3
</pre> </div> <div class="aliases"> Alias for: <a href="struct#method-i-size">size</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-members"> <span class="method-callseq"> members → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="members-source"> <pre class="c" data-language="c">static VALUE
rb_struct_members_m(VALUE obj)
{
    return rb_struct_s_members_m(rb_obj_class(obj));
}</pre> </div> <p>Returns the struct members as an array of symbols:</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.members   #=&gt; [:name, :address, :zip]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-select"> <span class="method-callseq"> select {|obj| block } → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> select → enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="select-source"> <pre class="c" data-language="c">static VALUE
rb_struct_select(int argc, VALUE *argv, VALUE s)
{
    VALUE result;
    long i;

    rb_check_arity(argc, 0, 0);
    RETURN_SIZED_ENUMERATOR(s, 0, 0, struct_enum_size);
    result = rb_ary_new();
    for (i = 0; i &lt; RSTRUCT_LEN(s); i++) {
        if (RTEST(rb_yield(RSTRUCT_GET(s, i)))) {
            rb_ary_push(result, RSTRUCT_GET(s, i));
        }
    }

    return result;
}</pre> </div> <p>Yields each member value from the struct to the block and returns an <a href="array"><code>Array</code></a> containing the member values from the <code>struct</code> for which the given block returns a true value (equivalent to <a href="enumerable#method-i-select"><code>Enumerable#select</code></a>).</p> <pre class="ruby" data-language="ruby">Lots = Struct.new(:a, :b, :c, :d, :e, :f)
l = Lots.new(11, 22, 33, 44, 55, 66)
l.select {|v| v.even? }   #=&gt; [22, 44, 66]
</pre> <p><a href="struct#method-i-filter"><code>Struct#filter</code></a> is an alias for <a href="struct#method-i-select"><code>Struct#select</code></a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="struct#method-i-filter">filter</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-size"> <span class="method-callseq"> size → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="size-source"> <pre class="c" data-language="c">VALUE
rb_struct_size(VALUE s)
{
    return LONG2FIX(RSTRUCT_LEN(s));
}</pre> </div> <p>Returns the number of struct members.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.length   #=&gt; 3
</pre>  </div> <div class="aliases"> Also aliased as: <a href="struct#method-i-length">length</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_a"> <span class="method-callseq"> to_a → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_a-source"> <pre class="c" data-language="c">static VALUE
rb_struct_to_a(VALUE s)
{
    return rb_ary_new4(RSTRUCT_LEN(s), RSTRUCT_CONST_PTR(s));
}</pre> </div> <p>Returns the values for this struct as an <a href="array"><code>Array</code></a>.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.to_a[1]   #=&gt; "123 Maple, Anytown NC"
</pre>  </div> <div class="aliases"> Also aliased as: <a href="struct#method-i-values">values</a>, <a href="struct#method-i-deconstruct">deconstruct</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_h"> <span class="method-callseq"> to_h → hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> to_h {|name, value| block } → hash </span> </div> <div class="method-description">
<div class="method-source-code" id="to_h-source"> <pre class="c" data-language="c">static VALUE
rb_struct_to_h(VALUE s)
{
    VALUE h = rb_hash_new_with_size(RSTRUCT_LEN(s));
    VALUE members = rb_struct_members(s);
    long i;
    int block_given = rb_block_given_p();

    for (i=0; i&lt;RSTRUCT_LEN(s); i++) {
        VALUE k = rb_ary_entry(members, i), v = RSTRUCT_GET(s, i);
        if (block_given)
            rb_hash_set_pair(h, rb_yield_values(2, k, v));
        else
            rb_hash_aset(h, k, v);
    }
    return h;
}</pre> </div> <p>Returns a <a href="hash"><code>Hash</code></a> containing the names and values for the struct's members.</p> <p>If a block is given, the results of the block on each pair of the receiver will be used as pairs.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.to_h[:address]   #=&gt; "123 Maple, Anytown NC"
joe.to_h{|name, value| [name.upcase, value.to_s.upcase]}[:ADDRESS]
                     #=&gt; "123 MAPLE, ANYTOWN NC"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_json"> <span class="method-name">to_json</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_json-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/struct.rb, line 27
def to_json(*args)
  as_json.to_json(*args)
end</pre> </div> <p>Stores class name (<a href="struct"><code>Struct</code></a>) with <a href="struct"><code>Struct</code></a> values <code>v</code> as a <a href="json"><code>JSON</code></a> string. Only named structs are supported.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-to_s"> <span class="method-callseq"> to_s → string </span> </div> <div class="method-description"> <p>Returns a description of this struct as a string.</p> </div> <div class="aliases"> Alias for: <a href="struct#method-i-inspect">inspect</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-values"> <span class="method-callseq"> values → array </span> </div> <div class="method-description"> <p>Returns the values for this struct as an <a href="array"><code>Array</code></a>.</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.to_a[1]   #=&gt; "123 Maple, Anytown NC"
</pre> </div> <div class="aliases"> Alias for: <a href="struct#method-i-to_a">to_a</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-values_at"> <span class="method-callseq"> values_at(selector, ...) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="values_at-source"> <pre class="c" data-language="c">static VALUE
rb_struct_values_at(int argc, VALUE *argv, VALUE s)
{
    return rb_get_values_at(s, RSTRUCT_LEN(s), argc, argv, struct_entry);
}</pre> </div> <p>Returns the struct member values for each <code>selector</code> as an <a href="array"><code>Array</code></a>. A <code>selector</code> may be either an <a href="integer"><code>Integer</code></a> offset or a <a href="range"><code>Range</code></a> of offsets (as in <a href="array#method-i-values_at"><code>Array#values_at</code></a>).</p> <pre class="ruby" data-language="ruby">Customer = Struct.new(:name, :address, :zip)
joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
joe.values_at(0, 2)   #=&gt; ["Joe Smith", 12345]
</pre>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2020 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
