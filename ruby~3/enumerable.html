<h1 id="module-Enumerable" class="module"> module Enumerable </h1> <section class="description"> <p>The <a href="enumerable"><code>Enumerable</code></a> mixin provides collection classes with several traversal and searching methods, and with the ability to sort. The class must provide a method each, which yields successive members of the collection. If <a href="enumerable#method-i-max"><code>Enumerable#max</code></a>, <a href="enumerable#method-i-min"><code>min</code></a>, or <a href="enumerable#method-i-sort"><code>sort</code></a> is used, the objects in the collection must also implement a meaningful <code>&lt;=&gt;</code> operator, as these methods rely on an ordering between members of the collection.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-all-3F"> <span class="method-callseq"> all? [{ |obj| block } ] → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> all?(pattern) → true or false </span> </div> <div class="method-description">
<div class="method-source-code" id="all-3F-source"> <pre class="c" data-language="c">static VALUE
enum_all(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo = MEMO_ENUM_NEW(Qtrue);
    WARN_UNUSED_BLOCK(argc);
    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(all), (VALUE)memo);
    return memo-&gt;v1;
}</pre> </div> <p>Passes each element of the collection to the given block. The method returns <code>true</code> if the block never returns <code>false</code> or <code>nil</code>. If the block is not given, Ruby adds an implicit block of <code>{ |obj| obj }</code> which will cause <a href="enumerable#method-i-all-3F"><code>all?</code></a> to return <code>true</code> when none of the collection members are <code>false</code> or <code>nil</code>.</p> <p>If instead a pattern is supplied, the method returns whether <code>pattern === element</code> for every collection member.</p> <pre class="ruby" data-language="ruby">%w[ant bear cat].all? { |word| word.length &gt;= 3 } #=&gt; true
%w[ant bear cat].all? { |word| word.length &gt;= 4 } #=&gt; false
%w[ant bear cat].all?(/t/)                        #=&gt; false
[1, 2i, 3.14].all?(Numeric)                       #=&gt; true
[nil, true, 99].all?                              #=&gt; false
[].all?                                           #=&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-any-3F"> <span class="method-callseq"> any? [{ |obj| block }] → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> any?(pattern) → true or false </span> </div> <div class="method-description">
<div class="method-source-code" id="any-3F-source"> <pre class="c" data-language="c">static VALUE
enum_any(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo = MEMO_ENUM_NEW(Qfalse);
    WARN_UNUSED_BLOCK(argc);
    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(any), (VALUE)memo);
    return memo-&gt;v1;
}</pre> </div> <p>Passes each element of the collection to the given block. The method returns <code>true</code> if the block ever returns a value other than <code>false</code> or <code>nil</code>. If the block is not given, Ruby adds an implicit block of <code>{ |obj| obj }</code> that will cause <a href="enumerable#method-i-any-3F"><code>any?</code></a> to return <code>true</code> if at least one of the collection members is not <code>false</code> or <code>nil</code>.</p> <p>If instead a pattern is supplied, the method returns whether <code>pattern === element</code> for any collection member.</p> <pre class="ruby" data-language="ruby">%w[ant bear cat].any? { |word| word.length &gt;= 3 } #=&gt; true
%w[ant bear cat].any? { |word| word.length &gt;= 4 } #=&gt; true
%w[ant bear cat].any?(/d/)                        #=&gt; false
[nil, true, 99].any?(Integer)                     #=&gt; true
[nil, true, 99].any?                              #=&gt; true
[].any?                                           #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-chain"> <span class="method-callseq"> chain(*enums) → enumerator </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="chain-source"> <pre class="c" data-language="c">static VALUE
enum_chain(int argc, VALUE *argv, VALUE obj)
{
    VALUE enums = rb_ary_new_from_values(1, &amp;obj);
    rb_ary_cat(enums, argv, argc);

    return enum_chain_initialize(enum_chain_allocate(rb_cEnumChain), enums);
}</pre> </div> <p>Returns an enumerator object generated from this enumerator and given enumerables.</p> <pre class="ruby" data-language="ruby">e = (1..3).chain([4, 5])
e.to_a #=&gt; [1, 2, 3, 4, 5]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-chunk"> <span class="method-callseq"> chunk { |elt| ... } → an_enumerator </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="chunk-source"> <pre class="c" data-language="c">static VALUE
enum_chunk(VALUE enumerable)
{
    VALUE enumerator;

    RETURN_SIZED_ENUMERATOR(enumerable, 0, 0, enum_size);

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, rb_intern("chunk_enumerable"), enumerable);
    rb_ivar_set(enumerator, rb_intern("chunk_categorize"), rb_block_proc());
    rb_block_call(enumerator, idInitialize, 0, 0, chunk_i, enumerator);
    return enumerator;
}</pre> </div> <p>Enumerates over the items, chunking them together based on the return value of the block.</p> <p>Consecutive elements which return the same block value are chunked together.</p> <p>For example, consecutive even numbers and odd numbers can be chunked as follows.</p> <pre class="ruby" data-language="ruby">[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5].chunk { |n|
  n.even?
}.each { |even, ary|
  p [even, ary]
}
#=&gt; [false, [3, 1]]
#   [true, [4]]
#   [false, [1, 5, 9]]
#   [true, [2, 6]]
#   [false, [5, 3, 5]]
</pre> <p>This method is especially useful for sorted series of elements. The following example counts words for each initial letter.</p> <pre class="ruby" data-language="ruby">open("/usr/share/dict/words", "r:iso-8859-1") { |f|
  f.chunk { |line| line.upcase.ord }.each { |ch, lines| p [ch.chr, lines.length] }
}
#=&gt; ["\n", 1]
#   ["A", 1327]
#   ["B", 1372]
#   ["C", 1507]
#   ["D", 791]
#   ...
</pre> <p>The following key values have special meaning:</p> <ul>
<li> <p><code>nil</code> and <code>:_separator</code> specifies that the elements should be dropped.</p> </li>
<li> <p><code>:_alone</code> specifies that the element should be chunked by itself.</p> </li>
</ul> <p>Any other symbols that begin with an underscore will raise an error:</p> <pre class="ruby" data-language="ruby">items.chunk { |item| :_underscore }
#=&gt; RuntimeError: symbols beginning with an underscore are reserved
</pre> <p><code>nil</code> and <code>:_separator</code> can be used to ignore some elements.</p> <p>For example, the sequence of hyphens in svn log can be eliminated as follows:</p> <pre class="ruby" data-language="ruby">sep = "-"*72 + "\n"
IO.popen("svn log README") { |f|
  f.chunk { |line|
    line != sep || nil
  }.each { |_, lines|
    pp lines
  }
}
#=&gt; ["r20018 | knu | 2008-10-29 13:20:42 +0900 (Wed, 29 Oct 2008) | 2 lines\n",
#    "\n",
#    "* README, README.ja: Update the portability section.\n",
#    "\n"]
#   ["r16725 | knu | 2008-05-31 23:34:23 +0900 (Sat, 31 May 2008) | 2 lines\n",
#    "\n",
#    "* README, README.ja: Add a note about default C flags.\n",
#    "\n"]
#   ...
</pre> <p>Paragraphs separated by empty lines can be parsed as follows:</p> <pre class="ruby" data-language="ruby">File.foreach("README").chunk { |line|
  /\A\s*\z/ !~ line || nil
}.each { |_, lines|
  pp lines
}
</pre> <p><code>:_alone</code> can be used to force items into their own chunk. For example, you can put lines that contain a URL by themselves, and chunk the rest of the lines together, like this:</p> <pre class="ruby" data-language="ruby">pattern = /http/
open(filename) { |f|
  f.chunk { |line| line =~ pattern ? :_alone : true }.each { |key, lines|
    pp lines
  }
}
</pre> <p>If no block is given, an enumerator to `chunk` is returned instead.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-chunk_while"> <span class="method-callseq"> chunk_while {|elt_before, elt_after| bool } → an_enumerator </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="chunk_while-source"> <pre class="c" data-language="c">static VALUE
enum_chunk_while(VALUE enumerable)
{
    VALUE enumerator;
    VALUE pred;

    pred = rb_block_proc();

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, rb_intern("slicewhen_enum"), enumerable);
    rb_ivar_set(enumerator, rb_intern("slicewhen_pred"), pred);
    rb_ivar_set(enumerator, rb_intern("slicewhen_inverted"), Qtrue);

    rb_block_call(enumerator, idInitialize, 0, 0, slicewhen_i, enumerator);
    return enumerator;
}</pre> </div> <p>Creates an enumerator for each chunked elements. The beginnings of chunks are defined by the block.</p> <p>This method splits each chunk using adjacent elements, <em>elt_before</em> and <em>elt_after</em>, in the receiver enumerator. This method split chunks between <em>elt_before</em> and <em>elt_after</em> where the block returns <code>false</code>.</p> <p>The block is called the length of the receiver enumerator minus one.</p> <p>The result enumerator yields the chunked elements as an array. So <code>each</code> method can be called as follows:</p> <pre>enum.chunk_while { |elt_before, elt_after| bool }.each { |ary| ... }</pre> <p>Other methods of the <a href="enumerator"><code>Enumerator</code></a> class and <a href="enumerable"><code>Enumerable</code></a> module, such as <code>to_a</code>, <code>map</code>, etc., are also usable.</p> <p>For example, one-by-one increasing subsequence can be chunked as follows:</p> <pre class="ruby" data-language="ruby">a = [1,2,4,9,10,11,12,15,16,19,20,21]
b = a.chunk_while {|i, j| i+1 == j }
p b.to_a #=&gt; [[1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21]]
c = b.map {|a| a.length &lt; 3 ? a : "#{a.first}-#{a.last}" }
p c #=&gt; [[1, 2], [4], "9-12", [15, 16], "19-21"]
d = c.join(",")
p d #=&gt; "1,2,4,9-12,15,16,19-21"
</pre> <p>Increasing (non-decreasing) subsequence can be chunked as follows:</p> <pre class="ruby" data-language="ruby">a = [0, 9, 2, 2, 3, 2, 7, 5, 9, 5]
p a.chunk_while {|i, j| i &lt;= j }.to_a
#=&gt; [[0, 9], [2, 2, 3], [2, 7], [5, 9], [5]]
</pre> <p>Adjacent evens and odds can be chunked as follows: (<a href="enumerable#method-i-chunk"><code>Enumerable#chunk</code></a> is another way to do it.)</p> <pre class="ruby" data-language="ruby">a = [7, 5, 9, 2, 0, 7, 9, 4, 2, 0]
p a.chunk_while {|i, j| i.even? == j.even? }.to_a
#=&gt; [[7, 5, 9], [2, 0], [7, 9], [4, 2, 0]]
</pre> <p><a href="enumerable#method-i-slice_when"><code>Enumerable#slice_when</code></a> does the same, except splitting when the block returns <code>true</code> instead of <code>false</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-collect"> <span class="method-callseq"> collect { |obj| block } → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> collect → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="collect-source"> <pre class="c" data-language="c">static VALUE
enum_collect(VALUE obj)
{
    VALUE ary;
    int min_argc, max_argc;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    min_argc = rb_block_min_max_arity(&amp;max_argc);
    rb_lambda_call(obj, id_each, 0, 0, collect_i, min_argc, max_argc, ary);

    return ary;
}</pre> </div> <p>Returns a new array with the results of running <em>block</em> once for every element in <em>enum</em>.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">(1..4).map { |i| i*i }      #=&gt; [1, 4, 9, 16]
(1..4).collect { "cat"  }   #=&gt; ["cat", "cat", "cat", "cat"]
</pre>  </div> <div class="aliases"> Also aliased as: <a href="enumerable#method-i-map">map</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-collect_concat"> <span class="method-callseq"> collect_concat { |obj| block } → array </span> </div> <div class="method-heading"> <span class="method-callseq"> collect_concat → an_enumerator </span> </div> <div class="method-description"> <p>Returns a new array with the concatenated results of running <em>block</em> once for every element in <em>enum</em>.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">[1, 2, 3, 4].flat_map { |e| [e, -e] } #=&gt; [1, -1, 2, -2, 3, -3, 4, -4]
[[1, 2], [3, 4]].flat_map { |e| e + [100] } #=&gt; [1, 2, 100, 3, 4, 100]
</pre> </div> <div class="aliases"> Alias for: <a href="enumerable#method-i-flat_map">flat_map</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-count"> <span class="method-callseq"> count → int </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> count(item) → int </span> </div> <div class="method-heading"> <span class="method-callseq"> count { |obj| block } → int </span> </div> <div class="method-description">
<div class="method-source-code" id="count-source"> <pre class="c" data-language="c">static VALUE
enum_count(int argc, VALUE *argv, VALUE obj)
{
    VALUE item = Qnil;
    struct MEMO *memo;
    rb_block_call_func *func;

    if (argc == 0) {
        if (rb_block_given_p()) {
            func = count_iter_i;
        }
        else {
            func = count_all_i;
        }
    }
    else {
        rb_scan_args(argc, argv, "1", &amp;item);
        if (rb_block_given_p()) {
            rb_warn("given block not used");
        }
        func = count_i;
    }

    memo = MEMO_NEW(item, 0, 0);
    rb_block_call(obj, id_each, 0, 0, func, (VALUE)memo);
    return imemo_count_value(memo);
}</pre> </div> <p>Returns the number of items in <code>enum</code> through enumeration. If an argument is given, the number of items in <code>enum</code> that are equal to <code>item</code> are counted. If a block is given, it counts the number of elements yielding a true value.</p> <pre class="ruby" data-language="ruby">ary = [1, 2, 4, 2]
ary.count               #=&gt; 4
ary.count(2)            #=&gt; 2
ary.count{ |x| x%2==0 } #=&gt; 3
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-cycle"> <span class="method-callseq"> cycle(n=nil) { |obj| block } → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> cycle(n=nil) → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="cycle-source"> <pre class="c" data-language="c">static VALUE
enum_cycle(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary;
    VALUE nv = Qnil;
    long n, i, len;

    rb_check_arity(argc, 0, 1);

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_cycle_size);
    if (!argc || NIL_P(nv = argv[0])) {
        n = -1;
    }
    else {
        n = NUM2LONG(nv);
        if (n &lt;= 0) return Qnil;
    }
    ary = rb_ary_new();
    RBASIC_CLEAR_CLASS(ary);
    rb_block_call(obj, id_each, 0, 0, cycle_i, ary);
    len = RARRAY_LEN(ary);
    if (len == 0) return Qnil;
    while (n &lt; 0 || 0 &lt; --n) {
        for (i=0; i&lt;len; i++) {
            enum_yield_array(RARRAY_AREF(ary, i));
        }
    }
    return Qnil;
}</pre> </div> <p>Calls <em>block</em> for each element of <em>enum</em> repeatedly <em>n</em> times or forever if none or <code>nil</code> is given. If a non-positive number is given or the collection is empty, does nothing. Returns <code>nil</code> if the loop has finished without getting interrupted.</p> <p><a href="enumerable#method-i-cycle"><code>Enumerable#cycle</code></a> saves elements in an internal array so changes to <em>enum</em> after the first pass have no effect.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">a = ["a", "b", "c"]
a.cycle { |x| puts x }  # print, a, b, c, a, b, c,.. forever.
a.cycle(2) { |x| puts x }  # print, a, b, c, a, b, c.
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-detect"> <span class="method-callseq"> detect(ifnone = nil) { |obj| block } → obj or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> detect(ifnone = nil) → an_enumerator </span> </div> <div class="method-description"> <p>Passes each entry in <em>enum</em> to <em>block</em>. Returns the first for which <em>block</em> is not false. If no object matches, calls <em>ifnone</em> and returns its result when it is specified, or returns <code>nil</code> otherwise.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">(1..100).detect  #=&gt; #&lt;Enumerator: 1..100:detect&gt;
(1..100).find    #=&gt; #&lt;Enumerator: 1..100:find&gt;

(1..10).detect         { |i| i % 5 == 0 &amp;&amp; i % 7 == 0 }   #=&gt; nil
(1..10).find           { |i| i % 5 == 0 &amp;&amp; i % 7 == 0 }   #=&gt; nil
(1..10).detect(-&gt; {0}) { |i| i % 5 == 0 &amp;&amp; i % 7 == 0 }   #=&gt; 0
(1..10).find(-&gt; {0})   { |i| i % 5 == 0 &amp;&amp; i % 7 == 0 }   #=&gt; 0
(1..100).detect        { |i| i % 5 == 0 &amp;&amp; i % 7 == 0 }   #=&gt; 35
(1..100).find          { |i| i % 5 == 0 &amp;&amp; i % 7 == 0 }   #=&gt; 35
</pre> </div> <div class="aliases"> Alias for: <a href="enumerable#method-i-find">find</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-drop"> <span class="method-callseq"> drop(n) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="drop-source"> <pre class="c" data-language="c">static VALUE
enum_drop(VALUE obj, VALUE n)
{
    VALUE result;
    struct MEMO *memo;
    long len = NUM2LONG(n);

    if (len &lt; 0) {
        rb_raise(rb_eArgError, "attempt to drop negative size");
    }

    result = rb_ary_new();
    memo = MEMO_NEW(result, 0, len);
    rb_block_call(obj, id_each, 0, 0, drop_i, (VALUE)memo);
    return result;
}</pre> </div> <p>Drops first n elements from <em>enum</em>, and returns rest elements in an array.</p> <pre class="ruby" data-language="ruby">a = [1, 2, 3, 4, 5, 0]
a.drop(3)             #=&gt; [4, 5, 0]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-drop_while"> <span class="method-callseq"> drop_while { |obj| block } → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> drop_while → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="drop_while-source"> <pre class="c" data-language="c">static VALUE
enum_drop_while(VALUE obj)
{
    VALUE result;
    struct MEMO *memo;

    RETURN_ENUMERATOR(obj, 0, 0);
    result = rb_ary_new();
    memo = MEMO_NEW(result, 0, FALSE);
    rb_block_call(obj, id_each, 0, 0, drop_while_i, (VALUE)memo);
    return result;
}</pre> </div> <p>Drops elements up to, but not including, the first element for which the block returns <code>nil</code> or <code>false</code> and returns an array containing the remaining elements.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">a = [1, 2, 3, 4, 5, 0]
a.drop_while { |i| i &lt; 3 }   #=&gt; [3, 4, 5, 0]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_cons"> <span class="method-callseq"> each_cons(n) { ... } → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_cons(n) → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_cons-source"> <pre class="c" data-language="c">static VALUE
enum_each_cons(VALUE obj, VALUE n)
{
    long size = NUM2LONG(n);
    struct MEMO *memo;
    int arity;

    if (size &lt;= 0) rb_raise(rb_eArgError, "invalid size");
    RETURN_SIZED_ENUMERATOR(obj, 1, &amp;n, enum_each_cons_size);
    arity = rb_block_arity();
    if (enum_size_over_p(obj, size)) return Qnil;
    memo = MEMO_NEW(rb_ary_new2(size), dont_recycle_block_arg(arity), size);
    rb_block_call(obj, id_each, 0, 0, each_cons_i, (VALUE)memo);

    return Qnil;
}</pre> </div> <p>Iterates the given block for each array of consecutive &lt;n&gt; elements. If no block is given, returns an enumerator.</p> <p>e.g.:</p> <pre class="ruby" data-language="ruby">(1..10).each_cons(3) { |a| p a }
# outputs below
[1, 2, 3]
[2, 3, 4]
[3, 4, 5]
[4, 5, 6]
[5, 6, 7]
[6, 7, 8]
[7, 8, 9]
[8, 9, 10]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_entry"> <span class="method-callseq"> each_entry { |obj| block } → enum </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_entry → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_entry-source"> <pre class="c" data-language="c">static VALUE
enum_each_entry(int argc, VALUE *argv, VALUE obj)
{
    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);
    rb_block_call(obj, id_each, argc, argv, each_val_i, 0);
    return obj;
}</pre> </div> <p>Calls <em>block</em> once for each element in <code>self</code>, passing that element as a parameter, converting multiple values from yield to an array.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">class Foo
  include Enumerable
  def each
    yield 1
    yield 1, 2
    yield
  end
end
Foo.new.each_entry{ |o| p o }
</pre> <p>produces:</p> <pre class="ruby" data-language="ruby">1
[1, 2]
nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_slice"> <span class="method-callseq"> each_slice(n) { ... } → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_slice(n) → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_slice-source"> <pre class="c" data-language="c">static VALUE
enum_each_slice(VALUE obj, VALUE n)
{
    long size = NUM2LONG(n);
    VALUE ary;
    struct MEMO *memo;
    int arity;

    if (size &lt;= 0) rb_raise(rb_eArgError, "invalid slice size");
    RETURN_SIZED_ENUMERATOR(obj, 1, &amp;n, enum_each_slice_size);
    size = limit_by_enum_size(obj, size);
    ary = rb_ary_new2(size);
    arity = rb_block_arity();
    memo = MEMO_NEW(ary, dont_recycle_block_arg(arity), size);
    rb_block_call(obj, id_each, 0, 0, each_slice_i, (VALUE)memo);
    ary = memo-&gt;v1;
    if (RARRAY_LEN(ary) &gt; 0) rb_yield(ary);

    return Qnil;
}</pre> </div> <p>Iterates the given block for each slice of &lt;n&gt; elements. If no block is given, returns an enumerator.</p> <pre class="ruby" data-language="ruby">(1..10).each_slice(3) { |a| p a }
# outputs below
[1, 2, 3]
[4, 5, 6]
[7, 8, 9]
[10]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_with_index"> <span class="method-callseq"> each_with_index(*args) { |obj, i| block } → enum </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_with_index(*args) → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_with_index-source"> <pre class="c" data-language="c">static VALUE
enum_each_with_index(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);

    memo = MEMO_NEW(0, 0, 0);
    rb_block_call(obj, id_each, argc, argv, each_with_index_i, (VALUE)memo);
    return obj;
}</pre> </div> <p>Calls <em>block</em> with two arguments, the item and its index, for each item in <em>enum</em>. Given arguments are passed through to each().</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">hash = Hash.new
%w(cat dog wombat).each_with_index { |item, index|
  hash[item] = index
}
hash   #=&gt; {"cat"=&gt;0, "dog"=&gt;1, "wombat"=&gt;2}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_with_object"> <span class="method-callseq"> each_with_object(obj) { |(*args), memo_obj| ... } → obj </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_with_object(obj) → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_with_object-source"> <pre class="c" data-language="c">static VALUE
enum_each_with_object(VALUE obj, VALUE memo)
{
    RETURN_SIZED_ENUMERATOR(obj, 1, &amp;memo, enum_size);

    rb_block_call(obj, id_each, 0, 0, each_with_object_i, memo);

    return memo;
}</pre> </div> <p>Iterates the given block for each element with an arbitrary object given, and returns the initially given object.</p> <p>If no block is given, returns an enumerator.</p> <pre class="ruby" data-language="ruby">evens = (1..10).each_with_object([]) { |i, a| a &lt;&lt; i*2 }
#=&gt; [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-entries"> <span class="method-callseq"> entries(*args) → array </span> </div> <div class="method-description"> <p>Returns an array containing the items in <em>enum</em>.</p> <pre class="ruby" data-language="ruby">(1..7).to_a                       #=&gt; [1, 2, 3, 4, 5, 6, 7]
{ 'a'=&gt;1, 'b'=&gt;2, 'c'=&gt;3 }.to_a   #=&gt; [["a", 1], ["b", 2], ["c", 3]]

require 'prime'
Prime.entries 10                  #=&gt; [2, 3, 5, 7]
</pre> </div> <div class="aliases"> Alias for: <a href="enumerable#method-i-to_a">to_a</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-filter"> <span class="method-callseq"> filter { |obj| block } → array </span> </div> <div class="method-heading"> <span class="method-callseq"> filter → an_enumerator </span> </div> <div class="method-description"> <p>Returns an array containing all elements of <code>enum</code> for which the given <code>block</code> returns a true value.</p> <p>The <em>find_all</em> and <em>select</em> methods are aliases. There is no performance benefit to either.</p> <p>If no block is given, an <a href="enumerator"><code>Enumerator</code></a> is returned instead.</p> <pre class="ruby" data-language="ruby">(1..10).find_all { |i|  i % 3 == 0 }   #=&gt; [3, 6, 9]

[1,2,3,4,5].select { |num|  num.even?  }   #=&gt; [2, 4]

[:foo, :bar].filter { |x| x == :foo }   #=&gt; [:foo]
</pre> <p>See also <a href="enumerable#method-i-reject"><code>Enumerable#reject</code></a>, <a href="enumerable#method-i-grep"><code>Enumerable#grep</code></a>.</p> </div> <div class="aliases"> Alias for: <a href="enumerable#method-i-find_all">find_all</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-filter_map"> <span class="method-callseq"> filter_map { |obj| block } → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> filter_map → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="filter_map-source"> <pre class="c" data-language="c">static VALUE
enum_filter_map(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, filter_map_i, ary);

    return ary;
}</pre> </div> <p>Returns a new array containing the truthy results (everything except <code>false</code> or <code>nil</code>) of running the <code>block</code> for every element in <code>enum</code>.</p> <p>If no block is given, an <a href="enumerator"><code>Enumerator</code></a> is returned instead.</p> <pre class="ruby" data-language="ruby">(1..10).filter_map { |i| i * 2 if i.even? } #=&gt; [4, 8, 12, 16, 20]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-find"> <span class="method-callseq"> find(ifnone = nil) { |obj| block } → obj or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> find(ifnone = nil) → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="find-source"> <pre class="c" data-language="c">static VALUE
enum_find(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    VALUE if_none;

    if_none = rb_check_arity(argc, 0, 1) ? argv[0] : Qnil;
    RETURN_ENUMERATOR(obj, argc, argv);
    memo = MEMO_NEW(Qundef, 0, 0);
    rb_block_call(obj, id_each, 0, 0, find_i, (VALUE)memo);
    if (memo-&gt;u3.cnt) {
        return memo-&gt;v1;
    }
    if (!NIL_P(if_none)) {
        return rb_funcallv(if_none, id_call, 0, 0);
    }
    return Qnil;
}</pre> </div> <p>Passes each entry in <em>enum</em> to <em>block</em>. Returns the first for which <em>block</em> is not false. If no object matches, calls <em>ifnone</em> and returns its result when it is specified, or returns <code>nil</code> otherwise.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">(1..100).detect  #=&gt; #&lt;Enumerator: 1..100:detect&gt;
(1..100).find    #=&gt; #&lt;Enumerator: 1..100:find&gt;

(1..10).detect         { |i| i % 5 == 0 &amp;&amp; i % 7 == 0 }   #=&gt; nil
(1..10).find           { |i| i % 5 == 0 &amp;&amp; i % 7 == 0 }   #=&gt; nil
(1..10).detect(-&gt; {0}) { |i| i % 5 == 0 &amp;&amp; i % 7 == 0 }   #=&gt; 0
(1..10).find(-&gt; {0})   { |i| i % 5 == 0 &amp;&amp; i % 7 == 0 }   #=&gt; 0
(1..100).detect        { |i| i % 5 == 0 &amp;&amp; i % 7 == 0 }   #=&gt; 35
(1..100).find          { |i| i % 5 == 0 &amp;&amp; i % 7 == 0 }   #=&gt; 35
</pre>  </div> <div class="aliases"> Also aliased as: <a href="enumerable#method-i-detect">detect</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-find_all"> <span class="method-callseq"> find_all { |obj| block } → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> find_all → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="find_all-source"> <pre class="c" data-language="c">static VALUE
enum_find_all(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, find_all_i, ary);

    return ary;
}</pre> </div> <p>Returns an array containing all elements of <code>enum</code> for which the given <code>block</code> returns a true value.</p> <p>The <em>find_all</em> and <em>select</em> methods are aliases. There is no performance benefit to either.</p> <p>If no block is given, an <a href="enumerator"><code>Enumerator</code></a> is returned instead.</p> <pre class="ruby" data-language="ruby">(1..10).find_all { |i|  i % 3 == 0 }   #=&gt; [3, 6, 9]

[1,2,3,4,5].select { |num|  num.even?  }   #=&gt; [2, 4]

[:foo, :bar].filter { |x| x == :foo }   #=&gt; [:foo]
</pre> <p>See also <a href="enumerable#method-i-reject"><code>Enumerable#reject</code></a>, <a href="enumerable#method-i-grep"><code>Enumerable#grep</code></a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="enumerable#method-i-select">select</a>, <a href="enumerable#method-i-filter">filter</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-find_index"> <span class="method-callseq"> find_index(value) → int or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> find_index { |obj| block } → int or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> find_index → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="find_index-source"> <pre class="c" data-language="c">static VALUE
enum_find_index(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;  /* [return value, current index, ] */
    VALUE condition_value = Qnil;
    rb_block_call_func *func;

    if (argc == 0) {
        RETURN_ENUMERATOR(obj, 0, 0);
        func = find_index_iter_i;
    }
    else {
        rb_scan_args(argc, argv, "1", &amp;condition_value);
        if (rb_block_given_p()) {
            rb_warn("given block not used");
        }
        func = find_index_i;
    }

    memo = MEMO_NEW(Qnil, condition_value, 0);
    rb_block_call(obj, id_each, 0, 0, func, (VALUE)memo);
    return memo-&gt;v1;
}</pre> </div> <p>Compares each entry in <em>enum</em> with <em>value</em> or passes to <em>block</em>. Returns the index for the first for which the evaluated value is non-false. If no object matches, returns <code>nil</code></p> <p>If neither block nor argument is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">(1..10).find_index  { |i| i % 5 == 0 &amp;&amp; i % 7 == 0 }  #=&gt; nil
(1..100).find_index { |i| i % 5 == 0 &amp;&amp; i % 7 == 0 }  #=&gt; 34
(1..100).find_index(50)                               #=&gt; 49
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-first"> <span class="method-callseq"> first → obj or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> first(n) → an_array </span> </div> <div class="method-description">
<div class="method-source-code" id="first-source"> <pre class="c" data-language="c">static VALUE
enum_first(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    rb_check_arity(argc, 0, 1);
    if (argc &gt; 0) {
        return enum_take(obj, argv[0]);
    }
    else {
        memo = MEMO_NEW(Qnil, 0, 0);
        rb_block_call(obj, id_each, 0, 0, first_i, (VALUE)memo);
        return memo-&gt;v1;
    }
}</pre> </div> <p>Returns the first element, or the first <code>n</code> elements, of the enumerable. If the enumerable is empty, the first form returns <code>nil</code>, and the second form returns an empty array.</p> <pre class="ruby" data-language="ruby">%w[foo bar baz].first     #=&gt; "foo"
%w[foo bar baz].first(2)  #=&gt; ["foo", "bar"]
%w[foo bar baz].first(10) #=&gt; ["foo", "bar", "baz"]
[].first                  #=&gt; nil
[].first(10)              #=&gt; []
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-flat_map"> <span class="method-callseq"> flat_map { |obj| block } → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> flat_map → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="flat_map-source"> <pre class="c" data-language="c">static VALUE
enum_flat_map(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, flat_map_i, ary);

    return ary;
}</pre> </div> <p>Returns a new array with the concatenated results of running <em>block</em> once for every element in <em>enum</em>.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">[1, 2, 3, 4].flat_map { |e| [e, -e] } #=&gt; [1, -1, 2, -2, 3, -3, 4, -4]
[[1, 2], [3, 4]].flat_map { |e| e + [100] } #=&gt; [1, 2, 100, 3, 4, 100]
</pre>  </div> <div class="aliases"> Also aliased as: <a href="enumerable#method-i-collect_concat">collect_concat</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-grep"> <span class="method-callseq"> grep(pattern) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> grep(pattern) { |obj| block } → array </span> </div> <div class="method-description">
<div class="method-source-code" id="grep-source"> <pre class="c" data-language="c">static VALUE
enum_grep(VALUE obj, VALUE pat)
{
    return enum_grep0(obj, pat, Qtrue);
}</pre> </div> <p>Returns an array of every element in <em>enum</em> for which <code>Pattern === element</code>. If the optional <em>block</em> is supplied, each matching element is passed to it, and the block's result is stored in the output array.</p> <pre class="ruby" data-language="ruby">(1..100).grep 38..44   #=&gt; [38, 39, 40, 41, 42, 43, 44]
c = IO.constants
c.grep(/SEEK/)         #=&gt; [:SEEK_SET, :SEEK_CUR, :SEEK_END]
res = c.grep(/SEEK/) { |v| IO.const_get(v) }
res                    #=&gt; [0, 1, 2]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-grep_v"> <span class="method-callseq"> grep_v(pattern) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> grep_v(pattern) { |obj| block } → array </span> </div> <div class="method-description">
<div class="method-source-code" id="grep_v-source"> <pre class="c" data-language="c">static VALUE
enum_grep_v(VALUE obj, VALUE pat)
{
    return enum_grep0(obj, pat, Qfalse);
}</pre> </div> <p>Inverted version of <a href="enumerable#method-i-grep"><code>Enumerable#grep</code></a>. Returns an array of every element in <em>enum</em> for which not <code>Pattern === element</code>.</p> <pre class="ruby" data-language="ruby">(1..10).grep_v 2..5   #=&gt; [1, 6, 7, 8, 9, 10]
res =(1..10).grep_v(2..5) { |v| v * 2 }
res                    #=&gt; [2, 12, 14, 16, 18, 20]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-group_by"> <span class="method-callseq"> group_by { |obj| block } → a_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> group_by → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="group_by-source"> <pre class="c" data-language="c">static VALUE
enum_group_by(VALUE obj)
{
    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    return enum_hashify(obj, 0, 0, group_by_i);
}</pre> </div> <p>Groups the collection by result of the block. Returns a hash where the keys are the evaluated result from the block and the values are arrays of elements in the collection that correspond to the key.</p> <p>If no block is given an enumerator is returned.</p> <pre class="ruby" data-language="ruby">(1..6).group_by { |i| i%3 }   #=&gt; {0=&gt;[3, 6], 1=&gt;[1, 4], 2=&gt;[2, 5]}
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-include-3F"> <span class="method-callseq"> include?(obj) → true or false </span> </div> <div class="method-description"> <p>Returns <code>true</code> if any member of <em>enum</em> equals <em>obj</em>. Equality is tested using <code>==</code>.</p> <pre class="ruby" data-language="ruby">(1..10).include? 5  #=&gt; true
(1..10).include? 15 #=&gt; false
(1..10).member? 5   #=&gt; true
(1..10).member? 15  #=&gt; false
</pre> </div> <div class="aliases"> Alias for: <a href="enumerable#method-i-member-3F">member?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inject"> <span class="method-callseq"> inject(initial, sym) → obj </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> inject(sym) → obj </span> </div> <div class="method-heading"> <span class="method-callseq"> inject(initial) { |memo, obj| block } → obj </span> </div> <div class="method-heading"> <span class="method-callseq"> inject { |memo, obj| block } → obj </span> </div> <div class="method-description">
<div class="method-source-code" id="inject-source"> <pre class="c" data-language="c">static VALUE
enum_inject(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    VALUE init, op;
    rb_block_call_func *iter = inject_i;
    ID id;

    switch (rb_scan_args(argc, argv, "02", &amp;init, &amp;op)) {
      case 0:
        init = Qundef;
        break;
      case 1:
        if (rb_block_given_p()) {
            break;
        }
        id = rb_check_id(&amp;init);
        op = id ? ID2SYM(id) : init;
        init = Qundef;
        iter = inject_op_i;
        break;
      case 2:
        if (rb_block_given_p()) {
            rb_warning("given block not used");
        }
        id = rb_check_id(&amp;op);
        if (id) op = ID2SYM(id);
        iter = inject_op_i;
        break;
    }

    if (iter == inject_op_i &amp;&amp;
        SYMBOL_P(op) &amp;&amp;
        RB_TYPE_P(obj, T_ARRAY) &amp;&amp;
        rb_method_basic_definition_p(CLASS_OF(obj), id_each)) {
        return ary_inject_op(obj, init, op);
    }

    memo = MEMO_NEW(init, Qnil, op);
    rb_block_call(obj, id_each, 0, 0, iter, (VALUE)memo);
    if (memo-&gt;v1 == Qundef) return Qnil;
    return memo-&gt;v1;
}</pre> </div> <p>Combines all elements of <em>enum</em> by applying a binary operation, specified by a block or a symbol that names a method or operator.</p> <p>The <em>inject</em> and <em>reduce</em> methods are aliases. There is no performance benefit to either.</p> <p>If you specify a block, then for each element in <em>enum</em> the block is passed an accumulator value (<em>memo</em>) and the element. If you specify a symbol instead, then each element in the collection will be passed to the named method of <em>memo</em>. In either case, the result becomes the new value for <em>memo</em>. At the end of the iteration, the final value of <em>memo</em> is the return value for the method.</p> <p>If you do not explicitly specify an <em>initial</em> value for <em>memo</em>, then the first element of collection is used as the initial value of <em>memo</em>.</p> <pre class="ruby" data-language="ruby"># Sum some numbers
(5..10).reduce(:+)                             #=&gt; 45
# Same using a block and inject
(5..10).inject { |sum, n| sum + n }            #=&gt; 45
# Multiply some numbers
(5..10).reduce(1, :*)                          #=&gt; 151200
# Same using a block
(5..10).inject(1) { |product, n| product * n } #=&gt; 151200
# find the longest word
longest = %w{ cat sheep bear }.inject do |memo, word|
   memo.length &gt; word.length ? memo : word
end
longest                                        #=&gt; "sheep"
</pre>  </div> <div class="aliases"> Also aliased as: <a href="enumerable#method-i-reduce">reduce</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-lazy"> <span class="method-callseq"> lazy → lazy_enumerator </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="lazy-source"> <pre class="c" data-language="c">static VALUE
enumerable_lazy(VALUE obj)
{
    VALUE result = lazy_to_enum_i(obj, sym_each, 0, 0, lazyenum_size, rb_keyword_given_p());
    /* Qfalse indicates that the Enumerator::Lazy has no method name */
    rb_ivar_set(result, id_method, Qfalse);
    return result;
}</pre> </div> <p>Returns an <a href="enumerator/lazy"><code>Enumerator::Lazy</code></a>, which redefines most <a href="enumerable"><code>Enumerable</code></a> methods to postpone enumeration and enumerate values only on an as-needed basis.</p> <h3 id="method-i-lazy-label-Example">Example</h3> <p>The following program finds pythagorean triples:</p> <pre class="ruby" data-language="ruby">def pythagorean_triples
  (1..Float::INFINITY).lazy.flat_map {|z|
    (1..z).flat_map {|x|
      (x..z).select {|y|
        x**2 + y**2 == z**2
      }.map {|y|
        [x, y, z]
      }
    }
  }
end
# show first ten pythagorean triples
p pythagorean_triples.take(10).force # take is lazy, so force is needed
p pythagorean_triples.first(10)      # first is eager
# show pythagorean triples less than 100
p pythagorean_triples.take_while { |*, z| z &lt; 100 }.force
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-map"> <span class="method-callseq"> map { |obj| block } → array </span> </div> <div class="method-heading"> <span class="method-callseq"> map → an_enumerator </span> </div> <div class="method-description"> <p>Returns a new array with the results of running <em>block</em> once for every element in <em>enum</em>.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">(1..4).map { |i| i*i }      #=&gt; [1, 4, 9, 16]
(1..4).collect { "cat"  }   #=&gt; ["cat", "cat", "cat", "cat"]
</pre> </div> <div class="aliases"> Alias for: <a href="enumerable#method-i-collect">collect</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-max"> <span class="method-callseq"> max → obj </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> max { |a, b| block } → obj </span> </div> <div class="method-heading"> <span class="method-callseq"> max(n) → array </span> </div> <div class="method-heading"> <span class="method-callseq"> max(n) { |a, b| block } → array </span> </div> <div class="method-description">
<div class="method-source-code" id="max-source"> <pre class="c" data-language="c">static VALUE
enum_max(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo;
    struct max_t *m = NEW_CMP_OPT_MEMO(struct max_t, memo);
    VALUE result;
    VALUE num;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(num = argv[0]))
       return rb_nmin_run(obj, num, 0, 1, 0);

    m-&gt;max = Qundef;
    m-&gt;cmp_opt.opt_methods = 0;
    m-&gt;cmp_opt.opt_inited = 0;
    if (rb_block_given_p()) {
        rb_block_call(obj, id_each, 0, 0, max_ii, (VALUE)memo);
    }
    else {
        rb_block_call(obj, id_each, 0, 0, max_i, (VALUE)memo);
    }
    result = m-&gt;max;
    if (result == Qundef) return Qnil;
    return result;
}</pre> </div> <p>Returns the object in <em>enum</em> with the maximum value. The first form assumes all objects implement <code>&lt;=&gt;</code>; the second uses the block to return <em>a &lt;=&gt; b</em>.</p> <pre class="ruby" data-language="ruby">a = %w(albatross dog horse)
a.max                                   #=&gt; "horse"
a.max { |a, b| a.length &lt;=&gt; b.length }  #=&gt; "albatross"
</pre> <p>If the <code>n</code> argument is given, maximum <code>n</code> elements are returned as an array, sorted in descending order.</p> <pre class="ruby" data-language="ruby">a = %w[albatross dog horse]
a.max(2)                                  #=&gt; ["horse", "dog"]
a.max(2) {|a, b| a.length &lt;=&gt; b.length }  #=&gt; ["albatross", "horse"]
[5, 1, 3, 4, 2].max(3)                    #=&gt; [5, 4, 3]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-max_by"> <span class="method-callseq"> max_by {|obj| block } → obj </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> max_by → an_enumerator </span> </div> <div class="method-heading"> <span class="method-callseq"> max_by(n) {|obj| block } → obj </span> </div> <div class="method-heading"> <span class="method-callseq"> max_by(n) → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="max_by-source"> <pre class="c" data-language="c">static VALUE
enum_max_by(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    VALUE num;

    rb_check_arity(argc, 0, 1);

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);

    if (argc &amp;&amp; !NIL_P(num = argv[0]))
        return rb_nmin_run(obj, num, 1, 1, 0);

    memo = MEMO_NEW(Qundef, Qnil, 0);
    rb_block_call(obj, id_each, 0, 0, max_by_i, (VALUE)memo);
    return memo-&gt;v2;
}</pre> </div> <p>Returns the object in <em>enum</em> that gives the maximum value from the given block.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">a = %w(albatross dog horse)
a.max_by { |x| x.length }   #=&gt; "albatross"
</pre> <p>If the <code>n</code> argument is given, maximum <code>n</code> elements are returned as an array. These <code>n</code> elements are sorted by the value from the given block, in descending order.</p> <pre class="ruby" data-language="ruby">a = %w[albatross dog horse]
a.max_by(2) {|x| x.length } #=&gt; ["albatross", "horse"]
</pre> <p>enum.max_by(n) can be used to implement weighted random sampling. Following example implements and use Enumerable#wsample.</p> <pre class="ruby" data-language="ruby">module Enumerable
  # weighted random sampling.
  #
  # Pavlos S. Efraimidis, Paul G. Spirakis
  # Weighted random sampling with a reservoir
  # Information Processing Letters
  # Volume 97, Issue 5 (16 March 2006)
  def wsample(n)
    self.max_by(n) {|v| rand ** (1.0/yield(v)) }
  end
end
e = (-20..20).to_a*10000
a = e.wsample(20000) {|x|
  Math.exp(-(x/5.0)**2) # normal distribution
}
# a is 20000 samples from e.
p a.length #=&gt; 20000
h = a.group_by {|x| x }
-10.upto(10) {|x| puts "*" * (h[x].length/30.0).to_i if h[x] }
#=&gt; *
#   ***
#   ******
#   ***********
#   ******************
#   *****************************
#   *****************************************
#   ****************************************************
#   ***************************************************************
#   ********************************************************************
#   ***********************************************************************
#   ***********************************************************************
#   **************************************************************
#   ****************************************************
#   ***************************************
#   ***************************
#   ******************
#   ***********
#   *******
#   ***
#   *
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-member-3F"> <span class="method-callseq"> member?(obj) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="member-3F-source"> <pre class="c" data-language="c">static VALUE
enum_member(VALUE obj, VALUE val)
{
    struct MEMO *memo = MEMO_NEW(val, Qfalse, 0);

    rb_block_call(obj, id_each, 0, 0, member_i, (VALUE)memo);
    return memo-&gt;v2;
}</pre> </div> <p>Returns <code>true</code> if any member of <em>enum</em> equals <em>obj</em>. Equality is tested using <code>==</code>.</p> <pre class="ruby" data-language="ruby">(1..10).include? 5  #=&gt; true
(1..10).include? 15 #=&gt; false
(1..10).member? 5   #=&gt; true
(1..10).member? 15  #=&gt; false
</pre>  </div> <div class="aliases"> Also aliased as: <a href="enumerable#method-i-include-3F">include?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-min"> <span class="method-callseq"> min → obj </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> min { |a, b| block } → obj </span> </div> <div class="method-heading"> <span class="method-callseq"> min(n) → array </span> </div> <div class="method-heading"> <span class="method-callseq"> min(n) { |a, b| block } → array </span> </div> <div class="method-description">
<div class="method-source-code" id="min-source"> <pre class="c" data-language="c">static VALUE
enum_min(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo;
    struct min_t *m = NEW_CMP_OPT_MEMO(struct min_t, memo);
    VALUE result;
    VALUE num;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(num = argv[0]))
       return rb_nmin_run(obj, num, 0, 0, 0);

    m-&gt;min = Qundef;
    m-&gt;cmp_opt.opt_methods = 0;
    m-&gt;cmp_opt.opt_inited = 0;
    if (rb_block_given_p()) {
        rb_block_call(obj, id_each, 0, 0, min_ii, memo);
    }
    else {
        rb_block_call(obj, id_each, 0, 0, min_i, memo);
    }
    result = m-&gt;min;
    if (result == Qundef) return Qnil;
    return result;
}</pre> </div> <p>Returns the object in <em>enum</em> with the minimum value. The first form assumes all objects implement <code>&lt;=&gt;</code>; the second uses the block to return <em>a &lt;=&gt; b</em>.</p> <pre class="ruby" data-language="ruby">a = %w(albatross dog horse)
a.min                                   #=&gt; "albatross"
a.min { |a, b| a.length &lt;=&gt; b.length }  #=&gt; "dog"
</pre> <p>If the <code>n</code> argument is given, minimum <code>n</code> elements are returned as a sorted array.</p> <pre class="ruby" data-language="ruby">a = %w[albatross dog horse]
a.min(2)                                  #=&gt; ["albatross", "dog"]
a.min(2) {|a, b| a.length &lt;=&gt; b.length }  #=&gt; ["dog", "horse"]
[5, 1, 3, 4, 2].min(3)                    #=&gt; [1, 2, 3]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-min_by"> <span class="method-callseq"> min_by {|obj| block } → obj </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> min_by → an_enumerator </span> </div> <div class="method-heading"> <span class="method-callseq"> min_by(n) {|obj| block } → array </span> </div> <div class="method-heading"> <span class="method-callseq"> min_by(n) → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="min_by-source"> <pre class="c" data-language="c">static VALUE
enum_min_by(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    VALUE num;

    rb_check_arity(argc, 0, 1);

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);

    if (argc &amp;&amp; !NIL_P(num = argv[0]))
        return rb_nmin_run(obj, num, 1, 0, 0);

    memo = MEMO_NEW(Qundef, Qnil, 0);
    rb_block_call(obj, id_each, 0, 0, min_by_i, (VALUE)memo);
    return memo-&gt;v2;
}</pre> </div> <p>Returns the object in <em>enum</em> that gives the minimum value from the given block.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">a = %w(albatross dog horse)
a.min_by { |x| x.length }   #=&gt; "dog"
</pre> <p>If the <code>n</code> argument is given, minimum <code>n</code> elements are returned as an array. These <code>n</code> elements are sorted by the value from the given block.</p> <pre class="ruby" data-language="ruby">a = %w[albatross dog horse]
p a.min_by(2) {|x| x.length } #=&gt; ["dog", "horse"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-minmax"> <span class="method-callseq"> minmax → [min, max] </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> minmax { |a, b| block } → [min, max] </span> </div> <div class="method-description">
<div class="method-source-code" id="minmax-source"> <pre class="c" data-language="c">static VALUE
enum_minmax(VALUE obj)
{
    VALUE memo;
    struct minmax_t *m = NEW_CMP_OPT_MEMO(struct minmax_t, memo);

    m-&gt;min = Qundef;
    m-&gt;last = Qundef;
    m-&gt;cmp_opt.opt_methods = 0;
    m-&gt;cmp_opt.opt_inited = 0;
    if (rb_block_given_p()) {
        rb_block_call(obj, id_each, 0, 0, minmax_ii, memo);
        if (m-&gt;last != Qundef)
            minmax_ii_update(m-&gt;last, m-&gt;last, m);
    }
    else {
        rb_block_call(obj, id_each, 0, 0, minmax_i, memo);
        if (m-&gt;last != Qundef)
            minmax_i_update(m-&gt;last, m-&gt;last, m);
    }
    if (m-&gt;min != Qundef) {
        return rb_assoc_new(m-&gt;min, m-&gt;max);
    }
    return rb_assoc_new(Qnil, Qnil);
}</pre> </div> <p>Returns a two element array which contains the minimum and the maximum value in the enumerable. The first form assumes all objects implement <code>&lt;=&gt;</code>; the second uses the block to return <em>a &lt;=&gt; b</em>.</p> <pre class="ruby" data-language="ruby">a = %w(albatross dog horse)
a.minmax                                  #=&gt; ["albatross", "horse"]
a.minmax { |a, b| a.length &lt;=&gt; b.length } #=&gt; ["dog", "albatross"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-minmax_by"> <span class="method-callseq"> minmax_by { |obj| block } → [min, max] </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> minmax_by → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="minmax_by-source"> <pre class="c" data-language="c">static VALUE
enum_minmax_by(VALUE obj)
{
    VALUE memo;
    struct minmax_by_t *m = NEW_MEMO_FOR(struct minmax_by_t, memo);

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    m-&gt;min_bv = Qundef;
    m-&gt;max_bv = Qundef;
    m-&gt;min = Qnil;
    m-&gt;max = Qnil;
    m-&gt;last_bv = Qundef;
    m-&gt;last = Qundef;
    rb_block_call(obj, id_each, 0, 0, minmax_by_i, memo);
    if (m-&gt;last_bv != Qundef)
        minmax_by_i_update(m-&gt;last_bv, m-&gt;last_bv, m-&gt;last, m-&gt;last, m);
    m = MEMO_FOR(struct minmax_by_t, memo);
    return rb_assoc_new(m-&gt;min, m-&gt;max);
}</pre> </div> <p>Returns a two element array containing the objects in <em>enum</em> that correspond to the minimum and maximum values respectively from the given block.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">a = %w(albatross dog horse)
a.minmax_by { |x| x.length }   #=&gt; ["dog", "albatross"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-none-3F"> <span class="method-callseq"> none? [{ |obj| block }] → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> none?(pattern) → true or false </span> </div> <div class="method-description">
<div class="method-source-code" id="none-3F-source"> <pre class="c" data-language="c">static VALUE
enum_none(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo = MEMO_ENUM_NEW(Qtrue);

    WARN_UNUSED_BLOCK(argc);
    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(none), (VALUE)memo);
    return memo-&gt;v1;
}</pre> </div> <p>Passes each element of the collection to the given block. The method returns <code>true</code> if the block never returns <code>true</code> for all elements. If the block is not given, <code>none?</code> will return <code>true</code> only if none of the collection members is true.</p> <p>If instead a pattern is supplied, the method returns whether <code>pattern === element</code> for none of the collection members.</p> <pre class="ruby" data-language="ruby">%w{ant bear cat}.none? { |word| word.length == 5 } #=&gt; true
%w{ant bear cat}.none? { |word| word.length &gt;= 4 } #=&gt; false
%w{ant bear cat}.none?(/d/)                        #=&gt; true
[1, 3.14, 42].none?(Float)                         #=&gt; false
[].none?                                           #=&gt; true
[nil].none?                                        #=&gt; true
[nil, false].none?                                 #=&gt; true
[nil, false, true].none?                           #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-one-3F"> <span class="method-callseq"> one? [{ |obj| block }] → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> one?(pattern) → true or false </span> </div> <div class="method-description">
<div class="method-source-code" id="one-3F-source"> <pre class="c" data-language="c">static VALUE
enum_one(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo = MEMO_ENUM_NEW(Qundef);
    VALUE result;

    WARN_UNUSED_BLOCK(argc);
    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(one), (VALUE)memo);
    result = memo-&gt;v1;
    if (result == Qundef) return Qfalse;
    return result;
}</pre> </div> <p>Passes each element of the collection to the given block. The method returns <code>true</code> if the block returns <code>true</code> exactly once. If the block is not given, <code>one?</code> will return <code>true</code> only if exactly one of the collection members is true.</p> <p>If instead a pattern is supplied, the method returns whether <code>pattern === element</code> for exactly one collection member.</p> <pre class="ruby" data-language="ruby">%w{ant bear cat}.one? { |word| word.length == 4 }  #=&gt; true
%w{ant bear cat}.one? { |word| word.length &gt; 4 }   #=&gt; false
%w{ant bear cat}.one? { |word| word.length &lt; 4 }   #=&gt; false
%w{ant bear cat}.one?(/t/)                         #=&gt; false
[ nil, true, 99 ].one?                             #=&gt; false
[ nil, true, false ].one?                          #=&gt; true
[ nil, true, 99 ].one?(Integer)                    #=&gt; true
[].one?                                            #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-partition"> <span class="method-callseq"> partition { |obj| block } → [ true_array, false_array ] </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> partition → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="partition-source"> <pre class="c" data-language="c">static VALUE
enum_partition(VALUE obj)
{
    struct MEMO *memo;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    memo = MEMO_NEW(rb_ary_new(), rb_ary_new(), 0);
    rb_block_call(obj, id_each, 0, 0, partition_i, (VALUE)memo);

    return rb_assoc_new(memo-&gt;v1, memo-&gt;v2);
}</pre> </div> <p>Returns two arrays, the first containing the elements of <em>enum</em> for which the block evaluates to true, the second containing the rest.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">(1..6).partition { |v| v.even? }  #=&gt; [[2, 4, 6], [1, 3, 5]]
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-reduce"> <span class="method-callseq"> reduce(initial, sym) → obj </span> </div> <div class="method-heading"> <span class="method-callseq"> reduce(sym) → obj </span> </div> <div class="method-heading"> <span class="method-callseq"> reduce(initial) { |memo, obj| block } → obj </span> </div> <div class="method-heading"> <span class="method-callseq"> reduce { |memo, obj| block } → obj </span> </div> <div class="method-description"> <p>Combines all elements of <em>enum</em> by applying a binary operation, specified by a block or a symbol that names a method or operator.</p> <p>The <em>inject</em> and <em>reduce</em> methods are aliases. There is no performance benefit to either.</p> <p>If you specify a block, then for each element in <em>enum</em> the block is passed an accumulator value (<em>memo</em>) and the element. If you specify a symbol instead, then each element in the collection will be passed to the named method of <em>memo</em>. In either case, the result becomes the new value for <em>memo</em>. At the end of the iteration, the final value of <em>memo</em> is the return value for the method.</p> <p>If you do not explicitly specify an <em>initial</em> value for <em>memo</em>, then the first element of collection is used as the initial value of <em>memo</em>.</p> <pre class="ruby" data-language="ruby"># Sum some numbers
(5..10).reduce(:+)                             #=&gt; 45
# Same using a block and inject
(5..10).inject { |sum, n| sum + n }            #=&gt; 45
# Multiply some numbers
(5..10).reduce(1, :*)                          #=&gt; 151200
# Same using a block
(5..10).inject(1) { |product, n| product * n } #=&gt; 151200
# find the longest word
longest = %w{ cat sheep bear }.inject do |memo, word|
   memo.length &gt; word.length ? memo : word
end
longest                                        #=&gt; "sheep"
</pre> </div> <div class="aliases"> Alias for: <a href="enumerable#method-i-inject">inject</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-reject"> <span class="method-callseq"> reject { |obj| block } → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> reject → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="reject-source"> <pre class="c" data-language="c">static VALUE
enum_reject(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, reject_i, ary);

    return ary;
}</pre> </div> <p>Returns an array for all elements of <code>enum</code> for which the given <code>block</code> returns <code>false</code>.</p> <p>If no block is given, an <a href="enumerator"><code>Enumerator</code></a> is returned instead.</p> <pre class="ruby" data-language="ruby">(1..10).reject { |i|  i % 3 == 0 }   #=&gt; [1, 2, 4, 5, 7, 8, 10]

[1, 2, 3, 4, 5].reject { |num| num.even? } #=&gt; [1, 3, 5]
</pre> <p>See also <a href="enumerable#method-i-find_all"><code>Enumerable#find_all</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-reverse_each"> <span class="method-callseq"> reverse_each(*args) { |item| block } → enum </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> reverse_each(*args) → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="reverse_each-source"> <pre class="c" data-language="c">static VALUE
enum_reverse_each(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary;
    long len;

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);

    ary = enum_to_a(argc, argv, obj);

    len = RARRAY_LEN(ary);
    while (len--) {
        long nlen;
        rb_yield(RARRAY_AREF(ary, len));
        nlen = RARRAY_LEN(ary);
        if (nlen &lt; len) {
            len = nlen;
        }
    }

    return obj;
}</pre> </div> <p>Builds a temporary array and traverses that array in reverse order.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">(1..3).reverse_each { |v| p v }
</pre> <p>produces:</p> <pre class="ruby" data-language="ruby">3
2
1
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-select"> <span class="method-callseq"> select { |obj| block } → array </span> </div> <div class="method-heading"> <span class="method-callseq"> select → an_enumerator </span> </div> <div class="method-description"> <p>Returns an array containing all elements of <code>enum</code> for which the given <code>block</code> returns a true value.</p> <p>The <em>find_all</em> and <em>select</em> methods are aliases. There is no performance benefit to either.</p> <p>If no block is given, an <a href="enumerator"><code>Enumerator</code></a> is returned instead.</p> <pre class="ruby" data-language="ruby">(1..10).find_all { |i|  i % 3 == 0 }   #=&gt; [3, 6, 9]

[1,2,3,4,5].select { |num|  num.even?  }   #=&gt; [2, 4]

[:foo, :bar].filter { |x| x == :foo }   #=&gt; [:foo]
</pre> <p>See also <a href="enumerable#method-i-reject"><code>Enumerable#reject</code></a>, <a href="enumerable#method-i-grep"><code>Enumerable#grep</code></a>.</p> </div> <div class="aliases"> Alias for: <a href="enumerable#method-i-find_all">find_all</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-slice_after"> <span class="method-callseq"> slice_after(pattern) → an_enumerator </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> slice_after { |elt| bool } → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="slice_after-source"> <pre class="c" data-language="c">static VALUE
enum_slice_after(int argc, VALUE *argv, VALUE enumerable)
{
    VALUE enumerator;
    VALUE pat = Qnil, pred = Qnil;

    if (rb_block_given_p()) {
        if (0 &lt; argc)
            rb_raise(rb_eArgError, "both pattern and block are given");
        pred = rb_block_proc();
    }
    else {
        rb_scan_args(argc, argv, "1", &amp;pat);
    }

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, rb_intern("sliceafter_enum"), enumerable);
    rb_ivar_set(enumerator, rb_intern("sliceafter_pat"), pat);
    rb_ivar_set(enumerator, rb_intern("sliceafter_pred"), pred);

    rb_block_call(enumerator, idInitialize, 0, 0, sliceafter_i, enumerator);
    return enumerator;
}</pre> </div> <p>Creates an enumerator for each chunked elements. The ends of chunks are defined by <em>pattern</em> and the block.</p> <p>If <code><em>pattern</em> === <em>elt</em></code> returns <code>true</code> or the block returns <code>true</code> for the element, the element is end of a chunk.</p> <p>The <code>===</code> and <em>block</em> is called from the first element to the last element of <em>enum</em>.</p> <p>The result enumerator yields the chunked elements as an array. So <code>each</code> method can be called as follows:</p> <pre>enum.slice_after(pattern).each { |ary| ... }
enum.slice_after { |elt| bool }.each { |ary| ... }</pre> <p>Other methods of the <a href="enumerator"><code>Enumerator</code></a> class and <a href="enumerable"><code>Enumerable</code></a> module, such as <code>map</code>, etc., are also usable.</p> <p>For example, continuation lines (lines end with backslash) can be concatenated as follows:</p> <pre class="ruby" data-language="ruby">lines = ["foo\n", "bar\\\n", "baz\n", "\n", "qux\n"]
e = lines.slice_after(/(?&lt;!\\)\n\z/)
p e.to_a
#=&gt; [["foo\n"], ["bar\\\n", "baz\n"], ["\n"], ["qux\n"]]
p e.map {|ll| ll[0...-1].map {|l| l.sub(/\\\n\z/, "") }.join + ll.last }
#=&gt;["foo\n", "barbaz\n", "\n", "qux\n"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-slice_before"> <span class="method-callseq"> slice_before(pattern) → an_enumerator </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> slice_before { |elt| bool } → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="slice_before-source"> <pre class="c" data-language="c">static VALUE
enum_slice_before(int argc, VALUE *argv, VALUE enumerable)
{
    VALUE enumerator;

    if (rb_block_given_p()) {
        if (argc != 0)
            rb_error_arity(argc, 0, 0);
        enumerator = rb_obj_alloc(rb_cEnumerator);
        rb_ivar_set(enumerator, rb_intern("slicebefore_sep_pred"), rb_block_proc());
    }
    else {
        VALUE sep_pat;
        rb_scan_args(argc, argv, "1", &amp;sep_pat);
        enumerator = rb_obj_alloc(rb_cEnumerator);
        rb_ivar_set(enumerator, rb_intern("slicebefore_sep_pat"), sep_pat);
    }
    rb_ivar_set(enumerator, rb_intern("slicebefore_enumerable"), enumerable);
    rb_block_call(enumerator, idInitialize, 0, 0, slicebefore_i, enumerator);
    return enumerator;
}</pre> </div> <p>Creates an enumerator for each chunked elements. The beginnings of chunks are defined by <em>pattern</em> and the block.</p> <p>If <code><em>pattern</em> === <em>elt</em></code> returns <code>true</code> or the block returns <code>true</code> for the element, the element is beginning of a chunk.</p> <p>The <code>===</code> and <em>block</em> is called from the first element to the last element of <em>enum</em>. The result for the first element is ignored.</p> <p>The result enumerator yields the chunked elements as an array. So <code>each</code> method can be called as follows:</p> <pre>enum.slice_before(pattern).each { |ary| ... }
enum.slice_before { |elt| bool }.each { |ary| ... }</pre> <p>Other methods of the <a href="enumerator"><code>Enumerator</code></a> class and <a href="enumerable"><code>Enumerable</code></a> module, such as <code>to_a</code>, <code>map</code>, etc., are also usable.</p> <p>For example, iteration over ChangeLog entries can be implemented as follows:</p> <pre class="ruby" data-language="ruby"># iterate over ChangeLog entries.
open("ChangeLog") { |f|
  f.slice_before(/\A\S/).each { |e| pp e }
}

# same as above.  block is used instead of pattern argument.
open("ChangeLog") { |f|
  f.slice_before { |line| /\A\S/ === line }.each { |e| pp e }
}
</pre> <p>“svn proplist -R” produces multiline output for each file. They can be chunked as follows:</p> <pre class="ruby" data-language="ruby">IO.popen([{"LC_ALL"=&gt;"C"}, "svn", "proplist", "-R"]) { |f|
  f.lines.slice_before(/\AProp/).each { |lines| p lines }
}
#=&gt; ["Properties on '.':\n", "  svn:ignore\n", "  svk:merge\n"]
#   ["Properties on 'goruby.c':\n", "  svn:eol-style\n"]
#   ["Properties on 'complex.c':\n", "  svn:mime-type\n", "  svn:eol-style\n"]
#   ["Properties on 'regparse.c':\n", "  svn:eol-style\n"]
#   ...
</pre> <p>If the block needs to maintain state over multiple elements, local variables can be used. For example, three or more consecutive increasing numbers can be squashed as follows (see <code>chunk_while</code> for a better way):</p> <pre class="ruby" data-language="ruby">a = [0, 2, 3, 4, 6, 7, 9]
prev = a[0]
p a.slice_before { |e|
  prev, prev2 = e, prev
  prev2 + 1 != e
}.map { |es|
  es.length &lt;= 2 ? es.join(",") : "#{es.first}-#{es.last}"
}.join(",")
#=&gt; "0,2-4,6,7,9"
</pre> <p>However local variables should be used carefully if the result enumerator is enumerated twice or more. The local variables should be initialized for each enumeration. <a href="enumerator#method-c-new"><code>Enumerator.new</code></a> can be used to do it.</p> <pre class="ruby" data-language="ruby"># Word wrapping.  This assumes all characters have same width.
def wordwrap(words, maxwidth)
  Enumerator.new {|y|
    # cols is initialized in Enumerator.new.
    cols = 0
    words.slice_before { |w|
      cols += 1 if cols != 0
      cols += w.length
      if maxwidth &lt; cols
        cols = w.length
        true
      else
        false
      end
    }.each {|ws| y.yield ws }
  }
end
text = (1..20).to_a.join(" ")
enum = wordwrap(text.split(/\s+/), 10)
puts "-"*10
enum.each { |ws| puts ws.join(" ") } # first enumeration.
puts "-"*10
enum.each { |ws| puts ws.join(" ") } # second enumeration generates same result as the first.
puts "-"*10
#=&gt; ----------
#   1 2 3 4 5
#   6 7 8 9 10
#   11 12 13
#   14 15 16
#   17 18 19
#   20
#   ----------
#   1 2 3 4 5
#   6 7 8 9 10
#   11 12 13
#   14 15 16
#   17 18 19
#   20
#   ----------
</pre> <p>mbox contains series of mails which start with Unix From line. So each mail can be extracted by slice before Unix From line.</p> <pre class="ruby" data-language="ruby"># parse mbox
open("mbox") { |f|
  f.slice_before { |line|
    line.start_with? "From "
  }.each { |mail|
    unix_from = mail.shift
    i = mail.index("\n")
    header = mail[0...i]
    body = mail[(i+1)..-1]
    body.pop if body.last == "\n"
    fields = header.slice_before { |line| !" \t".include?(line[0]) }.to_a
    p unix_from
    pp fields
    pp body
  }
}

# split mails in mbox (slice before Unix From line after an empty line)
open("mbox") { |f|
  emp = true
  f.slice_before { |line|
    prevemp = emp
    emp = line == "\n"
    prevemp &amp;&amp; line.start_with?("From ")
  }.each { |mail|
    mail.pop if mail.last == "\n"
    pp mail
  }
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-slice_when"> <span class="method-callseq"> slice_when {|elt_before, elt_after| bool } → an_enumerator </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="slice_when-source"> <pre class="c" data-language="c">static VALUE
enum_slice_when(VALUE enumerable)
{
    VALUE enumerator;
    VALUE pred;

    pred = rb_block_proc();

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, rb_intern("slicewhen_enum"), enumerable);
    rb_ivar_set(enumerator, rb_intern("slicewhen_pred"), pred);
    rb_ivar_set(enumerator, rb_intern("slicewhen_inverted"), Qfalse);

    rb_block_call(enumerator, idInitialize, 0, 0, slicewhen_i, enumerator);
    return enumerator;
}</pre> </div> <p>Creates an enumerator for each chunked elements. The beginnings of chunks are defined by the block.</p> <p>This method splits each chunk using adjacent elements, <em>elt_before</em> and <em>elt_after</em>, in the receiver enumerator. This method split chunks between <em>elt_before</em> and <em>elt_after</em> where the block returns <code>true</code>.</p> <p>The block is called the length of the receiver enumerator minus one.</p> <p>The result enumerator yields the chunked elements as an array. So <code>each</code> method can be called as follows:</p> <pre>enum.slice_when { |elt_before, elt_after| bool }.each { |ary| ... }</pre> <p>Other methods of the <a href="enumerator"><code>Enumerator</code></a> class and <a href="enumerable"><code>Enumerable</code></a> module, such as <code>to_a</code>, <code>map</code>, etc., are also usable.</p> <p>For example, one-by-one increasing subsequence can be chunked as follows:</p> <pre class="ruby" data-language="ruby">a = [1,2,4,9,10,11,12,15,16,19,20,21]
b = a.slice_when {|i, j| i+1 != j }
p b.to_a #=&gt; [[1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21]]
c = b.map {|a| a.length &lt; 3 ? a : "#{a.first}-#{a.last}" }
p c #=&gt; [[1, 2], [4], "9-12", [15, 16], "19-21"]
d = c.join(",")
p d #=&gt; "1,2,4,9-12,15,16,19-21"
</pre> <p>Near elements (threshold: 6) in sorted array can be chunked as follows:</p> <pre class="ruby" data-language="ruby">a = [3, 11, 14, 25, 28, 29, 29, 41, 55, 57]
p a.slice_when {|i, j| 6 &lt; j - i }.to_a
#=&gt; [[3], [11, 14], [25, 28, 29, 29], [41], [55, 57]]
</pre> <p>Increasing (non-decreasing) subsequence can be chunked as follows:</p> <pre class="ruby" data-language="ruby">a = [0, 9, 2, 2, 3, 2, 7, 5, 9, 5]
p a.slice_when {|i, j| i &gt; j }.to_a
#=&gt; [[0, 9], [2, 2, 3], [2, 7], [5, 9], [5]]
</pre> <p>Adjacent evens and odds can be chunked as follows: (<a href="enumerable#method-i-chunk"><code>Enumerable#chunk</code></a> is another way to do it.)</p> <pre class="ruby" data-language="ruby">a = [7, 5, 9, 2, 0, 7, 9, 4, 2, 0]
p a.slice_when {|i, j| i.even? != j.even? }.to_a
#=&gt; [[7, 5, 9], [2, 0], [7, 9], [4, 2, 0]]
</pre> <p>Paragraphs (non-empty lines with trailing empty lines) can be chunked as follows: (See <a href="enumerable#method-i-chunk"><code>Enumerable#chunk</code></a> to ignore empty lines.)</p> <pre class="ruby" data-language="ruby">lines = ["foo\n", "bar\n", "\n", "baz\n", "qux\n"]
p lines.slice_when {|l1, l2| /\A\s*\z/ =~ l1 &amp;&amp; /\S/ =~ l2 }.to_a
#=&gt; [["foo\n", "bar\n", "\n"], ["baz\n", "qux\n"]]
</pre> <p><a href="enumerable#method-i-chunk_while"><code>Enumerable#chunk_while</code></a> does the same, except splitting when the block returns <code>false</code> instead of <code>true</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-sort"> <span class="method-callseq"> sort → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> sort { |a, b| block } → array </span> </div> <div class="method-description">
<div class="method-source-code" id="sort-source"> <pre class="c" data-language="c">static VALUE
enum_sort(VALUE obj)
{
    return rb_ary_sort_bang(enum_to_a(0, 0, obj));
}</pre> </div> <p>Returns an array containing the items in <em>enum</em> sorted.</p> <p>Comparisons for the sort will be done using the items' own <code>&lt;=&gt;</code> operator or using an optional code block.</p> <p>The block must implement a comparison between <code>a</code> and <code>b</code> and return an integer less than 0 when <code>b</code> follows <code>a</code>, <code>0</code> when <code>a</code> and <code>b</code> are equivalent, or an integer greater than 0 when <code>a</code> follows <code>b</code>.</p> <p>The result is not guaranteed to be stable. When the comparison of two elements returns <code>0</code>, the order of the elements is unpredictable.</p> <pre class="ruby" data-language="ruby">%w(rhea kea flea).sort           #=&gt; ["flea", "kea", "rhea"]
(1..10).sort { |a, b| b &lt;=&gt; a }  #=&gt; [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
</pre> <p>See also <a href="enumerable#method-i-sort_by"><code>Enumerable#sort_by</code></a>. It implements a Schwartzian transform which is useful when key computation or comparison is expensive.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-sort_by"> <span class="method-callseq"> sort_by { |obj| block } → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> sort_by → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="sort_by-source"> <pre class="c" data-language="c">static VALUE
enum_sort_by(VALUE obj)
{
    VALUE ary, buf;
    struct MEMO *memo;
    long i;
    struct sort_by_data *data;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    if (RB_TYPE_P(obj, T_ARRAY) &amp;&amp; RARRAY_LEN(obj) &lt;= LONG_MAX/2) {
        ary = rb_ary_new2(RARRAY_LEN(obj)*2);
    }
    else {
        ary = rb_ary_new();
    }
    RBASIC_CLEAR_CLASS(ary);
    buf = rb_ary_tmp_new(SORT_BY_BUFSIZE*2);
    rb_ary_store(buf, SORT_BY_BUFSIZE*2-1, Qnil);
    memo = MEMO_NEW(0, 0, 0);
    data = (struct sort_by_data *)&amp;memo-&gt;v1;
    RB_OBJ_WRITE(memo, &amp;data-&gt;ary, ary);
    RB_OBJ_WRITE(memo, &amp;data-&gt;buf, buf);
    data-&gt;n = 0;
    rb_block_call(obj, id_each, 0, 0, sort_by_i, (VALUE)memo);
    ary = data-&gt;ary;
    buf = data-&gt;buf;
    if (data-&gt;n) {
        rb_ary_resize(buf, data-&gt;n*2);
        rb_ary_concat(ary, buf);
    }
    if (RARRAY_LEN(ary) &gt; 2) {
        RARRAY_PTR_USE(ary, ptr,
                       ruby_qsort(ptr, RARRAY_LEN(ary)/2, 2*sizeof(VALUE),
                                  sort_by_cmp, (void *)ary));
    }
    if (RBASIC(ary)-&gt;klass) {
        rb_raise(rb_eRuntimeError, "sort_by reentered");
    }
    for (i=1; i&lt;RARRAY_LEN(ary); i+=2) {
        RARRAY_ASET(ary, i/2, RARRAY_AREF(ary, i));
    }
    rb_ary_resize(ary, RARRAY_LEN(ary)/2);
    RBASIC_SET_CLASS_RAW(ary, rb_cArray);

    return ary;
}</pre> </div> <p>Sorts <em>enum</em> using a set of keys generated by mapping the values in <em>enum</em> through the given block.</p> <p>The result is not guaranteed to be stable. When two keys are equal, the order of the corresponding elements is unpredictable.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">%w{apple pear fig}.sort_by { |word| word.length }
              #=&gt; ["fig", "pear", "apple"]
</pre> <p>The current implementation of <a href="enumerable#method-i-sort_by"><code>sort_by</code></a> generates an array of tuples containing the original collection element and the mapped value. This makes <a href="enumerable#method-i-sort_by"><code>sort_by</code></a> fairly expensive when the keysets are simple.</p> <pre class="ruby" data-language="ruby">require 'benchmark'

a = (1..100000).map { rand(100000) }

Benchmark.bm(10) do |b|
  b.report("Sort")    { a.sort }
  b.report("Sort by") { a.sort_by { |a| a } }
end
</pre> <p><em>produces:</em></p> <pre>user     system      total        real
Sort        0.180000   0.000000   0.180000 (  0.175469)
Sort by     1.980000   0.040000   2.020000 (  2.013586)</pre> <p>However, consider the case where comparing the keys is a non-trivial operation. The following code sorts some files on modification time using the basic <a href="enumerable#method-i-sort"><code>sort</code></a> method.</p> <pre class="ruby" data-language="ruby">files = Dir["*"]
sorted = files.sort { |a, b| File.new(a).mtime &lt;=&gt; File.new(b).mtime }
sorted   #=&gt; ["mon", "tues", "wed", "thurs"]
</pre> <p>This sort is inefficient: it generates two new <a href="file"><code>File</code></a> objects during every comparison. A slightly better technique is to use the <a href="kernel#method-i-test"><code>Kernel#test</code></a> method to generate the modification times directly.</p> <pre class="ruby" data-language="ruby">files = Dir["*"]
sorted = files.sort { |a, b|
  test(?M, a) &lt;=&gt; test(?M, b)
}
sorted   #=&gt; ["mon", "tues", "wed", "thurs"]
</pre> <p>This still generates many unnecessary <a href="time"><code>Time</code></a> objects. A more efficient technique is to cache the sort keys (modification times in this case) before the sort. Perl users often call this approach a Schwartzian transform, after Randal Schwartz. We construct a temporary array, where each element is an array containing our sort key along with the filename. We sort this array, and then extract the filename from the result.</p> <pre class="ruby" data-language="ruby">sorted = Dir["*"].collect { |f|
   [test(?M, f), f]
}.sort.collect { |f| f[1] }
sorted   #=&gt; ["mon", "tues", "wed", "thurs"]
</pre> <p>This is exactly what <a href="enumerable#method-i-sort_by"><code>sort_by</code></a> does internally.</p> <pre class="ruby" data-language="ruby">sorted = Dir["*"].sort_by { |f| test(?M, f) }
sorted   #=&gt; ["mon", "tues", "wed", "thurs"]
</pre> <p>To produce the reverse of a specific order, the following can be used:</p> <pre>ary.sort_by { ... }.reverse!</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-sum"> <span class="method-callseq"> sum(init=0) → number </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> sum(init=0) {|e| expr } → number </span> </div> <div class="method-description">
<div class="method-source-code" id="sum-source"> <pre class="c" data-language="c">static VALUE
enum_sum(int argc, VALUE* argv, VALUE obj)
{
    struct enum_sum_memo memo;
    VALUE beg, end;
    int excl;

    memo.v = (rb_check_arity(argc, 0, 1) == 0) ? LONG2FIX(0) : argv[0];
    memo.block_given = rb_block_given_p();
    memo.n = 0;
    memo.r = Qundef;

    if ((memo.float_value = RB_FLOAT_TYPE_P(memo.v))) {
        memo.f = RFLOAT_VALUE(memo.v);
        memo.c = 0.0;
    }
    else {
        memo.f = 0.0;
        memo.c = 0.0;
    }

    if (RTEST(rb_range_values(obj, &amp;beg, &amp;end, &amp;excl))) {
        if (!memo.block_given &amp;&amp; !memo.float_value &amp;&amp;
                (FIXNUM_P(beg) || RB_TYPE_P(beg, T_BIGNUM)) &amp;&amp;
                (FIXNUM_P(end) || RB_TYPE_P(end, T_BIGNUM))) {
            return int_range_sum(beg, end, excl, memo.v);
        }
    }

    if (RB_TYPE_P(obj, T_HASH) &amp;&amp;
            rb_method_basic_definition_p(CLASS_OF(obj), id_each))
        hash_sum(obj, &amp;memo);
    else
        rb_block_call(obj, id_each, 0, 0, enum_sum_i, (VALUE)&amp;memo);

    if (memo.float_value) {
        return DBL2NUM(memo.f + memo.c);
    }
    else {
        if (memo.n != 0)
            memo.v = rb_fix_plus(LONG2FIX(memo.n), memo.v);
        if (memo.r != Qundef) {
            memo.v = rb_rational_plus(memo.r, memo.v);
        }
        return memo.v;
    }
}</pre> </div> <p>Returns the sum of elements in an <a href="enumerable"><code>Enumerable</code></a>.</p> <p>If a block is given, the block is applied to each element before addition.</p> <p>If <em>enum</em> is empty, it returns <em>init</em>.</p> <p>For example:</p> <pre class="ruby" data-language="ruby">{ 1 =&gt; 10, 2 =&gt; 20 }.sum {|k, v| k * v }  #=&gt; 50
(1..10).sum                               #=&gt; 55
(1..10).sum {|v| v * 2 }                  #=&gt; 110
('a'..'z').sum                            #=&gt; TypeError
</pre> <p>This method can be used for non-numeric objects by explicit <em>init</em> argument.</p> <pre class="ruby" data-language="ruby">{ 1 =&gt; 10, 2 =&gt; 20 }.sum([])                   #=&gt; [1, 10, 2, 20]
"a\nb\nc".each_line.lazy.map(&amp;:chomp).sum("")  #=&gt; "abc"
</pre> <p>If the method is applied to an <a href="integer"><code>Integer</code></a> range without a block, the sum is not done by iteration, but instead using Gauss's summation formula.</p> <p><a href="enumerable#method-i-sum"><code>Enumerable#sum</code></a> method may not respect method redefinition of “+” methods such as <a href="integer#method-i-2B"><code>Integer#+</code></a>, or “each” methods such as <a href="range#method-i-each"><code>Range#each</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-take"> <span class="method-callseq"> take(n) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="take-source"> <pre class="c" data-language="c">static VALUE
enum_take(VALUE obj, VALUE n)
{
    struct MEMO *memo;
    VALUE result;
    long len = NUM2LONG(n);

    if (len &lt; 0) {
        rb_raise(rb_eArgError, "attempt to take negative size");
    }

    if (len == 0) return rb_ary_new2(0);
    result = rb_ary_new2(len);
    memo = MEMO_NEW(result, 0, len);
    rb_block_call(obj, id_each, 0, 0, take_i, (VALUE)memo);
    return result;
}</pre> </div> <p>Returns first n elements from <em>enum</em>.</p> <pre class="ruby" data-language="ruby">a = [1, 2, 3, 4, 5, 0]
a.take(3)             #=&gt; [1, 2, 3]
a.take(30)            #=&gt; [1, 2, 3, 4, 5, 0]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-take_while"> <span class="method-callseq"> take_while { |obj| block } → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> take_while → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="take_while-source"> <pre class="c" data-language="c">static VALUE
enum_take_while(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);
    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, take_while_i, ary);
    return ary;
}</pre> </div> <p>Passes elements to the block until the block returns <code>nil</code> or <code>false</code>, then stops iterating and returns an array of all prior elements.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">a = [1, 2, 3, 4, 5, 0]
a.take_while { |i| i &lt; 3 }   #=&gt; [1, 2]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-tally"> <span class="method-callseq"> tally → a_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="tally-source"> <pre class="c" data-language="c">static VALUE
enum_tally(VALUE obj)
{
    return enum_hashify(obj, 0, 0, tally_i);
}</pre> </div> <p>Tallies the collection, i.e., counts the occurrences of each element. Returns a hash with the elements of the collection as keys and the corresponding counts as values.</p> <pre class="ruby" data-language="ruby">["a", "b", "c", "b"].tally  #=&gt; {"a"=&gt;1, "b"=&gt;2, "c"=&gt;1}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_a"> <span class="method-callseq"> to_a(*args) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_a-source"> <pre class="c" data-language="c">static VALUE
enum_to_a(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary = rb_ary_new();

    rb_block_call(obj, id_each, argc, argv, collect_all, ary);

    return ary;
}</pre> </div> <p>Returns an array containing the items in <em>enum</em>.</p> <pre class="ruby" data-language="ruby">(1..7).to_a                       #=&gt; [1, 2, 3, 4, 5, 6, 7]
{ 'a'=&gt;1, 'b'=&gt;2, 'c'=&gt;3 }.to_a   #=&gt; [["a", 1], ["b", 2], ["c", 3]]

require 'prime'
Prime.entries 10                  #=&gt; [2, 3, 5, 7]
</pre>  </div> <div class="aliases"> Also aliased as: <a href="enumerable#method-i-entries">entries</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_h"> <span class="method-callseq"> to_h(*args) → hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> to_h(*args) {...} → hash </span> </div> <div class="method-description">
<div class="method-source-code" id="to_h-source"> <pre class="c" data-language="c">static VALUE
enum_to_h(int argc, VALUE *argv, VALUE obj)
{
    rb_block_call_func *iter = rb_block_given_p() ? enum_to_h_ii : enum_to_h_i;
    return enum_hashify(obj, argc, argv, iter);
}</pre> </div> <p>Returns the result of interpreting <em>enum</em> as a list of <code>[key, value]</code> pairs.</p> <pre class="ruby" data-language="ruby">%i[hello world].each_with_index.to_h
  # =&gt; {:hello =&gt; 0, :world =&gt; 1}
</pre> <p>If a block is given, the results of the block on each element of the enum will be used as pairs.</p> <pre class="ruby" data-language="ruby">(1..5).to_h {|x| [x, x ** 2]}
  #=&gt; {1=&gt;1, 2=&gt;4, 3=&gt;9, 4=&gt;16, 5=&gt;25}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_set"> <span class="method-name">to_set</span><span class="method-args">(klass = Set, *args, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_set-source"> <pre class="ruby" data-language="ruby"># File lib/set.rb, line 687
def to_set(klass = Set, *args, &amp;block)
  klass.new(self, *args, &amp;block)
end</pre> </div> <p>Makes a set from the enumerable object with given arguments. Needs to <code>require "set"</code> to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-uniq"> <span class="method-callseq"> uniq → new_ary </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> uniq { |item| ... } → new_ary </span> </div> <div class="method-description">
<div class="method-source-code" id="uniq-source"> <pre class="c" data-language="c">static VALUE
enum_uniq(VALUE obj)
{
    VALUE hash, ret;
    rb_block_call_func *const func =
        rb_block_given_p() ? uniq_iter : uniq_func;

    hash = rb_obj_hide(rb_hash_new());
    rb_block_call(obj, id_each, 0, 0, func, hash);
    ret = rb_hash_values(hash);
    rb_hash_clear(hash);
    return ret;
}</pre> </div> <p>Returns a new array by removing duplicate values in <code>self</code>.</p> <p>See also <a href="array#method-i-uniq"><code>Array#uniq</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-zip"> <span class="method-callseq"> zip(arg, ...) → an_array_of_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> zip(arg, ...) { |arr| block } → nil </span> </div> <div class="method-description">
<div class="method-source-code" id="zip-source"> <pre class="c" data-language="c">static VALUE
enum_zip(int argc, VALUE *argv, VALUE obj)
{
    int i;
    ID conv;
    struct MEMO *memo;
    VALUE result = Qnil;
    VALUE args = rb_ary_new4(argc, argv);
    int allary = TRUE;

    argv = RARRAY_PTR(args);
    for (i=0; i&lt;argc; i++) {
        VALUE ary = rb_check_array_type(argv[i]);
        if (NIL_P(ary)) {
            allary = FALSE;
            break;
        }
        argv[i] = ary;
    }
    if (!allary) {
        static const VALUE sym_each = STATIC_ID2SYM(id_each);
        CONST_ID(conv, "to_enum");
        for (i=0; i&lt;argc; i++) {
            if (!rb_respond_to(argv[i], id_each)) {
                rb_raise(rb_eTypeError, "wrong argument type %"PRIsVALUE" (must respond to :each)",
                         rb_obj_class(argv[i]));
            }
            argv[i] = rb_funcallv(argv[i], conv, 1, &amp;sym_each);
        }
    }
    if (!rb_block_given_p()) {
        result = rb_ary_new();
    }

    /* TODO: use NODE_DOT2 as memo(v, v, -) */
    memo = MEMO_NEW(result, args, 0);
    rb_block_call(obj, id_each, 0, 0, allary ? zip_ary : zip_i, (VALUE)memo);

    return result;
}</pre> </div> <p>Takes one element from <em>enum</em> and merges corresponding elements from each <em>args</em>. This generates a sequence of <em>n</em>-element arrays, where <em>n</em> is one more than the count of arguments. The length of the resulting sequence will be <code>enum#size</code>. If the size of any argument is less than <code>enum#size</code>, <code>nil</code> values are supplied. If a block is given, it is invoked for each output array, otherwise an array of arrays is returned.</p> <pre class="ruby" data-language="ruby">a = [ 4, 5, 6 ]
b = [ 7, 8, 9 ]

a.zip(b)                 #=&gt; [[4, 7], [5, 8], [6, 9]]
[1, 2, 3].zip(a, b)      #=&gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
[1, 2].zip(a, b)         #=&gt; [[1, 4, 7], [2, 5, 8]]
a.zip([1, 2], [8])       #=&gt; [[4, 1, 8], [5, 2, nil], [6, nil, nil]]

c = []
a.zip(b) { |x, y| c &lt;&lt; x + y }  #=&gt; nil
c                               #=&gt; [11, 13, 15]
</pre>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2020 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
