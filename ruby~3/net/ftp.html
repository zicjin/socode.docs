<h1 id="class-Net::FTP" class="class"> class Net::FTP </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent">Protocol</dd>
<dt>Included modules:</dt>
<dd class="meta-includes">
<a class="include" href="../monitormixin">MonitorMixin</a>, <a class="include" href="../openssl">OpenSSL</a>, <a class="include" href="../openssl/ssl">OpenSSL::SSL</a>
</dd>
</dl> <section class="description"> <p>This class implements the <a href="../file"><code>File</code></a> Transfer Protocol. If you have used a command-line <a href="ftp"><code>FTP</code></a> program, and are familiar with the commands, you will be able to use this class easily. Some extra features are included to take advantage of Ruby's style and strengths.</p> <h2 id="class-Net::FTP-label-Example">Example</h2> <pre class="ruby" data-language="ruby">require 'net/ftp'
</pre> <h3 id="class-Net::FTP-label-Example+1">Example 1</h3> <pre class="ruby" data-language="ruby">ftp = Net::FTP.new('example.com')
ftp.login
files = ftp.chdir('pub/lang/ruby/contrib')
files = ftp.list('n*')
ftp.getbinaryfile('nif.rb-0.91.gz', 'nif.gz', 1024)
ftp.close
</pre> <h3 id="class-Net::FTP-label-Example+2">Example 2</h3> <pre class="ruby" data-language="ruby">Net::FTP.open('example.com') do |ftp|
  ftp.login
  files = ftp.chdir('pub/lang/ruby/contrib')
  files = ftp.list('n*')
  ftp.getbinaryfile('nif.rb-0.91.gz', 'nif.gz', 1024)
end
</pre> <h2 id="class-Net::FTP-label-Major+Methods">Major Methods</h2> <p>The following are the methods most likely to be useful to users:</p> <ul>
<li> <p><a href="ftp#method-c-open"><code>FTP.open</code></a></p> </li>
<li> <p><a href="ftp#method-i-getbinaryfile"><code>getbinaryfile</code></a></p> </li>
<li> <p><a href="ftp#method-i-gettextfile"><code>gettextfile</code></a></p> </li>
<li> <p><a href="ftp#method-i-putbinaryfile"><code>putbinaryfile</code></a></p> </li>
<li> <p><a href="ftp#method-i-puttextfile"><code>puttextfile</code></a></p> </li>
<li> <p><a href="ftp#method-i-chdir"><code>chdir</code></a></p> </li>
<li> <p><a href="ftp#method-i-nlst"><code>nlst</code></a></p> </li>
<li> <p><a href="ftp#method-i-size"><code>size</code></a></p> </li>
<li> <p><a href="ftp#method-i-rename"><code>rename</code></a></p> </li>
<li> <p><a href="ftp#method-i-delete"><code>delete</code></a></p> </li>
</ul> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="CASE_DEPENDENT_PARSER">CASE_DEPENDENT_PARSER </dt>

<dt id="CASE_INDEPENDENT_PARSER">CASE_INDEPENDENT_PARSER </dt>

<dt id="DECIMAL_PARSER">DECIMAL_PARSER </dt>

<dt id="FACT_PARSERS">FACT_PARSERS </dt>

<dt id="OCTAL_PARSER">OCTAL_PARSER </dt>

<dt id="TIME_PARSER">TIME_PARSER </dt>

</dl> </section> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-binary"> <span class="method-name">binary</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>When <code>true</code>, transfers are performed in binary mode. Default: <code>true</code>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-debug_mode"> <span class="method-name">debug_mode</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>When <code>true</code>, all traffic to and from the server is written to +$stdout+. Default: <code>false</code>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-last_response"> <span class="method-name">last_response</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>The server's last response.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-last_response_code"> <span class="method-name">last_response_code</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>The server's last response code.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-lastresp"> <span class="method-name">lastresp</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>The server's last response code.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-open_timeout"> <span class="method-name">open_timeout</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Number of seconds to wait for the connection to open. Any number may be used, including Floats for fractional seconds. If the <a href="ftp"><code>FTP</code></a> object cannot open a connection in this many seconds, it raises a <a href="opentimeout"><code>Net::OpenTimeout</code></a> exception. The default value is <code>nil</code>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-passive"> <span class="method-name">passive</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>When <code>true</code>, the connection is in passive mode. Default: <code>true</code>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-read_timeout"> <span class="method-name">read_timeout</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Number of seconds to wait for one block to be read (via one read(2) call). Any number may be used, including Floats for fractional seconds. If the <a href="ftp"><code>FTP</code></a> object cannot read data in this many seconds, it raises a <a href="../timeout/error"><code>Timeout::Error</code></a> exception. The default value is 60 seconds.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-resume"> <span class="method-name">resume</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or retrieves the <code>resume</code> status, which decides whether incomplete transfers are resumed or restarted. Default: <code>false</code>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-ssl_handshake_timeout"> <span class="method-name">ssl_handshake_timeout</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Number of seconds to wait for the TLS handshake. Any number may be used, including Floats for fractional seconds. If the <a href="ftp"><code>FTP</code></a> object cannot complete the TLS handshake in this many seconds, it raises a <a href="opentimeout"><code>Net::OpenTimeout</code></a> exception. The default value is <code>nil</code>. If <code>ssl_handshake_timeout</code> is <code>nil</code>, <code>open_timeout</code> is used instead.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-welcome"> <span class="method-name">welcome</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>The server's welcome message.</p> </div> </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-default_passive"> <span class="method-name">default_passive</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="default_passive-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 152
def self.default_passive
  @@default_passive
end</pre> </div> <p>When <code>true</code>, connections are in passive mode per default. Default: <code>true</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-default_passive-3D"> <span class="method-name">default_passive=</span><span class="method-args">(value)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="default_passive-3D-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 146
def self.default_passive=(value)
  @@default_passive = value
end</pre> </div> <p>When <code>true</code>, connections are in passive mode per default. Default: <code>true</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> Net::FTP.new(host = nil, options = {}) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 212
def initialize(host = nil, user_or_options = {}, passwd = nil, acct = nil)
  super()
  begin
    options = user_or_options.to_hash
  rescue NoMethodError
    # for backward compatibility
    options = {}
    options[:username] = user_or_options
    options[:password] = passwd
    options[:account] = acct
  end
  @host = nil
  if options[:ssl]
    unless defined?(OpenSSL::SSL)
      raise "SSL extension not installed"
    end
    ssl_params = options[:ssl] == true ? {} : options[:ssl]
    @ssl_context = SSLContext.new
    @ssl_context.set_params(ssl_params)
    if defined?(VerifyCallbackProc)
      @ssl_context.verify_callback = VerifyCallbackProc
    end
    @ssl_context.session_cache_mode =
      OpenSSL::SSL::SSLContext::SESSION_CACHE_CLIENT |
      OpenSSL::SSL::SSLContext::SESSION_CACHE_NO_INTERNAL_STORE
    @ssl_context.session_new_cb = proc {|sock, sess| @ssl_session = sess }
    @ssl_session = nil
    if options[:private_data_connection].nil?
      @private_data_connection = true
    else
      @private_data_connection = options[:private_data_connection]
    end
  else
    @ssl_context = nil
    if options[:private_data_connection]
      raise ArgumentError,
        "private_data_connection can be set to true only when ssl is enabled"
    end
    @private_data_connection = false
  end
  @binary = true
  if options[:passive].nil?
    @passive = @@default_passive
  else
    @passive = options[:passive]
  end
  if options[:debug_mode].nil?
    @debug_mode = false
  else
    @debug_mode = options[:debug_mode]
  end
  @resume = false
  @bare_sock = @sock = NullSocket.new
  @logged_in = false
  @open_timeout = options[:open_timeout]
  @ssl_handshake_timeout = options[:ssl_handshake_timeout]
  @read_timeout = options[:read_timeout] || 60
  if host
    connect(host, options[:port] || FTP_PORT)
    if options[:username]
      login(options[:username], options[:password], options[:account])
    end
  end
end</pre> </div> <p>Creates and returns a new <code>FTP</code> object. If a <code>host</code> is given, a connection is made.</p> <p><code>options</code> is an option hash, each key of which is a symbol.</p> <p>The available options are:</p> <dl class="rdoc-list note-list">
<dt>port </dt>
<dd> <p>Port number (default value is 21)</p> </dd>
<dt>ssl </dt>
<dd> <p>If <code>options[:ssl]</code> is true, then an attempt will be made to use SSL (now TLS) to connect to the server. For this to work <a href="../openssl"><code>OpenSSL</code></a> [OSSL] and the Ruby <a href="../openssl"><code>OpenSSL</code></a> [RSSL] extensions need to be installed. If <code>options[:ssl]</code> is a hash, it's passed to <a href="../openssl/ssl/sslcontext#method-i-set_params"><code>OpenSSL::SSL::SSLContext#set_params</code></a> as parameters.</p> </dd>
<dt>private_data_connection </dt>
<dd> <p>If true, TLS is used for data connections. Default: <code>true</code> when <code>options[:ssl]</code> is true.</p> </dd>
<dt>username </dt>
<dd> <p>Username for login. If <code>options[:username]</code> is the string “anonymous” and the <code>options[:password]</code> is <code>nil</code>, “anonymous@” is used as a password.</p> </dd>
<dt>password </dt>
<dd> <p>Password for login.</p> </dd>
<dt>account </dt>
<dd> <p>Account information for ACCT.</p> </dd>
<dt>passive </dt>
<dd> <p>When <code>true</code>, the connection is in passive mode. Default: <code>true</code>.</p> </dd>
<dt>
<a href="ftp#attribute-i-open_timeout"><code>open_timeout</code></a> </dt>
<dd> <p>Number of seconds to wait for the connection to open. See <a href="ftp#attribute-i-open_timeout"><code>Net::FTP#open_timeout</code></a> for details. Default: <code>nil</code>.</p> </dd>
<dt>
<a href="ftp#attribute-i-read_timeout"><code>read_timeout</code></a> </dt>
<dd> <p>Number of seconds to wait for one block to be read. See <a href="ftp#attribute-i-read_timeout"><code>Net::FTP#read_timeout</code></a> for details. Default: <code>60</code>.</p> </dd>
<dt>
<a href="ftp#attribute-i-ssl_handshake_timeout"><code>ssl_handshake_timeout</code></a> </dt>
<dd> <p>Number of seconds to wait for the TLS handshake. See <a href="ftp#attribute-i-ssl_handshake_timeout"><code>Net::FTP#ssl_handshake_timeout</code></a> for details. Default: <code>nil</code>.</p> </dd>
<dt>
<a href="ftp#attribute-i-debug_mode"><code>debug_mode</code></a> </dt>
<dd> <p>When <code>true</code>, all traffic to and from the server is written to +$stdout+. Default: <code>false</code>.</p> </dd>
</dl> <div class="method-calls-super"> Calls superclass method <a href="../monitormixin#method-c-new"><code>MonitorMixin::new</code></a> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-open"> <span class="method-name">open</span><span class="method-args">(host, *args) { |ftp| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="open-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 162
def FTP.open(host, *args)
  if block_given?
    ftp = new(host, *args)
    begin
      yield ftp
    ensure
      ftp.close
    end
  else
    new(host, *args)
  end
end</pre> </div> <p>A synonym for <code>FTP.new</code>, but with a mandatory host parameter.</p> <p>If a block is given, it is passed the <code>FTP</code> object, which will be closed when the block finishes, or when an exception is raised.</p>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-abort"> <span class="method-name">abort</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="abort-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1231
def abort
  line = "ABOR" + CRLF
  print "put: ABOR\n" if @debug_mode
  @sock.send(line, Socket::MSG_OOB)
  resp = getmultiline
  unless ["426", "226", "225"].include?(resp[0, 3])
    raise FTPProtoError, resp
  end
  return resp
end</pre> </div> <p>Aborts the previous command (ABOR command).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-acct"> <span class="method-name">acct</span><span class="method-args">(account)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="acct-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 884
def acct(account)
  cmd = "ACCT " + account
  voidcmd(cmd)
end</pre> </div> <p>Sends the ACCT command.</p> <p>This is a less common <a href="ftp"><code>FTP</code></a> command, to send account information if the destination host requires it.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-binary-3D"> <span class="method-name">binary=</span><span class="method-args">(newmode)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="binary-3D-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 279
def binary=(newmode)
  if newmode != @binary
    @binary = newmode
    send_type_command if @logged_in
  end
end</pre> </div> <p>A setter to toggle transfers in binary mode. <code>newmode</code> is either <code>true</code> or <code>false</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-chdir"> <span class="method-name">chdir</span><span class="method-args">(dirname)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="chdir-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1152
def chdir(dirname)
  if dirname == ".."
    begin
      voidcmd("CDUP")
      return
    rescue FTPPermError =&gt; e
      if e.message[0, 3] != "500"
        raise e
      end
    end
  end
  cmd = "CWD #{dirname}"
  voidcmd(cmd)
end</pre> </div> <p>Changes the (remote) directory.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-close"> <span class="method-name">close</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="close-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1345
def close
  if @sock and not @sock.closed?
    begin
      @sock.shutdown(Socket::SHUT_WR) rescue nil
      orig, self.read_timeout = self.read_timeout, 3
      @sock.read rescue nil
    ensure
      @sock.close
      self.read_timeout = orig
    end
  end
end</pre> </div> <p>Closes the connection. Further operations are impossible until you open a new connection with <a href="ftp#method-i-connect"><code>connect</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-closed-3F"> <span class="method-name">closed?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="closed-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1361
def closed?
  @sock == nil or @sock.closed?
end</pre> </div> <p>Returns <code>true</code> iff the connection is closed.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-connect"> <span class="method-name">connect</span><span class="method-args">(host, port = FTP_PORT)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="connect-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 367
def connect(host, port = FTP_PORT)
  if @debug_mode
    print "connect: ", host, ", ", port, "\n"
  end
  synchronize do
    @host = host
    @bare_sock = open_socket(host, port)
    @sock = BufferedSocket.new(@bare_sock, read_timeout: @read_timeout)
    voidresp
    if @ssl_context
      begin
        voidcmd("AUTH TLS")
        ssl_sock = start_tls_session(@bare_sock)
        @sock = BufferedSSLSocket.new(ssl_sock, read_timeout: @read_timeout)
        if @private_data_connection
          voidcmd("PBSZ 0")
          voidcmd("PROT P")
        end
      rescue OpenSSL::SSL::SSLError, OpenTimeout
        @sock.close
        raise
      end
    end
  end
end</pre> </div> <p>Establishes an <a href="ftp"><code>FTP</code></a> connection to host, optionally overriding the default port. If the environment variable <code>SOCKS_SERVER</code> is set, sets up the connection through a SOCKS proxy. Raises an exception (typically <code>Errno::ECONNREFUSED</code>) if the connection cannot be established.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-delete"> <span class="method-name">delete</span><span class="method-args">(filename)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="delete-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1138
def delete(filename)
  resp = sendcmd("DELE #{filename}")
  if resp.start_with?("250")
    return
  elsif resp.start_with?("5")
    raise FTPPermError, resp
  else
    raise FTPReplyError, resp
  end
end</pre> </div> <p>Deletes a file on the server.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-dir"> <span class="method-name">dir</span><span class="method-args">(*args)</span> </div>  <div class="aliases"> Alias for: <a href="ftp#method-i-list">list</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-features"> <span class="method-name">features</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="features-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1311
def features
  resp = sendcmd("FEAT")
  if !resp.start_with?("211")
    raise FTPReplyError, resp
  end

  feats = []
  resp.split("\n").each do |line|
    next if !line.start_with?(' ') # skip status lines

    feats &lt;&lt; line.strip
  end

  return feats
end</pre> </div> <p>Issues a FEAT command</p> <p>Returns an array of supported optional features</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-get"> <span class="method-name">get</span><span class="method-args">(remotefile, localfile = File.basename(remotefile), blocksize = DEFAULT_BLOCKSIZE) { |data| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="get-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 813
def get(remotefile, localfile = File.basename(remotefile),
        blocksize = DEFAULT_BLOCKSIZE, &amp;block) # :yield: data
  if @binary
    getbinaryfile(remotefile, localfile, blocksize, &amp;block)
  else
    gettextfile(remotefile, localfile, &amp;block)
  end
end</pre> </div> <p>Retrieves <code>remotefile</code> in whatever mode the session is set (text or binary). See <a href="ftp#method-i-gettextfile"><code>gettextfile</code></a> and <a href="ftp#method-i-getbinaryfile"><code>getbinaryfile</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-getbinaryfile"> <span class="method-name">getbinaryfile</span><span class="method-args">(remotefile, localfile = File.basename(remotefile), blocksize = DEFAULT_BLOCKSIZE) { |data| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="getbinaryfile-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 752
def getbinaryfile(remotefile, localfile = File.basename(remotefile),
                  blocksize = DEFAULT_BLOCKSIZE, &amp;block) # :yield: data
  f = nil
  result = nil
  if localfile
    if @resume
      rest_offset = File.size?(localfile)
      f = File.open(localfile, "a")
    else
      rest_offset = nil
      f = File.open(localfile, "w")
    end
  elsif !block_given?
    result = String.new
  end
  begin
    f&amp;.binmode
    retrbinary("RETR #{remotefile}", blocksize, rest_offset) do |data|
      f&amp;.write(data)
      block&amp;.(data)
      result&amp;.concat(data)
    end
    return result
  ensure
    f&amp;.close
  end
end</pre> </div> <p>Retrieves <code>remotefile</code> in binary mode, storing the result in <code>localfile</code>. If <code>localfile</code> is nil, returns retrieved data. If a block is supplied, it is passed the retrieved data in <code>blocksize</code> chunks.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-getdir"> <span class="method-name">getdir</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="ftp#method-i-pwd">pwd</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-gettextfile"> <span class="method-name">gettextfile</span><span class="method-args">(remotefile, localfile = File.basename(remotefile)) { |line| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="gettextfile-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 787
def gettextfile(remotefile, localfile = File.basename(remotefile),
                &amp;block) # :yield: line
  f = nil
  result = nil
  if localfile
    f = File.open(localfile, "w")
  elsif !block_given?
    result = String.new
  end
  begin
    retrlines("RETR #{remotefile}") do |line, newline|
      l = newline ? line + "\n" : line
      f&amp;.print(l)
      block&amp;.(line, newline)
      result&amp;.concat(l)
    end
    return result
  ensure
    f&amp;.close
  end
end</pre> </div> <p>Retrieves <code>remotefile</code> in ASCII (text) mode, storing the result in <code>localfile</code>. If <code>localfile</code> is nil, returns retrieved data. If a block is supplied, it is passed the retrieved data one line at a time.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-help"> <span class="method-name">help</span><span class="method-args">(arg = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="help-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1274
def help(arg = nil)
  cmd = "HELP"
  if arg
    cmd = cmd + " " + arg
  end
  sendcmd(cmd)
end</pre> </div> <p>Issues the HELP command.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-list"> <span class="method-name">list</span><span class="method-args">(*args) { |line| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="list-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 908
def list(*args, &amp;block) # :yield: line
  cmd = "LIST"
  args.each do |arg|
    cmd = "#{cmd} #{arg}"
  end
  lines = []
  retrlines(cmd) do |line|
    lines &lt;&lt; line
  end
  if block
    lines.each(&amp;block)
  end
  return lines
end</pre> </div> <p>Returns an array of file information in the directory (the output is like `ls -l`). If a block is given, it iterates through the listing.</p>  </div> <div class="aliases"> Also aliased as: <a href="ftp#method-i-ls">ls</a>, <a href="ftp#method-i-dir">dir</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-login"> <span class="method-name">login</span><span class="method-args">(user = "anonymous", passwd = nil, acct = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="login-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 599
def login(user = "anonymous", passwd = nil, acct = nil)
  if user == "anonymous" and passwd == nil
    passwd = "anonymous@"
  end

  resp = ""
  synchronize do
    resp = sendcmd('USER ' + user)
    if resp.start_with?("3")
      raise FTPReplyError, resp if passwd.nil?
      resp = sendcmd('PASS ' + passwd)
    end
    if resp.start_with?("3")
      raise FTPReplyError, resp if acct.nil?
      resp = sendcmd('ACCT ' + acct)
    end
  end
  if !resp.start_with?("2")
    raise FTPReplyError, resp
  end
  @welcome = resp
  send_type_command
  @logged_in = true
end</pre> </div> <p>Logs in to the remote host. The session must have been previously connected. If <code>user</code> is the string “anonymous” and the <code>password</code> is <code>nil</code>, “anonymous@” is used as a password. If the <code>acct</code> parameter is not <code>nil</code>, an <a href="ftp"><code>FTP</code></a> ACCT command is sent following the successful login. Raises an exception on error (typically <code>Net::FTPPermError</code>).</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-ls"> <span class="method-name">ls</span><span class="method-args">(*args)</span> </div>  <div class="aliases"> Alias for: <a href="ftp#method-i-list">list</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-mdtm"> <span class="method-name">mdtm</span><span class="method-args">(filename)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="mdtm-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1264
def mdtm(filename)
  resp = sendcmd("MDTM #{filename}")
  if resp.start_with?("213")
    return get_body(resp)
  end
end</pre> </div> <p>Returns the raw last modification time of the (remote) file in the format “YYYYMMDDhhmmss” (MDTM command).</p> <p>Use <code>mtime</code> if you want a parsed <a href="../time"><code>Time</code></a> instance.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-mkdir"> <span class="method-name">mkdir</span><span class="method-args">(dirname)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="mkdir-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1196
def mkdir(dirname)
  resp = sendcmd("MKD #{dirname}")
  return parse257(resp)
end</pre> </div> <p>Creates a remote directory.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-mlsd"> <span class="method-name">mlsd</span><span class="method-args">(pathname = nil) { |entry| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="mlsd-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1112
def mlsd(pathname = nil, &amp;block) # :yield: entry
  cmd = pathname ? "MLSD #{pathname}" : "MLSD"
  entries = []
  retrlines(cmd) do |line|
    entries &lt;&lt; parse_mlsx_entry(line)
  end
  if block
    entries.each(&amp;block)
  end
  return entries
end</pre> </div> <p>Returns an array of the entries of the directory specified by <code>pathname</code>. Each entry has the facts (e.g., size, last modification time, etc.) and the pathname. If a block is given, it iterates through the listing. If <code>pathname</code> is omitted, the current directory is assumed.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-mlst"> <span class="method-name">mlst</span><span class="method-args">(pathname = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="mlst-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1090
def mlst(pathname = nil)
  cmd = pathname ? "MLST #{pathname}" : "MLST"
  resp = sendcmd(cmd)
  if !resp.start_with?("250")
    raise FTPReplyError, resp
  end
  line = resp.lines[1]
  unless line
    raise FTPProtoError, resp
  end
  entry = line.sub(/\A(250-| *)/, "")
  return parse_mlsx_entry(entry)
end</pre> </div> <p>Returns data (e.g., size, last modification time, entry type, etc.) about the file or directory specified by <code>pathname</code>. If <code>pathname</code> is omitted, the current directory is assumed.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-mtime"> <span class="method-name">mtime</span><span class="method-args">(filename, local = false)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="mtime-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1189
def mtime(filename, local = false)
  return TIME_PARSER.(mdtm(filename), local)
end</pre> </div> <p>Returns the last modification time of the (remote) file. If <code>local</code> is <code>true</code>, it is returned as a local time, otherwise it's a UTC time.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-nlst"> <span class="method-name">nlst</span><span class="method-args">(dir = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="nlst-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 892
def nlst(dir = nil)
  cmd = "NLST"
  if dir
    cmd = "#{cmd} #{dir}"
  end
  files = []
  retrlines(cmd) do |line|
    files.push(line)
  end
  return files
end</pre> </div> <p>Returns an array of filenames in the remote directory.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-noop"> <span class="method-name">noop</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="noop-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1294
def noop
  voidcmd("NOOP")
end</pre> </div> <p>Issues a NOOP command.</p> <p>Does nothing except return a response.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-option"> <span class="method-name">option</span><span class="method-args">(name, params = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="option-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1334
def option(name, params = nil)
  cmd = "OPTS #{name}"
  cmd += " #{params}" if params

  voidcmd(cmd)
end</pre> </div> <p>Issues an OPTS command</p> <ul>
<li> <p>name Should be the name of the option to set</p> </li>
<li> <p>params is any optional parameters to supply with the option</p> </li>
</ul> <p>example: option('UTF8', 'ON') =&gt; 'OPTS UTF8 ON'</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-put"> <span class="method-name">put</span><span class="method-args">(localfile, remotefile = File.basename(localfile), blocksize = DEFAULT_BLOCKSIZE, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="put-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 869
def put(localfile, remotefile = File.basename(localfile),
        blocksize = DEFAULT_BLOCKSIZE, &amp;block)
  if @binary
    putbinaryfile(localfile, remotefile, blocksize, &amp;block)
  else
    puttextfile(localfile, remotefile, &amp;block)
  end
end</pre> </div> <p>Transfers <code>localfile</code> to the server in whatever mode the session is set (text or binary). See <a href="ftp#method-i-puttextfile"><code>puttextfile</code></a> and <a href="ftp#method-i-putbinaryfile"><code>putbinaryfile</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-putbinaryfile"> <span class="method-name">putbinaryfile</span><span class="method-args">(localfile, remotefile = File.basename(localfile), blocksize = DEFAULT_BLOCKSIZE) { |data| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="putbinaryfile-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 827
def putbinaryfile(localfile, remotefile = File.basename(localfile),
                  blocksize = DEFAULT_BLOCKSIZE, &amp;block) # :yield: data
  if @resume
    begin
      rest_offset = size(remotefile)
    rescue Net::FTPPermError
      rest_offset = nil
    end
  else
    rest_offset = nil
  end
  f = File.open(localfile)
  begin
    f.binmode
    if rest_offset
      storbinary("APPE #{remotefile}", f, blocksize, rest_offset, &amp;block)
    else
      storbinary("STOR #{remotefile}", f, blocksize, rest_offset, &amp;block)
    end
  ensure
    f.close
  end
end</pre> </div> <p>Transfers <code>localfile</code> to the server in binary mode, storing the result in <code>remotefile</code>. If a block is supplied, calls it, passing in the transmitted data in <code>blocksize</code> chunks.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-puttextfile"> <span class="method-name">puttextfile</span><span class="method-args">(localfile, remotefile = File.basename(localfile)) { |line| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="puttextfile-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 856
def puttextfile(localfile, remotefile = File.basename(localfile), &amp;block) # :yield: line
  f = File.open(localfile)
  begin
    storlines("STOR #{remotefile}", f, &amp;block)
  ensure
    f.close
  end
end</pre> </div> <p>Transfers <code>localfile</code> to the server in ASCII (text) mode, storing the result in <code>remotefile</code>. If callback or an associated block is supplied, calls it, passing in the transmitted data one line at a time.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pwd"> <span class="method-name">pwd</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pwd-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1211
def pwd
  resp = sendcmd("PWD")
  return parse257(resp)
end</pre> </div> <p>Returns the current remote directory.</p>  </div> <div class="aliases"> Also aliased as: <a href="ftp#method-i-getdir">getdir</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-quit"> <span class="method-name">quit</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="quit-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1285
def quit
  voidcmd("QUIT")
end</pre> </div> <p>Exits the <a href="ftp"><code>FTP</code></a> session.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-read_timeout-3D"> <span class="method-name">read_timeout=</span><span class="method-args">(sec)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="read_timeout-3D-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 129
def read_timeout=(sec)
  @sock.read_timeout = sec
  @read_timeout = sec
end</pre> </div> <p>Setter for the <a href="ftp#attribute-i-read_timeout"><code>read_timeout</code></a> attribute.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rename"> <span class="method-name">rename</span><span class="method-args">(fromname, toname)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rename-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1127
def rename(fromname, toname)
  resp = sendcmd("RNFR #{fromname}")
  if !resp.start_with?("3")
    raise FTPReplyError, resp
  end
  voidcmd("RNTO #{toname}")
end</pre> </div> <p>Renames a file on the server.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-retrbinary"> <span class="method-name">retrbinary</span><span class="method-args">(cmd, blocksize, rest_offset = nil) { |data| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="retrbinary-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 630
def retrbinary(cmd, blocksize, rest_offset = nil) # :yield: data
  synchronize do
    with_binary(true) do
      begin
        conn = transfercmd(cmd, rest_offset)
        while data = conn.read(blocksize)
          yield(data)
        end
        conn.shutdown(Socket::SHUT_WR) rescue nil
        conn.read_timeout = 1
        conn.read rescue nil
      ensure
        conn.close if conn
      end
      voidresp
    end
  end
end</pre> </div> <p>Puts the connection into binary (image) mode, issues the given command, and fetches the data returned, passing it to the associated block in chunks of <code>blocksize</code> characters. Note that <code>cmd</code> is a server command (such as “RETR myfile”).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-retrlines"> <span class="method-name">retrlines</span><span class="method-args">(cmd) { |line| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="retrlines-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 655
def retrlines(cmd) # :yield: line
  synchronize do
    with_binary(false) do
      begin
        conn = transfercmd(cmd)
        while line = conn.gets
          yield(line.sub(/\r?\n\z/, ""), !line.match(/\n\z/).nil?)
        end
        conn.shutdown(Socket::SHUT_WR) rescue nil
        conn.read_timeout = 1
        conn.read rescue nil
      ensure
        conn.close if conn
      end
      voidresp
    end
  end
end</pre> </div> <p>Puts the connection into ASCII (text) mode, issues the given command, and passes the resulting data, one line at a time, to the associated block. If no block is given, prints the lines. Note that <code>cmd</code> is a server command (such as “RETR myfile”).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rmdir"> <span class="method-name">rmdir</span><span class="method-args">(dirname)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rmdir-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1204
def rmdir(dirname)
  voidcmd("RMD #{dirname}")
end</pre> </div> <p>Removes a remote directory.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-sendcmd"> <span class="method-name">sendcmd</span><span class="method-args">(cmd)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="sendcmd-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 492
def sendcmd(cmd)
  synchronize do
    putline(cmd)
    return getresp
  end
end</pre> </div> <p>Sends a command and returns the response.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-set_socket"> <span class="method-name">set_socket</span><span class="method-args">(sock, get_greeting = true)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="set_socket-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 397
def set_socket(sock, get_greeting = true)
  synchronize do
    @sock = sock
    if get_greeting
      voidresp
    end
  end
end</pre> </div> <p><a href="../set"><code>Set</code></a> the socket used to connect to the <a href="ftp"><code>FTP</code></a> server.</p> <p>May raise FTPReplyError if <code>get_greeting</code> is false.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-site"> <span class="method-name">site</span><span class="method-args">(arg)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="site-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1301
def site(arg)
  cmd = "SITE " + arg
  voidcmd(cmd)
end</pre> </div> <p>Issues a SITE command.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-size"> <span class="method-name">size</span><span class="method-args">(filename)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="size-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1175
def size(filename)
  with_binary(true) do
    resp = sendcmd("SIZE #{filename}")
    if !resp.start_with?("213")
      raise FTPReplyError, resp
    end
    return get_body(resp).to_i
  end
end</pre> </div> <p>Returns the size of the given (remote) filename.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-status"> <span class="method-name">status</span><span class="method-args">(pathname = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="status-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1248
def status(pathname = nil)
  line = pathname ? "STAT #{pathname}" : "STAT"
  if /[\r\n]/ =~ line
    raise ArgumentError, "A line must not contain CR or LF"
  end
  print "put: #{line}\n" if @debug_mode
  @sock.send(line + CRLF, Socket::MSG_OOB)
  return getresp
end</pre> </div> <p>Returns the status (STAT command).</p> <dl class="rdoc-list note-list">
<dt>pathname </dt>
<dd> <p>when stat is invoked with pathname as a parameter it acts like list but a lot faster and over the same tcp session.</p> </dd>
</dl>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-storbinary"> <span class="method-name">storbinary</span><span class="method-args">(cmd, file, blocksize, rest_offset = nil) { |data| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="storbinary-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 680
def storbinary(cmd, file, blocksize, rest_offset = nil) # :yield: data
  if rest_offset
    file.seek(rest_offset, IO::SEEK_SET)
  end
  synchronize do
    with_binary(true) do
      begin
        conn = transfercmd(cmd)
        while buf = file.read(blocksize)
          conn.write(buf)
          yield(buf) if block_given?
        end
        conn.shutdown(Socket::SHUT_WR) rescue nil
        conn.read_timeout = 1
        conn.read rescue nil
      ensure
        conn.close if conn
      end
      voidresp
    end
  end
rescue Errno::EPIPE
  # EPIPE, in this case, means that the data connection was unexpectedly
  # terminated.  Rather than just raising EPIPE to the caller, check the
  # response on the control connection.  If getresp doesn't raise a more
  # appropriate exception, re-raise the original exception.
  getresp
  raise
end</pre> </div> <p>Puts the connection into binary (image) mode, issues the given server-side command (such as “STOR myfile”), and sends the contents of the file named <code>file</code> to the server. If the optional block is given, it also passes it the data, in chunks of <code>blocksize</code> characters.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-storlines"> <span class="method-name">storlines</span><span class="method-args">(cmd, file) { |line| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="storlines-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 716
def storlines(cmd, file) # :yield: line
  synchronize do
    with_binary(false) do
      begin
        conn = transfercmd(cmd)
        while buf = file.gets
          if buf[-2, 2] != CRLF
            buf = buf.chomp + CRLF
          end
          conn.write(buf)
          yield(buf) if block_given?
        end
        conn.shutdown(Socket::SHUT_WR) rescue nil
        conn.read_timeout = 1
        conn.read rescue nil
      ensure
        conn.close if conn
      end
      voidresp
    end
  end
rescue Errno::EPIPE
  # EPIPE, in this case, means that the data connection was unexpectedly
  # terminated.  Rather than just raising EPIPE to the caller, check the
  # response on the control connection.  If getresp doesn't raise a more
  # appropriate exception, re-raise the original exception.
  getresp
  raise
end</pre> </div> <p>Puts the connection into ASCII (text) mode, issues the given server-side command (such as “STOR myfile”), and sends the contents of the file named <code>file</code> to the server, one line at a time. If the optional block is given, it also passes it the lines.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-system"> <span class="method-name">system</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="system-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1220
def system
  resp = sendcmd("SYST")
  if !resp.start_with?("215")
    raise FTPReplyError, resp
  end
  return get_body(resp)
end</pre> </div> <p>Returns system information.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-voidcmd"> <span class="method-name">voidcmd</span><span class="method-args">(cmd)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="voidcmd-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 502
def voidcmd(cmd)
  synchronize do
    putline(cmd)
    voidresp
  end
end</pre> </div> <p>Sends a command and expect a response beginning with '2'.</p>  </div> </div> </section> <section id="private-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Private Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-parse_mlsx_entry"> <span class="method-name">parse_mlsx_entry</span><span class="method-args">(entry)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="parse_mlsx_entry-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1070
def parse_mlsx_entry(entry)
  facts, pathname = entry.chomp.split(/ /, 2)
  unless pathname
    raise FTPProtoError, entry
  end
  return MLSxEntry.new(
    facts.scan(/(.*?)=(.*?);/).each_with_object({}) {
      |(factname, value), h|
      name = factname.downcase
      h[name] = FACT_PARSERS[name].(value)
    },
    pathname)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-parse_pasv_ipv4_host"> <span class="method-name">parse_pasv_ipv4_host</span><span class="method-args">(s)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="parse_pasv_ipv4_host-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1399
def parse_pasv_ipv4_host(s)
  return s.tr(",", ".")
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-parse_pasv_ipv6_host"> <span class="method-name">parse_pasv_ipv6_host</span><span class="method-args">(s)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="parse_pasv_ipv6_host-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1404
def parse_pasv_ipv6_host(s)
  return s.split(/,/).map { |i|
    "%02x" % i.to_i
  }.each_slice(2).map(&amp;:join).join(":")
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-parse_pasv_port"> <span class="method-name">parse_pasv_port</span><span class="method-args">(s)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="parse_pasv_port-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 1411
def parse_pasv_port(s)
  return s.split(/,/).map(&amp;:to_i).inject { |x, y|
    (x &lt;&lt; 8) + y
  }
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-start_tls_session"> <span class="method-name">start_tls_session</span><span class="method-args">(sock)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="start_tls_session-source"> <pre class="ruby" data-language="ruby"># File lib/net/ftp.rb, line 344
def start_tls_session(sock)
  ssl_sock = SSLSocket.new(sock, @ssl_context)
  ssl_sock.sync_close = true
  ssl_sock.hostname = @host if ssl_sock.respond_to? :hostname=
  if @ssl_session &amp;&amp;
      Process.clock_gettime(Process::CLOCK_REALTIME) &lt; @ssl_session.time.to_f + @ssl_session.timeout
    # ProFTPD returns 425 for data connections if session is not reused.
    ssl_sock.session = @ssl_session
  end
  ssl_socket_connect(ssl_sock, @ssl_handshake_timeout || @open_timeout)
  if @ssl_context.verify_mode != VERIFY_NONE
    ssl_sock.post_connection_check(@host)
  end
  return ssl_sock
end</pre> </div>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2020 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
