<h1 id="class-Net::SMTP" class="class"> class Net::SMTP </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent">Net::Protocol</dd>
</dl> <section class="description"> <h2 id="class-Net::SMTP-label-What+is+This+Library-3F">What is This Library?</h2> <p>This library provides functionality to send internet mail via <a href="smtp"><code>SMTP</code></a>, the Simple Mail Transfer Protocol. For details of <a href="smtp"><code>SMTP</code></a> itself, see [RFC2821] (<a href="http://www.ietf.org/rfc/rfc2821.txt">www.ietf.org/rfc/rfc2821.txt</a>).</p> <h2 id="class-Net::SMTP-label-What+is+This+Library+NOT-3F">What is This Library NOT?</h2> <p>This library does NOT provide functions to compose internet mails. You must create them by yourself. If you want better mail support, try RubyMail or TMail or search for alternatives in <a href="https://rubygems.org/">RubyGems.org</a> or <a href="https://www.ruby-toolbox.com/">The Ruby Toolbox</a>.</p> <p>FYI: the official documentation on internet mail is: [RFC2822] (<a href="http://www.ietf.org/rfc/rfc2822.txt">www.ietf.org/rfc/rfc2822.txt</a>).</p> <h2 id="class-Net::SMTP-label-Examples">Examples</h2> <h3 id="class-Net::SMTP-label-Sending+Messages">Sending Messages</h3> <p>You must open a connection to an <a href="smtp"><code>SMTP</code></a> server before sending messages. The first argument is the address of your <a href="smtp"><code>SMTP</code></a> server, and the second argument is the port number. Using <a href="smtp#method-c-start"><code>SMTP.start</code></a> with a block is the simplest way to do this. This way, the <a href="smtp"><code>SMTP</code></a> connection is closed automatically after the block is executed.</p> <pre class="ruby" data-language="ruby">require 'net/smtp'
Net::SMTP.start('your.smtp.server', 25) do |smtp|
  # Use the SMTP object smtp only in this block.
end
</pre> <p>Replace 'your.smtp.server' with your <a href="smtp"><code>SMTP</code></a> server. Normally your system manager or internet provider supplies a server for you.</p> <p>Then you can send messages.</p> <pre class="ruby" data-language="ruby">msgstr = &lt;&lt;END_OF_MESSAGE
From: Your Name &lt;your@mail.address&gt;
To: Destination Address &lt;someone@example.com&gt;
Subject: test message
Date: Sat, 23 Jun 2001 16:26:43 +0900
Message-Id: &lt;unique.message.id.string@example.com&gt;

This is a test message.
END_OF_MESSAGE

require 'net/smtp'
Net::SMTP.start('your.smtp.server', 25) do |smtp|
  smtp.send_message msgstr,
                    'your@mail.address',
                    'his_address@example.com'
end
</pre> <h3 id="class-Net::SMTP-label-Closing+the+Session">Closing the Session</h3> <p>You MUST close the <a href="smtp"><code>SMTP</code></a> session after sending messages, by calling the <a href="smtp#method-i-finish"><code>finish</code></a> method:</p> <pre class="ruby" data-language="ruby"># using SMTP#finish
smtp = Net::SMTP.start('your.smtp.server', 25)
smtp.send_message msgstr, 'from@address', 'to@address'
smtp.finish
</pre> <p>You can also use the block form of <a href="smtp#method-c-start"><code>SMTP.start</code></a>/SMTP#start. This closes the <a href="smtp"><code>SMTP</code></a> session automatically:</p> <pre class="ruby" data-language="ruby"># using block form of SMTP.start
Net::SMTP.start('your.smtp.server', 25) do |smtp|
  smtp.send_message msgstr, 'from@address', 'to@address'
end
</pre> <p>I strongly recommend this scheme. This form is simpler and more robust.</p> <h3 id="class-Net::SMTP-label-HELO+domain">HELO domain</h3> <p>In almost all situations, you must provide a third argument to <a href="smtp#method-c-start"><code>SMTP.start</code></a>/SMTP#start. This is the domain name which you are on (the host to send mail from). It is called the “HELO domain”. The <a href="smtp"><code>SMTP</code></a> server will judge whether it should send or reject the <a href="smtp"><code>SMTP</code></a> session by inspecting the HELO domain.</p> <pre>Net::SMTP.start('your.smtp.server', 25
                helo: 'mail.from.domain') { |smtp| ... }</pre> <h3 id="class-Net::SMTP-label-SMTP+Authentication">
<a href="smtp"><code>SMTP</code></a> Authentication</h3> <p>The <a href="smtp"><code>Net::SMTP</code></a> class supports three authentication schemes; PLAIN, LOGIN and CRAM MD5. (<a href="smtp"><code>SMTP</code></a> Authentication: [RFC2554]) To use <a href="smtp"><code>SMTP</code></a> authentication, pass extra arguments to <a href="smtp#method-c-start"><code>SMTP.start</code></a>/SMTP#start.</p> <pre># PLAIN
Net::SMTP.start('your.smtp.server', 25
                user: 'Your Account', secret: 'Your Password', authtype: :plain)
# LOGIN
Net::SMTP.start('your.smtp.server', 25
                user: 'Your Account', secret: 'Your Password', authtype: :login)

# CRAM MD5
Net::SMTP.start('your.smtp.server', 25
                user: 'Your Account', secret: 'Your Password', authtype: :cram_md5)</pre> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="CRAM_BUFSIZE">CRAM_BUFSIZE </dt>

<dt id="DEFAULT_AUTH_TYPE">DEFAULT_AUTH_TYPE </dt>
<dd>
<p>Authentication</p> </dd>
<dt id="IMASK">IMASK </dt>

<dt id="OMASK">OMASK </dt>

<dt id="Revision">Revision </dt>

<dt id="VERSION">VERSION </dt>

</dl> </section> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-address"> <span class="method-name">address</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>The address of the <a href="smtp"><code>SMTP</code></a> server to connect to.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-esmtp"> <span class="method-name">esmtp</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p><a href="../set"><code>Set</code></a> whether to use ESMTP or not. This should be done before calling <a href="smtp#method-i-start"><code>start</code></a>. Note that if <a href="smtp#method-i-start"><code>start</code></a> is called in ESMTP mode, and the connection fails due to a <span><code>ProtocolError</code></span>, the <a href="smtp"><code>SMTP</code></a> object will automatically switch to plain <a href="smtp"><code>SMTP</code></a> mode and retry (but not vice versa).</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-esmtp-3F"> <span class="method-name">esmtp?</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p><a href="../set"><code>Set</code></a> whether to use ESMTP or not. This should be done before calling <a href="smtp#method-i-start"><code>start</code></a>. Note that if <a href="smtp#method-i-start"><code>start</code></a> is called in ESMTP mode, and the connection fails due to a <span><code>ProtocolError</code></span>, the <a href="smtp"><code>SMTP</code></a> object will automatically switch to plain <a href="smtp"><code>SMTP</code></a> mode and retry (but not vice versa).</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-open_timeout"> <span class="method-name">open_timeout</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Seconds to wait while attempting to open a connection. If the connection cannot be opened within this time, a <a href="opentimeout"><code>Net::OpenTimeout</code></a> is raised. The default value is 30 seconds.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-port"> <span class="method-name">port</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>The port number of the <a href="smtp"><code>SMTP</code></a> server to connect to.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-read_timeout"> <span class="method-name">read_timeout</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Seconds to wait while reading one block (by one read(2) call). If the read(2) call does not complete within this time, a <a href="readtimeout"><code>Net::ReadTimeout</code></a> is raised. The default value is 60 seconds.</p> </div> </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-default_port"> <span class="method-name">default_port</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="default_port-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 176
def SMTP.default_port
  25
end</pre> </div> <p>The default <a href="smtp"><code>SMTP</code></a> port number, 25.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-default_ssl_context"> <span class="method-name">default_ssl_context</span><span class="method-args">(verify_peer=true)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="default_ssl_context-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 194
def SMTP.default_ssl_context(verify_peer=true)
  context = OpenSSL::SSL::SSLContext.new
  context.verify_mode = verify_peer ? OpenSSL::SSL::VERIFY_PEER : OpenSSL::SSL::VERIFY_NONE
  store = OpenSSL::X509::Store.new
  store.set_default_paths
  context.cert_store = store
  context
end</pre> </div>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-c-default_ssl_port"> <span class="method-name">default_ssl_port</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="smtp#method-c-default_tls_port">default_tls_port</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-default_submission_port"> <span class="method-name">default_submission_port</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="default_submission_port-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 181
def SMTP.default_submission_port
  587
end</pre> </div> <p>The default mail submission port number, 587.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-default_tls_port"> <span class="method-name">default_tls_port</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="default_tls_port-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 186
def SMTP.default_tls_port
  465
end</pre> </div> <p>The default SMTPS port number, 465.</p>  </div> <div class="aliases"> Also aliased as: <a href="smtp#method-c-default_ssl_port">default_ssl_port</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-name">new</span><span class="method-args">(address, port = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 214
def initialize(address, port = nil)
  @address = address
  @port = (port || SMTP.default_port)
  @esmtp = true
  @capabilities = nil
  @socket = nil
  @started = false
  @open_timeout = 30
  @read_timeout = 60
  @error_occurred = false
  @debug_output = nil
  @tls = false
  @starttls = :auto
  @ssl_context_tls = nil
  @ssl_context_starttls = nil
end</pre> </div> <p>Creates a new <a href="smtp"><code>Net::SMTP</code></a> object.</p> <p><code>address</code> is the hostname or ip address of your <a href="smtp"><code>SMTP</code></a> server. <code>port</code> is the port to connect to; it defaults to port 25.</p> <p>This method does not open the TCP connection. You can use <a href="smtp#method-c-start"><code>SMTP.start</code></a> instead of <a href="smtp#method-c-new"><code>SMTP.new</code></a> if you want to do everything at once. Otherwise, follow <a href="smtp#method-c-new"><code>SMTP.new</code></a> with <a href="smtp#method-i-start"><code>SMTP#start</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-start"> <span class="method-callseq"> start(address, port = nil, helo: 'localhost', user: nil, secret: nil, authtype: nil, tls_verify: true, tls_hostname: nil) { |smtp| ... } </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> start(address, port = nil, helo = 'localhost', user = nil, secret = nil, authtype = nil) { |smtp| ... } </span> </div> <div class="method-description">
<div class="method-source-code" id="start-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 466
def SMTP.start(address, port = nil, *args, helo: nil,
               user: nil, secret: nil, password: nil, authtype: nil,
               tls_verify: true, tls_hostname: nil,
               &amp;block)
  raise ArgumentError, "wrong number of arguments (given #{args.size + 2}, expected 1..6)" if args.size &gt; 4
  helo ||= args[0] || 'localhost'
  user ||= args[1]
  secret ||= password || args[2]
  authtype ||= args[3]
  new(address, port).start(helo: helo, user: user, secret: secret, authtype: authtype, tls_verify: tls_verify, tls_hostname: tls_hostname, &amp;block)
end</pre> </div> <p>Creates a new <a href="smtp"><code>Net::SMTP</code></a> object and connects to the server.</p> <p>This method is equivalent to:</p> <pre class="ruby" data-language="ruby">Net::SMTP.new(address, port).start(helo: helo_domain, user: account, secret: password, authtype: authtype, tls_verify: flag, tls_hostname: hostname)
</pre> <h3 id="method-c-start-label-Example">Example</h3> <pre class="ruby" data-language="ruby">Net::SMTP.start('your.smtp.server') do |smtp|
  smtp.send_message msgstr, 'from@example.com', ['dest@example.com']
end
</pre> <h3 id="method-c-start-label-Block+Usage">Block Usage</h3> <p>If called with a block, the newly-opened <a href="smtp"><code>Net::SMTP</code></a> object is yielded to the block, and automatically closed when the block finishes. If called without a block, the newly-opened <a href="smtp"><code>Net::SMTP</code></a> object is returned to the caller, and it is the caller's responsibility to close it when finished.</p> <h3 id="method-c-start-label-Parameters">Parameters</h3> <p><code>address</code> is the hostname or ip address of your smtp server.</p> <p><code>port</code> is the port to connect to; it defaults to port 25.</p> <p><code>helo</code> is the <em>HELO</em> <em>domain</em> provided by the client to the server (see overview comments); it defaults to 'localhost'.</p> <p>The remaining arguments are used for <a href="smtp"><code>SMTP</code></a> authentication, if required or desired. <code>user</code> is the account name; <code>secret</code> is your password or other authentication token; and <code>authtype</code> is the authentication type, one of :plain, :login, or :cram_md5. See the discussion of <a href="smtp"><code>SMTP</code></a> Authentication in the overview notes. If <code>tls_verify</code> is true, verify the server's certificate. The default is true. If the hostname in the server certificate is different from <code>address</code>, it can be specified with <code>tls_hostname</code>.</p> <h3 id="method-c-start-label-Errors">Errors</h3> <p>This method may raise:</p> <ul>
<li> <p><a href="smtpauthenticationerror"><code>Net::SMTPAuthenticationError</code></a></p> </li>
<li> <p><a href="smtpserverbusy"><code>Net::SMTPServerBusy</code></a></p> </li>
<li> <p><a href="smtpsyntaxerror"><code>Net::SMTPSyntaxError</code></a></p> </li>
<li> <p><a href="smtpfatalerror"><code>Net::SMTPFatalError</code></a></p> </li>
<li> <p><a href="smtpunknownerror"><code>Net::SMTPUnknownError</code></a></p> </li>
<li> <p><a href="opentimeout"><code>Net::OpenTimeout</code></a></p> </li>
<li> <p><a href="readtimeout"><code>Net::ReadTimeout</code></a></p> </li>
<li> <p><a href="../ioerror"><code>IOError</code></a></p> </li>
</ul>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-auth_cram_md5"> <span class="method-name">auth_cram_md5</span><span class="method-args">(user, secret)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="auth_cram_md5-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 791
def auth_cram_md5(user, secret)
  check_auth_args user, secret
  res = critical {
    res0 = get_response('AUTH CRAM-MD5')
    check_auth_continue res0
    crammed = cram_md5_response(secret, res0.cram_md5_challenge)
    get_response(base64_encode("#{user} #{crammed}"))
  }
  check_auth_response res
  res
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-auth_login"> <span class="method-name">auth_login</span><span class="method-args">(user, secret)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="auth_login-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 780
def auth_login(user, secret)
  check_auth_args user, secret
  res = critical {
    check_auth_continue get_response('AUTH LOGIN')
    check_auth_continue get_response(base64_encode(user))
    get_response(base64_encode(secret))
  }
  check_auth_response res
  res
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-auth_plain"> <span class="method-name">auth_plain</span><span class="method-args">(user, secret)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="auth_plain-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 771
def auth_plain(user, secret)
  check_auth_args user, secret
  res = critical {
    get_response('AUTH PLAIN ' + base64_encode("\0#{user}\0#{secret}"))
  }
  check_auth_response res
  res
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-authenticate"> <span class="method-name">authenticate</span><span class="method-args">(user, secret, authtype = DEFAULT_AUTH_TYPE)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="authenticate-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 765
def authenticate(user, secret, authtype = DEFAULT_AUTH_TYPE)
  check_auth_method authtype
  check_auth_args user, secret
  public_send auth_method(authtype), user, secret
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-capable_auth_types"> <span class="method-name">capable_auth_types</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="capable_auth_types-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 287
def capable_auth_types
  return [] unless @capabilities
  return [] unless @capabilities['AUTH']
  @capabilities['AUTH']
end</pre> </div> <p>Returns supported authentication methods on this server. You cannot get valid value before opening <a href="smtp"><code>SMTP</code></a> session.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-capable_cram_md5_auth-3F"> <span class="method-name">capable_cram_md5_auth?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="capable_cram_md5_auth-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 274
def capable_cram_md5_auth?
  auth_capable?('CRAM-MD5')
end</pre> </div> <p>true if server advertises AUTH CRAM-MD5. You cannot get valid value before opening <a href="smtp"><code>SMTP</code></a> session.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-capable_login_auth-3F"> <span class="method-name">capable_login_auth?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="capable_login_auth-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 268
def capable_login_auth?
  auth_capable?('LOGIN')
end</pre> </div> <p>true if server advertises AUTH LOGIN. You cannot get valid value before opening <a href="smtp"><code>SMTP</code></a> session.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-capable_plain_auth-3F"> <span class="method-name">capable_plain_auth?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="capable_plain_auth-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 262
def capable_plain_auth?
  auth_capable?('PLAIN')
end</pre> </div> <p>true if server advertises AUTH PLAIN. You cannot get valid value before opening <a href="smtp"><code>SMTP</code></a> session.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-capable_starttls-3F"> <span class="method-name">capable_starttls?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="capable_starttls-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 250
def capable_starttls?
  capable?('STARTTLS')
end</pre> </div> <p>true if server advertises STARTTLS. You cannot get valid value before opening <a href="smtp"><code>SMTP</code></a> session.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-data"> <span class="method-name">data</span><span class="method-args">(msgstr = nil) { |stream| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="data-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 925
def data(msgstr = nil, &amp;block)   #:yield: stream
  if msgstr and block
    raise ArgumentError, "message and block are exclusive"
  end
  unless msgstr or block
    raise ArgumentError, "message or block is required"
  end
  res = critical {
    check_continue get_response('DATA')
    socket_sync_bak = @socket.io.sync
    begin
      @socket.io.sync = false
      if msgstr
        @socket.write_message msgstr
      else
        @socket.write_message_by_block(&amp;block)
      end
    ensure
      @socket.io.flush
      @socket.io.sync = socket_sync_bak
    end
    recv_response()
  }
  check_response res
  res
end</pre> </div> <p>This method sends a message. If <code>msgstr</code> is given, sends it as a message. If block is given, yield a message writer stream. You must write message before the block is closed.</p> <pre class="ruby" data-language="ruby"># Example 1 (by string)
smtp.data(&lt;&lt;EndMessage)
From: john@example.com
To: betty@example.com
Subject: I found a bug

Check vm.c:58879.
EndMessage

# Example 2 (by block)
smtp.data {|f|
  f.puts "From: john@example.com"
  f.puts "To: betty@example.com"
  f.puts "Subject: I found a bug"
  f.puts ""
  f.puts "Check vm.c:58879."
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-debug_output-3D"> <span class="method-name">debug_output=</span><span class="method-args">(arg)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="debug_output-3D-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 400
def debug_output=(arg)
  @debug_output = arg
end</pre> </div> <p>WARNING: This method causes serious security holes. Use this method for only debugging.</p> <p><a href="../set"><code>Set</code></a> an output stream for debug logging. You must call this before <a href="smtp#method-i-start"><code>start</code></a>.</p> <pre># example
smtp = Net::SMTP.new(addr, port)
smtp.set_debug_output $stderr
smtp.start do |smtp|
  ....
end</pre>  </div> <div class="aliases"> Also aliased as: <a href="smtp#method-i-set_debug_output">set_debug_output</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-disable_ssl"> <span class="method-name">disable_ssl</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="smtp#method-i-disable_tls">disable_tls</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-disable_starttls"> <span class="method-name">disable_starttls</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="disable_starttls-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 358
def disable_starttls
  @starttls = false
  @ssl_context_starttls = nil
end</pre> </div> <p>Disables SMTP/TLS (STARTTLS) for this object. Must be called before the connection is established to have any effect.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-disable_tls"> <span class="method-name">disable_tls</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="disable_tls-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 314
def disable_tls
  @tls = false
  @ssl_context_tls = nil
end</pre> </div> <p>Disables SMTP/TLS for this object. Must be called before the connection is established to have any effect.</p>  </div> <div class="aliases"> Also aliased as: <a href="smtp#method-i-disable_ssl">disable_ssl</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ehlo"> <span class="method-name">ehlo</span><span class="method-args">(domain)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ehlo-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 869
def ehlo(domain)
  getok("EHLO #{domain}")
end</pre> </div>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-enable_ssl"> <span class="method-name">enable_ssl</span><span class="method-args">(context = nil)</span> </div>  <div class="aliases"> Alias for: <a href="smtp#method-i-enable_tls">enable_tls</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-enable_starttls"> <span class="method-name">enable_starttls</span><span class="method-args">(context = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="enable_starttls-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 340
def enable_starttls(context = nil)
  raise 'openssl library not installed' unless defined?(OpenSSL)
  raise ArgumentError, "SMTPS and STARTTLS is exclusive" if @tls
  @starttls = :always
  @ssl_context_starttls = context
end</pre> </div> <p>Enables SMTP/TLS (STARTTLS) for this object. <code>context</code> is a <a href="../openssl/ssl/sslcontext"><code>OpenSSL::SSL::SSLContext</code></a> object.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-enable_starttls_auto"> <span class="method-name">enable_starttls_auto</span><span class="method-args">(context = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="enable_starttls_auto-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 349
def enable_starttls_auto(context = nil)
  raise 'openssl library not installed' unless defined?(OpenSSL)
  raise ArgumentError, "SMTPS and STARTTLS is exclusive" if @tls
  @starttls = :auto
  @ssl_context_starttls = context
end</pre> </div> <p>Enables SMTP/TLS (STARTTLS) for this object if server accepts. <code>context</code> is a <a href="../openssl/ssl/sslcontext"><code>OpenSSL::SSL::SSLContext</code></a> object.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-enable_tls"> <span class="method-name">enable_tls</span><span class="method-args">(context = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="enable_tls-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 303
def enable_tls(context = nil)
  raise 'openssl library not installed' unless defined?(OpenSSL)
  raise ArgumentError, "SMTPS and STARTTLS is exclusive" if @starttls == :always
  @tls = true
  @ssl_context_tls = context
end</pre> </div> <p>Enables SMTP/TLS (SMTPS: <a href="smtp"><code>SMTP</code></a> over direct TLS connection) for this object. Must be called before the connection is established to have any effect. <code>context</code> is a <a href="../openssl/ssl/sslcontext"><code>OpenSSL::SSL::SSLContext</code></a> object.</p>  </div> <div class="aliases"> Also aliased as: <a href="smtp#method-i-enable_ssl">enable_ssl</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-finish"> <span class="method-name">finish</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="finish-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 570
def finish
  raise IOError, 'not yet started' unless started?
  do_finish
end</pre> </div> <p>Finishes the <a href="smtp"><code>SMTP</code></a> session and closes TCP connection. Raises <a href="../ioerror"><code>IOError</code></a> if not started.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-helo"> <span class="method-name">helo</span><span class="method-args">(domain)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="helo-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 865
def helo(domain)
  getok("HELO #{domain}")
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inspect"> <span class="method-name">inspect</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 232
def inspect
  "#&lt;#{self.class} #{@address}:#{@port} started=#{@started}&gt;"
end</pre> </div> <p>Provide human-readable stringification of class state.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-mailfrom"> <span class="method-name">mailfrom</span><span class="method-args">(from_addr)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="mailfrom-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 873
def mailfrom(from_addr)
  getok("MAIL FROM:&lt;#{from_addr}&gt;")
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-open_message_stream"> <span class="method-name">open_message_stream</span><span class="method-args">(from_addr, *to_addrs) { |stream| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="open_message_stream-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 749
def open_message_stream(from_addr, *to_addrs, &amp;block)   # :yield: stream
  raise IOError, 'closed session' unless @socket
  mailfrom from_addr
  rcptto_list(to_addrs) {data(&amp;block)}
end</pre> </div> <p>Opens a message writer stream and gives it to the block. The stream is valid only in the block, and has these methods:</p> <dl class="rdoc-list note-list">
<dt>puts(str = '') </dt>
<dd> <p>outputs STR and CR LF.</p> </dd>
<dt>print(str) </dt>
<dd> <p>outputs STR.</p> </dd>
<dt>printf(fmt, *args) </dt>
<dd> <p>outputs sprintf(fmt,*args).</p> </dd>
<dt>write(str) </dt>
<dd> <p>outputs STR and returns the length of written bytes.</p> </dd>
<dt>&lt;&lt;(str) </dt>
<dd> <p>outputs STR and returns self.</p> </dd>
</dl> <p>If a single CR (“r”) or LF (“n”) is found in the message, it is converted to the CR LF pair. You cannot send a binary message with this method.</p> <h3 id="method-i-open_message_stream-label-Parameters">Parameters</h3> <p><code>from_addr</code> is a <a href="../string"><code>String</code></a> representing the source mail address.</p> <p><code>to_addr</code> is a <a href="../string"><code>String</code></a> or Strings or <a href="../array"><code>Array</code></a> of Strings, representing the destination mail address or addresses.</p> <h3 id="method-i-open_message_stream-label-Example">Example</h3> <pre class="ruby" data-language="ruby">Net::SMTP.start('smtp.example.com', 25) do |smtp|
  smtp.open_message_stream('from@example.com', ['dest@example.com']) do |f|
    f.puts 'From: from@example.com'
    f.puts 'To: dest@example.com'
    f.puts 'Subject: test message'
    f.puts
    f.puts 'This is a test message.'
  end
end
</pre> <h3 id="method-i-open_message_stream-label-Errors">Errors</h3> <p>This method may raise:</p> <ul>
<li> <p><a href="smtpserverbusy"><code>Net::SMTPServerBusy</code></a></p> </li>
<li> <p><a href="smtpsyntaxerror"><code>Net::SMTPSyntaxError</code></a></p> </li>
<li> <p><a href="smtpfatalerror"><code>Net::SMTPFatalError</code></a></p> </li>
<li> <p><a href="smtpunknownerror"><code>Net::SMTPUnknownError</code></a></p> </li>
<li> <p><a href="readtimeout"><code>Net::ReadTimeout</code></a></p> </li>
<li> <p><a href="../ioerror"><code>IOError</code></a></p> </li>
</ul>  </div> <div class="aliases"> Also aliased as: <a href="smtp#method-i-ready">ready</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-quit"> <span class="method-name">quit</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="quit-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 952
def quit
  getok('QUIT')
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rcptto"> <span class="method-name">rcptto</span><span class="method-args">(to_addr)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rcptto-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 898
def rcptto(to_addr)
  getok("RCPT TO:&lt;#{to_addr}&gt;")
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rcptto_list"> <span class="method-name">rcptto_list</span><span class="method-args">(to_addrs) { || ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rcptto_list-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 877
def rcptto_list(to_addrs)
  raise ArgumentError, 'mail destination not given' if to_addrs.empty?
  ok_users = []
  unknown_users = []
  to_addrs.flatten.each do |addr|
    begin
      rcptto addr
    rescue SMTPAuthenticationError
      unknown_users &lt;&lt; addr.dump
    else
      ok_users &lt;&lt; addr
    end
  end
  raise ArgumentError, 'mail destination not given' if ok_users.empty?
  ret = yield
  unless unknown_users.empty?
    raise SMTPAuthenticationError, "failed to deliver for #{unknown_users.join(', ')}"
  end
  ret
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-read_timeout-3D"> <span class="method-name">read_timeout=</span><span class="method-args">(sec)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="read_timeout-3D-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 381
def read_timeout=(sec)
  @socket.read_timeout = sec if @socket
  @read_timeout = sec
end</pre> </div> <p><a href="../set"><code>Set</code></a> the number of seconds to wait until timing-out a read(2) call.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-ready"> <span class="method-name">ready</span><span class="method-args">(from_addr, *to_addrs)</span> </div>  <div class="aliases"> Alias for: <a href="smtp#method-i-open_message_stream">open_message_stream</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rset"> <span class="method-name">rset</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rset-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 857
def rset
  getok('RSET')
end</pre> </div> <p>Aborts the current mail transaction</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-send_mail"> <span class="method-name">send_mail</span><span class="method-args">(msgstr, from_addr, *to_addrs)</span> </div>  <div class="aliases"> Alias for: <a href="smtp#method-i-send_message">send_message</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-send_message"> <span class="method-name">send_message</span><span class="method-args">(msgstr, from_addr, *to_addrs)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="send_message-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 696
def send_message(msgstr, from_addr, *to_addrs)
  raise IOError, 'closed session' unless @socket
  mailfrom from_addr
  rcptto_list(to_addrs) {data msgstr}
end</pre> </div> <p>Sends <code>msgstr</code> as a message. Single CR (“r”) and LF (“n”) found in the <code>msgstr</code>, are converted into the CR LF pair. You cannot send a binary message with this method. <code>msgstr</code> should include both the message headers and body.</p> <p><code>from_addr</code> is a <a href="../string"><code>String</code></a> representing the source mail address.</p> <p><code>to_addr</code> is a <a href="../string"><code>String</code></a> or Strings or <a href="../array"><code>Array</code></a> of Strings, representing the destination mail address or addresses.</p> <h3 id="method-i-send_message-label-Example">Example</h3> <pre class="ruby" data-language="ruby">Net::SMTP.start('smtp.example.com') do |smtp|
  smtp.send_message msgstr,
                    'from@example.com',
                    ['dest@example.com', 'dest2@example.com']
end
</pre> <h3 id="method-i-send_message-label-Errors">Errors</h3> <p>This method may raise:</p> <ul>
<li> <p><a href="smtpserverbusy"><code>Net::SMTPServerBusy</code></a></p> </li>
<li> <p><a href="smtpsyntaxerror"><code>Net::SMTPSyntaxError</code></a></p> </li>
<li> <p><a href="smtpfatalerror"><code>Net::SMTPFatalError</code></a></p> </li>
<li> <p><a href="smtpunknownerror"><code>Net::SMTPUnknownError</code></a></p> </li>
<li> <p><a href="readtimeout"><code>Net::ReadTimeout</code></a></p> </li>
<li> <p><a href="../ioerror"><code>IOError</code></a></p> </li>
</ul>  </div> <div class="aliases"> Also aliased as: <a href="smtp#method-i-send_mail">send_mail</a>, <a href="smtp#method-i-sendmail">sendmail</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-sendmail"> <span class="method-name">sendmail</span><span class="method-args">(msgstr, from_addr, *to_addrs)</span> </div>  <div class="aliases"> Alias for: <a href="smtp#method-i-send_message">send_message</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-set_debug_output"> <span class="method-name">set_debug_output</span><span class="method-args">(arg)</span> </div>  <div class="aliases"> Alias for: <a href="smtp#method-i-debug_output-3D">debug_output=</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-ssl-3F"> <span class="method-name">ssl?</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="smtp#method-i-tls-3F">tls?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-start"> <span class="method-callseq"> start(helo: 'localhost', user: nil, secret: nil, authtype: nil, tls_verify: true, tls_hostname: nil) { |smtp| ... } </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> start(helo = 'localhost', user = nil, secret = nil, authtype = nil) { |smtp| ... } </span> </div> <div class="method-description">
<div class="method-source-code" id="start-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 541
def start(*args, helo: nil,
          user: nil, secret: nil, password: nil, authtype: nil, tls_verify: true, tls_hostname: nil)
  raise ArgumentError, "wrong number of arguments (given #{args.size}, expected 0..4)" if args.size &gt; 4
  helo ||= args[0] || 'localhost'
  user ||= args[1]
  secret ||= password || args[2]
  authtype ||= args[3]
  if @tls &amp;&amp; @ssl_context_tls.nil?
    @ssl_context_tls = SMTP.default_ssl_context(tls_verify)
  end
  if @starttls &amp;&amp; @ssl_context_starttls.nil?
    @ssl_context_starttls = SMTP.default_ssl_context(tls_verify)
  end
  @tls_hostname = tls_hostname
  if block_given?
    begin
      do_start helo, user, secret, authtype
      return yield(self)
    ensure
      do_finish
    end
  else
    do_start helo, user, secret, authtype
    return self
  end
end</pre> </div> <p>Opens a TCP connection and starts the <a href="smtp"><code>SMTP</code></a> session.</p> <h3 id="method-i-start-label-Parameters">Parameters</h3> <p><code>helo</code> is the <em>HELO</em> <em>domain</em> that you'll dispatch mails from; see the discussion in the overview notes.</p> <p>If both of <code>user</code> and <code>secret</code> are given, <a href="smtp"><code>SMTP</code></a> authentication will be attempted using the AUTH command. <code>authtype</code> specifies the type of authentication to attempt; it must be one of :login, :plain, and :cram_md5. See the notes on <a href="smtp"><code>SMTP</code></a> Authentication in the overview. If <code>tls_verify</code> is true, verify the server's certificate. The default is true. If the hostname in the server certificate is different from <code>address</code>, it can be specified with <code>tls_hostname</code>.</p> <h3 id="method-i-start-label-Block+Usage">Block Usage</h3> <p>When this methods is called with a block, the newly-started <a href="smtp"><code>SMTP</code></a> object is yielded to the block, and automatically closed after the block call finishes. Otherwise, it is the caller's responsibility to close the session when finished.</p> <h3 id="method-i-start-label-Example">Example</h3> <p>This is very similar to the class method <a href="smtp#method-c-start"><code>SMTP.start</code></a>.</p> <pre class="ruby" data-language="ruby">require 'net/smtp'
smtp = Net::SMTP.new('smtp.mail.server', 25)
smtp.start(helo: helo_domain, user: account, secret: password, authtype: authtype) do |smtp|
  smtp.send_message msgstr, 'from@example.com', ['dest@example.com']
end
</pre> <p>The primary use of this method (as opposed to <a href="smtp#method-c-start"><code>SMTP.start</code></a>) is probably to set debugging (<a href="smtp#method-i-set_debug_output"><code>set_debug_output</code></a>) or ESMTP (<a href="smtp#attribute-i-esmtp"><code>esmtp=</code></a>), which must be done before the session is started.</p> <h3 id="method-i-start-label-Errors">Errors</h3> <p>If session has already been started, an <a href="../ioerror"><code>IOError</code></a> will be raised.</p> <p>This method may raise:</p> <ul>
<li> <p><a href="smtpauthenticationerror"><code>Net::SMTPAuthenticationError</code></a></p> </li>
<li> <p><a href="smtpserverbusy"><code>Net::SMTPServerBusy</code></a></p> </li>
<li> <p><a href="smtpsyntaxerror"><code>Net::SMTPSyntaxError</code></a></p> </li>
<li> <p><a href="smtpfatalerror"><code>Net::SMTPFatalError</code></a></p> </li>
<li> <p><a href="smtpunknownerror"><code>Net::SMTPUnknownError</code></a></p> </li>
<li> <p><a href="opentimeout"><code>Net::OpenTimeout</code></a></p> </li>
<li> <p><a href="readtimeout"><code>Net::ReadTimeout</code></a></p> </li>
<li> <p><a href="../ioerror"><code>IOError</code></a></p> </li>
</ul>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-started-3F"> <span class="method-name">started?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="started-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 479
def started?
  @started
end</pre> </div> <p><code>true</code> if the <a href="smtp"><code>SMTP</code></a> session has been started.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-starttls"> <span class="method-name">starttls</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="starttls-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 861
def starttls
  getok('STARTTLS')
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-starttls-3F"> <span class="method-name">starttls?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="starttls-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 324
def starttls?
  @starttls
end</pre> </div> <p>Returns truth value if this object uses STARTTLS. If this object always uses STARTTLS, returns :always. If this object uses STARTTLS when the server support TLS, returns :auto.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-starttls_always-3F"> <span class="method-name">starttls_always?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="starttls_always-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 329
def starttls_always?
  @starttls == :always
end</pre> </div> <p>true if this object uses STARTTLS.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-starttls_auto-3F"> <span class="method-name">starttls_auto?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="starttls_auto-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 334
def starttls_auto?
  @starttls == :auto
end</pre> </div> <p>true if this object uses STARTTLS when server advertises STARTTLS.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-tls-3F"> <span class="method-name">tls?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="tls-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 294
def tls?
  @tls
end</pre> </div> <p>true if this object uses SMTP/TLS (SMTPS).</p>  </div> <div class="aliases"> Also aliased as: <a href="smtp#method-i-ssl-3F">ssl?</a> </div> </div> </section> <section id="private-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Private Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-auth_capable-3F"> <span class="method-name">auth_capable?</span><span class="method-args">(type)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="auth_capable-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 278
def auth_capable?(type)
  return nil unless @capabilities
  return false unless @capabilities['AUTH']
  @capabilities['AUTH'].include?(type)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-auth_method"> <span class="method-name">auth_method</span><span class="method-args">(type)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="auth_method-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 811
def auth_method(type)
  "auth_#{type.to_s.downcase}".intern
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-base64_encode"> <span class="method-name">base64_encode</span><span class="method-args">(str)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="base64_encode-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 824
def base64_encode(str)
  # expects "str" may not become too long
  [str].pack('m0')
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-capable-3F"> <span class="method-name">capable?</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="capable-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 254
def capable?(key)
  return nil unless @capabilities
  @capabilities[key] ? true : false
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-check_auth_args"> <span class="method-name">check_auth_args</span><span class="method-args">(user, secret, authtype = DEFAULT_AUTH_TYPE)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="check_auth_args-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 815
def check_auth_args(user, secret, authtype = DEFAULT_AUTH_TYPE)
  unless user
    raise ArgumentError, 'SMTP-AUTH requested but missing user name'
  end
  unless secret
    raise ArgumentError, 'SMTP-AUTH requested but missing secret phrase'
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-check_auth_continue"> <span class="method-name">check_auth_continue</span><span class="method-args">(res)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="check_auth_continue-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 1019
def check_auth_continue(res)
  unless res.continue?
    raise res.exception_class, res.message
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-check_auth_method"> <span class="method-name">check_auth_method</span><span class="method-args">(type)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="check_auth_method-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 805
def check_auth_method(type)
  unless respond_to?(auth_method(type), true)
    raise ArgumentError, "wrong authentication type #{type}"
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-check_auth_response"> <span class="method-name">check_auth_response</span><span class="method-args">(res)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="check_auth_response-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 1013
def check_auth_response(res)
  unless res.success?
    raise SMTPAuthenticationError, res.message
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-check_continue"> <span class="method-name">check_continue</span><span class="method-args">(res)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="check_continue-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 1007
def check_continue(res)
  unless res.continue?
    raise SMTPUnknownError, "could not get 3xx (#{res.status}: #{res.string})"
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-check_response"> <span class="method-name">check_response</span><span class="method-args">(res)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="check_response-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 1001
def check_response(res)
  unless res.success?
    raise res.exception_class, res.message
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-cram_md5_response"> <span class="method-name">cram_md5_response</span><span class="method-args">(secret, challenge)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="cram_md5_response-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 833
def cram_md5_response(secret, challenge)
  tmp = Digest::MD5.digest(cram_secret(secret, IMASK) + challenge)
  Digest::MD5.hexdigest(cram_secret(secret, OMASK) + tmp)
end</pre> </div> <p>CRAM-MD5: [RFC2195]</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-cram_secret"> <span class="method-name">cram_secret</span><span class="method-args">(secret, mask)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="cram_secret-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 840
def cram_secret(secret, mask)
  secret = Digest::MD5.digest(secret) if secret.size &gt; CRAM_BUFSIZE
  buf = secret.ljust(CRAM_BUFSIZE, "\0")
  0.upto(buf.size - 1) do |i|
    buf[i] = (buf[i].ord ^ mask).chr
  end
  buf
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-critical"> <span class="method-name">critical</span><span class="method-args">() { || ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="critical-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 991
def critical
  return Response.parse('200 dummy reply code') if @error_occurred
  begin
    return yield()
  rescue Exception
    @error_occurred = true
    raise
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-do_finish"> <span class="method-name">do_finish</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="do_finish-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 651
def do_finish
  quit if @socket and not @socket.closed? and not @error_occurred
ensure
  @started = false
  @error_occurred = false
  @socket.close if @socket
  @socket = nil
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-do_helo"> <span class="method-name">do_helo</span><span class="method-args">(helo_domain)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="do_helo-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 639
def do_helo(helo_domain)
  res = @esmtp ? ehlo(helo_domain) : helo(helo_domain)
  @capabilities = res.capabilities
rescue SMTPError
  if @esmtp
    @esmtp = false
    @error_occurred = false
    retry
  end
  raise
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-do_start"> <span class="method-name">do_start</span><span class="method-args">(helo_domain, user, secret, authtype)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="do_start-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 581
def do_start(helo_domain, user, secret, authtype)
  raise IOError, 'SMTP session already started' if @started
  if user or secret
    check_auth_method(authtype || DEFAULT_AUTH_TYPE)
    check_auth_args user, secret
  end
  s = Timeout.timeout(@open_timeout, Net::OpenTimeout) do
    tcp_socket(@address, @port)
  end
  logging "Connection opened: #{@address}:#{@port}"
  @socket = new_internet_message_io(tls? ? tlsconnect(s, @ssl_context_tls) : s)
  check_response critical { recv_response() }
  do_helo helo_domain
  if ! tls? and (starttls_always? or (capable_starttls? and starttls_auto?))
    unless capable_starttls?
      raise SMTPUnsupportedCommand,
          "STARTTLS is not supported on this server"
    end
    starttls
    @socket = new_internet_message_io(tlsconnect(s, @ssl_context_starttls))
    # helo response may be different after STARTTLS
    do_helo helo_domain
  end
  authenticate user, secret, (authtype || DEFAULT_AUTH_TYPE) if user
  @started = true
ensure
  unless @started
    # authentication failed, cancel connection.
    s.close if s
    @socket = nil
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-get_response"> <span class="method-name">get_response</span><span class="method-args">(reqline)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="get_response-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 975
def get_response(reqline)
  validate_line reqline
  @socket.writeline reqline
  recv_response()
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-getok"> <span class="method-name">getok</span><span class="method-args">(reqline)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="getok-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 965
def getok(reqline)
  validate_line reqline
  res = critical {
    @socket.writeline reqline
    recv_response()
  }
  check_response res
  res
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-logging"> <span class="method-name">logging</span><span class="method-args">(msg)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="logging-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 1104
def logging(msg)
  @debug_output &lt;&lt; msg + "\n" if @debug_output
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-new_internet_message_io"> <span class="method-name">new_internet_message_io</span><span class="method-args">(s)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new_internet_message_io-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 634
def new_internet_message_io(s)
  InternetMessageIO.new(s, read_timeout: @read_timeout,
                        debug_output: @debug_output)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-recv_response"> <span class="method-name">recv_response</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="recv_response-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 981
def recv_response
  buf = ''.dup
  while true
    line = @socket.readline
    buf &lt;&lt; line &lt;&lt; "\n"
    break unless line[3,1] == '-'   # "210-PIPELINING"
  end
  Response.parse(buf)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ssl_socket"> <span class="method-name">ssl_socket</span><span class="method-args">(socket, context)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ssl_socket-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 614
def ssl_socket(socket, context)
  OpenSSL::SSL::SSLSocket.new socket, context
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-tcp_socket"> <span class="method-name">tcp_socket</span><span class="method-args">(address, port)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="tcp_socket-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 577
def tcp_socket(address, port)
  TCPSocket.open address, port
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-tlsconnect"> <span class="method-name">tlsconnect</span><span class="method-args">(s, context)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="tlsconnect-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 618
def tlsconnect(s, context)
  verified = false
  s = ssl_socket(s, context)
  logging "TLS connection started"
  s.sync_close = true
  s.hostname = @tls_hostname || @address if s.respond_to? :hostname=
  ssl_socket_connect(s, @open_timeout)
  if context.verify_mode &amp;&amp; context.verify_mode != OpenSSL::SSL::VERIFY_NONE
    s.post_connection_check(@tls_hostname || @address)
  end
  verified = true
  s
ensure
  s.close unless verified
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-validate_line"> <span class="method-name">validate_line</span><span class="method-args">(line)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="validate_line-source"> <pre class="ruby" data-language="ruby"># File lib/net/smtp.rb, line 958
def validate_line(line)
  # A bare CR or LF is not allowed in RFC5321.
  if /[\r\n]/ =~ line
    raise ArgumentError, "A line must not contain CR or LF"
  end
end</pre> </div>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2020 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
