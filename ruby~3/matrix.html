<h1 id="class-Matrix" class="class"> class Matrix </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes">
<a class="include" href="enumerable">Enumerable</a>, <span class="include">ExceptionForMatrix</span>
</dd>
</dl> <section class="description"> <p>The <code>Matrix</code> class represents a mathematical matrix. It provides methods for creating matrices, operating on them arithmetically and algebraically, and determining their mathematical properties such as trace, rank, inverse, determinant, or eigensystem.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="SELECTORS">SELECTORS </dt>

<dt id="VERSION">VERSION </dt>

</dl> </section> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-column_count"> <span class="method-name">column_count</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Returns the number of columns.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-column_size"> <span class="method-name">column_size</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Returns the number of columns.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-rows"> <span class="method-name">rows</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>instance creations</p> </div> </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail method-alias"> <div class="method-heading" id="method-c-I"> <span class="method-name">I</span><span class="method-args">(n)</span> </div>  <div class="aliases"> Alias for: <a href="matrix#method-c-identity">identity</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-5B-5D"> <span class="method-name">[]</span><span class="method-args">(*rows)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 78
def Matrix.[](*rows)
  rows(rows, false)
end</pre> </div> <p>Creates a matrix where each argument is a row.</p> <pre class="ruby" data-language="ruby">Matrix[ [25, 93], [-1, 66] ]
#   =&gt;  25 93
#       -1 66
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-build"> <span class="method-name">build</span><span class="method-args">(row_count, column_count = row_count) { |i, j| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="build-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 123
def Matrix.build(row_count, column_count = row_count)
  row_count = CoercionHelper.coerce_to_int(row_count)
  column_count = CoercionHelper.coerce_to_int(column_count)
  raise ArgumentError if row_count &lt; 0 || column_count &lt; 0
  return to_enum :build, row_count, column_count unless block_given?
  rows = Array.new(row_count) do |i|
    Array.new(column_count) do |j|
      yield i, j
    end
  end
  new rows, column_count
end</pre> </div> <p>Creates a matrix of size <code>row_count</code> x <code>column_count</code>. It fills the values by calling the given block, passing the current row and column. Returns an enumerator if no block is given.</p> <pre class="ruby" data-language="ruby">m = Matrix.build(2, 4) {|row, col| col - row }
#  =&gt; Matrix[[0, 1, 2, 3], [-1, 0, 1, 2]]
m = Matrix.build(3) { rand }
#  =&gt; a 3x3 matrix with random elements
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-column_vector"> <span class="method-name">column_vector</span><span class="method-args">(column)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="column_vector-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 209
def Matrix.column_vector(column)
  column = convert_to_array(column)
  new [column].transpose, 1
end</pre> </div> <p>Creates a single-column matrix where the values of that column are as given in <code>column</code>.</p> <pre class="ruby" data-language="ruby">Matrix.column_vector([4,5,6])
#  =&gt; 4
#     5
#     6
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-columns"> <span class="method-name">columns</span><span class="method-args">(columns)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="columns-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 108
def Matrix.columns(columns)
  rows(columns, false).transpose
end</pre> </div> <p>Creates a matrix using <code>columns</code> as an array of column vectors.</p> <pre class="ruby" data-language="ruby">Matrix.columns([[25, 93], [-1, 66]])
#   =&gt;  25 -1
#       93 66
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-combine"> <span class="method-callseq"> combine(*matrices) { |*elements| ... } </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="combine-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 288
def Matrix.combine(*matrices)
  return to_enum(__method__, *matrices) unless block_given?

  return Matrix.empty if matrices.empty?
  matrices.map!(&amp;CoercionHelper.method(:coerce_to_matrix))
  x = matrices.first
  matrices.each do |m|
    raise ErrDimensionMismatch unless x.row_count == m.row_count &amp;&amp; x.column_count == m.column_count
  end

  rows = Array.new(x.row_count) do |i|
    Array.new(x.column_count) do |j|
      yield matrices.map{|m| m[i,j]}
    end
  end
  new rows, x.column_count
end</pre> </div> <p>Create a matrix by combining matrices entrywise, using the given block</p> <pre class="ruby" data-language="ruby">x = Matrix[[6, 6], [4, 4]]
y = Matrix[[1, 2], [3, 4]]
Matrix.combine(x, y) {|a, b| a - b} # =&gt; Matrix[[5, 4], [1, 0]]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-diagonal"> <span class="method-name">diagonal</span><span class="method-args">(*values)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="diagonal-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 143
def Matrix.diagonal(*values)
  size = values.size
  return Matrix.empty if size == 0
  rows = Array.new(size) {|j|
    row = Array.new(size, 0)
    row[j] = values[j]
    row
  }
  new rows
end</pre> </div> <p>Creates a matrix where the diagonal elements are composed of <code>values</code>.</p> <pre class="ruby" data-language="ruby">Matrix.diagonal(9, 5, -3)
#  =&gt;  9  0  0
#      0  5  0
#      0  0 -3
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-empty"> <span class="method-name">empty</span><span class="method-args">(row_count = 0, column_count = 0)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="empty-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 227
def Matrix.empty(row_count = 0, column_count = 0)
  raise ArgumentError, "One size must be 0" if column_count != 0 &amp;&amp; row_count != 0
  raise ArgumentError, "Negative size" if column_count &lt; 0 || row_count &lt; 0

  new([[]]*row_count, column_count)
end</pre> </div> <p>Creates a empty matrix of <code>row_count</code> x <code>column_count</code>. At least one of <code>row_count</code> or <code>column_count</code> must be 0.</p> <pre class="ruby" data-language="ruby">m = Matrix.empty(2, 0)
m == Matrix[ [], [] ]
#  =&gt; true
n = Matrix.empty(0, 3)
n == Matrix.columns([ [], [], [] ])
#  =&gt; true
m * n
#  =&gt; Matrix[[0, 0, 0], [0, 0, 0]]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-hstack"> <span class="method-name">hstack</span><span class="method-args">(x, *matrices)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="hstack-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 262
def Matrix.hstack(x, *matrices)
  x = CoercionHelper.coerce_to_matrix(x)
  result = x.send(:rows).map(&amp;:dup)
  total_column_count = x.column_count
  matrices.each do |m|
    m = CoercionHelper.coerce_to_matrix(m)
    if m.row_count != x.row_count
      raise ErrDimensionMismatch, "The given matrices must have #{x.row_count} rows, but one has #{m.row_count}"
    end
    result.each_with_index do |row, i|
      row.concat m.send(:rows)[i]
    end
    total_column_count += m.column_count
  end
  new result, total_column_count
end</pre> </div> <p>Create a matrix by stacking matrices horizontally</p> <pre class="ruby" data-language="ruby">x = Matrix[[1, 2], [3, 4]]
y = Matrix[[5, 6], [7, 8]]
Matrix.hstack(x, y) # =&gt; Matrix[[1, 2, 5, 6], [3, 4, 7, 8]]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-identity"> <span class="method-name">identity</span><span class="method-args">(n)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="identity-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 171
def Matrix.identity(n)
  scalar(n, 1)
end</pre> </div> <p>Creates an <code>n</code> by <code>n</code> identity matrix.</p> <pre class="ruby" data-language="ruby">Matrix.identity(2)
#  =&gt; 1 0
#     0 1
</pre>  </div> <div class="aliases"> Also aliased as: <a href="matrix#method-c-unit">unit</a>, <a href="matrix#method-c-I">I</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-name">new</span><span class="method-args">(rows, column_count = rows[0].size)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 322
def initialize(rows, column_count = rows[0].size)
  # No checking is done at this point. rows must be an Array of Arrays.
  # column_count must be the size of the first row, if there is one,
  # otherwise it *must* be specified and can be any integer &gt;= 0
  @rows = rows
  @column_count = column_count
end</pre> </div> <p><a href="matrix#method-c-new"><code>Matrix.new</code></a> is private; use <a href="matrix#method-c-rows"><code>::rows</code></a>, <a href="matrix#method-c-columns"><code>::columns</code></a>, <a href="matrix#method-c-5B-5D"><code>::[]</code></a>, etc… to create.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-row_vector"> <span class="method-name">row_vector</span><span class="method-args">(row)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="row_vector-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 196
def Matrix.row_vector(row)
  row = convert_to_array(row)
  new [row]
end</pre> </div> <p>Creates a single-row matrix where the values of that row are as given in <code>row</code>.</p> <pre class="ruby" data-language="ruby">Matrix.row_vector([4,5,6])
#  =&gt; 4 5 6
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-rows"> <span class="method-name">rows</span><span class="method-args">(rows, copy = true)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rows-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 90
def Matrix.rows(rows, copy = true)
  rows = convert_to_array(rows, copy)
  rows.map! do |row|
    convert_to_array(row, copy)
  end
  size = (rows[0] || []).size
  rows.each do |row|
    raise ErrDimensionMismatch, "row size differs (#{row.size} should be #{size})" unless row.size == size
  end
  new rows, size
end</pre> </div> <p>Creates a matrix where <code>rows</code> is an array of arrays, each of which is a row of the matrix. If the optional argument <code>copy</code> is false, use the given arrays as the internal structure of the matrix without copying.</p> <pre class="ruby" data-language="ruby">Matrix.rows([[25, 93], [-1, 66]])
#   =&gt;  25 93
#       -1 66
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-scalar"> <span class="method-name">scalar</span><span class="method-args">(n, value)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="scalar-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 161
def Matrix.scalar(n, value)
  diagonal(*Array.new(n, value))
end</pre> </div> <p>Creates an <code>n</code> by <code>n</code> diagonal matrix where each diagonal element is <code>value</code>.</p> <pre class="ruby" data-language="ruby">Matrix.scalar(2, 5)
#  =&gt; 5 0
#     0 5
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-c-unit"> <span class="method-name">unit</span><span class="method-args">(n)</span> </div>  <div class="aliases"> Alias for: <a href="matrix#method-c-identity">identity</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-vstack"> <span class="method-name">vstack</span><span class="method-args">(x, *matrices)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="vstack-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 241
def Matrix.vstack(x, *matrices)
  x = CoercionHelper.coerce_to_matrix(x)
  result = x.send(:rows).map(&amp;:dup)
  matrices.each do |m|
    m = CoercionHelper.coerce_to_matrix(m)
    if m.column_count != x.column_count
      raise ErrDimensionMismatch, "The given matrices must have #{x.column_count} columns, but one has #{m.column_count}"
    end
    result.concat(m.send(:rows))
  end
  new result, x.column_count
end</pre> </div> <p>Create a matrix by stacking matrices vertically</p> <pre class="ruby" data-language="ruby">x = Matrix[[1, 2], [3, 4]]
y = Matrix[[5, 6], [7, 8]]
Matrix.vstack(x, y) # =&gt; Matrix[[1, 2], [3, 4], [5, 6], [7, 8]]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-zero"> <span class="method-name">zero</span><span class="method-args">(row_count, column_count = row_count)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="zero-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 185
def Matrix.zero(row_count, column_count = row_count)
  rows = Array.new(row_count){Array.new(column_count, 0)}
  new rows, column_count
end</pre> </div> <p>Creates a zero matrix.</p> <pre class="ruby" data-language="ruby">Matrix.zero(2)
#  =&gt; 0 0
#     0 0
</pre>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-2A"> <span class="method-name">*</span><span class="method-args">(m)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="2A-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1058
def *(m) # m is matrix or vector or number
  case(m)
  when Numeric
    new_rows = @rows.collect {|row|
      row.collect {|e| e * m }
    }
    return new_matrix new_rows, column_count
  when Vector
    m = self.class.column_vector(m)
    r = self * m
    return r.column(0)
  when Matrix
    raise ErrDimensionMismatch if column_count != m.row_count
    m_rows = m.rows
    new_rows = rows.map do |row_i|
      Array.new(m.column_count) do |j|
        vij = 0
        column_count.times do |k|
          vij += row_i[k] * m_rows[k][j]
        end
        vij
      end
    end
    return new_matrix new_rows, m.column_count
  else
    return apply_through_coercion(m, __method__)
  end
end</pre> </div> <p><a href="matrix"><code>Matrix</code></a> multiplication.</p> <pre class="ruby" data-language="ruby">Matrix[[2,4], [6,8]] * Matrix.identity(2)
#  =&gt; 2 4
#     6 8
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-2A-2A"> <span class="method-name">**</span><span class="method-args">(exp)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="2A-2A-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1237
def **(exp)
  case exp
  when Integer
    case
    when exp == 0
      _make_sure_it_is_invertible = inverse
      self.class.identity(column_count)
    when exp &lt; 0
      inverse.power_int(-exp)
    else
      power_int(exp)
    end
  when Numeric
    v, d, v_inv = eigensystem
    v * self.class.diagonal(*d.each(:diagonal).map{|e| e ** exp}) * v_inv
  else
    raise ErrOperationNotDefined, ["**", self.class, exp.class]
  end
end</pre> </div> <p><a href="matrix"><code>Matrix</code></a> exponentiation. Equivalent to multiplying the matrix by itself N times. Non integer exponents will be handled by diagonalizing the matrix.</p> <pre class="ruby" data-language="ruby">Matrix[[7,6], [3,9]] ** 2
#  =&gt; 67 96
#     48 99
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-2B"> <span class="method-name">+</span><span class="method-args">(m)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="2B-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1093
def +(m)
  case m
  when Numeric
    raise ErrOperationNotDefined, ["+", self.class, m.class]
  when Vector
    m = self.class.column_vector(m)
  when Matrix
  else
    return apply_through_coercion(m, __method__)
  end

  raise ErrDimensionMismatch unless row_count == m.row_count &amp;&amp; column_count == m.column_count

  rows = Array.new(row_count) {|i|
    Array.new(column_count) {|j|
      self[i, j] + m[i, j]
    }
  }
  new_matrix rows, column_count
end</pre> </div> <p><a href="matrix"><code>Matrix</code></a> addition.</p> <pre class="ruby" data-language="ruby">Matrix.scalar(2,5) + Matrix[[1,0], [-4,7]]
#  =&gt;  6  0
#     -4 12
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-2B-40"> <span class="method-name">+@</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="2B-40-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1283
def +@
  self
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-2D"> <span class="method-name">-</span><span class="method-args">(m)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="2D-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1120
def -(m)
  case m
  when Numeric
    raise ErrOperationNotDefined, ["-", self.class, m.class]
  when Vector
    m = self.class.column_vector(m)
  when Matrix
  else
    return apply_through_coercion(m, __method__)
  end

  raise ErrDimensionMismatch unless row_count == m.row_count &amp;&amp; column_count == m.column_count

  rows = Array.new(row_count) {|i|
    Array.new(column_count) {|j|
      self[i, j] - m[i, j]
    }
  }
  new_matrix rows, column_count
end</pre> </div> <p><a href="matrix"><code>Matrix</code></a> subtraction.</p> <pre class="ruby" data-language="ruby">Matrix[[1,5], [4,2]] - Matrix[[9,3], [-4,1]]
#  =&gt; -8  2
#      8  1
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-2D-40"> <span class="method-name">-@</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="2D-40-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1292
def -@
  collect {|e| -e }
end</pre> </div> <p>Unary matrix negation.</p> <pre class="ruby" data-language="ruby">-Matrix[[1,5], [4,2]]
# =&gt; -1 -5
#    -4 -2
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-2F"> <span class="method-name">/</span><span class="method-args">(other)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="2F-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1147
def /(other)
  case other
  when Numeric
    rows = @rows.collect {|row|
      row.collect {|e| e / other }
    }
    return new_matrix rows, column_count
  when Matrix
    return self * other.inverse
  else
    return apply_through_coercion(other, __method__)
  end
end</pre> </div> <p><a href="matrix"><code>Matrix</code></a> division (multiplication by the inverse).</p> <pre class="ruby" data-language="ruby">Matrix[[7,6], [3,9]] / Matrix[[2,9], [3,1]]
#  =&gt; -7  1
#     -3 -6
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3D-3D"> <span class="method-name">==</span><span class="method-args">(other)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1021
def ==(other)
  return false unless Matrix === other &amp;&amp;
                      column_count == other.column_count # necessary for empty matrices
  rows == other.rows
end</pre> </div> <p>Returns <code>true</code> if and only if the two matrices contain equal elements.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-5B-5D"> <span class="method-name">[]</span><span class="method-args">(i, j)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 337
def [](i, j)
  @rows.fetch(i){return nil}[j]
end</pre> </div> <p>Returns element (<code>i</code>,<code>j</code>) of the matrix. That is: row <code>i</code>, column <code>j</code>.</p>  </div> <div class="aliases"> Also aliased as: <a href="matrix#method-i-element">element</a>, <a href="matrix#method-i-component">component</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-5B-5D-3D"> <span class="method-callseq"> matrix[range, range] = matrix/element </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> matrix[range, integer] = vector/column_matrix/element </span> </div> <div class="method-heading"> <span class="method-callseq"> matrix[integer, range] = vector/row_matrix/element </span> </div> <div class="method-heading"> <span class="method-callseq"> matrix[integer, integer] = element </span> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-3D-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 351
def []=(i, j, v)
  raise FrozenError, "can't modify frozen Matrix" if frozen?
  rows = check_range(i, :row) or row = check_int(i, :row)
  columns = check_range(j, :column) or column = check_int(j, :column)
  if rows &amp;&amp; columns
    set_row_and_col_range(rows, columns, v)
  elsif rows
    set_row_range(rows, column, v)
  elsif columns
    set_col_range(row, columns, v)
  else
    set_value(row, column, v)
  end
end</pre> </div> <p><a href="set"><code>Set</code></a> element or elements of matrix.</p>  </div> <div class="aliases"> Also aliased as: <a href="matrix#method-i-set_element">set_element</a>, <a href="matrix#method-i-set_component">set_component</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-abs"> <span class="method-name">abs</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="abs-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1299
def abs
  collect(&amp;:abs)
end</pre> </div> <p>Returns the absolute value elementwise</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-adjoint"> <span class="method-name">adjoint</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="adjoint-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1566
def adjoint
  conjugate.transpose
end</pre> </div> <p>Returns the adjoint of the matrix.</p> <pre class="ruby" data-language="ruby">Matrix[ [i,1],[2,-i] ].adjoint
#  =&gt; -i 2
#      1 i
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-adjugate"> <span class="method-name">adjugate</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="adjugate-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 793
def adjugate
  raise ErrDimensionMismatch unless square?
  Matrix.build(row_count, column_count) do |row, column|
    cofactor(column, row)
  end
end</pre> </div> <p>Returns the adjugate of the matrix.</p> <pre class="ruby" data-language="ruby">Matrix[ [7,6],[3,9] ].adjugate
#  =&gt; 9 -6
#     -3 7
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-antisymmetric-3F"> <span class="method-name">antisymmetric?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="antisymmetric-3F-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 973
def antisymmetric?
  raise ErrDimensionMismatch unless square?
  each_with_index(:upper) do |e, row, col|
    return false unless e == -rows[col][row]
  end
  true
end</pre> </div> <p>Returns <code>true</code> if this is an antisymmetric matrix. Raises an error if matrix is not square.</p>  </div> <div class="aliases"> Also aliased as: <a href="matrix#method-i-skew_symmetric-3F">skew_symmetric?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-coerce"> <span class="method-name">coerce</span><span class="method-args">(other)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="coerce-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1619
def coerce(other)
  case other
  when Numeric
    return Scalar.new(other), self
  else
    raise TypeError, "#{self.class} can't be coerced into #{other.class}"
  end
end</pre> </div> <p>The coerce method provides support for Ruby type coercion. This coercion mechanism is used by Ruby to handle mixed-type numeric operations: it is intended to find a compatible common type between the two operands of the operator. See also <a href="numeric#method-i-coerce"><code>Numeric#coerce</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-cofactor"> <span class="method-name">cofactor</span><span class="method-args">(row, column)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="cofactor-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 778
def cofactor(row, column)
  raise RuntimeError, "cofactor of empty matrix is not defined" if empty?
  raise ErrDimensionMismatch unless square?

  det_of_minor = first_minor(row, column).determinant
  det_of_minor * (-1) ** (row + column)
end</pre> </div> <p>Returns the (row, column) cofactor which is obtained by multiplying the first minor by (-1)**(row + column).</p> <pre class="ruby" data-language="ruby">Matrix.diagonal(9, 5, -3, 4).cofactor(1, 1)
#  =&gt; -108
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-cofactor_expansion"> <span class="method-name">cofactor_expansion</span><span class="method-args">(row: nil, column: nil)</span> </div>  <div class="aliases"> Alias for: <a href="matrix#method-i-laplace_expansion">laplace_expansion</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-collect"> <span class="method-name">collect</span><span class="method-args">(which = :all) { |e| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="collect-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 508
def collect(which = :all, &amp;block) # :yield: e
  return to_enum(:collect, which) unless block_given?
  dup.collect!(which, &amp;block)
end</pre> </div> <p>Returns a matrix that is the result of iteration of the given block over all elements of the matrix. Elements can be restricted by passing an argument:</p> <ul>
<li> <p>:all (default): yields all elements</p> </li>
<li> <p>:diagonal: yields only elements on the diagonal</p> </li>
<li> <p>:off_diagonal: yields all elements except on the diagonal</p> </li>
<li> <p>:lower: yields only elements on or below the diagonal</p> </li>
<li> <p>:strict_lower: yields only elements below the diagonal</p> </li>
<li> <p>:strict_upper: yields only elements above the diagonal</p> </li>
<li> <p>:upper: yields only elements on or above the diagonal Matrix[ [1,2], [3,4] ].collect { |e| e**2 } # =&gt; 1 4 # 9 16</p> </li>
</ul>  </div> <div class="aliases"> Also aliased as: <a href="matrix#method-i-map">map</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-collect-21"> <span class="method-name">collect!</span><span class="method-args">(which = :all) { |e| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="collect-21-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 526
def collect!(which = :all)
  return to_enum(:collect!, which) unless block_given?
  raise FrozenError, "can't modify frozen Matrix" if frozen?
  each_with_index(which){ |e, row_index, col_index| @rows[row_index][col_index] = yield e }
end</pre> </div> <p>Invokes the given block for each element of matrix, replacing the element with the value returned by the block. Elements can be restricted by passing an argument:</p> <ul>
<li> <p>:all (default): yields all elements</p> </li>
<li> <p>:diagonal: yields only elements on the diagonal</p> </li>
<li> <p>:off_diagonal: yields all elements except on the diagonal</p> </li>
<li> <p>:lower: yields only elements on or below the diagonal</p> </li>
<li> <p>:strict_lower: yields only elements below the diagonal</p> </li>
<li> <p>:strict_upper: yields only elements above the diagonal</p> </li>
<li> <p>:upper: yields only elements on or above the diagonal</p> </li>
</ul>  </div> <div class="aliases"> Also aliased as: <a href="matrix#method-i-map-21">map!</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-column"> <span class="method-name">column</span><span class="method-args">(j) { |e| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="column-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 477
def column(j) # :yield: e
  if block_given?
    return self if j &gt;= column_count || j &lt; -column_count
    row_count.times do |i|
      yield @rows[i][j]
    end
    self
  else
    return nil if j &gt;= column_count || j &lt; -column_count
    col = Array.new(row_count) {|i|
      @rows[i][j]
    }
    Vector.elements(col, false)
  end
end</pre> </div> <p>Returns column vector number <code>j</code> of the matrix as a <a href="vector"><code>Vector</code></a> (starting at 0 like an array). When a block is given, the elements of that vector are iterated.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-column_vectors"> <span class="method-name">column_vectors</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="column_vectors-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1640
def column_vectors
  Array.new(column_count) {|i|
    column(i)
  }
end</pre> </div> <p>Returns an array of the column vectors of the matrix. See <a href="vector"><code>Vector</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-combine"> <span class="method-callseq"> combine(*other_matrices) { |*elements| ... } </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="combine-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 315
def combine(*matrices, &amp;block)
  Matrix.combine(self, *matrices, &amp;block)
end</pre> </div> <p>Creates new matrix by combining with <em>other_matrices</em> entrywise, using the given block.</p> <pre class="ruby" data-language="ruby">x = Matrix[[6, 6], [4, 4]]
y = Matrix[[1, 2], [3, 4]]
x.combine(y) {|a, b| a - b} # =&gt; Matrix[[5, 4], [1, 0]]
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-component"> <span class="method-name">component</span><span class="method-args">(i, j)</span> </div>  <div class="aliases"> Alias for: <a href="matrix#method-i-5B-5D">[]</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-conj"> <span class="method-name">conj</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="matrix#method-i-conjugate">conjugate</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-conjugate"> <span class="method-name">conjugate</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="conjugate-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1554
def conjugate
  collect(&amp;:conjugate)
end</pre> </div> <p>Returns the conjugate of the matrix.</p> <pre class="ruby" data-language="ruby">Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]]
#  =&gt; 1+2i   i  0
#        1   2  3
Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]].conjugate
#  =&gt; 1-2i  -i  0
#        1   2  3
</pre>  </div> <div class="aliases"> Also aliased as: <a href="matrix#method-i-conj">conj</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-det"> <span class="method-name">det</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="matrix#method-i-determinant">determinant</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-det_e"> <span class="method-name">det_e</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="matrix#method-i-determinant_e">determinant_e</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-determinant"> <span class="method-name">determinant</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="determinant-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1317
def determinant
  raise ErrDimensionMismatch unless square?
  m = @rows
  case row_count
    # Up to 4x4, give result using Laplacian expansion by minors.
    # This will typically be faster, as well as giving good results
    # in case of Floats
  when 0
    +1
  when 1
    + m[0][0]
  when 2
    + m[0][0] * m[1][1] - m[0][1] * m[1][0]
  when 3
    m0, m1, m2 = m
    + m0[0] * m1[1] * m2[2] - m0[0] * m1[2] * m2[1] \
    - m0[1] * m1[0] * m2[2] + m0[1] * m1[2] * m2[0] \
    + m0[2] * m1[0] * m2[1] - m0[2] * m1[1] * m2[0]
  when 4
    m0, m1, m2, m3 = m
    + m0[0] * m1[1] * m2[2] * m3[3] - m0[0] * m1[1] * m2[3] * m3[2] \
    - m0[0] * m1[2] * m2[1] * m3[3] + m0[0] * m1[2] * m2[3] * m3[1] \
    + m0[0] * m1[3] * m2[1] * m3[2] - m0[0] * m1[3] * m2[2] * m3[1] \
    - m0[1] * m1[0] * m2[2] * m3[3] + m0[1] * m1[0] * m2[3] * m3[2] \
    + m0[1] * m1[2] * m2[0] * m3[3] - m0[1] * m1[2] * m2[3] * m3[0] \
    - m0[1] * m1[3] * m2[0] * m3[2] + m0[1] * m1[3] * m2[2] * m3[0] \
    + m0[2] * m1[0] * m2[1] * m3[3] - m0[2] * m1[0] * m2[3] * m3[1] \
    - m0[2] * m1[1] * m2[0] * m3[3] + m0[2] * m1[1] * m2[3] * m3[0] \
    + m0[2] * m1[3] * m2[0] * m3[1] - m0[2] * m1[3] * m2[1] * m3[0] \
    - m0[3] * m1[0] * m2[1] * m3[2] + m0[3] * m1[0] * m2[2] * m3[1] \
    + m0[3] * m1[1] * m2[0] * m3[2] - m0[3] * m1[1] * m2[2] * m3[0] \
    - m0[3] * m1[2] * m2[0] * m3[1] + m0[3] * m1[2] * m2[1] * m3[0]
  else
    # For bigger matrices, use an efficient and general algorithm.
    # Currently, we use the Gauss-Bareiss algorithm
    determinant_bareiss
  end
end</pre> </div> <p>Returns the determinant of the matrix.</p> <p>Beware that using <a href="float"><code>Float</code></a> values can yield erroneous results because of their lack of precision. Consider using exact types like <a href="rational"><code>Rational</code></a> or <a href="bigdecimal"><code>BigDecimal</code></a> instead.</p> <pre class="ruby" data-language="ruby">Matrix[[7,6], [3,9]].determinant
#  =&gt; 45
</pre>  </div> <div class="aliases"> Also aliased as: <a href="matrix#method-i-det">det</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-determinant_e"> <span class="method-name">determinant_e</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="determinant_e-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1398
def determinant_e
  warn "Matrix#determinant_e is deprecated; use #determinant", uplevel: 1
  determinant
end</pre> </div> <p>deprecated; use <a href="matrix#method-i-determinant"><code>Matrix#determinant</code></a></p>  </div> <div class="aliases"> Also aliased as: <a href="matrix#method-i-det_e">det_e</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-diagonal-3F"> <span class="method-name">diagonal?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="diagonal-3F-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 839
def diagonal?
  raise ErrDimensionMismatch unless square?
  each(:off_diagonal).all?(&amp;:zero?)
end</pre> </div> <p>Returns <code>true</code> if this is a diagonal matrix. Raises an error if matrix is not square.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each"> <span class="method-name">each</span><span class="method-args">(which = :all) { |e| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="each-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 556
def each(which = :all, &amp;block) # :yield: e
  return to_enum :each, which unless block_given?
  last = column_count - 1
  case which
  when :all
    @rows.each do |row|
      row.each(&amp;block)
    end
  when :diagonal
    @rows.each_with_index do |row, row_index|
      yield row.fetch(row_index){return self}
    end
  when :off_diagonal
    @rows.each_with_index do |row, row_index|
      column_count.times do |col_index|
        yield row[col_index] unless row_index == col_index
      end
    end
  when :lower
    @rows.each_with_index do |row, row_index|
      0.upto([row_index, last].min) do |col_index|
        yield row[col_index]
      end
    end
  when :strict_lower
    @rows.each_with_index do |row, row_index|
      [row_index, column_count].min.times do |col_index|
        yield row[col_index]
      end
    end
  when :strict_upper
    @rows.each_with_index do |row, row_index|
      (row_index+1).upto(last) do |col_index|
        yield row[col_index]
      end
    end
  when :upper
    @rows.each_with_index do |row, row_index|
      row_index.upto(last) do |col_index|
        yield row[col_index]
      end
    end
  else
    raise ArgumentError, "expected #{which.inspect} to be one of :all, :diagonal, :off_diagonal, :lower, :strict_lower, :strict_upper or :upper"
  end
  self
end</pre> </div> <p>Yields all elements of the matrix, starting with those of the first row, or returns an <a href="enumerator"><code>Enumerator</code></a> if no block given. Elements can be restricted by passing an argument:</p> <ul>
<li> <p>:all (default): yields all elements</p> </li>
<li> <p>:diagonal: yields only elements on the diagonal</p> </li>
<li> <p>:off_diagonal: yields all elements except on the diagonal</p> </li>
<li> <p>:lower: yields only elements on or below the diagonal</p> </li>
<li> <p>:strict_lower: yields only elements below the diagonal</p> </li>
<li> <p>:strict_upper: yields only elements above the diagonal</p> </li>
<li> <p>:upper: yields only elements on or above the diagonal</p> <pre class="ruby" data-language="ruby">Matrix[ [1,2], [3,4] ].each { |e| puts e }
  # =&gt; prints the numbers 1 to 4
Matrix[ [1,2], [3,4] ].each(:strict_lower).to_a # =&gt; [3]
</pre> </li>
</ul>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_with_index"> <span class="method-name">each_with_index</span><span class="method-args">(which = :all) { |e, row, column| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="each_with_index-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 616
def each_with_index(which = :all) # :yield: e, row, column
  return to_enum :each_with_index, which unless block_given?
  last = column_count - 1
  case which
  when :all
    @rows.each_with_index do |row, row_index|
      row.each_with_index do |e, col_index|
        yield e, row_index, col_index
      end
    end
  when :diagonal
    @rows.each_with_index do |row, row_index|
      yield row.fetch(row_index){return self}, row_index, row_index
    end
  when :off_diagonal
    @rows.each_with_index do |row, row_index|
      column_count.times do |col_index|
        yield row[col_index], row_index, col_index unless row_index == col_index
      end
    end
  when :lower
    @rows.each_with_index do |row, row_index|
      0.upto([row_index, last].min) do |col_index|
        yield row[col_index], row_index, col_index
      end
    end
  when :strict_lower
    @rows.each_with_index do |row, row_index|
      [row_index, column_count].min.times do |col_index|
        yield row[col_index], row_index, col_index
      end
    end
  when :strict_upper
    @rows.each_with_index do |row, row_index|
      (row_index+1).upto(last) do |col_index|
        yield row[col_index], row_index, col_index
      end
    end
  when :upper
    @rows.each_with_index do |row, row_index|
      row_index.upto(last) do |col_index|
        yield row[col_index], row_index, col_index
      end
    end
  else
    raise ArgumentError, "expected #{which.inspect} to be one of :all, :diagonal, :off_diagonal, :lower, :strict_lower, :strict_upper or :upper"
  end
  self
end</pre> </div> <p>Same as <a href="matrix#method-i-each"><code>each</code></a>, but the row index and column index in addition to the element</p> <pre class="ruby" data-language="ruby">Matrix[ [1,2], [3,4] ].each_with_index do |e, row, col|
  puts "#{e} at #{row}, #{col}"
end
  # =&gt; Prints:
  #    1 at 0, 0
  #    2 at 0, 1
  #    3 at 1, 0
  #    4 at 1, 1
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-eigen"> <span class="method-name">eigen</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="matrix#method-i-eigensystem">eigensystem</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-eigensystem"> <span class="method-name">eigensystem</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="eigensystem-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1521
def eigensystem
  EigenvalueDecomposition.new(self)
end</pre> </div> <p>Returns the Eigensystem of the matrix; see <code>EigenvalueDecomposition</code>.</p> <pre class="ruby" data-language="ruby">m = Matrix[[1, 2], [3, 4]]
v, d, v_inv = m.eigensystem
d.diagonal? # =&gt; true
v.inv == v_inv # =&gt; true
(v * d * v_inv).round(5) == m # =&gt; true
</pre>  </div> <div class="aliases"> Also aliased as: <a href="matrix#method-i-eigen">eigen</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-element"> <span class="method-name">element</span><span class="method-args">(i, j)</span> </div>  <div class="aliases"> Alias for: <a href="matrix#method-i-5B-5D">[]</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-elements_to_f"> <span class="method-name">elements_to_f</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="elements_to_f-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1663
def elements_to_f
  warn "Matrix#elements_to_f is deprecated, use map(&amp;:to_f)", uplevel: 1
  map(&amp;:to_f)
end</pre> </div> <p>Deprecated.</p> <p>Use <code>map(&amp;:to_f)</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-elements_to_i"> <span class="method-name">elements_to_i</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="elements_to_i-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1671
def elements_to_i
  warn "Matrix#elements_to_i is deprecated, use map(&amp;:to_i)", uplevel: 1
  map(&amp;:to_i)
end</pre> </div> <p>Deprecated.</p> <p>Use <code>map(&amp;:to_i)</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-elements_to_r"> <span class="method-name">elements_to_r</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="elements_to_r-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1679
def elements_to_r
  warn "Matrix#elements_to_r is deprecated, use map(&amp;:to_r)", uplevel: 1
  map(&amp;:to_r)
end</pre> </div> <p>Deprecated.</p> <p>Use <code>map(&amp;:to_r)</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-empty-3F"> <span class="method-name">empty?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="empty-3F-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 848
def empty?
  column_count == 0 || row_count == 0
end</pre> </div> <p>Returns <code>true</code> if this is an empty matrix, i.e. if the number of rows or the number of columns is 0.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-entrywise_product"> <span class="method-name">entrywise_product</span><span class="method-args">(m)</span> </div>  <div class="aliases"> Alias for: <a href="matrix#method-i-hadamard_product">hadamard_product</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-eql-3F"> <span class="method-name">eql?</span><span class="method-args">(other)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="eql-3F-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1027
def eql?(other)
  return false unless Matrix === other &amp;&amp;
                      column_count == other.column_count # necessary for empty matrices
  rows.eql? other.rows
end</pre> </div>  </div> </div> <div id="method-i-find_index" class="method-detail method-alias">  <div class="aliases"> Alias for: <a href="matrix#method-i-index">index</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-first_minor"> <span class="method-name">first_minor</span><span class="method-args">(row, column)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="first_minor-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 751
def first_minor(row, column)
  raise RuntimeError, "first_minor of empty matrix is not defined" if empty?

  unless 0 &lt;= row &amp;&amp; row &lt; row_count
    raise ArgumentError, "invalid row (#{row.inspect} for 0..#{row_count - 1})"
  end

  unless 0 &lt;= column &amp;&amp; column &lt; column_count
    raise ArgumentError, "invalid column (#{column.inspect} for 0..#{column_count - 1})"
  end

  arrays = to_a
  arrays.delete_at(row)
  arrays.each do |array|
    array.delete_at(column)
  end

  new_matrix arrays, column_count - 1
end</pre> </div> <p>Returns the submatrix obtained by deleting the specified row and column.</p> <pre class="ruby" data-language="ruby">Matrix.diagonal(9, 5, -3, 4).first_minor(1, 2)
#  =&gt; 9 0 0
#     0 0 0
#     0 0 4
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-freeze"> <span class="method-name">freeze</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="freeze-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 534
def freeze
  @rows.each(&amp;:freeze).freeze

  super
end</pre> </div> <div class="method-calls-super"> Calls superclass method <a href="object#method-i-freeze"><code>Object#freeze</code></a> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-hadamard_product"> <span class="method-name">hadamard_product</span><span class="method-args">(m)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="hadamard_product-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1167
def hadamard_product(m)
  combine(m){|a, b| a * b}
end</pre> </div> <p>Hadamard product</p> <pre class="ruby" data-language="ruby">Matrix[[1,2], [3,4]].hadamard_product(Matrix[[1,2], [3,2]])
#  =&gt; 1  4
#     9  8
</pre>  </div> <div class="aliases"> Also aliased as: <a href="matrix#method-i-entrywise_product">entrywise_product</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-hash"> <span class="method-name">hash</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="hash-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1044
def hash
  @rows.hash
end</pre> </div> <p>Returns a hash-code for the matrix.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-hermitian-3F"> <span class="method-name">hermitian?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="hermitian-3F-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 856
def hermitian?
  raise ErrDimensionMismatch unless square?
  each_with_index(:upper).all? do |e, row, col|
    e == rows[col][row].conj
  end
end</pre> </div> <p>Returns <code>true</code> if this is an hermitian matrix. Raises an error if matrix is not square.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-hstack"> <span class="method-name">hstack</span><span class="method-args">(*matrices)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="hstack-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1412
def hstack(*matrices)
  self.class.hstack(self, *matrices)
end</pre> </div> <p>Returns a new matrix resulting by stacking horizontally the receiver with the given matrices</p> <pre class="ruby" data-language="ruby">x = Matrix[[1, 2], [3, 4]]
y = Matrix[[5, 6], [7, 8]]
x.hstack(y) # =&gt; Matrix[[1, 2, 5, 6], [3, 4, 7, 8]]
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-imag"> <span class="method-name">imag</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="matrix#method-i-imaginary">imaginary</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-imaginary"> <span class="method-name">imaginary</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="imaginary-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1579
def imaginary
  collect(&amp;:imaginary)
end</pre> </div> <p>Returns the imaginary part of the matrix.</p> <pre class="ruby" data-language="ruby">Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]]
#  =&gt; 1+2i  i  0
#        1  2  3
Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]].imaginary
#  =&gt;   2i  i  0
#        0  0  0
</pre>  </div> <div class="aliases"> Also aliased as: <a href="matrix#method-i-imag">imag</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-index"> <span class="method-callseq"> index(value, selector = :all) → [row, column] </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> index(selector = :all){ block } → [row, column] </span> </div> <div class="method-heading"> <span class="method-callseq"> index(selector = :all) → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="index-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 679
def index(*args)
  raise ArgumentError, "wrong number of arguments(#{args.size} for 0-2)" if args.size &gt; 2
  which = (args.size == 2 || SELECTORS.include?(args.last)) ? args.pop : :all
  return to_enum :find_index, which, *args unless block_given? || args.size == 1
  if args.size == 1
    value = args.first
    each_with_index(which) do |e, row_index, col_index|
      return row_index, col_index if e == value
    end
  else
    each_with_index(which) do |e, row_index, col_index|
      return row_index, col_index if yield e
    end
  end
  nil
end</pre> </div> <p>The index method is specialized to return the index as [row, column] It also accepts an optional <code>selector</code> argument, see <a href="matrix#method-i-each"><code>each</code></a> for details.</p> <pre class="ruby" data-language="ruby">Matrix[ [1,2], [3,4] ].index(&amp;:even?) # =&gt; [0, 1]
Matrix[ [1,1], [1,1] ].index(1, :strict_lower) # =&gt; [1, 0]
</pre>  </div> <div class="aliases"> Also aliased as: <a href="matrix#method-i-find_index">find_index</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inspect"> <span class="method-name">inspect</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1704
def inspect
  if empty?
    "#{self.class}.empty(#{row_count}, #{column_count})"
  else
    "#{self.class}#{@rows.inspect}"
  end
end</pre> </div> <p>Overrides <a href="object#method-i-inspect"><code>Object#inspect</code></a></p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-inv"> <span class="method-name">inv</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="matrix#method-i-inverse">inverse</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inverse"> <span class="method-name">inverse</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="inverse-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1178
def inverse
  raise ErrDimensionMismatch unless square?
  self.class.I(row_count).send(:inverse_from, self)
end</pre> </div> <p>Returns the inverse of the matrix.</p> <pre class="ruby" data-language="ruby">Matrix[[-1, -1], [0, -1]].inverse
#  =&gt; -1  1
#      0 -1
</pre>  </div> <div class="aliases"> Also aliased as: <a href="matrix#method-i-inv">inv</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-laplace_expansion"> <span class="method-name">laplace_expansion</span><span class="method-args">(row: nil, column: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="laplace_expansion-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 810
def laplace_expansion(row: nil, column: nil)
  num = row || column

  if !num || (row &amp;&amp; column)
    raise ArgumentError, "exactly one the row or column arguments must be specified"
  end

  raise ErrDimensionMismatch unless square?
  raise RuntimeError, "laplace_expansion of empty matrix is not defined" if empty?

  unless 0 &lt;= num &amp;&amp; num &lt; row_count
    raise ArgumentError, "invalid num (#{num.inspect} for 0..#{row_count - 1})"
  end

  send(row ? :row : :column, num).map.with_index { |e, k|
    e * cofactor(*(row ? [num, k] : [k,num]))
  }.inject(:+)
end</pre> </div> <p>Returns the Laplace expansion along given row or column.</p> <pre class="ruby" data-language="ruby">Matrix[[7,6], [3,9]].laplace_expansion(column: 1)
# =&gt; 45

Matrix[[Vector[1, 0], Vector[0, 1]], [2, 3]].laplace_expansion(row: 0)
# =&gt; Vector[3, -2]
</pre>  </div> <div class="aliases"> Also aliased as: <a href="matrix#method-i-cofactor_expansion">cofactor_expansion</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-lower_triangular-3F"> <span class="method-name">lower_triangular?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="lower_triangular-3F-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 866
def lower_triangular?
  each(:strict_upper).all?(&amp;:zero?)
end</pre> </div> <p>Returns <code>true</code> if this is a lower triangular matrix.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-lup"> <span class="method-name">lup</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="lup-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1536
def lup
  LUPDecomposition.new(self)
end</pre> </div> <p>Returns the LUP decomposition of the matrix; see <code>LUPDecomposition</code>.</p> <pre class="ruby" data-language="ruby">a = Matrix[[1, 2], [3, 4]]
l, u, p = a.lup
l.lower_triangular? # =&gt; true
u.upper_triangular? # =&gt; true
p.permutation?      # =&gt; true
l * u == p * a      # =&gt; true
a.lup.solve([2, 5]) # =&gt; Vector[(1/1), (1/2)]
</pre>  </div> <div class="aliases"> Also aliased as: <a href="matrix#method-i-lup_decomposition">lup_decomposition</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-lup_decomposition"> <span class="method-name">lup_decomposition</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="matrix#method-i-lup">lup</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-map"> <span class="method-name">map</span><span class="method-args">(which = :all)</span> </div>  <div class="aliases"> Alias for: <a href="matrix#method-i-collect">collect</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-map-21"> <span class="method-name">map!</span><span class="method-args">(which = :all)</span> </div>  <div class="aliases"> Alias for: <a href="matrix#method-i-collect-21">collect!</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-minor"> <span class="method-name">minor</span><span class="method-args">(*param)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="minor-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 710
def minor(*param)
  case param.size
  when 2
    row_range, col_range = param
    from_row = row_range.first
    from_row += row_count if from_row &lt; 0
    to_row = row_range.end
    to_row += row_count if to_row &lt; 0
    to_row += 1 unless row_range.exclude_end?
    size_row = to_row - from_row

    from_col = col_range.first
    from_col += column_count if from_col &lt; 0
    to_col = col_range.end
    to_col += column_count if to_col &lt; 0
    to_col += 1 unless col_range.exclude_end?
    size_col = to_col - from_col
  when 4
    from_row, size_row, from_col, size_col = param
    return nil if size_row &lt; 0 || size_col &lt; 0
    from_row += row_count if from_row &lt; 0
    from_col += column_count if from_col &lt; 0
  else
    raise ArgumentError, param.inspect
  end

  return nil if from_row &gt; row_count || from_col &gt; column_count || from_row &lt; 0 || from_col &lt; 0
  rows = @rows[from_row, size_row].collect{|row|
    row[from_col, size_col]
  }
  new_matrix rows, [column_count - from_col, size_col].min
end</pre> </div> <p>Returns a section of the matrix. The parameters are either:</p> <ul>
<li> <p>start_row, nrows, start_col, ncols; OR</p> </li>
<li> <p>row_range, col_range</p> </li>
</ul> <pre class="ruby" data-language="ruby">Matrix.diagonal(9, 5, -3).minor(0..1, 0..2)
#  =&gt; 9 0 0
#     0 5 0
</pre> <p>Like <a href="array#method-i-5B-5D"><code>Array#[]</code></a>, negative indices count backward from the end of the row or column (-1 is the last element). Returns nil if the starting row or column is greater than <a href="matrix#method-i-row_count"><code>row_count</code></a> or <a href="matrix#attribute-i-column_count"><code>column_count</code></a> respectively.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-normal-3F"> <span class="method-name">normal?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="normal-3F-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 874
def normal?
  raise ErrDimensionMismatch unless square?
  rows.each_with_index do |row_i, i|
    rows.each_with_index do |row_j, j|
      s = 0
      rows.each_with_index do |row_k, k|
        s += row_i[k] * row_j[k].conj - row_k[i].conj * row_k[j]
      end
      return false unless s == 0
    end
  end
  true
end</pre> </div> <p>Returns <code>true</code> if this is a normal matrix. Raises an error if matrix is not square.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-orthogonal-3F"> <span class="method-name">orthogonal?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="orthogonal-3F-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 892
def orthogonal?
  raise ErrDimensionMismatch unless square?

  rows.each_with_index do |row_i, i|
    rows.each_with_index do |row_j, j|
      s = 0
      row_count.times do |k|
        s += row_i[k] * row_j[k]
      end
      return false unless s == (i == j ? 1 : 0)
    end
  end
  true
end</pre> </div> <p>Returns <code>true</code> if this is an orthogonal matrix Raises an error if matrix is not square.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-permutation-3F"> <span class="method-name">permutation?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="permutation-3F-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 911
def permutation?
  raise ErrDimensionMismatch unless square?
  cols = Array.new(column_count)
  rows.each_with_index do |row, i|
    found = false
    row.each_with_index do |e, j|
      if e == 1
        return false if found || cols[j]
        found = cols[j] = true
      elsif e != 0
        return false
      end
    end
    return false unless found
  end
  true
end</pre> </div> <p>Returns <code>true</code> if this is a permutation matrix Raises an error if matrix is not square.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rank"> <span class="method-name">rank</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rank-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1425
def rank
  # We currently use Bareiss' multistep integer-preserving gaussian elimination
  # (see comments on determinant)
  a = to_a
  last_column = column_count - 1
  last_row = row_count - 1
  pivot_row = 0
  previous_pivot = 1
  0.upto(last_column) do |k|
    switch_row = (pivot_row .. last_row).find {|row|
      a[row][k] != 0
    }
    if switch_row
      a[switch_row], a[pivot_row] = a[pivot_row], a[switch_row] unless pivot_row == switch_row
      pivot = a[pivot_row][k]
      (pivot_row+1).upto(last_row) do |i|
         ai = a[i]
         (k+1).upto(last_column) do |j|
           ai[j] =  (pivot * ai[j] - ai[k] * a[pivot_row][j]) / previous_pivot
         end
       end
      pivot_row += 1
      previous_pivot = pivot
    end
  end
  pivot_row
end</pre> </div> <p>Returns the rank of the matrix. Beware that using <a href="float"><code>Float</code></a> values can yield erroneous results because of their lack of precision. Consider using exact types like <a href="rational"><code>Rational</code></a> or <a href="bigdecimal"><code>BigDecimal</code></a> instead.</p> <pre class="ruby" data-language="ruby">Matrix[[7,6], [3,9]].rank
#  =&gt; 2
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rank_e"> <span class="method-name">rank_e</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rank_e-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1456
def rank_e
  warn "Matrix#rank_e is deprecated; use #rank", uplevel: 1
  rank
end</pre> </div> <p>deprecated; use <a href="matrix#method-i-rank"><code>Matrix#rank</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-real"> <span class="method-name">real</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="real-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1593
def real
  collect(&amp;:real)
end</pre> </div> <p>Returns the real part of the matrix.</p> <pre class="ruby" data-language="ruby">Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]]
#  =&gt; 1+2i  i  0
#        1  2  3
Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]].real
#  =&gt;    1  0  0
#        1  2  3
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-real-3F"> <span class="method-name">real?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="real-3F-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 932
def real?
  all?(&amp;:real?)
end</pre> </div> <p>Returns <code>true</code> if all entries of the matrix are real.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rect"> <span class="method-name">rect</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rect-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1603
def rect
  [real, imag]
end</pre> </div> <p>Returns an array containing matrices corresponding to the real and imaginary parts of the matrix</p> <pre class="ruby" data-language="ruby">m.rect == [m.real, m.imag]  # ==&gt; true for all matrices m
</pre>  </div> <div class="aliases"> Also aliased as: <a href="matrix#method-i-rectangular">rectangular</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-rectangular"> <span class="method-name">rectangular</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="matrix#method-i-rect">rect</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-regular-3F"> <span class="method-name">regular?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="regular-3F-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 939
def regular?
  not singular?
end</pre> </div> <p>Returns <code>true</code> if this is a regular (i.e. non-singular) matrix.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-round"> <span class="method-name">round</span><span class="method-args">(ndigits=0)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="round-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1464
def round(ndigits=0)
  map{|e| e.round(ndigits)}
end</pre> </div> <p>Returns a matrix with entries rounded to the given precision (see <a href="float#method-i-round"><code>Float#round</code></a>)</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-row"> <span class="method-name">row</span><span class="method-args">(i) { |e| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="row-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 463
def row(i, &amp;block) # :yield: e
  if block_given?
    @rows.fetch(i){return self}.each(&amp;block)
    self
  else
    Vector.elements(@rows.fetch(i){return nil})
  end
end</pre> </div> <p>Returns row vector number <code>i</code> of the matrix as a <a href="vector"><code>Vector</code></a> (starting at 0 like an array). When a block is given, the elements of that vector are iterated.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-row_count"> <span class="method-name">row_count</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="row_count-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 448
def row_count
  @rows.size
end</pre> </div> <p>Returns the number of rows.</p>  </div> <div class="aliases"> Also aliased as: <a href="matrix#method-i-row_size">row_size</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-row_size"> <span class="method-name">row_size</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="matrix#method-i-row_count">row_count</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-row_vectors"> <span class="method-name">row_vectors</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="row_vectors-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1631
def row_vectors
  Array.new(row_count) {|i|
    row(i)
  }
end</pre> </div> <p>Returns an array of the row vectors of the matrix. See <a href="vector"><code>Vector</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-singular-3F"> <span class="method-name">singular?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="singular-3F-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 946
def singular?
  determinant == 0
end</pre> </div> <p>Returns <code>true</code> if this is a singular matrix.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-skew_symmetric-3F"> <span class="method-name">skew_symmetric?</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="matrix#method-i-antisymmetric-3F">antisymmetric?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-square-3F"> <span class="method-name">square?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="square-3F-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 953
def square?
  column_count == row_count
end</pre> </div> <p>Returns <code>true</code> if this is a square matrix.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-symmetric-3F"> <span class="method-name">symmetric?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="symmetric-3F-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 961
def symmetric?
  raise ErrDimensionMismatch unless square?
  each_with_index(:strict_upper) do |e, row, col|
    return false if e != rows[col][row]
  end
  true
end</pre> </div> <p>Returns <code>true</code> if this is a symmetric matrix. Raises an error if matrix is not square.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-t"> <span class="method-name">t</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="matrix#method-i-transpose">transpose</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_a"> <span class="method-name">to_a</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_a-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1656
def to_a
  @rows.collect(&amp;:dup)
end</pre> </div> <p>Returns an array of arrays that describe the rows of the matrix.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_matrix"> <span class="method-name">to_matrix</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_matrix-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1649
def to_matrix
  self
end</pre> </div> <p>Explicit conversion to a <a href="matrix"><code>Matrix</code></a>. Returns self</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_s"> <span class="method-name">to_s</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_s-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1691
def to_s
  if empty?
    "#{self.class}.empty(#{row_count}, #{column_count})"
  else
    "#{self.class}[" + @rows.collect{|row|
      "[" + row.collect{|e| e.to_s}.join(", ") + "]"
    }.join(", ")+"]"
  end
end</pre> </div> <p>Overrides <a href="object#method-i-to_s"><code>Object#to_s</code></a></p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-tr"> <span class="method-name">tr</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="matrix#method-i-trace">trace</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-trace"> <span class="method-name">trace</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="trace-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1473
def trace
  raise ErrDimensionMismatch unless square?
  (0...column_count).inject(0) do |tr, i|
    tr + @rows[i][i]
  end
end</pre> </div> <p>Returns the trace (sum of diagonal elements) of the matrix.</p> <pre class="ruby" data-language="ruby">Matrix[[7,6], [3,9]].trace
#  =&gt; 16
</pre>  </div> <div class="aliases"> Also aliased as: <a href="matrix#method-i-tr">tr</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-transpose"> <span class="method-name">transpose</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="transpose-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1491
def transpose
  return self.class.empty(column_count, 0) if row_count.zero?
  new_matrix @rows.transpose, row_count
end</pre> </div> <p>Returns the transpose of the matrix.</p> <pre class="ruby" data-language="ruby">Matrix[[1,2], [3,4], [5,6]]
#  =&gt; 1 2
#     3 4
#     5 6
Matrix[[1,2], [3,4], [5,6]].transpose
#  =&gt; 1 3 5
#     2 4 6
</pre>  </div> <div class="aliases"> Also aliased as: <a href="matrix#method-i-t">t</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-unitary-3F"> <span class="method-name">unitary?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="unitary-3F-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 986
def unitary?
  raise ErrDimensionMismatch unless square?
  rows.each_with_index do |row_i, i|
    rows.each_with_index do |row_j, j|
      s = 0
      row_count.times do |k|
        s += row_i[k].conj * row_j[k]
      end
      return false unless s == (i == j ? 1 : 0)
    end
  end
  true
end</pre> </div> <p>Returns <code>true</code> if this is a unitary matrix Raises an error if matrix is not square.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-upper_triangular-3F"> <span class="method-name">upper_triangular?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="upper_triangular-3F-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1003
def upper_triangular?
  each(:strict_lower).all?(&amp;:zero?)
end</pre> </div> <p>Returns <code>true</code> if this is an upper triangular matrix.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-vstack"> <span class="method-name">vstack</span><span class="method-args">(*matrices)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="vstack-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1505
def vstack(*matrices)
  self.class.vstack(self, *matrices)
end</pre> </div> <p>Returns a new matrix resulting by stacking vertically the receiver with the given matrices</p> <pre class="ruby" data-language="ruby">x = Matrix[[1, 2], [3, 4]]
y = Matrix[[5, 6], [7, 8]]
x.vstack(y) # =&gt; Matrix[[1, 2], [3, 4], [5, 6], [7, 8]]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-zero-3F"> <span class="method-name">zero?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="zero-3F-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1010
def zero?
  all?(&amp;:zero?)
end</pre> </div> <p>Returns <code>true</code> if this is a matrix with only zero elements</p>  </div> </div> </section> <section id="protected-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Protected Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-power_int"> <span class="method-name">power_int</span><span class="method-args">(exp)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="power_int-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1257
          def power_int(exp)
  # assumes `exp` is an Integer &gt; 0
  #
  # Previous algorithm:
  #   build M**2, M**4 = (M**2)**2, M**8, ... and multiplying those you need
  #   e.g. M**0b1011 = M**11 = M * M**2 * M**8
  #                              ^  ^
  #   (highlighted the 2 out of 5 multiplications involving `M * x`)
  #
  # Current algorithm has same number of multiplications but with lower exponents:
  #    M**11 = M * (M * M**4)**2
  #              ^    ^  ^
  #   (highlighted the 3 out of 5 multiplications involving `M * x`)
  #
  # This should be faster for all (non nil-potent) matrices.
  case
  when exp == 1
    self
  when exp.odd?
    self * power_int(exp - 1)
  else
    sqrt = power_int(exp / 2)
    sqrt * sqrt
  end
end</pre> </div>  </div> </div> </section> <section id="private-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Private Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-check_int"> <span class="method-name">check_int</span><span class="method-args">(val, direction)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="check_int-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 376
        def check_int(val, direction)
  count = direction == :row ? row_count : column_count
  CoercionHelper.check_int(val, count, direction)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-check_range"> <span class="method-name">check_range</span><span class="method-args">(val, direction)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="check_range-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 370
        def check_range(val, direction)
  return unless val.is_a?(Range)
  count = direction == :row ? row_count : column_count
  CoercionHelper.check_range(val, count, direction)
end</pre> </div> <p>Returns range or nil</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-determinant_bareiss"> <span class="method-name">determinant_bareiss</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="determinant_bareiss-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1368
        def determinant_bareiss
  size = row_count
  last = size - 1
  a = to_a
  no_pivot = Proc.new{ return 0 }
  sign = +1
  pivot = 1
  size.times do |k|
    previous_pivot = pivot
    if (pivot = a[k][k]) == 0
      switch = (k+1 ... size).find(no_pivot) {|row|
        a[row][k] != 0
      }
      a[switch], a[k] = a[k], a[switch]
      pivot = a[k][k]
      sign = -sign
    end
    (k+1).upto(last) do |i|
      ai = a[i]
      (k+1).upto(last) do |j|
        ai[j] =  (pivot * ai[j] - ai[k] * a[k][j]) / previous_pivot
      end
    end
  end
  sign * pivot
end</pre> </div> <p>Private. Use <a href="matrix#method-i-determinant"><code>Matrix#determinant</code></a></p> <p>Returns the determinant of the matrix, using Bareiss' multistep integer-preserving gaussian elimination. It has the same computational cost order O(n^3) as standard Gaussian elimination. Intermediate results are fraction free and of lower complexity. A matrix of Integers will have thus intermediate results that are also Integers, with smaller bignums (if any), while a matrix of <a href="float"><code>Float</code></a> will usually have intermediate results with better precision.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-initialize_copy"> <span class="method-name">initialize_copy</span><span class="method-args">(m)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="initialize_copy-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 1036
        def initialize_copy(m)
  super
  @rows = @rows.map(&amp;:dup) unless frozen?
end</pre> </div> <p>Called for dup &amp; clone.</p> <div class="method-calls-super"> Calls superclass method </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-set_col_range"> <span class="method-name">set_col_range</span><span class="method-args">(row, col_range, value)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="set_col_range-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 432
        def set_col_range(row, col_range, value)
  value = if value.is_a?(Vector)
    value.to_a
  elsif value.is_a?(Matrix)
    raise ErrDimensionMismatch unless value.row_count == 1
    value.row(0).to_a
  else
    Array.new(col_range.size, value)
  end
  raise ErrDimensionMismatch unless col_range.size == value.size
  @rows[row][col_range] = value
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-set_column_vector"> <span class="method-name">set_column_vector</span><span class="method-args">(row_range, col, value)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="set_column_vector-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 425
        def set_column_vector(row_range, col, value)
  value.each_with_index do |e, index|
    r = row_range.begin + index
    @rows[r][col] = e
  end
end</pre> </div>  </div> </div> <div id="method-i-set_component" class="method-detail method-alias">  <div class="aliases"> Alias for: <a href="matrix#method-i-5B-5D-3D">[]=</a> </div> </div> <div id="method-i-set_element" class="method-detail method-alias">  <div class="aliases"> Alias for: <a href="matrix#method-i-5B-5D-3D">[]=</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-set_row_and_col_range"> <span class="method-name">set_row_and_col_range</span><span class="method-args">(row_range, col_range, value)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="set_row_and_col_range-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 387
        def set_row_and_col_range(row_range, col_range, value)
  if value.is_a?(Matrix)
    if row_range.size != value.row_count || col_range.size != value.column_count
      raise ErrDimensionMismatch, [
        'Expected a Matrix of dimensions',
        "#{row_range.size}x#{col_range.size}",
        'got',
        "#{value.row_count}x#{value.column_count}",
      ].join(' ')
    end
    source = value.instance_variable_get :@rows
    row_range.each_with_index do |row, i|
      @rows[row][col_range] = source[i]
    end
  elsif value.is_a?(Vector)
    raise ErrDimensionMismatch, 'Expected a Matrix or a value, got a Vector'
  else
    value_to_set = Array.new(col_range.size, value)
    row_range.each do |i|
      @rows[i][col_range] = value_to_set
    end
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-set_row_range"> <span class="method-name">set_row_range</span><span class="method-args">(row_range, col, value)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="set_row_range-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 411
        def set_row_range(row_range, col, value)
  if value.is_a?(Vector)
    raise ErrDimensionMismatch unless row_range.size == value.size
    set_column_vector(row_range, col, value)
  elsif value.is_a?(Matrix)
    raise ErrDimensionMismatch unless value.column_count == 1
    value = value.column(0)
    raise ErrDimensionMismatch unless row_range.size == value.size
    set_column_vector(row_range, col, value)
  else
    @rows[row_range].each{|e| e[col] = value }
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-set_value"> <span class="method-name">set_value</span><span class="method-args">(row, col, value)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="set_value-source"> <pre class="ruby" data-language="ruby"># File lib/matrix.rb, line 381
        def set_value(row, col, value)
  raise ErrDimensionMismatch, "Expected a a value, got a #{value.class}" if value.respond_to?(:to_matrix)

  @rows[row][col] = value
end</pre> </div>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2020 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
