<h1 id="class-GetoptLong" class="class"> class GetoptLong </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object">Object</a></dd>
</dl> <section class="description"> <p>The <a href="getoptlong"><code>GetoptLong</code></a> class allows you to parse command line options similarly to the GNU getopt_long() C library call. Note, however, that <a href="getoptlong"><code>GetoptLong</code></a> is a pure Ruby implementation.</p> <p><a href="getoptlong"><code>GetoptLong</code></a> allows for POSIX-style options like <code>--file</code> as well as single letter options like <code>-f</code></p> <p>The empty option <code>--</code> (two minus symbols) is used to end option processing. This can be particularly important if options have optional arguments.</p> <p>Here is a simple example of usage:</p> <pre class="ruby" data-language="ruby">require 'getoptlong'

opts = GetoptLong.new(
  [ '--help', '-h', GetoptLong::NO_ARGUMENT ],
  [ '--repeat', '-n', GetoptLong::REQUIRED_ARGUMENT ],
  [ '--name', GetoptLong::OPTIONAL_ARGUMENT ]
)

dir = nil
name = nil
repetitions = 1
opts.each do |opt, arg|
  case opt
    when '--help'
      puts &lt;&lt;-EOF
hello [OPTION] ... DIR

-h, --help:
   show help

--repeat x, -n x:
   repeat x times

--name [name]:
   greet user by name, if name not supplied default is John

DIR: The directory in which to issue the greeting.
      EOF
    when '--repeat'
      repetitions = arg.to_i
    when '--name'
      if arg == ''
        name = 'John'
      else
        name = arg
      end
  end
end

if ARGV.length != 1
  puts "Missing dir argument (try --help)"
  exit 0
end

dir = ARGV.shift

Dir.chdir(dir)
for i in (1..repetitions)
  print "Hello"
  if name
    print ", #{name}"
  end
  puts
end
</pre> <p>Example command line:</p> <pre>hello -n 6 --name -- /tmp</pre> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="ARGUMENT_FLAGS">ARGUMENT_FLAGS </dt>
<dd>
<p>Argument flags.</p> </dd>
<dt id="ORDERINGS">ORDERINGS </dt>
<dd>
<p>Orderings.</p> </dd>
<dt id="STATUS_TERMINATED">STATUS_TERMINATED </dt>

<dt id="VERSION">VERSION </dt>
<dd>
<p>Version.</p> </dd>
</dl> </section> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-error"> <span class="method-name">error</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Examine whether an option processing is failed.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-error-3F"> <span class="method-name">error?</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Examine whether an option processing is failed.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-ordering"> <span class="method-name">ordering</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Return ordering.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-quiet"> <span class="method-name">quiet</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Set/Unset `quiet' mode.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-quiet-3F"> <span class="method-name">quiet?</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Set/Unset `quiet' mode.</p> </div> </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-name">new</span><span class="method-args">(*arguments)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/getoptlong.rb, line 132
def initialize(*arguments)
  #
  # Current ordering.
  #
  if ENV.include?('POSIXLY_CORRECT')
    @ordering = REQUIRE_ORDER
  else
    @ordering = PERMUTE
  end

  #
  # Hash table of option names.
  # Keys of the table are option names, and their values are canonical
  # names of the options.
  #
  @canonical_names = Hash.new

  #
  # Hash table of argument flags.
  # Keys of the table are option names, and their values are argument
  # flags of the options.
  #
  @argument_flags = Hash.new

  #
  # Whether error messages are output to $stderr.
  #
  @quiet = false

  #
  # Status code.
  #
  @status = STATUS_YET

  #
  # Error code.
  #
  @error = nil

  #
  # Error message.
  #
  @error_message = nil

  #
  # Rest of catenated short options.
  #
  @rest_singles = ''

  #
  # List of non-option-arguments.
  # Append them to ARGV when option processing is terminated.
  #
  @non_option_arguments = Array.new

  if 0 &lt; arguments.length
    set_options(*arguments)
  end
end</pre> </div> <p><a href="set"><code>Set</code></a> up option processing.</p> <p>The options to support are passed to new() as an array of arrays. Each sub-array contains any number of <a href="string"><code>String</code></a> option names which carry the same meaning, and one of the following flags:</p> <dl class="rdoc-list note-list">
<dt>GetoptLong::NO_ARGUMENT </dt>
<dd> <p>Option does not take an argument.</p> </dd>
<dt>GetoptLong::REQUIRED_ARGUMENT </dt>
<dd> <p>Option always takes an argument.</p> </dd>
<dt>GetoptLong::OPTIONAL_ARGUMENT </dt>
<dd> <p>Option may or may not take an argument.</p> </dd>
</dl> <p>The first option name is considered to be the preferred (canonical) name. Other than that, the elements of each sub-array can be in any order.</p>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-each"> <span class="method-name">each</span><span class="method-args">() { |option_name, option_argument| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="each-source"> <pre class="ruby" data-language="ruby"># File lib/getoptlong.rb, line 604
def each
  loop do
    option_name, option_argument = get_option
    break if option_name == nil
    yield option_name, option_argument
  end
end</pre> </div> <p>Iterator version of `get'.</p> <p>The block is called repeatedly with two arguments: The first is the option name. The second is the argument which followed it (if any). Example: ('â€“opt', 'value')</p> <p>The option name is always converted to the first (preferred) name given in the original options to <a href="getoptlong#method-c-new"><code>GetoptLong.new</code></a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="getoptlong#method-i-each_option">each_option</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-each_option"> <span class="method-name">each_option</span><span class="method-args">()</span> </div> <div class="method-description"> <p>`each_option' is an alias of `each'.</p> </div> <div class="aliases"> Alias for: <a href="getoptlong#method-i-each">each</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-error_message"> <span class="method-name">error_message</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="error_message-source"> <pre class="ruby" data-language="ruby"># File lib/getoptlong.rb, line 415
def error_message
  return @error_message
end</pre> </div> <p>Return the appropriate error message in POSIX-defined format. If no error has occurred, returns nil.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-get"> <span class="method-name">get</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="get-source"> <pre class="ruby" data-language="ruby"># File lib/getoptlong.rb, line 430
def get
  option_name, option_argument = nil, ''

  #
  # Check status.
  #
  return nil if @error != nil
  case @status
  when STATUS_YET
    @status = STATUS_STARTED
  when STATUS_TERMINATED
    return nil
  end

  #
  # Get next option argument.
  #
  if 0 &lt; @rest_singles.length
    argument = '-' + @rest_singles
  elsif (ARGV.length == 0)
    terminate
    return nil
  elsif @ordering == PERMUTE
    while 0 &lt; ARGV.length &amp;&amp; ARGV[0] !~ /\A-./
      @non_option_arguments.push(ARGV.shift)
    end
    if ARGV.length == 0
      terminate
      return nil
    end
    argument = ARGV.shift
  elsif @ordering == REQUIRE_ORDER
    if (ARGV[0] !~ /\A-./)
      terminate
      return nil
    end
    argument = ARGV.shift
  else
    argument = ARGV.shift
  end

  #
  # Check the special argument `--'.
  # `--' indicates the end of the option list.
  #
  if argument == '--' &amp;&amp; @rest_singles.length == 0
    terminate
    return nil
  end

  #
  # Check for long and short options.
  #
  if argument =~ /\A(--[^=]+)/ &amp;&amp; @rest_singles.length == 0
    #
    # This is a long style option, which start with `--'.
    #
    pattern = $1
    if @canonical_names.include?(pattern)
      option_name = pattern
    else
      #
      # The option `option_name' is not registered in `@canonical_names'.
      # It may be an abbreviated.
      #
      matches = []
      @canonical_names.each_key do |key|
        if key.index(pattern) == 0
          option_name = key
          matches &lt;&lt; key
        end
      end
      if 2 &lt;= matches.length
        set_error(AmbiguousOption, "option `#{argument}' is ambiguous between #{matches.join(', ')}")
      elsif matches.length == 0
        set_error(InvalidOption, "unrecognized option `#{argument}'")
      end
    end

    #
    # Check an argument to the option.
    #
    if @argument_flags[option_name] == REQUIRED_ARGUMENT
      if argument =~ /=(.*)/m
        option_argument = $1
      elsif 0 &lt; ARGV.length
        option_argument = ARGV.shift
      else
        set_error(MissingArgument,
                  "option `#{argument}' requires an argument")
      end
    elsif @argument_flags[option_name] == OPTIONAL_ARGUMENT
      if argument =~ /=(.*)/m
        option_argument = $1
      elsif 0 &lt; ARGV.length &amp;&amp; ARGV[0] !~ /\A-./
        option_argument = ARGV.shift
      else
        option_argument = ''
      end
    elsif argument =~ /=(.*)/m
      set_error(NeedlessArgument,
                "option `#{option_name}' doesn't allow an argument")
    end

  elsif argument =~ /\A(-(.))(.*)/m
    #
    # This is a short style option, which start with `-' (not `--').
    # Short options may be catenated (e.g. `-l -g' is equivalent to
    # `-lg').
    #
    option_name, ch, @rest_singles = $1, $2, $3

    if @canonical_names.include?(option_name)
      #
      # The option `option_name' is found in `@canonical_names'.
      # Check its argument.
      #
      if @argument_flags[option_name] == REQUIRED_ARGUMENT
        if 0 &lt; @rest_singles.length
          option_argument = @rest_singles
          @rest_singles = ''
        elsif 0 &lt; ARGV.length
          option_argument = ARGV.shift
        else
          # 1003.2 specifies the format of this message.
          set_error(MissingArgument, "option requires an argument -- #{ch}")
        end
      elsif @argument_flags[option_name] == OPTIONAL_ARGUMENT
        if 0 &lt; @rest_singles.length
          option_argument = @rest_singles
          @rest_singles = ''
        elsif 0 &lt; ARGV.length &amp;&amp; ARGV[0] !~ /\A-./
          option_argument = ARGV.shift
        else
          option_argument = ''
        end
      end
    else
      #
      # This is an invalid option.
      # 1003.2 specifies the format of this message.
      #
      if ENV.include?('POSIXLY_CORRECT')
        set_error(InvalidOption, "invalid option -- #{ch}")
      else
        set_error(InvalidOption, "invalid option -- #{ch}")
      end
    end
  else
    #
    # This is a non-option argument.
    # Only RETURN_IN_ORDER fell into here.
    #
    return '', argument
  end

  return @canonical_names[option_name], option_argument
end</pre> </div> <p>Get next option name and its argument, as an <a href="array"><code>Array</code></a> of two elements.</p> <p>The option name is always converted to the first (preferred) name given in the original options to <a href="getoptlong#method-c-new"><code>GetoptLong.new</code></a>.</p> <p>Example: ['â€“option', 'value']</p> <p>Returns nil if the processing is complete (as determined by <a href="getoptlong#STATUS_TERMINATED"><code>STATUS_TERMINATED</code></a>).</p>  </div> <div class="aliases"> Also aliased as: <a href="getoptlong#method-i-get_option">get_option</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-get_option"> <span class="method-name">get_option</span><span class="method-args">()</span> </div> <div class="method-description"> <p>`get_option' is an alias of `get'.</p> </div> <div class="aliases"> Alias for: <a href="getoptlong#method-i-get">get</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ordering-3D"> <span class="method-name">ordering=</span><span class="method-args">(ordering)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ordering-3D-source"> <pre class="ruby" data-language="ruby"># File lib/getoptlong.rb, line 241
def ordering=(ordering)
  #
  # The method is failed if option processing has already started.
  #
  if @status != STATUS_YET
    set_error(ArgumentError, "argument error")
    raise RuntimeError,
      "invoke ordering=, but option processing has already started"
  end

  #
  # Check ordering.
  #
  if !ORDERINGS.include?(ordering)
    raise ArgumentError, "invalid ordering `#{ordering}'"
  end
  if ordering == PERMUTE &amp;&amp; ENV.include?('POSIXLY_CORRECT')
    @ordering = REQUIRE_ORDER
  else
    @ordering = ordering
  end
end</pre> </div> <p><a href="set"><code>Set</code></a> the handling of the ordering of options and arguments. A <a href="runtimeerror"><code>RuntimeError</code></a> is raised if option processing has already started.</p> <p>The supplied value must be a member of <a href="getoptlong#ORDERINGS"><code>GetoptLong::ORDERINGS</code></a>. It alters the processing of options as follows:</p> <p><strong>REQUIRE_ORDER</strong> :</p> <p>Options are required to occur before non-options.</p> <p>Processing of options ends as soon as a word is encountered that has not been preceded by an appropriate option flag.</p> <p>For example, if -a and -b are options which do not take arguments, parsing command line arguments of '-a one -b two' would result in 'one', '-b', 'two' being left in ARGV, and only ('-a', '') being processed as an option/arg pair.</p> <p>This is the default ordering, if the environment variable POSIXLY_CORRECT is set. (This is for compatibility with GNU getopt_long.)</p> <p><strong>PERMUTE</strong> :</p> <p>Options can occur anywhere in the command line parsed. This is the default behavior.</p> <p>Every sequence of words which can be interpreted as an option (with or without argument) is treated as an option; non-option words are skipped.</p> <p>For example, if -a does not require an argument and -b optionally takes an argument, parsing '-a one -b two three' would result in ('-a','') and ('-b', 'two') being processed as option/arg pairs, and 'one','three' being left in ARGV.</p> <p>If the ordering is set to PERMUTE but the environment variable POSIXLY_CORRECT is set, REQUIRE_ORDER is used instead. This is for compatibility with GNU getopt_long.</p> <p><strong>RETURN_IN_ORDER</strong> :</p> <p>All words on the command line are processed as options. Words not preceded by a short or long option flag are passed as arguments with an option of '' (empty string).</p> <p>For example, if -a requires an argument but -b does not, a command line of '-a one -b two three' would result in option/arg pairs of ('-a', 'one') ('-b', ''), ('', 'two'), ('', 'three') being processed.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-set_options"> <span class="method-name">set_options</span><span class="method-args">(*arguments)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="set_options-source"> <pre class="ruby" data-language="ruby"># File lib/getoptlong.rb, line 274
def set_options(*arguments)
  #
  # The method is failed if option processing has already started.
  #
  if @status != STATUS_YET
    raise RuntimeError,
      "invoke set_options, but option processing has already started"
  end

  #
  # Clear tables of option names and argument flags.
  #
  @canonical_names.clear
  @argument_flags.clear

  arguments.each do |arg|
    if !arg.is_a?(Array)
     raise ArgumentError, "the option list contains non-Array argument"
    end

    #
    # Find an argument flag and it set to `argument_flag'.
    #
    argument_flag = nil
    arg.each do |i|
      if ARGUMENT_FLAGS.include?(i)
        if argument_flag != nil
          raise ArgumentError, "too many argument-flags"
        end
        argument_flag = i
      end
    end

    raise ArgumentError, "no argument-flag" if argument_flag == nil

    canonical_name = nil
    arg.each do |i|
      #
      # Check an option name.
      #
      next if i == argument_flag
      begin
        if !i.is_a?(String) || i !~ /\A-([^-]|-.+)\z/
          raise ArgumentError, "an invalid option `#{i}'"
        end
        if (@canonical_names.include?(i))
          raise ArgumentError, "option redefined `#{i}'"
        end
      rescue
        @canonical_names.clear
        @argument_flags.clear
        raise
      end

      #
      # Register the option (`i') to the `@canonical_names' and
      # `@canonical_names' Hashes.
      #
      if canonical_name == nil
        canonical_name = i
      end
      @canonical_names[i] = canonical_name
      @argument_flags[i] = argument_flag
    end
    raise ArgumentError, "no option name" if canonical_name == nil
  end
  return self
end</pre> </div> <p><a href="set"><code>Set</code></a> options. Takes the same argument as <a href="getoptlong#method-c-new"><code>GetoptLong.new</code></a>.</p> <p>Raises a <a href="runtimeerror"><code>RuntimeError</code></a> if option processing has already started.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-terminate"> <span class="method-name">terminate</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="terminate-source"> <pre class="ruby" data-language="ruby"># File lib/getoptlong.rb, line 361
def terminate
  return nil if @status == STATUS_TERMINATED
  raise RuntimeError, "an error has occurred" if @error != nil

  @status = STATUS_TERMINATED
  @non_option_arguments.reverse_each do |argument|
    ARGV.unshift(argument)
  end

  @canonical_names = nil
  @argument_flags = nil
  @rest_singles = nil
  @non_option_arguments = nil

  return self
end</pre> </div> <p>Explicitly terminate option processing.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-terminated-3F"> <span class="method-name">terminated?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="terminated-3F-source"> <pre class="ruby" data-language="ruby"># File lib/getoptlong.rb, line 381
def terminated?
  return @status == STATUS_TERMINATED
end</pre> </div> <p>Returns true if option processing has terminated, false otherwise.</p>  </div> </div> </section> <section id="protected-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Protected Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-set_error"> <span class="method-name">set_error</span><span class="method-args">(type, message)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="set_error-source"> <pre class="ruby" data-language="ruby"># File lib/getoptlong.rb, line 388
def set_error(type, message)
  $stderr.print("#{$0}: #{message}\n") if !@quiet

  @error = type
  @error_message = message
  @canonical_names = nil
  @argument_flags = nil
  @rest_singles = nil
  @non_option_arguments = nil

  raise type, message
end</pre> </div> <p><a href="set"><code>Set</code></a> an error (a protected method).</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2020 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
