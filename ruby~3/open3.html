<h1 id="module-Open3" class="module"> module Open3 </h1> <section class="description"> <p><a href="open3"><code>Open3</code></a> grants you access to stdin, stdout, stderr and a thread to wait for the child process when running another program. You can specify various attributes, redirections, current directory, etc., of the program in the same way as for <a href="process#method-c-spawn"><code>Process.spawn</code></a>.</p> <ul>
<li> <p><a href="open3#method-c-popen3"><code>Open3.popen3</code></a> : pipes for stdin, stdout, stderr</p> </li>
<li> <p><a href="open3#method-c-popen2"><code>Open3.popen2</code></a> : pipes for stdin, stdout</p> </li>
<li> <p><a href="open3#method-c-popen2e"><code>Open3.popen2e</code></a> : pipes for stdin, merged stdout and stderr</p> </li>
<li> <p><a href="open3#method-c-capture3"><code>Open3.capture3</code></a> : give a string for stdin; get strings for stdout, stderr</p> </li>
<li> <p><a href="open3#method-c-capture2"><code>Open3.capture2</code></a> : give a string for stdin; get a string for stdout</p> </li>
<li> <p><a href="open3#method-c-capture2e"><code>Open3.capture2e</code></a> : give a string for stdin; get a string for merged stdout and stderr</p> </li>
<li> <p><a href="open3#method-c-pipeline_rw"><code>Open3.pipeline_rw</code></a> : pipes for first stdin and last stdout of a pipeline</p> </li>
<li> <p><a href="open3#method-c-pipeline_r"><code>Open3.pipeline_r</code></a> : pipe for last stdout of a pipeline</p> </li>
<li> <p><a href="open3#method-c-pipeline_w"><code>Open3.pipeline_w</code></a> : pipe for first stdin of a pipeline</p> </li>
<li> <p><a href="open3#method-c-pipeline_start"><code>Open3.pipeline_start</code></a> : run a pipeline without waiting</p> </li>
<li> <p><a href="open3#method-c-pipeline"><code>Open3.pipeline</code></a> : run a pipeline and wait for its completion</p> </li>
</ul> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="VERSION">VERSION </dt>

</dl> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-capture2"> <span class="method-name">capture2</span><span class="method-args">(*cmd)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="capture2-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 340
def capture2(*cmd)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  stdin_data = opts.delete(:stdin_data)
  binmode = opts.delete(:binmode)

  popen2(*cmd, opts) {|i, o, t|
    if binmode
      i.binmode
      o.binmode
    end
    out_reader = Thread.new { o.read }
    if stdin_data
      begin
        if stdin_data.respond_to? :readpartial
          IO.copy_stream(stdin_data, i)
        else
          i.write stdin_data
        end
      rescue Errno::EPIPE
      end
    end
    i.close
    [out_reader.value, t.value]
  }
end</pre> </div> <p><a href="open3#method-c-capture2"><code>Open3.capture2</code></a> captures the standard output of a command.</p> <pre>stdout_str, status = Open3.capture2([env,] cmd... [, opts])</pre> <p>The arguments env, cmd and opts are passed to <a href="open3#method-c-popen3"><code>Open3.popen3</code></a> except <code>opts[:stdin_data]</code> and <code>opts[:binmode]</code>. See <a href="process#method-c-spawn"><code>Process.spawn</code></a>.</p> <p>If <code>opts[:stdin_data]</code> is specified, it is sent to the command's standard input.</p> <p>If <code>opts[:binmode]</code> is true, internal pipes are set to binary mode.</p> <p>Example:</p> <pre class="ruby" data-language="ruby"># factor is a command for integer factorization.
o, s = Open3.capture2("factor", :stdin_data=&gt;"42")
p o #=&gt; "42: 2 3 7\n"

# generate x**2 graph in png using gnuplot.
gnuplot_commands = &lt;&lt;"End"
  set terminal png
  plot x**2, "-" with lines
  1 14
  2 1
  3 8
  4 5
  e
End
image, s = Open3.capture2("gnuplot", :stdin_data=&gt;gnuplot_commands, :binmode=&gt;true)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-capture2e"> <span class="method-name">capture2e</span><span class="method-args">(*cmd)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="capture2e-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 388
def capture2e(*cmd)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  stdin_data = opts.delete(:stdin_data)
  binmode = opts.delete(:binmode)

  popen2e(*cmd, opts) {|i, oe, t|
    if binmode
      i.binmode
      oe.binmode
    end
    outerr_reader = Thread.new { oe.read }
    if stdin_data
      begin
        if stdin_data.respond_to? :readpartial
          IO.copy_stream(stdin_data, i)
        else
          i.write stdin_data
        end
      rescue Errno::EPIPE
      end
    end
    i.close
    [outerr_reader.value, t.value]
  }
end</pre> </div> <p><a href="open3#method-c-capture2e"><code>Open3.capture2e</code></a> captures the standard output and the standard error of a command.</p> <pre>stdout_and_stderr_str, status = Open3.capture2e([env,] cmd... [, opts])</pre> <p>The arguments env, cmd and opts are passed to <a href="open3#method-c-popen3"><code>Open3.popen3</code></a> except <code>opts[:stdin_data]</code> and <code>opts[:binmode]</code>. See <a href="process#method-c-spawn"><code>Process.spawn</code></a>.</p> <p>If <code>opts[:stdin_data]</code> is specified, it is sent to the command's standard input.</p> <p>If <code>opts[:binmode]</code> is true, internal pipes are set to binary mode.</p> <p>Example:</p> <pre class="ruby" data-language="ruby"># capture make log
make_log, s = Open3.capture2e("make")
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-capture3"> <span class="method-name">capture3</span><span class="method-args">(*cmd)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="capture3-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 279
def capture3(*cmd)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  stdin_data = opts.delete(:stdin_data) || ''
  binmode = opts.delete(:binmode)

  popen3(*cmd, opts) {|i, o, e, t|
    if binmode
      i.binmode
      o.binmode
      e.binmode
    end
    out_reader = Thread.new { o.read }
    err_reader = Thread.new { e.read }
    begin
      if stdin_data.respond_to? :readpartial
        IO.copy_stream(stdin_data, i)
      else
        i.write stdin_data
      end
    rescue Errno::EPIPE
    end
    i.close
    [out_reader.value, err_reader.value, t.value]
  }
end</pre> </div> <p><a href="open3#method-c-capture3"><code>Open3.capture3</code></a> captures the standard output and the standard error of a command.</p> <pre>stdout_str, stderr_str, status = Open3.capture3([env,] cmd... [, opts])</pre> <p>The arguments env, cmd and opts are passed to <a href="open3#method-c-popen3"><code>Open3.popen3</code></a> except <code>opts[:stdin_data]</code> and <code>opts[:binmode]</code>. See <a href="process#method-c-spawn"><code>Process.spawn</code></a>.</p> <p>If <code>opts[:stdin_data]</code> is specified, it is sent to the command's standard input.</p> <p>If <code>opts[:binmode]</code> is true, internal pipes are set to binary mode.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby"># dot is a command of graphviz.
graph = &lt;&lt;'End'
  digraph g {
    a -&gt; b
  }
End
drawn_graph, dot_log = Open3.capture3("dot -v", :stdin_data=&gt;graph)

o, e, s = Open3.capture3("echo abc; sort &gt;&amp;2", :stdin_data=&gt;"foo\nbar\nbaz\n")
p o #=&gt; "abc\n"
p e #=&gt; "bar\nbaz\nfoo\n"
p s #=&gt; #&lt;Process::Status: pid 32682 exit 0&gt;

# generate a thumbnail image using the convert command of ImageMagick.
# However, if the image is really stored in a file,
# system("convert", "-thumbnail", "80", "png:#{filename}", "png:-") is better
# because of reduced memory consumption.
# But if the image is stored in a DB or generated by the gnuplot Open3.capture2 example,
# Open3.capture3 should be considered.
#
image = File.read("/usr/share/openclipart/png/animals/mammals/sheep-md-v0.1.png", :binmode=&gt;true)
thumbnail, err, s = Open3.capture3("convert -thumbnail 80 png:- png:-", :stdin_data=&gt;image, :binmode=&gt;true)
if s.success?
  STDOUT.binmode; print thumbnail
end
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-pipeline"> <span class="method-name">pipeline</span><span class="method-args">(*cmds)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pipeline-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 687
def pipeline(*cmds)
  if Hash === cmds.last
    opts = cmds.pop.dup
  else
    opts = {}
  end

  pipeline_run(cmds, opts, [], []) {|ts|
    ts.map(&amp;:value)
  }
end</pre> </div> <p><a href="open3#method-c-pipeline"><code>Open3.pipeline</code></a> starts a list of commands as a pipeline. It waits for the completion of the commands. No pipes are created for stdin of the first command and stdout of the last command.</p> <pre>status_list = Open3.pipeline(cmd1, cmd2, ... [, opts])</pre> <p>Each cmd is a string or an array. If it is an array, the elements are passed to <a href="process#method-c-spawn"><code>Process.spawn</code></a>.</p> <pre>cmd:
  commandline                              command line string which is passed to a shell
  [env, commandline, opts]                 command line string which is passed to a shell
  [env, cmdname, arg1, ..., opts]          command name and one or more arguments (no shell)
  [env, [cmdname, argv0], arg1, ..., opts] command name and arguments including argv[0] (no shell)

Note that env and opts are optional, as Process.spawn.</pre> <p>Example:</p> <pre class="ruby" data-language="ruby">fname = "/usr/share/man/man1/ruby.1.gz"
p Open3.pipeline(["zcat", fname], "nroff -man", "less")
#=&gt; [#&lt;Process::Status: pid 11817 exit 0&gt;,
#    #&lt;Process::Status: pid 11820 exit 0&gt;,
#    #&lt;Process::Status: pid 11828 exit 0&gt;]

fname = "/usr/share/man/man1/ls.1.gz"
Open3.pipeline(["zcat", fname], "nroff -man", "colcrt")

# convert PDF to PS and send to a printer by lpr
pdf_file = "paper.pdf"
printer = "printer-name"
Open3.pipeline(["pdftops", pdf_file, "-"],
               ["lpr", "-P#{printer}"])

# count lines
Open3.pipeline("sort", "uniq -c", :in=&gt;"names.txt", :out=&gt;"count")

# cyclic pipeline
r,w = IO.pipe
w.print "ibase=14\n10\n"
Open3.pipeline("bc", "tee /dev/tty", :in=&gt;r, :out=&gt;w)
#=&gt; 14
#   18
#   22
#   30
#   42
#   58
#   78
#   106
#   202
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-pipeline_r"> <span class="method-name">pipeline_r</span><span class="method-args">(*cmds, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pipeline_r-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 518
def pipeline_r(*cmds, &amp;block)
  if Hash === cmds.last
    opts = cmds.pop.dup
  else
    opts = {}
  end

  out_r, out_w = IO.pipe
  opts[:out] = out_w

  pipeline_run(cmds, opts, [out_w], [out_r], &amp;block)
end</pre> </div> <p><a href="open3#method-c-pipeline_r"><code>Open3.pipeline_r</code></a> starts a list of commands as a pipeline with a pipe which connects to stdout of the last command.</p> <pre>Open3.pipeline_r(cmd1, cmd2, ... [, opts]) {|last_stdout, wait_threads|
  ...
}

last_stdout, wait_threads = Open3.pipeline_r(cmd1, cmd2, ... [, opts])
...
last_stdout.close</pre> <p>Each cmd is a string or an array. If it is an array, the elements are passed to <a href="process#method-c-spawn"><code>Process.spawn</code></a>.</p> <pre>cmd:
  commandline                              command line string which is passed to a shell
  [env, commandline, opts]                 command line string which is passed to a shell
  [env, cmdname, arg1, ..., opts]          command name and one or more arguments (no shell)
  [env, [cmdname, argv0], arg1, ..., opts] command name and arguments including argv[0] (no shell)

Note that env and opts are optional, as for Process.spawn.</pre> <p>Example:</p> <pre>Open3.pipeline_r("zcat /var/log/apache2/access.log.*.gz",
                 [{"LANG"=&gt;"C"}, "grep", "GET /favicon.ico"],
                 "logresolve") {|o, ts|
  o.each_line {|line|
    ...
  }
}

Open3.pipeline_r("yes", "head -10") {|o, ts|
  p o.read      #=&gt; "y\ny\ny\ny\ny\ny\ny\ny\ny\ny\n"
  p ts[0].value #=&gt; #&lt;Process::Status: pid 24910 SIGPIPE (signal 13)&gt;
  p ts[1].value #=&gt; #&lt;Process::Status: pid 24913 exit 0&gt;
}</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-pipeline_rw"> <span class="method-name">pipeline_rw</span><span class="method-args">(*cmds, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pipeline_rw-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 462
def pipeline_rw(*cmds, &amp;block)
  if Hash === cmds.last
    opts = cmds.pop.dup
  else
    opts = {}
  end

  in_r, in_w = IO.pipe
  opts[:in] = in_r
  in_w.sync = true

  out_r, out_w = IO.pipe
  opts[:out] = out_w

  pipeline_run(cmds, opts, [in_r, out_w], [in_w, out_r], &amp;block)
end</pre> </div> <p><a href="open3#method-c-pipeline_rw"><code>Open3.pipeline_rw</code></a> starts a list of commands as a pipeline with pipes which connect to stdin of the first command and stdout of the last command.</p> <pre>Open3.pipeline_rw(cmd1, cmd2, ... [, opts]) {|first_stdin, last_stdout, wait_threads|
  ...
}

first_stdin, last_stdout, wait_threads = Open3.pipeline_rw(cmd1, cmd2, ... [, opts])
...
first_stdin.close
last_stdout.close</pre> <p>Each cmd is a string or an array. If it is an array, the elements are passed to <a href="process#method-c-spawn"><code>Process.spawn</code></a>.</p> <pre>cmd:
  commandline                              command line string which is passed to a shell
  [env, commandline, opts]                 command line string which is passed to a shell
  [env, cmdname, arg1, ..., opts]          command name and one or more arguments (no shell)
  [env, [cmdname, argv0], arg1, ..., opts] command name and arguments including argv[0] (no shell)

Note that env and opts are optional, as for Process.spawn.</pre> <p>The options to pass to <a href="process#method-c-spawn"><code>Process.spawn</code></a> are constructed by merging <code>opts</code>, the last hash element of the array, and specifications for the pipes between each of the commands.</p> <p>Example:</p> <pre class="ruby" data-language="ruby">Open3.pipeline_rw("tr -dc A-Za-z", "wc -c") {|i, o, ts|
  i.puts "All persons more than a mile high to leave the court."
  i.close
  p o.gets #=&gt; "42\n"
}

Open3.pipeline_rw("sort", "cat -n") {|stdin, stdout, wait_thrs|
  stdin.puts "foo"
  stdin.puts "bar"
  stdin.puts "baz"
  stdin.close     # send EOF to sort.
  p stdout.read   #=&gt; "     1\tbar\n     2\tbaz\n     3\tfoo\n"
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-pipeline_start"> <span class="method-name">pipeline_start</span><span class="method-args">(*cmds, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pipeline_start-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 619
def pipeline_start(*cmds, &amp;block)
  if Hash === cmds.last
    opts = cmds.pop.dup
  else
    opts = {}
  end

  if block
    pipeline_run(cmds, opts, [], [], &amp;block)
  else
    ts, = pipeline_run(cmds, opts, [], [])
    ts
  end
end</pre> </div> <p><a href="open3#method-c-pipeline_start"><code>Open3.pipeline_start</code></a> starts a list of commands as a pipeline. No pipes are created for stdin of the first command and stdout of the last command.</p> <pre>Open3.pipeline_start(cmd1, cmd2, ... [, opts]) {|wait_threads|
  ...
}

wait_threads = Open3.pipeline_start(cmd1, cmd2, ... [, opts])
...</pre> <p>Each cmd is a string or an array. If it is an array, the elements are passed to <a href="process#method-c-spawn"><code>Process.spawn</code></a>.</p> <pre>cmd:
  commandline                              command line string which is passed to a shell
  [env, commandline, opts]                 command line string which is passed to a shell
  [env, cmdname, arg1, ..., opts]          command name and one or more arguments (no shell)
  [env, [cmdname, argv0], arg1, ..., opts] command name and arguments including argv[0] (no shell)

Note that env and opts are optional, as for Process.spawn.</pre> <p>Example:</p> <pre class="ruby" data-language="ruby"># Run xeyes in 10 seconds.
Open3.pipeline_start("xeyes") {|ts|
  sleep 10
  t = ts[0]
  Process.kill("TERM", t.pid)
  p t.value #=&gt; #&lt;Process::Status: pid 911 SIGTERM (signal 15)&gt;
}

# Convert pdf to ps and send it to a printer.
# Collect error message of pdftops and lpr.
pdf_file = "paper.pdf"
printer = "printer-name"
err_r, err_w = IO.pipe
Open3.pipeline_start(["pdftops", pdf_file, "-"],
                     ["lpr", "-P#{printer}"],
                     :err=&gt;err_w) {|ts|
  err_w.close
  p err_r.read # error messages of pdftops and lpr.
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-pipeline_w"> <span class="method-name">pipeline_w</span><span class="method-args">(*cmds, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pipeline_w-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 560
def pipeline_w(*cmds, &amp;block)
  if Hash === cmds.last
    opts = cmds.pop.dup
  else
    opts = {}
  end

  in_r, in_w = IO.pipe
  opts[:in] = in_r
  in_w.sync = true

  pipeline_run(cmds, opts, [in_r], [in_w], &amp;block)
end</pre> </div> <p><a href="open3#method-c-pipeline_w"><code>Open3.pipeline_w</code></a> starts a list of commands as a pipeline with a pipe which connects to stdin of the first command.</p> <pre>Open3.pipeline_w(cmd1, cmd2, ... [, opts]) {|first_stdin, wait_threads|
  ...
}

first_stdin, wait_threads = Open3.pipeline_w(cmd1, cmd2, ... [, opts])
...
first_stdin.close</pre> <p>Each cmd is a string or an array. If it is an array, the elements are passed to <a href="process#method-c-spawn"><code>Process.spawn</code></a>.</p> <pre>cmd:
  commandline                              command line string which is passed to a shell
  [env, commandline, opts]                 command line string which is passed to a shell
  [env, cmdname, arg1, ..., opts]          command name and one or more arguments (no shell)
  [env, [cmdname, argv0], arg1, ..., opts] command name and arguments including argv[0] (no shell)

Note that env and opts are optional, as for Process.spawn.</pre> <p>Example:</p> <pre class="ruby" data-language="ruby">Open3.pipeline_w("bzip2 -c", :out=&gt;"/tmp/hello.bz2") {|i, ts|
  i.puts "hello"
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-popen2"> <span class="method-name">popen2</span><span class="method-args">(*cmd, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="popen2-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 146
def popen2(*cmd, &amp;block)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  in_r, in_w = IO.pipe
  opts[:in] = in_r
  in_w.sync = true

  out_r, out_w = IO.pipe
  opts[:out] = out_w

  popen_run(cmd, opts, [in_r, out_w], [in_w, out_r], &amp;block)
end</pre> </div> <p><a href="open3#method-c-popen2"><code>Open3.popen2</code></a> is similar to <a href="open3#method-c-popen3"><code>Open3.popen3</code></a> except that it doesn't create a pipe for the standard error stream.</p> <p>Block form:</p> <pre>Open3.popen2([env,] cmd... [, opts]) {|stdin, stdout, wait_thr|
  pid = wait_thr.pid # pid of the started process.
  ...
  exit_status = wait_thr.value # Process::Status object returned.
}</pre> <p>Non-block form:</p> <pre>stdin, stdout, wait_thr = Open3.popen2([env,] cmd... [, opts])
...
stdin.close  # stdin and stdout should be closed explicitly in this form.
stdout.close</pre> <p>See <a href="process#method-c-spawn"><code>Process.spawn</code></a> for the optional hash arguments <em>env</em> and <em>opts</em>.</p> <p>Example:</p> <pre class="ruby" data-language="ruby">Open3.popen2("wc -c") {|i,o,t|
  i.print "answer to life the universe and everything"
  i.close
  p o.gets #=&gt; "42\n"
}

Open3.popen2("bc -q") {|i,o,t|
  i.puts "obase=13"
  i.puts "6 * 9"
  p o.gets #=&gt; "42\n"
}

Open3.popen2("dc") {|i,o,t|
  i.print "42P"
  i.close
  p o.read #=&gt; "*"
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-popen2e"> <span class="method-name">popen2e</span><span class="method-args">(*cmd, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="popen2e-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 195
def popen2e(*cmd, &amp;block)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  in_r, in_w = IO.pipe
  opts[:in] = in_r
  in_w.sync = true

  out_r, out_w = IO.pipe
  opts[[:out, :err]] = out_w

  popen_run(cmd, opts, [in_r, out_w], [in_w, out_r], &amp;block)
ensure
  if block
    in_r.close
    in_w.close
    out_r.close
    out_w.close
  end
end</pre> </div> <p><a href="open3#method-c-popen2e"><code>Open3.popen2e</code></a> is similar to <a href="open3#method-c-popen3"><code>Open3.popen3</code></a> except that it merges the standard output stream and the standard error stream.</p> <p>Block form:</p> <pre>Open3.popen2e([env,] cmd... [, opts]) {|stdin, stdout_and_stderr, wait_thr|
  pid = wait_thr.pid # pid of the started process.
  ...
  exit_status = wait_thr.value # Process::Status object returned.
}</pre> <p>Non-block form:</p> <pre>stdin, stdout_and_stderr, wait_thr = Open3.popen2e([env,] cmd... [, opts])
...
stdin.close  # stdin and stdout_and_stderr should be closed explicitly in this form.
stdout_and_stderr.close</pre> <p>See <a href="process#method-c-spawn"><code>Process.spawn</code></a> for the optional hash arguments <em>env</em> and <em>opts</em>.</p> <p>Example:</p> <pre># check gcc warnings
source = "foo.c"
Open3.popen2e("gcc", "-Wall", source) {|i,oe,t|
  oe.each {|line|
    if /warning/ =~ line
      ...
    end
  }
}</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-popen3"> <span class="method-name">popen3</span><span class="method-args">(*cmd, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="popen3-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 85
def popen3(*cmd, &amp;block)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  in_r, in_w = IO.pipe
  opts[:in] = in_r
  in_w.sync = true

  out_r, out_w = IO.pipe
  opts[:out] = out_w

  err_r, err_w = IO.pipe
  opts[:err] = err_w

  popen_run(cmd, opts, [in_r, out_w, err_w], [in_w, out_r, err_r], &amp;block)
end</pre> </div> <p>Open stdin, stdout, and stderr streams and start external executable. In addition, a thread to wait for the started process is created. The thread has a pid method and a thread variable :pid which is the pid of the started process.</p> <p>Block form:</p> <pre>Open3.popen3([env,] cmd... [, opts]) {|stdin, stdout, stderr, wait_thr|
  pid = wait_thr.pid # pid of the started process.
  ...
  exit_status = wait_thr.value # Process::Status object returned.
}</pre> <p>Non-block form:</p> <pre>stdin, stdout, stderr, wait_thr = Open3.popen3([env,] cmd... [, opts])
pid = wait_thr[:pid]  # pid of the started process
...
stdin.close  # stdin, stdout and stderr should be closed explicitly in this form.
stdout.close
stderr.close
exit_status = wait_thr.value  # Process::Status object returned.</pre> <p>The parameters env, cmd, and opts are passed to <a href="process#method-c-spawn"><code>Process.spawn</code></a>. A commandline string and a list of argument strings can be accepted as follows:</p> <pre>Open3.popen3("echo abc") {|i, o, e, t| ... }
Open3.popen3("echo", "abc") {|i, o, e, t| ... }
Open3.popen3(["echo", "argv0"], "abc") {|i, o, e, t| ... }</pre> <p>If the last parameter, opts, is a <a href="hash"><code>Hash</code></a>, it is recognized as an option for <a href="process#method-c-spawn"><code>Process.spawn</code></a>.</p> <pre class="ruby" data-language="ruby">Open3.popen3("pwd", :chdir=&gt;"/") {|i,o,e,t|
  p o.read.chomp #=&gt; "/"
}
</pre> <p>wait_thr.value waits for the termination of the process. The block form also waits for the process when it returns.</p> <p>Closing stdin, stdout and stderr does not wait for the process to complete.</p> <p>You should be careful to avoid deadlocks. Since pipes are fixed length buffers, <a href="open3#method-c-popen3"><code>Open3.popen3</code></a>(“prog”) {|i, o, e, t| o.read } deadlocks if the program generates too much output on stderr. You should read stdout and stderr simultaneously (using threads or <a href="io#method-c-select"><code>IO.select</code></a>). However, if you don't need stderr output, you can use <a href="open3#method-c-popen2"><code>Open3.popen2</code></a>. If merged stdout and stderr output is not a problem, you can use <a href="open3#method-c-popen2e"><code>Open3.popen2e</code></a>. If you really need stdout and stderr output as separate strings, you can consider <a href="open3#method-c-capture3"><code>Open3.capture3</code></a>.</p>  </div> </div> </section> <section id="private-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Private Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-capture2"> <span class="method-name">capture2</span><span class="method-args">(*cmd)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="capture2-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 340
def capture2(*cmd)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  stdin_data = opts.delete(:stdin_data)
  binmode = opts.delete(:binmode)

  popen2(*cmd, opts) {|i, o, t|
    if binmode
      i.binmode
      o.binmode
    end
    out_reader = Thread.new { o.read }
    if stdin_data
      begin
        if stdin_data.respond_to? :readpartial
          IO.copy_stream(stdin_data, i)
        else
          i.write stdin_data
        end
      rescue Errno::EPIPE
      end
    end
    i.close
    [out_reader.value, t.value]
  }
end</pre> </div> <p><a href="open3#method-c-capture2"><code>Open3.capture2</code></a> captures the standard output of a command.</p> <pre>stdout_str, status = Open3.capture2([env,] cmd... [, opts])</pre> <p>The arguments env, cmd and opts are passed to <a href="open3#method-c-popen3"><code>Open3.popen3</code></a> except <code>opts[:stdin_data]</code> and <code>opts[:binmode]</code>. See <a href="process#method-c-spawn"><code>Process.spawn</code></a>.</p> <p>If <code>opts[:stdin_data]</code> is specified, it is sent to the command's standard input.</p> <p>If <code>opts[:binmode]</code> is true, internal pipes are set to binary mode.</p> <p>Example:</p> <pre class="ruby" data-language="ruby"># factor is a command for integer factorization.
o, s = Open3.capture2("factor", :stdin_data=&gt;"42")
p o #=&gt; "42: 2 3 7\n"

# generate x**2 graph in png using gnuplot.
gnuplot_commands = &lt;&lt;"End"
  set terminal png
  plot x**2, "-" with lines
  1 14
  2 1
  3 8
  4 5
  e
End
image, s = Open3.capture2("gnuplot", :stdin_data=&gt;gnuplot_commands, :binmode=&gt;true)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-capture2e"> <span class="method-name">capture2e</span><span class="method-args">(*cmd)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="capture2e-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 388
def capture2e(*cmd)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  stdin_data = opts.delete(:stdin_data)
  binmode = opts.delete(:binmode)

  popen2e(*cmd, opts) {|i, oe, t|
    if binmode
      i.binmode
      oe.binmode
    end
    outerr_reader = Thread.new { oe.read }
    if stdin_data
      begin
        if stdin_data.respond_to? :readpartial
          IO.copy_stream(stdin_data, i)
        else
          i.write stdin_data
        end
      rescue Errno::EPIPE
      end
    end
    i.close
    [outerr_reader.value, t.value]
  }
end</pre> </div> <p><a href="open3#method-c-capture2e"><code>Open3.capture2e</code></a> captures the standard output and the standard error of a command.</p> <pre>stdout_and_stderr_str, status = Open3.capture2e([env,] cmd... [, opts])</pre> <p>The arguments env, cmd and opts are passed to <a href="open3#method-c-popen3"><code>Open3.popen3</code></a> except <code>opts[:stdin_data]</code> and <code>opts[:binmode]</code>. See <a href="process#method-c-spawn"><code>Process.spawn</code></a>.</p> <p>If <code>opts[:stdin_data]</code> is specified, it is sent to the command's standard input.</p> <p>If <code>opts[:binmode]</code> is true, internal pipes are set to binary mode.</p> <p>Example:</p> <pre class="ruby" data-language="ruby"># capture make log
make_log, s = Open3.capture2e("make")
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-capture3"> <span class="method-name">capture3</span><span class="method-args">(*cmd)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="capture3-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 279
def capture3(*cmd)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  stdin_data = opts.delete(:stdin_data) || ''
  binmode = opts.delete(:binmode)

  popen3(*cmd, opts) {|i, o, e, t|
    if binmode
      i.binmode
      o.binmode
      e.binmode
    end
    out_reader = Thread.new { o.read }
    err_reader = Thread.new { e.read }
    begin
      if stdin_data.respond_to? :readpartial
        IO.copy_stream(stdin_data, i)
      else
        i.write stdin_data
      end
    rescue Errno::EPIPE
    end
    i.close
    [out_reader.value, err_reader.value, t.value]
  }
end</pre> </div> <p><a href="open3#method-c-capture3"><code>Open3.capture3</code></a> captures the standard output and the standard error of a command.</p> <pre>stdout_str, stderr_str, status = Open3.capture3([env,] cmd... [, opts])</pre> <p>The arguments env, cmd and opts are passed to <a href="open3#method-c-popen3"><code>Open3.popen3</code></a> except <code>opts[:stdin_data]</code> and <code>opts[:binmode]</code>. See <a href="process#method-c-spawn"><code>Process.spawn</code></a>.</p> <p>If <code>opts[:stdin_data]</code> is specified, it is sent to the command's standard input.</p> <p>If <code>opts[:binmode]</code> is true, internal pipes are set to binary mode.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby"># dot is a command of graphviz.
graph = &lt;&lt;'End'
  digraph g {
    a -&gt; b
  }
End
drawn_graph, dot_log = Open3.capture3("dot -v", :stdin_data=&gt;graph)

o, e, s = Open3.capture3("echo abc; sort &gt;&amp;2", :stdin_data=&gt;"foo\nbar\nbaz\n")
p o #=&gt; "abc\n"
p e #=&gt; "bar\nbaz\nfoo\n"
p s #=&gt; #&lt;Process::Status: pid 32682 exit 0&gt;

# generate a thumbnail image using the convert command of ImageMagick.
# However, if the image is really stored in a file,
# system("convert", "-thumbnail", "80", "png:#{filename}", "png:-") is better
# because of reduced memory consumption.
# But if the image is stored in a DB or generated by the gnuplot Open3.capture2 example,
# Open3.capture3 should be considered.
#
image = File.read("/usr/share/openclipart/png/animals/mammals/sheep-md-v0.1.png", :binmode=&gt;true)
thumbnail, err, s = Open3.capture3("convert -thumbnail 80 png:- png:-", :stdin_data=&gt;image, :binmode=&gt;true)
if s.success?
  STDOUT.binmode; print thumbnail
end
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pipeline"> <span class="method-name">pipeline</span><span class="method-args">(*cmds)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pipeline-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 687
def pipeline(*cmds)
  if Hash === cmds.last
    opts = cmds.pop.dup
  else
    opts = {}
  end

  pipeline_run(cmds, opts, [], []) {|ts|
    ts.map(&amp;:value)
  }
end</pre> </div> <p><a href="open3#method-c-pipeline"><code>Open3.pipeline</code></a> starts a list of commands as a pipeline. It waits for the completion of the commands. No pipes are created for stdin of the first command and stdout of the last command.</p> <pre>status_list = Open3.pipeline(cmd1, cmd2, ... [, opts])</pre> <p>Each cmd is a string or an array. If it is an array, the elements are passed to <a href="process#method-c-spawn"><code>Process.spawn</code></a>.</p> <pre>cmd:
  commandline                              command line string which is passed to a shell
  [env, commandline, opts]                 command line string which is passed to a shell
  [env, cmdname, arg1, ..., opts]          command name and one or more arguments (no shell)
  [env, [cmdname, argv0], arg1, ..., opts] command name and arguments including argv[0] (no shell)

Note that env and opts are optional, as Process.spawn.</pre> <p>Example:</p> <pre class="ruby" data-language="ruby">fname = "/usr/share/man/man1/ruby.1.gz"
p Open3.pipeline(["zcat", fname], "nroff -man", "less")
#=&gt; [#&lt;Process::Status: pid 11817 exit 0&gt;,
#    #&lt;Process::Status: pid 11820 exit 0&gt;,
#    #&lt;Process::Status: pid 11828 exit 0&gt;]

fname = "/usr/share/man/man1/ls.1.gz"
Open3.pipeline(["zcat", fname], "nroff -man", "colcrt")

# convert PDF to PS and send to a printer by lpr
pdf_file = "paper.pdf"
printer = "printer-name"
Open3.pipeline(["pdftops", pdf_file, "-"],
               ["lpr", "-P#{printer}"])

# count lines
Open3.pipeline("sort", "uniq -c", :in=&gt;"names.txt", :out=&gt;"count")

# cyclic pipeline
r,w = IO.pipe
w.print "ibase=14\n10\n"
Open3.pipeline("bc", "tee /dev/tty", :in=&gt;r, :out=&gt;w)
#=&gt; 14
#   18
#   22
#   30
#   42
#   58
#   78
#   106
#   202
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pipeline_r"> <span class="method-name">pipeline_r</span><span class="method-args">(*cmds, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pipeline_r-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 518
def pipeline_r(*cmds, &amp;block)
  if Hash === cmds.last
    opts = cmds.pop.dup
  else
    opts = {}
  end

  out_r, out_w = IO.pipe
  opts[:out] = out_w

  pipeline_run(cmds, opts, [out_w], [out_r], &amp;block)
end</pre> </div> <p><a href="open3#method-c-pipeline_r"><code>Open3.pipeline_r</code></a> starts a list of commands as a pipeline with a pipe which connects to stdout of the last command.</p> <pre>Open3.pipeline_r(cmd1, cmd2, ... [, opts]) {|last_stdout, wait_threads|
  ...
}

last_stdout, wait_threads = Open3.pipeline_r(cmd1, cmd2, ... [, opts])
...
last_stdout.close</pre> <p>Each cmd is a string or an array. If it is an array, the elements are passed to <a href="process#method-c-spawn"><code>Process.spawn</code></a>.</p> <pre>cmd:
  commandline                              command line string which is passed to a shell
  [env, commandline, opts]                 command line string which is passed to a shell
  [env, cmdname, arg1, ..., opts]          command name and one or more arguments (no shell)
  [env, [cmdname, argv0], arg1, ..., opts] command name and arguments including argv[0] (no shell)

Note that env and opts are optional, as for Process.spawn.</pre> <p>Example:</p> <pre>Open3.pipeline_r("zcat /var/log/apache2/access.log.*.gz",
                 [{"LANG"=&gt;"C"}, "grep", "GET /favicon.ico"],
                 "logresolve") {|o, ts|
  o.each_line {|line|
    ...
  }
}

Open3.pipeline_r("yes", "head -10") {|o, ts|
  p o.read      #=&gt; "y\ny\ny\ny\ny\ny\ny\ny\ny\ny\n"
  p ts[0].value #=&gt; #&lt;Process::Status: pid 24910 SIGPIPE (signal 13)&gt;
  p ts[1].value #=&gt; #&lt;Process::Status: pid 24913 exit 0&gt;
}</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pipeline_rw"> <span class="method-name">pipeline_rw</span><span class="method-args">(*cmds, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pipeline_rw-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 462
def pipeline_rw(*cmds, &amp;block)
  if Hash === cmds.last
    opts = cmds.pop.dup
  else
    opts = {}
  end

  in_r, in_w = IO.pipe
  opts[:in] = in_r
  in_w.sync = true

  out_r, out_w = IO.pipe
  opts[:out] = out_w

  pipeline_run(cmds, opts, [in_r, out_w], [in_w, out_r], &amp;block)
end</pre> </div> <p><a href="open3#method-c-pipeline_rw"><code>Open3.pipeline_rw</code></a> starts a list of commands as a pipeline with pipes which connect to stdin of the first command and stdout of the last command.</p> <pre>Open3.pipeline_rw(cmd1, cmd2, ... [, opts]) {|first_stdin, last_stdout, wait_threads|
  ...
}

first_stdin, last_stdout, wait_threads = Open3.pipeline_rw(cmd1, cmd2, ... [, opts])
...
first_stdin.close
last_stdout.close</pre> <p>Each cmd is a string or an array. If it is an array, the elements are passed to <a href="process#method-c-spawn"><code>Process.spawn</code></a>.</p> <pre>cmd:
  commandline                              command line string which is passed to a shell
  [env, commandline, opts]                 command line string which is passed to a shell
  [env, cmdname, arg1, ..., opts]          command name and one or more arguments (no shell)
  [env, [cmdname, argv0], arg1, ..., opts] command name and arguments including argv[0] (no shell)

Note that env and opts are optional, as for Process.spawn.</pre> <p>The options to pass to <a href="process#method-c-spawn"><code>Process.spawn</code></a> are constructed by merging <code>opts</code>, the last hash element of the array, and specifications for the pipes between each of the commands.</p> <p>Example:</p> <pre class="ruby" data-language="ruby">Open3.pipeline_rw("tr -dc A-Za-z", "wc -c") {|i, o, ts|
  i.puts "All persons more than a mile high to leave the court."
  i.close
  p o.gets #=&gt; "42\n"
}

Open3.pipeline_rw("sort", "cat -n") {|stdin, stdout, wait_thrs|
  stdin.puts "foo"
  stdin.puts "bar"
  stdin.puts "baz"
  stdin.close     # send EOF to sort.
  p stdout.read   #=&gt; "     1\tbar\n     2\tbaz\n     3\tfoo\n"
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pipeline_start"> <span class="method-name">pipeline_start</span><span class="method-args">(*cmds, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pipeline_start-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 619
def pipeline_start(*cmds, &amp;block)
  if Hash === cmds.last
    opts = cmds.pop.dup
  else
    opts = {}
  end

  if block
    pipeline_run(cmds, opts, [], [], &amp;block)
  else
    ts, = pipeline_run(cmds, opts, [], [])
    ts
  end
end</pre> </div> <p><a href="open3#method-c-pipeline_start"><code>Open3.pipeline_start</code></a> starts a list of commands as a pipeline. No pipes are created for stdin of the first command and stdout of the last command.</p> <pre>Open3.pipeline_start(cmd1, cmd2, ... [, opts]) {|wait_threads|
  ...
}

wait_threads = Open3.pipeline_start(cmd1, cmd2, ... [, opts])
...</pre> <p>Each cmd is a string or an array. If it is an array, the elements are passed to <a href="process#method-c-spawn"><code>Process.spawn</code></a>.</p> <pre>cmd:
  commandline                              command line string which is passed to a shell
  [env, commandline, opts]                 command line string which is passed to a shell
  [env, cmdname, arg1, ..., opts]          command name and one or more arguments (no shell)
  [env, [cmdname, argv0], arg1, ..., opts] command name and arguments including argv[0] (no shell)

Note that env and opts are optional, as for Process.spawn.</pre> <p>Example:</p> <pre class="ruby" data-language="ruby"># Run xeyes in 10 seconds.
Open3.pipeline_start("xeyes") {|ts|
  sleep 10
  t = ts[0]
  Process.kill("TERM", t.pid)
  p t.value #=&gt; #&lt;Process::Status: pid 911 SIGTERM (signal 15)&gt;
}

# Convert pdf to ps and send it to a printer.
# Collect error message of pdftops and lpr.
pdf_file = "paper.pdf"
printer = "printer-name"
err_r, err_w = IO.pipe
Open3.pipeline_start(["pdftops", pdf_file, "-"],
                     ["lpr", "-P#{printer}"],
                     :err=&gt;err_w) {|ts|
  err_w.close
  p err_r.read # error messages of pdftops and lpr.
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pipeline_w"> <span class="method-name">pipeline_w</span><span class="method-args">(*cmds, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pipeline_w-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 560
def pipeline_w(*cmds, &amp;block)
  if Hash === cmds.last
    opts = cmds.pop.dup
  else
    opts = {}
  end

  in_r, in_w = IO.pipe
  opts[:in] = in_r
  in_w.sync = true

  pipeline_run(cmds, opts, [in_r], [in_w], &amp;block)
end</pre> </div> <p><a href="open3#method-c-pipeline_w"><code>Open3.pipeline_w</code></a> starts a list of commands as a pipeline with a pipe which connects to stdin of the first command.</p> <pre>Open3.pipeline_w(cmd1, cmd2, ... [, opts]) {|first_stdin, wait_threads|
  ...
}

first_stdin, wait_threads = Open3.pipeline_w(cmd1, cmd2, ... [, opts])
...
first_stdin.close</pre> <p>Each cmd is a string or an array. If it is an array, the elements are passed to <a href="process#method-c-spawn"><code>Process.spawn</code></a>.</p> <pre>cmd:
  commandline                              command line string which is passed to a shell
  [env, commandline, opts]                 command line string which is passed to a shell
  [env, cmdname, arg1, ..., opts]          command name and one or more arguments (no shell)
  [env, [cmdname, argv0], arg1, ..., opts] command name and arguments including argv[0] (no shell)

Note that env and opts are optional, as for Process.spawn.</pre> <p>Example:</p> <pre class="ruby" data-language="ruby">Open3.pipeline_w("bzip2 -c", :out=&gt;"/tmp/hello.bz2") {|i, ts|
  i.puts "hello"
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-popen2"> <span class="method-name">popen2</span><span class="method-args">(*cmd, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="popen2-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 146
def popen2(*cmd, &amp;block)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  in_r, in_w = IO.pipe
  opts[:in] = in_r
  in_w.sync = true

  out_r, out_w = IO.pipe
  opts[:out] = out_w

  popen_run(cmd, opts, [in_r, out_w], [in_w, out_r], &amp;block)
end</pre> </div> <p><a href="open3#method-c-popen2"><code>Open3.popen2</code></a> is similar to <a href="open3#method-c-popen3"><code>Open3.popen3</code></a> except that it doesn't create a pipe for the standard error stream.</p> <p>Block form:</p> <pre>Open3.popen2([env,] cmd... [, opts]) {|stdin, stdout, wait_thr|
  pid = wait_thr.pid # pid of the started process.
  ...
  exit_status = wait_thr.value # Process::Status object returned.
}</pre> <p>Non-block form:</p> <pre>stdin, stdout, wait_thr = Open3.popen2([env,] cmd... [, opts])
...
stdin.close  # stdin and stdout should be closed explicitly in this form.
stdout.close</pre> <p>See <a href="process#method-c-spawn"><code>Process.spawn</code></a> for the optional hash arguments <em>env</em> and <em>opts</em>.</p> <p>Example:</p> <pre class="ruby" data-language="ruby">Open3.popen2("wc -c") {|i,o,t|
  i.print "answer to life the universe and everything"
  i.close
  p o.gets #=&gt; "42\n"
}

Open3.popen2("bc -q") {|i,o,t|
  i.puts "obase=13"
  i.puts "6 * 9"
  p o.gets #=&gt; "42\n"
}

Open3.popen2("dc") {|i,o,t|
  i.print "42P"
  i.close
  p o.read #=&gt; "*"
}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-popen2e"> <span class="method-name">popen2e</span><span class="method-args">(*cmd, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="popen2e-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 195
def popen2e(*cmd, &amp;block)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  in_r, in_w = IO.pipe
  opts[:in] = in_r
  in_w.sync = true

  out_r, out_w = IO.pipe
  opts[[:out, :err]] = out_w

  popen_run(cmd, opts, [in_r, out_w], [in_w, out_r], &amp;block)
ensure
  if block
    in_r.close
    in_w.close
    out_r.close
    out_w.close
  end
end</pre> </div> <p><a href="open3#method-c-popen2e"><code>Open3.popen2e</code></a> is similar to <a href="open3#method-c-popen3"><code>Open3.popen3</code></a> except that it merges the standard output stream and the standard error stream.</p> <p>Block form:</p> <pre>Open3.popen2e([env,] cmd... [, opts]) {|stdin, stdout_and_stderr, wait_thr|
  pid = wait_thr.pid # pid of the started process.
  ...
  exit_status = wait_thr.value # Process::Status object returned.
}</pre> <p>Non-block form:</p> <pre>stdin, stdout_and_stderr, wait_thr = Open3.popen2e([env,] cmd... [, opts])
...
stdin.close  # stdin and stdout_and_stderr should be closed explicitly in this form.
stdout_and_stderr.close</pre> <p>See <a href="process#method-c-spawn"><code>Process.spawn</code></a> for the optional hash arguments <em>env</em> and <em>opts</em>.</p> <p>Example:</p> <pre># check gcc warnings
source = "foo.c"
Open3.popen2e("gcc", "-Wall", source) {|i,oe,t|
  oe.each {|line|
    if /warning/ =~ line
      ...
    end
  }
}</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-popen3"> <span class="method-name">popen3</span><span class="method-args">(*cmd, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="popen3-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 85
def popen3(*cmd, &amp;block)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  in_r, in_w = IO.pipe
  opts[:in] = in_r
  in_w.sync = true

  out_r, out_w = IO.pipe
  opts[:out] = out_w

  err_r, err_w = IO.pipe
  opts[:err] = err_w

  popen_run(cmd, opts, [in_r, out_w, err_w], [in_w, out_r, err_r], &amp;block)
end</pre> </div> <p>Open stdin, stdout, and stderr streams and start external executable. In addition, a thread to wait for the started process is created. The thread has a pid method and a thread variable :pid which is the pid of the started process.</p> <p>Block form:</p> <pre>Open3.popen3([env,] cmd... [, opts]) {|stdin, stdout, stderr, wait_thr|
  pid = wait_thr.pid # pid of the started process.
  ...
  exit_status = wait_thr.value # Process::Status object returned.
}</pre> <p>Non-block form:</p> <pre>stdin, stdout, stderr, wait_thr = Open3.popen3([env,] cmd... [, opts])
pid = wait_thr[:pid]  # pid of the started process
...
stdin.close  # stdin, stdout and stderr should be closed explicitly in this form.
stdout.close
stderr.close
exit_status = wait_thr.value  # Process::Status object returned.</pre> <p>The parameters env, cmd, and opts are passed to <a href="process#method-c-spawn"><code>Process.spawn</code></a>. A commandline string and a list of argument strings can be accepted as follows:</p> <pre>Open3.popen3("echo abc") {|i, o, e, t| ... }
Open3.popen3("echo", "abc") {|i, o, e, t| ... }
Open3.popen3(["echo", "argv0"], "abc") {|i, o, e, t| ... }</pre> <p>If the last parameter, opts, is a <a href="hash"><code>Hash</code></a>, it is recognized as an option for <a href="process#method-c-spawn"><code>Process.spawn</code></a>.</p> <pre class="ruby" data-language="ruby">Open3.popen3("pwd", :chdir=&gt;"/") {|i,o,e,t|
  p o.read.chomp #=&gt; "/"
}
</pre> <p>wait_thr.value waits for the termination of the process. The block form also waits for the process when it returns.</p> <p>Closing stdin, stdout and stderr does not wait for the process to complete.</p> <p>You should be careful to avoid deadlocks. Since pipes are fixed length buffers, <a href="open3#method-c-popen3"><code>Open3.popen3</code></a>(“prog”) {|i, o, e, t| o.read } deadlocks if the program generates too much output on stderr. You should read stdout and stderr simultaneously (using threads or <a href="io#method-c-select"><code>IO.select</code></a>). However, if you don't need stderr output, you can use <a href="open3#method-c-popen2"><code>Open3.popen2</code></a>. If merged stdout and stderr output is not a problem, you can use <a href="open3#method-c-popen2e"><code>Open3.popen2e</code></a>. If you really need stdout and stderr output as separate strings, you can consider <a href="open3#method-c-capture3"><code>Open3.capture3</code></a>.</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2020 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
