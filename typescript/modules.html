<h1>Modules</h1>
<p>Starting with ECMAScript 2015, JavaScript has a concept of modules. TypeScript shares this concept.</p> <p>Modules are executed within their own scope, not in the global scope; this means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the <a href="#export"><code>export</code> forms</a>. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the <a href="#import"><code>import</code> forms</a>.</p> <p>Modules are declarative; the relationships between modules are specified in terms of imports and exports at the file level.</p> <p>Modules import one another using a module loader. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it. Well-known module loaders used in JavaScript are Node.js’s loader for <a href="https://wikipedia.org/wiki/CommonJS">CommonJS</a> modules and the <a href="http://requirejs.org/">RequireJS</a> loader for <a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md">AMD</a> modules in Web applications.</p> <p>In TypeScript, just as in ECMAScript 2015, any file containing a top-level <code>import</code> or <code>export</code> is considered a module. Conversely, a file without any top-level <code>import</code> or <code>export</code> declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).</p> <h2 id="export" style="position:relative;">Export</h2> <h2 id="exporting-a-declaration" style="position:relative;">Exporting a declaration</h2> <p>Any declaration (such as a variable, function, class, type alias, or interface) can be exported by adding the <code>export</code> keyword.</p> <h5 id="stringvalidatorts" style="position:relative;">StringValidator.ts</h5> <pre data-language="ts">export interface StringValidator {
  isAcceptable(s: string): boolean;
}</pre> <h5 id="zipcodevalidatorts" style="position:relative;">ZipCodeValidator.ts</h5> <pre data-language="ts">import { StringValidator } from "./StringValidator";

export const numberRegexp = /^[0-9]+$/;

export class ZipCodeValidator implements StringValidator {
  isAcceptable(s: string) {
    return s.length === 5 &amp;&amp; numberRegexp.test(s);
  }
}</pre> <h2 id="export-statements" style="position:relative;">Export statements</h2> <p>Export statements are handy when exports need to be renamed for consumers, so the above example can be written as:</p> <pre data-language="ts">class ZipCodeValidator implements StringValidator {
  isAcceptable(s: string) {
    return s.length === 5 &amp;&amp; numberRegexp.test(s);
  }
}
export { ZipCodeValidator };
export { ZipCodeValidator as mainValidator };</pre> <h2 id="re-exports" style="position:relative;">Re-exports</h2> <p>Often modules extend other modules, and partially expose some of their features. A re-export does not import it locally, or introduce a local variable.</p> <h5 id="parseintbasedzipcodevalidatorts" style="position:relative;">ParseIntBasedZipCodeValidator.ts</h5> <pre data-language="ts">export class ParseIntBasedZipCodeValidator {
  isAcceptable(s: string) {
    return s.length === 5 &amp;&amp; parseInt(s).toString() === s;
  }
}

// Export original validator but rename it
export { ZipCodeValidator as RegExpBasedZipCodeValidator } from "./ZipCodeValidator";</pre> <p>Optionally, a module can wrap one or more modules and combine all their exports using <code>export * from "module"</code> syntax.</p> <h5 id="allvalidatorsts" style="position:relative;">AllValidators.ts</h5> <pre data-language="ts">export * from "./StringValidator"; // exports 'StringValidator' interface
export * from "./ZipCodeValidator"; // exports 'ZipCodeValidator' class and 'numberRegexp' constant value
export * from "./ParseIntBasedZipCodeValidator"; //  exports the 'ParseIntBasedZipCodeValidator' class
// and re-exports 'RegExpBasedZipCodeValidator' as alias
// of the 'ZipCodeValidator' class from 'ZipCodeValidator.ts'
// module.</pre> <h2 id="import" style="position:relative;">Import</h2> <p>Importing is just about as easy as exporting from a module. Importing an exported declaration is done through using one of the <code>import</code> forms below:</p> <h2 id="import-a-single-export-from-a-module" style="position:relative;">Import a single export from a module</h2> <pre data-language="ts">import { ZipCodeValidator } from "./ZipCodeValidator";

let myValidator = new ZipCodeValidator();</pre> <p>imports can also be renamed</p> <pre data-language="ts">import { ZipCodeValidator as ZCV } from "./ZipCodeValidator";
let myValidator = new ZCV();</pre> <h2 id="import-the-entire-module-into-a-single-variable-and-use-it-to-access-the-module-exports" style="position:relative;">Import the entire module into a single variable, and use it to access the module exports</h2> <pre data-language="ts">import * as validator from "./ZipCodeValidator";
let myValidator = new validator.ZipCodeValidator();</pre> <h2 id="import-a-module-for-side-effects-only" style="position:relative;">Import a module for side-effects only</h2> <p>Though not recommended practice, some modules set up some global state that can be used by other modules. These modules may not have any exports, or the consumer is not interested in any of their exports. To import these modules, use:</p> <pre data-language="ts">import "./my-module.js";</pre> <h2 id="importing-types" style="position:relative;">Importing Types</h2> <p>Prior to TypeScript 3.8, you can import a type using <code>import</code>. With TypeScript 3.8, you can import a type using the <code>import</code> statement, or using <code>import type</code>.</p> <pre data-language="ts">// Re-using the same import
import { APIResponseType } from "./api";

// Explicitly use import type
import type { APIResponseType } from "./api";</pre> <p><code>import type</code> is always guaranteed to be removed from your JavaScript, and tools like Babel can make better assumptions about your code via the <code>isolatedModules</code> compiler flag. You can read more in the <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#type-only-imports-exports">3.8 release notes</a>.</p> <h2 id="default-exports" style="position:relative;">Default exports</h2> <p>Each module can optionally export a <code>default</code> export. Default exports are marked with the keyword <code>default</code>; and there can only be one <code>default</code> export per module. <code>default</code> exports are imported using a different import form.</p> <p><code>default</code> exports are really handy. For instance, a library like jQuery might have a default export of <code>jQuery</code> or <code>$</code>, which we’d probably also import under the name <code>$</code> or <code>jQuery</code>.</p> <h5 id="jquerydts" style="position:relative;"><a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/jquery/JQuery.d.ts">JQuery.d.ts</a></h5> <pre data-language="ts">declare let $: JQuery;
export default $;</pre> <h5 id="appts" style="position:relative;">App.ts</h5> <pre data-language="ts">import $ from "jquery";

$("button.continue").html("Next Step...");</pre> <p>Classes and function declarations can be authored directly as default exports. Default export class and function declaration names are optional.</p> <h5 id="zipcodevalidatorts-1" style="position:relative;">ZipCodeValidator.ts</h5> <pre data-language="ts">export default class ZipCodeValidator {
  static numberRegexp = /^[0-9]+$/;
  isAcceptable(s: string) {
    return s.length === 5 &amp;&amp; ZipCodeValidator.numberRegexp.test(s);
  }
}</pre> <h5 id="testts" style="position:relative;">Test.ts</h5> <pre data-language="ts">import validator from "./ZipCodeValidator";

let myValidator = new validator();</pre> <p>or</p> <h5 id="staticzipcodevalidatorts" style="position:relative;">StaticZipCodeValidator.ts</h5> <pre data-language="ts">const numberRegexp = /^[0-9]+$/;

export default function (s: string) {
  return s.length === 5 &amp;&amp; numberRegexp.test(s);
}</pre> <h5 id="testts-1" style="position:relative;">Test.ts</h5> <pre data-language="ts">import validate from "./StaticZipCodeValidator";

let strings = ["Hello", "98052", "101"];

// Use function validate
strings.forEach((s) =&gt; {
  console.log(`"${s}" ${validate(s) ? "matches" : "does not match"}`);
});</pre> <p><code>default</code> exports can also be just values:</p> <h5 id="onetwothreets" style="position:relative;">OneTwoThree.ts</h5> <pre data-language="ts">export default "123";</pre> <h5 id="logts" style="position:relative;">Log.ts</h5> <pre data-language="ts">import num from "./OneTwoThree";

console.log(num); // "123"</pre> <h2 id="export-all-as-x" style="position:relative;">Export all as x</h2> <p>With TypeScript 3.8, you can use <code>export * as ns</code> as a shorthand for re-exporting another module with a name:</p> <pre data-language="ts">export * as utilities from "./utilities";</pre> <p>This takes all of the dependencies from a module and makes it an exported field, you could import it like this:</p> <pre data-language="ts">import { utilities } from "./index";</pre> <h2 id="export--and-import--require" style="position:relative;">
<code>export =</code> and <code>import = require()</code>
</h2> <p>Both CommonJS and AMD generally have the concept of an <code>exports</code> object which contains all exports from a module.</p> <p>They also support replacing the <code>exports</code> object with a custom single object. Default exports are meant to act as a replacement for this behavior; however, the two are incompatible. TypeScript supports <code>export =</code> to model the traditional CommonJS and AMD workflow.</p> <p>The <code>export =</code> syntax specifies a single object that is exported from the module. This can be a class, interface, namespace, function, or enum.</p> <p>When exporting a module using <code>export =</code>, TypeScript-specific <code>import module = require("module")</code> must be used to import the module.</p> <h5 id="zipcodevalidatorts-2" style="position:relative;">ZipCodeValidator.ts</h5> <pre data-language="ts">let numberRegexp = /^[0-9]+$/;
class ZipCodeValidator {
  isAcceptable(s: string) {
    return s.length === 5 &amp;&amp; numberRegexp.test(s);
  }
}
export = ZipCodeValidator;</pre> <h5 id="testts-2" style="position:relative;">Test.ts</h5> <pre data-language="ts">import zip = require("./ZipCodeValidator");

// Some samples to try
let strings = ["Hello", "98052", "101"];

// Validators to use
let validator = new zip();

// Show whether each string passed each validator
strings.forEach((s) =&gt; {
  console.log(
    `"${s}" - ${validator.isAcceptable(s) ? "matches" : "does not match"}`
  );
});</pre> <h2 id="code-generation-for-modules" style="position:relative;">Code Generation for Modules</h2> <p>Depending on the module target specified during compilation, the compiler will generate appropriate code for Node.js (<a href="http://wiki.commonjs.org/wiki/CommonJS">CommonJS</a>), require.js (<a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a>), <a href="https://github.com/umdjs/umd">UMD</a>, <a href="https://github.com/systemjs/systemjs">SystemJS</a>, or <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-modules">ECMAScript 2015 native modules</a> (ES6) module-loading systems. For more information on what the <code>define</code>, <code>require</code> and <code>register</code> calls in the generated code do, consult the documentation for each module loader.</p> <p>This simple example shows how the names used during importing and exporting get translated into the module loading code.</p> <h5 id="simplemodulets" style="position:relative;">SimpleModule.ts</h5> <pre data-language="ts">import m = require("mod");
export let t = m.something + 1;</pre> <h5 id="amd--requirejs-simplemodulejs" style="position:relative;">AMD / RequireJS SimpleModule.js</h5> <pre data-language="js">define(["require", "exports", "./mod"], function (require, exports, mod_1) {
  exports.t = mod_1.something + 1;
});</pre> <h5 id="commonjs--node-simplemodulejs" style="position:relative;">CommonJS / Node SimpleModule.js</h5> <pre data-language="js">var mod_1 = require("./mod");
exports.t = mod_1.something + 1;</pre> <h5 id="umd-simplemodulejs" style="position:relative;">UMD SimpleModule.js</h5> <pre data-language="js">(function (factory) {
  if (typeof module === "object" &amp;&amp; typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" &amp;&amp; define.amd) {
    define(["require", "exports", "./mod"], factory);
  }
})(function (require, exports) {
  var mod_1 = require("./mod");
  exports.t = mod_1.something + 1;
});</pre> <h5 id="system-simplemodulejs" style="position:relative;">System SimpleModule.js</h5> <pre data-language="js">System.register(["./mod"], function (exports_1) {
  var mod_1;
  var t;
  return {
    setters: [
      function (mod_1_1) {
        mod_1 = mod_1_1;
      },
    ],
    execute: function () {
      exports_1("t", (t = mod_1.something + 1));
    },
  };
});</pre> <h5 id="native-ecmascript-2015-modules-simplemodulejs" style="position:relative;">Native ECMAScript 2015 modules SimpleModule.js</h5> <pre data-language="js">import { something } from "./mod";
export var t = something + 1;</pre> <h2 id="simple-example" style="position:relative;">Simple Example</h2> <p>Below, we’ve consolidated the Validator implementations used in previous examples to only export a single named export from each module.</p> <p>To compile, we must specify a module target on the command line. For Node.js, use <code>--module commonjs</code>; for require.js, use <code>--module amd</code>. For example:</p> <pre data-language="typescript">tsc --module commonjs Test.ts</pre>Yes<button title="Dislike this page" id="dislike-button"> No</button><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.typescriptlang.org/docs/handbook/modules.html" class="_attribution-link" target="_blank">https://www.typescriptlang.org/docs/handbook/modules.html</a>
  </p>
</div>
