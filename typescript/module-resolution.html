<h1>Module Resolution</h1>
<blockquote> <p>This section assumes some basic knowledge about modules. Please see the <a href="modules">Modules</a> documentation for more information.</p> </blockquote> <p><em>Module resolution</em> is the process the compiler uses to figure out what an import refers to. Consider an import statement like <code>import { a } from "moduleA"</code>; in order to check any use of <code>a</code>, the compiler needs to know exactly what it represents, and will need to check its definition <code>moduleA</code>.</p> <p>At this point, the compiler will ask “what’s the shape of <code>moduleA</code>?” While this sounds straightforward, <code>moduleA</code> could be defined in one of your own <code>.ts</code>/<code>.tsx</code> files, or in a <code>.d.ts</code> that your code depends on.</p> <p>First, the compiler will try to locate a file that represents the imported module. To do so the compiler follows one of two different strategies: <a href="#classic">Classic</a> or <a href="#node">Node</a>. These strategies tell the compiler <em>where</em> to look for <code>moduleA</code>.</p> <p>If that didn’t work and if the module name is non-relative (and in the case of <code>"moduleA"</code>, it is), then the compiler will attempt to locate an <a href="modules#ambient-modules">ambient module declaration</a>. We’ll cover non-relative imports next.</p> <p>Finally, if the compiler could not resolve the module, it will log an error. In this case, the error would be something like <code>error TS2307: Cannot find module 'moduleA'.</code></p> <h2 id="relative-vs-non-relative-module-imports" style="position:relative;">Relative vs. Non-relative module imports</h2> <p>Module imports are resolved differently based on whether the module reference is relative or non-relative.</p> <p>A <em>relative import</em> is one that starts with <code>/</code>, <code>./</code> or <code>../</code>. Some examples include:</p> <ul> <li><code>import Entry from "./components/Entry";</code></li> <li><code>import { DefaultHeaders } from "../constants/http";</code></li> <li><code>import "/mod";</code></li> </ul> <p>Any other import is considered <strong>non-relative</strong>. Some examples include:</p> <ul> <li><code>import * as $ from "jquery";</code></li> <li><code>import { Component } from "@angular/core";</code></li> </ul> <p>A relative import is resolved relative to the importing file and <em>cannot</em> resolve to an ambient module declaration. You should use relative imports for your own modules that are guaranteed to maintain their relative location at runtime.</p> <p>A non-relative import can be resolved relative to <code>baseUrl</code>, or through path mapping, which we’ll cover below. They can also resolve to <a href="modules#ambient-modules">ambient module declarations</a>. Use non-relative paths when importing any of your external dependencies.</p> <h2 id="module-resolution-strategies" style="position:relative;">Module Resolution Strategies</h2> <p>There are two possible module resolution strategies: <a href="#node">Node</a> and <a href="#classic">Classic</a>. You can use the <code>--moduleResolution</code> flag to specify the module resolution strategy. If not specified, the default is <a href="#node">Node</a> for <code>--module commonjs</code>, and <a href="#classic">Classic</a> otherwise (including when <code>--module</code> is set to <code>amd</code>, <code>system</code>, <code>umd</code>, <code>es2015</code>, <code>esnext</code>, etc.).</p> <blockquote> <p>Note: <code>node</code> module resolution is the most-commonly used in the TypeScript community and is recommended for most projects. If you are having resolution problems with <code>import</code>s and <code>export</code>s in TypeScript, try setting <code>moduleResolution: "node"</code> to see if it fixes the issue.</p> </blockquote> <h3 id="classic" style="position:relative;">Classic</h3> <p>This used to be TypeScript’s default resolution strategy. Nowadays, this strategy is mainly present for backward compatibility.</p> <p>A relative import will be resolved relative to the importing file. So <code>import { b } from "./moduleB"</code> in source file <code>/root/src/folder/A.ts</code> would result in the following lookups:</p> <ol> <li><code>/root/src/folder/moduleB.ts</code></li> <li><code>/root/src/folder/moduleB.d.ts</code></li> </ol> <p>For non-relative module imports, however, the compiler walks up the directory tree starting with the directory containing the importing file, trying to locate a matching definition file.</p> <p>For example:</p> <p>A non-relative import to <code>moduleB</code> such as <code>import { b } from "moduleB"</code>, in a source file <code>/root/src/folder/A.ts</code>, would result in attempting the following locations for locating <code>"moduleB"</code>:</p> <ol> <li><code>/root/src/folder/moduleB.ts</code></li> <li><code>/root/src/folder/moduleB.d.ts</code></li> <li><code>/root/src/moduleB.ts</code></li> <li><code>/root/src/moduleB.d.ts</code></li> <li><code>/root/moduleB.ts</code></li> <li><code>/root/moduleB.d.ts</code></li> <li><code>/moduleB.ts</code></li> <li><code>/moduleB.d.ts</code></li> </ol> <h3 id="node" style="position:relative;">Node</h3> <p>This resolution strategy attempts to mimic the <a href="https://nodejs.org/">Node.js</a> module resolution mechanism at runtime. The full Node.js resolution algorithm is outlined in <a href="https://nodejs.org/api/modules.html#modules_all_together">Node.js module documentation</a>.</p> <h4 id="how-nodejs-resolves-modules" style="position:relative;">How Node.js resolves modules</h4> <p>To understand what steps the TS compiler will follow, it is important to shed some light on Node.js modules. Traditionally, imports in Node.js are performed by calling a function named <code>require</code>. The behavior Node.js takes will differ depending on if <code>require</code> is given a relative path or a non-relative path.</p> <p>Relative paths are fairly straightforward. As an example, let’s consider a file located at <code>/root/src/moduleA.js</code>, which contains the import <code>var x = require("./moduleB");</code> Node.js resolves that import in the following order:</p> <ol> <li> <p>Ask the file named <code>/root/src/moduleB.js</code>, if it exists.</p> </li> <li> <p>Ask the folder <code>/root/src/moduleB</code> if it contains a file named <code>package.json</code> that specifies a <code>"main"</code> module. In our example, if Node.js found the file <code>/root/src/moduleB/package.json</code> containing <code>{ "main": "lib/mainModule.js" }</code>, then Node.js will refer to <code>/root/src/moduleB/lib/mainModule.js</code>.</p> </li> <li> <p>Ask the folder <code>/root/src/moduleB</code> if it contains a file named <code>index.js</code>. That file is implicitly considered that folder’s “main” module.</p> </li> </ol> <p>You can read more about this in Node.js documentation on <a href="https://nodejs.org/api/modules.html#modules_file_modules">file modules</a> and <a href="https://nodejs.org/api/modules.html#modules_folders_as_modules">folder modules</a>.</p> <p>However, resolution for a <a href="#relative-vs-non-relative-module-imports">non-relative module name</a> is performed differently. Node will look for your modules in special folders named <code>node_modules</code>. A <code>node_modules</code> folder can be on the same level as the current file, or higher up in the directory chain. Node will walk up the directory chain, looking through each <code>node_modules</code> until it finds the module you tried to load.</p> <p>Following up our example above, consider if <code>/root/src/moduleA.js</code> instead used a non-relative path and had the import <code>var x = require("moduleB");</code>. Node would then try to resolve <code>moduleB</code> to each of the locations until one worked.</p> <ol> <li><code>/root/src/node_modules/moduleB.js</code></li> <li>
<code>/root/src/node_modules/moduleB/package.json</code> (if it specifies a <code>"main"</code> property)</li> <li>
<code>/root/src/node_modules/moduleB/index.js</code> <br><br>
</li> <li><code>/root/node_modules/moduleB.js</code></li> <li>
<code>/root/node_modules/moduleB/package.json</code> (if it specifies a <code>"main"</code> property)</li> <li>
<code>/root/node_modules/moduleB/index.js</code> <br><br>
</li> <li><code>/node_modules/moduleB.js</code></li> <li>
<code>/node_modules/moduleB/package.json</code> (if it specifies a <code>"main"</code> property)</li> <li><code>/node_modules/moduleB/index.js</code></li> </ol> <p>Notice that Node.js jumped up a directory in steps (4) and (7).</p> <p>You can read more about the process in Node.js documentation on <a href="https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders">loading modules from <code>node_modules</code></a>.</p> <h4 id="how-typescript-resolves-modules" style="position:relative;">How TypeScript resolves modules</h4> <p>TypeScript will mimic the Node.js run-time resolution strategy in order to locate definition files for modules at compile-time. To accomplish this, TypeScript overlays the TypeScript source file extensions (<code>.ts</code>, <code>.tsx</code>, and <code>.d.ts</code>) over Node’s resolution logic. TypeScript will also use a field in <code>package.json</code> named <code>"types"</code> to mirror the purpose of <code>"main"</code> - the compiler will use it to find the “main” definition file to consult.</p> <p>For example, an import statement like <code>import { b } from "./moduleB"</code> in <code>/root/src/moduleA.ts</code> would result in attempting the following locations for locating <code>"./moduleB"</code>:</p> <ol> <li><code>/root/src/moduleB.ts</code></li> <li><code>/root/src/moduleB.tsx</code></li> <li><code>/root/src/moduleB.d.ts</code></li> <li>
<code>/root/src/moduleB/package.json</code> (if it specifies a <code>"types"</code> property)</li> <li><code>/root/src/moduleB/index.ts</code></li> <li><code>/root/src/moduleB/index.tsx</code></li> <li><code>/root/src/moduleB/index.d.ts</code></li> </ol> <p>Recall that Node.js looked for a file named <code>moduleB.js</code>, then an applicable <code>package.json</code>, and then for an <code>index.js</code>.</p> <p>Similarly, a non-relative import will follow the Node.js resolution logic, first looking up a file, then looking up an applicable folder. So <code>import { b } from "moduleB"</code> in source file <code>/root/src/moduleA.ts</code> would result in the following lookups:</p> <ol> <li><code>/root/src/node_modules/moduleB.ts</code></li> <li><code>/root/src/node_modules/moduleB.tsx</code></li> <li><code>/root/src/node_modules/moduleB.d.ts</code></li> <li>
<code>/root/src/node_modules/moduleB/package.json</code> (if it specifies a <code>"types"</code> property)</li> <li><code>/root/src/node_modules/@types/moduleB.d.ts</code></li> <li><code>/root/src/node_modules/moduleB/index.ts</code></li> <li><code>/root/src/node_modules/moduleB/index.tsx</code></li> <li>
<code>/root/src/node_modules/moduleB/index.d.ts</code> <br><br>
</li> <li><code>/root/node_modules/moduleB.ts</code></li> <li><code>/root/node_modules/moduleB.tsx</code></li> <li><code>/root/node_modules/moduleB.d.ts</code></li> <li>
<code>/root/node_modules/moduleB/package.json</code> (if it specifies a <code>"types"</code> property)</li> <li><code>/root/node_modules/@types/moduleB.d.ts</code></li> <li><code>/root/node_modules/moduleB/index.ts</code></li> <li><code>/root/node_modules/moduleB/index.tsx</code></li> <li>
<code>/root/node_modules/moduleB/index.d.ts</code> <br><br>
</li> <li><code>/node_modules/moduleB.ts</code></li> <li><code>/node_modules/moduleB.tsx</code></li> <li><code>/node_modules/moduleB.d.ts</code></li> <li>
<code>/node_modules/moduleB/package.json</code> (if it specifies a <code>"types"</code> property)</li> <li><code>/node_modules/@types/moduleB.d.ts</code></li> <li><code>/node_modules/moduleB/index.ts</code></li> <li><code>/node_modules/moduleB/index.tsx</code></li> <li><code>/node_modules/moduleB/index.d.ts</code></li> </ol> <p>Don’t be intimidated by the number of steps here - TypeScript is still only jumping up directories twice at steps (9) and (17). This is really no more complex than what Node.js itself is doing.</p> <h2 id="additional-module-resolution-flags" style="position:relative;">Additional module resolution flags</h2> <p>A project source layout sometimes does not match that of the output. Usually a set of build steps result in generating the final output. These include compiling <code>.ts</code> files into <code>.js</code>, and copying dependencies from different source locations to a single output location. The net result is that modules at runtime may have different names than the source files containing their definitions. Or module paths in the final output may not match their corresponding source file paths at compile time.</p> <p>The TypeScript compiler has a set of additional flags to <em>inform</em> the compiler of transformations that are expected to happen to the sources to generate the final output.</p> <p>It is important to note that the compiler will <em>not</em> perform any of these transformations; it just uses these pieces of information to guide the process of resolving a module import to its definition file.</p> <h3 id="base-url" style="position:relative;">Base URL</h3> <p>Using a <code>baseUrl</code> is a common practice in applications using AMD module loaders where modules are “deployed” to a single folder at run-time. The sources of these modules can live in different directories, but a build script will put them all together.</p> <p>Setting <code>baseUrl</code> informs the compiler where to find modules. All module imports with non-relative names are assumed to be relative to the <code>baseUrl</code>.</p> <p>Value of <em>baseUrl</em> is determined as either:</p> <ul> <li>value of <em>baseUrl</em> command line argument (if given path is relative, it is computed based on current directory)</li> <li>value of <em>baseUrl</em> property in ‘tsconfig.json’ (if given path is relative, it is computed based on the location of ‘tsconfig.json’)</li> </ul> <p>Note that relative module imports are not impacted by setting the baseUrl, as they are always resolved relative to their importing files.</p> <p>You can find more documentation on baseUrl in <a href="http://requirejs.org/docs/api.html#config-baseUrl">RequireJS</a> and <a href="https://github.com/systemjs/systemjs/blob/main/docs/api.md">SystemJS</a> documentation.</p> <h3 id="path-mapping" style="position:relative;">Path mapping</h3> <p>Sometimes modules are not directly located under <em>baseUrl</em>. For instance, an import to a module <code>"jquery"</code> would be translated at runtime to <code>"node_modules/jquery/dist/jquery.slim.min.js"</code>. Loaders use a mapping configuration to map module names to files at run-time, see <a href="http://requirejs.org/docs/api.html#config-paths">RequireJs documentation</a> and <a href="https://github.com/systemjs/systemjs/blob/main/docs/import-maps.md">SystemJS documentation</a>.</p> <p>The TypeScript compiler supports the declaration of such mappings using <code>"paths"</code> property in <code>tsconfig.json</code> files. Here is an example for how to specify the <code>"paths"</code> property for <code>jquery</code>.</p> <pre tsconfig="true" data-language="typescript">{
  "compilerOptions": {
    "baseUrl": ".", // This must be specified if "paths" is.
    "paths": {
      "jquery": ["node_modules/jquery/dist/jquery"] // This mapping is relative to "baseUrl"
    }
  }
}</pre> <p>Please notice that <code>"paths"</code> are resolved relative to <code>"baseUrl"</code>. When setting <code>"baseUrl"</code> to another value than <code>"."</code>, i.e. the directory of <code>tsconfig.json</code>, the mappings must be changed accordingly. Say, you set <code>"baseUrl": "./src"</code> in the above example, then jquery should be mapped to <code>"../node_modules/jquery/dist/jquery"</code>.</p> <p>Using <code>"paths"</code> also allows for more sophisticated mappings including multiple fall back locations. Consider a project configuration where only some modules are available in one location, and the rest are in another. A build step would put them all together in one place. The project layout may look like:</p> <pre data-language="typescript">projectRoot
├── folder1
│   ├── file1.ts (imports 'folder1/file2' and 'folder2/file3')
│   └── file2.ts
├── generated
│   ├── folder1
│   └── folder2
│       └── file3.ts
└── tsconfig.json</pre>Yes<button title="Dislike this page" id="dislike-button"> No</button><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.typescriptlang.org/docs/handbook/module-resolution.html" class="_attribution-link" target="_blank">https://www.typescriptlang.org/docs/handbook/module-resolution.html</a>
  </p>
</div>
