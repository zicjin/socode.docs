<h1>Advanced Types</h1>
<div id="deprecated-content" class="deprecated"><div><p>This handbook page has been replaced, <a class="deprecation-redirect-link" href="2/types-from-types">go to the new page</a></p></div></div>
<p>This page lists some of the more advanced ways in which you can model types, it works in tandem with the <a href="utility-types">Utility Types</a> doc which includes types which are included in TypeScript and available globally.</p> <h2 id="type-guards-and-differentiating-types" style="position:relative;">Type Guards and Differentiating Types</h2> <p>Union types are useful for modeling situations when values can overlap in the types they can take on. What happens when we need to know specifically whether we have a <code>Fish</code>? A common idiom in JavaScript to differentiate between two possible values is to check for the presence of a member. As we mentioned, you can only access members that are guaranteed to be in all the constituents of a union type.</p> <pre data-language="ts">let pet = getSmallPet();
 
// You can use the 'in' operator to check
if ("swim" in pet) {
  pet.swim();
}
// However, you cannot use property access
if (pet.fly) {
  pet.fly();
}</pre> <p>To get the same code working via property accessors, we’ll need to use a type assertion:</p> <pre data-language="ts">let pet = getSmallPet();
let fishPet = pet as Fish;
let birdPet = pet as Bird;
 
if (fishPet.swim) {
  fishPet.swim();
} else if (birdPet.fly) {
  birdPet.fly();
}</pre> <p>This isn’t the sort of code you would want in your codebase however.</p> <h2 id="user-defined-type-guards" style="position:relative;">User-Defined Type Guards</h2> <p>It would be much better if once we performed the check, we could know the type of <code>pet</code> within each branch.</p> <p>It just so happens that TypeScript has something called a <em>type guard</em>. A type guard is some expression that performs a runtime check that guarantees the type in some scope.</p> <h3 id="using-type-predicates" style="position:relative;">Using type predicates</h3> <p>To define a type guard, we simply need to define a function whose return type is a <em>type predicate</em>:</p> <pre data-language="ts">function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined;
}</pre> <p><code>pet is Fish</code> is our type predicate in this example. A predicate takes the form <code>parameterName is Type</code>, where <code>parameterName</code> must be the name of a parameter from the current function signature.</p> <p>Any time <code>isFish</code> is called with some variable, TypeScript will <em>narrow</em> that variable to that specific type if the original type is compatible.</p> <pre data-language="ts">// Both calls to 'swim' and 'fly' are now okay.
let pet = getSmallPet();
 
if (isFish(pet)) {
  pet.swim();
} else {
  pet.fly();
}</pre> <p>Notice that TypeScript not only knows that <code>pet</code> is a <code>Fish</code> in the <code>if</code> branch; it also knows that in the <code>else</code> branch, you <em>don’t</em> have a <code>Fish</code>, so you must have a <code>Bird</code>.</p> <p>You may use the type guard <code>isFish</code> to filter an array of <code>Fish | Bird</code> and obtain an array of <code>Fish</code>:</p> <pre data-language="ts">const zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];
const underWater1: Fish[] = zoo.filter(isFish);
// or, equivalently
const underWater2: Fish[] = zoo.filter&lt;Fish&gt;(isFish);
const underWater3: Fish[] = zoo.filter&lt;Fish&gt;((pet) =&gt; isFish(pet));</pre> <h3 id="using-the-in-operator" style="position:relative;">Using the <code>in</code> operator</h3> <p>The <code>in</code> operator also acts as a narrowing expression for types.</p> <p>For a <code>n in x</code> expression, where <code>n</code> is a string literal or string literal type and <code>x</code> is a union type, the “true” branch narrows to types which have an optional or required property <code>n</code>, and the “false” branch narrows to types which have an optional or missing property <code>n</code>.</p> <pre data-language="ts">function move(pet: Fish | Bird) {
  if ("swim" in pet) {
    return pet.swim();
  }
  return pet.fly();
}</pre> <h2 id="typeof-type-guards" style="position:relative;">
<code>typeof</code> type guards</h2> <p>Let’s go back and write the code for a version of <code>padLeft</code> which uses union types. We could write it with type predicates as follows:</p> <pre data-language="ts">function isNumber(x: any): x is number {
  return typeof x === "number";
}
 
function isString(x: any): x is string {
  return typeof x === "string";
}
 
function padLeft(value: string, padding: string | number) {
  if (isNumber(padding)) {
    return Array(padding + 1).join(" ") + value;
  }
  if (isString(padding)) {
    return padding + value;
  }
  throw new Error(`Expected string or number, got '${padding}'.`);
}</pre> <p>However, having to define a function to figure out if a type is a primitive is kind of a pain. Luckily, you don’t need to abstract <code>typeof x === "number"</code> into its own function because TypeScript will recognize it as a type guard on its own. That means we could just write these checks inline.</p> <pre data-language="ts">function padLeft(value: string, padding: string | number) {
  if (typeof padding === "number") {
    return Array(padding + 1).join(" ") + value;
  }
  if (typeof padding === "string") {
    return padding + value;
  }
  throw new Error(`Expected string or number, got '${padding}'.`);
}</pre> <p>These <em><code>typeof</code> type guards</em> are recognized in two different forms: <code>typeof v === "typename"</code> and <code>typeof v !== "typename"</code>, where <code>"typename"</code> can be one of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#Description"><code>typeof</code> operator’s return values</a> (<code>"undefined"</code>, <code>"number"</code>, <code>"string"</code>, <code>"boolean"</code>, <code>"bigint"</code>, <code>"symbol"</code>, <code>"object"</code>, or <code>"function"</code>). While TypeScript won’t stop you from comparing to other strings, the language won’t recognize those expressions as type guards.</p> <h2 id="instanceof-type-guards" style="position:relative;">
<code>instanceof</code> type guards</h2> <p>If you’ve read about <code>typeof</code> type guards and are familiar with the <code>instanceof</code> operator in JavaScript, you probably have some idea of what this section is about.</p> <p><em><code>instanceof</code> type guards</em> are a way of narrowing types using their constructor function. For instance, let’s borrow our industrial strength string-padder example from earlier:</p> <pre data-language="ts">interface Padder {
  getPaddingString(): string;
}
 
class SpaceRepeatingPadder implements Padder {
  constructor(private numSpaces: number) {}
  getPaddingString() {
    return Array(this.numSpaces + 1).join(" ");
  }
}
 
class StringPadder implements Padder {
  constructor(private value: string) {}
  getPaddingString() {
    return this.value;
  }
}
 
function getRandomPadder() {
  return Math.random() &lt; 0.5
    ? new SpaceRepeatingPadder(4)
    : new StringPadder("  ");
}
 
let padder: Padder = getRandomPadder();
 
if (padder instanceof SpaceRepeatingPadder) {
  padder;
}
if (padder instanceof StringPadder) {
  padder;
}</pre> <p>The right side of the <code>instanceof</code> needs to be a constructor function, and TypeScript will narrow down to:</p> <ol> <li>the type of the function’s <code>prototype</code> property if its type is not <code>any</code>
</li> <li>the union of types returned by that type’s construct signatures</li> </ol> <p>in that order.</p> <h2 id="nullable-types" style="position:relative;">Nullable types</h2> <p>TypeScript has two special types, <code>null</code> and <code>undefined</code>, that have the values null and undefined respectively. We mentioned these briefly in <a href="basic-types">the Basic Types section</a>.</p> <p>By default, the type checker considers <code>null</code> and <code>undefined</code> assignable to anything. Effectively, <code>null</code> and <code>undefined</code> are valid values of every type. That means it’s not possible to <em>stop</em> them from being assigned to any type, even when you would like to prevent it. The inventor of <code>null</code>, Tony Hoare, calls this his <a href="https://wikipedia.org/wiki/Null_pointer#History">“billion dollar mistake”</a>.</p> <p>The <a href="https://www.typescriptlang.org/tsconfig#strictNullChecks"><code>--strictNullChecks</code></a> flag fixes this: when you declare a variable, it doesn’t automatically include <code>null</code> or <code>undefined</code>. You can include them explicitly using a union type:</p> <pre data-language="ts">let exampleString = "foo";
exampleString = null;
 
let stringOrNull: string | null = "bar";
stringOrNull = null;
 
stringOrNull = undefined;</pre> <p>Note that TypeScript treats <code>null</code> and <code>undefined</code> differently in order to match JavaScript semantics. <code>string | null</code> is a different type than <code>string | undefined</code> and <code>string | undefined | null</code>.</p> <p>From TypeScript 3.7 and onwards, you can use <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining">optional chaining</a> to simplify working with nullable types.</p> <h3 id="optional-parameters-and-properties" style="position:relative;">Optional parameters and properties</h3> <p>With <a href="https://www.typescriptlang.org/tsconfig#strictNullChecks"><code>--strictNullChecks</code></a>, an optional parameter automatically adds <code>| undefined</code>:</p> <pre data-language="ts">function f(x: number, y?: number) {
  return x + (y ?? 0);
}
 
f(1, 2);
f(1);
f(1, undefined);
f(1, null);</pre> <p>The same is true for optional properties:</p> <pre data-language="ts">class C {
  a: number;
  b?: number;
}
 
let c = new C();
 
c.a = 12;
c.a = undefined;
c.b = 13;
c.b = undefined;
c.b = null;</pre> <h3 id="type-guards-and-type-assertions" style="position:relative;">Type guards and type assertions</h3> <p>Since nullable types are implemented with a union, you need to use a type guard to get rid of the <code>null</code>. Fortunately, this is the same code you’d write in JavaScript:</p> <pre data-language="ts">function f(stringOrNull: string | null): string {
  if (stringOrNull === null) {
    return "default";
  } else {
    return stringOrNull;
  }
}</pre> <p>The <code>null</code> elimination is pretty obvious here, but you can use terser operators too:</p> <pre data-language="ts">function f(stringOrNull: string | null): string {
  return stringOrNull ?? "default";
}</pre> <p>In cases where the compiler can’t eliminate <code>null</code> or <code>undefined</code>, you can use the type assertion operator to manually remove them. The syntax is postfix <code>!</code>: <code>identifier!</code> removes <code>null</code> and <code>undefined</code> from the type of <code>identifier</code>:</p> <pre data-language="ts">interface UserAccount {
  id: number;
  email?: string;
}
 
const user = getUser("admin");
user.id;
 
if (user) {
  user.email.length;
}
 
// Instead if you are sure that these objects or fields exist, the
// postfix ! lets you short circuit the nullability
user!.email!.length;</pre> <h2 id="type-aliases" style="position:relative;">Type Aliases</h2> <p>Type aliases create a new name for a type. Type aliases are sometimes similar to interfaces, but can name primitives, unions, tuples, and any other types that you’d otherwise have to write by hand.</p> <pre data-language="ts">type Second = number;
 
let timeInSecond: number = 10;
let time: Second = 10;</pre> <p>Aliasing doesn’t actually create a new type - it creates a new <em>name</em> to refer to that type. Aliasing a primitive is not terribly useful, though it can be used as a form of documentation.</p> <p>Just like interfaces, type aliases can also be generic - we can just add type parameters and use them on the right side of the alias declaration:</p> <pre data-language="ts">type Container&lt;T&gt; = { value: T };</pre> <p>We can also have a type alias refer to itself in a property:</p> <pre data-language="ts">type Tree&lt;T&gt; = {
  value: T;
  left?: Tree&lt;T&gt;;
  right?: Tree&lt;T&gt;;
};</pre> <p>Together with <a href="unions-and-intersections">intersection</a> types, we can make some pretty mind-bending types:</p> <pre data-language="ts">type LinkedList&lt;Type&gt; = Type &amp; { next: LinkedList&lt;Type&gt; };
 
interface Person {
  name: string;
}
 
let people = getDriversLicenseQueue();
people.name;
people.next.name;
people.next.next.name;
people.next.next.next.name;</pre> <h2 id="interfaces-vs-type-aliases" style="position:relative;">Interfaces vs. Type Aliases</h2> <p>As we mentioned, type aliases can act sort of like interfaces; however, there are some subtle differences.</p> <p>Almost all features of an <code>interface</code> are available in <code>type</code>, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.</p> <table class="full-width-table"> <tbody> <tr> <th><code>Interface</code></th> <th><code>Type</code></th> </tr> <tr> <td> <p>Extending an interface</p> <code><pre data-language="typescript">
interface Animal {
  name: string
}
interface Bear extends Animal {
  honey: boolean
}
const bear = getBear() 
bear.name
bear.honey
        </pre></code> </td> <td> <p>Extending a type via intersections</p> <code><pre data-language="typescript">
type Animal = {
  name: string
}
type Bear = Animal &amp; { 
  honey: Boolean 
}
const bear = getBear();
bear.name;
bear.honey;
        </pre></code> </td> </tr> <tr> <td> <p>Adding new fields to an existing interface</p> <code><pre data-language="typescript">
interface Window {
  title: string
}
interface Window {
  ts: import("typescript")
}
const src = 'const a = "Hello World"';
window.ts.transpileModule(src, {});
        </pre></code> </td> <td> <p>A type cannot be changed after being created</p> <code><pre data-language="typescript">
type Window = {
  title: string
}
type Window = {
  ts: import("typescript")
}
// Error: Duplicate identifier 'Window'.
        </pre></code> </td> </tr> </tbody> </table> <p>Because an interface more closely maps how JavaScript objects work <a href="https://wikipedia.org/wiki/Open/closed_principle">by being open to extension</a>, we recommend using an interface over a type alias when possible.</p> <p>On the other hand, if you can’t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.</p> <h2 id="enum-member-types" style="position:relative;">Enum Member Types</h2> <p>As mentioned in <a href="enums#union-enums-and-enum-member-types">our section on enums</a>, enum members have types when every member is literal-initialized.</p> <p>Much of the time when we talk about “singleton types”, we’re referring to both enum member types as well as numeric/string literal types, though many users will use “singleton types” and “literal types” interchangeably.</p> <h2 id="polymorphic-this-types" style="position:relative;">Polymorphic <code>this</code> types</h2> <p>A polymorphic <code>this</code> type represents a type that is the <em>subtype</em> of the containing class or interface. This is called <em>F</em>-bounded polymorphism, a lot of people know it as the <a href="https://en.wikipedia.org/wiki/Fluent_interface">fluent API</a> pattern. This makes hierarchical fluent interfaces much easier to express, for example. Take a simple calculator that returns <code>this</code> after each operation:</p> <pre data-language="ts">class BasicCalculator {
  public constructor(protected value: number = 0) {}
  public currentValue(): number {
    return this.value;
  }
  public add(operand: number): this {
    this.value += operand;
    return this;
  }
  public multiply(operand: number): this {
    this.value *= operand;
    return this;
  }
  // ... other operations go here ...
}
 
let v = new BasicCalculator(2).multiply(5).add(1).currentValue();</pre> <p>Since the class uses <code>this</code> types, you can extend it and the new class can use the old methods with no changes.</p> <pre data-language="ts">class ScientificCalculator extends BasicCalculator {
  public constructor(value = 0) {
    super(value);
  }
  public sin() {
    this.value = Math.sin(this.value);
    return this;
  }
  // ... other operations go here ...
}
 
let v = new ScientificCalculator(2).multiply(5).sin().add(1).currentValue();</pre> <p>Without <code>this</code> types, <code>ScientificCalculator</code> would not have been able to extend <code>BasicCalculator</code> and keep the fluent interface. <code>multiply</code> would have returned <code>BasicCalculator</code>, which doesn’t have the <code>sin</code> method. However, with <code>this</code> types, <code>multiply</code> returns <code>this</code>, which is <code>ScientificCalculator</code> here.</p> <h2 id="index-types" style="position:relative;">Index types</h2> <p>With index types, you can get the compiler to check code that uses dynamic property names. For example, a common JavaScript pattern is to pick a subset of properties from an object:</p> <pre data-language="js">function pluck(o, propertyNames) {
  return propertyNames.map((n) =&gt; o[n]);
}</pre> <p>Here’s how you would write and use this function in TypeScript, using the <strong>index type query</strong> and <strong>indexed access</strong> operators:</p> <pre data-language="ts">function pluck&lt;T, K extends keyof T&gt;(o: T, propertyNames: K[]): T[K][] {
  return propertyNames.map((n) =&gt; o[n]);
}
 
interface Car {
  manufacturer: string;
  model: string;
  year: number;
}
 
let taxi: Car = {
  manufacturer: "Toyota",
  model: "Camry",
  year: 2014,
};
 
// Manufacturer and model are both of type string,
// so we can pluck them both into a typed string array
let makeAndModel: string[] = pluck(taxi, ["manufacturer", "model"]);
 
// If we try to pluck model and year, we get an
// array of a union type: (string | number)[]
let modelYear = pluck(taxi, ["model", "year"]);</pre> <p>The compiler checks that <code>manufacturer</code> and <code>model</code> are actually properties on <code>Car</code>. The example introduces a couple of new type operators. First is <code>keyof T</code>, the <strong>index type query operator</strong>. For any type <code>T</code>, <code>keyof T</code> is the union of known, public property names of <code>T</code>. For example:</p> <pre data-language="ts">let carProps: keyof Car;</pre> <p><code>keyof Car</code> is completely interchangeable with <code>"manufacturer" | "model" | "year"</code>. The difference is that if you add another property to <code>Car</code>, say <code>ownersAddress: string</code>, then <code>keyof Car</code> will automatically update to be <code>"manufacturer" | "model" | "year" | "ownersAddress"</code>. And you can use <code>keyof</code> in generic contexts like <code>pluck</code>, where you can’t possibly know the property names ahead of time. That means the compiler will check that you pass the right set of property names to <code>pluck</code>:</p> <pre data-language="ts">// error, Type '"unknown"' is not assignable to type '"manufacturer" | "model" | "year"'
pluck(taxi, ["year", "unknown"]);</pre> <p>The second operator is <code>T[K]</code>, the <strong>indexed access operator</strong>. Here, the type syntax reflects the expression syntax. That means that <code>taxi["manufacturer"]</code> has the type <code>Car["manufacturer"]</code> — which in our example is just <code>string</code>. However, just like index type queries, you can use <code>T[K]</code> in a generic context, which is where its real power comes to life. You just have to make sure that the type variable <code>K extends keyof T</code>. Here’s another example with a function named <code>getProperty</code>.</p> <pre data-language="ts">function getProperty&lt;T, K extends keyof T&gt;(o: T, propertyName: K): T[K] {
  return o[propertyName]; // o[propertyName] is of type T[K]
}</pre> <p>In <code>getProperty</code>, <code>o: T</code> and <code>propertyName: K</code>, so that means <code>o[propertyName]: T[K]</code>. Once you return the <code>T[K]</code> result, the compiler will instantiate the actual type of the key, so the return type of <code>getProperty</code> will vary according to which property you request.</p> <pre data-language="ts">let manufacturer: string = getProperty(taxi, "manufacturer");
let year: number = getProperty(taxi, "year");
 
let unknown = getProperty(taxi, "unknown");</pre> <h2 id="index-types-and-index-signatures" style="position:relative;">Index types and index signatures</h2> <p><code>keyof</code> and <code>T[K]</code> interact with index signatures. An index signature parameter type must be ‘string’ or ‘number’. If you have a type with a string index signature, <code>keyof T</code> will be <code>string | number</code> (and not just <code>string</code>, since in JavaScript you can access an object property either by using strings (<code>object["42"]</code>) or numbers (<code>object[42]</code>)). And <code>T[string]</code> is just the type of the index signature:</p> <pre data-language="ts">interface Dictionary&lt;T&gt; {
  [key: string]: T;
}
let keys: keyof Dictionary&lt;number&gt;;
let value: Dictionary&lt;number&gt;["foo"];</pre> <p>If you have a type with a number index signature, <code>keyof T</code> will just be <code>number</code>.</p> <pre data-language="ts">interface Dictionary&lt;T&gt; {
  [key: number]: T;
}
 
let keys: keyof Dictionary&lt;number&gt;;
let numberValue: Dictionary&lt;number&gt;[42];
let value: Dictionary&lt;number&gt;["foo"];</pre> <h2 id="mapped-types" style="position:relative;">Mapped types</h2> <p>A common task is to take an existing type and make each of its properties optional:</p> <pre data-language="ts">interface PersonSubset {
  name?: string;
  age?: number;
}</pre> <p>Or we might want a readonly version:</p> <pre data-language="ts">interface PersonReadonly {
  readonly name: string;
  readonly age: number;
}</pre> <p>This happens often enough in JavaScript that TypeScript provides a way to create new types based on old types — <strong>mapped types</strong>. In a mapped type, the new type transforms each property in the old type in the same way. For example, you can make all properties optional or of a type <code>readonly</code>. Here are a couple of examples:</p> <pre data-language="ts">type Partial&lt;T&gt; = {
  [P in keyof T]?: T[P];
};
 
type Readonly&lt;T&gt; = {
  readonly [P in keyof T]: T[P];
};</pre> <p>And to use it:</p> <pre data-language="ts">type PersonPartial = Partial&lt;Person&gt;;
type ReadonlyPerson = Readonly&lt;Person&gt;;</pre> <p>Note that this syntax describes a type rather than a member. If you want to add members, you can use an intersection type:</p> <pre data-language="ts">// Use this:
type PartialWithNewMember&lt;T&gt; = {
  [P in keyof T]?: T[P];
} &amp; { newMember: boolean }
 
// This is an error!
type WrongPartialWithNewMember&lt;T&gt; = {
  [P in keyof T]?: T[P];
  newMember: boolean;
}</pre> <p>Let’s take a look at the simplest mapped type and its parts:</p> <pre data-language="ts">type Keys = "option1" | "option2";
type Flags = { [K in Keys]: boolean };</pre> <p>The syntax resembles the syntax for index signatures with a <code>for .. in</code> inside. There are three parts:</p> <ol> <li>The type variable <code>K</code>, which gets bound to each property in turn.</li> <li>The string literal union <code>Keys</code>, which contains the names of properties to iterate over.</li> <li>The resulting type of the property.</li> </ol> <p>In this simple example, <code>Keys</code> is a hard-coded list of property names and the property type is always <code>boolean</code>, so this mapped type is equivalent to writing:</p> <pre data-language="ts">type Flags = {
  option1: boolean;
  option2: boolean;
};</pre> <p>Real applications, however, look like <code>Readonly</code> or <code>Partial</code> above. They’re based on some existing type, and they transform the properties in some way. That’s where <code>keyof</code> and indexed access types come in:</p> <pre data-language="ts">type NullablePerson = { [P in keyof Person]: Person[P] | null };
type PartialPerson = { [P in keyof Person]?: Person[P] };</pre> <p>But it’s more useful to have a general version.</p> <pre data-language="ts">type Nullable&lt;T&gt; = { [P in keyof T]: T[P] | null };
type Partial&lt;T&gt; = { [P in keyof T]?: T[P] };</pre> <p>In these examples, the properties list is <code>keyof T</code> and the resulting type is some variant of <code>T[P]</code>. This is a good template for any general use of mapped types. That’s because this kind of transformation is <a href="https://wikipedia.org/wiki/Homomorphism">homomorphic</a>, which means that the mapping applies only to properties of <code>T</code> and no others. The compiler knows that it can copy all the existing property modifiers before adding any new ones. For example, if <code>Person.name</code> was readonly, <code>Partial&lt;Person&gt;.name</code> would be readonly and optional.</p> <p>Here’s one more example, in which <code>T[P]</code> is wrapped in a <code>Proxy&lt;T&gt;</code> class:</p> <pre data-language="ts">type Proxy&lt;T&gt; = {
  get(): T;
  set(value: T): void;
};
 
type Proxify&lt;T&gt; = {
  [P in keyof T]: Proxy&lt;T[P]&gt;;
};
 
function proxify&lt;T&gt;(o: T): Proxify&lt;T&gt; {
  // ... wrap proxies ...
}
 
let props = { rooms: 4 };
let proxyProps = proxify(props);</pre> <p>Note that <code>Readonly&lt;T&gt;</code> and <code>Partial&lt;T&gt;</code> are so useful, they are included in TypeScript’s standard library along with <code>Pick</code> and <code>Record</code>:</p> <pre data-language="ts">type Pick&lt;T, K extends keyof T&gt; = {
  [P in K]: T[P];
};

type Record&lt;K extends keyof any, T&gt; = {
  [P in K]: T;
};</pre> <p><code>Readonly</code>, <code>Partial</code> and <code>Pick</code> are homomorphic whereas <code>Record</code> is not. One clue that <code>Record</code> is not homomorphic is that it doesn’t take an input type to copy properties from:</p> <pre data-language="ts">type ThreeStringProps = Record&lt;"prop1" | "prop2" | "prop3", string&gt;;</pre> <p>Non-homomorphic types are essentially creating new properties, so they can’t copy property modifiers from anywhere.</p> <p>Note that <code>keyof any</code> represents the type of any value that can be used as an index to an object. In otherwords, <code>keyof any</code> is currently equal to <code>string | number | symbol</code>.</p> <h2 id="inference-from-mapped-types" style="position:relative;">Inference from mapped types</h2> <p>Now that you know how to wrap the properties of a type, the next thing you’ll want to do is unwrap them. Fortunately, that’s pretty easy:</p> <pre data-language="ts">function unproxify&lt;T&gt;(t: Proxify&lt;T&gt;): T {
  let result = {} as T;
  for (const k in t) {
    result[k] = t[k].get();
  }
  return result;
}
 
let originalProps = unproxify(proxyProps);</pre> <p>Note that this unwrapping inference only works on homomorphic mapped types. If the mapped type is not homomorphic you’ll have to give an explicit type parameter to your unwrapping function.</p> <h2 id="conditional-types" style="position:relative;">Conditional Types</h2> <p>A conditional type selects one of two possible types based on a condition expressed as a type relationship test:</p> <pre data-language="ts">T extends U ? X : Y</pre> <p>The type above means when <code>T</code> is assignable to <code>U</code> the type is <code>X</code>, otherwise the type is <code>Y</code>.</p> <p>A conditional type <code>T extends U ? X : Y</code> is either <em>resolved</em> to <code>X</code> or <code>Y</code>, or <em>deferred</em> because the condition depends on one or more type variables. When <code>T</code> or <code>U</code> contains type variables, whether to resolve to <code>X</code> or <code>Y</code>, or to defer, is determined by whether or not the type system has enough information to conclude that <code>T</code> is always assignable to <code>U</code>.</p> <p>As an example of some types that are immediately resolved, we can take a look at the following example:</p> <pre data-language="ts">declare function f&lt;T extends boolean&gt;(x: T): T extends true ? string : number;
 
// Type is 'string | number'
let x = f(Math.random() &lt; 0.5);</pre> <p>Another example would be the <code>TypeName</code> type alias, which uses nested conditional types:</p> <pre data-language="ts">type TypeName&lt;T&gt; = T extends string
  ? "string"
  : T extends number
  ? "number"
  : T extends boolean
  ? "boolean"
  : T extends undefined
  ? "undefined"
  : T extends Function
  ? "function"
  : "object";
 
type T0 = TypeName&lt;string&gt;;
type T1 = TypeName&lt;"a"&gt;;
type T2 = TypeName&lt;true&gt;;
type T3 = TypeName&lt;() =&gt; void&gt;;
type T4 = TypeName&lt;string[]&gt;;</pre> <p>But as an example of a place where conditional types are deferred - where they stick around instead of picking a branch - would be in the following:</p> <pre data-language="ts">interface Foo {
  propA: boolean;
  propB: boolean;
}
 
declare function f&lt;T&gt;(x: T): T extends Foo ? string : number;
 
function foo&lt;U&gt;(x: U) {
  // Has type 'U extends Foo ? string : number'
  let a = f(x);
 
  // This assignment is allowed though!
  let b: string | number = a;
}</pre> <p>In the above, the variable <code>a</code> has a conditional type that hasn’t yet chosen a branch. When another piece of code ends up calling <code>foo</code>, it will substitute in <code>U</code> with some other type, and TypeScript will re-evaluate the conditional type, deciding whether it can actually pick a branch.</p> <p>In the meantime, we can assign a conditional type to any other target type as long as each branch of the conditional is assignable to that target. So in our example above we were able to assign <code>U extends Foo ? string : number</code> to <code>string | number</code> since no matter what the conditional evaluates to, it’s known to be either <code>string</code> or <code>number</code>.</p> <h2 id="distributive-conditional-types" style="position:relative;">Distributive conditional types</h2> <p>Conditional types in which the checked type is a naked type parameter are called <em>distributive conditional types</em>. Distributive conditional types are automatically distributed over union types during instantiation. For example, an instantiation of <code>T extends U ? X : Y</code> with the type argument <code>A | B | C</code> for <code>T</code> is resolved as <code>(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)</code>.</p> <h4 id="example" style="position:relative;">Example</h4> <pre data-language="ts">type T5 = TypeName&lt;string | (() =&gt; void)&gt;;
type T6 = TypeName&lt;string | string[] | undefined&gt;;
type T7 = TypeName&lt;string[] | number[]&gt;;</pre> <p>In instantiations of a distributive conditional type <code>T extends U ? X : Y</code>, references to <code>T</code> within the conditional type are resolved to individual constituents of the union type (i.e. <code>T</code> refers to the individual constituents <em>after</em> the conditional type is distributed over the union type). Furthermore, references to <code>T</code> within <code>X</code> have an additional type parameter constraint <code>U</code> (i.e. <code>T</code> is considered assignable to <code>U</code> within <code>X</code>).</p> <h4 id="example-1" style="position:relative;">Example</h4> <pre data-language="ts">type BoxedValue&lt;T&gt; = { value: T };
type BoxedArray&lt;T&gt; = { array: T[] };
type Boxed&lt;T&gt; = T extends any[] ? BoxedArray&lt;T[number]&gt; : BoxedValue&lt;T&gt;;
 
type T1 = Boxed&lt;string&gt;;
type T2 = Boxed&lt;number[]&gt;;
type T3 = Boxed&lt;string | number[]&gt;;</pre> <p>Notice that <code>T</code> has the additional constraint <code>any[]</code> within the true branch of <code>Boxed&lt;T&gt;</code> and it is therefore possible to refer to the element type of the array as <code>T[number]</code>. Also, notice how the conditional type is distributed over the union type in the last example.</p> <p>The distributive property of conditional types can conveniently be used to <em>filter</em> union types:</p> <pre data-language="ts">// Remove types from T that are assignable to U
type Diff&lt;T, U&gt; = T extends U ? never : T;
// Remove types from T that are not assignable to U
type Filter&lt;T, U&gt; = T extends U ? T : never;
 
type T1 = Diff&lt;"a" | "b" | "c" | "d", "a" | "c" | "f"&gt;;
type T2 = Filter&lt;"a" | "b" | "c" | "d", "a" | "c" | "f"&gt;; // "a" | "c"
type T3 = Diff&lt;string | number | (() =&gt; void), Function&gt;; // string | number
type T4 = Filter&lt;string | number | (() =&gt; void), Function&gt;; // () =&gt; void
 
// Remove null and undefined from T
type NotNullable&lt;T&gt; = Diff&lt;T, null | undefined&gt;;
 
type T5 = NotNullable&lt;string | number | undefined&gt;;
type T6 = NotNullable&lt;string | string[] | null | undefined&gt;;
 
function f1&lt;T&gt;(x: T, y: NotNullable&lt;T&gt;) {
  x = y;
  y = x;
}
 
function f2&lt;T extends string | undefined&gt;(x: T, y: NotNullable&lt;T&gt;) {
  x = y;
  y = x;
  let s1: string = x;
  let s2: string = y;
}</pre> <p>Conditional types are particularly useful when combined with mapped types:</p> <pre data-language="ts">type FunctionPropertyNames&lt;T&gt; = {
  [K in keyof T]: T[K] extends Function ? K : never;
}[keyof T];
type FunctionProperties&lt;T&gt; = Pick&lt;T, FunctionPropertyNames&lt;T&gt;&gt;;
 
type NonFunctionPropertyNames&lt;T&gt; = {
  [K in keyof T]: T[K] extends Function ? never : K;
}[keyof T];
type NonFunctionProperties&lt;T&gt; = Pick&lt;T, NonFunctionPropertyNames&lt;T&gt;&gt;;
 
interface Part {
  id: number;
  name: string;
  subparts: Part[];
  updatePart(newName: string): void;
}
 
type T1 = FunctionPropertyNames&lt;Part&gt;;
type T2 = NonFunctionPropertyNames&lt;Part&gt;;
type T3 = FunctionProperties&lt;Part&gt;;
type T4 = NonFunctionProperties&lt;Part&gt;;</pre> <p>Note, conditional types are not permitted to reference themselves recursively. For example the following is an error.</p> <h4 id="example-2" style="position:relative;">Example</h4> <pre data-language="ts">type ElementType&lt;T&gt; = T extends any[] ? ElementType&lt;T[number]&gt; : T; // Error</pre> <h2 id="type-inference-in-conditional-types" style="position:relative;">Type inference in conditional types</h2> <p>Within the <code>extends</code> clause of a conditional type, it is now possible to have <code>infer</code> declarations that introduce a type variable to be inferred. Such inferred type variables may be referenced in the true branch of the conditional type. It is possible to have multiple <code>infer</code> locations for the same type variable.</p> <p>For example, the following extracts the return type of a function type:</p> <pre data-language="ts">type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;</pre> <p>Conditional types can be nested to form a sequence of pattern matches that are evaluated in order:</p> <pre data-language="ts">type Unpacked&lt;T&gt; = T extends (infer U)[]
  ? U
  : T extends (...args: any[]) =&gt; infer U
  ? U
  : T extends Promise&lt;infer U&gt;
  ? U
  : T;
 
type T0 = Unpacked&lt;string&gt;;
type T1 = Unpacked&lt;string[]&gt;;
type T2 = Unpacked&lt;() =&gt; string&gt;;
type T3 = Unpacked&lt;Promise&lt;string&gt;&gt;;
type T4 = Unpacked&lt;Promise&lt;string&gt;[]&gt;;
type T5 = Unpacked&lt;Unpacked&lt;Promise&lt;string&gt;[]&gt;&gt;;</pre> <p>The following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:</p> <pre data-language="ts">type Foo&lt;T&gt; = T extends { a: infer U; b: infer U } ? U : never;
 
type T1 = Foo&lt;{ a: string; b: string }&gt;;
type T2 = Foo&lt;{ a: string; b: number }&gt;;</pre> <p>Likewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:</p> <pre data-language="ts">type Bar&lt;T&gt; = T extends { a: (x: infer U) =&gt; void; b: (x: infer U) =&gt; void }
  ? U
  : never;
 
type T1 = Bar&lt;{ a: (x: string) =&gt; void; b: (x: string) =&gt; void }&gt;;
type T2 = Bar&lt;{ a: (x: string) =&gt; void; b: (x: number) =&gt; void }&gt;;</pre> <p>When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the <em>last</em> signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.</p> <pre data-language="ts">declare function foo(x: string): number;
declare function foo(x: number): string;
declare function foo(x: string | number): string | number;
 
type T1 = ReturnType&lt;typeof foo&gt;;</pre> <p>It is not possible to use <code>infer</code> declarations in constraint clauses for regular type parameters:</p> <pre data-language="ts">type ReturnedType&lt;T extends (...args: any[]) =&gt; infer R&gt; = R;</pre> <p>However, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:</p> <pre data-language="ts">type AnyFunction = (...args: any[]) =&gt; any;
type ReturnType&lt;T extends AnyFunction&gt; = T extends (...args: any[]) =&gt; infer R
  ? R
  : any;</pre> <h2 id="predefined-conditional-types" style="position:relative;">Predefined conditional types</h2> <p>TypeScript adds several predefined conditional types, you can find the full list and examples in <a href="utility-types">Utility Types</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html" class="_attribution-link" target="_blank">https://www.typescriptlang.org/docs/handbook/advanced-types.html</a>
  </p>
</div>
