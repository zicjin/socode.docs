<h1> <button class="settings display-settings">  <span class="sr-only">Settings</span> </button>  <span>JavaScript interoperability</span> </h1> <p>To enable LiveView client/server interaction, we instantiate a LiveSocket. For example:</p>
<pre data-language="elixir">import {Socket} from "phoenix"
import {LiveSocket} from "phoenix_live_view"

let csrfToken = document.querySelector("meta[name='csrf-token']").getAttribute("content")
let liveSocket = new LiveSocket("/live", Socket, {params: {_csrf_token: csrfToken}})
liveSocket.connect()</pre>
<p>All options are passed directly to the <a href="../phoenix/1.5.9/phoenix.socket"><code class="inline">Phoenix.Socket</code></a> constructor, except for the following LiveView specific options:</p>
<ul>
<li>
<code class="inline">bindingPrefix</code> - the prefix to use for phoenix bindings. Defaults <code class="inline">"phx-"</code>
</li>
<li>
<code class="inline">params</code> - the <code class="inline">connect_params</code> to pass to the view's mount callback. May be a literal object or closure returning an object. When a closure is provided, the function receives the view's element.</li>
<li>
<code class="inline">hooks</code> – a reference to a user-defined hooks namespace, containing client callbacks for server/client interop. See the <a href="#client-hooks-via-phx-hook">Client hooks</a> section below for details.</li>
<li>
<code class="inline">uploaders</code> – a reference to a user-defined uploaders namespace, containing client callbacks for client-side direct-to-cloud uploads. See the <a href="uploads-external">External Uploads guide</a> for details.</li>
</ul>
<h2 id="debugging-client-events" class="section-heading">  Debugging Client Events </h2> <p>To aid debugging on the client when troubleshooting issues, the <code class="inline">enableDebug()</code> and <code class="inline">disableDebug()</code> functions are exposed on the <code class="inline">LiveSocket</code> JavaScript instance. Calling <code class="inline">enableDebug()</code> turns on debug logging which includes LiveView life-cycle and payload events as they come and go from client to server. In practice, you can expose your instance on <code class="inline">window</code> for quick access in the browser's web console, for example:</p>
<pre data-language="elixir">// app.js
let liveSocket = new LiveSocket(...)
liveSocket.connect()
window.liveSocket = liveSocket

// in the browser's web console
&gt;&gt; liveSocket.enableDebug()</pre>
<p>The debug state uses the browser's built-in <code class="inline">sessionStorage</code>, so it will remain in effect for as long as your browser session lasts.</p>
<h2 id="simulating-latency" class="section-heading">  Simulating Latency </h2> <p>Proper handling of latency is critical for good UX. LiveView's CSS loading states allow the client to provide user feedback while awaiting a server response. In development, near zero latency on localhost does not allow latency to be easily represented or tested, so LiveView includes a latency simulator with the JavaScript client to ensure your application provides a pleasant experience. Like the <code class="inline">enableDebug()</code> function above, the <code class="inline">LiveSocket</code> instance includes <code class="inline">enableLatencySim(milliseconds)</code> and <code class="inline">disableLatencySim()</code> functions which apply throughout the current browser session. The <code class="inline">enableLatencySim</code> function accepts an integer in milliseconds for the round-trip-time to the server. For example:</p>
<pre data-language="elixir">// app.js
let liveSocket = new LiveSocket(...)
liveSocket.connect()
window.liveSocket = liveSocket

// in the browser's web console
&gt;&gt; liveSocket.enableLatencySim(1000)
[Log] latency simulator enabled for the duration of this browser session.
      Call disableLatencySim() to disable</pre>
<h2 id="event-listeners" class="section-heading">  Event listeners </h2> <p>LiveView emits several events to the browsers and allows developers to submit their own events too.</p>
<h3 id="live-navigation-events" class="section-heading">  Live navigation events </h3> <p>For live page navigation via <code class="inline">live_redirect</code> and <code class="inline">live_patch</code>, as well as form submits via <code class="inline">phx-submit</code>, the JavaScript events <code class="inline">"phx:page-loading-start"</code> and <code class="inline">"phx:page-loading-stop"</code> are dispatched on window. Additionally, any <code class="inline">phx-</code> event may dispatch page loading events by annotating the DOM element with <code class="inline">phx-page-loading</code>. This is useful for showing main page loading status, for example:</p>
<pre data-language="elixir">// app.js
import topbar from "topbar"
window.addEventListener("phx:page-loading-start", info =&gt; topbar.show())
window.addEventListener("phx:page-loading-stop", info =&gt; topbar.hide())</pre>
<p>Within the callback, <code class="inline">info.detail</code> will be an object that contains a <code class="inline">kind</code> key, with a value that depends on the triggering event:</p>
<ul>
<li>
<code class="inline">"redirect"</code> - the event was triggered by a redirect</li>
<li>
<code class="inline">"patch"</code> - the event was triggered by a patch</li>
<li>
<code class="inline">"initial"</code> - the event was triggered by initial page load</li>
<li>
<code class="inline">"element"</code> - the event was triggered by a <code class="inline">phx-</code> bound element, such as <code class="inline">phx-click</code>
</li>
</ul>
<p>For all kinds of page loading events, all but <code class="inline">"element"</code> will receive an additional <code class="inline">to</code> key in the info metadata pointing to the href associated with the page load.</p>
<p>In the case of an <code class="inline">"element"</code> page loading event, the info will contain a <code class="inline">"target"</code> key containing the DOM element which triggered the page loading state.</p>
<h3 id="handling-server-pushed-events" class="section-heading">  Handling server-pushed events </h3> <p>When the server uses <a href="phoenix.liveview#push_event/3"><code class="inline">Phoenix.LiveView.push_event/3</code></a>, the event name will be dispatched in the browser with the <code class="inline">phx:</code> prefix. For example, imagine the following template where you want to highlight an existing element from the server to draw the user's attention:</p>
<pre data-language="elixir">&lt;div id={"item-#{item.id}"} class="item"&gt;
  &lt;%= item.title %&gt;
&lt;/div&gt;</pre>
<p>Next, the server can issue a highlight using the standard <code class="inline">push_event</code>:</p>
<pre data-language="elixir">def handle_info({:item_updated, item}, socket) do
  {:ok, push_event(socket, "highlight", %{id: item.id})}
end</pre>
<p>Finally, a window event listener can listen for the event and conditionally execute the highlight command if the element matches:</p>
<pre data-language="elixir">let liveSocket = new LiveSocket(...)
window.addEventListener(`phx:highlight`, (e) =&gt; {
  let el = document.getElementById(e.detail.id)
  if(el) {
    // logic for highlighting
  }
})</pre>
<p>If you desire, you can also integrate this functionality with Phoenix' JS commands, executing JS commands for the given element whenever highlight is triggered. First, update the element to embed the JS command into a data attribute:</p>
<pre data-language="elixir">&lt;div id={"item-#{item.id}"} class="item" data-highlight={JS.transition("highligh")}&gt;
  &lt;%= item.title %&gt;
&lt;/div&gt;</pre>
<p>Now, in the event listener, use <code class="inline">LiveSocket.execJS</code> to trigger all JS commands in the new attribute:</p>
<pre data-language="elixir">let liveSocket = new LiveSocket(...)
window.addEventListener(`phx:highlight`, (e) =&gt; {
  document.querySelectorAll(`[data-highlight]`).forEach(el =&gt; {
    if(el.id == e.detail.id){
      liveSocket.execJS(el, el.getAttribute("data-highlight"))
    }
  })
})</pre>
<h2 id="client-hooks-via-phx-hook" class="section-heading">  Client hooks via <code class="inline">phx-hook</code> </h2> <p>To handle custom client-side JavaScript when an element is added, updated, or removed by the server, a hook object may be provided via <code class="inline">phx-hook</code>. <code class="inline">phx-hook</code> must point to an object with the following life-cycle callbacks:</p>
<ul>
<li>
<code class="inline">mounted</code> - the element has been added to the DOM and its server LiveView has finished mounting</li>
<li>
<code class="inline">beforeUpdate</code> - the element is about to be updated in the DOM. <em>Note</em>: any call here must be synchronous as the operation cannot be deferred or cancelled.</li>
<li>
<code class="inline">updated</code> - the element has been updated in the DOM by the server</li>
<li>
<code class="inline">destroyed</code> - the element has been removed from the page, either by a parent update, or by the parent being removed entirely</li>
<li>
<code class="inline">disconnected</code> - the element's parent LiveView has disconnected from the server</li>
<li>
<code class="inline">reconnected</code> - the element's parent LiveView has reconnected to the server</li>
</ul>
<p>The above life-cycle callbacks have in-scope access to the following attributes:</p>
<ul>
<li>
<code class="inline">el</code> - attribute referencing the bound DOM node</li>
<li>
<code class="inline">pushEvent(event, payload, (reply, ref) =&gt; ...)</code> - method to push an event from the client to the LiveView server</li>
<li>
<code class="inline">pushEventTo(selectorOrTarget, event, payload, (reply, ref) =&gt; ...)</code> - method to push targeted events from the client to LiveViews and LiveComponents. It sends the event to the LiveComponent or LiveView the <code class="inline">selectorOrTarget</code> is defined in, where it's value can be either a query selector or an actual DOM element. If the query selector returns more than one element it will send the event to all of them, even if all the elements are in the same LiveComponent or LiveView.</li>
<li>
<code class="inline">handleEvent(event, (payload) =&gt; ...)</code> - method to handle an event pushed from the server</li>
<li>
<code class="inline">upload(name, files)</code> - method to inject a list of file-like objects into an uploader.</li>
<li>
<code class="inline">uploadTo(selectorOrTarget, name, files)</code> - method to inject a list of file-like objects into an uploader. The hook will send the files to the uploader with <code class="inline">name</code> defined by <a href="phoenix.liveview#allow_upload/3"><code class="inline">allow_upload/3</code></a> on the server-side. Dispatching new uploads triggers an input change event which will be sent to the LiveComponent or LiveView the <code class="inline">selectorOrTarget</code> is defined in, where it's value can be either a query selector or an actual DOM element. If the query selector returns more than one live file input, an error will be logged.</li>
</ul>
<p>For example, the markup for a controlled input for phone-number formatting could be written like this:</p>
<pre data-language="elixir">&lt;input type="text" name="user[phone_number]" id="user-phone-number" phx-hook="PhoneNumber" /&gt;</pre>
<p>Then a hook callback object could be defined and passed to the socket:</p>
<pre data-language="elixir">let Hooks = {}
Hooks.PhoneNumber = {
  mounted() {
    this.el.addEventListener("input", e =&gt; {
      let match = this.el.value.replace(/\D/g, "").match(/^(\d{3})(\d{3})(\d{4})$/)
      if(match) {
        this.el.value = `${match[1]}-${match[2]}-${match[3]}`
      }
    })
  }
}

let liveSocket = new LiveSocket("/live", Socket, {hooks: Hooks, ...})
...</pre>
<p><em>Note</em>: when using <code class="inline">phx-hook</code>, a unique DOM ID must always be set.</p>
<p>For integration with client-side libraries which require a broader access to full DOM management, the <code class="inline">LiveSocket</code> constructor accepts a <code class="inline">dom</code> option with an <code class="inline">onBeforeElUpdated</code> callback. The <code class="inline">fromEl</code> and <code class="inline">toEl</code> DOM nodes are passed to the function just before the DOM patch operations occurs in LiveView. This allows external libraries to (re)initialize DOM elements or copy attributes as necessary as LiveView performs its own patch operations. The update operation cannot be cancelled or deferred, and the return value is ignored. For example, the following option could be used to add <a href="https://github.com/alpinejs/alpine">Alpine.js</a> support to your project:</p>
<pre data-language="elixir">let liveSocket = new LiveSocket("/live", Socket, {
  ...,
  dom: {
    onBeforeElUpdated(from, to){
      if(from._x_dataStack){ window.Alpine.clone(from, to) }
    }
  },
})</pre>
<h3 id="client-server-communication" class="section-heading">  Client-server communication </h3> <p>A hook can push events to the LiveView by using the <code class="inline">pushEvent</code> function and receive a reply from the server via a <code class="inline">{:reply, map, socket}</code> return value. The reply payload will be passed to the optional <code class="inline">pushEvent</code> response callback.</p>
<p>Communication with the hook from the server can be done by reading data attributes on the hook element or by using <a href="phoenix.liveview#push_event/3"><code class="inline">Phoenix.LiveView.push_event/3</code></a> on the server and <code class="inline">handleEvent</code> on the client.</p>
<p>For example, to implement infinite scrolling, one can pass the current page using data attributes:</p>
<pre data-language="elixir">&lt;div id="infinite-scroll" phx-hook="InfiniteScroll" data-page="&lt;%= @page %&gt;"&gt;</pre>
<p>And then in the client:</p>
<pre data-language="elixir">Hooks.InfiniteScroll = {
  page() { return this.el.dataset.page },
  mounted(){
    this.pending = this.page()
    window.addEventListener("scroll", e =&gt; {
      if(this.pending == this.page() &amp;&amp; scrollAt() &gt; 90){
        this.pending = this.page() + 1
        this.pushEvent("load-more", {})
      }
    })
  },
  updated(){ this.pending = this.page() }
}</pre>
<p>However, the data attribute approach is not a good approach if you need to frequently push data to the client. To push out-of-band events to the client, for example to render charting points, one could do:</p>
<pre data-language="elixir">&lt;div id="chart" phx-hook="Chart"&gt;
{:noreply, push_event(socket, "points", %{points: new_points})}</pre>
<p>And then on the client:</p>
<pre data-language="elixir">Hooks.Chart = {
  mounted(){
    this.handleEvent("points", ({points}) =&gt; MyChartLib.addPoints(points))
  }
}</pre>
<p><em>Note</em>: remember events pushed from the server via <code class="inline">push_event</code> are global and will be dispatched to all active hooks on the client who are handling that event.</p>
<p><em>Note</em>: In case a LiveView pushes events and renders content, <code class="inline">handleEvent</code> callbacks are invoked after the page is updated. Therefore, if the LiveView redirects at the same time it pushes events, callbacks won't be invoked on the old page's elements. Callbacks would be invoked on the redirected page's newly mounted hook elements.</p>
<h2 id="triggering-phx-form-events-with-javascript" class="section-heading">  Triggering <code class="inline">phx-</code> form events with JavaScript </h2> <p>Often it is desirable to trigger an event on a DOM element without explicit user interaction on the element. For example, a custom form element such as a date picker or custom select input which utilizes a hidden input element to store the selected state.</p>
<p>In these cases, the event functions on the DOM API can be used, for example to trigger a <code class="inline">phx-change</code> event:</p>
<pre data-language="elixir">document.getElementById("my-select").dispatchEvent(
  new Event("input", {bubbles: true})
)</pre>
<p>When using a client hook, <code class="inline">this.el</code> can be used to determine the element as outlined in the "Client hooks" documentation.</p>
<p>It is also possible to trigger a <code class="inline">phx-submit</code> using a "submit" event:</p>
<pre data-language="elixir">document.getElementById("my-form").dispatchEvent(
  new Event("submit", {bubbles: true})
)</pre> <div class="bottom-actions"> <div class="bottom-actions-item"> <a href="dom-patching" class="bottom-actions-button" rel="prev"> <span class="subheader"> ← Previous Page </span> <span class="title"> DOM patching &amp; temporary assigns </span> </a> </div> <div class="bottom-actions-item"> <a href="uploads-external" class="bottom-actions-button" rel="next"> <span class="subheader"> Next Page → </span> <span class="title"> External Uploads </span> </a> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/phoenix_live_view/js-interop.html" class="_attribution-link" target="_blank">https://hexdocs.pm/phoenix_live_view/js-interop.html</a>
  </p>
</div>
