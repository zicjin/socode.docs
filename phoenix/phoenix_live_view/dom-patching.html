<h1>DOM patching &amp; temporary assigns</h1>
<p>A container can be marked with <code class="inline">phx-update</code>, allowing the DOM patch operations to avoid updating or removing portions of the LiveView, or to append or prepend the updates rather than replacing the existing contents. This is useful for client-side interop with existing libraries that do their own DOM operations. The following <code class="inline">phx-update</code> values are supported:</p>
<ul>
<li>
<code class="inline">replace</code> - the default operation. Replaces the element with the contents</li>
<li>
<code class="inline">ignore</code> - ignores updates to the DOM regardless of new content changes</li>
<li>
<code class="inline">append</code> - append the new DOM contents instead of replacing</li>
<li>
<code class="inline">prepend</code> - prepend the new DOM contents instead of replacing</li>
</ul>
<p>When using <code class="inline">phx-update</code>, a unique DOM ID must always be set in the container. If using "append" or "prepend", a DOM ID must also be set for each child. When appending or prepending elements containing an ID already present in the container, LiveView will replace the existing element with the new content instead appending or prepending a new element.</p>
<p>The "ignore" behaviour is frequently used when you need to integrate with another JS library. The "append" and "prepend" feature is often used with "Temporary assigns" to work with large amounts of data. Let's learn more.</p>
<h2 id="temporary-assigns" class="section-heading">  Temporary assigns </h2> <p>By default, all LiveView assigns are stateful, which enables change tracking and stateful interactions. In some cases, it's useful to mark assigns as temporary, meaning they will be reset to a default value after each update. This allows otherwise large but infrequently updated values to be discarded after the client has been patched.</p>
<p>Imagine you want to implement a chat application with LiveView. You could render each message like this:</p>
<pre data-language="elixir">&lt;%= for message &lt;- @messages do %&gt;
  &lt;p&gt;&lt;span&gt;&lt;%= message.username %&gt;:&lt;/span&gt; &lt;%= message.text %&gt;&lt;/p&gt;
&lt;% end %&gt;</pre>
<p>Every time there is a new message, you would append it to the <code class="inline">@messages</code> assign and re-render all messages.</p>
<p>As you may suspect, keeping the whole chat conversation in memory and resending it on every update would be too expensive, even with LiveView smart change tracking. By using temporary assigns and phx-update, we don't need to keep any messages in memory, and send messages to be appended to the UI only when there are new ones.</p>
<p>To do so, the first step is to mark which assigns are temporary and what values they should be reset to on mount:</p>
<pre data-language="elixir">def mount(_params, _session, socket) do
  socket = assign(socket, :messages, load_last_20_messages())
  {:ok, socket, temporary_assigns: [messages: []]}
end</pre>
<p>On mount we also load the initial number of messages we want to send. After the initial render, the initial batch of messages will be reset back to an empty list.</p>
<p>Now, whenever there are one or more new messages, we will assign only the new messages to <code class="inline">@messages</code>:</p>
<pre data-language="elixir">socket = assign(socket, :messages, new_messages)</pre>
<p>In the template, we want to wrap all of the messages in a container and tag this content with <code class="inline">phx-update</code>. Remember, we must add an ID to the container as well as to each child:</p>
<pre data-language="elixir">&lt;div id="chat-messages" phx-update="append"&gt;
  &lt;%= for message &lt;- @messages do %&gt;
    &lt;p id="&lt;%= message.id %&gt;"&gt;
      &lt;span&gt;&lt;%= message.username %&gt;:&lt;/span&gt; &lt;%= message.text %&gt;
    &lt;/p&gt;
  &lt;% end %&gt;
&lt;/div&gt;</pre>
<p>When the client receives new messages, it now knows to append to the old content rather than replace it.</p>
<p>You can also update the direction of messages. Suppose there is an edit to a message that is being sent to your LiveView like this:</p>
<pre data-language="elixir">def handle_info({:update_message, message}, socket) do
  {:noreply, update(socket, :messages, fn messages -&gt; [message | messages] end)}
end</pre>
<p>You can add it to the list like you do with new messages. LiveView is aware that this message was rendered on the client, even though the message itself is discarded on the server after it is rendered.</p>
<p>LiveView uses DOM ids to check if a message is rendered before or not. If an id is rendered before, the DOM element is updated rather than appending or prepending a new node. Also, the order of elements is not changed. You can use it to show edited messages, show likes, or anything that would require an update to a rendered message.</p>
<h2 id="pitfall-temporary-assigns-to-reset-or-control-ui-state" class="section-heading">  Pitfall: temporary assigns to reset or control UI state </h2> <p>Temporary assigns are useful when you want to render some data and then discard it so LiveView no longer needs to keep it in memory.</p>
<p>For this reason, a temporary assign is not re-rendered until it is set again. This means that temporary assigns should not be used to reset or control UI state. Let's see an example.</p>
<p>Imagine you want to show an error message when the input is less than 3 chars. You can write this code:</p>
<pre data-language="elixir">  def render(assigns) do
    ~L"""
    &lt;%= if @too_short do %&gt;
      Input too short...
    &lt;% end %&gt;

    Searched for: &lt;%= @search %&gt;
    &lt;form&gt;&lt;input phx-change="search" name="term" /&gt;&lt;/form&gt;
    """
  end

  def mount(_params, _session, socket) do
    {:ok,
     assign(socket, too_short: false, search: ""),
     temporary_assigns: [too_short: false]}
  end

  def handle_event("search", %{"term" =&gt; term}, socket) do
    # do not search if user provides less then 3 chars
    if String.length(term) &gt;= 3 do
      {:noreply, assign(socket, search: term)}
    else
      {:noreply, assign(socket, too_short: true, search: term)}
    end
  end</pre>
<p>The idea here is that, while the term is less than 3 characters, we will set <code class="inline">@too_short</code> to true and show an error message in the UI accordingly. We also set <code class="inline">@too_short</code> as a temporary assign, so that it resets to <code class="inline">false</code> after every render.</p>
<p>However, once a temporary assign resets to its original value, it won't be re-rendered, unless we explicitly assign it to something else. This means that the LiveView will never re-render the <code class="inline">if</code> block and we will continue to show "Input too short..." even after the input has 3 or more characters.</p>
<p>The mistake here is using <code class="inline">:temporary_assigns</code> to reset or control UI state, while <code class="inline">:temporary_assigns</code> should rather be used when we don't have (or don't want to keep) certain data around. The fix is to set <code class="inline">too_short: false</code> on the <code class="inline">if</code> branch, making sure it is reset whenever the search input changes.</p> <div class="bottom-actions"> <div class="bottom-actions-item"> <a href="form-bindings" class="bottom-actions-button" rel="prev"> <span class="subheader"> ← Previous Page </span> <span class="title"> Form bindings </span> </a> </div> <div class="bottom-actions-item"> <a href="js-interop" class="bottom-actions-button" rel="next"> <span class="subheader"> Next Page → </span> <span class="title"> JavaScript interoperability </span> </a> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/phoenix_live_view/dom-patching.html" class="_attribution-link" target="_blank">https://hexdocs.pm/phoenix_live_view/dom-patching.html</a>
  </p>
</div>
