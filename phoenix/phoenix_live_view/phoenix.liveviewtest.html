<h1> Phoenix.LiveViewTest   </h1> <section id="moduledoc"> <p>Conveniences for testing Phoenix LiveViews.</p>
<p>In LiveView tests, we interact with views via process communication in substitution of a browser. Like a browser, our test process receives messages about the rendered updates from the view which can be asserted against to test the life-cycle and behavior of LiveViews and their children.</p>
<h2 id="module-liveview-testing" class="section-heading">  LiveView Testing </h2> <p>The life-cycle of a LiveView as outlined in the <a href="phoenix.liveview"><code class="inline">Phoenix.LiveView</code></a> docs details how a view starts as a stateless HTML render in a disconnected socket state. Once the browser receives the HTML, it connects to the server and a new LiveView process is started, remounted in a connected socket state, and the view continues statefully. The LiveView test functions support testing both disconnected and connected mounts separately, for example:</p>
<pre data-language="elixir">import Plug.Conn
import Phoenix.ConnTest
import Phoenix.LiveViewTest
@endpoint MyEndpoint

test "disconnected and connected mount", %{conn: conn} do
  conn = get(conn, "/my-path")
  assert html_response(conn, 200) =~ "&lt;h1&gt;My Disconnected View&lt;/h1&gt;"

  {:ok, view, html} = live(conn)
end

test "redirected mount", %{conn: conn} do
  assert {:error, {:redirect, %{to: "/somewhere"}}} = live(conn, "my-path")
end</pre>
<p>Here, we start by using the familiar <a href="../phoenix/1.5.7/phoenix.conntest"><code class="inline">Phoenix.ConnTest</code></a> function, <code class="inline">get/2</code> to test the regular HTTP GET request which invokes mount with a disconnected socket. Next, <a href="#live/1"><code class="inline">live/1</code></a> is called with our sent connection to mount the view in a connected state, which starts our stateful LiveView process.</p>
<p>In general, it's often more convenient to test the mounting of a view in a single step, provided you don't need the result of the stateless HTTP render. This is done with a single call to <a href="#live/2"><code class="inline">live/2</code></a>, which performs the <code class="inline">get</code> step for us:</p>
<pre data-language="elixir">test "connected mount", %{conn: conn} do
  {:ok, _view, html} = live(conn, "/my-path")
  assert html =~ "&lt;h1&gt;My Connected View&lt;/h1&gt;"
end</pre>
<h2 id="module-testing-events" class="section-heading">  Testing Events </h2> <p>The browser can send a variety of events to a LiveView via <code class="inline">phx-</code> bindings, which are sent to the <code class="inline">handle_event/3</code> callback. To test events sent by the browser and assert on the rendered side effect of the event, use the <code class="inline">render_*</code> functions:</p>
<ul>
<li><p><a href="#render_click/1"><code class="inline">render_click/1</code></a> - sends a phx-click event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
<li><p><a href="#render_focus/2"><code class="inline">render_focus/2</code></a> - sends a phx-focus event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
<li><p><a href="#render_blur/1"><code class="inline">render_blur/1</code></a> - sends a phx-blur event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
<li><p><a href="#render_submit/1"><code class="inline">render_submit/1</code></a> - sends a form phx-submit event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
<li><p><a href="#render_change/1"><code class="inline">render_change/1</code></a> - sends a form phx-change event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
<li><p><a href="#render_keydown/1"><code class="inline">render_keydown/1</code></a> - sends a form phx-keydown event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
<li><p><a href="#render_keyup/1"><code class="inline">render_keyup/1</code></a> - sends a form phx-keyup event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
<li><p><a href="#render_hook/3"><code class="inline">render_hook/3</code></a> - sends a hook event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
</ul>
<p>For example:</p>
<pre data-language="elixir">{:ok, view, _html} = live(conn, "/thermo")

assert view
       |&gt; element("button#inc")
       |&gt; render_click() =~ "The temperature is: 31℉"</pre>
<p>In the example above, we are looking for a particular element on the page and triggering its phx-click event. LiveView takes care of making sure the element has a phx-click and automatically sends its values to the server.</p>
<p>You can also bypass the element lookup and directly trigger the LiveView event in most functions:</p>
<pre data-language="elixir">assert render_click(view, :inc, %{}) =~ "The temperature is: 31℉"</pre>
<p>The <code class="inline">element</code> style is preferred as much as possible, as it helps LiveView perform validations and ensure the events in the HTML actually matches the event names on the server.</p>
<h2 id="module-testing-regular-messages" class="section-heading">  Testing regular messages </h2> <p>LiveViews are <a href="https://hexdocs.pm/elixir/GenServer.html"><code class="inline">GenServer</code></a>'s under the hood, and can send and receive messages just like any other server. To test the side effects of sending or receiving messages, simply message the view and use the <code class="inline">render</code> function to test the result:</p>
<pre data-language="elixir">send(view.pid, {:set_temp, 50})
assert render(view) =~ "The temperature is: 50℉"</pre>
<h2 id="module-testing-components" class="section-heading">  Testing components </h2> <p>There are two main mechanisms for testing components. To test stateless components or just a regular rendering of a component, one can use <a href="#render_component/2"><code class="inline">render_component/2</code></a>:</p>
<pre data-language="elixir">assert render_component(MyComponent, id: 123, user: %User{}) =~
         "some markup in component"</pre>
<p>If you want to test how components are mounted by a LiveView and interact with DOM events, you can use the regular <a href="#live/2"><code class="inline">live/2</code></a> macro to build the LiveView with the component and then scope events by passing the view and a <strong>DOM selector</strong> in a list:</p>
<pre data-language="elixir">{:ok, view, html} = live(conn, "/users")
html = view |&gt; element("#user-13 a", "Delete") |&gt; render_click()
refute html =~ "user-13"
refute view |&gt; element("#user-13") |&gt; has_element?()</pre>
<p>In the example above, LiveView will lookup for an element with ID=user-13 and retrieve its <code class="inline">phx-target</code>. If <code class="inline">phx-target</code> points to a component, that will be the component used, otherwise it will fallback to the view.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_patch/3">assert_patch(view, to, timeout \\ 100)</a> </dt> <dd class="summary-synopsis"><p>Asserts a live patch will happen within <code class="inline">timeout</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_patched/2">assert_patched(view, to)</a> </dt> <dd class="summary-synopsis"><p>Asserts a live patch was performed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_push_event/4">assert_push_event(view, event, payload, timeout \\ 100)</a> </dt> <dd class="summary-synopsis"><p>Asserts an event will be pushed within <code class="inline">timeout</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_redirect/3">assert_redirect(view, to, timeout \\ 100)</a> </dt> <dd class="summary-synopsis"><p>Asserts a redirect will happen within <code class="inline">timeout</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_redirected/2">assert_redirected(view, to)</a> </dt> <dd class="summary-synopsis"><p>Asserts a redirect was performed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_reply/3">assert_reply(view, payload, timeout \\ 100)</a> </dt> <dd class="summary-synopsis"><p>Asserts a hook reply was returned from a <code class="inline">handle_event</code> callback.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#element/3">element(view, selector, text_filter \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Returns an element to scope a function to.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#file_input/4">file_input(view, form_selector, name, entries)</a> </dt> <dd class="summary-synopsis"><p>Builds a file input for testing uploads within a form.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#find_live_child/2">find_live_child(parent, child_id)</a> </dt> <dd class="summary-synopsis"><p>Gets the nested LiveView child by <code class="inline">child_id</code> from the <code class="inline">parent</code> LiveView.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#follow_redirect/3">follow_redirect(reason, conn, to \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Follows the redirect from a <code class="inline">render_*</code> action or an <code class="inline">{:error, redirect}</code> tuple.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#follow_trigger_action/2">follow_trigger_action(form, conn)</a> </dt> <dd class="summary-synopsis"><p>Receives a <code class="inline">form_element</code> and asserts that <code class="inline">phx-trigger-action</code> has been set to true, following up on that request.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#form/3">form(view, selector, form_data \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Returns a form element to scope a function to.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#has_element?/1">has_element?(element)</a> </dt> <dd class="summary-synopsis"><p>Checks if the given element exists on the page.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#has_element?/3">has_element?(view, selector, text_filter \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Checks if the given <code class="inline">selector</code> with <code class="inline">text_filter</code> is on <code class="inline">view</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#live/2">live(conn, path \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Spawns a connected LiveView process.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#live_children/1">live_children(parent)</a> </dt> <dd class="summary-synopsis"><p>Returns the current list of LiveView children for the <code class="inline">parent</code> LiveView.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#live_isolated/3">live_isolated(conn, live_view, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Spawns a connected LiveView process mounted in isolation as the sole rendered element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#open_browser/2">open_browser(view_or_element, open_fun \\ &amp;open_with_system_cmd/1)</a> </dt> <dd class="summary-synopsis"><p>Open the default browser to display current HTML of <code class="inline">view_or_element</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#page_title/1">page_title(view)</a> </dt> <dd class="summary-synopsis"><p>Returns the most recent title that was updated via a <code class="inline">page_title</code> assign.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#preflight_upload/1">preflight_upload(upload)</a> </dt> <dd class="summary-synopsis"><p>Performs a preflight upload request.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_connect_info/2">put_connect_info(conn, params)</a> </dt> <dd class="summary-synopsis"><p>Puts connect info to be used on LiveView connections.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_connect_params/2">put_connect_params(conn, params)</a> </dt> <dd class="summary-synopsis"><p>Puts connect params to be used on LiveView connections.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render/1">render(view_or_element)</a> </dt> <dd class="summary-synopsis"><p>Returns the HTML string of the rendered view or element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_blur/2">render_blur(element, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a blur event given by <code class="inline">element</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_blur/3">render_blur(view, event, value)</a> </dt> <dd class="summary-synopsis"><p>Sends a blur event to the view and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_change/2">render_change(element, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a form change event given by <code class="inline">element</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_change/3">render_change(view, event, value)</a> </dt> <dd class="summary-synopsis"><p>Sends a form change event to the view and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_click/2">render_click(element, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a click event given by <code class="inline">element</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_click/3">render_click(view, event, value)</a> </dt> <dd class="summary-synopsis"><p>Sends a click <code class="inline">event</code> to the <code class="inline">view</code> with <code class="inline">value</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_component/3">render_component(component, assigns, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Mounts, updates and renders a component.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_focus/2">render_focus(element, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a focus event given by <code class="inline">element</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_focus/3">render_focus(view, event, value)</a> </dt> <dd class="summary-synopsis"><p>Sends a focus event to the view and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_hook/3">render_hook(view_or_element, event, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a hook event to the view or an element and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_keydown/2">render_keydown(element, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a keydown event given by <code class="inline">element</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_keydown/3">render_keydown(view, event, value)</a> </dt> <dd class="summary-synopsis"><p>Sends a keydown event to the view and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_keyup/2">render_keyup(element, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a keyup event given by <code class="inline">element</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_keyup/3">render_keyup(view, event, value)</a> </dt> <dd class="summary-synopsis"><p>Sends a keyup event to the view and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_patch/2">render_patch(view, path)</a> </dt> <dd class="summary-synopsis"><p>Simulates a <code class="inline">live_patch</code> to the given <code class="inline">path</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_submit/2">render_submit(element, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a form submit event given by <code class="inline">element</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_submit/3">render_submit(view, event, value)</a> </dt> <dd class="summary-synopsis"><p>Sends a form submit event to the view and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_upload/3">render_upload(upload, entry_name, percent \\ 100)</a> </dt> <dd class="summary-synopsis"><p>Performs an upload of a file input and renders the result.</p></dd> </div> </dl> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail">  <h3 class="detail-header" id="assert_patch/3">assert_patch(view, to, timeout \\ 100)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L1049" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts a live patch will happen within <code class="inline">timeout</code>.</p>
<p>It always returns <code class="inline">:ok</code>. To assert on the flash message, you can assert on the result of the rendered LiveView.</p>
<h4 id="assert_patch/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">render_click(view, :event_that_triggers_patch)
assert_patch view, "/path"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="assert_patched/2">assert_patched(view, to)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L1067" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts a live patch was performed.</p>
<p>It always returns <code class="inline">:ok</code>. To assert on the flash message, you can assert on the result of the rendered LiveView.</p>
<h4 id="assert_patched/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">render_click(view, :event_that_triggers_redirect)
assert_patched view, "/path"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="assert_push_event/4">assert_push_event(view, event, payload, timeout \\ 100)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L1233" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts an event will be pushed within <code class="inline">timeout</code>.</p>
<h4 id="assert_push_event/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">assert_push_event view, "scores", %{points: 100, user: "josé"}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="assert_redirect/3">assert_redirect(view, to, timeout \\ 100)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L1084" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts a redirect will happen within <code class="inline">timeout</code>.</p>
<p>It returns the flash messages from said redirect, if any. Note the flash will contain string keys.</p>
<h4 id="assert_redirect/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">render_click(view, :event_that_triggers_redirect)
flash = assert_redirect view, "/path"
assert flash["info"] == "Welcome"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="assert_redirected/2">assert_redirected(view, to)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L1102" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts a redirect was performed.</p>
<p>It returns the flash messages from said redirect, if any. Note the flash will contain string keys.</p>
<h4 id="assert_redirected/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">render_click(view, :event_that_triggers_redirect)
flash = assert_redirected view, "/path"
assert flash["info"] == "Welcome"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="assert_reply/3">assert_reply(view, payload, timeout \\ 100)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L1248" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts a hook reply was returned from a <code class="inline">handle_event</code> callback.</p>
<h4 id="assert_reply/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">assert_reply view, %{result: "ok", transaction_id: _}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="element/3">element(view, selector, text_filter \\ nil)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L916" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns an element to scope a function to.</p>
<p>It expects the current LiveView, a query selector, and a text filter.</p>
<p>An optional text filter may be given to filter the results by the query selector. If the text filter is a string or a regex, it will match any element that contains the string or matches the regex. After the text filter is applied, only one element must remain, otherwise an error is raised.</p>
<p>If no text filter is given, then the query selector itself must return a single element.</p>
<pre data-language="elixir">assert view
      |&gt; element("#term a:first-child()", "Increment")
      |&gt; render() =~ "Increment&lt;/a&gt;"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="file_input/4">file_input(view, form_selector, name, entries)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L970" class="source">Source</a>
</h3> <section class="docstring"> <p>Builds a file input for testing uploads within a form.</p>
<p>Given the form DOM selector, the upload name, and a list of maps of client metadata for the upload, the returned file input can be passed to <a href="#render_upload/2"><code class="inline">render_upload/2</code></a>.</p>
<p>Client metadata takes the following form:</p>
<ul>
<li>
<code class="inline">:last_modified</code> - the last modified timestamp</li>
<li>
<code class="inline">:name</code> - the name of the file</li>
<li>
<code class="inline">:content</code> - the binary content of the file</li>
<li>
<code class="inline">:size</code> - the byte size of the content</li>
<li>
<code class="inline">:type</code> - the MIME type of the file</li>
</ul>
<h4 id="file_input/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">avatar = file_input(lv, "#my-form-id", :avatar, [%{
  last_modified: 1_594_171_879_000,
  name: "myfile.jpeg",
  content: File.read!("myfile.jpg"),
  size: 1_396_009,
  type: "image/jpeg"
}])

assert render_upload(avatar, "foo.jpeg") =~ "100%"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="find_live_child/2">find_live_child(parent, child_id)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L816" class="source">Source</a>
</h3> <section class="docstring"> <p>Gets the nested LiveView child by <code class="inline">child_id</code> from the <code class="inline">parent</code> LiveView.</p>
<h4 id="find_live_child/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, _html} = live(conn, "/thermo")
assert clock_view = find_live_child(view, "clock")
assert render_click(clock_view, :snooze) =~ "snoozing"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="follow_redirect/3">follow_redirect(reason, conn, to \\ nil)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L1291" class="source">Source</a>
</h3> <section class="docstring"> <p>Follows the redirect from a <code class="inline">render_*</code> action or an <code class="inline">{:error, redirect}</code> tuple.</p>
<p>Imagine you have a LiveView that redirects on a <code class="inline">render_click</code> event. You can make it sure it immediately redirects after the <code class="inline">render_click</code> action by calling <a href="#follow_redirect/3"><code class="inline">follow_redirect/3</code></a>:</p>
<pre data-language="elixir">live_view
|&gt; render_click("redirect")
|&gt; follow_redirect(conn)</pre>
<p>Or in the case of an error tuple:</p>
<pre data-language="elixir">assert {:error, {:redirect, %{to: "/somewhere"}}} = result = live(conn, "my-path")
{:ok, view, html} = follow_redirect(result, conn)</pre>
<p><a href="#follow_redirect/3"><code class="inline">follow_redirect/3</code></a> expects a connection as second argument. This is the connection that will be used to perform the underlying request.</p>
<p>If the LiveView redirects with a live redirect, this macro returns <code class="inline">{:ok, live_view, disconnected_html}</code> with the content of the new LiveView, the same as the <code class="inline">live/3</code> macro. If the LiveView redirects with a regular redirect, this macro returns <code class="inline">{:ok, conn}</code> with the rendered redirected page. In any other case, this macro raises.</p>
<p>Finally, note that you can optionally assert on the path you are being redirected to by passing a third argument:</p>
<pre data-language="elixir">live_view
|&gt; render_click("redirect")
|&gt; follow_redirect(conn, "/redirected/page")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="follow_trigger_action/2">follow_trigger_action(form, conn)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L1344" class="source">Source</a>
</h3> <section class="docstring"> <p>Receives a <code class="inline">form_element</code> and asserts that <code class="inline">phx-trigger-action</code> has been set to true, following up on that request.</p>
<p>Imagine you have a LiveView that sends an HTTP form submission. Say that it sets the <code class="inline">phx-trigger-action</code> to true, as a response to a submit event. You can follow the trigger action like this:</p>
<pre data-language="elixir">form = form(live_view, selector, %{"form" =&gt; "data"})

# First we submit the form. Optionally verify that phx-trigger-action
# is now part of the form.
assert render_submit(form) =~ ~r/phx-trigger-action/

# Now follow the request made by the form
conn = follow_trigger_action(form, conn)
assert conn.method == "POST"
assert conn.params == %{"form" =&gt; "data"}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="form/3">form(view, selector, form_data \\ %{})<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L940" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns a form element to scope a function to.</p>
<p>It expects the current LiveView, a query selector, and the form data. The query selector must return a single element.</p>
<p>The form data will be validated directly against the form markup and make sure the data you are changing/submitting actually exists, failing otherwise.</p>
<h4 id="form/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">assert view
      |&gt; form("#term", user: %{name: "hello"})
      |&gt; render_submit() =~ "Name updated"</pre>
<p>This function is meant to mimic what the user can actually do, so you cannot set hidden input values. However, hidden values can be given when calling <a href="#render_submit/2"><code class="inline">render_submit/2</code></a> or <a href="#render_change/2"><code class="inline">render_change/2</code></a>, see their docs for examples.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="has_element?/1">has_element?(element)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L830" class="source">Source</a>
</h3> <section class="docstring"> <p>Checks if the given element exists on the page.</p>
<h4 id="has_element?/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">assert view |&gt; element("#some-element") |&gt; has_element?()</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="has_element?/3">has_element?(view, selector, text_filter \\ nil)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L844" class="source">Source</a>
</h3> <section class="docstring"> <p>Checks if the given <code class="inline">selector</code> with <code class="inline">text_filter</code> is on <code class="inline">view</code>.</p>
<p>See <a href="#element/3"><code class="inline">element/3</code></a> for more information.</p>
<h4 id="has_element?/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">assert has_element?(view, "#some-element")</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="live/2">live(conn, path \\ nil)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L182" class="source">Source</a>
</h3> <section class="docstring"> <p>Spawns a connected LiveView process.</p>
<p>If a <code class="inline">path</code> is given, then a regular <code class="inline">get(conn, path)</code> is done and the page is upgraded to a <code class="inline">LiveView</code>. If no path is given, it assumes a previously rendered <code class="inline">%Plug.Conn{}</code> is given, which will be converted to a <code class="inline">LiveView</code> immediately.</p>
<h4 id="live/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/path")
assert view.module = MyLive
assert html =~ "the count is 3"

assert {:error, {:redirect, %{to: "/somewhere"}}} = live(conn, "/path")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="live_children/1">live_children(parent)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L803" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns the current list of LiveView children for the <code class="inline">parent</code> LiveView.</p>
<p>Children are returned in the order they appear in the rendered HTML.</p>
<h4 id="live_children/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, _html} = live(conn, "/thermo")
assert [clock_view] = live_children(view)
assert render_click(clock_view, :snooze) =~ "snoozing"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="live_isolated/3">live_isolated(conn, live_view, opts \\ [])<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L228" class="source">Source</a>
</h3> <section class="docstring"> <p>Spawns a connected LiveView process mounted in isolation as the sole rendered element.</p>
<p>Useful for testing LiveViews that are not directly routable, such as those built as small components to be re-used in multiple parents. Testing routable LiveViews is still recommended whenever possible since features such as live navigation require routable LiveViews.</p>
<h4 id="live_isolated/3-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:session</code> - the session to be given to the LiveView</li></ul>
<p>All other options are forwarded to the LiveView for rendering. Refer to <a href="phoenix.liveview.helpers#live_render/3"><code class="inline">Phoenix.LiveView.Helpers.live_render/3</code></a> for a list of supported render options.</p>
<h4 id="live_isolated/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} =
  live_isolated(conn, AppWeb.ClockLive, session: %{"tz" =&gt; "EST"})</pre>
<p>Use <a href="#put_connect_params/2"><code class="inline">put_connect_params/2</code></a> to put connect params for a call to <a href="phoenix.liveview#get_connect_params/1"><code class="inline">Phoenix.LiveView.get_connect_params/1</code></a> in <a href="phoenix.liveview#c:mount/3"><code class="inline">Phoenix.LiveView.mount/3</code></a>:</p>
<pre data-language="elixir">{:ok, view, html} =
  conn
  |&gt; put_connect_params(%{"param" =&gt; "value"})
  |&gt; live_isolated(AppWeb.ClockLive, session: %{"tz" =&gt; "EST"})</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="open_browser/2">open_browser(view_or_element, open_fun \\ &amp;open_with_system_cmd/1)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L1147" class="source">Source</a>
</h3> <section class="docstring"> <p>Open the default browser to display current HTML of <code class="inline">view_or_element</code>.</p>
<h4 id="open_browser/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">view
|&gt; element("#term a:first-child()", "Increment")
|&gt; open_browser()

assert view
       |&gt; form("#term", user: %{name: "hello"})
       |&gt; open_browser()
       |&gt; render_submit() =~ "Name updated"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="page_title/1">page_title(view)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L1033" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns the most recent title that was updated via a <code class="inline">page_title</code> assign.</p>
<h4 id="page_title/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">render_click(view, :event_that_triggers_page_title_update)
assert page_title(view) =~ "my title"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="preflight_upload/1">preflight_upload(upload)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L1435" class="source">Source</a>
</h3> <section class="docstring"> <p>Performs a preflight upload request.</p>
<p>Useful for testing external uploaders to retrieve the <code class="inline">:external</code> entry metadata.</p>
<h4 id="preflight_upload/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">avatar = file_input(lv, "#my-form-id", :avatar, [%{name: ..., ...}, ...])
assert {:ok, %{ref: _ref, config: %{chunk_size: _}}} = preflight_upload(avatar)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_connect_info/2">put_connect_info(conn, params)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L160" class="source">Source</a>
</h3> <section class="docstring"> <p>Puts connect info to be used on LiveView connections.</p>
<p>See <a href="phoenix.liveview#get_connect_info/1"><code class="inline">Phoenix.LiveView.get_connect_info/1</code></a>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_connect_params/2">put_connect_params(conn, params)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L151" class="source">Source</a>
</h3> <section class="docstring"> <p>Puts connect params to be used on LiveView connections.</p>
<p>See <a href="phoenix.liveview#get_connect_params/1"><code class="inline">Phoenix.LiveView.get_connect_params/1</code></a>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="render/1">render(view_or_element)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L863" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns the HTML string of the rendered view or element.</p>
<p>If a view is provided, the entire LiveView is rendered. If an element is provided, only that element is rendered.</p>
<h4 id="render/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, _html} = live(conn, "/thermo")
assert render(view) =~ ~s|&lt;button id="alarm"&gt;Snooze&lt;/div&gt;|

assert view
       |&gt; element("#alarm")
       |&gt; render() == "Snooze"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_blur/2">render_blur(element, value \\ %{})<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L682" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a blur event given by <code class="inline">element</code> and returns the rendered result.</p>
<p>The <code class="inline">element</code> is created with <a href="#element/3"><code class="inline">element/3</code></a> and must point to a single element on the page with a <code class="inline">phx-blur</code> attribute in it. The event name given set on <code class="inline">phx-blur</code> is then sent to the appropriate LiveView (or component if <code class="inline">phx-target</code> is set accordingly). All <code class="inline">phx-value-*</code> entries in the element are sent as values. Extra values can be given with the <code class="inline">value</code> argument.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_blur/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")

assert view
       |&gt; element("#inactive")
       |&gt; render_blur() =~ "Tap to wake"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_blur/3">render_blur(view, event, value)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L699" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a blur event to the view and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_blur/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert render_blur(view, :inactive) =~ "Tap to wake"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_change/2">render_change(element, value \\ %{})<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L556" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a form change event given by <code class="inline">element</code> and returns the rendered result.</p>
<p>The <code class="inline">element</code> is created with <a href="#element/3"><code class="inline">element/3</code></a> and must point to a single element on the page with a <code class="inline">phx-change</code> attribute in it. The event name given set on <code class="inline">phx-change</code> is then sent to the appropriate LiveView (or component if <code class="inline">phx-target</code> is set accordingly). All <code class="inline">phx-value-*</code> entries in the element are sent as values.</p>
<p>If you need to pass any extra values or metadata, such as the "_target" parameter, you can do so by giving a map under the <code class="inline">value</code> argument.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_change/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")

assert view
       |&gt; element("form")
       |&gt; render_change(%{deg: 123}) =~ "123 exceeds limits"

# Passing metadata
{:ok, view, html} = live(conn, "/thermo")

assert view
       |&gt; element("form")
       |&gt; render_change(%{_target: ["deg"], deg: 123}) =~ "123 exceeds limits"</pre>
<p>As with <a href="#render_submit/2"><code class="inline">render_submit/2</code></a>, hidden input field values can be provided like so:</p>
<pre data-language="elixir">refute view
      |&gt; form("#term", user: %{name: "hello"})
      |&gt; render_change(%{user: %{"hidden_field" =&gt; "example"}}) =~ "can't be blank"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_change/3">render_change(view, event, value)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L572" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a form change event to the view and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_change/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert render_change(view, :validate, %{deg: 123}) =~ "123 exceeds limits"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_click/2">render_click(element, value \\ %{})<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L450" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a click event given by <code class="inline">element</code> and returns the rendered result.</p>
<p>The <code class="inline">element</code> is created with <a href="#element/3"><code class="inline">element/3</code></a> and must point to a single element on the page with a <code class="inline">phx-click</code> attribute in it. The event name given set on <code class="inline">phx-click</code> is then sent to the appropriate LiveView (or component if <code class="inline">phx-target</code> is set accordingly). All <code class="inline">phx-value-*</code> entries in the element are sent as values. Extra values can be given with the <code class="inline">value</code> argument.</p>
<p>If the element is does not have a <code class="inline">phx-click</code> attribute but it is a link (the <code class="inline">&lt;a&gt;</code> tag), the link will be followed accordingly:</p>
<ul>
<li>if the link is a <code class="inline">live_patch</code>, the current view will be patched</li>
<li>if the link is a <code class="inline">live_redirect</code>, this function will return <code class="inline">{:error, {:live_redirect, %{to: url}}}</code>, which can be followed with <a href="#follow_redirect/2"><code class="inline">follow_redirect/2</code></a>
</li>
<li>if the link is a regular link, this function will return <code class="inline">{:error, {:redirect, %{to: url}}}</code>, which can be followed with <a href="#follow_redirect/2"><code class="inline">follow_redirect/2</code></a>
</li>
</ul>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_click/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")

assert view
       |&gt; element("buttons", "Increment")
       |&gt; render_click() =~ "The temperature is: 30℉"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_click/3">render_click(view, event, value)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L467" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a click <code class="inline">event</code> to the <code class="inline">view</code> with <code class="inline">value</code> and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_click/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temperature is: 30℉"
assert render_click(view, :inc) =~ "The temperature is: 31℉"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_component/3">render_component(component, assigns, opts \\ [])<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L392" class="source">Source</a>
</h3> <section class="docstring"> <p>Mounts, updates and renders a component.</p>
<p>If the component uses the <code class="inline">@myself</code> assigns, then an <code class="inline">id</code> must be given to it is marked as stateful.</p>
<h4 id="render_component/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">assert render_component(MyComponent, id: 123, user: %User{}) =~
         "some markup in component"

assert render_component(MyComponent, %{id: 123, user: %User{}}, router: SomeRouter) =~
         "some markup in component"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_focus/2">render_focus(element, value \\ %{})<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L724" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a focus event given by <code class="inline">element</code> and returns the rendered result.</p>
<p>The <code class="inline">element</code> is created with <a href="#element/3"><code class="inline">element/3</code></a> and must point to a single element on the page with a <code class="inline">phx-focus</code> attribute in it. The event name given set on <code class="inline">phx-focus</code> is then sent to the appropriate LiveView (or component if <code class="inline">phx-target</code> is set accordingly). All <code class="inline">phx-value-*</code> entries in the element are sent as values. Extra values can be given with the <code class="inline">value</code> argument.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_focus/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")

assert view
       |&gt; element("#inactive")
       |&gt; render_focus() =~ "Tap to wake"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_focus/3">render_focus(view, event, value)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L741" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a focus event to the view and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_focus/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert render_focus(view, :inactive) =~ "Tap to wake"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_hook/3">render_hook(view_or_element, event, value \\ %{})<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L767" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a hook event to the view or an element and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_hook/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert render_hook(view, :refresh, %{deg: 32}) =~ "The temp is: 32℉"</pre>
<p>If you are pushing events from a hook to a component, then you must pass an <code class="inline">element</code>, created with <a href="#element/3"><code class="inline">element/3</code></a>, as first argument and it must point to a single element on the page with a <code class="inline">phx-target</code> attribute in it:</p>
<pre data-language="elixir">{:ok, view, _html} = live(conn, "/thermo")
assert view
       |&gt; element("#thermo-component")
       |&gt; render_hook(:refresh, %{deg: 32}) =~ "The temp is: 32℉"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_keydown/2">render_keydown(element, value \\ %{})<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L596" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a keydown event given by <code class="inline">element</code> and returns the rendered result.</p>
<p>The <code class="inline">element</code> is created with <a href="#element/3"><code class="inline">element/3</code></a> and must point to a single element on the page with a <code class="inline">phx-keydown</code> or <code class="inline">phx-window-keydown</code> attribute in it. The event name given set on <code class="inline">phx-keydown</code> is then sent to the appropriate LiveView (or component if <code class="inline">phx-target</code> is set accordingly). All <code class="inline">phx-value-*</code> entries in the element are sent as values. Extra values can be given with the <code class="inline">value</code> argument.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_keydown/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert view |&gt; element("#inc") |&gt; render_keydown() =~ "The temp is: 31℉"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_keydown/3">render_keydown(view, event, value)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L616" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a keydown event to the view and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_keydown/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert render_keydown(view, :inc) =~ "The temp is: 31℉"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_keyup/2">render_keyup(element, value \\ %{})<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L640" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a keyup event given by <code class="inline">element</code> and returns the rendered result.</p>
<p>The <code class="inline">element</code> is created with <a href="#element/3"><code class="inline">element/3</code></a> and must point to a single element on the page with a <code class="inline">phx-keyup</code> or <code class="inline">phx-window-keyup</code> attribute in it. The event name given set on <code class="inline">phx-keyup</code> is then sent to the appropriate LiveView (or component if <code class="inline">phx-target</code> is set accordingly). All <code class="inline">phx-value-*</code> entries in the element are sent as values. Extra values can be given with the <code class="inline">value</code> argument.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_keyup/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert view |&gt; element("#inc") |&gt; render_keyup() =~ "The temp is: 31℉"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_keyup/3">render_keyup(view, event, value)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L657" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a keyup event to the view and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_keyup/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert render_keyup(view, :inc) =~ "The temp is: 31℉"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_patch/2">render_patch(view, path)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L788" class="source">Source</a>
</h3> <section class="docstring"> <p>Simulates a <code class="inline">live_patch</code> to the given <code class="inline">path</code> and returns the rendered result.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_submit/2">render_submit(element, value \\ %{})<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L499" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a form submit event given by <code class="inline">element</code> and returns the rendered result.</p>
<p>The <code class="inline">element</code> is created with <a href="#element/3"><code class="inline">element/3</code></a> and must point to a single element on the page with a <code class="inline">phx-submit</code> attribute in it. The event name given set on <code class="inline">phx-submit</code> is then sent to the appropriate LiveView (or component if <code class="inline">phx-target</code> is set accordingly). All <code class="inline">phx-value-*</code> entries in the element are sent as values. Extra values, including hidden input fields, can be given with the <code class="inline">value</code> argument.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_submit/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")

assert view
       |&gt; element("form")
       |&gt; render_submit(%{deg: 123, avatar: upload}) =~ "123 exceeds limits"</pre>
<p>To submit a form along with some with hidden input values:</p>
<pre data-language="elixir">assert view
      |&gt; form("#term", user: %{name: "hello"})
      |&gt; render_submit(%{user: %{"hidden_field" =&gt; "example"}}) =~ "Name updated"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_submit/3">render_submit(view, event, value)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L515" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a form submit event to the view and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_submit/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert render_submit(view, :refresh, %{deg: 32}) =~ "The temp is: 32℉"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_upload/3">render_upload(upload, entry_name, percent \\ 100)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.15.7/lib/phoenix_live_view/test/live_view_test.ex#L1408" class="source">Source</a>
</h3> <section class="docstring"> <p>Performs an upload of a file input and renders the result.</p>
<p>See <a href="#file_input/4"><code class="inline">file_input/4</code></a> for details on building a file input.</p>
<h4 id="render_upload/3-examples" class="section-heading">  Examples </h4> <p>Given the following LiveView template:</p>
<pre data-language="elixir">&lt;%= for entry &lt;- @uploads.avatar.entries %&gt;
    &lt;%=entry.name %&gt;: &lt;%= entry.progress %&gt;%
&lt;% end %&gt;</pre>
<p>Your test case can assert the uploaded content:</p>
<pre data-language="elixir">avatar = file_input(lv, "#my-form-id", :avatar, [
  %{
    last_modified: 1_594_171_879_000,
    name: "myfile.jpeg",
    content: File.read!("myfile.jpg"),
    size: 1_396_009,
    type: "image/jpeg"
  }
])

assert render_upload(avatar, "foo.jpeg") =~ "100%"</pre>
<p>By default, the entire file is chunked to the server, but an optional percentage to chunk can be passed to test chunk-by-chunk uploads:</p>
<pre data-language="elixir">assert render_upload(avatar, "foo.jpeg", 49) =~ "49%"
assert render_upload(avatar, "foo.jpeg", 51) =~ "100%"</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveViewTest.html" class="_attribution-link" target="_blank">https://hexdocs.pm/phoenix_live_view/Phoenix.LiveViewTest.html</a>
  </p>
</div>
