<h1> <small class="visible-xs">Plug v1.7.1</small> Plug.Conn  </h1> <section id="moduledoc"> <p>The Plug connection.</p> <p>This module defines a <a href="plug.conn#content"><code class="inline">Plug.Conn</code></a> struct and the main functions for working with Plug connections.</p> <p>Note request headers are normalized to lowercase and response headers are expected to have lowercase keys.</p> <h2 id="module-request-fields" class="section-heading">  Request fields </h2> <p>These fields contain request information:</p> <ul> <li>
<code class="inline">host</code> - the requested host as a binary, example: <code class="inline">"www.example.com"</code> </li> <li>
<code class="inline">method</code> - the request method as a binary, example: <code class="inline">"GET"</code> </li> <li>
<code class="inline">path_info</code> - the path split into segments, example: <code class="inline">["hello", "world"]</code> </li> <li>
<code class="inline">script_name</code> - the initial portion of the URL’s path that corresponds to the application routing, as segments, example: <code class="inline">["sub","app"]</code> </li> <li>
<code class="inline">request_path</code> - the requested path, example: <code class="inline">/trailing/and//double//slashes/</code> </li> <li>
<code class="inline">port</code> - the requested port as an integer, example: <code class="inline">80</code> </li> <li>
<code class="inline">remote_ip</code> - the IP of the client, example: <code class="inline">{151, 236, 219, 228}</code>. This field is meant to be overwritten by plugs that understand e.g. the <code class="inline">X-Forwarded-For</code> header or HAProxy’s PROXY protocol. It defaults to peer’s IP </li> <li>
<code class="inline">req_headers</code> - the request headers as a list, example: <code class="inline">[{"content-type", "text/plain"}]</code>. Note all headers will be downcased </li> <li>
<code class="inline">scheme</code> - the request scheme as an atom, example: <code class="inline">:http</code> </li> <li>
<code class="inline">query_string</code> - the request query string as a binary, example: <code class="inline">"foo=bar"</code> </li> </ul> <h2 id="module-fetchable-fields" class="section-heading">  Fetchable fields </h2> <p>The request information in these fields is not populated until it is fetched using the associated <code class="inline">fetch_</code> function. For example, the <code class="inline">cookies</code> field uses <a href="#fetch_cookies/2"><code class="inline">fetch_cookies/2</code></a>.</p> <p>If you access these fields before fetching them, they will be returned as <a href="plug.conn.unfetched"><code class="inline">Plug.Conn.Unfetched</code></a> structs.</p> <ul> <li>
<code class="inline">cookies</code>- the request cookies with the response cookies </li> <li>
<code class="inline">body_params</code> - the request body params, populated through a <a href="plug.parsers"><code class="inline">Plug.Parsers</code></a> parser. </li> <li>
<code class="inline">query_params</code> - the request query params, populated through <a href="#fetch_query_params/2"><code class="inline">fetch_query_params/2</code></a> </li> <li>
<code class="inline">path_params</code> - the request path params, populated by routers such as <a href="plug.router"><code class="inline">Plug.Router</code></a> </li> <li>
<code class="inline">params</code> - the request params, the result of merging the <code class="inline">:body_params</code> and <code class="inline">:query_params</code> with <code class="inline">:path_params</code> </li> <li>
<code class="inline">req_cookies</code> - the request cookies (without the response ones) </li> </ul> <h2 id="module-response-fields" class="section-heading">  Response fields </h2> <p>These fields contain response information:</p> <ul> <li>
<code class="inline">resp_body</code> - the response body, by default is an empty string. It is set to nil after the response is sent, except for test connections. </li> <li>
<code class="inline">resp_charset</code> - the response charset, defaults to “utf-8” </li> <li>
<code class="inline">resp_cookies</code> - the response cookies with their name and options </li> <li>
<code class="inline">resp_headers</code> - the response headers as a list of tuples, by default <code class="inline">cache-control</code> is set to <code class="inline">"max-age=0, private, must-revalidate"</code>. Note, response headers are expected to have lowercase keys. </li> <li>
<code class="inline">status</code> - the response status </li> </ul> <p>Furthermore, the <code class="inline">before_send</code> field stores callbacks that are invoked before the connection is sent. Callbacks are invoked in the reverse order they are registered (callbacks registered first are invoked last) in order to reproduce a pipeline ordering.</p> <h2 id="module-connection-fields" class="section-heading">  Connection fields </h2> <ul> <li>
<code class="inline">assigns</code> - shared user data as a map </li> <li>
<code class="inline">owner</code> - the Elixir process that owns the connection </li> <li>
<code class="inline">halted</code> - the boolean status on whether the pipeline was halted </li> <li>
<code class="inline">secret_key_base</code> - a secret key used to verify and encrypt cookies. the field must be set manually whenever one of those features are used. This data must be kept in the connection and never used directly, always use <a href="https://hexdocs.pm/plug_crypto/1.0.0/Plug.Crypto.KeyGenerator.html#generate/3"><code class="inline">Plug.Crypto.KeyGenerator.generate/3</code></a> to derive keys from it </li> <li>
<code class="inline">state</code> - the connection state </li> </ul> <p>The connection state is used to track the connection lifecycle. It starts as <code class="inline">:unset</code> but is changed to <code class="inline">:set</code> (via <a href="#resp/3"><code class="inline">resp/3</code></a>) or <code class="inline">:set_chunked</code> (used only for <code class="inline">before_send</code> callbacks by <a href="#send_chunked/2"><code class="inline">send_chunked/2</code></a>) or <code class="inline">:file</code> (when invoked via <a href="#send_file/3"><code class="inline">send_file/3</code></a>). Its final result is <code class="inline">:sent</code>, <code class="inline">:file</code> or <code class="inline">:chunked</code> depending on the response model.</p> <h2 id="module-private-fields" class="section-heading">  Private fields </h2> <p>These fields are reserved for libraries/framework usage.</p> <ul> <li>
<code class="inline">adapter</code> - holds the adapter information in a tuple </li> <li>
<code class="inline">private</code> - shared library data as a map </li> </ul> <h2 id="module-custom-status-codes" class="section-heading">  Custom status codes </h2> <p>Plug allows status codes to be overridden or added in order to allow new codes not directly specified by Plug or its adapters. Adding or overriding a status code is done through the Mix configuration of the <code class="inline">:plug</code> application. For example, to override the existing 404 reason phrase for the 404 status code (“Not Found” by default) and add a new 998 status code, the following config can be specified:</p> <pre data-language="elixir">config :plug, :statuses, %{
  404 =&gt; "Actually This Was Found",
  998 =&gt; "Not An RFC Status Code"
}</pre> <p>As this configuration is Plug specific, Plug will need to be recompiled for the changes to take place: this will not happen automatically as dependencies are not automatically recompiled when their configuration changes. To recompile Plug:</p> <pre data-language="elixir">mix deps.clean --build plug</pre> <p>The atoms that can be used in place of the status code in many functions are inflected from the reason phrase of the status code. With the above configuration, the following will all work:</p> <pre data-language="elixir">put_status(conn, :not_found)                     # 404
put_status(conn, :actually_this_was_found)       # 404
put_status(conn, :not_an_rfc_status_code)        # 998</pre> <p>Even though 404 has been overridden, the <code class="inline">:not_found</code> atom can still be used to set the status to 404 as well as the new atom <code class="inline">:actually_this_was_found</code> inflected from the reason phrase “Actually This Was Found”.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:adapter/0">adapter()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:assigns/0">assigns()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:before_send/0">before_send()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:body/0">body()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:cookies/0">cookies()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:halted/0">halted()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:headers/0">headers()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:host/0">host()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:int_status/0">int_status()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:method/0">method()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:owner/0">owner()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:param/0">param()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:params/0">params()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:port_number/0">port_number()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:query_string/0">query_string()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:resp_cookies/0">resp_cookies()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:scheme/0">scheme()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:secret_key_base/0">secret_key_base()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:segments/0">segments()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:state/0">state()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:status/0">status()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#assign/3">assign(conn, key, value)</a> </dt> <dd class="summary-synopsis">
<p>Assigns a value to a key in the connection</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#chunk/2">chunk(conn, chunk)</a> </dt> <dd class="summary-synopsis">
<p>Sends a chunk as part of a chunked response</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#clear_session/1">clear_session(conn)</a> </dt> <dd class="summary-synopsis">
<p>Clears the entire session</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#configure_session/2">configure_session(conn, opts)</a> </dt> <dd class="summary-synopsis">
<p>Configures the session</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete_req_header/2">delete_req_header(conn, key)</a> </dt> <dd class="summary-synopsis">
<p>Deletes a request header if present</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete_resp_cookie/3">delete_resp_cookie(conn, key, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Deletes a response cookie</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete_resp_header/2">delete_resp_header(conn, key)</a> </dt> <dd class="summary-synopsis">
<p>Deletes a response header if present</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete_session/2">delete_session(conn, key)</a> </dt> <dd class="summary-synopsis">
<p>Deletes the session for the given <code class="inline">key</code></p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#fetch_cookies/2">fetch_cookies(conn, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Fetches cookies from the request headers</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#fetch_query_params/2">fetch_query_params(conn, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Fetches query parameters from the query string</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#fetch_session/2">fetch_session(conn, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Fetches the session from the session store. Will also fetch cookies</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_http_protocol/1">get_http_protocol(conn)</a> </dt> <dd class="summary-synopsis">
<p>Returns the HTTP protocol and version</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_peer_data/1">get_peer_data(conn)</a> </dt> <dd class="summary-synopsis">
<p>Returns the request peer data if one is present</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_req_header/2">get_req_header(conn, key)</a> </dt> <dd class="summary-synopsis">
<p>Returns the values of the request header specified by <code class="inline">key</code></p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_resp_header/2">get_resp_header(conn, key)</a> </dt> <dd class="summary-synopsis">
<p>Returns the values of the response header specified by <code class="inline">key</code></p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_session/2">get_session(conn, key)</a> </dt> <dd class="summary-synopsis">
<p>Returns session value for the given <code class="inline">key</code>. If <code class="inline">key</code> is not set, <code class="inline">nil</code> is returned</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#halt/1">halt(conn)</a> </dt> <dd class="summary-synopsis">
<p>Halts the Plug pipeline by preventing further plugs downstream from being invoked. See the docs for <a href="plug.builder"><code class="inline">Plug.Builder</code></a> for more information on halting a Plug pipeline</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#inform!/3">inform!(conn, status, headers \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Sends an information response to a client but raises if the adapter does not support inform</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#inform/3">inform(conn, status, headers \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Sends and informational response to the client</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#merge_assigns/2">merge_assigns(conn, keyword)</a> </dt> <dd class="summary-synopsis">
<p>Assigns multiple values to keys in the connection</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#merge_private/2">merge_private(conn, keyword)</a> </dt> <dd class="summary-synopsis">
<p>Assigns multiple <strong>private</strong> keys and values in the connection</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#merge_resp_headers/2">merge_resp_headers(conn, headers)</a> </dt> <dd class="summary-synopsis">
<p>Merges a series of response headers into the connection</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#prepend_resp_headers/2">prepend_resp_headers(conn, headers)</a> </dt> <dd class="summary-synopsis">
<p>Prepends the list of headers to the connection response headers</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#push!/3">push!(conn, path, headers \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Pushes a resource to the client but raises if the adapter does not support server push</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#push/3">push(conn, path, headers \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Pushes a resource to the client</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_private/3">put_private(conn, key, value)</a> </dt> <dd class="summary-synopsis">
<p>Assigns a new <strong>private</strong> key and value in the connection</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_req_header/3">put_req_header(conn, key, value)</a> </dt> <dd class="summary-synopsis">
<p>Adds a new request header (<code class="inline">key</code>) if not present, otherwise replaces the previous value of that header with <code class="inline">value</code></p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_resp_content_type/3">put_resp_content_type(conn, content_type, charset \\ "utf-8")</a> </dt> <dd class="summary-synopsis">
<p>Sets the value of the <code class="inline">"content-type"</code> response header taking into account the <code class="inline">charset</code></p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_resp_cookie/4">put_resp_cookie(conn, key, value, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Puts a response cookie in the connection</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_resp_header/3">put_resp_header(conn, key, value)</a> </dt> <dd class="summary-synopsis">
<p>Adds a new response header (<code class="inline">key</code>) if not present, otherwise replaces the previous value of that header with <code class="inline">value</code></p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_session/3">put_session(conn, key, value)</a> </dt> <dd class="summary-synopsis">
<p>Puts the specified <code class="inline">value</code> in the session for the given <code class="inline">key</code></p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_status/2">put_status(conn, status)</a> </dt> <dd class="summary-synopsis">
<p>Stores the given status code in the connection</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#read_body/2">read_body(conn, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Reads the request body</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#read_part_body/2">read_part_body(conn, opts)</a> </dt> <dd class="summary-synopsis">
<p>Reads the body of a multipart request</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#read_part_headers/2">read_part_headers(conn, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Reads the headers of a multipart request</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#register_before_send/2">register_before_send(conn, callback)</a> </dt> <dd class="summary-synopsis">
<p>Registers a callback to be invoked before the response is sent</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#request_url/1">request_url(conn)</a> </dt> <dd class="summary-synopsis">
<p>Returns the full request URL</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#resp/3">resp(conn, status, body)</a> </dt> <dd class="summary-synopsis">
<p>Sets the response to the given <code class="inline">status</code> and <code class="inline">body</code></p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#send_chunked/2">send_chunked(conn, status)</a> </dt> <dd class="summary-synopsis">
<p>Sends the response headers as a chunked response</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#send_file/5">send_file(conn, status, file, offset \\ 0, length \\ :all)</a> </dt> <dd class="summary-synopsis">
<p>Sends a file as the response body with the given <code class="inline">status</code> and optionally starting at the given offset until the given length</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#send_resp/1">send_resp(conn)</a> </dt> <dd class="summary-synopsis">
<p>Sends a response to the client</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#send_resp/3">send_resp(conn, status, body)</a> </dt> <dd class="summary-synopsis">
<p>Sends a response with the given status and body</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#update_req_header/4">update_req_header(conn, key, initial, fun)</a> </dt> <dd class="summary-synopsis">
<p>Updates a request header if present, otherwise it sets it to an initial value</p> </dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#update_resp_header/4">update_resp_header(conn, key, initial, fun)</a> </dt> <dd class="summary-synopsis">
<p>Updates a response header if present, otherwise it sets it to an initial value</p> </dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <div class="detail" id="t:adapter/0"> <div class="detail-header"> <a href="#t:adapter/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">adapter()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L125" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">adapter() :: {module(), term()}</pre> </div> </div>  </div> <div class="detail" id="t:assigns/0"> <div class="detail-header"> <a href="#t:assigns/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">assigns()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L126" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">assigns() :: %{optional(atom()) =&gt; any()}</pre> </div> </div>  </div> <div class="detail" id="t:before_send/0"> <div class="detail-header"> <a href="#t:before_send/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">before_send()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L127" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">before_send() :: [(t() -&gt; t())]</pre> </div> </div>  </div> <div class="detail" id="t:body/0"> <div class="detail-header"> <a href="#t:body/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">body()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L128" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">body() :: iodata()</pre> </div> </div>  </div> <div class="detail" id="t:cookies/0"> <div class="detail-header"> <a href="#t:cookies/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">cookies()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L129" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">cookies() :: %{optional(binary()) =&gt; binary()}</pre> </div> </div>  </div> <div class="detail" id="t:halted/0"> <div class="detail-header"> <a href="#t:halted/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">halted()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L130" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">halted() :: boolean()</pre> </div> </div>  </div> <div class="detail" id="t:headers/0"> <div class="detail-header"> <a href="#t:headers/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">headers()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L131" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">headers() :: [{binary(), binary()}]</pre> </div> </div>  </div> <div class="detail" id="t:host/0"> <div class="detail-header"> <a href="#t:host/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">host()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L132" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">host() :: binary()</pre> </div> </div>  </div> <div class="detail" id="t:int_status/0"> <div class="detail-header"> <a href="#t:int_status/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">int_status()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L133" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">int_status() :: non_neg_integer() | nil</pre> </div> </div>  </div> <div class="detail" id="t:method/0"> <div class="detail-header"> <a href="#t:method/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">method()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L135" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">method() :: binary()</pre> </div> </div>  </div> <div class="detail" id="t:owner/0"> <div class="detail-header"> <a href="#t:owner/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">owner()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L134" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">owner() :: pid()</pre> </div> </div>  </div> <div class="detail" id="t:param/0"> <div class="detail-header"> <a href="#t:param/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">param()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L136" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">param() :: binary() | %{optional(binary()) =&gt; param()} | [param()]</pre> </div> </div>  </div> <div class="detail" id="t:params/0"> <div class="detail-header"> <a href="#t:params/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">params()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L137" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">params() :: %{optional(binary()) =&gt; param()}</pre> </div> </div>  </div> <div class="detail" id="t:port_number/0"> <div class="detail-header"> <a href="#t:port_number/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">port_number()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L138" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">port_number() :: :inet.port_number()</pre> </div> </div>  </div> <div class="detail" id="t:query_string/0"> <div class="detail-header"> <a href="#t:query_string/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">query_string()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L139" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">query_string() :: String.t()</pre> </div> </div>  </div> <div class="detail" id="t:resp_cookies/0"> <div class="detail-header"> <a href="#t:resp_cookies/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">resp_cookies()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L140" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">resp_cookies() :: %{optional(binary()) =&gt; %{}}</pre> </div> </div>  </div> <div class="detail" id="t:scheme/0"> <div class="detail-header"> <a href="#t:scheme/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">scheme()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L141" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">scheme() :: :http | :https</pre> </div> </div>  </div> <div class="detail" id="t:secret_key_base/0"> <div class="detail-header"> <a href="#t:secret_key_base/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">secret_key_base()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L142" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">secret_key_base() :: binary() | nil</pre> </div> </div>  </div> <div class="detail" id="t:segments/0"> <div class="detail-header"> <a href="#t:segments/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">segments()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L143" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">segments() :: [binary()]</pre> </div> </div>  </div> <div class="detail" id="t:state/0"> <div class="detail-header"> <a href="#t:state/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">state()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L144" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">state() :: :unset | :set | :set_chunked | :set_file | :file | :chunked | :sent</pre> </div> </div>  </div> <div class="detail" id="t:status/0"> <div class="detail-header"> <a href="#t:status/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">status()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L145" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">status() :: atom() | int_status()</pre> </div> </div>  </div> <div class="detail" id="t:t/0"> <div class="detail-header"> <a href="#t:t/0" class="detail-link" title="Link to this type">  <span class="sr-only">Link to this type</span> </a> <span class="signature">t()</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L147" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">t() :: %Plug.Conn{
  adapter: adapter(),
  assigns: assigns(),
  before_send: before_send(),
  body_params: params() | Plug.Conn.Unfetched.t(),
  cookies: cookies() | Plug.Conn.Unfetched.t(),
  halted: term(),
  host: host(),
  method: method(),
  owner: owner(),
  params: params() | Plug.Conn.Unfetched.t(),
  path_info: segments(),
  path_params: params(),
  port: :inet.port_number(),
  private: assigns(),
  query_params: params() | Plug.Conn.Unfetched.t(),
  query_string: query_string(),
  remote_ip: :inet.ip_address(),
  req_cookies: cookies() | Plug.Conn.Unfetched.t(),
  req_headers: headers(),
  request_path: binary(),
  resp_body: body() | nil,
  resp_cookies: resp_cookies(),
  resp_headers: headers(),
  scheme: scheme(),
  script_name: segments(),
  secret_key_base: secret_key_base(),
  state: state(),
  status: int_status()
}</pre> </div> </div>  </div> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="detail" id="assign/3"> <div class="detail-header"> <a href="#assign/3" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">assign(conn, key, value)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L273" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">assign(t(), atom(), term()) :: t()</pre> </div> </div> <section class="docstring"> <p>Assigns a value to a key in the connection.</p> <p>The “assigns” storage is meant to be used to store values in the connection so that other plugs in your plug pipeline can access them. The assigns storage is a map.</p> <h2 id="assign/3-examples" class="section-heading">  Examples </h2> <pre data-language="elixir">iex&gt; conn.assigns[:hello]
nil
iex&gt; conn = assign(conn, :hello, :world)
iex&gt; conn.assigns[:hello]
:world</pre> </section> </div> <div class="detail" id="chunk/2"> <div class="detail-header"> <a href="#chunk/2" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">chunk(conn, chunk)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L527" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">chunk(t(), body()) :: {:ok, t()} | {:error, term()} | no_return()</pre> </div> </div> <section class="docstring"> <p>Sends a chunk as part of a chunked response.</p> <p>It expects a connection with state <code class="inline">:chunked</code> as set by <a href="#send_chunked/2"><code class="inline">send_chunked/2</code></a>. It returns <code class="inline">{:ok, conn}</code> in case of success, otherwise <code class="inline">{:error, reason}</code>.</p> <p>To stream data use <a href="https://hexdocs.pm/elixir/Enum.html#reduce_while/3"><code class="inline">Enum.reduce_while/3</code></a> instead of <a href="https://hexdocs.pm/elixir/Enum.html#into/2"><code class="inline">Enum.into/2</code></a>. <a href="https://hexdocs.pm/elixir/Enum.html#reduce_while/3"><code class="inline">Enum.reduce_while/3</code></a> allows aborting the execution if <a href="#chunk/2"><code class="inline">chunk/2</code></a> fails to deliver the chunk of data.</p> <h2 id="chunk/2-example" class="section-heading">  Example </h2> <pre data-language="elixir">Enum.reduce_while(~w(each chunk as a word), conn, fn (chunk, conn) -&gt;
  case Plug.Conn.chunk(conn, chunk) do
    {:ok, conn} -&gt;
      {:cont, conn}
    {:error, :closed} -&gt;
      {:halt, conn}
  end
end)</pre> </section> </div> <div class="detail" id="clear_session/1"> <div class="detail-header"> <a href="#clear_session/1" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">clear_session(conn)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L1437" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">clear_session(t()) :: t()</pre> </div> </div> <section class="docstring"> <p>Clears the entire session.</p> <p>This function removes every key from the session, clearing the session.</p> <p>Note that, even if <a href="#clear_session/1"><code class="inline">clear_session/1</code></a> is used, the session is still sent to the client. If the session should be effectively <em>dropped</em>, <a href="#configure_session/2"><code class="inline">configure_session/2</code></a> should be used with the <code class="inline">:drop</code> option set to <code class="inline">true</code>.</p> </section> </div> <div class="detail" id="configure_session/2"> <div class="detail-header"> <a href="#configure_session/2" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">configure_session(conn, opts)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L1458" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">configure_session(t(), Keyword.t()) :: t()</pre> </div> </div> <section class="docstring"> <p>Configures the session.</p> <h2 id="configure_session/2-options" class="section-heading">  Options </h2> <ul> <li>
<code class="inline">:renew</code> - generates a new session id for the cookie </li> <li>
<code class="inline">:drop</code> - drops the session, a session cookie will not be included in the response </li> <li>
<code class="inline">:ignore</code> - ignores all changes made to the session in this request cycle </li> </ul> </section> </div> <div class="detail" id="delete_req_header/2"> <div class="detail-header"> <a href="#delete_req_header/2" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">delete_req_header(conn, key)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L679" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">delete_req_header(t(), binary()) :: t()</pre> </div> </div> <section class="docstring"> <p>Deletes a request header if present.</p> <p>Raises a <a href="plug.conn.alreadysenterror"><code class="inline">Plug.Conn.AlreadySentError</code></a> if the connection has already been <code class="inline">:sent</code> or <code class="inline">:chunked</code>.</p> <h2 id="delete_req_header/2-examples" class="section-heading">  Examples </h2> <pre data-language="elixir">Plug.Conn.delete_req_header(conn, "content-type")</pre> </section> </div> <div class="detail" id="delete_resp_cookie/3">  <div class="detail-header"> <a href="#delete_resp_cookie/3" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">delete_resp_cookie(conn, key, opts \\ [])</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L1365" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">delete_resp_cookie(t(), binary(), Keyword.t()) :: t()</pre> </div> </div> <section class="docstring"> <p>Deletes a response cookie.</p> <p>Deleting a cookie requires the same options as to when the cookie was put. Check <a href="#put_resp_cookie/4"><code class="inline">put_resp_cookie/4</code></a> for more information.</p> </section> </div> <div class="detail" id="delete_resp_header/2"> <div class="detail-header"> <a href="#delete_resp_header/2" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">delete_resp_header(conn, key)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L872" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">delete_resp_header(t(), binary()) :: t()</pre> </div> </div> <section class="docstring"> <p>Deletes a response header if present.</p> <p>Raises a <a href="plug.conn.alreadysenterror"><code class="inline">Plug.Conn.AlreadySentError</code></a> if the connection has already been <code class="inline">:sent</code> or <code class="inline">:chunked</code>.</p> <h2 id="delete_resp_header/2-examples" class="section-heading">  Examples </h2> <pre data-language="elixir">Plug.Conn.delete_resp_header(conn, "content-type")</pre> </section> </div> <div class="detail" id="delete_session/2"> <div class="detail-header"> <a href="#delete_session/2" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">delete_session(conn, key)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L1423" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">delete_session(t(), String.t() | atom()) :: t()</pre> </div> </div> <section class="docstring"> <p>Deletes the session for the given <code class="inline">key</code>.</p> <p>The key can be a string or an atom, where atoms are automatically converted to strings.</p> </section> </div> <div class="detail" id="fetch_cookies/2">  <div class="detail-header"> <a href="#fetch_cookies/2" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">fetch_cookies(conn, opts \\ [])</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L1317" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">fetch_cookies(t(), Keyword.t()) :: t()</pre> </div> </div> <section class="docstring"> <p>Fetches cookies from the request headers.</p> </section> </div> <div class="detail" id="fetch_query_params/2">  <div class="detail-header"> <a href="#fetch_query_params/2" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">fetch_query_params(conn, opts \\ [])</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L976" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">fetch_query_params(t(), Keyword.t()) :: t()</pre> </div> </div> <section class="docstring"> <p>Fetches query parameters from the query string.</p> <p>Params are decoded as <code class="inline">"x-www-form-urlencoded"</code> in which key/value pairs are separated by <code class="inline">&amp;</code> and keys are separated from values by <code class="inline">=</code>.</p> <p>This function does not fetch parameters from the body. To fetch parameters from the body, use the <a href="plug.parsers"><code class="inline">Plug.Parsers</code></a> plug.</p> <h2 id="fetch_query_params/2-options" class="section-heading">  Options </h2> <ul> <li>
<code class="inline">:length</code> - the maximum query string length. Defaults to <code class="inline">1_000_000</code> bytes. </li> </ul> </section> </div> <div class="detail" id="fetch_session/2">  <div class="detail-header"> <a href="#fetch_session/2" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">fetch_session(conn, opts \\ [])</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L1378" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">fetch_session(t(), Keyword.t()) :: t()</pre> </div> </div> <section class="docstring"> <p>Fetches the session from the session store. Will also fetch cookies.</p> </section> </div> <div class="detail" id="get_http_protocol/1"> <div class="detail-header"> <a href="#get_http_protocol/1" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">get_http_protocol(conn)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L609" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">get_http_protocol(t()) :: Plug.Conn.Adapter.http_protocol()</pre> </div> </div> <section class="docstring"> <p>Returns the HTTP protocol and version.</p> <h2 id="get_http_protocol/1-examples" class="section-heading">  Examples </h2> <pre data-language="elixir">iex&gt; get_http_protocol(conn)
:"HTTP/1.1"</pre> </section> </div> <div class="detail" id="get_peer_data/1"> <div class="detail-header"> <a href="#get_peer_data/1" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">get_peer_data(conn)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L595" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">get_peer_data(t()) :: Plug.Conn.Adapter.peer_data()</pre> </div> </div> <section class="docstring"> <p>Returns the request peer data if one is present.</p> </section> </div> <div class="detail" id="get_req_header/2"> <div class="detail-header"> <a href="#get_req_header/2" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">get_req_header(conn, key)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L623" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">get_req_header(t(), binary()) :: [binary()]</pre> </div> </div> <section class="docstring"> <p>Returns the values of the request header specified by <code class="inline">key</code>.</p> <h2 id="get_req_header/2-examples" class="section-heading">  Examples </h2> <pre data-language="elixir">iex&gt; get_req_header(conn, "accept")
["application/json"]</pre> </section> </div> <div class="detail" id="get_resp_header/2"> <div class="detail-header"> <a href="#get_resp_header/2" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">get_resp_header(conn, key)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L733" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">get_resp_header(t(), binary()) :: [binary()]</pre> </div> </div> <section class="docstring"> <p>Returns the values of the response header specified by <code class="inline">key</code>.</p> <h2 id="get_resp_header/2-examples" class="section-heading">  Examples </h2> <pre data-language="elixir">iex&gt; conn = %{conn | resp_headers: [{"content-type", "text/plain"}]}
iex&gt; get_resp_header(conn, "content-type")
["text/plain"]</pre> </section> </div> <div class="detail" id="get_session/2"> <div class="detail-header"> <a href="#get_session/2" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">get_session(conn, key)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L1409" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">get_session(t(), String.t() | atom()) :: any()</pre> </div> </div> <section class="docstring"> <p>Returns session value for the given <code class="inline">key</code>. If <code class="inline">key</code> is not set, <code class="inline">nil</code> is returned.</p> <p>The key can be a string or an atom, where atoms are automatically converted to strings.</p> </section> </div> <div class="detail" id="halt/1"> <div class="detail-header"> <a href="#halt/1" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">halt(conn)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L1507" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">halt(t()) :: t()</pre> </div> </div> <section class="docstring"> <p>Halts the Plug pipeline by preventing further plugs downstream from being invoked. See the docs for <a href="plug.builder"><code class="inline">Plug.Builder</code></a> for more information on halting a Plug pipeline.</p> </section> </div> <div class="detail" id="inform!/3">  <div class="detail-header"> <a href="#inform!/3" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">inform!(conn, status, headers \\ [])</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L1212" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">inform!(t(), status(), Keyword.t()) :: t()</pre> </div> </div> <section class="docstring"> <p>Sends an information response to a client but raises if the adapter does not support inform.</p> <p>See <code class="inline">inform/1</code> for more information.</p> </section> </div> <div class="detail" id="inform/3">  <div class="detail-header"> <a href="#inform/3" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">inform(conn, status, headers \\ [])</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L1200" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">inform(t(), status(), Keyword.t()) :: t()</pre> </div> </div> <section class="docstring"> <p>Sends and informational response to the client.</p> <p>An informational response, such as an early hint, must happen prior to a response being sent. If an informational request is attempted after a response is sent then a <a href="plug.conn.alreadysenterror"><code class="inline">Plug.Conn.AlreadySentError</code></a> will be raised. Only status codes from 100-199 are valid.</p> <p>To use inform for early hints send one or more informs with a status of 103.</p> <p>If the adapter does not support informational responses then this is a noop.</p> <p>Most HTTP/1.1 clients do not properly support informational responses but some proxies require it to support server push for HTTP/2. You can call <a href="#get_http_protocol/1"><code class="inline">get_http_protocol/1</code></a> to retrieve the protocol and version.</p> </section> </div> <div class="detail" id="merge_assigns/2"> <div class="detail-header"> <a href="#merge_assigns/2" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">merge_assigns(conn, keyword)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L292" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">merge_assigns(t(), Keyword.t()) :: t()</pre> </div> </div> <section class="docstring"> <p>Assigns multiple values to keys in the connection.</p> <p>Equivalent to multiple calls to <a href="#assign/3"><code class="inline">assign/3</code></a>.</p> <h2 id="merge_assigns/2-examples" class="section-heading">  Examples </h2> <pre data-language="elixir">iex&gt; conn.assigns[:hello]
nil
iex&gt; conn = merge_assigns(conn, hello: :world)
iex&gt; conn.assigns[:hello]
:world</pre> </section> </div> <div class="detail" id="merge_private/2"> <div class="detail-header"> <a href="#merge_private/2" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">merge_private(conn, keyword)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L351" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">merge_private(t(), Keyword.t()) :: t()</pre> </div> </div> <section class="docstring"> <p>Assigns multiple <strong>private</strong> keys and values in the connection.</p> <p>Equivalent to multiple <a href="#put_private/3"><code class="inline">put_private/3</code></a> calls.</p> <h2 id="merge_private/2-examples" class="section-heading">  Examples </h2> <pre data-language="elixir">iex&gt; conn.private[:my_plug_hello]
nil
iex&gt; conn = merge_private(conn, my_plug_hello: :world)
iex&gt; conn.private[:my_plug_hello]
:world</pre> </section> </div> <div class="detail" id="merge_resp_headers/2"> <div class="detail-header"> <a href="#merge_resp_headers/2" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">merge_resp_headers(conn, headers)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L840" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">merge_resp_headers(t(), Enum.t()) :: t()</pre> </div> </div> <section class="docstring"> <p>Merges a series of response headers into the connection.</p> <h2 id="merge_resp_headers/2-example" class="section-heading">  Example </h2> <pre data-language="elixir">Plug.Conn.merge_resp_headers(conn, [{"content-type", "text/plain"}, {"X-1337", "5P34K"}])</pre> </section> </div> <div class="detail" id="prepend_resp_headers/2"> <div class="detail-header"> <a href="#prepend_resp_headers/2" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">prepend_resp_headers(conn, headers)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L807" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">prepend_resp_headers(t(), headers()) :: t()</pre> </div> </div> <section class="docstring"> <p>Prepends the list of headers to the connection response headers.</p> <p>Similar to <code class="inline">put_resp_header</code> this functions adds a new response header (<code class="inline">key</code>) but rather then replacing the existing one it prepends another header with the same <code class="inline">key</code>.</p> <p>It is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. As a convenience, when using the <code class="inline">Plug.Adapters.Conn.Test</code> adapter, any headers that aren’t lowercase will raise a <a href="plug.conn.invalidheadererror"><code class="inline">Plug.Conn.InvalidHeaderError</code></a>.</p> <p>Raises a <a href="plug.conn.alreadysenterror"><code class="inline">Plug.Conn.AlreadySentError</code></a> if the connection has already been <code class="inline">:sent</code> or <code class="inline">:chunked</code>.</p> <p>Raises a <a href="plug.conn.invalidheadererror"><code class="inline">Plug.Conn.InvalidHeaderError</code></a> if the header value contains control feed (<code class="inline">\r</code>) or newline (<code class="inline">\n</code>) characters.</p> <h2 id="prepend_resp_headers/2-examples" class="section-heading">  Examples </h2> <pre data-language="elixir">Plug.Conn.prepend_resp_headers(conn, "content-type", "application/json")</pre> </section> </div> <div class="detail" id="push!/3">  <div class="detail-header"> <a href="#push!/3" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">push!(conn, path, headers \\ [])</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L1263" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">push!(t(), String.t(), Keyword.t()) :: t()</pre> </div> </div> <section class="docstring"> <p>Pushes a resource to the client but raises if the adapter does not support server push.</p> </section> </div> <div class="detail" id="push/3">  <div class="detail-header"> <a href="#push/3" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">push(conn, path, headers \\ [])</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L1253" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">push(t(), String.t(), Keyword.t()) :: t()</pre> </div> </div> <section class="docstring"> <p>Pushes a resource to the client.</p> <p>Server pushes must happen prior to a response being sent. If a server push is attempted after a response is sent then a <a href="plug.conn.alreadysenterror"><code class="inline">Plug.Conn.AlreadySentError</code></a> will be raised.</p> <p>If the adapter does not support server push then this is a noop.</p> <p>Note that certain browsers (such as Google Chrome) will not accept a pushed resource if your certificate is not trusted. In the case of Chrome this means a valid cert with a SAN. See https://www.chromestatus.com/feature/4981025180483584</p> </section> </div> <div class="detail" id="put_private/3"> <div class="detail-header"> <a href="#put_private/3" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">put_private(conn, key, value)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L332" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">put_private(t(), atom(), term()) :: t()</pre> </div> </div> <section class="docstring"> <p>Assigns a new <strong>private</strong> key and value in the connection.</p> <p>This storage is meant to be used by libraries and frameworks to avoid writing to the user storage (the <code class="inline">:assigns</code> field). It is recommended for libraries/frameworks to prefix the keys with the library name.</p> <p>For example, if a plug called <code class="inline">my_plug</code> needs to store a <code class="inline">:hello</code> key, it would store it as <code class="inline">:my_plug_hello</code>:</p> <pre data-language="elixir">iex&gt; conn.private[:my_plug_hello]
nil
iex&gt; conn = put_private(conn, :my_plug_hello, :world)
iex&gt; conn.private[:my_plug_hello]
:world</pre> </section> </div> <div class="detail" id="put_req_header/3"> <div class="detail-header"> <a href="#put_req_header/3" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">put_req_header(conn, key, value)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L651" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">put_req_header(t(), binary(), binary()) :: t()</pre> </div> </div> <section class="docstring"> <p>Adds a new request header (<code class="inline">key</code>) if not present, otherwise replaces the previous value of that header with <code class="inline">value</code>.</p> <p>It is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. As a convenience, when using the <code class="inline">Plug.Adapters.Conn.Test</code> adapter, any headers that aren’t lowercase will raise a <a href="plug.conn.invalidheadererror"><code class="inline">Plug.Conn.InvalidHeaderError</code></a>.</p> <p>Raises a <a href="plug.conn.alreadysenterror"><code class="inline">Plug.Conn.AlreadySentError</code></a> if the connection has already been <code class="inline">:sent</code> or <code class="inline">:chunked</code>.</p> <h2 id="put_req_header/3-examples" class="section-heading">  Examples </h2> <pre data-language="elixir">Plug.Conn.put_req_header(conn, "accept", "application/json")</pre> </section> </div> <div class="detail" id="put_resp_content_type/3">  <div class="detail-header"> <a href="#put_resp_content_type/3" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">put_resp_content_type(conn, content_type, charset \\ "utf-8")</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L936" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">put_resp_content_type(t(), binary(), binary() | nil) :: t()</pre> </div> </div> <section class="docstring"> <p>Sets the value of the <code class="inline">"content-type"</code> response header taking into account the <code class="inline">charset</code>.</p> <p>If <code class="inline">charset</code> is <code class="inline">nil</code>, the value of the <code class="inline">"content-type"</code> response header won’t specify a charset.</p> <h2 id="put_resp_content_type/3-examples" class="section-heading">  Examples </h2> <pre data-language="elixir">iex&gt; conn = put_resp_content_type(conn, "application/json")
iex&gt; get_resp_header(conn, "content-type")
["application/json; charset=utf-8"]</pre> </section> </div> <div class="detail" id="put_resp_cookie/4">  <div class="detail-header"> <a href="#put_resp_cookie/4" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">put_resp_cookie(conn, key, value, opts \\ [])</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L1345" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">put_resp_cookie(t(), binary(), binary(), Keyword.t()) :: t()</pre> </div> </div> <section class="docstring"> <p>Puts a response cookie in the connection.</p> <p>The cookie value is not automatically escaped. Therefore, if you want to store values with comma, quotes, and so on, you need to explicitly escape them or use a function such as <code class="inline">Base.encode64(value, padding: false)</code> when writing and <code class="inline">Base.decode64(encoded, padding: false)</code> when reading the cookie. Padding needs to be disabled since <code class="inline">=</code> is not a valid character in cookie values.</p> <h2 id="put_resp_cookie/4-options" class="section-heading">  Options </h2> <ul> <li>
<code class="inline">:domain</code> - the domain the cookie applies to </li> <li>
<code class="inline">:max_age</code> - the cookie max-age, in seconds. Providing a value for this option will set both the <em>max-age</em> and <em>expires</em> cookie attributes </li> <li>
<code class="inline">:path</code> - the path the cookie applies to </li> <li>
<code class="inline">:http_only</code> - when <code class="inline">false</code>, the cookie is accessible beyond HTTP </li> <li>
<code class="inline">:secure</code> - if the cookie must be sent only over https. Defaults to true when the connection is HTTPS </li> <li>
<code class="inline">:extra</code> - string to append to cookie. Use this to take advantage of non-standard cookie attributes. </li> </ul> </section> </div> <div class="detail" id="put_resp_header/3"> <div class="detail-header"> <a href="#put_resp_header/3" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">put_resp_header(conn, key, value)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L766" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">put_resp_header(t(), binary(), binary()) :: t()</pre> </div> </div> <section class="docstring"> <p>Adds a new response header (<code class="inline">key</code>) if not present, otherwise replaces the previous value of that header with <code class="inline">value</code>.</p> <p>It is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. As a convenience, when using the <code class="inline">Plug.Adapters.Conn.Test</code> adapter, any headers that aren’t lowercase will raise a <a href="plug.conn.invalidheadererror"><code class="inline">Plug.Conn.InvalidHeaderError</code></a>.</p> <p>Raises a <a href="plug.conn.alreadysenterror"><code class="inline">Plug.Conn.AlreadySentError</code></a> if the connection has already been <code class="inline">:sent</code> or <code class="inline">:chunked</code>.</p> <p>Raises a <a href="plug.conn.invalidheadererror"><code class="inline">Plug.Conn.InvalidHeaderError</code></a> if the header value contains control feed (<code class="inline">\r</code>) or newline (<code class="inline">\n</code>) characters.</p> <h2 id="put_resp_header/3-examples" class="section-heading">  Examples </h2> <pre data-language="elixir">Plug.Conn.put_resp_header(conn, "content-type", "application/json")</pre> </section> </div> <div class="detail" id="put_session/3"> <div class="detail-header"> <a href="#put_session/3" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">put_session(conn, key, value)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L1397" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">put_session(t(), String.t() | atom(), any()) :: t()</pre> </div> </div> <section class="docstring"> <p>Puts the specified <code class="inline">value</code> in the session for the given <code class="inline">key</code>.</p> <p>The key can be a string or an atom, where atoms are automatically converted to strings. Can only be invoked on unsent <code class="inline">conn</code>s. Will raise otherwise.</p> </section> </div> <div class="detail" id="put_status/2"> <div class="detail-header"> <a href="#put_status/2" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">put_status(conn, status)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L373" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">put_status(t(), status()) :: t()</pre> </div> </div> <section class="docstring"> <p>Stores the given status code in the connection.</p> <p>The status code can be <code class="inline">nil</code>, an integer, or an atom. The list of allowed atoms is available in <a href="plug.conn.status"><code class="inline">Plug.Conn.Status</code></a>.</p> <p>Raises a <a href="plug.conn.alreadysenterror"><code class="inline">Plug.Conn.AlreadySentError</code></a> if the connection has already been <code class="inline">:sent</code> or <code class="inline">:chunked</code>.</p> <h2 id="put_status/2-examples" class="section-heading">  Examples </h2> <pre data-language="elixir">Plug.Conn.put_status(conn, :not_found)
Plug.Conn.put_status(conn, 200)</pre> </section> </div> <div class="detail" id="read_body/2">  <div class="detail-header"> <a href="#read_body/2" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">read_body(conn, opts \\ [])</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L1027" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">read_body(t(), Keyword.t()) ::
  {:ok, binary(), t()} | {:more, binary(), t()} | {:error, term()}</pre> </div> </div> <section class="docstring"> <p>Reads the request body.</p> <p>This function reads a chunk of the request body up to a given length (specified by the <code class="inline">:length</code> option). If there is more data to be read, then <code class="inline">{:more, partial_body, conn}</code> is returned. Otherwise <code class="inline">{:ok, body, conn}</code> is returned. In case of an error reading the socket, <code class="inline">{:error, reason}</code> is returned as per <a href="http://www.erlang.org/doc/man/gen_tcp.html#recv-2"><code class="inline">:gen_tcp.recv/2</code></a>.</p> <p>Like all functions in this module, the <code class="inline">conn</code> returned by <code class="inline">read_body</code> must be passed to the next stage of your pipeline and should not be ignored.</p> <p>In order to, for instance, support slower clients you can tune the <code class="inline">:read_length</code> and <code class="inline">:read_timeout</code> options. These specify how much time should be allowed to pass for each read from the underlying socket.</p> <p>Because the request body can be of any size, reading the body will only work once, as Plug will not cache the result of these operations. If you need to access the body multiple times, it is your responsibility to store it. Finally keep in mind some plugs like <a href="plug.parsers"><code class="inline">Plug.Parsers</code></a> may read the body, so the body may be unavailable after being accessed by such plugs.</p> <p>This function is able to handle both chunked and identity transfer-encoding by default.</p> <h2 id="read_body/2-options" class="section-heading">  Options </h2> <ul> <li>
<code class="inline">:length</code> - sets the maximum number of bytes to read from the body on every call, defaults to <code class="inline">8_000_000</code> bytes </li> <li>
<code class="inline">:read_length</code> - sets the amount of bytes to read at one time from the underlying socket to fill the chunk, defaults to <code class="inline">1_000_000</code> bytes </li> <li>
<code class="inline">:read_timeout</code> - sets the timeout for each socket read, defaults to <code class="inline">15_000</code> milliseconds </li> </ul> <p>The values above are not meant to be exact. For example, setting the length to <code class="inline">8_000_000</code> may end up reading some hundred bytes more from the socket until we halt.</p> <h2 id="read_body/2-examples" class="section-heading">  Examples </h2> <pre data-language="elixir">{:ok, body, conn} = Plug.Conn.read_body(conn, length: 1_000_000)</pre> </section> </div> <div class="detail" id="read_part_body/2"> <div class="detail-header"> <a href="#read_part_body/2" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">read_part_body(conn, opts)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L1103" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">read_part_body(t(), Keyword.t()) ::
  {:ok, binary(), t()} | {:more, binary(), t()} | {:done, t()}</pre> </div> </div> <section class="docstring"> <p>Reads the body of a multipart request.</p> <p>Returns <code class="inline">{:ok, body, conn}</code> if all body has been read, <code class="inline">{:more, binary, conn}</code> otherwise, and <code class="inline">{:done, conn}</code> if there is no more body.</p> <p>It accepts the same options as <a href="#read_body/2"><code class="inline">read_body/2</code></a>.</p> </section> </div> <div class="detail" id="read_part_headers/2">  <div class="detail-header"> <a href="#read_part_headers/2" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">read_part_headers(conn, opts \\ [])</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L1062" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">read_part_headers(t(), Keyword.t()) ::
  {:ok, headers(), t()} | {:done, t()}</pre> </div> </div> <section class="docstring"> <p>Reads the headers of a multipart request.</p> <p>It returns <code class="inline">{:ok, headers, conn}</code> with the headers or <code class="inline">{:done, conn}</code> if there are no more parts.</p> <p>Once <a href="#read_part_headers/2"><code class="inline">read_part_headers/2</code></a> is invoked, you may call <a href="#read_part_body/2"><code class="inline">read_part_body/2</code></a> to read the body associated to the headers. If <a href="#read_part_headers/2"><code class="inline">read_part_headers/2</code></a> is called instead, the body is automatically skipped until the next part headers.</p> <h2 id="read_part_headers/2-options" class="section-heading">  Options </h2> <ul> <li>
<code class="inline">:length</code> - sets the maximum number of bytes to read from the body for each chunk, defaults to <code class="inline">64_000</code> bytes </li> <li>
<code class="inline">:read_length</code> - sets the amount of bytes to read at one time from the underlying socket to fill the chunk, defaults to <code class="inline">64_000</code> bytes </li> <li>
<code class="inline">:read_timeout</code> - sets the timeout for each socket read, defaults to <code class="inline">5_000</code> milliseconds </li> </ul> </section> </div> <div class="detail" id="register_before_send/2"> <div class="detail-header"> <a href="#register_before_send/2" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">register_before_send(conn, callback)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L1496" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">register_before_send(t(), (t() -&gt; t())) :: t()</pre> </div> </div> <section class="docstring"> <p>Registers a callback to be invoked before the response is sent.</p> <p>Callbacks are invoked in the reverse order they are defined (callbacks defined first are invoked last).</p> <h2 id="register_before_send/2-examples" class="section-heading">  Examples </h2> <p>To log the status of requests being sent:</p> <pre data-language="elixir">require Logger

Plug.Conn.register_before_send(conn, fn conn -&gt;
  Logger.info("Sent a #{conn.status} response")
  conn
end)</pre> </section> </div> <div class="detail" id="request_url/1"> <div class="detail-header"> <a href="#request_url/1" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">request_url(conn)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L1514" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> </div> <section class="docstring"> <p>Returns the full request URL.</p> </section> </div> <div class="detail" id="resp/3"> <div class="detail-header"> <a href="#resp/3" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">resp(conn, status, body)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L586" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">resp(t(), status(), body()) :: t()</pre> </div> </div> <section class="docstring"> <p>Sets the response to the given <code class="inline">status</code> and <code class="inline">body</code>.</p> <p>It sets the connection state to <code class="inline">:set</code> (if not already <code class="inline">:set</code>) and raises <a href="plug.conn.alreadysenterror"><code class="inline">Plug.Conn.AlreadySentError</code></a> if it was already <code class="inline">:sent</code>.</p> <p>If you also want to send the response, use <a href="#send_resp/1"><code class="inline">send_resp/1</code></a> after this or use <a href="#send_resp/3"><code class="inline">send_resp/3</code></a>.</p> <p>The status can be an integer, an atom, or <code class="inline">nil</code>. See <a href="plug.conn.status"><code class="inline">Plug.Conn.Status</code></a> for more information.</p> <h2 id="resp/3-examples" class="section-heading">  Examples </h2> <pre data-language="elixir">Plug.Conn.resp(conn, 404, "Not found")</pre> </section> </div> <div class="detail" id="send_chunked/2"> <div class="detail-header"> <a href="#send_chunked/2" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">send_chunked(conn, status)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L483" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">send_chunked(t(), status()) :: t() | no_return()</pre> </div> </div> <section class="docstring"> <p>Sends the response headers as a chunked response.</p> <p>It expects a connection that has not been <code class="inline">:sent</code> yet and sets its state to <code class="inline">:chunked</code> afterwards. Otherwise, raises <a href="plug.conn.alreadysenterror"><code class="inline">Plug.Conn.AlreadySentError</code></a>. After <a href="#send_chunked/2"><code class="inline">send_chunked/2</code></a> is called, chunks can be sent to the client via the <a href="#chunk/2"><code class="inline">chunk/2</code></a> function.</p> <p>HTTP/2 does not support chunking and will instead stream the response without a transfer encoding. When using HTTP/1.1, the Cowboy adapter will stream the response instead of emitting chunks if the <code class="inline">content-length</code> header has been set before calling <a href="#send_chunked/2"><code class="inline">send_chunked/2</code></a>.</p> </section> </div> <div class="detail" id="send_file/5">   <div class="detail-header"> <a href="#send_file/5" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">send_file(conn, status, file, offset \\ 0, length \\ :all)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L441" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">send_file(
  t(),
  status(),
  filename :: binary(),
  offset :: integer(),
  length :: integer() | :all
) :: t() | no_return()</pre> </div> </div> <section class="docstring"> <p>Sends a file as the response body with the given <code class="inline">status</code> and optionally starting at the given offset until the given length.</p> <p>If available, the file is sent directly over the socket using the operating system <code class="inline">sendfile</code> operation.</p> <p>It expects a connection that has not been <code class="inline">:sent</code> yet and sets its state to <code class="inline">:file</code> afterwards. Otherwise raises <a href="plug.conn.alreadysenterror"><code class="inline">Plug.Conn.AlreadySentError</code></a>.</p> <h2 id="send_file/5-examples" class="section-heading">  Examples </h2> <pre data-language="elixir">Plug.Conn.send_file(conn, 200, "README.md")</pre> </section> </div> <div class="detail" id="send_resp/1"> <div class="detail-header"> <a href="#send_resp/1" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">send_resp(conn)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L412" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">send_resp(t()) :: t() | no_return()</pre> </div> </div> <section class="docstring"> <p>Sends a response to the client.</p> <p>It expects the connection state to be <code class="inline">:set</code>, otherwise raises an <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> for <code class="inline">:unset</code> connections or a <a href="plug.conn.alreadysenterror"><code class="inline">Plug.Conn.AlreadySentError</code></a> for already <code class="inline">:sent</code> connections.</p> <p>At the end sets the connection state to <code class="inline">:sent</code>.</p> <p>Note that this function does not halt the connection, so if subsequent plugs try to send another response, it will error out. Use <a href="#halt/1"><code class="inline">halt/1</code></a> after this function if you want to halt the plug pipeline.</p> <h2 id="send_resp/1-examples" class="section-heading">  Examples </h2> <pre data-language="elixir">conn
|&gt; Plug.Conn.resp(404, "Not found")
|&gt; Plug.Conn.send_resp()</pre> </section> </div> <div class="detail" id="send_resp/3"> <div class="detail-header"> <a href="#send_resp/3" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">send_resp(conn, status, body)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L554" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">send_resp(t(), status(), body()) :: t() | no_return()</pre> </div> </div> <section class="docstring"> <p>Sends a response with the given status and body.</p> <p>This is equivalent to setting the status and the body and then calling <a href="#send_resp/1"><code class="inline">send_resp/1</code></a>.</p> <p>Note that this function does not halt the connection, so if subsequent plugs try to send another response, it will error out. Use <a href="#halt/1"><code class="inline">halt/1</code></a> after this function if you want to halt the plug pipeline.</p> <h2 id="send_resp/3-examples" class="section-heading">  Examples </h2> <pre data-language="elixir">Plug.Conn.send_resp(conn, 404, "Not found")</pre> </section> </div> <div class="detail" id="update_req_header/4"> <div class="detail-header"> <a href="#update_req_header/4" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">update_req_header(conn, key, initial, fun)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L714" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">update_req_header(t(), binary(), binary(), (binary() -&gt; binary())) :: t()</pre> </div> </div> <section class="docstring"> <p>Updates a request header if present, otherwise it sets it to an initial value.</p> <p>Raises a <a href="plug.conn.alreadysenterror"><code class="inline">Plug.Conn.AlreadySentError</code></a> if the connection has already been <code class="inline">:sent</code> or <code class="inline">:chunked</code>.</p> <p>Only the first value of the header <code class="inline">key</code> is updated if present.</p> <h2 id="update_req_header/4-examples" class="section-heading">  Examples </h2> <pre data-language="elixir">Plug.Conn.update_req_header(
  conn,
  "accept",
  "application/json; charset=utf-8",
  &amp;(&amp;1 &lt;&gt; "; charset=utf-8")
)</pre> </section> </div> <div class="detail" id="update_resp_header/4"> <div class="detail-header"> <a href="#update_resp_header/4" class="detail-link" title="Link to this function">  <span class="sr-only">Link to this function</span> </a> <span class="signature">update_resp_header(conn, key, initial, fun)</span> <a href="https://github.com/elixir-plug/plug/blob/v1.7.1/lib/plug/conn.ex#L907" class="view-source" rel="help" title="View Source">  <span class="sr-only">View Source</span> </a> <div class="specs"> <pre data-language="elixir">update_resp_header(t(), binary(), binary(), (binary() -&gt; binary())) :: t()</pre> </div> </div> <section class="docstring"> <p>Updates a response header if present, otherwise it sets it to an initial value.</p> <p>Raises a <a href="plug.conn.alreadysenterror"><code class="inline">Plug.Conn.AlreadySentError</code></a> if the connection has already been <code class="inline">:sent</code> or <code class="inline">:chunked</code>.</p> <p>Only the first value of the header <code class="inline">key</code> is updated if present.</p> <h2 id="update_resp_header/4-examples" class="section-heading">  Examples </h2> <pre data-language="elixir">Plug.Conn.update_resp_header(
  conn,
  "content-type",
  "application/json; charset=utf-8",
  &amp;(&amp;1 &lt;&gt; "; charset=utf-8")
)</pre> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/plug/1.7.1/Plug.Conn.html" class="_attribution-link" target="_blank">https://hexdocs.pm/plug/1.7.1/Plug.Conn.html</a>
  </p>
</div>
