<h1> Plug.Conn.Adapter <small>behaviour</small>   </h1> <section id="moduledoc"> <p>Specification of the connection adapter API implemented by webservers.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:http_protocol/0">http_protocol()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:payload/0">payload()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:peer_data/0">peer_data()</a> </dt> </div> </dl> <h2> Callbacks </h2>
<dl class="summary-callbacks summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#c:chunk/2">chunk(payload, arg2)</a> </dt> <dd class="summary-synopsis"><p>Sends a chunk in the chunked response.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:get_http_protocol/1">get_http_protocol(payload)</a> </dt> <dd class="summary-synopsis"><p>Returns the HTTP protocol and its version.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:get_peer_data/1">get_peer_data(payload)</a> </dt> <dd class="summary-synopsis"><p>Returns peer information such as the address, port and ssl cert.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:inform/3">inform(payload, arg2, headers)</a> </dt> <dd class="summary-synopsis"><p>Send an informational response to the client.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:push/3">push(payload, path, headers)</a> </dt> <dd class="summary-synopsis"><p>Push a resource to the client.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:read_req_body/2">read_req_body(payload, options)</a> </dt> <dd class="summary-synopsis"><p>Reads the request body.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:send_chunked/3">send_chunked(payload, arg2, arg3)</a> </dt> <dd class="summary-synopsis"><p>Sends the given status, headers as the beginning of a chunked response to the client.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:send_file/6">send_file(payload, arg2, arg3, file, offset, length)</a> </dt> <dd class="summary-synopsis"><p>Sends the given status, headers and file as a response back to the client.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:send_resp/4">send_resp(payload, arg2, arg3, arg4)</a> </dt> <dd class="summary-synopsis"><p>Sends the given status, headers and body as a response back to the client.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:http_protocol/0">http_protocol()<a href="https://github.com/elixir-plug/plug/blob/v1.11.0/lib/plug/conn/adapter.ex#L7" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">http_protocol() :: :"HTTP/1" | :"HTTP/1.1" | :"HTTP/2" | atom()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:payload/0">payload()<a href="https://github.com/elixir-plug/plug/blob/v1.11.0/lib/plug/conn/adapter.ex#L8" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">payload() :: term()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:peer_data/0">peer_data()<a href="https://github.com/elixir-plug/plug/blob/v1.11.0/lib/plug/conn/adapter.ex#L9" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">peer_data() :: %{
  address: :inet.ip_address(),
  port: :inet.port_number(),
  ssl_cert: binary() | nil
}</pre> </div> </section> </section> </div> </section> <section id="callbacks" class="details-list"> <h1 class="section-heading">  Callbacks </h1> <div class="callbacks-list"> <section class="detail"> <h3 class="detail-header" id="c:chunk/2">chunk(payload, arg2)<a href="https://github.com/elixir-plug/plug/blob/v1.11.0/lib/plug/conn/adapter.ex#L74" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">chunk(payload(), Plug.Conn.body()) ::
  :ok | {:ok, sent_body :: binary(), payload()} | {:error, term()}</pre> </div> <p>Sends a chunk in the chunked response.</p>
<p>If the request has method <code class="inline">"HEAD"</code>, the adapter should not send the response to the client.</p>
<p>Webservers are advised to return <code class="inline">:ok</code> and not modify any further state for each chunk. However, the test implementation returns the actual body and payload so it can be used during testing.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:get_http_protocol/1">get_http_protocol(payload)<a href="https://github.com/elixir-plug/plug/blob/v1.11.0/lib/plug/conn/adapter.ex#L112" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">get_http_protocol(payload()) :: http_protocol()</pre> </div> <p>Returns the HTTP protocol and its version.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:get_peer_data/1">get_peer_data(payload)<a href="https://github.com/elixir-plug/plug/blob/v1.11.0/lib/plug/conn/adapter.ex#L107" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">get_peer_data(payload()) :: peer_data()</pre> </div> <p>Returns peer information such as the address, port and ssl cert.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:inform/3">inform(payload, arg2, headers)<a href="https://github.com/elixir-plug/plug/blob/v1.11.0/lib/plug/conn/adapter.ex#L102" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">inform(payload(), Plug.Conn.status(), headers :: Keyword.t()) ::
  :ok | {:error, term()}</pre> </div> <p>Send an informational response to the client.</p>
<p>If the adapter does not support inform, then <code class="inline">{:error, :not_supported}</code> should be returned.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:push/3">push(payload, path, headers)<a href="https://github.com/elixir-plug/plug/blob/v1.11.0/lib/plug/conn/adapter.ex#L94" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">push(payload(), path :: String.t(), headers :: Keyword.t()) ::
  :ok | {:error, term()}</pre> </div> <p>Push a resource to the client.</p>
<p>If the adapter does not support server push then <code class="inline">{:error, :not_supported}</code> should be returned.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:read_req_body/2">read_req_body(payload, options)<a href="https://github.com/elixir-plug/plug/blob/v1.11.0/lib/plug/conn/adapter.ex#L83" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">read_req_body(payload(), options :: Keyword.t()) ::
  {:ok, data :: binary(), payload()}
  | {:more, data :: binary(), payload()}
  | {:error, term()}</pre> </div> <p>Reads the request body.</p>
<p>Read the docs in <a href="../plug.conn#read_body/2"><code class="inline">Plug.Conn.read_body/2</code></a> for the supported options and expected behaviour.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:send_chunked/3">send_chunked(payload, arg2, arg3)<a href="https://github.com/elixir-plug/plug/blob/v1.11.0/lib/plug/conn/adapter.ex#L60" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">send_chunked(payload(), Plug.Conn.status(), Plug.Conn.headers()) ::
  {:ok, sent_body :: binary() | nil, payload()}</pre> </div> <p>Sends the given status, headers as the beginning of a chunked response to the client.</p>
<p>Webservers are advised to return <code class="inline">nil</code> as the sent_body, as the body can no longer be manipulated. However, the test implementation returns the actual body so it can be used during testing.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:send_file/6">send_file(payload, arg2, arg3, file, offset, length)<a href="https://github.com/elixir-plug/plug/blob/v1.11.0/lib/plug/conn/adapter.ex#L42" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">send_file(
  payload(),
  Plug.Conn.status(),
  Plug.Conn.headers(),
  file :: binary(),
  offset :: integer(),
  length :: integer() | :all
) :: {:ok, sent_body :: binary() | nil, payload()}</pre> </div> <p>Sends the given status, headers and file as a response back to the client.</p>
<p>If the request has method <code class="inline">"HEAD"</code>, the adapter should not send the response to the client.</p>
<p>Webservers are advised to return <code class="inline">nil</code> as the sent_body, as the body can no longer be manipulated. However, the test implementation returns the actual body so it can be used during testing.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:send_resp/4">send_resp(payload, arg2, arg3, arg4)<a href="https://github.com/elixir-plug/plug/blob/v1.11.0/lib/plug/conn/adapter.ex#L27" class="source">Source</a>
</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">send_resp(payload(), Plug.Conn.status(), Plug.Conn.headers(), Plug.Conn.body()) ::
  {:ok, sent_body :: binary() | nil, payload()}</pre> </div> <p>Sends the given status, headers and body as a response back to the client.</p>
<p>If the request has method <code class="inline">"HEAD"</code>, the adapter should not send the response to the client.</p>
<p>Webservers are advised to return <code class="inline">nil</code> as the sent_body, as the body can no longer be manipulated. However, the test implementation returns the actual body so it can be used during testing.</p> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/plug/1.11.0/Plug.Conn.Adapter.html" class="_attribution-link" target="_blank">https://hexdocs.pm/plug/1.11.0/Plug.Conn.Adapter.html</a>
  </p>
</div>
