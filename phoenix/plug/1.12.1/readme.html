<h1>Plug</h1>
<p><a href="https://github.com/elixir-plug/plug/actions?query=workflow%3A%22CI%22"><img src="data:image/svg+xml;%20charset=utf-8;base64,CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iODMiIGhlaWdodD0iMjAiPgogIDxkZWZzPgogICAgPGxpbmVhckdyYWRpZW50IGlkPSJ3b3JrZmxvdy1maWxsIiB4MT0iNTAlIiB5MT0iMCUiIHgyPSI1MCUiIHkyPSIxMDAlIj4KICAgICAgPHN0b3Agc3RvcC1jb2xvcj0iIzQ0NEQ1NiIgb2Zmc2V0PSIwJSI+PC9zdG9wPgogICAgICA8c3RvcCBzdG9wLWNvbG9yPSIjMjQyOTJFIiBvZmZzZXQ9IjEwMCUiPjwvc3RvcD4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgICA8bGluZWFyR3JhZGllbnQgaWQ9InN0YXRlLWZpbGwiIHgxPSI1MCUiIHkxPSIwJSIgeDI9IjUwJSIgeTI9IjEwMCUiPgogICAgICA8c3RvcCBzdG9wLWNvbG9yPSIjRDczQTQ5IiBvZmZzZXQ9IjAlIj48L3N0b3A+CiAgICAgIDxzdG9wIHN0b3AtY29sb3I9IiNDQjI0MzEiIG9mZnNldD0iMTAwJSI+PC9zdG9wPgogICAgPC9saW5lYXJHcmFkaWVudD4KICA8L2RlZnM+CiAgPGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgIDxnIGZvbnQtZmFtaWx5PSImIzM5O0RlamFWdSBTYW5zJiMzOTssVmVyZGFuYSxHZW5ldmEsc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMSI+CiAgICAgIDxwYXRoIGlkPSJ3b3JrZmxvdy1iZyIgZD0iTTAsMyBDMCwxLjM0MzEgMS4zNTUyLDAgMy4wMjcwMjcwMywwIEw0MCwwIEw0MCwyMCBMMy4wMjcwMjcwMywyMCBDMS4zNTUyLDIwIDAsMTguNjU2OSAwLDE3IEwwLDMgWiIgZmlsbD0idXJsKCN3b3JrZmxvdy1maWxsKSIgZmlsbC1ydWxlPSJub256ZXJvIj48L3BhdGg+CiAgICAgIDx0ZXh0IGZpbGw9IiMwMTAxMDEiIGZpbGwtb3BhY2l0eT0iLjMiPgogICAgICAgIDx0c3BhbiB4PSIyMi4xOTgxOTgyIiB5PSIxNSI+Q0k8L3RzcGFuPgogICAgICA8L3RleHQ+CiAgICAgIDx0ZXh0IGZpbGw9IiNGRkZGRkYiPgogICAgICAgIDx0c3BhbiB4PSIyMi4xOTgxOTgyIiB5PSIxNCI+Q0k8L3RzcGFuPgogICAgICA8L3RleHQ+CiAgICA8L2c+CiAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0MCkiIGZvbnQtZmFtaWx5PSImIzM5O0RlamFWdSBTYW5zJiMzOTssVmVyZGFuYSxHZW5ldmEsc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMSI+CiAgICAgIDxwYXRoIGQ9Ik0wIDBoNDAuNDdDNDEuODY5IDAgNDMgMS4zNDMgNDMgM3YxNGMwIDEuNjU3LTEuMTMyIDMtMi41MyAzSDBWMHoiIGlkPSJzdGF0ZS1iZyIgZmlsbD0idXJsKCNzdGF0ZS1maWxsKSIgZmlsbC1ydWxlPSJub256ZXJvIj48L3BhdGg+CiAgICAgIDx0ZXh0IGZpbGw9IiMwMTAxMDEiIGZpbGwtb3BhY2l0eT0iLjMiPgogICAgICAgIDx0c3BhbiB4PSI1IiB5PSIxNSI+ZmFpbGluZzwvdHNwYW4+CiAgICAgIDwvdGV4dD4KICAgICAgPHRleHQgZmlsbD0iI0ZGRkZGRiI+CiAgICAgICAgPHRzcGFuIHg9IjUiIHk9IjE0Ij5mYWlsaW5nPC90c3Bhbj4KICAgICAgPC90ZXh0PgogICAgPC9nPgogICAgPHBhdGggZmlsbD0iIzk1OURBNSIgZD0iTTExIDNjLTMuODY4IDAtNyAzLjEzMi03IDdhNi45OTYgNi45OTYgMCAwIDAgNC43ODYgNi42NDFjLjM1LjA2Mi40ODItLjE0OC40ODItLjMzMiAwLS4xNjYtLjAxLS43MTgtLjAxLTEuMzA0LTEuNzU4LjMyNC0yLjIxMy0uNDI5LTIuMzUzLS44MjItLjA3OS0uMjAyLS40Mi0uODIzLS43MTctLjk5LS4yNDUtLjEzLS41OTUtLjQ1NC0uMDEtLjQ2My41NTItLjAwOS45NDYuNTA4IDEuMDc3LjcxOC42MyAxLjA1OCAxLjYzNi43NiAyLjAzOS41NzcuMDYxLS40NTUuMjQ1LS43NjEuNDQ2LS45MzYtMS41NTctLjE3NS0zLjE4NS0uNzc5LTMuMTg1LTMuNDU2IDAtLjc2Mi4yNzEtMS4zOTIuNzE4LTEuODgyLS4wNy0uMTc1LS4zMTUtLjg5Mi4wNy0xLjg1NSAwIDAgLjU4Ni0uMTgzIDEuOTI1LjcxOGE2LjUgNi41IDAgMCAxIDEuNzUtLjIzNiA2LjUgNi41IDAgMCAxIDEuNzUuMjM2YzEuMzM4LS45MSAxLjkyNS0uNzE4IDEuOTI1LS43MTguMzg1Ljk2My4xNCAxLjY4LjA3IDEuODU1LjQ0Ni40OS43MTcgMS4xMTIuNzE3IDEuODgyIDAgMi42ODYtMS42MzYgMy4yOC0zLjE5NCAzLjQ1Ni4yNTQuMjE5LjQ3My42MzkuNDczIDEuMjk1IDAgLjkzNi0uMDA5IDEuNjg5LS4wMDkgMS45MjUgMCAuMTg0LjEzMS40MDIuNDgxLjMzMkE3LjAxMSA3LjAxMSAwIDAgMCAxOCAxMGMwLTMuODY3LTMuMTMzLTctNy03eiI+PC9wYXRoPgogIDwvZz4KPC9zdmc+Cgo=" alt="Build Status"></a> <a href="http://inch-ci.org/github/elixir-plug/plug"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI4MCIgaGVpZ2h0PSIyMCI+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJhIiB4Mj0iMCIgeTI9IjEwMCUiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iI2JiYiIgc3RvcC1vcGFjaXR5PSIuMSIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1vcGFjaXR5PSIuMSIvPjwvbGluZWFyR3JhZGllbnQ+CiAgPHJlY3Qgcng9IjMiIHdpZHRoPSI4MCIgaGVpZ2h0PSIyMCIgZmlsbD0iIzU1NSIvPgogIDxyZWN0IHJ4PSIzIiB3aWR0aD0iODAiIGhlaWdodD0iMjAiIGZpbGw9InVybCgjYSkiLz4KCiAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkQSIgeDI9IjAiIHkyPSIxMDAlIj4KICAgIDxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzQ2YjAxZSIgLz4KICAgIDxzdG9wIG9mZnNldD0iLjEiIHN0b3AtY29sb3I9IiM0NmIwMWUiIC8+CiAgICA8c3RvcCBvZmZzZXQ9Ii41IiBzdG9wLWNvbG9yPSIjNDZiMDFlIiAvPgogICAgPHN0b3Agb2Zmc2V0PSIuOSIgc3RvcC1jb2xvcj0iIzQ2YjAxZSIgLz4KICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzQ2YjAxZSIgLz4KICA8L2xpbmVhckdyYWRpZW50PgogIDxsaW5lYXJHcmFkaWVudCBpZD0iZ3JhZEIiIHgyPSIwIiB5Mj0iMTAwJSI+CiAgICA8c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiM4N2FlMTAiIC8+CiAgICA8c3RvcCBvZmZzZXQ9Ii4xIiBzdG9wLWNvbG9yPSIjODdhZTEwIiAvPgogICAgPHN0b3Agb2Zmc2V0PSIuNSIgc3RvcC1jb2xvcj0iIzg3YWUxMCIgLz4KICAgIDxzdG9wIG9mZnNldD0iLjkiIHN0b3AtY29sb3I9IiM4N2FlMTAiIC8+CiAgICA8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM4N2FlMTAiIC8+CiAgPC9saW5lYXJHcmFkaWVudD4KICA8bGluZWFyR3JhZGllbnQgaWQ9ImdyYWRDIiB4Mj0iMCIgeTI9IjEwMCUiPgogICAgPHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjYzA1OTQ2IiAvPgogICAgPHN0b3Agb2Zmc2V0PSIuMSIgc3RvcC1jb2xvcj0iI2MwNTk0NiIgLz4KICAgIDxzdG9wIG9mZnNldD0iLjUiIHN0b3AtY29sb3I9IiNjMDU5NDYiIC8+CiAgICA8c3RvcCBvZmZzZXQ9Ii45IiBzdG9wLWNvbG9yPSIjYzA1OTQ2IiAvPgogICAgPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjYzA1OTQ2IiAvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkVSIgeDI9IjAiIHkyPSIxMDAlIj4KICAgIDxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzdhNjdhMCIgLz4KICAgIDxzdG9wIG9mZnNldD0iLjEiIHN0b3AtY29sb3I9IiM3YTY3YTAiIC8+CiAgICA8c3RvcCBvZmZzZXQ9Ii41IiBzdG9wLWNvbG9yPSIjN2E2N2EwIiAvPgogICAgPHN0b3Agb2Zmc2V0PSIuOSIgc3RvcC1jb2xvcj0iIzdhNjdhMCIgLz4KICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzdhNjdhMCIgLz4KICA8L2xpbmVhckdyYWRpZW50PgogICAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkTiIgeDI9IjAiIHkyPSIxMDAlIj4KICAgICAgPHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjOUI5QjlCIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9Ii4xIiBzdG9wLWNvbG9yPSIjOUI5QjlCIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9Ii41IiBzdG9wLWNvbG9yPSIjOUI5QjlCIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9Ii45IiBzdG9wLWNvbG9yPSIjOUI5QjlCIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM5QjlCOUIiIC8+CiAgICA8L2xpbmVhckdyYWRpZW50PgoKICAKICAKICAgIDxyZWN0IHg9IjM2IiB5PSI0IiB3aWR0aD0iOSIgaGVpZ2h0PSIxMiIgZmlsbD0idXJsKCNncmFkQSkiLz4KICAgIAogIAogICAgPHJlY3QgeD0iNDUiIHk9IjQiIHdpZHRoPSIxNiIgaGVpZ2h0PSIxMiIgZmlsbD0idXJsKCNncmFkQikiLz4KICAgIAogIAogICAgPHJlY3QgeD0iNjEiIHk9IjQiIHdpZHRoPSIwIiBoZWlnaHQ9IjEyIiBmaWxsPSJ1cmwoI2dyYWRDKSIvPgogICAgCiAgCiAgICA8cmVjdCB4PSI2MSIgeT0iNCIgd2lkdGg9IjE1IiBoZWlnaHQ9IjEyIiBmaWxsPSJ1cmwoI2dyYWRVKSIvPgogICAgCiAgCgogIDxyZWN0IHg9IjM2IiB5PSI0IiB3aWR0aD0iMSIgaGVpZ2h0PSIxIiBmaWxsPSIjNjY2Ii8+CiAgPHJlY3QgeD0iMzYiIHk9IjE1IiB3aWR0aD0iMSIgaGVpZ2h0PSIxIiBmaWxsPSIjNjY2Ii8+CiAgPHJlY3QgeD0iNzUiIHk9IjQiIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIGZpbGw9IiM2NjYiLz4KICA8cmVjdCB4PSI3NSIgeT0iMTUiIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIGZpbGw9IiM2NjYiLz4KCiAgPGcgZmlsbD0iI2ZmZiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1mYW1pbHk9IkRlamFWdSBTYW5zLFZlcmRhbmEsR2VuZXZhLHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTEiPgogICAgPHRleHQgeD0iMTguNSIgeT0iMTQiPmRvY3M8L3RleHQ+CiAgPC9nPgo8L3N2Zz4K" alt="Inline docs"></a></p>
<p>Plug is:</p>
<ol>
<li>A specification for composable modules between web applications</li>
<li>Connection adapters for different web servers in the Erlang VM</li>
</ol>
<p><a href="http://hexdocs.pm/plug/">Documentation for Plug is available online</a>.</p>
<h2 id="installation" class="section-heading">  Installation </h2> <p>In order to use Plug, you need a webserver and its bindings for Plug. The Cowboy webserver is the most common one, which can be installed by adding <code class="inline">plug_cowboy</code> as a dependency to your <code class="inline">mix.exs</code>:</p>
<pre data-language="elixir">def deps do
  [
    {:plug_cowboy, "~&gt; 2.0"}
  ]
end</pre>
<h2 id="hello-world" class="section-heading">  Hello world </h2> <pre data-language="elixir">defmodule MyPlug do
  import Plug.Conn

  def init(options) do
    # initialize options
    options
  end

  def call(conn, _opts) do
    conn
    |&gt; put_resp_content_type("text/plain")
    |&gt; send_resp(200, "Hello world")
  end
end</pre>
<p>The snippet above shows a very simple example on how to use Plug. Save that snippet to a file and run it inside the plug application with:</p>
<pre data-language="elixir">$ iex -S mix
iex&gt; c "path/to/file.ex"
[MyPlug]
iex&gt; {:ok, _} = Plug.Cowboy.http MyPlug, []
{:ok, #PID&lt;...&gt;}</pre>
<p>Access <a href="http://localhost:4000/">http://localhost:4000/</a> and we are done! For now, we have directly started the server in our terminal but, for production deployments, you likely want to start it in your supervision tree. See the <a href="#supervised-handlers">Supervised handlers</a> section next.</p>
<h2 id="supervised-handlers" class="section-heading">  Supervised handlers </h2> <p>On a production system, you likely want to start your Plug pipeline under your application's supervision tree. Start a new Elixir project with the <code class="inline">--sup</code> flag:</p>
<pre data-language="elixir">$ mix new my_app --sup</pre>
<p>and then update <code class="inline">lib/my_app/application.ex</code> as follows:</p>
<pre data-language="elixir">defmodule MyApp do
  # See https://hexdocs.pm/elixir/Application.html
  # for more information on OTP Applications
  @moduledoc false

  use Application

  def start(_type, _args) do
    # List all child processes to be supervised
    children = [
      {Plug.Cowboy, scheme: :http, plug: MyPlug, options: [port: 4001]}
    ]

    # See https://hexdocs.pm/elixir/Supervisor.html
    # for other strategies and supported options
    opts = [strategy: :one_for_one, name: MyApp.Supervisor]
    Supervisor.start_link(children, opts)
  end
end</pre>
<p>Now run <code class="inline">mix run --no-halt</code> and it will start your application with a web server running at <code class="inline">localhost:4001</code>.</p>
<h2 id="supported-versions" class="section-heading">  Supported Versions </h2> <table>
<thead><tr>
<th style="text-align: left;">Branch</th>
<th style="text-align: left;">Support</th>
</tr></thead>
<tbody>
<tr>
<td style="text-align: left;">v1.11</td>
<td style="text-align: left;">Bug fixes</td>
</tr>
<tr>
<td style="text-align: left;">v1.10</td>
<td style="text-align: left;">Security patches only</td>
</tr>
<tr>
<td style="text-align: left;">v1.9</td>
<td style="text-align: left;">Security patches only</td>
</tr>
<tr>
<td style="text-align: left;">v1.8</td>
<td style="text-align: left;">Security patches only</td>
</tr>
<tr>
<td style="text-align: left;">v1.7</td>
<td style="text-align: left;">Security patches only</td>
</tr>
<tr>
<td style="text-align: left;">v1.6</td>
<td style="text-align: left;">Security patches only</td>
</tr>
<tr>
<td style="text-align: left;">v1.5</td>
<td style="text-align: left;">Unsupported from 03/2021</td>
</tr>
<tr>
<td style="text-align: left;">v1.4</td>
<td style="text-align: left;">Unsupported from 12/2018</td>
</tr>
<tr>
<td style="text-align: left;">v1.3</td>
<td style="text-align: left;">Unsupported from 12/2018</td>
</tr>
<tr>
<td style="text-align: left;">v1.2</td>
<td style="text-align: left;">Unsupported from 06/2018</td>
</tr>
<tr>
<td style="text-align: left;">v1.1</td>
<td style="text-align: left;">Unsupported from 01/2018</td>
</tr>
<tr>
<td style="text-align: left;">v1.0</td>
<td style="text-align: left;">Unsupported from 05/2017</td>
</tr>
</tbody>
</table>
<h2 id="the-plug-conn-struct" class="section-heading">  The <a href="plug.conn"><code class="inline">Plug.Conn</code></a> struct </h2> <p>In the hello world example, we defined our first plug. What is a plug after all?</p>
<p>A plug takes two shapes. A function plug receives a connection and a set of options as arguments and returns the connection:</p>
<pre data-language="elixir">def hello_world_plug(conn, _opts) do
  conn
  |&gt; put_resp_content_type("text/plain")
  |&gt; send_resp(200, "Hello world")
end</pre>
<p>A module plug implements an <code class="inline">init/1</code> function to initialize the options and a <code class="inline">call/2</code> function which receives the connection and initialized options and returns the connection:</p>
<pre data-language="elixir">defmodule MyPlug do
  def init([]), do: false
  def call(conn, _opts), do: conn
end</pre>
<p>As per the specification above, a connection is represented by the <a href="plug.conn"><code class="inline">Plug.Conn</code></a> struct:</p>
<pre data-language="elixir">%Plug.Conn{host: "www.example.com",
           path_info: ["bar", "baz"],
           ...}</pre>
<p>Data can be read directly from the connection and also pattern matched on. Manipulating the connection often happens with the use of the functions defined in the <a href="plug.conn"><code class="inline">Plug.Conn</code></a> module. In our example, both <code class="inline">put_resp_content_type/2</code> and <code class="inline">send_resp/3</code> are defined in <a href="plug.conn"><code class="inline">Plug.Conn</code></a>.</p>
<p>Remember that, as everything else in Elixir, <strong>a connection is immutable</strong>, so every manipulation returns a new copy of the connection:</p>
<pre data-language="elixir">conn = put_resp_content_type(conn, "text/plain")
conn = send_resp(conn, 200, "ok")
conn</pre>
<p>Finally, keep in mind that a connection is a <strong>direct interface to the underlying web server</strong>. When you call <code class="inline">send_resp/3</code> above, it will immediately send the given status and body back to the client. This makes features like streaming a breeze to work with.</p>
<h2 id="plug-router" class="section-heading">  <a href="plug.router"><code class="inline">Plug.Router</code></a> </h2> <p>To write a "router" plug that dispatches based on the path and method of incoming requests, Plug provides <a href="plug.router"><code class="inline">Plug.Router</code></a>:</p>
<pre data-language="elixir">defmodule MyRouter do
  use Plug.Router

  plug :match
  plug :dispatch

  get "/hello" do
    send_resp(conn, 200, "world")
  end

  forward "/users", to: UsersRouter

  match _ do
    send_resp(conn, 404, "oops")
  end
end</pre>
<p>The router is a plug. Not only that: it contains its own plug pipeline too. The example above says that when the router is invoked, it will invoke the <code class="inline">:match</code> plug, represented by a local (imported) <code class="inline">match/2</code> function, and then call the <code class="inline">:dispatch</code> plug which will execute the matched code.</p>
<p>Plug ships with many plugs that you can add to the router plug pipeline, allowing you to plug something before a route matches or before a route is dispatched to. For example, if you want to add logging to the router, just do:</p>
<pre data-language="elixir">plug Plug.Logger
plug :match
plug :dispatch</pre>
<p>Note <a href="plug.router"><code class="inline">Plug.Router</code></a> compiles all of your routes into a single function and relies on the Erlang VM to optimize the underlying routes into a tree lookup, instead of a linear lookup that would instead match route-per-route. This means route lookups are extremely fast in Plug!</p>
<p>This also means that a catch all <code class="inline">match</code> block is recommended to be defined as in the example above, otherwise routing fails with a function clause error (as it would in any regular Elixir function).</p>
<p>Each route needs to return the connection as per the Plug specification. See the <a href="plug.router"><code class="inline">Plug.Router</code></a> docs for more information.</p>
<h2 id="testing-plugs" class="section-heading">  Testing plugs </h2> <p>Plug ships with a <a href="plug.test"><code class="inline">Plug.Test</code></a> module that makes testing your plugs easy. Here is how we can test the router from above (or any other plug):</p>
<pre data-language="elixir">defmodule MyPlugTest do
  use ExUnit.Case, async: true
  use Plug.Test

  @opts MyRouter.init([])

  test "returns hello world" do
    # Create a test connection
    conn = conn(:get, "/hello")

    # Invoke the plug
    conn = MyRouter.call(conn, @opts)

    # Assert the response and status
    assert conn.state == :sent
    assert conn.status == 200
    assert conn.resp_body == "world"
  end
end</pre>
<h2 id="available-plugs" class="section-heading">  Available plugs </h2> <p>This project aims to ship with different plugs that can be re-used across applications:</p>
<ul>
<li>
<a href="plug.basicauth"><code class="inline">Plug.BasicAuth</code></a> - provides Basic HTTP authentication;</li>
<li>
<a href="plug.csrfprotection"><code class="inline">Plug.CSRFProtection</code></a> - adds Cross-Site Request Forgery protection to your application. Typically required if you are using <a href="plug.session"><code class="inline">Plug.Session</code></a>;</li>
<li>
<a href="plug.head"><code class="inline">Plug.Head</code></a> - converts HEAD requests to GET requests;</li>
<li>
<a href="plug.logger"><code class="inline">Plug.Logger</code></a> - logs requests;</li>
<li>
<a href="plug.methodoverride"><code class="inline">Plug.MethodOverride</code></a> - overrides a request method with one specified in the request parameters;</li>
<li>
<a href="plug.parsers"><code class="inline">Plug.Parsers</code></a> - responsible for parsing the request body given its content-type;</li>
<li>
<a href="plug.requestid"><code class="inline">Plug.RequestId</code></a> - sets up a request ID to be used in logs;</li>
<li>
<a href="plug.rewriteon"><code class="inline">Plug.RewriteOn</code></a> - rewrite the request's host/port/protocol from <code class="inline">x-forwarded-*</code> headers;</li>
<li>
<a href="plug.session"><code class="inline">Plug.Session</code></a> - handles session management and storage;</li>
<li>
<a href="plug.ssl"><code class="inline">Plug.SSL</code></a> - enforces requests through SSL;</li>
<li>
<a href="plug.static"><code class="inline">Plug.Static</code></a> - serves static files;</li>
<li>
<a href="plug.telemetry"><code class="inline">Plug.Telemetry</code></a> - instruments the plug pipeline with <code class="inline">:telemetry</code> events;</li>
</ul>
<p>You can go into more details about each of them <a href="http://hexdocs.pm/plug/">in our docs</a>.</p>
<h2 id="helper-modules" class="section-heading">  Helper modules </h2> <p>Modules that can be used after you use <a href="plug.router"><code class="inline">Plug.Router</code></a> or <a href="plug.builder"><code class="inline">Plug.Builder</code></a> to help development:</p>
<ul>
<li>
<a href="plug.debugger"><code class="inline">Plug.Debugger</code></a> - shows a helpful debugging page every time there is a failure in a request;</li>
<li>
<a href="plug.errorhandler"><code class="inline">Plug.ErrorHandler</code></a> - allows developers to customize error pages in case of crashes instead of sending a blank one;</li>
</ul>
<h2 id="contributing" class="section-heading">  Contributing </h2> <p>We welcome everyone to contribute to Plug and help us tackle existing issues!</p>
<p>Use the <a href="https://github.com/elixir-plug/plug/issues" title="">issue tracker</a> for bug reports or feature requests. Open a <a href="https://github.com/elixir-plug/plug/pulls" title="">pull request</a> when you are ready to contribute. When submitting a pull request you should not update the <code class="inline">CHANGELOG.md</code>.</p>
<p>If you are planning to contribute documentation, <a href="https://hexdocs.pm/elixir/writing-documentation.html" title="">please check our best practices for writing documentation</a>.</p>
<p>Finally, remember all interactions in our official spaces follow our <a href="https://github.com/elixir-lang/elixir/blob/master/CODE_OF_CONDUCT.md" title="">Code of Conduct</a>.</p>
<h2 id="license" class="section-heading">  License </h2> <p>Plug source code is released under Apache License 2.0. Check LICENSE file for more information.</p> <div class="bottom-actions"> <div class="bottom-actions-item"> <a href="api-reference" class="bottom-actions-button" rel="prev"> <span class="subheader"> ← Previous Page </span> <span class="title"> API Reference </span> </a> </div> <div class="bottom-actions-item"> <a href="https" class="bottom-actions-button" rel="next"> <span class="subheader"> Next Page → </span> <span class="title"> HTTPS </span> </a> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/plug/1.12.1/readme.html" class="_attribution-link" target="_blank">https://hexdocs.pm/plug/1.12.1/readme.html</a>
  </p>
</div>
