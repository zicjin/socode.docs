<h1>Deploying with Releases</h1>
<h2 id="what-we-ll-need" class="section-heading">  What we'll need </h2> <p>The only thing we'll need for this guide is a working Phoenix application. For those of us who need a simple application to deploy, please follow the <a href="up_and_running">Up and Running guide</a>.</p>
<h2 id="goals" class="section-heading">  Goals </h2> <p>Our main goal for this guide is to package your Phoenix application into a self-contained directory that includes the Erlang VM, Elixir, all of your code and dependencies. This package can then be dropped into a production machine.</p>
<h2 id="releases-assemble" class="section-heading">  Releases, assemble! </h2> <p>To assemble a release, you will need Elixir v1.9 or later:</p>
<pre data-language="elixir">$ elixir -v
1.9.0
</pre>
<p>If you are not familiar with Elixir releases yet, we recommend you to read <a href="https://hexdocs.pm/mix/Mix.Tasks.Release.html">Elixir's excellent docs</a> before continuing.</p>
<p>Once that is done, you can assemble a release by going through all of the steps in our general <a href="deployment">deployment guide</a> with <a href="https://hexdocs.pm/mix/Mix.Tasks.Release.html"><code class="inline">mix release</code></a> at the end. Let's recap.</p>
<p>First set the environment variables:</p>
<pre data-language="elixir">$ mix phx.gen.secret
REALLY_LONG_SECRET
$ export SECRET_KEY_BASE=REALLY_LONG_SECRET
$ export DATABASE_URL=ecto://USER:PASS@HOST/database
</pre>
<p>Then load dependencies to compile code and assets:</p>
<pre data-language="elixir"># Initial setup
$ mix deps.get --only prod
$ MIX_ENV=prod mix compile

# Install / update  JavaScript dependencies
$ npm install --prefix ./assets

# Compile assets
$ npm run deploy --prefix ./assets
$ mix phx.digest
</pre>
<p><em>Note:</em> the <code class="inline">--prefix</code> flag on <code class="inline">npm</code> may not work on Windows. If so, replace the first command by <code class="inline">cd assets &amp;&amp; npm run deploy &amp;&amp; cd ..</code>.</p>
<p>And now run <a href="https://hexdocs.pm/mix/Mix.Tasks.Release.html"><code class="inline">mix release</code></a>:</p>
<pre data-language="elixir">$ MIX_ENV=prod mix release
Generated my_app app
* assembling my_app-0.1.0 on MIX_ENV=prod
* skipping runtime configuration (config/releases.exs not found)

Release created at _build/prod/rel/my_app!

    # To start your system
    _build/prod/rel/my_app/bin/my_app start

...
</pre>
<p>You can start the release by calling <code class="inline">_build/prod/rel/my_app/bin/my_app start</code>, where you have to replace <code class="inline">my_app</code> by your current application name. If you do so, your application should start but you will notice your web server does not actually run! That's because we need to tell Phoenix to start the web servers. When using <a href="mix.tasks.phx.server"><code class="inline">mix phx.server</code></a>, the <code class="inline">phx.server</code> command does that for us, but in a release we don't have Mix (which is a <em>build</em> tool), so we have to do it ourselves.</p>
<p>Open up <code class="inline">config/prod.secret.exs</code> and you should find a section about "Using releases" with a configuration to set. Go ahead and uncomment that line or manually add the line below, adapted to your application names:</p>
<pre data-language="elixir">config :my_app, MyApp.Endpoint, server: true</pre>
<p>Now assemble the release once again:</p>
<pre data-language="elixir">$ MIX_ENV=prod mix release
Generated my_app app
* assembling my_app-0.1.0 on MIX_ENV=prod
* skipping runtime configuration (config/releases.exs not found)

Release created at _build/prod/rel/my_app!

    # To start your system
    _build/prod/rel/my_app/bin/my_app start
</pre>
<p>And starting the release now should also successfully start the web server! Now you can get all of the files under the <code class="inline">_build/prod/rel/my_app</code> directory, package it, and run it in any production machine with the same OS and architecture as the one that assembled the release. For more details, check the <a href="https://hexdocs.pm/mix/Mix.Tasks.Release.html">docs for <code class="inline">mix release</code></a>.</p>
<p>But before we finish this guide, there are two features from releases most Phoenix applications will use, so let's talk about those.</p>
<h2 id="runtime-configuration" class="section-heading">  Runtime configuration </h2> <p>You may have noticed that, in order to assemble our release, we had to set both <code class="inline">SECRET_KEY_BASE</code> and <code class="inline">DATABASE_URL</code>. That's because <code class="inline">config/config.exs</code>, <code class="inline">config/prod.exs</code>, and friends are executed when the release is assembled (or more generally speaking, whenever you run a <code class="inline">mix</code> command).</p>
<p>However, in many cases, we don't want to set the values for <code class="inline">SECRET_KEY_BASE</code> and <code class="inline">DATABASE_URL</code> when assembling the release but only when starting the system in production. In particular, you may not even have those values easily accessible, and you may have to reach out to another system to retrieve those. Luckily, for such use cases, <a href="https://hexdocs.pm/mix/Mix.Tasks.Release.html"><code class="inline">mix release</code></a> provides runtime configuration, which we can enable in three steps:</p>
<ol>
<li><p>Rename <code class="inline">config/prod.secret.exs</code> to <code class="inline">config/releases.exs</code></p></li>
<li><p>Change <code class="inline">use Mix.Config</code> inside the new <code class="inline">config/releases.exs</code> file to <code class="inline">import Config</code> (if you want, you can replace all uses of <code class="inline">use Mix.Config</code> by <code class="inline">import Config</code>, as the latter replaces the former)</p></li>
<li><p>Change <code class="inline">config/prod.exs</code> to no longer call <code class="inline">import_config "prod.secret.exs"</code> at the bottom</p></li>
</ol>
<p>Now if you assemble another release, you should see this:</p>
<pre data-language="elixir">$ MIX_ENV=prod mix release
Generated my_app app
* assembling my_app-0.1.0 on MIX_ENV=prod
* using config/releases.exs to configure the release at runtime
</pre>
<p>Notice how it says you are using runtime configuration. Now you no longer need to set those environment variables when assembling the release, only when you run <code class="inline">_build/prod/rel/my_app/bin/my_app start</code> and friends.</p>
<h2 id="ecto-migrations-and-custom-commands" class="section-heading">  Ecto migrations and custom commands </h2> <p>Another common need in production systems is to execute custom commands required to set up the production environment. One of such commands is precisely migrating the database. Since we don't have <a href="https://hexdocs.pm/mix/Mix.html"><code class="inline">Mix</code></a>, a <em>build</em> tool, inside releases, which are a production artifact, we need to bring said commands directly into the release.</p>
<p>Our recommendation is to create a new file in your application, such as <code class="inline">lib/my_app/release.ex</code>, with the following:</p>
<pre data-language="elixir">defmodule MyApp.Release do
  @app :my_app

  def migrate do
    load_app()

    for repo &lt;- repos() do
      {:ok, _, _} = Ecto.Migrator.with_repo(repo, &amp;Ecto.Migrator.run(&amp;1, :up, all: true))
    end
  end

  def rollback(repo, version) do
    load_app()
    {:ok, _, _} = Ecto.Migrator.with_repo(repo, &amp;Ecto.Migrator.run(&amp;1, :down, to: version))
  end

  defp repos do
    Application.fetch_env!(@app, :ecto_repos)
  end

  defp load_app do
    Application.load(@app)
  end
end</pre>
<p>Where you replace the first two lines by your application names.</p>
<p>Now you can assemble a new release with <code class="inline">MIX_ENV=prod mix release</code> and you can invoke any code, including the functions in the module above, by calling the <code class="inline">eval</code> command:</p>
<pre data-language="elixir">$ _build/prod/rel/my_app/bin/my_app eval "MyApp.Release.migrate"
</pre>
<p>And that's it!</p>
<p>You can use this approach to create any custom command to run in production. In this case, we used <code class="inline">load_app</code>, which calls <a href="https://hexdocs.pm/elixir/Application.html#load/1"><code class="inline">Application.load/1</code></a> to load the current application without starting it. However, you may want to write a custom command that starts the whole application. In such cases, <a href="https://hexdocs.pm/elixir/Application.html#ensure_all_started/1"><code class="inline">Application.ensure_all_started/1</code></a> must be used. Keep in mind starting the application will start all processes for the current application, including the Phoenix endpoint. This can be circumvented by changing your supervision tree to not start certain children under certain conditions. For example, in the release commands file you could do:</p>
<pre data-language="elixir">defp start_app do
  load_app()
  Application.put_env(@app, :minimal, true)
  Application.ensure_all_started(@app)
end</pre>
<p>And then in your application you check <code class="inline">Application.get_env(@app, :minimal)</code> and start only part of the children when it is set.</p>
<h2 id="containers" class="section-heading">  Containers </h2> <p>Elixir releases work well with container technologies, such as Docker. The idea is that you assemble the release inside the Docker container and then build an image based on the release artifacts.</p>
<p>Here is an example Docker file to run at the root of your application covering all of the steps above:</p>
<pre data-language="elixir">FROM elixir:1.9.0-alpine AS build

# install build dependencies
RUN apk add --no-cache build-base npm git python

# prepare build dir
WORKDIR /app

# install hex + rebar
RUN mix local.hex --force &amp;&amp; \
    mix local.rebar --force

# set build ENV
ENV MIX_ENV=prod

# install mix dependencies
COPY mix.exs mix.lock ./
COPY config config
RUN mix do deps.get, deps.compile

# build assets
COPY assets/package.json assets/package-lock.json ./assets/
RUN npm --prefix ./assets ci --progress=false --no-audit --loglevel=error

COPY priv priv
COPY assets assets
RUN npm run --prefix ./assets deploy
RUN mix phx.digest

# compile and build release
COPY lib lib
# uncomment COPY if rel/ exists
# COPY rel rel
RUN mix do compile, release

# prepare release image
FROM alpine:3.9 AS app
RUN apk add --no-cache openssl ncurses-libs

WORKDIR /app

RUN chown nobody:nobody /app

USER nobody:nobody

COPY --from=build --chown=nobody:nobody /app/_build/prod/rel/my_app ./

ENV HOME=/app

CMD ["bin/my_app", "start"]</pre>
<p>At the end, you will have an application in <code class="inline">/app</code> ready to run as <code class="inline">bin/my_app start</code>.</p> <div class="bottom-actions"> <div class="bottom-actions-item"> <a href="deployment" class="bottom-actions-button" rel="prev"> <span class="subheader"> ← Previous Page </span> <span class="title"> Introduction to Deployment </span> </a> </div> <div class="bottom-actions-item"> <a href="gigalixir" class="bottom-actions-button" rel="next"> <span class="subheader"> Next Page → </span> <span class="title"> Deploying on Gigalixir </span> </a> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/phoenix/releases.html" class="_attribution-link" target="_blank">https://hexdocs.pm/phoenix/releases.html</a>
  </p>
</div>
