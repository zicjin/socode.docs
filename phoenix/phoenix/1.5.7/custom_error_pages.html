<h1>Custom Error Pages</h1>
<p>Phoenix has a view called the <code class="inline">ErrorView</code> which lives in <code class="inline">lib/hello_web/views/error_view.ex</code>. The purpose of the <code class="inline">ErrorView</code> is to handle errors in a general way, from one centralized location.</p>
<h2 id="the-errorview" class="section-heading">  The ErrorView </h2> <p>For new applications, the ErrorView looks like this:</p>
<pre data-language="elixir">defmodule HelloWeb.ErrorView do
  use HelloWeb, :view

  # If you want to customize a particular status code
  # for a certain format, you may uncomment below.
  # def render("500.html", _assigns) do
  #   "Internal Server Error"
  # end

  # By default, Phoenix returns the status message from
  # the template name. For example, "404.html" becomes
  # "Not Found".
  def template_not_found(template, _assigns) do
    Phoenix.Controller.status_message_from_template(template)
  end
end</pre>
<p>Before we dive into this, let's see what the rendered <code class="inline">404 not found</code> message looks like in a browser. In the development environment, Phoenix will debug errors by default, showing us a very informative debugging page. What we want here, however, is to see what page the application would serve in production. In order to do that we need to set <code class="inline">debug_errors: false</code> in <code class="inline">config/dev.exs</code>.</p>
<pre data-language="elixir">use Mix.Config

config :hello, HelloWeb.Endpoint,
  http: [port: 4000],
  debug_errors: false,
  code_reloader: true,
  . . .</pre>
<p>After modifying our config file, we need to restart our server in order for this change to take effect. After restarting the server, let's go to <a href="http://localhost:4000/such/a/wrong/path">http://localhost:4000/such/a/wrong/path</a> for a running local application and see what we get.</p>
<p>Ok, that's not very exciting. We get the bare string "Not Found", displayed without any markup or styling.</p>
<p>The first question is, where does that error string come from? The answer is right in the <code class="inline">ErrorView</code>.</p>
<pre data-language="elixir">def template_not_found(template, _assigns) do
  Phoenix.Controller.status_message_from_template(template)
end</pre>
<p>Great, so we have this <code class="inline">template_not_found/2</code> function that takes a template and an <code class="inline">assigns</code> map, which we ignore. The <code class="inline">template_not_found/2</code> is invoked whenever a Phoenix.View attempts to render a template but no template is found.</p>
<p>In order words, to provide custom error pages, we could simply define a the proper <code class="inline">render/2</code> function clause in <code class="inline">HelloWeb.ErrorView</code>.</p>
<pre data-language="elixir">def render("404.html", _assigns) do
  "Page Not Found"
end</pre>
<p>But we can do even better.</p>
<p>Phoenix generates an <code class="inline">ErrorView</code> for us, but it doesn't give us a <code class="inline">lib/hello_web/templates/error</code> directory. Let's create one now. Inside our new directory, let's add a template, <code class="inline">404.html.eex</code> and give it some markup - a mixture of our application layout and a new <code class="inline">div</code> with our message to the user.</p>
<pre data-language="elixir">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;meta name="description" content=""&gt;
    &lt;meta name="author" content=""&gt;

    &lt;title&gt;Welcome to Phoenix!&lt;/title&gt;
    &lt;link rel="stylesheet" href="/css/app.css"&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;div class="container"&gt;
      &lt;div class="header"&gt;
        &lt;ul class="nav nav-pills pull-right"&gt;
          &lt;li&gt;&lt;a href="https://hexdocs.pm/phoenix/overview.html"&gt;Get Started&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;span class="logo"&gt;&lt;/span&gt;
      &lt;/div&gt;

      &lt;div class="phx-hero"&gt;
        &lt;p&gt;Sorry, the page you are looking for does not exist.&lt;/p&gt;
      &lt;/div&gt;

      &lt;div class="footer"&gt;
        &lt;p&gt;&lt;a href="https://phoenixframework.org"&gt;phoenixframework.org&lt;/a&gt;&lt;/p&gt;
      &lt;/div&gt;

    &lt;/div&gt; &lt;!-- /container --&gt;
    &lt;script src="/js/app.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
<p>Now when we go back to <a href="http://localhost:4000/such/a/wrong/path">http://localhost:4000/such/a/wrong/path</a>, we should see a much nicer error page. It is worth noting that we did not render our <code class="inline">404.html.eex</code> template through our application layout, even though we want our error page to have the look and feel of the rest of our site. This is to avoid circular errors. For example, what happens if our application failed due to an error in the layout? Attempting to render the layout again will just trigger another error. So ideally we want to minimize the amount of dependencies and logic in our error templates, sharing only what is necessary.</p>
<h2 id="custom-exceptions" class="section-heading">  Custom Exceptions </h2> <p>Elixir provides a macro called <code class="inline">defexception</code> for defining custom exceptions. Exceptions are represented as structs, and structs need to be defined inside of modules.</p>
<p>In order to create a custom exception, we need to define a new module. Conventionally this will have "Error" in the name. Inside of that module, we need to define a new exception with <code class="inline">defexception</code>.</p>
<pre data-language="elixir">defmodule MyApp.SomethingNotFoundError do
  defexception [:message]
end</pre>
<p>You can raise your new exception like this:</p>
<pre data-language="elixir">raise MyApp.SomethingNotFoundError, "oops"</pre>
<p>By default, Plug and Phoenix will treat all exceptions as 500 errors. However, Plug provides a protocol called <a href="../../plug/plug.exception"><code class="inline">Plug.Exception</code></a> where we are able to customize the status and add actions that exception structs can returns on the debug error page.</p>
<p>If we wanted to supply a status of 404 for an <code class="inline">MyApp.SomethingNotFoundError</code>, we could do it by defining an implementation for the <a href="../../plug/plug.exception"><code class="inline">Plug.Exception</code></a> protocol like this:</p>
<pre data-language="elixir">defimpl Plug.Exception, for: MyApp.SomethingNotFoundError do
  def status(_exception), do: 404
  def actions(_exception), do: []
end</pre>
<p>Alternatively, you could define a <code class="inline">plug_status</code> field directly in the exception struct:</p>
<pre data-language="elixir">defmodule MyApp.SomethingNotFoundError do
  defexception [:message, plug_status: 404]
end</pre>
<p>However, implementing the <a href="../../plug/plug.exception"><code class="inline">Plug.Exception</code></a> protocol by hand can be convenient in certain occasions, such as when providing Actionable ERrors.</p>
<h2 id="actionable-errors" class="section-heading">  Actionable Errors </h2> <p>Exception actions are functions that can be triggered by the error page, it is basically a list of maps defining a <code class="inline">label</code> and a <code class="inline">handler</code> to be executed.</p>
<p>It is rendered in the error page as a collection of buttons and follows the format of: <code class="inline">[%{label: String.t(), handler: {module(), function :: atom(), args :: []}}]</code>.</p>
<p>If we wanted to return some actions for an <code class="inline">MyApp.SomethingNotFoundError</code> we would implement <a href="../../plug/plug.exception"><code class="inline">Plug.Exception</code></a> like this:</p>
<pre data-language="elixir">defimpl Plug.Exception, for: MyApp.SomethingNotFoundError do
  def status(_exception), do: 404
  def actions(_exception), do: [%{
      label: "Run seeds",
      handler: {Code, :eval_file, "priv/repo/seeds.exs"}
    }]
end</pre><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://hexdocs.pm/phoenix/1.5.7/custom_error_pages.html" class="_attribution-link" target="_blank">https://hexdocs.pm/phoenix/1.5.7/custom_error_pages.html</a>
  </p>
</div>
