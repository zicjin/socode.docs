<h1 id="dis-disassembler-for-python-bytecode">dis — Disassembler for Python bytecode</h1> <p id="module-dis"><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/dis.py">Lib/dis.py</a></p>  <p>The <a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code>dis</code></a> module supports the analysis of CPython <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> by disassembling it. The CPython bytecode which this module takes as an input is defined in the file <code>Include/opcode.h</code> and used by the compiler and the interpreter.</p> <div class="impl-detail compound"> <p class="compound-first"><strong>CPython implementation detail:</strong> Bytecode is an implementation detail of the CPython interpreter. No guarantees are made that bytecode will not be added, removed, or changed between versions of Python. Use of this module should not be considered to work across Python VMs or Python releases.</p> <div class="compound-last versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Use 2 bytes for each instruction. Previously the number of bytes varied by instruction.</p> </div> </div> <p>Example: Given the function <code>myfunc()</code>:</p> <pre data-language="python">def myfunc(alist):
    return len(alist)
</pre> <p>the following command can be used to display the disassembly of <code>myfunc()</code>:</p> <pre data-language="python">&gt;&gt;&gt; dis.dis(myfunc)
  2           0 LOAD_GLOBAL              0 (len)
              2 LOAD_FAST                0 (alist)
              4 CALL_FUNCTION            1
              6 RETURN_VALUE
</pre> <p>(The “2” is a line number).</p>  <h2 id="bytecode-analysis">Bytecode analysis</h2> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> <p>The bytecode analysis API allows pieces of Python code to be wrapped in a <a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code>Bytecode</code></a> object that provides easy access to details of the compiled code.</p> <dl class="class"> <dt id="dis.Bytecode">
<code>class dis.Bytecode(x, *, first_line=None, current_offset=None)</code> </dt> <dd>
<p>Analyse the bytecode corresponding to a function, generator, asynchronous generator, coroutine, method, string of source code, or a code object (as returned by <a class="reference internal" href="functions#compile" title="compile"><code>compile()</code></a>).</p> <p>This is a convenience wrapper around many of the functions listed below, most notably <a class="reference internal" href="#dis.get_instructions" title="dis.get_instructions"><code>get_instructions()</code></a>, as iterating over a <a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code>Bytecode</code></a> instance yields the bytecode operations as <a class="reference internal" href="#dis.Instruction" title="dis.Instruction"><code>Instruction</code></a> instances.</p> <p>If <em>first_line</em> is not <code>None</code>, it indicates the line number that should be reported for the first source line in the disassembled code. Otherwise, the source line information (if any) is taken directly from the disassembled code object.</p> <p>If <em>current_offset</em> is not <code>None</code>, it refers to an instruction offset in the disassembled code. Setting this means <a class="reference internal" href="#dis.Bytecode.dis" title="dis.Bytecode.dis"><code>dis()</code></a> will display a “current instruction” marker against the specified opcode.</p> <dl class="method"> <dt id="dis.Bytecode.from_traceback">
<code>classmethod from_traceback(tb)</code> </dt> <dd>
<p>Construct a <a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code>Bytecode</code></a> instance from the given traceback, setting <em>current_offset</em> to the instruction responsible for the exception.</p> </dd>
</dl> <dl class="data"> <dt id="dis.Bytecode.codeobj">
<code>codeobj</code> </dt> <dd>
<p>The compiled code object.</p> </dd>
</dl> <dl class="data"> <dt id="dis.Bytecode.first_line">
<code>first_line</code> </dt> <dd>
<p>The first source line of the code object (if available)</p> </dd>
</dl> <dl class="method"> <dt id="dis.Bytecode.dis">
<code>dis()</code> </dt> <dd>
<p>Return a formatted view of the bytecode operations (the same as printed by <a class="reference internal" href="#dis.dis" title="dis.dis"><code>dis.dis()</code></a>, but returned as a multi-line string).</p> </dd>
</dl> <dl class="method"> <dt id="dis.Bytecode.info">
<code>info()</code> </dt> <dd>
<p>Return a formatted multi-line string with detailed information about the code object, like <a class="reference internal" href="#dis.code_info" title="dis.code_info"><code>code_info()</code></a>.</p> </dd>
</dl> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>This can now handle coroutine and asynchronous generator objects.</p> </div> </dd>
</dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; bytecode = dis.Bytecode(myfunc)
&gt;&gt;&gt; for instr in bytecode:
...     print(instr.opname)
...
LOAD_GLOBAL
LOAD_FAST
CALL_FUNCTION
RETURN_VALUE
</pre>   <h2 id="analysis-functions">Analysis functions</h2> <p>The <a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code>dis</code></a> module also defines the following analysis functions that convert the input directly to the desired output. They can be useful if only a single operation is being performed, so the intermediate analysis object isn’t useful:</p> <dl class="function"> <dt id="dis.code_info">
<code>dis.code_info(x)</code> </dt> <dd>
<p>Return a formatted multi-line string with detailed code object information for the supplied function, generator, asynchronous generator, coroutine, method, source code string or code object.</p> <p>Note that the exact contents of code info strings are highly implementation dependent and they may change arbitrarily across Python VMs or Python releases.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>This can now handle coroutine and asynchronous generator objects.</p> </div> </dd>
</dl> <dl class="function"> <dt id="dis.show_code">
<code>dis.show_code(x, *, file=None)</code> </dt> <dd>
<p>Print detailed code object information for the supplied function, method, source code string or code object to <em>file</em> (or <code>sys.stdout</code> if <em>file</em> is not specified).</p> <p>This is a convenient shorthand for <code>print(code_info(x), file=file)</code>, intended for interactive exploration at the interpreter prompt.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>Added <em>file</em> parameter.</p> </div> </dd>
</dl> <dl class="function"> <dt id="dis.dis">
<code>dis.dis(x=None, *, file=None, depth=None)</code> </dt> <dd>
<p>Disassemble the <em>x</em> object. <em>x</em> can denote either a module, a class, a method, a function, a generator, an asynchronous generator, a coroutine, a code object, a string of source code or a byte sequence of raw bytecode. For a module, it disassembles all functions. For a class, it disassembles all methods (including class and static methods). For a code object or sequence of raw bytecode, it prints one line per bytecode instruction. It also recursively disassembles nested code objects (the code of comprehensions, generator expressions and nested functions, and the code used for building nested classes). Strings are first compiled to code objects with the <a class="reference internal" href="functions#compile" title="compile"><code>compile()</code></a> built-in function before being disassembled. If no object is provided, this function disassembles the last traceback.</p> <p>The disassembly is written as text to the supplied <em>file</em> argument if provided and to <code>sys.stdout</code> otherwise.</p> <p>The maximal depth of recursion is limited by <em>depth</em> unless it is <code>None</code>. <code>depth=0</code> means no recursion.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>Added <em>file</em> parameter.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>Implemented recursive disassembling and added <em>depth</em> parameter.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>This can now handle coroutine and asynchronous generator objects.</p> </div> </dd>
</dl> <dl class="function"> <dt id="dis.distb">
<code>dis.distb(tb=None, *, file=None)</code> </dt> <dd>
<p>Disassemble the top-of-stack function of a traceback, using the last traceback if none was passed. The instruction causing the exception is indicated.</p> <p>The disassembly is written as text to the supplied <em>file</em> argument if provided and to <code>sys.stdout</code> otherwise.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>Added <em>file</em> parameter.</p> </div> </dd>
</dl> <dl class="function"> <dt id="dis.disassemble">
<code>dis.disassemble(code, lasti=-1, *, file=None)</code> </dt> <dt id="dis.disco">
<code>dis.disco(code, lasti=-1, *, file=None)</code> </dt> <dd>
<p>Disassemble a code object, indicating the last instruction if <em>lasti</em> was provided. The output is divided in the following columns:</p> <ol class="arabic simple"> <li>the line number, for the first instruction of each line</li> <li>the current instruction, indicated as <code>--&gt;</code>,</li> <li>a labelled instruction, indicated with <code>&gt;&gt;</code>,</li> <li>the address of the instruction,</li> <li>the operation code name,</li> <li>operation parameters, and</li> <li>interpretation of the parameters in parentheses.</li> </ol> <p>The parameter interpretation recognizes local and global variable names, constant values, branch targets, and compare operators.</p> <p>The disassembly is written as text to the supplied <em>file</em> argument if provided and to <code>sys.stdout</code> otherwise.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>Added <em>file</em> parameter.</p> </div> </dd>
</dl> <dl class="function"> <dt id="dis.get_instructions">
<code>dis.get_instructions(x, *, first_line=None)</code> </dt> <dd>
<p>Return an iterator over the instructions in the supplied function, method, source code string or code object.</p> <p>The iterator generates a series of <a class="reference internal" href="#dis.Instruction" title="dis.Instruction"><code>Instruction</code></a> named tuples giving the details of each operation in the supplied code.</p> <p>If <em>first_line</em> is not <code>None</code>, it indicates the line number that should be reported for the first source line in the disassembled code. Otherwise, the source line information (if any) is taken directly from the disassembled code object.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="dis.findlinestarts">
<code>dis.findlinestarts(code)</code> </dt> <dd>
<p>This generator function uses the <code>co_firstlineno</code> and <code>co_lnotab</code> attributes of the code object <em>code</em> to find the offsets which are starts of lines in the source code. They are generated as <code>(offset, lineno)</code> pairs. See <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Objects/lnotab_notes.txt">Objects/lnotab_notes.txt</a> for the <code>co_lnotab</code> format and how to decode it.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Line numbers can be decreasing. Before, they were always increasing.</p> </div> </dd>
</dl> <dl class="function"> <dt id="dis.findlabels">
<code>dis.findlabels(code)</code> </dt> <dd>
<p>Detect all offsets in the raw compiled bytecode string <em>code</em> which are jump targets, and return a list of these offsets.</p> </dd>
</dl> <dl class="function"> <dt id="dis.stack_effect">
<code>dis.stack_effect(opcode, oparg=None, *, jump=None)</code> </dt> <dd>
<p>Compute the stack effect of <em>opcode</em> with argument <em>oparg</em>.</p> <p>If the code has a jump target and <em>jump</em> is <code>True</code>, <a class="reference internal" href="#dis.stack_effect" title="dis.stack_effect"><code>stack_effect()</code></a> will return the stack effect of jumping. If <em>jump</em> is <code>False</code>, it will return the stack effect of not jumping. And if <em>jump</em> is <code>None</code> (default), it will return the maximal stack effect of both cases.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Added <em>jump</em> parameter.</p> </div> </dd>
</dl>   <h2 id="bytecodes">Python Bytecode Instructions</h2> <p id="python-bytecode-instructions">The <a class="reference internal" href="#dis.get_instructions" title="dis.get_instructions"><code>get_instructions()</code></a> function and <a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code>Bytecode</code></a> class provide details of bytecode instructions as <a class="reference internal" href="#dis.Instruction" title="dis.Instruction"><code>Instruction</code></a> instances:</p> <dl class="class"> <dt id="dis.Instruction">
<code>class dis.Instruction</code> </dt> <dd>
<p>Details for a bytecode operation</p> <dl class="data"> <dt id="dis.Instruction.opcode">
<code>opcode</code> </dt> <dd>
<p>numeric code for operation, corresponding to the opcode values listed below and the bytecode values in the <a class="reference internal" href="#opcode-collections"><span class="std std-ref">Opcode collections</span></a>.</p> </dd>
</dl> <dl class="data"> <dt id="dis.Instruction.opname">
<code>opname</code> </dt> <dd>
<p>human readable name for operation</p> </dd>
</dl> <dl class="data"> <dt id="dis.Instruction.arg">
<code>arg</code> </dt> <dd>
<p>numeric argument to operation (if any), otherwise <code>None</code></p> </dd>
</dl> <dl class="data"> <dt id="dis.Instruction.argval">
<code>argval</code> </dt> <dd>
<p>resolved arg value (if known), otherwise same as arg</p> </dd>
</dl> <dl class="data"> <dt id="dis.Instruction.argrepr">
<code>argrepr</code> </dt> <dd>
<p>human readable description of operation argument</p> </dd>
</dl> <dl class="data"> <dt id="dis.Instruction.offset">
<code>offset</code> </dt> <dd>
<p>start index of operation within bytecode sequence</p> </dd>
</dl> <dl class="data"> <dt id="dis.Instruction.starts_line">
<code>starts_line</code> </dt> <dd>
<p>line started by this opcode (if any), otherwise <code>None</code></p> </dd>
</dl> <dl class="data"> <dt id="dis.Instruction.is_jump_target">
<code>is_jump_target</code> </dt> <dd>
<p><code>True</code> if other code jumps to here, otherwise <code>False</code></p> </dd>
</dl> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> </dd>
</dl> <p>The Python compiler currently generates the following bytecode instructions.</p> <p><strong>General instructions</strong></p> <dl class="opcode"> <dt id="opcode-NOP">
<code>NOP</code> </dt> <dd>
<p>Do nothing code. Used as a placeholder by the bytecode optimizer.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-POP_TOP">
<code>POP_TOP</code> </dt> <dd>
<p>Removes the top-of-stack (TOS) item.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-ROT_TWO">
<code>ROT_TWO</code> </dt> <dd>
<p>Swaps the two top-most stack items.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-ROT_THREE">
<code>ROT_THREE</code> </dt> <dd>
<p>Lifts second and third stack item one position up, moves top down to position three.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-ROT_FOUR">
<code>ROT_FOUR</code> </dt> <dd>
<p>Lifts second, third and fourth stack items one position up, moves top down to position four.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.8.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DUP_TOP">
<code>DUP_TOP</code> </dt> <dd>
<p>Duplicates the reference on top of the stack.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DUP_TOP_TWO">
<code>DUP_TOP_TWO</code> </dt> <dd>
<p>Duplicates the two references on top of the stack, leaving them in the same order.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> </dd>
</dl> <p><strong>Unary operations</strong></p> <p>Unary operations take the top of the stack, apply the operation, and push the result back on the stack.</p> <dl class="opcode"> <dt id="opcode-UNARY_POSITIVE">
<code>UNARY_POSITIVE</code> </dt> <dd>
<p>Implements <code>TOS = +TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-UNARY_NEGATIVE">
<code>UNARY_NEGATIVE</code> </dt> <dd>
<p>Implements <code>TOS = -TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-UNARY_NOT">
<code>UNARY_NOT</code> </dt> <dd>
<p>Implements <code>TOS = not TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-UNARY_INVERT">
<code>UNARY_INVERT</code> </dt> <dd>
<p>Implements <code>TOS = ~TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-GET_ITER">
<code>GET_ITER</code> </dt> <dd>
<p>Implements <code>TOS = iter(TOS)</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-GET_YIELD_FROM_ITER">
<code>GET_YIELD_FROM_ITER</code> </dt> <dd>
<p>If <code>TOS</code> is a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-generator-iterator"><span class="xref std std-term">generator iterator</span></a> or <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a> object it is left as is. Otherwise, implements <code>TOS = iter(TOS)</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <p><strong>Binary operations</strong></p> <p>Binary operations remove the top of the stack (TOS) and the second top-most stack item (TOS1) from the stack. They perform the operation, and put the result back on the stack.</p> <dl class="opcode"> <dt id="opcode-BINARY_POWER">
<code>BINARY_POWER</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 ** TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_MULTIPLY">
<code>BINARY_MULTIPLY</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 * TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_MATRIX_MULTIPLY">
<code>BINARY_MATRIX_MULTIPLY</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 @ TOS</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_FLOOR_DIVIDE">
<code>BINARY_FLOOR_DIVIDE</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 // TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_TRUE_DIVIDE">
<code>BINARY_TRUE_DIVIDE</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 / TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_MODULO">
<code>BINARY_MODULO</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 % TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_ADD">
<code>BINARY_ADD</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 + TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_SUBTRACT">
<code>BINARY_SUBTRACT</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 - TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_SUBSCR">
<code>BINARY_SUBSCR</code> </dt> <dd>
<p>Implements <code>TOS = TOS1[TOS]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_LSHIFT">
<code>BINARY_LSHIFT</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 &lt;&lt; TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_RSHIFT">
<code>BINARY_RSHIFT</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 &gt;&gt; TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_AND">
<code>BINARY_AND</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 &amp; TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_XOR">
<code>BINARY_XOR</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 ^ TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_OR">
<code>BINARY_OR</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 | TOS</code>.</p> </dd>
</dl> <p><strong>In-place operations</strong></p> <p>In-place operations are like binary operations, in that they remove TOS and TOS1, and push the result back on the stack, but the operation is done in-place when TOS1 supports it, and the resulting TOS may be (but does not have to be) the original TOS1.</p> <dl class="opcode"> <dt id="opcode-INPLACE_POWER">
<code>INPLACE_POWER</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 ** TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_MULTIPLY">
<code>INPLACE_MULTIPLY</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 * TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_MATRIX_MULTIPLY">
<code>INPLACE_MATRIX_MULTIPLY</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 @ TOS</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_FLOOR_DIVIDE">
<code>INPLACE_FLOOR_DIVIDE</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 // TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_TRUE_DIVIDE">
<code>INPLACE_TRUE_DIVIDE</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 / TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_MODULO">
<code>INPLACE_MODULO</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 % TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_ADD">
<code>INPLACE_ADD</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 + TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_SUBTRACT">
<code>INPLACE_SUBTRACT</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 - TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_LSHIFT">
<code>INPLACE_LSHIFT</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 &lt;&lt; TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_RSHIFT">
<code>INPLACE_RSHIFT</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 &gt;&gt; TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_AND">
<code>INPLACE_AND</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 &amp; TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_XOR">
<code>INPLACE_XOR</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 ^ TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_OR">
<code>INPLACE_OR</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 | TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-STORE_SUBSCR">
<code>STORE_SUBSCR</code> </dt> <dd>
<p>Implements <code>TOS1[TOS] = TOS2</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DELETE_SUBSCR">
<code>DELETE_SUBSCR</code> </dt> <dd>
<p>Implements <code>del TOS1[TOS]</code>.</p> </dd>
</dl> <p><strong>Coroutine opcodes</strong></p> <dl class="opcode"> <dt id="opcode-GET_AWAITABLE">
<code>GET_AWAITABLE</code> </dt> <dd>
<p>Implements <code>TOS = get_awaitable(TOS)</code>, where <code>get_awaitable(o)</code> returns <code>o</code> if <code>o</code> is a coroutine object or a generator object with the CO_ITERABLE_COROUTINE flag, or resolves <code>o.__await__</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-GET_AITER">
<code>GET_AITER</code> </dt> <dd>
<p>Implements <code>TOS = TOS.__aiter__()</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>Returning awaitable objects from <code>__aiter__</code> is no longer supported.</p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-GET_ANEXT">
<code>GET_ANEXT</code> </dt> <dd>
<p>Implements <code>PUSH(get_awaitable(TOS.__anext__()))</code>. See <code>GET_AWAITABLE</code> for details about <code>get_awaitable</code></p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-END_ASYNC_FOR">
<code>END_ASYNC_FOR</code> </dt> <dd>
<p>Terminates an <a class="reference internal" href="https://docs.python.org/3.9/reference/compound_stmts.html#async-for"><code>async for</code></a> loop. Handles an exception raised when awaiting a next item. If TOS is <a class="reference internal" href="exceptions#StopAsyncIteration" title="StopAsyncIteration"><code>StopAsyncIteration</code></a> pop 7 values from the stack and restore the exception state using the second three of them. Otherwise re-raise the exception using the three values from the stack. An exception handler block is removed from the block stack.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.8.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BEFORE_ASYNC_WITH">
<code>BEFORE_ASYNC_WITH</code> </dt> <dd>
<p>Resolves <code>__aenter__</code> and <code>__aexit__</code> from the object on top of the stack. Pushes <code>__aexit__</code> and result of <code>__aenter__()</code> to the stack.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-SETUP_ASYNC_WITH">
<code>SETUP_ASYNC_WITH</code> </dt> <dd>
<p>Creates a new frame object.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <p><strong>Miscellaneous opcodes</strong></p> <dl class="opcode"> <dt id="opcode-PRINT_EXPR">
<code>PRINT_EXPR</code> </dt> <dd>
<p>Implements the expression statement for the interactive mode. TOS is removed from the stack and printed. In non-interactive mode, an expression statement is terminated with <a class="reference internal" href="#opcode-POP_TOP"><code>POP_TOP</code></a>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-SET_ADD">
<code>SET_ADD(i)</code> </dt> <dd>
<p>Calls <code>set.add(TOS1[-i], TOS)</code>. Used to implement set comprehensions.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LIST_APPEND">
<code>LIST_APPEND(i)</code> </dt> <dd>
<p>Calls <code>list.append(TOS1[-i], TOS)</code>. Used to implement list comprehensions.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-MAP_ADD">
<code>MAP_ADD(i)</code> </dt> <dd>
<p>Calls <code>dict.__setitem__(TOS1[-i], TOS1, TOS)</code>. Used to implement dict comprehensions.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.1.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Map value is TOS and map key is TOS1. Before, those were reversed.</p> </div> </dd>
</dl> <p>For all of the <a class="reference internal" href="#opcode-SET_ADD"><code>SET_ADD</code></a>, <a class="reference internal" href="#opcode-LIST_APPEND"><code>LIST_APPEND</code></a> and <a class="reference internal" href="#opcode-MAP_ADD"><code>MAP_ADD</code></a> instructions, while the added value or key/value pair is popped off, the container object remains on the stack so that it is available for further iterations of the loop.</p> <dl class="opcode"> <dt id="opcode-RETURN_VALUE">
<code>RETURN_VALUE</code> </dt> <dd>
<p>Returns with TOS to the caller of the function.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-YIELD_VALUE">
<code>YIELD_VALUE</code> </dt> <dd>
<p>Pops TOS and yields it from a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-generator"><span class="xref std std-term">generator</span></a>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-YIELD_FROM">
<code>YIELD_FROM</code> </dt> <dd>
<p>Pops TOS and delegates to it as a subiterator from a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-generator"><span class="xref std std-term">generator</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-SETUP_ANNOTATIONS">
<code>SETUP_ANNOTATIONS</code> </dt> <dd>
<p>Checks whether <code>__annotations__</code> is defined in <code>locals()</code>, if not it is set up to an empty <code>dict</code>. This opcode is only emitted if a class or module body contains <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-variable-annotation"><span class="xref std std-term">variable annotations</span></a> statically.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-IMPORT_STAR">
<code>IMPORT_STAR</code> </dt> <dd>
<p>Loads all symbols not starting with <code>'_'</code> directly from the module TOS to the local namespace. The module is popped after loading all names. This opcode implements <code>from module import *</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-POP_BLOCK">
<code>POP_BLOCK</code> </dt> <dd>
<p>Removes one block from the block stack. Per frame, there is a stack of blocks, denoting <a class="reference internal" href="https://docs.python.org/3.9/reference/compound_stmts.html#try"><code>try</code></a> statements, and such.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-POP_EXCEPT">
<code>POP_EXCEPT</code> </dt> <dd>
<p>Removes one block from the block stack. The popped block must be an exception handler block, as implicitly created when entering an except handler. In addition to popping extraneous values from the frame stack, the last three popped values are used to restore the exception state.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-RERAISE">
<code>RERAISE</code> </dt> <dd>
<p>Re-raises the exception currently on top of the stack.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-WITH_EXCEPT_START">
<code>WITH_EXCEPT_START</code> </dt> <dd>
<p>Calls the function in position 7 on the stack with the top three items on the stack as arguments. Used to implement the call <code>context_manager.__exit__(*exc_info())</code> when an exception has occurred in a <a class="reference internal" href="https://docs.python.org/3.9/reference/compound_stmts.html#with"><code>with</code></a> statement.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_ASSERTION_ERROR">
<code>LOAD_ASSERTION_ERROR</code> </dt> <dd>
<p>Pushes <a class="reference internal" href="exceptions#AssertionError" title="AssertionError"><code>AssertionError</code></a> onto the stack. Used by the <a class="reference internal" href="https://docs.python.org/3.9/reference/simple_stmts.html#assert"><code>assert</code></a> statement.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_BUILD_CLASS">
<code>LOAD_BUILD_CLASS</code> </dt> <dd>
<p>Pushes <code>builtins.__build_class__()</code> onto the stack. It is later called by <a class="reference internal" href="#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a> to construct a class.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-SETUP_WITH">
<code>SETUP_WITH(delta)</code> </dt> <dd>
<p>This opcode performs several operations before a with block starts. First, it loads <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__exit__" title="object.__exit__"><code>__exit__()</code></a> from the context manager and pushes it onto the stack for later use by <code>WITH_CLEANUP_START</code>. Then, <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__enter__" title="object.__enter__"><code>__enter__()</code></a> is called, and a finally block pointing to <em>delta</em> is pushed. Finally, the result of calling the <code>__enter__()</code> method is pushed onto the stack. The next opcode will either ignore it (<a class="reference internal" href="#opcode-POP_TOP"><code>POP_TOP</code></a>), or store it in (a) variable(s) (<a class="reference internal" href="#opcode-STORE_FAST"><code>STORE_FAST</code></a>, <a class="reference internal" href="#opcode-STORE_NAME"><code>STORE_NAME</code></a>, or <a class="reference internal" href="#opcode-UNPACK_SEQUENCE"><code>UNPACK_SEQUENCE</code></a>).</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> </dd>
</dl> <p>All of the following opcodes use their arguments.</p> <dl class="opcode"> <dt id="opcode-STORE_NAME">
<code>STORE_NAME(namei)</code> </dt> <dd>
<p>Implements <code>name = TOS</code>. <em>namei</em> is the index of <em>name</em> in the attribute <code>co_names</code> of the code object. The compiler tries to use <a class="reference internal" href="#opcode-STORE_FAST"><code>STORE_FAST</code></a> or <a class="reference internal" href="#opcode-STORE_GLOBAL"><code>STORE_GLOBAL</code></a> if possible.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DELETE_NAME">
<code>DELETE_NAME(namei)</code> </dt> <dd>
<p>Implements <code>del name</code>, where <em>namei</em> is the index into <code>co_names</code> attribute of the code object.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-UNPACK_SEQUENCE">
<code>UNPACK_SEQUENCE(count)</code> </dt> <dd>
<p>Unpacks TOS into <em>count</em> individual values, which are put onto the stack right-to-left.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-UNPACK_EX">
<code>UNPACK_EX(counts)</code> </dt> <dd>
<p>Implements assignment with a starred target: Unpacks an iterable in TOS into individual values, where the total number of values can be smaller than the number of items in the iterable: one of the new values will be a list of all leftover items.</p> <p>The low byte of <em>counts</em> is the number of values before the list value, the high byte of <em>counts</em> the number of values after it. The resulting values are put onto the stack right-to-left.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-STORE_ATTR">
<code>STORE_ATTR(namei)</code> </dt> <dd>
<p>Implements <code>TOS.name = TOS1</code>, where <em>namei</em> is the index of name in <code>co_names</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DELETE_ATTR">
<code>DELETE_ATTR(namei)</code> </dt> <dd>
<p>Implements <code>del TOS.name</code>, using <em>namei</em> as index into <code>co_names</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-STORE_GLOBAL">
<code>STORE_GLOBAL(namei)</code> </dt> <dd>
<p>Works as <a class="reference internal" href="#opcode-STORE_NAME"><code>STORE_NAME</code></a>, but stores the name as a global.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DELETE_GLOBAL">
<code>DELETE_GLOBAL(namei)</code> </dt> <dd>
<p>Works as <a class="reference internal" href="#opcode-DELETE_NAME"><code>DELETE_NAME</code></a>, but deletes a global name.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_CONST">
<code>LOAD_CONST(consti)</code> </dt> <dd>
<p>Pushes <code>co_consts[consti]</code> onto the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_NAME">
<code>LOAD_NAME(namei)</code> </dt> <dd>
<p>Pushes the value associated with <code>co_names[namei]</code> onto the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_TUPLE">
<code>BUILD_TUPLE(count)</code> </dt> <dd>
<p>Creates a tuple consuming <em>count</em> items from the stack, and pushes the resulting tuple onto the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_LIST">
<code>BUILD_LIST(count)</code> </dt> <dd>
<p>Works as <a class="reference internal" href="#opcode-BUILD_TUPLE"><code>BUILD_TUPLE</code></a>, but creates a list.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_SET">
<code>BUILD_SET(count)</code> </dt> <dd>
<p>Works as <a class="reference internal" href="#opcode-BUILD_TUPLE"><code>BUILD_TUPLE</code></a>, but creates a set.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_MAP">
<code>BUILD_MAP(count)</code> </dt> <dd>
<p>Pushes a new dictionary object onto the stack. Pops <code>2 * count</code> items so that the dictionary holds <em>count</em> entries: <code>{..., TOS3: TOS2, TOS1: TOS}</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>The dictionary is created from stack items instead of creating an empty dictionary pre-sized to hold <em>count</em> items.</p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_CONST_KEY_MAP">
<code>BUILD_CONST_KEY_MAP(count)</code> </dt> <dd>
<p>The version of <a class="reference internal" href="#opcode-BUILD_MAP"><code>BUILD_MAP</code></a> specialized for constant keys. Pops the top element on the stack which contains a tuple of keys, then starting from <code>TOS1</code>, pops <em>count</em> values to form values in the built dictionary.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_STRING">
<code>BUILD_STRING(count)</code> </dt> <dd>
<p>Concatenates <em>count</em> strings from the stack and pushes the resulting string onto the stack.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LIST_TO_TUPLE">
<code>LIST_TO_TUPLE</code> </dt> <dd>
<p>Pops a list from the stack and pushes a tuple containing the same values.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LIST_EXTEND">
<code>LIST_EXTEND(i)</code> </dt> <dd>
<p>Calls <code>list.extend(TOS1[-i], TOS)</code>. Used to build lists.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-SET_UPDATE">
<code>SET_UPDATE(i)</code> </dt> <dd>
<p>Calls <code>set.update(TOS1[-i], TOS)</code>. Used to build sets.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DICT_UPDATE">
<code>DICT_UPDATE(i)</code> </dt> <dd>
<p>Calls <code>dict.update(TOS1[-i], TOS)</code>. Used to build dicts.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DICT_MERGE">
<code>DICT_MERGE</code> </dt> <dd>
<p>Like <a class="reference internal" href="#opcode-DICT_UPDATE"><code>DICT_UPDATE</code></a> but raises an exception for duplicate keys.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_ATTR">
<code>LOAD_ATTR(namei)</code> </dt> <dd>
<p>Replaces TOS with <code>getattr(TOS, co_names[namei])</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-COMPARE_OP">
<code>COMPARE_OP(opname)</code> </dt> <dd>
<p>Performs a Boolean operation. The operation name can be found in <code>cmp_op[opname]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-IS_OP">
<code>IS_OP(invert)</code> </dt> <dd>
<p>Performs <code>is</code> comparison, or <code>is not</code> if <code>invert</code> is 1.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-CONTAINS_OP">
<code>CONTAINS_OP(invert)</code> </dt> <dd>
<p>Performs <code>in</code> comparison, or <code>not in</code> if <code>invert</code> is 1.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-IMPORT_NAME">
<code>IMPORT_NAME(namei)</code> </dt> <dd>
<p>Imports the module <code>co_names[namei]</code>. TOS and TOS1 are popped and provide the <em>fromlist</em> and <em>level</em> arguments of <a class="reference internal" href="functions#__import__" title="__import__"><code>__import__()</code></a>. The module object is pushed onto the stack. The current namespace is not affected: for a proper import statement, a subsequent <a class="reference internal" href="#opcode-STORE_FAST"><code>STORE_FAST</code></a> instruction modifies the namespace.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-IMPORT_FROM">
<code>IMPORT_FROM(namei)</code> </dt> <dd>
<p>Loads the attribute <code>co_names[namei]</code> from the module found in TOS. The resulting object is pushed onto the stack, to be subsequently stored by a <a class="reference internal" href="#opcode-STORE_FAST"><code>STORE_FAST</code></a> instruction.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-JUMP_FORWARD">
<code>JUMP_FORWARD(delta)</code> </dt> <dd>
<p>Increments bytecode counter by <em>delta</em>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-POP_JUMP_IF_TRUE">
<code>POP_JUMP_IF_TRUE(target)</code> </dt> <dd>
<p>If TOS is true, sets the bytecode counter to <em>target</em>. TOS is popped.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.1.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-POP_JUMP_IF_FALSE">
<code>POP_JUMP_IF_FALSE(target)</code> </dt> <dd>
<p>If TOS is false, sets the bytecode counter to <em>target</em>. TOS is popped.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.1.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-JUMP_IF_NOT_EXC_MATCH">
<code>JUMP_IF_NOT_EXC_MATCH(target)</code> </dt> <dd>
<p>Tests whether the second value on the stack is an exception matching TOS, and jumps if it is not. Pops two values from the stack.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-JUMP_IF_TRUE_OR_POP">
<code>JUMP_IF_TRUE_OR_POP(target)</code> </dt> <dd>
<p>If TOS is true, sets the bytecode counter to <em>target</em> and leaves TOS on the stack. Otherwise (TOS is false), TOS is popped.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.1.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-JUMP_IF_FALSE_OR_POP">
<code>JUMP_IF_FALSE_OR_POP(target)</code> </dt> <dd>
<p>If TOS is false, sets the bytecode counter to <em>target</em> and leaves TOS on the stack. Otherwise (TOS is true), TOS is popped.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.1.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-JUMP_ABSOLUTE">
<code>JUMP_ABSOLUTE(target)</code> </dt> <dd>
<p>Set bytecode counter to <em>target</em>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-FOR_ITER">
<code>FOR_ITER(delta)</code> </dt> <dd>
<p>TOS is an <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>. Call its <a class="reference internal" href="stdtypes#iterator.__next__" title="iterator.__next__"><code>__next__()</code></a> method. If this yields a new value, push it on the stack (leaving the iterator below it). If the iterator indicates it is exhausted, TOS is popped, and the byte code counter is incremented by <em>delta</em>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_GLOBAL">
<code>LOAD_GLOBAL(namei)</code> </dt> <dd>
<p>Loads the global named <code>co_names[namei]</code> onto the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-SETUP_FINALLY">
<code>SETUP_FINALLY(delta)</code> </dt> <dd>
<p>Pushes a try block from a try-finally or try-except clause onto the block stack. <em>delta</em> points to the finally block or the first except block.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_FAST">
<code>LOAD_FAST(var_num)</code> </dt> <dd>
<p>Pushes a reference to the local <code>co_varnames[var_num]</code> onto the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-STORE_FAST">
<code>STORE_FAST(var_num)</code> </dt> <dd>
<p>Stores TOS into the local <code>co_varnames[var_num]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DELETE_FAST">
<code>DELETE_FAST(var_num)</code> </dt> <dd>
<p>Deletes local <code>co_varnames[var_num]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_CLOSURE">
<code>LOAD_CLOSURE(i)</code> </dt> <dd>
<p>Pushes a reference to the cell contained in slot <em>i</em> of the cell and free variable storage. The name of the variable is <code>co_cellvars[i]</code> if <em>i</em> is less than the length of <em>co_cellvars</em>. Otherwise it is <code>co_freevars[i -
len(co_cellvars)]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_DEREF">
<code>LOAD_DEREF(i)</code> </dt> <dd>
<p>Loads the cell contained in slot <em>i</em> of the cell and free variable storage. Pushes a reference to the object the cell contains on the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_CLASSDEREF">
<code>LOAD_CLASSDEREF(i)</code> </dt> <dd>
<p>Much like <a class="reference internal" href="#opcode-LOAD_DEREF"><code>LOAD_DEREF</code></a> but first checks the locals dictionary before consulting the cell. This is used for loading free variables in class bodies.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-STORE_DEREF">
<code>STORE_DEREF(i)</code> </dt> <dd>
<p>Stores TOS into the cell contained in slot <em>i</em> of the cell and free variable storage.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DELETE_DEREF">
<code>DELETE_DEREF(i)</code> </dt> <dd>
<p>Empties the cell contained in slot <em>i</em> of the cell and free variable storage. Used by the <a class="reference internal" href="https://docs.python.org/3.9/reference/simple_stmts.html#del"><code>del</code></a> statement.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-RAISE_VARARGS">
<code>RAISE_VARARGS(argc)</code> </dt> <dd>
<p>Raises an exception using one of the 3 forms of the <code>raise</code> statement, depending on the value of <em>argc</em>:</p> <ul class="simple"> <li>0: <code>raise</code> (re-raise previous exception)</li> <li>1: <code>raise TOS</code> (raise exception instance or type at <code>TOS</code>)</li> <li>2: <code>raise TOS1 from TOS</code> (raise exception instance or type at <code>TOS1</code> with <code>__cause__</code> set to <code>TOS</code>)</li> </ul> </dd>
</dl> <dl class="opcode"> <dt id="opcode-CALL_FUNCTION">
<code>CALL_FUNCTION(argc)</code> </dt> <dd>
<p>Calls a callable object with positional arguments. <em>argc</em> indicates the number of positional arguments. The top of the stack contains positional arguments, with the right-most argument on top. Below the arguments is a callable object to call. <code>CALL_FUNCTION</code> pops all arguments and the callable object off the stack, calls the callable object with those arguments, and pushes the return value returned by the callable object.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>This opcode is used only for calls with positional arguments.</p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-CALL_FUNCTION_KW">
<code>CALL_FUNCTION_KW(argc)</code> </dt> <dd>
<p>Calls a callable object with positional (if any) and keyword arguments. <em>argc</em> indicates the total number of positional and keyword arguments. The top element on the stack contains a tuple with the names of the keyword arguments, which must be strings. Below that are the values for the keyword arguments, in the order corresponding to the tuple. Below that are positional arguments, with the right-most parameter on top. Below the arguments is a callable object to call. <code>CALL_FUNCTION_KW</code> pops all arguments and the callable object off the stack, calls the callable object with those arguments, and pushes the return value returned by the callable object.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Keyword arguments are packed in a tuple instead of a dictionary, <em>argc</em> indicates the total number of arguments.</p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-CALL_FUNCTION_EX">
<code>CALL_FUNCTION_EX(flags)</code> </dt> <dd>
<p>Calls a callable object with variable set of positional and keyword arguments. If the lowest bit of <em>flags</em> is set, the top of the stack contains a mapping object containing additional keyword arguments. Before the callable is called, the mapping object and iterable object are each “unpacked” and their contents passed in as keyword and positional arguments respectively. <code>CALL_FUNCTION_EX</code> pops all arguments and the callable object off the stack, calls the callable object with those arguments, and pushes the return value returned by the callable object.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_METHOD">
<code>LOAD_METHOD(namei)</code> </dt> <dd>
<p>Loads a method named <code>co_names[namei]</code> from the TOS object. TOS is popped. This bytecode distinguishes two cases: if TOS has a method with the correct name, the bytecode pushes the unbound method and TOS. TOS will be used as the first argument (<code>self</code>) by <a class="reference internal" href="#opcode-CALL_METHOD"><code>CALL_METHOD</code></a> when calling the unbound method. Otherwise, <code>NULL</code> and the object return by the attribute lookup are pushed.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.7.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-CALL_METHOD">
<code>CALL_METHOD(argc)</code> </dt> <dd>
<p>Calls a method. <em>argc</em> is the number of positional arguments. Keyword arguments are not supported. This opcode is designed to be used with <a class="reference internal" href="#opcode-LOAD_METHOD"><code>LOAD_METHOD</code></a>. Positional arguments are on top of the stack. Below them, the two items described in <a class="reference internal" href="#opcode-LOAD_METHOD"><code>LOAD_METHOD</code></a> are on the stack (either <code>self</code> and an unbound method object or <code>NULL</code> and an arbitrary callable). All of them are popped and the return value is pushed.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.7.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-MAKE_FUNCTION">
<code>MAKE_FUNCTION(flags)</code> </dt> <dd>
<p>Pushes a new function object on the stack. From bottom to top, the consumed stack must consist of values if the argument carries a specified flag value</p> <ul class="simple"> <li>
<code>0x01</code> a tuple of default values for positional-only and positional-or-keyword parameters in positional order</li> <li>
<code>0x02</code> a dictionary of keyword-only parameters’ default values</li> <li>
<code>0x04</code> an annotation dictionary</li> <li>
<code>0x08</code> a tuple containing cells for free variables, making a closure</li> <li>the code associated with the function (at TOS1)</li> <li>the <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-qualified-name"><span class="xref std std-term">qualified name</span></a> of the function (at TOS)</li> </ul> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_SLICE">
<code>BUILD_SLICE(argc)</code> </dt> <dd>
<p id="index-0">Pushes a slice object on the stack. <em>argc</em> must be 2 or 3. If it is 2, <code>slice(TOS1, TOS)</code> is pushed; if it is 3, <code>slice(TOS2, TOS1, TOS)</code> is pushed. See the <a class="reference internal" href="functions#slice" title="slice"><code>slice()</code></a> built-in function for more information.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-EXTENDED_ARG">
<code>EXTENDED_ARG(ext)</code> </dt> <dd>
<p>Prefixes any opcode which has an argument too big to fit into the default one byte. <em>ext</em> holds an additional byte which act as higher bits in the argument. For each opcode, at most three prefixal <code>EXTENDED_ARG</code> are allowed, forming an argument from two-byte to four-byte.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-FORMAT_VALUE">
<code>FORMAT_VALUE(flags)</code> </dt> <dd>
<p>Used for implementing formatted literal strings (f-strings). Pops an optional <em>fmt_spec</em> from the stack, then a required <em>value</em>. <em>flags</em> is interpreted as follows:</p> <ul class="simple"> <li>
<code>(flags &amp; 0x03) == 0x00</code>: <em>value</em> is formatted as-is.</li> <li>
<code>(flags &amp; 0x03) == 0x01</code>: call <a class="reference internal" href="stdtypes#str" title="str"><code>str()</code></a> on <em>value</em> before formatting it.</li> <li>
<code>(flags &amp; 0x03) == 0x02</code>: call <a class="reference internal" href="functions#repr" title="repr"><code>repr()</code></a> on <em>value</em> before formatting it.</li> <li>
<code>(flags &amp; 0x03) == 0x03</code>: call <a class="reference internal" href="functions#ascii" title="ascii"><code>ascii()</code></a> on <em>value</em> before formatting it.</li> <li>
<code>(flags &amp; 0x04) == 0x04</code>: pop <em>fmt_spec</em> from the stack and use it, else use an empty <em>fmt_spec</em>.</li> </ul> <p>Formatting is performed using <code>PyObject_Format()</code>. The result is pushed on the stack.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-HAVE_ARGUMENT">
<code>HAVE_ARGUMENT</code> </dt> <dd>
<p>This is not really an opcode. It identifies the dividing line between opcodes which don’t use their argument and those that do (<code>&lt; HAVE_ARGUMENT</code> and <code>&gt;= HAVE_ARGUMENT</code>, respectively).</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Now every instruction has an argument, but opcodes <code>&lt; HAVE_ARGUMENT</code> ignore it. Before, only opcodes <code>&gt;= HAVE_ARGUMENT</code> had an argument.</p> </div> </dd>
</dl>   <h2 id="id1">Opcode collections</h2> <p id="opcode-collections">These collections are provided for automatic introspection of bytecode instructions:</p> <dl class="data"> <dt id="dis.opname">
<code>dis.opname</code> </dt> <dd>
<p>Sequence of operation names, indexable using the bytecode.</p> </dd>
</dl> <dl class="data"> <dt id="dis.opmap">
<code>dis.opmap</code> </dt> <dd>
<p>Dictionary mapping operation names to bytecodes.</p> </dd>
</dl> <dl class="data"> <dt id="dis.cmp_op">
<code>dis.cmp_op</code> </dt> <dd>
<p>Sequence of all compare operation names.</p> </dd>
</dl> <dl class="data"> <dt id="dis.hasconst">
<code>dis.hasconst</code> </dt> <dd>
<p>Sequence of bytecodes that access a constant.</p> </dd>
</dl> <dl class="data"> <dt id="dis.hasfree">
<code>dis.hasfree</code> </dt> <dd>
<p>Sequence of bytecodes that access a free variable (note that ‘free’ in this context refers to names in the current scope that are referenced by inner scopes or names in outer scopes that are referenced from this scope. It does <em>not</em> include references to global or builtin scopes).</p> </dd>
</dl> <dl class="data"> <dt id="dis.hasname">
<code>dis.hasname</code> </dt> <dd>
<p>Sequence of bytecodes that access an attribute by name.</p> </dd>
</dl> <dl class="data"> <dt id="dis.hasjrel">
<code>dis.hasjrel</code> </dt> <dd>
<p>Sequence of bytecodes that have a relative jump target.</p> </dd>
</dl> <dl class="data"> <dt id="dis.hasjabs">
<code>dis.hasjabs</code> </dt> <dd>
<p>Sequence of bytecodes that have an absolute jump target.</p> </dd>
</dl> <dl class="data"> <dt id="dis.haslocal">
<code>dis.haslocal</code> </dt> <dd>
<p>Sequence of bytecodes that access a local variable.</p> </dd>
</dl> <dl class="data"> <dt id="dis.hascompare">
<code>dis.hascompare</code> </dt> <dd>
<p>Sequence of bytecodes of Boolean operations.</p> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2021 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.9/library/dis.html" class="_attribution-link">https://docs.python.org/3.9/library/dis.html</a>
  </p>
</div>
