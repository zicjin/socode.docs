<h1 id="collections-abc-abstract-base-classes-for-containers">collections.abc â€” Abstract Base Classes for Containers</h1> <div class="versionadded" id="module-collections.abc"> <p><span class="versionmodified added">New in version 3.3: </span>Formerly, this module was part of the <a class="reference internal" href="collections#module-collections" title="collections: Container datatypes"><code>collections</code></a> module.</p> </div> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/_collections_abc.py">Lib/_collections_abc.py</a></p>  <p>This module provides <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base classes</span></a> that can be used to test whether a class provides a particular interface; for example, whether it is hashable or whether it is a mapping.</p>  <h2 id="id1">Collections Abstract Base Classes</h2> <p id="collections-abstract-base-classes">The collections module offers the following <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-abstract-base-class"><span class="xref std std-term">ABCs</span></a>:</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>ABC</p></th> <th class="head"><p>Inherits from</p></th> <th class="head"><p>Abstract Methods</p></th> <th class="head"><p>Mixin Methods</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="#collections.abc.Container" title="collections.abc.Container"><code>Container</code></a></p></td> <td></td> <td><p><code>__contains__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Hashable" title="collections.abc.Hashable"><code>Hashable</code></a></p></td> <td></td> <td><p><code>__hash__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code>Iterable</code></a></p></td> <td></td> <td><p><code>__iter__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Iterator" title="collections.abc.Iterator"><code>Iterator</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code>Iterable</code></a></p></td> <td><p><code>__next__</code></p></td> <td><p><code>__iter__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Reversible" title="collections.abc.Reversible"><code>Reversible</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code>Iterable</code></a></p></td> <td><p><code>__reversed__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Generator" title="collections.abc.Generator"><code>Generator</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Iterator" title="collections.abc.Iterator"><code>Iterator</code></a></p></td> <td><p><code>send</code>, <code>throw</code></p></td> <td><p><code>close</code>, <code>__iter__</code>, <code>__next__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Sized" title="collections.abc.Sized"><code>Sized</code></a></p></td> <td></td> <td><p><code>__len__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Callable" title="collections.abc.Callable"><code>Callable</code></a></p></td> <td></td> <td><p><code>__call__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Collection" title="collections.abc.Collection"><code>Collection</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Sized" title="collections.abc.Sized"><code>Sized</code></a>, <a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code>Iterable</code></a>, <a class="reference internal" href="#collections.abc.Container" title="collections.abc.Container"><code>Container</code></a></p></td> <td><p><code>__contains__</code>, <code>__iter__</code>, <code>__len__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code>Sequence</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Reversible" title="collections.abc.Reversible"><code>Reversible</code></a>, <a class="reference internal" href="#collections.abc.Collection" title="collections.abc.Collection"><code>Collection</code></a></p></td> <td><p><code>__getitem__</code>, <code>__len__</code></p></td> <td><p><code>__contains__</code>, <code>__iter__</code>, <code>__reversed__</code>, <code>index</code>, and <code>count</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code>MutableSequence</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code>Sequence</code></a></p></td> <td><p><code>__getitem__</code>, <code>__setitem__</code>, <code>__delitem__</code>, <code>__len__</code>, <code>insert</code></p></td> <td><p>Inherited <a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code>Sequence</code></a> methods and <code>append</code>, <code>reverse</code>, <code>extend</code>, <code>pop</code>, <code>remove</code>, and <code>__iadd__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.ByteString" title="collections.abc.ByteString"><code>ByteString</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code>Sequence</code></a></p></td> <td><p><code>__getitem__</code>, <code>__len__</code></p></td> <td><p>Inherited <a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code>Sequence</code></a> methods</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Collection" title="collections.abc.Collection"><code>Collection</code></a></p></td> <td><p><code>__contains__</code>, <code>__iter__</code>, <code>__len__</code></p></td> <td><p><code>__le__</code>, <code>__lt__</code>, <code>__eq__</code>, <code>__ne__</code>, <code>__gt__</code>, <code>__ge__</code>, <code>__and__</code>, <code>__or__</code>, <code>__sub__</code>, <code>__xor__</code>, and <code>isdisjoint</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.MutableSet" title="collections.abc.MutableSet"><code>MutableSet</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a></p></td> <td><p><code>__contains__</code>, <code>__iter__</code>, <code>__len__</code>, <code>add</code>, <code>discard</code></p></td> <td><p>Inherited <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a> methods and <code>clear</code>, <code>pop</code>, <code>remove</code>, <code>__ior__</code>, <code>__iand__</code>, <code>__ixor__</code>, and <code>__isub__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Mapping" title="collections.abc.Mapping"><code>Mapping</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Collection" title="collections.abc.Collection"><code>Collection</code></a></p></td> <td><p><code>__getitem__</code>, <code>__iter__</code>, <code>__len__</code></p></td> <td><p><code>__contains__</code>, <code>keys</code>, <code>items</code>, <code>values</code>, <code>get</code>, <code>__eq__</code>, and <code>__ne__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code>MutableMapping</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Mapping" title="collections.abc.Mapping"><code>Mapping</code></a></p></td> <td><p><code>__getitem__</code>, <code>__setitem__</code>, <code>__delitem__</code>, <code>__iter__</code>, <code>__len__</code></p></td> <td><p>Inherited <a class="reference internal" href="#collections.abc.Mapping" title="collections.abc.Mapping"><code>Mapping</code></a> methods and <code>pop</code>, <code>popitem</code>, <code>clear</code>, <code>update</code>, and <code>setdefault</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.MappingView" title="collections.abc.MappingView"><code>MappingView</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Sized" title="collections.abc.Sized"><code>Sized</code></a></p></td> <td></td> <td><p><code>__len__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.ItemsView" title="collections.abc.ItemsView"><code>ItemsView</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.MappingView" title="collections.abc.MappingView"><code>MappingView</code></a>, <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a></p></td> <td></td> <td><p><code>__contains__</code>, <code>__iter__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.KeysView" title="collections.abc.KeysView"><code>KeysView</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.MappingView" title="collections.abc.MappingView"><code>MappingView</code></a>, <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a></p></td> <td></td> <td><p><code>__contains__</code>, <code>__iter__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.ValuesView" title="collections.abc.ValuesView"><code>ValuesView</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.MappingView" title="collections.abc.MappingView"><code>MappingView</code></a>, <a class="reference internal" href="#collections.abc.Collection" title="collections.abc.Collection"><code>Collection</code></a></p></td> <td></td> <td><p><code>__contains__</code>, <code>__iter__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Awaitable" title="collections.abc.Awaitable"><code>Awaitable</code></a></p></td> <td></td> <td><p><code>__await__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Coroutine" title="collections.abc.Coroutine"><code>Coroutine</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Awaitable" title="collections.abc.Awaitable"><code>Awaitable</code></a></p></td> <td><p><code>send</code>, <code>throw</code></p></td> <td><p><code>close</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code>AsyncIterable</code></a></p></td> <td></td> <td><p><code>__aiter__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code>AsyncIterator</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code>AsyncIterable</code></a></p></td> <td><p><code>__anext__</code></p></td> <td><p><code>__aiter__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.AsyncGenerator" title="collections.abc.AsyncGenerator"><code>AsyncGenerator</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code>AsyncIterator</code></a></p></td> <td><p><code>asend</code>, <code>athrow</code></p></td> <td><p><code>aclose</code>, <code>__aiter__</code>, <code>__anext__</code></p></td> </tr>  </table> <dl class="class"> <dt id="collections.abc.Container">
<code>class collections.abc.Container</code> </dt> <dd>
<p>ABC for classes that provide the <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__contains__" title="object.__contains__"><code>__contains__()</code></a> method.</p> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Hashable">
<code>class collections.abc.Hashable</code> </dt> <dd>
<p>ABC for classes that provide the <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__hash__" title="object.__hash__"><code>__hash__()</code></a> method.</p> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Sized">
<code>class collections.abc.Sized</code> </dt> <dd>
<p>ABC for classes that provide the <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__len__" title="object.__len__"><code>__len__()</code></a> method.</p> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Callable">
<code>class collections.abc.Callable</code> </dt> <dd>
<p>ABC for classes that provide the <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__call__" title="object.__call__"><code>__call__()</code></a> method.</p> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Iterable">
<code>class collections.abc.Iterable</code> </dt> <dd>
<p>ABC for classes that provide the <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__iter__" title="object.__iter__"><code>__iter__()</code></a> method.</p> <p>Checking <code>isinstance(obj, Iterable)</code> detects classes that are registered as <a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code>Iterable</code></a> or that have an <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__iter__" title="object.__iter__"><code>__iter__()</code></a> method, but it does not detect classes that iterate with the <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code>__getitem__()</code></a> method. The only reliable way to determine whether an object is <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> is to call <code>iter(obj)</code>.</p> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Collection">
<code>class collections.abc.Collection</code> </dt> <dd>
<p>ABC for sized iterable container classes.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Iterator">
<code>class collections.abc.Iterator</code> </dt> <dd>
<p>ABC for classes that provide the <a class="reference internal" href="stdtypes#iterator.__iter__" title="iterator.__iter__"><code>__iter__()</code></a> and <a class="reference internal" href="stdtypes#iterator.__next__" title="iterator.__next__"><code>__next__()</code></a> methods. See also the definition of <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>.</p> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Reversible">
<code>class collections.abc.Reversible</code> </dt> <dd>
<p>ABC for iterable classes that also provide the <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__reversed__" title="object.__reversed__"><code>__reversed__()</code></a> method.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Generator">
<code>class collections.abc.Generator</code> </dt> <dd>
<p>ABC for generator classes that implement the protocol defined in <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0342" id="index-0"><strong>PEP 342</strong></a> that extends iterators with the <a class="reference internal" href="https://docs.python.org/3.9/reference/expressions.html#generator.send" title="generator.send"><code>send()</code></a>, <a class="reference internal" href="https://docs.python.org/3.9/reference/expressions.html#generator.throw" title="generator.throw"><code>throw()</code></a> and <a class="reference internal" href="https://docs.python.org/3.9/reference/expressions.html#generator.close" title="generator.close"><code>close()</code></a> methods. See also the definition of <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-generator"><span class="xref std std-term">generator</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Sequence">
<code>class collections.abc.Sequence</code> </dt> <dt id="collections.abc.MutableSequence">
<code>class collections.abc.MutableSequence</code> </dt> <dt id="collections.abc.ByteString">
<code>class collections.abc.ByteString</code> </dt> <dd>
<p>ABCs for read-only and mutable <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-sequence"><span class="xref std std-term">sequences</span></a>.</p> <p>Implementation note: Some of the mixin methods, such as <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__iter__" title="object.__iter__"><code>__iter__()</code></a>, <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__reversed__" title="object.__reversed__"><code>__reversed__()</code></a> and <code>index()</code>, make repeated calls to the underlying <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code>__getitem__()</code></a> method. Consequently, if <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code>__getitem__()</code></a> is implemented with constant access speed, the mixin methods will have linear performance; however, if the underlying method is linear (as it would be with a linked list), the mixins will have quadratic performance and will likely need to be overridden.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>The index() method added support for <em>stop</em> and <em>start</em> arguments.</p> </div> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Set">
<code>class collections.abc.Set</code> </dt> <dt id="collections.abc.MutableSet">
<code>class collections.abc.MutableSet</code> </dt> <dd>
<p>ABCs for read-only and mutable sets.</p> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Mapping">
<code>class collections.abc.Mapping</code> </dt> <dt id="collections.abc.MutableMapping">
<code>class collections.abc.MutableMapping</code> </dt> <dd>
<p>ABCs for read-only and mutable <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-mapping"><span class="xref std std-term">mappings</span></a>.</p> </dd>
</dl> <dl class="class"> <dt id="collections.abc.MappingView">
<code>class collections.abc.MappingView</code> </dt> <dt id="collections.abc.ItemsView">
<code>class collections.abc.ItemsView</code> </dt> <dt id="collections.abc.KeysView">
<code>class collections.abc.KeysView</code> </dt> <dt id="collections.abc.ValuesView">
<code>class collections.abc.ValuesView</code> </dt> <dd>
<p>ABCs for mapping, items, keys, and values <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-dictionary-view"><span class="xref std std-term">views</span></a>.</p> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Awaitable">
<code>class collections.abc.Awaitable</code> </dt> <dd>
<p>ABC for <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> objects, which can be used in <a class="reference internal" href="https://docs.python.org/3.9/reference/expressions.html#await"><code>await</code></a> expressions. Custom implementations must provide the <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__await__" title="object.__await__"><code>__await__()</code></a> method.</p> <p><a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-coroutine"><span class="xref std std-term">Coroutine</span></a> objects and instances of the <a class="reference internal" href="#collections.abc.Coroutine" title="collections.abc.Coroutine"><code>Coroutine</code></a> ABC are all instances of this ABC.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>In CPython, generator-based coroutines (generators decorated with <a class="reference internal" href="types#types.coroutine" title="types.coroutine"><code>types.coroutine()</code></a> or <a class="reference internal" href="asyncio-task#asyncio.coroutine" title="asyncio.coroutine"><code>asyncio.coroutine()</code></a>) are <em>awaitables</em>, even though they do not have an <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__await__" title="object.__await__"><code>__await__()</code></a> method. Using <code>isinstance(gencoro, Awaitable)</code> for them will return <code>False</code>. Use <a class="reference internal" href="inspect#inspect.isawaitable" title="inspect.isawaitable"><code>inspect.isawaitable()</code></a> to detect them.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Coroutine">
<code>class collections.abc.Coroutine</code> </dt> <dd>
<p>ABC for coroutine compatible classes. These implement the following methods, defined in <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#coroutine-objects"><span class="std std-ref">Coroutine Objects</span></a>: <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#coroutine.send" title="coroutine.send"><code>send()</code></a>, <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#coroutine.throw" title="coroutine.throw"><code>throw()</code></a>, and <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#coroutine.close" title="coroutine.close"><code>close()</code></a>. Custom implementations must also implement <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__await__" title="object.__await__"><code>__await__()</code></a>. All <a class="reference internal" href="#collections.abc.Coroutine" title="collections.abc.Coroutine"><code>Coroutine</code></a> instances are also instances of <a class="reference internal" href="#collections.abc.Awaitable" title="collections.abc.Awaitable"><code>Awaitable</code></a>. See also the definition of <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>In CPython, generator-based coroutines (generators decorated with <a class="reference internal" href="types#types.coroutine" title="types.coroutine"><code>types.coroutine()</code></a> or <a class="reference internal" href="asyncio-task#asyncio.coroutine" title="asyncio.coroutine"><code>asyncio.coroutine()</code></a>) are <em>awaitables</em>, even though they do not have an <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__await__" title="object.__await__"><code>__await__()</code></a> method. Using <code>isinstance(gencoro, Coroutine)</code> for them will return <code>False</code>. Use <a class="reference internal" href="inspect#inspect.isawaitable" title="inspect.isawaitable"><code>inspect.isawaitable()</code></a> to detect them.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="class"> <dt id="collections.abc.AsyncIterable">
<code>class collections.abc.AsyncIterable</code> </dt> <dd>
<p>ABC for classes that provide <code>__aiter__</code> method. See also the definition of <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-asynchronous-iterable"><span class="xref std std-term">asynchronous iterable</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="class"> <dt id="collections.abc.AsyncIterator">
<code>class collections.abc.AsyncIterator</code> </dt> <dd>
<p>ABC for classes that provide <code>__aiter__</code> and <code>__anext__</code> methods. See also the definition of <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="class"> <dt id="collections.abc.AsyncGenerator">
<code>class collections.abc.AsyncGenerator</code> </dt> <dd>
<p>ABC for asynchronous generator classes that implement the protocol defined in <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0525" id="index-1"><strong>PEP 525</strong></a> and <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492" id="index-2"><strong>PEP 492</strong></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> </dd>
</dl> <p>These ABCs allow us to ask classes or instances if they provide particular functionality, for example:</p> <pre data-language="python">size = None
if isinstance(myvar, collections.abc.Sized):
    size = len(myvar)
</pre> <p>Several of the ABCs are also useful as mixins that make it easier to develop classes supporting container APIs. For example, to write a class supporting the full <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a> API, it is only necessary to supply the three underlying abstract methods: <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__contains__" title="object.__contains__"><code>__contains__()</code></a>, <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__iter__" title="object.__iter__"><code>__iter__()</code></a>, and <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__len__" title="object.__len__"><code>__len__()</code></a>. The ABC supplies the remaining methods such as <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__and__" title="object.__and__"><code>__and__()</code></a> and <code>isdisjoint()</code>:</p> <pre data-language="python">class ListBasedSet(collections.abc.Set):
    ''' Alternate set implementation favoring space over speed
        and not requiring the set elements to be hashable. '''
    def __init__(self, iterable):
        self.elements = lst = []
        for value in iterable:
            if value not in lst:
                lst.append(value)

    def __iter__(self):
        return iter(self.elements)

    def __contains__(self, value):
        return value in self.elements

    def __len__(self):
        return len(self.elements)

s1 = ListBasedSet('abcdef')
s2 = ListBasedSet('defghi')
overlap = s1 &amp; s2            # The __and__() method is supported automatically
</pre> <p>Notes on using <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a> and <a class="reference internal" href="#collections.abc.MutableSet" title="collections.abc.MutableSet"><code>MutableSet</code></a> as a mixin:</p> <ol class="arabic simple"> <li>Since some set operations create new sets, the default mixin methods need a way to create new instances from an iterable. The class constructor is assumed to have a signature in the form <code>ClassName(iterable)</code>. That assumption is factored-out to an internal classmethod called <code>_from_iterable()</code> which calls <code>cls(iterable)</code> to produce a new set. If the <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a> mixin is being used in a class with a different constructor signature, you will need to override <code>_from_iterable()</code> with a classmethod or regular method that can construct new instances from an iterable argument.</li> <li>To override the comparisons (presumably for speed, as the semantics are fixed), redefine <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__le__" title="object.__le__"><code>__le__()</code></a> and <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__ge__" title="object.__ge__"><code>__ge__()</code></a>, then the other operations will automatically follow suit.</li> <li>The <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a> mixin provides a <code>_hash()</code> method to compute a hash value for the set; however, <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__hash__" title="object.__hash__"><code>__hash__()</code></a> is not defined because not all sets are hashable or immutable. To add set hashability using mixins, inherit from both <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set()</code></a> and <a class="reference internal" href="#collections.abc.Hashable" title="collections.abc.Hashable"><code>Hashable()</code></a>, then define <code>__hash__ = Set._hash</code>.</li> </ol> <div class="admonition seealso"> <p class="admonition-title">See also</p> <ul class="simple"> <li>
<a class="reference external" href="https://code.activestate.com/recipes/576694/">OrderedSet recipe</a> for an example built on <a class="reference internal" href="#collections.abc.MutableSet" title="collections.abc.MutableSet"><code>MutableSet</code></a>.</li> <li>For more about ABCs, see the <a class="reference internal" href="abc#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code>abc</code></a> module and <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3119" id="index-3"><strong>PEP 3119</strong></a>.</li> </ul> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2021 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.9/library/collections.abc.html" class="_attribution-link">https://docs.python.org/3.9/library/collections.abc.html</a>
  </p>
</div>
