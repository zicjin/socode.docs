<h1 id="id1">Fish for bash users</h1> <p id="fish-for-bash-users">This is to give you a quick overview if you come from bash (or to a lesser extent other shells like zsh or ksh) and want to know how fish differs. Fish is intentionally not POSIX-compatible and as such some of the things you are used to work differently.</p> <p>Many things are similar - they both fundamentally expand commandlines to execute commands, have pipes, redirections, variables, globs, use command output in various ways. This document is there to quickly show you the differences.</p>  <h2 id="bash-command-substitutions">Command substitutions</h2> <p id="command-substitutions">Fish spells command substitutions as <code>(command)</code> instead of <code>$(command)</code> (or <code>`command`</code>).</p> <p>In addition, it only splits them on newlines instead of $IFS. If you want to split on something else, use <a class="reference internal" href="cmds/string#cmd-string-split"><span class="std std-ref">string split</span></a>, <a class="reference internal" href="cmds/string#cmd-string-split"><span class="std std-ref">string split0</span></a> or <a class="reference internal" href="cmds/string#cmd-string-collect"><span class="std std-ref">string collect</span></a>. If those are used as the last command in a command substitution the splits they create are carried over. So:</p> <pre data-language="shell">for i in (find . -print0 | string split0)
</pre> <p>will correctly handle all possible filenames.</p>   <h2 id="variables">Variables</h2> <p>Fish sets and erases variables with <a class="reference internal" href="cmds/set#cmd-set"><span class="std std-ref">set</span></a> instead of <code>VAR=VAL</code> and <code>declare</code> and <code>unset</code> and <code>export</code>. <code>set</code> takes options to determine the scope and exportedness of a variable:</p> <pre data-language="shell"># Define $PAGER global and exported, so this is like ``export PAGER=less``
set -gx PAGER less

# Define $alocalvariable only locally - like ``local alocalvariable=foo``
set -l alocalvariable foo
</pre> <p>or to erase variables:</p> <pre data-language="shell">set -e PAGER
</pre> <p><code>VAR=VAL</code> statements are available as environment overrides:</p> <pre data-language="shell">PAGER=cat git log
</pre> <p>Fish does not perform word splitting. Once a variable has been set to a value, that value stays as it is, so double-quoting variable expansions isn't the necessity it is in bash. <a class="footnote-reference brackets" href="#id3" id="id2">1</a></p> <p>For instance, here's bash</p> <pre data-language="sh">&gt; foo="bar baz"
&gt; printf '"%s"\n' $foo # will print two lines, because we didn't double-quote, so the variable is split
"bar"
"baz"
</pre> <p>And here is fish:</p> <pre data-language="shell">&gt; set foo "bar baz"
&gt; printf '"%s"\n' $foo # foo was set as one element, so it will be passed as one element, so this is one line
"bar baz"
</pre> <p>All variables are "arrays" (we use the term "lists"), and expanding a variable expands to all its elements, with each element as its own argument (like bash's <code>"${var[@]}"</code>:</p> <pre data-language="shell">&gt; set var "foo bar" banana
&gt; printf %s\n $var
foo bar
banana
</pre> <p>Specific elements of a list can be selected:</p> <pre data-language="shell">echo $list[5..7]
</pre> <dl class="footnote brackets"> <dt class="label" id="id3">
<code>1</code> </dt> <dd>
<p>zsh also does not perform word splitting by default (the SH_WORD_SPLIT option controls this)</p> </dd> </dl>   <h2 id="wildcards-globs">Wildcards (globs)</h2> <p>Fish only supports the <code>*</code> and <code>**</code> glob (and the deprecated <code>?</code> glob). If a glob doesn't match it fails the command (like with bash's <code>failglob</code>) unless the command is <code>for</code>, <code>set</code> or <code>count</code> or the glob is used with an environment override (<code>VAR=* command</code>), in which case it expands to nothing (like with bash's <code>nullglob</code> option).</p> <p>Globbing doesn't happen on expanded variables, so:</p> <pre data-language="shell">set foo "*"
echo $foo
</pre> <p>will not match any files.</p> <p>There are no options to control globbing so it always behaves like that.</p>   <h2 id="quoting">Quoting</h2> <p>Fish has two quoting styles: <code>""</code> and <code>''</code>. Variables are expanded in double-quotes, nothing is expanded in single-quotes.</p> <p>There is no <code>$''</code>, instead the sequences that would transform are transformed <em>when unquoted</em>:</p> <pre data-language="shell">&gt; echo a\nb
a
b
</pre>   <h2 id="string-manipulation">String manipulation</h2> <p>Fish does not have <code>${foo%bar}</code>, <code>${foo#bar}</code> and <code>${foo/bar/baz}</code>. Instead string manipulation is done by the <a class="reference internal" href="cmds/string#cmd-string"><span class="std std-ref">string</span></a> builtin.</p>   <h2 id="special-variables">Special variables</h2> <p>Some bash variables and their closest fish equivalent:</p> <ul class="simple"> <li>
<code>$*</code>, <code>$@</code>, <code>$1</code> and so on: <code>$argv</code>
</li> <li>
<code>$?</code>: <code>$status</code>
</li> <li>
<code>$$</code>: <code>$fish_pid</code>
</li> <li>
<code>$#</code>: No variable, instead use <code>count $argv</code>
</li> <li>
<code>$!</code>: <code>$last_pid</code>
</li> <li>
<code>$0</code>: <code>status filename</code>
</li> <li>
<code>$-</code>: Mostly <code>status is-interactive</code> and <code>status is-login</code>
</li> </ul>   <h2 id="process-substitution">Process substitution</h2> <p>Instead of <code>&lt;(command)</code> fish uses <code>(command | psub)</code>. There is no equivalent to <code>&gt;(command)</code>.</p> <p>Note that both of these are bashisms, and most things can easily be expressed without. E.g. instead of:</p> <pre data-language="shell">source (command | psub)
</pre> <p>just use:</p> <pre data-language="shell">command | source
</pre> <p>as fish's <a class="reference internal" href="cmds/source#cmd-source"><span class="std std-ref">source</span></a> can read from stdin.</p>   <h2 id="heredocs">Heredocs</h2> <p>Fish does not have <code>&lt;&lt;EOF</code> "heredocs". Instead of:</p> <pre data-language="shell">cat &lt;&lt;EOF
some string
some more string
EOF
</pre> <p>use:</p> <pre data-language="shell">printf %s\n "some string" "some more string"
</pre> <p>or:</p> <pre data-language="shell">echo "some string
some more string"
</pre> <p>Quotes are followed across newlines.</p>   <h2 id="test-test">Test (<code>test</code>, <code>[</code>, <code>[[</code>)</h2> <p>Fish has a POSIX-compatible <code>test</code> or <code>[</code> builtin. There is no <code>[[</code> and <code>test</code> does not accept <code>==</code> as a synonym for <code>=</code>. It can compare floating point numbers, however.</p> <p><code>set -q</code> can be used to determine if a variable exists or has a certain number of elements (<code>set -q foo[2]</code>).</p>   <h2 id="arithmetic-expansion">Arithmetic Expansion</h2> <p>Fish does not have <code>$((i+1))</code> arithmetic expansion, computation is handled by <a class="reference internal" href="cmds/math#cmd-math"><span class="std std-ref">math</span></a>:</p> <pre data-language="shell">math $i + 1
</pre> <p>It can handle floating point numbers:</p> <pre data-language="shell">&gt; math 5 / 2
2.5
</pre>   <h2 id="prompts">Prompts</h2> <p>Fish does not use the <code>$PS1</code>, <code>$PS2</code> and so on variables. Instead the prompt is the output of the <a class="reference internal" href="cmds/fish_prompt#cmd-fish-prompt"><span class="std std-ref">fish_prompt</span></a> function, plus the <a class="reference internal" href="cmds/fish_mode_prompt#cmd-fish-mode-prompt"><span class="std std-ref">fish_mode_prompt</span></a> function if vi-mode is enabled and the <a class="reference internal" href="cmds/fish_right_prompt#cmd-fish-right-prompt"><span class="std std-ref">fish_right_prompt</span></a> function for the right prompt.</p> <p>As an example, here's a relatively simple bash prompt:</p> <pre data-language="sh"># &lt;$HOSTNAME&gt; &lt;$PWD in blue&gt; &lt;Prompt Sign in Yellow&gt; &lt;Rest in default light white&gt;
export PS1='\h\[\e[1;34m\]\w\[\e[m\] \[\e[1;32m\]\$\[\e[m\] '
</pre> <p>and a rough fish equivalent:</p> <pre data-language="shell">function fish_prompt
    set -l prompt_symbol '$'
    fish_is_root_user; and set prompt_symbol '#'

    echo -s $hostname (set_color blue) (prompt_pwd) \
    (set_color yellow) $prompt_symbol (set_color normal)
end
</pre> <p>This shows a few differences:</p> <ul class="simple"> <li>Fish provides <a class="reference internal" href="cmds/set_color#cmd-set-color"><span class="std std-ref">set_color</span></a> to color text. It can use the 16 named colors and also RGB sequences (so you could also use <code>set_color 5555FF</code>)</li> <li>Instead of introducing specific escapes like <code>\h</code> for the hostname, the prompt is simply a function, so you can use variables like <code>$hostname</code>.</li> <li>Fish offers helper functions for adding things to the prompt, like <a class="reference internal" href="cmds/fish_vcs_prompt#cmd-fish-vcs-prompt"><span class="std std-ref">fish_vcs_prompt</span></a> for adding a display for common version control systems (git, mercurial, svn) and <a class="reference internal" href="cmds/prompt_pwd#cmd-prompt-pwd"><span class="std std-ref">prompt_pwd</span></a> for showing a shortened $PWD (the user's home directory becomes <code>~</code> and any path component is shortened).</li> </ul> <p>The default prompt is reasonably full-featured and its code can be read via <code>type fish_prompt</code>.</p> <p>Fish does not have <code>$PS2</code> for continuation lines, instead it leaves the lines indented to show that the commandline isn't complete yet.</p>   <h2 id="blocks-and-loops">Blocks and loops</h2> <p>Fish's blocking constructs look a little different. They all start with a word, end in <code>end</code> and don't have a second starting word:</p> <pre data-language="shell">for i in 1 2 3; do
   echo $i
done

# becomes

for i in 1 2 3
   echo $i
end

while true; do
   echo Weeee
done

# becomes

while true
   echo Weeeeeee
end

{
   echo Hello
}

# becomes

begin
   echo Hello
end

if true; then
   echo Yes I am true
else
   echo "How is true not true?"
fi

# becomes

if true
   echo Yes I am true
else
   echo "How is true not true?"
end

foo() {
   echo foo
}

# becomes

function foo
    echo foo
end

# (note that bash specifically allows the word "function" as an extension, but POSIX only specifies the form without, so it's more compatible to just use the form without)
</pre> <p>Fish does not have an <code>until</code>. Use <code>while not</code> or <code>while !</code>.</p>   <h2 id="subshells">Subshells</h2> <p>Bash has a feature called "subshells", where it will start another shell process for certain things. That shell will then be independent and e.g. any changes it makes to variables won't be visible in the main shell.</p> <p>This includes things like:</p> <pre data-language="sh"># A list of commands in `()` parentheses
(foo; bar) | baz

# Both sides of a pipe
foo | while read -r bar; do
    # This variable will not be visible outside of the while loop.
    VAR=VAL
    # This background process will not be, either
    baz &amp;
done
</pre> <p><code>()</code> subshells are often confused with <code>{}</code> grouping, which does <em>not</em> use a subshell. When you just need to group, you can use <code>begin; end</code> in fish:</p> <pre data-language="shell">(foo; bar) | baz
# when it should really have been:
{ foo; bar } | baz
# becomes
begin; foo; bar; end | baz
</pre> <p>The pipe will simply be run in the same process, so <code>while read</code> loops can set variables outside:</p> <pre data-language="shell">foo | while read bar
    set -g VAR VAL
    baz &amp;
end

echo $VAR # will print VAL
jobs # will show "baz"
</pre> <p>Subshells are also frequently confused with <a class="reference internal" href="#bash-command-substitutions"><span class="std std-ref">command substitutions</span></a>, which bash writes as <code>`command`</code> or <code>$(command)</code> and fish writes as <code>(command)</code>. Bash also <em>uses</em> subshells to implement them.</p> <p>The isolation can usually be achieved by just scoping variables (with <code>set -l</code>), but if you really do need to run your code in a new shell environment you can always use <code>fish -c 'your code here'</code> to do so explicitly.</p>   <h2 id="builtins-and-other-commands">Builtins and other commands</h2> <p>By now it has become apparent that fish puts much more of a focus on its builtins and external commands rather than its syntax. So here are some helpful builtins and their rough equivalent in bash:</p> <ul class="simple"> <li>
<a class="reference internal" href="cmds/string#cmd-string"><span class="std std-ref">string</span></a> - this replaces most of the string transformation (<code>${i%foo}</code> et al) and can also be used instead of <code>grep</code> and <code>sed</code> and such.</li> <li>
<a class="reference internal" href="cmds/math#cmd-math"><span class="std std-ref">math</span></a> - this replaces <code>$((i + 1))</code> arithmetic and can also do floats and some simple functions (sine and friends).</li> <li>
<a class="reference internal" href="cmds/argparse#cmd-argparse"><span class="std std-ref">argparse</span></a> - this can handle a script's option parsing, for which bash would probably use <code>getopt</code> (zsh provides <code>zparseopts</code>).</li> <li>
<a class="reference internal" href="cmds/count#cmd-count"><span class="std std-ref">count</span></a> can be used to count things and therefore replaces <code>$#</code> and can be used instead of <code>wc</code>.</li> <li>
<a class="reference internal" href="cmds/status#cmd-status"><span class="std std-ref">status</span></a> provides information about the shell status, e.g. if it's interactive or what the current linenumber is. This replaces <code>$-</code> and <code>$BASH_LINENO</code> and other variables.</li> <li>
<code>seq(1)</code> can be used as a replacement for <code>{1..10}</code> range expansion. If your OS doesn't ship a <code>seq</code> fish includes a replacement function.</li> </ul>   <div class="_attribution">
  <p class="_attribution-p">
    <a href="https://fishshell.com/docs/3.3/fish_for_bash_users.html" class="_attribution-link" target="_blank">https://fishshell.com/docs/3.3/fish_for_bash_users.html</a>
  </p>
</div>
