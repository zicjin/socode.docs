<p class="_links"><a href="../../dart-async/dart-async-library" class="_links-link">dart:async</a></p> <h1>handleUncaughtError method  </h1> <section class="multi-line-signature"> void handleUncaughtError(<wbr><ol class="parameter-list">
<li>
<a href="../../dart-core/object-class">Object</a> error, </li> <li>
<a href="../../dart-core/stacktrace-class">StackTrace</a> stackTrace</li> </ol>) </wbr></section>  <p>Handles uncaught asynchronous errors.</p> <p>There are two kind of asynchronous errors that are handled by this function:</p> <ol> <li>Uncaught errors that were thrown in asynchronous callbacks, for example, a <code>throw</code> in the function passed to <a href="../timer/run">Timer.run</a>.</li> <li>Asynchronous errors that are pushed through <a href="../future-class">Future</a> and <a href="../stream-class">Stream</a> chains, but for which nobody registered an error handler. Most asynchronous classes, like <a href="../future-class">Future</a> or <a href="../stream-class">Stream</a> push errors to their listeners. Errors are propagated this way until either a listener handles the error (for example with <a href="../future/catcherror">Future.catchError</a>), or no listener is available anymore. In the latter case, futures and streams invoke the zone's <a href="handleuncaughterror">handleUncaughtError</a>.</li> </ol> <p>By default, when handled by the root zone, uncaught asynchronous errors are treated like uncaught synchronous exceptions.</p>   <h2 id="source">Implementation</h2> <pre class="language-dart" data-language="dart">void handleUncaughtError(Object error, StackTrace stackTrace);</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012 the Dart project authors<br>Licensed under the Creative Commons Attribution-ShareAlike License v4.0.<br>
    <a href="https://api.dart.dev/stable/2.15.1/dart-async/Zone/handleUncaughtError.html" class="_attribution-link">https://api.dart.dev/stable/2.15.1/dart-async/Zone/handleUncaughtError.html</a>
  </p>
</div>
