<h1 id="formula-cookbook">Formula Cookbook</h1> <p>A <em>formula</em> is a package definition written in Ruby. It can be created with <code class="highlighter-rouge">brew create &lt;URL&gt;</code> where <code class="highlighter-rouge">&lt;URL&gt;</code> is a zip or tarball, installed with <code class="highlighter-rouge">brew install &lt;formula&gt;</code>, and debugged with <code class="highlighter-rouge">brew install --debug --verbose &lt;formula&gt;</code>. Formulae use the <a href="https://rubydoc.brew.sh/Formula">Formula API</a> which provides various Homebrew-specific helpers.</p> <h2 id="homebrew-terminology">Homebrew terminology</h2> <table> <thead> <tr> <th>Term</th> <th>Description</th> <th>Example</th> </tr> </thead> <tbody> <tr> <td><strong>Formula</strong></td> <td>The package definition</td> <td><code class="highlighter-rouge">/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/foo.rb</code></td> </tr> <tr> <td><strong>Keg</strong></td> <td>The installation prefix of a <strong>Formula</strong>
</td> <td><code class="highlighter-rouge">/usr/local/Cellar/foo/0.1</code></td> </tr> <tr> <td><strong>opt prefix</strong></td> <td>A symlink to the active version of a <strong>Keg</strong>
</td> <td><code class="highlighter-rouge">/usr/local/opt/foo </code></td> </tr> <tr> <td><strong>Cellar</strong></td> <td>All <strong>Kegs</strong> are installed here</td> <td><code class="highlighter-rouge">/usr/local/Cellar</code></td> </tr> <tr> <td><strong>Tap</strong></td> <td>A Git repository of <strong>Formulae</strong> and/or commands</td> <td><code class="highlighter-rouge">/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core</code></td> </tr> <tr> <td><strong>Bottle</strong></td> <td>Pre-built <strong>Keg</strong> used instead of building from source</td> <td><code class="highlighter-rouge">qt-4.8.4.mavericks.bottle.tar.gz</code></td> </tr> <tr> <td><strong>Cask</strong></td> <td>An <a href="https://github.com/Homebrew/homebrew-cask">extension of Homebrew</a> to install macOS native apps</td> <td><code class="highlighter-rouge">/Applications/MacDown.app/Contents/SharedSupport/bin/macdown</code></td> </tr> <tr> <td><strong>Brew Bundle</strong></td> <td>An <a href="https://github.com/Homebrew/homebrew-bundle">extension of Homebrew</a> to describe dependencies</td> <td><code class="highlighter-rouge">brew 'myservice', restart_service: true</code></td> </tr> </tbody> </table> <h2 id="an-introduction">An introduction</h2> <p>Homebrew uses Git for downloading updates and contributing to the project.</p> <p>Homebrew installs to the <code class="highlighter-rouge">Cellar</code> and then symlinks some of the installation into <code class="highlighter-rouge">/usr/local</code> so that other programs can see what’s going on. We suggest you <code class="highlighter-rouge">brew ls</code> a few of the kegs in your Cellar to see how it is all arranged.</p> <p>Packages are installed according to their formulae, which live in <code class="highlighter-rouge">/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula</code>. Check out a simple one, e.g. <code class="highlighter-rouge">brew edit etl</code> (or <a href="https://github.com/Homebrew/homebrew-core/blob/master/Formula/etl.rb"><code class="highlighter-rouge">etl</code></a>) or a more advanced one, e.g. <code class="highlighter-rouge">brew edit git</code> (or <a href="https://github.com/Homebrew/homebrew-core/blob/master/Formula/git.rb"><code class="highlighter-rouge">git</code></a>).</p> <h2 id="basic-instructions">Basic instructions</h2> <p>Make sure you run <code class="highlighter-rouge">brew update</code> before you start. This turns your Homebrew installation into a Git repository.</p> <p>Before submitting a new formula make sure your package:</p> <ul> <li>meets all our <a href="acceptable-formulae">Acceptable Formulae</a> requirements</li> <li>isn’t already in Homebrew (check <code class="highlighter-rouge">brew search &lt;formula&gt;</code>)</li> <li>isn’t already waiting to be merged (check the <a href="https://github.com/Homebrew/homebrew-core/pulls">issue tracker</a>)</li> <li>is still supported by upstream (i.e. doesn’t require extensive patching)</li> <li>has a stable, tagged version (i.e. not just a GitHub repository with no versions)</li> <li>passes all <code class="highlighter-rouge">brew audit --new-formula &lt;formula&gt;</code> tests</li> </ul> <p>Before submitting a new formula make sure you read over our <a href="https://github.com/Homebrew/brew/blob/master/CONTRIBUTING.md#contributing-to-homebrew">contribution guidelines</a>.</p> <h3 id="grab-the-url">Grab the URL</h3> <p>Run <code class="highlighter-rouge">brew create</code> with a URL to the source tarball:</p> <pre data-language="sh">brew create https://example.com/foo-0.1.tar.gz</pre> <p>This creates <code class="highlighter-rouge">/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/foo.rb</code> and opens it in your <code class="highlighter-rouge">EDITOR</code>. It’ll look something like:</p> <pre data-language="ruby">class Foo &lt; Formula
  desc ""
  homepage ""
  url "https://example.com/foo-0.1.tar.gz"
  sha256 "85cc828a96735bdafcf29eb6291ca91bac846579bcef7308536e0c875d6c81d7"

  # depends_on "cmake" =&gt; :build

  def install
    # ENV.deparallelize
    system "./configure", "--disable-debug",
                          "--disable-dependency-tracking",
                          "--disable-silent-rules",
                          "--prefix=#{prefix}"
    # system "cmake", ".", *std_cmake_args
    system "make", "install"
  end

  test do
    system "false"
  end
end</pre> <p>If <code class="highlighter-rouge">brew</code> said <code class="highlighter-rouge">Warning: Version cannot be determined from URL</code> when doing the <code class="highlighter-rouge">create</code> step, you’ll need to explicitly add the correct <a href="https://rubydoc.brew.sh/Formula#version-class_method"><code class="highlighter-rouge">version</code></a> to the formula and then save the formula.</p> <p>Homebrew will try to guess the formula’s name from its URL. If it fails to do so you can override this with <code class="highlighter-rouge">brew create &lt;URL&gt; --set-name &lt;name&gt;</code>.</p> <h3 id="fill-in-the-homepage">Fill in the <code class="highlighter-rouge">homepage</code>
</h3> <p><strong>We don’t accept formulae without a <a href="https://rubydoc.brew.sh/Formula#homepage%3D-class_method"><code class="highlighter-rouge">homepage</code></a>!</strong></p> <p>An SSL/TLS (https) <a href="https://rubydoc.brew.sh/Formula#homepage%3D-class_method"><code class="highlighter-rouge">homepage</code></a> is preferred, if one is available.</p> <p>Try to summarize from the <a href="https://rubydoc.brew.sh/Formula#homepage%3D-class_method"><code class="highlighter-rouge">homepage</code></a> what the formula does in the <a href="https://rubydoc.brew.sh/Formula#desc%3D-class_method"><code class="highlighter-rouge">desc</code></a>ription. Note that the <a href="https://rubydoc.brew.sh/Formula#desc%3D-class_method"><code class="highlighter-rouge">desc</code></a>ription is automatically prepended with the formula name.</p> <h3 id="check-the-build-system">Check the build system</h3> <pre data-language="sh">brew install --interactive foo</pre> <p>You’re now at a new prompt with the tarball extracted to a temporary sandbox.</p> <p>Check the package’s <code class="highlighter-rouge">README</code>. Does the package install with <code class="highlighter-rouge">./configure</code>, <code class="highlighter-rouge">cmake</code>, or something else? Delete the commented out <code class="highlighter-rouge">cmake</code> lines if the package uses <code class="highlighter-rouge">./configure</code>.</p> <h3 id="check-for-dependencies">Check for dependencies</h3> <p>The <code class="highlighter-rouge">README</code> probably tells you about dependencies and Homebrew or macOS probably already has them. You can check for Homebrew dependencies with <code class="highlighter-rouge">brew search</code>. Some common dependencies that macOS comes with:</p> <ul> <li><code class="highlighter-rouge">libexpat</code></li> <li><code class="highlighter-rouge">libGL</code></li> <li><code class="highlighter-rouge">libiconv</code></li> <li><code class="highlighter-rouge">libpcap</code></li> <li><code class="highlighter-rouge">libxml2</code></li> <li><code class="highlighter-rouge">python</code></li> <li><code class="highlighter-rouge">ruby</code></li> </ul> <p>There are plenty of others; check <code class="highlighter-rouge">/usr/lib</code> for them.</p> <p>We generally try not to duplicate system libraries and complicated tools in core Homebrew but we do duplicate some commonly used tools.</p> <p>Special exceptions are OpenSSL and LibreSSL. Things that use either <em>should</em> be built using Homebrew’s shipped equivalent and our Brew Test Bot’s post-install <code class="highlighter-rouge">audit</code> will warn if it detects you haven’t done this.</p> <p>Homebrew’s OpenSSL is <a href="https://rubydoc.brew.sh/Formula#keg_only-class_method"><code class="highlighter-rouge">keg_only</code></a> to avoid conflicting with the system so sometimes formulae need to have environment variables set or special configuration flags passed to locate our OpenSSL. You can see this mechanism in the <a href="https://github.com/Homebrew/homebrew-core/blob/89c4574ef1a6d15e92196637ff315a0a4bb3e289/Formula/clamav.rb#L37"><code class="highlighter-rouge">clamav</code></a> formula. Usually this is unnecessary because Homebrew sets up our <a href="https://github.com/Homebrew/brew/blob/master/Library/Homebrew/extend/ENV/super.rb">build environment</a> to favour finding <a href="https://rubydoc.brew.sh/Formula#keg_only-class_method"><code class="highlighter-rouge">keg_only</code></a> formulae first.</p> <p><strong>Important:</strong> <code class="highlighter-rouge">$(brew --prefix)/bin</code> is NOT on the <code class="highlighter-rouge">PATH</code> during formula installation. If you have dependencies at build time, you must specify them and <code class="highlighter-rouge">brew</code> will add them to the <code class="highlighter-rouge">PATH</code> or create a <a href="https://rubydoc.brew.sh/Requirement"><code class="highlighter-rouge">Requirement</code></a>.</p> <h3 id="specifying-other-formulae-as-dependencies">Specifying other formulae as dependencies</h3> <pre data-language="ruby">class Foo &lt; Formula
  depends_on "pkg-config"
  depends_on "jpeg"
  depends_on "readline" =&gt; :recommended
  depends_on "gtk+" =&gt; :optional
  depends_on "httpd" =&gt; [:build, :test]
  depends_on :x11 =&gt; :optional
  depends_on :xcode =&gt; "9.3"
end</pre> <p>A String (e.g. <code class="highlighter-rouge">"jpeg"</code>) specifies a formula dependency.</p> <p>A Symbol (e.g. <code class="highlighter-rouge">:x11</code>) specifies a <a href="https://rubydoc.brew.sh/Requirement"><code class="highlighter-rouge">Requirement</code></a> which can be fulfilled by one or more formulae, casks or other system-wide installed software (e.g. X11).</p> <p>A Hash (e.g. <code class="highlighter-rouge">=&gt;</code>) adds information to a dependency. Given a String or Symbol, the value can be one or more of the following values:</p> <ul> <li>
<code class="highlighter-rouge">:build</code> means that dependency is a build-time only dependency so it can be skipped when installing from a bottle or when listing missing dependencies using <code class="highlighter-rouge">brew missing</code>.</li> <li>
<code class="highlighter-rouge">:test</code> means that dependency is only required when running <code class="highlighter-rouge">brew test</code>.</li> <li>
<code class="highlighter-rouge">:optional</code> generates an implicit <code class="highlighter-rouge">with-foo</code> option for the formula. This means that, given <code class="highlighter-rouge">depends_on "foo" =&gt; :optional</code>, the user must pass <code class="highlighter-rouge">--with-foo</code> in order to use the dependency.</li> <li>
<code class="highlighter-rouge">:recommended</code> generates an implicit <code class="highlighter-rouge">without-foo</code> option, meaning that the dependency is enabled by default and the user must pass <code class="highlighter-rouge">--without-foo</code> to disable this dependency. The default description can be overridden using the normal option syntax (in this case, the option declaration must precede the dependency): <pre data-language="ruby">option "with-foo", "Compile with foo bindings" # This overrides the generated description if you want to
  depends_on "foo" =&gt; :optional # Generated description would otherwise be "Build with foo support"</pre> </li> <li>Some <a href="https://rubydoc.brew.sh/Requirement"><code class="highlighter-rouge">Requirement</code></a>s can also take a string specifying their minimum version that the formula depends on.</li> </ul> <p><strong>Note:</strong> <a href="https://rubydoc.brew.sh/Formula#option-class_method"><code class="highlighter-rouge">option</code></a>s are not allowed in Homebrew/homebrew-core as they are not tested by CI.</p> <h3 id="specifying-conflicts-with-other-formulae">Specifying conflicts with other formulae</h3> <p>Sometimes there’s hard conflict between formulae, and it can’t be avoided or circumvented with <a href="https://rubydoc.brew.sh/Formula#keg_only-class_method"><code class="highlighter-rouge">keg_only</code></a>.</p> <p>A good example formula for minor conflict is <a href="https://github.com/Homebrew/homebrew-core/blob/master/Formula/mbedtls.rb"><code class="highlighter-rouge">mbedtls</code></a>, which ships and compiles a “Hello World” executable. This is obviously non-essential to <code class="highlighter-rouge">mbedtls</code>’s functionality, and conflict with the popular GNU <a href="https://github.com/Homebrew/homebrew-core/blob/master/Formula/hello.rb"><code class="highlighter-rouge">hello</code></a> formula would be overkill, so we just <a href="https://github.com/Homebrew/homebrew-core/blob/966273060ad507fea490bd931971963de8b1a1dc/Formula/mbedtls.rb#L30-L31">remove it</a> during the installation process.</p> <p><a href="https://github.com/Homebrew/homebrew-core/blob/master/Formula/pdftohtml.rb"><code class="highlighter-rouge">pdftohtml</code></a> provides an example of a serious conflict, where both formula ship an identically-named binary that is essential to functionality, so a <a href="https://rubydoc.brew.sh/Formula#conflicts_with-class_method"><code class="highlighter-rouge">conflicts_with</code></a> is preferable.</p> <p>As a general rule, <a href="https://rubydoc.brew.sh/Formula#conflicts_with-class_method"><code class="highlighter-rouge">conflicts_with</code></a> should be a last-resort option. It’s a fairly blunt instrument.</p> <p>The syntax for a conflict that can’t be worked around is:</p> <pre data-language="ruby">conflicts_with "blueduck", :because =&gt; "yellowduck also ships a duck binary"</pre> <h3 id="formulae-revisions">Formulae revisions</h3> <p>In Homebrew we sometimes accept formulae updates that don’t include a version bump. These include resource updates, new patches or fixing a security issue with a formula.</p> <p>Occasionally, these updates require a forced-recompile of the formula itself or its dependents to either ensure formulae continue to function as expected or to close a security issue. This forced-recompile is known as a <a href="https://rubydoc.brew.sh/Formula#revision%3D-class_method"><code class="highlighter-rouge">revision</code></a> and is inserted underneath the <a href="https://rubydoc.brew.sh/Formula#homepage%3D-class_method"><code class="highlighter-rouge">homepage</code></a>/<a href="https://rubydoc.brew.sh/Formula#url-class_method"><code class="highlighter-rouge">url</code></a>/<a href="https://rubydoc.brew.sh/Formula#sha256%3D-class_method"><code class="highlighter-rouge">sha256</code></a> block.</p> <p>When a dependent of a formula fails against a new version of that dependency it must receive a <a href="https://rubydoc.brew.sh/Formula#revision%3D-class_method"><code class="highlighter-rouge">revision</code></a>. An example of such failure can be seen <a href="https://github.com/Homebrew/legacy-homebrew/issues/31195">here</a> and the fix <a href="https://github.com/Homebrew/legacy-homebrew/pull/31207">here</a>.</p> <p><a href="https://rubydoc.brew.sh/Formula#revision%3D-class_method"><code class="highlighter-rouge">revision</code></a>s are also used for formulae that move from the system OpenSSL to the Homebrew-shipped OpenSSL without any other changes to that formula. This ensures users aren’t left exposed to the potential security issues of the outdated OpenSSL. An example of this can be seen in <a href="https://github.com/Homebrew/homebrew-core/commit/0d4453a91923e6118983961e18d0609e9828a1a4">this commit</a>.</p> <h3 id="version-scheme-changes">Version scheme changes</h3> <p>Sometimes formulae have version schemes that change such that a direct comparison between two versions no longer produces the correct result. For example, a project might be version <code class="highlighter-rouge">13</code> and then decide to become <code class="highlighter-rouge">1.0.0</code>. As <code class="highlighter-rouge">13</code> is translated to <code class="highlighter-rouge">13.0.0</code> by our versioning system by default this requires intervention.</p> <p>When a version scheme of a formula fails to recognise a new version as newer it must receive a <a href="https://rubydoc.brew.sh/Formula#version_scheme%3D-class_method"><code class="highlighter-rouge">version_scheme</code></a>. An example of this can be seen <a href="https://github.com/Homebrew/homebrew-core/pull/4006">here</a>.</p> <h3 id="double-check-for-dependencies">Double-check for dependencies</h3> <p>When you already have a lot of formulae installed, it’s easy to miss a common dependency. You can double-check which libraries a binary links to with the <code class="highlighter-rouge">otool</code> command (perhaps you need to use <code class="highlighter-rouge">xcrun otool</code>):</p> <pre data-language="sh">$ otool -L /usr/local/bin/ldapvi
/usr/local/bin/ldapvi:
    /usr/local/opt/openssl/lib/libssl.1.0.0.dylib (compatibility version 1.0.0, current version 1.0.0)
    /usr/local/opt/openssl/lib/libcrypto.1.0.0.dylib (compatibility version 1.0.0, current version 1.0.0)
    /usr/local/lib/libglib-2.0.0.dylib (compatibility version 4201.0.0, current version 4201.0.0)
    /usr/local/opt/gettext/lib/libintl.8.dylib (compatibility version 10.0.0, current version 10.2.0)
    /usr/local/opt/readline/lib/libreadline.6.dylib (compatibility version 6.0.0, current version 6.3.0)
    /usr/local/lib/libpopt.0.dylib (compatibility version 1.0.0, current version 1.0.0)
    /usr/lib/libncurses.5.4.dylib (compatibility version 5.4.0, current version 5.4.0)
    /System/Library/Frameworks/LDAP.framework/Versions/A/LDAP (compatibility version 1.0.0, current version 2.4.0)
    /usr/lib/libresolv.9.dylib (compatibility version 1.0.0, current version 1.0.0)
    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1213.0.0)</pre> <h3 id="specifying-gems-python-modules-go-projects-etc-as-dependencies">Specifying gems, Python modules, Go projects, etc. as dependencies</h3> <p>Homebrew doesn’t package already-packaged language-specific libraries. These should be installed directly from <code class="highlighter-rouge">gem</code>/<code class="highlighter-rouge">cpan</code>/<code class="highlighter-rouge">pip</code> etc.</p> <p>If you’re installing an application then use <a href="https://rubydoc.brew.sh/Formula#resource-class_method"><code class="highlighter-rouge">resource</code></a>s for all language-specific dependencies:</p> <pre data-language="ruby">class Foo &lt; Formula
  resource "pycrypto" do
    url "https://files.pythonhosted.org/packages/60/db/645aa9af249f059cc3a368b118de33889219e0362141e75d4eaf6f80f163/pycrypto-2.6.1.tar.gz"
    sha256 "f2ce1e989b272cfcb677616763e0a2e7ec659effa67a88aa92b3a65528f60a3c"
  end

  def install
    resource("pycrypto").stage { system "python", *Language::Python.setup_install_args(libexec/"vendor") }
  end
end</pre> <p><a href="https://github.com/Homebrew/homebrew-core/blob/master/Formula/jrnl.rb"><code class="highlighter-rouge">jrnl</code></a> is an example of a formula that does this well. The end result means the user doesn’t have to use <code class="highlighter-rouge">pip</code> or Python and can just run <code class="highlighter-rouge">jrnl</code>.</p> <p><a href="https://github.com/tdsmith/homebrew-pypi-poet">homebrew-pypi-poet</a> can help you generate <a href="https://rubydoc.brew.sh/Formula#resource-class_method"><code class="highlighter-rouge">resource</code></a> stanzas for the dependencies of your Python application.</p> <h3 id="install-the-formula">Install the formula</h3> <pre data-language="sh">brew install --verbose --debug foo</pre> <p><code class="highlighter-rouge">--debug</code> will ask you to open an interactive shell if the build fails so you can try to figure out what went wrong.</p> <p>Check the top of the e.g. <code class="highlighter-rouge">./configure</code> output. Some configure scripts do not recognise e.g. <code class="highlighter-rouge">--disable-debug</code>. If you see a warning about it, remove the option from the formula.</p> <h3 id="add-a-test-to-the-formula">Add a test to the formula</h3> <p>Add a valid test to the <a href="https://rubydoc.brew.sh/Formula#test-class_method"><code class="highlighter-rouge">test do</code></a> block of the formula. This will be run by <code class="highlighter-rouge">brew test foo</code> and the <a href="brew-test-bot">Brew Test Bot</a>.</p> <p>The <a href="https://rubydoc.brew.sh/Formula#test-class_method"><code class="highlighter-rouge">test do</code></a> block automatically creates and changes to a temporary directory which is deleted after run. You can access this <a href="https://rubydoc.brew.sh/Pathname"><code class="highlighter-rouge">Pathname</code></a> with the <a href="https://rubydoc.brew.sh/Formula#testpath-instance_method"><code class="highlighter-rouge">testpath</code></a> function. The environment variable <code class="highlighter-rouge">HOME</code> is set to <a href="https://rubydoc.brew.sh/Formula#testpath-instance_method"><code class="highlighter-rouge">testpath</code></a> within the <a href="https://rubydoc.brew.sh/Formula#test-class_method"><code class="highlighter-rouge">test do</code></a> block.</p> <p>We want tests that don’t require any user input and test the basic functionality of the application. For example <code class="highlighter-rouge">foo build-foo input.foo</code> is a good test and (despite their widespread use) <code class="highlighter-rouge">foo --version</code> and <code class="highlighter-rouge">foo --help</code> are bad tests. However, a bad test is better than no test at all.</p> <p>See <a href="https://github.com/Homebrew/homebrew-core/blob/master/Formula/cmake.rb"><code class="highlighter-rouge">cmake</code></a> for an example of a formula with a good test. The formula writes a basic <code class="highlighter-rouge">CMakeLists.txt</code> file into the test directory then calls CMake to generate Makefiles. This test checks that CMake doesn’t e.g. segfault during basic operation.</p> <p>You can check that the output is as expected with <code class="highlighter-rouge">assert_equal</code> or <code class="highlighter-rouge">assert_match</code> on the output of shell_output such as in this example from the <a href="https://github.com/Homebrew/homebrew-core/blob/master/Formula/envv.rb">envv formula</a>:</p> <pre data-language="ruby">assert_equal "mylist=A:C; export mylist", shell_output("#{bin}/envv del mylist B").strip</pre> <p>You can also check that an output file was created:</p> <pre data-language="ruby">assert_predicate testpath/"output.txt", :exist?</pre> <p>Some advice for specific cases:</p> <ul> <li>If the formula is a library, compile and run some simple code that links against it. It could be taken from upstream’s documentation / source examples. A good example is <a href="https://github.com/Homebrew/homebrew-core/blob/master/Formula/tinyxml2.rb"><code class="highlighter-rouge">tinyxml2</code></a>, which writes a small C++ source file into the test directory, compiles and links it against the tinyxml2 library and finally checks that the resulting program runs successfully.</li> <li>If the formula is for a GUI program, try to find some function that runs as command-line only, like a format conversion, reading or displaying a config file, etc.</li> <li>If the software cannot function without credentials or requires a virtual machine, docker instance, etc. to run, a test could be to try to connect with invalid credentials (or without credentials) and confirm that it fails as expected.</li> </ul> <h3 id="manuals">Manuals</h3> <p>Homebrew expects to find manual pages in <code class="highlighter-rouge">#{prefix}/share/man/...</code>, and not in <code class="highlighter-rouge">#{prefix}/man/...</code>.</p> <p>Some software installs to <code class="highlighter-rouge">man</code> instead of <code class="highlighter-rouge">share/man</code>, so check the output and add a <code class="highlighter-rouge">"--mandir=#{man}"</code> to the <code class="highlighter-rouge">./configure</code> line if needed.</p> <h3 id="caveats">Caveats</h3> <p>In case there are specific issues with the Homebrew packaging (compared to how the software is installed from other sources) a <code class="highlighter-rouge">caveats</code> block can be added to the formula to warn users. This can indicate non-standard install paths, an example from the <code class="highlighter-rouge">ruby</code> formula:</p> <pre>==&gt; Caveats
By default, binaries installed by gem will be placed into:
  /usr/local/lib/ruby/gems/bin

You may want to add this to your PATH.</pre> <h3 id="a-quick-word-on-naming">A quick word on naming</h3> <p>Name the formula like the project markets the product. So it’s <code class="highlighter-rouge">pkg-config</code>, not <code class="highlighter-rouge">pkgconfig</code>; <code class="highlighter-rouge">sdl_mixer</code>, not <code class="highlighter-rouge">sdl-mixer</code> or <code class="highlighter-rouge">sdlmixer</code>.</p> <p>The only exception is stuff like “Apache Ant”. Apache sticks “Apache” in front of everything, but we use the formula name <code class="highlighter-rouge">ant</code>. We only include the prefix in cases like <code class="highlighter-rouge">gnuplot</code> (because it’s part of the name) and <code class="highlighter-rouge">gnu-go</code> (because everyone calls it “GNU Go”—nobody just calls it “Go”). The word “Go” is too common and there are too many implementations of it.</p> <p>If you’re not sure about the name, check its homepage, Wikipedia page and <a href="https://www.debian.org/distrib/packages">what Debian calls it</a>.</p> <p>When Homebrew already has a formula called <code class="highlighter-rouge">foo</code> we typically do not accept requests to replace that formula with something else also named <code class="highlighter-rouge">foo</code>. This is to avoid both confusing and surprising users’ expectations.</p> <p>When two formulae share an upstream name, e.g. <a href="https://github.com/Homebrew/homebrew-core/blob/master/Formula/aescrypt.rb">AESCrypt</a> and <a href="https://github.com/Homebrew/homebrew-core/blob/master/Formula/aescrypt-packetizer.rb">AES Crypt</a> the newer formula must typically adapt its name to avoid conflict with the current formula.</p> <p>If you’re <em>still</em> not sure, just commit. We’ll apply some arbitrary rule and make a decision 😉.</p> <p>When importing classes, Homebrew will require the formula and then create an instance of the class. It does this by assuming the formula name can be directly converted to the class name using a <code class="highlighter-rouge">regexp</code>. The rules are simple:</p> <ul> <li>
<code class="highlighter-rouge">foo-bar.rb</code> =&gt; <code class="highlighter-rouge">FooBar</code>
</li> <li>
<code class="highlighter-rouge">foobar.rb</code> =&gt; <code class="highlighter-rouge">Foobar</code>
</li> </ul> <p>Thus, if you change the name of the class, you must also rename the file. Filenames should be all lowercase, and class names should be the strict CamelCase equivalent, e.g. formulae <code class="highlighter-rouge">gnu-go</code> and <code class="highlighter-rouge">sdl_mixer</code> become classes <code class="highlighter-rouge">GnuGo</code> and <code class="highlighter-rouge">SdlMixer</code>, even if part of their name is an acronym.</p> <p>Add aliases by creating symlinks in an <code class="highlighter-rouge">Aliases</code> directory in the tap root.</p> <h3 id="audit-the-formula">Audit the formula</h3> <p>You can run <code class="highlighter-rouge">brew audit --strict --online</code> to test formulae for adherence to Homebrew house style. The <code class="highlighter-rouge">audit</code> command includes warnings for trailing whitespace, preferred URLs for certain source hosts, and a lot of other style issues. Fixing these warnings before committing will make the process a lot quicker for everyone.</p> <p>New formulae being submitted to Homebrew should run <code class="highlighter-rouge">brew audit --new-formula foo</code>. This command is performed by the Brew Test Bot on new submissions as part of the automated build and test process, and highlights more potential issues than the standard audit.</p> <p>Use <code class="highlighter-rouge">brew info</code> and check if the version guessed by Homebrew from the URL is correct. Add an explicit <a href="https://rubydoc.brew.sh/Formula#version-class_method"><code class="highlighter-rouge">version</code></a> if not.</p> <h3 id="commit">Commit</h3> <p>Everything is built on Git, so contribution is easy:</p> <pre data-language="sh">brew update # required in more ways than you think (initializes the brew git repository if you don't already have it)
cd $(brew --repo homebrew/core)
# Create a new git branch for your formula so your pull request is easy to
# modify if any changes come up during review.
git checkout -b &lt;some-descriptive-name&gt; origin/master
git add Formula/foo.rb
git commit</pre> <p>The established standard for Git commit messages is:</p> <ul> <li>the first line is a commit summary of <em>50 characters or less</em>
</li> <li>two (2) newlines, then</li> <li>explain the commit thoroughly.</li> </ul> <p>At Homebrew, we like to put the name of the formula up front like so: <code class="highlighter-rouge">foobar 7.3 (new formula)</code>. This may seem crazy short, but you’ll find that forcing yourself to summarise the commit encourages you to be atomic and concise. If you can’t summarise it in 50-80 characters, you’re probably trying to commit two commits as one. For a more thorough explanation, please read Tim Pope’s excellent blog post, <a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">A Note About Git Commit Messages</a>.</p> <p>The preferred commit message format for simple version updates is <code class="highlighter-rouge">foobar 7.3</code> and for fixes is <code class="highlighter-rouge">foobar: fix flibble matrix.</code>.</p> <p>Ensure you reference any relevant GitHub issue, e.g. <code class="highlighter-rouge">Closes #12345</code> in the commit message. Homebrew’s history is the first thing future contributors will look to when trying to understand the current state of formulae they’re interested in.</p> <h3 id="push">Push</h3> <p>Now you just need to push your commit to GitHub.</p> <p>If you haven’t forked Homebrew yet, <a href="https://github.com/Homebrew/homebrew-core">go to the <code class="highlighter-rouge">homebrew-core</code> repository and hit the Fork button</a>.</p> <p>If you have already forked Homebrew on GitHub, then you can manually push (just make sure you have been pulling from the <code class="highlighter-rouge">Homebrew/homebrew-core</code> master):</p> <pre data-language="sh">git push https://github.com/myname/homebrew-core/ &lt;what-you-called-your-branch&gt;</pre> <p>Now, <a href="how-to-open-a-homebrew-pull-request">open a pull request</a> for your changes.</p> <ul> <li>One formula per commit; one commit per formula.</li> <li>Keep merge commits out of the pull request.</li> </ul> <h2 id="convenience-tools">Convenience tools</h2> <h3 id="messaging">Messaging</h3> <p>Three commands are provided for displaying informational messages to the user:</p> <ul> <li>
<code class="highlighter-rouge">ohai</code> for general info</li> <li>
<code class="highlighter-rouge">opoo</code> for warning messages</li> <li>
<code class="highlighter-rouge">odie</code> for error messages and immediately exiting</li> </ul> <p>In particular, when a test needs to be performed before installation use <code class="highlighter-rouge">odie</code> to bail out gracefully. For example:</p> <pre data-language="ruby">if build.with?("qt") &amp;&amp; build.with("qt5")
  odie "Options --with-qt and --with-qt5 are mutually exclusive."
end
system "make", "install"</pre> <h3 id="bininstall-foo"><code class="highlighter-rouge">bin.install "foo"</code></h3> <p>You’ll see stuff like this in some formulae. This moves the file <code class="highlighter-rouge">foo</code> into the formula’s <code class="highlighter-rouge">bin</code> directory (<code class="highlighter-rouge">/usr/local/Cellar/pkg/0.1/bin</code>) and makes it executable (<code class="highlighter-rouge">chmod 0555 foo</code>).</p> <h3 id="inreplace"><code class="highlighter-rouge">inreplace</code></h3> <p><a href="https://rubydoc.brew.sh/Utils/Inreplace"><code class="highlighter-rouge">inreplace</code></a> is a convenience function that can edit files in-place. For example:</p> <pre data-language="ruby">inreplace "path", before, after</pre> <p><code class="highlighter-rouge">before</code> and <code class="highlighter-rouge">after</code> can be strings or regular expressions. You should use the block form if you need to make multiple replacements in a file:</p> <pre data-language="ruby">inreplace "path" do |s|
  s.gsub! /foo/, "bar"
  s.gsub! "123", "456"
end</pre> <p>Make sure you modify <code class="highlighter-rouge">s</code>! This block ignores the returned value.</p> <p><a href="https://rubydoc.brew.sh/Utils/Inreplace"><code class="highlighter-rouge">inreplace</code></a> should be used instead of patches when patching something that will never be accepted upstream, e.g. making the software’s build system respect Homebrew’s installation hierarchy. If it’s something that affects both Homebrew and MacPorts (i.e. macOS specific) it should be turned into an upstream submitted patch instead.</p> <p>If you need modify variables in a <code class="highlighter-rouge">Makefile</code>, rather than using <a href="https://rubydoc.brew.sh/Utils/Inreplace"><code class="highlighter-rouge">inreplace</code></a>, pass them as arguments to <code class="highlighter-rouge">make</code>:</p> <pre data-language="ruby">system "make", "target", "VAR2=value1", "VAR2=value2", "VAR3=values can have spaces"</pre> <pre data-language="ruby">system "make", "CC=#{ENV.cc}", "PREFIX=#{prefix}"</pre> <p>Note that values <em>can</em> contain unescaped spaces if you use the multiple-argument form of <code class="highlighter-rouge">system</code>.</p> <h2 id="patches">Patches</h2> <p>While <a href="https://rubydoc.brew.sh/Formula#patch-class_method"><code class="highlighter-rouge">patch</code></a>es should generally be avoided, sometimes they are temporarily necessary.</p> <p>When <a href="https://rubydoc.brew.sh/Formula#patch-class_method"><code class="highlighter-rouge">patch</code></a>ing (i.e. fixing header file inclusion, fixing compiler warnings, etc.) the first thing to do is check whether or not the upstream project is aware of the issue. If not, file a bug report and/or submit your patch for inclusion. We may sometimes still accept your patch before it was submitted upstream but by getting the ball rolling on fixing the upstream issue you reduce the length of time we have to carry the patch around.</p> <p><em>Always justify a <a href="https://rubydoc.brew.sh/Formula#patch-class_method"><code class="highlighter-rouge">patch</code></a> with a code comment!</em> Otherwise, nobody will know when it is safe to remove the patch, or safe to leave it in when updating the formula. The comment should include a link to the relevant upstream issue(s).</p> <p>External <a href="https://rubydoc.brew.sh/Formula#patch-class_method"><code class="highlighter-rouge">patch</code></a>es can be declared using resource-style blocks:</p> <pre data-language="ruby">patch do
  url "https://example.com/example_patch.diff"
  sha256 "85cc828a96735bdafcf29eb6291ca91bac846579bcef7308536e0c875d6c81d7"
end</pre> <p>A strip level of <code class="highlighter-rouge">-p1</code> is assumed. It can be overridden using a symbol argument:</p> <pre data-language="ruby">patch :p0 do
  url "https://example.com/example_patch.diff"
  sha256 "85cc828a96735bdafcf29eb6291ca91bac846579bcef7308536e0c875d6c81d7"
end</pre> <p><a href="https://rubydoc.brew.sh/Formula#patch-class_method"><code class="highlighter-rouge">patch</code></a>es can be declared in <a href="https://rubydoc.brew.sh/Formula#stable-class_method"><code class="highlighter-rouge">stable</code></a>, <a href="https://rubydoc.brew.sh/Formula#devel-class_method"><code class="highlighter-rouge">devel</code></a>, and <a href="https://rubydoc.brew.sh/Formula#head-class_method"><code class="highlighter-rouge">head</code></a> blocks. Always use a block instead of a conditional, i.e. <code class="highlighter-rouge">stable do ... end</code> instead of <code class="highlighter-rouge">if build.stable? then ... end</code>.</p> <pre data-language="ruby">stable do
  # some other things...

  patch do
    url "https://example.com/example_patch.diff"
    sha256 "85cc828a96735bdafcf29eb6291ca91bac846579bcef7308536e0c875d6c81d7"
  end
end</pre> <p>Embedded (<strong>END</strong>) patches can be declared like so:</p> <pre data-language="ruby">patch :DATA
patch :p0, :DATA</pre> <p>with the patch data included at the end of the file:</p> <pre>__END__
diff --git a/foo/showfigfonts b/foo/showfigfonts
index 643c60b..543379c 100644
--- a/foo/showfigfonts
+++ b/foo/showfigfonts
@@ -14,6 +14,7 @@
…</pre> <p>Patches can also be embedded by passing a string. This makes it possible to provide multiple embedded patches while making only some of them conditional.</p> <pre data-language="ruby">patch :p0, "..."</pre> <p>In embedded patches, the string “HOMEBREW_PREFIX” is replaced with the value of the constant <code class="highlighter-rouge">HOMEBREW_PREFIX</code> before the patch is applied.</p> <h3 id="creating-the-diff">Creating the diff</h3> <pre data-language="sh">brew install --interactive --git foo
# (make some edits)
git diff | pbcopy
brew edit foo</pre> <p>Now just paste into the formula after <code class="highlighter-rouge">__END__</code>. Instead of <code class="highlighter-rouge">git diff | pbcopy</code>, for some editors <code class="highlighter-rouge">git diff &gt;&gt; path/to/your/formula/foo.rb</code> might help you ensure that the patch is not touched, e.g. white space removal, indentation changes, etc.</p> <h2 id="advanced-formula-tricks">Advanced formula tricks</h2> <p>If anything isn’t clear, you can usually figure it out by <code class="highlighter-rouge">grep</code>ping the <code class="highlighter-rouge">$(brew --repo homebrew/core)</code> directory. Please submit a pull request to amend this document if you think it will help!</p> <h3 id="unstable-versions-devel-head">Unstable versions (<code class="highlighter-rouge">devel</code>, <code class="highlighter-rouge">head</code>)</h3> <p>Formulae can specify alternate downloads for the upstream project’s <a href="https://rubydoc.brew.sh/Formula#head-class_method"><code class="highlighter-rouge">head</code></a> (<code class="highlighter-rouge">master</code>/<code class="highlighter-rouge">trunk</code>) or <a href="https://rubydoc.brew.sh/Formula#devel-class_method"><code class="highlighter-rouge">devel</code></a> release (unstable but not <code class="highlighter-rouge">master</code>/<code class="highlighter-rouge">trunk</code>).</p> <h4 id="head"><code class="highlighter-rouge">head</code></h4> <p><a href="https://rubydoc.brew.sh/Formula#head-class_method"><code class="highlighter-rouge">head</code></a> URLs (activated by passing <code class="highlighter-rouge">--HEAD</code>) build the development cutting edge. Specifying it is easy:</p> <pre data-language="ruby">class Foo &lt; Formula
  head "https://github.com/mxcl/lastfm-cocoa.git"
end</pre> <p>Homebrew understands <code class="highlighter-rouge">git</code>, <code class="highlighter-rouge">svn</code>, and <code class="highlighter-rouge">hg</code> URLs, and has a way to specify <code class="highlighter-rouge">cvs</code> repositories as a URL as well. You can test whether the <a href="https://rubydoc.brew.sh/Formula#head-class_method"><code class="highlighter-rouge">head</code></a> is being built with <code class="highlighter-rouge">build.head?</code>.</p> <p>To use a specific commit, tag, or branch from a repository, specify <a href="https://rubydoc.brew.sh/Formula#head-class_method"><code class="highlighter-rouge">head</code></a> with the <code class="highlighter-rouge">:tag</code> and <code class="highlighter-rouge">:revision</code>, <code class="highlighter-rouge">:revision</code>, or <code class="highlighter-rouge">:branch</code> option, like so:</p> <pre data-language="ruby">class Foo &lt; Formula
  head "https://github.com/some/package.git", :revision =&gt; "090930930295adslfknsdfsdaffnasd13"
                                         # or :branch =&gt; "develop" (the default is "master")
                                         # or :tag =&gt; "1_0_release",
                                         #    :revision =&gt; "090930930295adslfknsdfsdaffnasd13"
end</pre> <h4 id="devel"><code class="highlighter-rouge">devel</code></h4> <p>The <a href="https://rubydoc.brew.sh/Formula#devel-class_method"><code class="highlighter-rouge">devel</code></a> spec (activated by passing <code class="highlighter-rouge">--devel</code>) is used for a project’s unstable releases. <code class="highlighter-rouge">devel</code> specs are not allowed in Homebrew/homebrew-core.</p> <p>A <code class="highlighter-rouge">devel</code> spec is specified in a block:</p> <pre data-language="ruby">devel do
  url "https://foo.com/foo-0.1.tar.gz"
  sha256 "85cc828a96735bdafcf29eb6291ca91bac846579bcef7308536e0c875d6c81d7"
end</pre> <p>You can test if the <a href="https://rubydoc.brew.sh/Formula#devel-class_method"><code class="highlighter-rouge">devel</code></a> spec is in use with <code class="highlighter-rouge">build.devel?</code>.</p> <h3 id="compiler-selection">Compiler selection</h3> <p>Sometimes a package fails to build when using a certain compiler. Since recent <a href="xcode">Xcode versions</a> no longer include a GCC compiler we cannot simply force the use of GCC. Instead, the correct way to declare this is the <a href="https://rubydoc.brew.sh/Formula#fails_with-class_method"><code class="highlighter-rouge">fails_with</code></a> DSL method. A properly constructed <a href="https://rubydoc.brew.sh/Formula#fails_with-class_method"><code class="highlighter-rouge">fails_with</code></a> block documents the latest compiler build version known to cause compilation to fail, and the cause of the failure. For example:</p> <pre data-language="ruby">fails_with :clang do
  build 211
  cause "Miscompilation resulting in segfault on queries"
end</pre> <p><code class="highlighter-rouge">build</code> takes a Fixnum (an integer; you can find this number in your <code class="highlighter-rouge">brew --config</code> output). <code class="highlighter-rouge">cause</code> takes a String, and the use of heredocs is encouraged to improve readability and allow for more comprehensive documentation.</p> <p><a href="https://rubydoc.brew.sh/Formula#fails_with-class_method"><code class="highlighter-rouge">fails_with</code></a> declarations can be used with any of <code class="highlighter-rouge">:gcc</code>, <code class="highlighter-rouge">:llvm</code>, and <code class="highlighter-rouge">:clang</code>. Homebrew will use this information to select a working compiler (if one is available).</p> <h3 id="specifying-the-download-strategy-explicitly">Specifying the download strategy explicitly</h3> <p>To use one of Homebrew’s built-in download strategies, specify the <code class="highlighter-rouge">:using =&gt;</code> flag on a <a href="https://rubydoc.brew.sh/Formula#url-class_method"><code class="highlighter-rouge">url</code></a> or <a href="https://rubydoc.brew.sh/Formula#head-class_method"><code class="highlighter-rouge">head</code></a>. For example:</p> <pre data-language="ruby">class Python3 &lt; Formula
  homepage "https://www.python.org/"
  url "https://www.python.org/ftp/python/3.4.3/Python-3.4.3.tar.xz"
  sha256 "b5b3963533768d5fc325a4d7a6bd6f666726002d696f1d399ec06b043ea996b8"
  head "https://hg.python.org/cpython", :using =&gt; :hg</pre> <p>Homebrew offers anonymous download strategies.</p> <table> <thead> <tr> <th>
<code class="highlighter-rouge">:using</code> value</th> <th>download strategy</th> </tr> </thead> <tbody> <tr> <td><code class="highlighter-rouge">:bzr</code></td> <td><code class="highlighter-rouge">BazaarDownloadStrategy</code></td> </tr> <tr> <td><code class="highlighter-rouge">:curl</code></td> <td><code class="highlighter-rouge">CurlDownloadStrategy</code></td> </tr> <tr> <td><code class="highlighter-rouge">:cvs</code></td> <td><code class="highlighter-rouge">CVSDownloadStrategy</code></td> </tr> <tr> <td><code class="highlighter-rouge">:fossil</code></td> <td><code class="highlighter-rouge">FossilDownloadStrategy</code></td> </tr> <tr> <td><code class="highlighter-rouge">:git</code></td> <td><code class="highlighter-rouge">GitDownloadStrategy</code></td> </tr> <tr> <td><code class="highlighter-rouge">:hg</code></td> <td><code class="highlighter-rouge">MercurialDownloadStrategy</code></td> </tr> <tr> <td><code class="highlighter-rouge">:nounzip</code></td> <td><code class="highlighter-rouge">NoUnzipCurlDownloadStrategy</code></td> </tr> <tr> <td><code class="highlighter-rouge">:post</code></td> <td><code class="highlighter-rouge">CurlPostDownloadStrategy</code></td> </tr> <tr> <td><code class="highlighter-rouge">:svn</code></td> <td><code class="highlighter-rouge">SubversionDownloadStrategy</code></td> </tr> </tbody> </table> <p>If you need more control over the way files are downloaded and staged, you can create a custom download strategy and specify it using the <a href="https://rubydoc.brew.sh/Formula#url-class_method"><code class="highlighter-rouge">url</code></a> method’s <code class="highlighter-rouge">:using</code> option:</p> <pre data-language="ruby">class MyDownloadStrategy &lt; SomeHomebrewDownloadStrategy
  def fetch
    # downloads output to `temporary_path`
  end
end

class Foo &lt; Formula
  url "something", :using =&gt; MyDownloadStrategy
end</pre> <h3 id="just-moving-some-files">Just moving some files</h3> <p>When your code in the install function is run, the current working directory is set to the extracted tarball.</p> <p>So it is easy to just move some files:</p> <pre data-language="ruby">prefix.install "file1", "file2"</pre> <p>Or everything:</p> <pre data-language="ruby">prefix.install Dir["output/*"]</pre> <p>Generally we’d rather you were specific about what files or directories need to be installed rather than installing everything.</p> <h4 id="variables-for-directory-locations">Variables for directory locations</h4> <table> <thead> <tr> <th>Name</th> <th>Default</th> <th>Example</th> </tr> </thead> <tbody> <tr> <td><strong><code class="highlighter-rouge">HOMEBREW_PREFIX</code></strong></td> <td><code class="highlighter-rouge">/usr/local</code></td> <td> </td> </tr> <tr> <td><strong><code class="highlighter-rouge">prefix</code></strong></td> <td><code class="highlighter-rouge">#{HOMEBREW_PREFIX}/Cellar/#{name}/#{version}</code></td> <td><code class="highlighter-rouge">/usr/local/Cellar/foo/0.1</code></td> </tr> <tr> <td><strong><code class="highlighter-rouge">opt_prefix</code></strong></td> <td><code class="highlighter-rouge">#{HOMEBREW_PREFIX}/opt/#{name}</code></td> <td><code class="highlighter-rouge">/usr/local/opt/foo</code></td> </tr> <tr> <td><strong><code class="highlighter-rouge">bin</code></strong></td> <td><code class="highlighter-rouge">#{prefix}/bin</code></td> <td><code class="highlighter-rouge">/usr/local/Cellar/foo/0.1/bin</code></td> </tr> <tr> <td><strong><code class="highlighter-rouge">doc</code></strong></td> <td><code class="highlighter-rouge">#{prefix}/share/doc/foo</code></td> <td><code class="highlighter-rouge">/usr/local/Cellar/foo/0.1/share/doc/foo</code></td> </tr> <tr> <td><strong><code class="highlighter-rouge">include</code></strong></td> <td><code class="highlighter-rouge">#{prefix}/include</code></td> <td><code class="highlighter-rouge">/usr/local/Cellar/foo/0.1/include</code></td> </tr> <tr> <td><strong><code class="highlighter-rouge">info</code></strong></td> <td><code class="highlighter-rouge">#{prefix}/share/info</code></td> <td><code class="highlighter-rouge">/usr/local/Cellar/foo/0.1/share/info</code></td> </tr> <tr> <td><strong><code class="highlighter-rouge">lib</code></strong></td> <td><code class="highlighter-rouge">#{prefix}/lib</code></td> <td><code class="highlighter-rouge">/usr/local/Cellar/foo/0.1/lib</code></td> </tr> <tr> <td><strong><code class="highlighter-rouge">libexec</code></strong></td> <td><code class="highlighter-rouge">#{prefix}/libexec</code></td> <td><code class="highlighter-rouge">/usr/local/Cellar/foo/0.1/libexec</code></td> </tr> <tr> <td><strong><code class="highlighter-rouge">man</code></strong></td> <td><code class="highlighter-rouge">#{prefix}/share/man</code></td> <td><code class="highlighter-rouge">/usr/local/Cellar/foo/0.1/share/man</code></td> </tr> <tr> <td><strong><code class="highlighter-rouge">man[1-8]</code></strong></td> <td><code class="highlighter-rouge">#{prefix}/share/man/man[1-8]</code></td> <td><code class="highlighter-rouge">/usr/local/Cellar/foo/0.1/share/man/man[1-8]</code></td> </tr> <tr> <td><strong><code class="highlighter-rouge">sbin</code></strong></td> <td><code class="highlighter-rouge">#{prefix}/sbin</code></td> <td><code class="highlighter-rouge">/usr/local/Cellar/foo/0.1/sbin</code></td> </tr> <tr> <td><strong><code class="highlighter-rouge">share</code></strong></td> <td><code class="highlighter-rouge">#{prefix}/share</code></td> <td><code class="highlighter-rouge">/usr/local/Cellar/foo/0.1/share</code></td> </tr> <tr> <td><strong><code class="highlighter-rouge">pkgshare</code></strong></td> <td><code class="highlighter-rouge">#{prefix}/share/foo</code></td> <td><code class="highlighter-rouge">/usr/local/Cellar/foo/0.1/share/foo</code></td> </tr> <tr> <td><strong><code class="highlighter-rouge">etc</code></strong></td> <td><code class="highlighter-rouge">#{HOMEBREW_PREFIX}/etc</code></td> <td><code class="highlighter-rouge">/usr/local/etc</code></td> </tr> <tr> <td><strong><code class="highlighter-rouge">var</code></strong></td> <td><code class="highlighter-rouge">#{HOMEBREW_PREFIX}/var</code></td> <td><code class="highlighter-rouge">/usr/local/var</code></td> </tr> <tr> <td><strong><code class="highlighter-rouge">buildpath</code></strong></td> <td>A temporary directory somewhere on your system</td> <td><code class="highlighter-rouge">/private/tmp/[formula-name]-0q2b/[formula-name]</code></td> </tr> </tbody> </table> <p>These can be used, for instance, in code such as</p> <pre data-language="ruby">bin.install Dir["output/*"]</pre> <p>to move binaries into their correct location into the Cellar, and</p> <pre data-language="ruby">man.mkpath</pre> <p>to create the directory structure for the manual page location.</p> <p>To install man pages into specific locations, use <code class="highlighter-rouge">man1.install "foo.1", "bar.1"</code>, <code class="highlighter-rouge">man2.install "foo.2"</code>, etc.</p> <p>Note that in the context of Homebrew, <a href="https://rubydoc.brew.sh/Formula#libexec-instance_method"><code class="highlighter-rouge">libexec</code></a> is reserved for private use by the formula and therefore is not symlinked into <code class="highlighter-rouge">HOMEBREW_PREFIX</code>.</p> <h3 id="adding-optional-steps">Adding optional steps</h3> <p><strong>Note:</strong> <a href="https://rubydoc.brew.sh/Formula#option-class_method"><code class="highlighter-rouge">option</code></a>s are not allowed in Homebrew/homebrew-core as they are not tested by CI.</p> <p>If you want to add an <a href="https://rubydoc.brew.sh/Formula#option-class_method"><code class="highlighter-rouge">option</code></a>:</p> <pre data-language="ruby">class Yourformula &lt; Formula
  ...
  option "with-ham", "Description of the option"
  option "without-spam", "Another description"

  depends_on "foo" =&gt; :optional  # will automatically add a with-foo option
  ...</pre> <p>And then to define the effects the <a href="https://rubydoc.brew.sh/Formula#option-class_method"><code class="highlighter-rouge">option</code></a>s have:</p> <pre data-language="ruby">if build.with? "ham"
  # note, no "with" in the option name (it is added by the build.with? method)
end

if build.without? "ham"
  # works as you'd expect. True if `--without-ham` was given.
end</pre> <p><a href="https://rubydoc.brew.sh/Formula#option-class_method"><code class="highlighter-rouge">option</code></a> names should be prefixed with the words <code class="highlighter-rouge">with</code> or <code class="highlighter-rouge">without</code>. For example, an option to run a test suite should be named <code class="highlighter-rouge">--with-test</code> or <code class="highlighter-rouge">--with-check</code> rather than <code class="highlighter-rouge">--test</code>, and an option to enable a shared library <code class="highlighter-rouge">--with-shared</code> rather than <code class="highlighter-rouge">--shared</code> or <code class="highlighter-rouge">--enable-shared</code>.</p> <p><a href="https://rubydoc.brew.sh/Formula#option-class_method"><code class="highlighter-rouge">option</code></a>s that aren’t <code class="highlighter-rouge">build.with? </code> or <code class="highlighter-rouge">build.without?</code> should be deprecated with <a href="https://rubydoc.brew.sh/Formula#deprecated_option-class_method"><code class="highlighter-rouge">deprecated_option</code></a>. See <a href="https://github.com/Homebrew/homebrew-core/blob/3f762b63c6fbbd49191ffdf58574d7e18937d93f/Formula/wget.rb#L27-L31"><code class="highlighter-rouge">wget</code></a> for an example.</p> <h3 id="file-level-operations">File level operations</h3> <p>You can use the file utilities provided by Ruby’s <a href="https://www.ruby-doc.org/stdlib/libdoc/fileutils/rdoc/index.html"><code class="highlighter-rouge">FileUtils</code></a>. These are included in the <a href="https://rubydoc.brew.sh/Formula"><code class="highlighter-rouge">Formula</code></a> class, so you do not need the <code class="highlighter-rouge">FileUtils.</code> prefix to use them.</p> <p>When creating symlinks, take special care to ensure they are <em>relative</em> symlinks. This makes it easier to create a relocatable bottle. For example, to create a symlink in <code class="highlighter-rouge">bin</code> to an executable in <code class="highlighter-rouge">libexec</code>, use</p> <pre data-language="ruby">bin.install_symlink libexec/"name"</pre> <p>instead of:</p> <pre data-language="ruby">ln_s libexec/"name", bin</pre> <p>The symlinks created by <a href="https://rubydoc.brew.sh/Pathname#install_symlink-instance_method"><code class="highlighter-rouge">install_symlink</code></a> are guaranteed to be relative. <code class="highlighter-rouge">ln_s</code> will only produce a relative symlink when given a relative path.</p> <h3 id="handling-files-that-should-persist-over-formula-upgrades">Handling files that should persist over formula upgrades</h3> <p>For example, Ruby 1.9’s gems should be installed to <code class="highlighter-rouge">var/lib/ruby/</code> so that gems don’t need to be reinstalled when upgrading Ruby. You can usually do this with symlink trickery, or (ideally) a configure option.</p> <p>Another example would be configuration files that should not be overwritten on package upgrades. If after installation you find that to-be-persisted configuration files are not copied but instead <em>symlinked</em> into <code class="highlighter-rouge">/usr/local/etc/</code> from the Cellar, this can often be rectified by passing an appropriate argument to the package’s configure script. That argument will vary depending on a given package’s configure script and/or Makefile, but one example might be: <code class="highlighter-rouge">--sysconfdir=#{etc}</code></p> <h3 id="launchd-plist-files">launchd plist files</h3> <p>Homebrew provides two formula DSL methods for launchd plist files:</p> <ul> <li>
<a href="https://rubydoc.brew.sh/Formula#plist_name-instance_method"><code class="highlighter-rouge">plist_name</code></a> will return e.g. <code class="highlighter-rouge">homebrew.mxcl.&lt;formula&gt;</code>
</li> <li>
<a href="https://rubydoc.brew.sh/Formula#plist_path-instance_method"><code class="highlighter-rouge">plist_path</code></a> will return e.g. <code class="highlighter-rouge">/usr/local/Cellar/foo/0.1/homebrew.mxcl.foo.plist</code>
</li> </ul> <h3 id="using-environment-variables">Using environment variables</h3> <p>Homebrew has multiple levels of environment variable filtering which affects variables available to formulae.</p> <p>Firstly, the overall environment in which Homebrew runs is filtered to avoid environment contamination breaking from-source builds (<a href="https://github.com/Homebrew/brew/issues/932">https://github.com/Homebrew/brew/issues/932</a>). In particular, this process filters all but the given whitelisted variables, but allows environment variables prefixed with <code class="highlighter-rouge">HOMEBREW_</code>. The specific implementation can be seen in <a href="https://github.com/Homebrew/brew/blob/master/bin/brew"><code class="highlighter-rouge">bin/brew</code></a>.</p> <p>The second level of filtering removes sensitive environment variables (such as credentials like keys, passwords or tokens) to avoid malicious subprocesses obtaining them (<a href="https://github.com/Homebrew/brew/pull/2524">https://github.com/Homebrew/brew/pull/2524</a>). This has the effect of preventing any such variables from reaching a formula’s Ruby code as they are filtered before it is called. The specific implementation can be seen in the <a href="https://github.com/Homebrew/brew/blob/master/Library/Homebrew/extend/ENV.rb"><code class="highlighter-rouge">ENV.clear_sensitive_environment!</code> method</a>.</p> <p>In summary, environment variables used by a formula need to conform to these filtering rules in order to be available.</p> <h2 id="updating-formulae">Updating formulae</h2> <p>Eventually a new version of the software will be released. In this case you should update the <a href="https://rubydoc.brew.sh/Formula#url-class_method"><code class="highlighter-rouge">url</code></a> and <a href="https://rubydoc.brew.sh/Formula#sha256%3D-class_method"><code class="highlighter-rouge">sha256</code></a>. If a <a href="https://rubydoc.brew.sh/Formula#revision%3D-class_method"><code class="highlighter-rouge">revision</code></a> line exists outside any <code class="highlighter-rouge">bottle do</code> block <em>and</em> the new release is stable rather than devel, it should be removed.</p> <p>Leave the <code class="highlighter-rouge">bottle do ... end</code> block as-is; our CI system will update it when we pull your change.</p> <p>Check if the formula you are updating is a dependency for any other formulae by running <code class="highlighter-rouge">brew uses &lt;formula&gt;</code>. If it is a dependency, run <code class="highlighter-rouge">brew reinstall</code> for all the dependencies after it is installed and verify they work correctly.</p> <h2 id="style-guide">Style guide</h2> <p>Homebrew wants to maintain a consistent Ruby style across all formulae mostly based on <a href="https://github.com/rubocop-hq/ruby-style-guide#the-ruby-style-guide">Ruby Style Guide</a>. Other formulae may not have been updated to match this guide yet but all new ones should. Also:</p> <ul> <li>The order of methods in a formula should be consistent with other formulae (e.g.: <code class="highlighter-rouge">def install</code> goes before <code class="highlighter-rouge">def post_install</code>).</li> <li>An empty line is required before the <code class="highlighter-rouge">__END__</code> line.</li> </ul> <h2 id="troubleshooting-for-people-writing-new-formulae">Troubleshooting for people writing new formulae</h2> <h3 id="version-detection-fails">Version detection fails</h3> <p>Homebrew tries to automatically determine the <a href="https://rubydoc.brew.sh/Formula#version-class_method"><code class="highlighter-rouge">version</code></a> from the <a href="https://rubydoc.brew.sh/Formula#url-class_method"><code class="highlighter-rouge">url</code></a> to avoid duplication. If the tarball has an unusual name you may need to manually assign the <a href="https://rubydoc.brew.sh/Formula#version-class_method"><code class="highlighter-rouge">version</code></a>.</p> <h3 id="bad-makefiles">Bad makefiles</h3> <p>Not all projects have makefiles that will run in parallel so try to deparallelize by adding these lines to the <code class="highlighter-rouge">install</code> method:</p> <pre data-language="ruby">ENV.deparallelize
system "make"  # separate make and make install steps
system "make", "install"</pre> <p>If that fixes it, please open an <a href="https://github.com/Homebrew/homebrew-core/issues">issue</a> so that we can fix it for everyone.</p> <h3 id="still-wont-work">Still won’t work?</h3> <p>Check out what MacPorts and Fink do:</p> <pre data-language="sh">brew search --macports foo
brew search --fink foo</pre> <h2 id="superenv-notes">Superenv notes</h2> <p><code class="highlighter-rouge">superenv</code> is our “super environment” that isolates builds by removing <code class="highlighter-rouge">/usr/local/bin</code> and all user <code class="highlighter-rouge">PATH</code>s that are not essential for the build. It does this because user <code class="highlighter-rouge">PATH</code>s are often full of stuff that breaks builds. <code class="highlighter-rouge">superenv</code> also removes bad flags from the commands passed to <code class="highlighter-rouge">clang</code>/<code class="highlighter-rouge">gcc</code> and injects others (for example all <a href="https://rubydoc.brew.sh/Formula#keg_only-class_method"><code class="highlighter-rouge">keg_only</code></a> dependencies are added to the <code class="highlighter-rouge">-I</code> and <code class="highlighter-rouge">-L</code> flags).</p> <h2 id="fortran">Fortran</h2> <p>Some software requires a Fortran compiler. This can be declared by adding <code class="highlighter-rouge">depends_on "gcc"</code> to a formula.</p> <h2 id="mpi">MPI</h2> <p>Formula requiring MPI should use <a href="https://www.open-mpi.org/">OpenMPI</a> by adding <code class="highlighter-rouge">depends_on "open-mpi"</code> to the formula, rather than <a href="https://www.mpich.org/">MPICH</a>. These packages have conflicts and provide the same standardized interfaces. Choosing a default implementation and requiring it to be adopted allows software to link against multiple libraries that rely on MPI without creating un-anticipated incompatibilities due to differing MPI runtimes.</p> <h2 id="linear-algebra-libraries">Linear algebra libraries</h2> <p>By default packages that require BLAS/LAPACK linear algebra interfaces should link to <a href="https://www.openblas.net/">OpenBLAS</a> using <code class="highlighter-rouge">depends_on "openblas"</code> and passing <code class="highlighter-rouge">-DBLA_VENDOR=OpenBLAS</code> to CMake (applies to CMake based formula only) rather than Apple’s Accelerate framework, or the default reference lapack implementation. Apple’s implementation of BLAS/LAPACK is outdated and may introduce hard-to-debug problems. The reference <code class="highlighter-rouge">lapack</code> formula is fine, although it is not actively maintained or tuned. For this reason, formulae needing BLAS/LAPACK should link with OpenBLAS.</p> <h2 id="how-to-start-over-reset-to-upstream-master">How to start over (reset to upstream <code class="highlighter-rouge">master</code>)</h2> <p>Have you created a real mess in Git which stops you from creating a commit you want to submit to us? You might want to consider starting again from scratch. Your changes can be reset to the Homebrew <code class="highlighter-rouge">master</code> branch by running:</p> <pre data-language="sh">git checkout -f master
git reset --hard origin/master</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2009&ndash;present Homebrew contributors<br>Licensed under the BSD 2-Clause License.<br>
    <a href="https://docs.brew.sh/Formula-Cookbook" class="_attribution-link">https://docs.brew.sh/Formula-Cookbook</a>
  </p>
</div>
