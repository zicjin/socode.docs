
<h1 id="require-or-disallow-yoda-conditions-yoda">Require or disallow Yoda Conditions (yoda)</h1>
<p>The <code>--fix</code> option on the <a href="../user-guide/command-line-interface#fixing-problems">command line</a> can automatically fix some of the problems reported by this rule.</p>
<p>Yoda conditions are so named because the literal value of the condition comes first while the variable comes second. For example, the following is a Yoda condition:</p>
<pre data-language="js">if ("red" === color) {
    // ...
}</pre>
<p>This is called a Yoda condition because it reads as, "if red equals the color", similar to the way the Star Wars character Yoda speaks. Compare to the other way of arranging the operands:</p>
<pre data-language="js">if (color === "red") {
    // ...
}</pre>
<p>This typically reads, "if the color equals red", which is arguably a more natural way to describe the comparison.</p>
<p>Proponents of Yoda conditions highlight that it is impossible to mistakenly use <code>=</code> instead of <code>==</code> because you cannot assign to a literal value. Doing so will cause a syntax error and you will be informed of the mistake early on. This practice was therefore very common in early programming where tools were not yet available.</p>
<p>Opponents of Yoda conditions point out that tooling has made us better programmers because tools will catch the mistaken use of <code>=</code> instead of <code>==</code> (ESLint will catch this for you). Therefore, they argue, the utility of the pattern doesn't outweigh the readability hit the code takes while using Yoda conditions.</p>
<h2 id="rule-details">Rule Details</h2>
<p>This rule aims to enforce consistent style of conditions which compare a variable to a literal value.</p>
<h2 id="options">Options</h2>
<p>This rule can take a string option:</p>
<ul>
<li>If it is the default <code>"never"</code>, then comparisons must never be Yoda conditions.</li>
<li>If it is <code>"always"</code>, then the literal value must always come first.</li>
</ul>
<p>The default <code>"never"</code> option can have exception options in an object literal:</p>
<ul>
<li>If the <code>"exceptRange"</code> property is <code>true</code>, the rule <em>allows</em> yoda conditions in range comparisons which are wrapped directly in parentheses, including the parentheses of an <code>if</code> or <code>while</code> condition. The default value is <code>false</code>. A <em>range</em> comparison tests whether a variable is inside or outside the range between two literal values.</li>
<li>If the <code>"onlyEquality"</code> property is <code>true</code>, the rule reports yoda conditions <em>only</em> for the equality operators <code>==</code> and <code>===</code>. The default value is <code>false</code>.</li>
</ul>
<p>The <code>onlyEquality</code> option allows a superset of the exceptions which <code>exceptRange</code> allows, thus both options are not useful together.</p>
<h3 id="never">never</h3>
<p>Examples of <strong>incorrect</strong> code for the default <code>"never"</code> option:</p>
<pre data-language="js">/*eslint yoda: "error"*/

if ("red" === color) {
    // ...
}

if (`red` === color) {
    // ...
}

if (`red` === `${color}`) {
    // ...
}

if (true == flag) {
    // ...
}

if (5 &gt; count) {
    // ...
}

if (-1 &lt; str.indexOf(substr)) {
    // ...
}

if (0 &lt;= x &amp;&amp; x &lt; 1) {
    // ...
}</pre>
<p>Examples of <strong>correct</strong> code for the default <code>"never"</code> option:</p>
<pre data-language="js">/*eslint yoda: "error"*/

if (5 &amp; value) {
    // ...
}

if (value === "red") {
    // ...
}

if (value === `red`) {
    // ...
}

if (`${value}` === `red`) {

}</pre>
<h3 id="exceptrange">exceptRange</h3>
<p>Examples of <strong>correct</strong> code for the <code>"never", { "exceptRange": true }</code> options:</p>
<pre data-language="js">/*eslint yoda: ["error", "never", { "exceptRange": true }]*/

function isReddish(color) {
    return (color.hue &lt; 60 || 300 &lt; color.hue);
}

if (x &lt; -1 || 1 &lt; x) {
    // ...
}

if (count &lt; 10 &amp;&amp; (0 &lt;= rand &amp;&amp; rand &lt; 1)) {
    // ...
}

if (`blue` &lt; x &amp;&amp; x &lt; `green`) {
    // ...
}

function howLong(arr) {
    return (0 &lt;= arr.length &amp;&amp; arr.length &lt; 10) ? "short" : "long";
}</pre>
<h3 id="onlyequality">onlyEquality</h3>
<p>Examples of <strong>correct</strong> code for the <code>"never", { "onlyEquality": true }</code> options:</p>
<pre data-language="js">/*eslint yoda: ["error", "never", { "onlyEquality": true }]*/

if (x &lt; -1 || 9 &lt; x) {
}

if (x !== 'foo' &amp;&amp; 'bar' != x) {
}

if (x !== `foo` &amp;&amp; `bar` != x) {
}</pre>
<h3 id="always">always</h3>
<p>Examples of <strong>incorrect</strong> code for the <code>"always"</code> option:</p>
<pre data-language="js">/*eslint yoda: ["error", "always"]*/

if (color == "blue") {
    // ...
}

if (color == `blue`) {
    // ...
}</pre>
<p>Examples of <strong>correct</strong> code for the <code>"always"</code> option:</p>
<pre data-language="js">/*eslint yoda: ["error", "always"]*/

if ("blue" == value) {
    // ...
}

if (`blue` == value) {
    // ...
}

if (`blue` == `${value}`) {
    // ...
}

if (-1 &lt; str.indexOf(substr)) {
    // ...
}</pre>
<h2 id="further-reading">Further Reading</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Yoda_conditions">Yoda Conditions</a></li>
<li><a href="http://thomas.tuerke.net/on/design/?with=1249091668#msg1146181680">Yoda Notation and Safe Switching</a></li>
</ul>
<h2 id="version">Version</h2>
<p>This rule was introduced in ESLint 0.7.1.</p>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="https://github.com/eslint/eslint/tree/master/lib/rules/yoda.js">Rule source</a></li>
<li><a href="https://github.com/eslint/eslint/tree/master/docs/rules/yoda.md">Documentation source</a></li>
</ul><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://eslint.org/docs/rules/yoda" class="_attribution-link" target="_blank">https://eslint.org/docs/rules/yoda</a>
  </p>
</div>
