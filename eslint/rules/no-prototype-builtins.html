
<h1 id="disallow-use-of-objectprototypes-builtins-directly-no-prototype-builtins">Disallow use of Object.prototypes builtins directly (no-prototype-builtins)</h1>
<p>The <code>"extends": "eslint:recommended"</code> property in a configuration file enables this rule.</p>
<p>In ECMAScript 5.1, <code>Object.create</code> was added, which enables the creation of objects with a specified <code>[[Prototype]]</code>. <code>Object.create(null)</code> is a common pattern used to create objects that will be used as a Map. This can lead to errors when it is assumed that objects will have properties from <code>Object.prototype</code>. This rule prevents calling some <code>Object.prototype</code> methods directly from an object.</p>
<p>Additionally, objects can have properties that shadow the builtins on <code>Object.prototype</code>, potentially causing unintended behavior or denial-of-service security vulnerabilities. For example, it would be unsafe for a webserver to parse JSON input from a client and call <code>hasOwnProperty</code> directly on the resulting object, because a malicious client could send a JSON value like <code>{"hasOwnProperty": 1}</code> and cause the server to crash.</p>
<p>To avoid subtle bugs like this, it's better to always call these methods from <code>Object.prototype</code>. For example, <code>foo.hasOwnProperty("bar")</code> should be replaced with <code>Object.prototype.hasOwnProperty.call(foo, "bar")</code>.</p>
<h2 id="rule-details">Rule Details</h2>
<p>This rule disallows calling some <code>Object.prototype</code> methods directly on object instances.</p>
<p>Examples of <strong>incorrect</strong> code for this rule:</p>
<pre data-language="js">/*eslint no-prototype-builtins: "error"*/

var hasBarProperty = foo.hasOwnProperty("bar");

var isPrototypeOfBar = foo.isPrototypeOf(bar);

var barIsEnumerable = foo.propertyIsEnumerable("bar");</pre>
<p>Examples of <strong>correct</strong> code for this rule:</p>
<pre data-language="js">/*eslint no-prototype-builtins: "error"*/

var hasBarProperty = Object.prototype.hasOwnProperty.call(foo, "bar");

var isPrototypeOfBar = Object.prototype.isPrototypeOf.call(foo, bar);

var barIsEnumerable = {}.propertyIsEnumerable.call(foo, "bar");</pre>
<h2 id="when-not-to-use-it">When Not To Use It</h2>
<p>You may want to turn this rule off if your code only touches objects with hardcoded keys, and you will never use an object that shadows an <code>Object.prototype</code> method or which does not inherit from <code>Object.prototype</code>.</p>
<h2 id="version">Version</h2>
<p>This rule was introduced in ESLint 2.11.0.</p>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="https://github.com/eslint/eslint/tree/master/lib/rules/no-prototype-builtins.js">Rule source</a></li>
<li><a href="https://github.com/eslint/eslint/tree/master/docs/rules/no-prototype-builtins.md">Documentation source</a></li>
</ul><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://eslint.org/docs/rules/no-prototype-builtins" class="_attribution-link" target="_blank">https://eslint.org/docs/rules/no-prototype-builtins</a>
  </p>
</div>
