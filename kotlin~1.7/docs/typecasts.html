<h1 data-toc="typecasts" id="typecasts.md">Type checks and casts</h1>
<section class="chapter"><h2 id="is-and-is-operators" data-toc="typecasts#is-and-is-operators">is and !is operators</h2>
<p id="7c78e370">Use the <code class="code ">is</code> operator or its negated form <code class="code ">!is</code> to perform a runtime check that identifies whether an object conforms to a given type:</p>
<pre class="code" data-language="kotlin">if (obj is String) {
    print(obj.length)
}

if (obj !is String) { // same as !(obj is String)
    print("Not a String")
} else {
    print(obj.length)
}
</pre></section><section class="chapter"><h2 id="smart-casts" data-toc="typecasts#smart-casts">Smart casts</h2>
<p id="bd5f40bf">In most cases, you don't need to use explicit cast operators in Kotlin because the compiler tracks the <code class="code ">is</code>-checks and <a href="#unsafe-cast-operator" id="3c2417bf">explicit casts</a> for immutable values and inserts (safe) casts automatically when necessary:</p>
<pre class="code" data-language="kotlin">fun demo(x: Any) {
    if (x is String) {
        print(x.length) // x is automatically cast to String
    }
}
</pre>
<p id="d5ca25a6">The compiler is smart enough to know that a cast is safe if a negative check leads to a return:</p>
<pre class="code" data-language="kotlin">if (x !is String) return

print(x.length) // x is automatically cast to String
</pre>
<p id="5666f20c">or if it is on the right-hand side of <code class="code ">&amp;&amp;</code> or <code class="code ">||</code> and the proper check (regular or negative) is on the left-hand side:</p>
<pre class="code" data-language="kotlin">// x is automatically cast to String on the right-hand side of `||`
if (x !is String || x.length == 0) return

// x is automatically cast to String on the right-hand side of `&amp;&amp;`
if (x is String &amp;&amp; x.length &gt; 0) {
    print(x.length) // x is automatically cast to String
}
</pre>
<p id="c34ca242">Smart casts work for <a href="control-flow#when-expression" id="e7238f45"><code class="code ">when</code> expressions</a> and <a href="control-flow#while-loops" id="a2180bd7"><code class="code ">while</code> loops</a> as well:</p>
<pre class="code" data-language="kotlin">when (x) {
    is Int -&gt; print(x + 1)
    is String -&gt; print(x.length + 1)
    is IntArray -&gt; print(x.sum())
}
</pre>
<p id="dc1f06af">Note that smart casts work only when the compiler can guarantee that the variable won't change between the check and the usage. More specifically, smart casts can be used under the following conditions:</p>
<ul class="list _ul" id="dc8e8295">
<li class="list__item" id="b4a1dba6"><p><code class="code ">val</code> local variables - always, with the exception of <a href="delegated-properties" id="3cfd1b0">local delegated properties</a>.</p></li>
<li class="list__item" id="eeb33322"><p><code class="code ">val</code> properties - if the property is private or internal or if the check is performed in the same <a href="visibility-modifiers#modules" id="4802292d">module</a> where the property is declared. Smart casts cannot be used on open properties or properties that have custom getters.</p></li>
<li class="list__item" id="3e0bd77c"><p><code class="code ">var</code> local variables - if the variable is not modified between the check and the usage, is not captured in a lambda that modifies it, and is not a local delegated property.</p></li>
<li class="list__item" id="9c1e6c76"><p><code class="code ">var</code> properties - never, because the variable can be modified at any time by other code.</p></li>
</ul></section><section class="chapter"><h2 id="unsafe-cast-operator" data-toc="typecasts#unsafe-cast-operator">"Unsafe" cast operator</h2>
<p id="e2796782">Usually, the cast operator throws an exception if the cast isn't possible. And so, it's called <em id="85e440e2" class="">unsafe</em>. The unsafe cast in Kotlin is done by the infix operator <code class="code ">as</code>.</p>
<pre class="code" data-language="kotlin">val x: String = y as String
</pre>
<p id="58bc551d">Note that <code class="code ">null</code> cannot be cast to <code class="code ">String</code>, as this type is not <a href="null-safety" id="a066c4a2">nullable</a>. If <code class="code ">y</code> is null, the code above throws an exception. To make code like this correct for null values, use the nullable type on the right-hand side of the cast:</p>
<pre class="code" data-language="kotlin">val x: String? = y as String?
</pre></section><section class="chapter"><h2 id="safe-nullable-cast-operator" data-toc="typecasts#safe-nullable-cast-operator">"Safe" (nullable) cast operator</h2>
<p id="4f288752">To avoid exceptions, use the <em id="8432a0d4" class="">safe</em> cast operator <code class="code ">as?</code>, which returns <code class="code ">null</code> on failure.</p>
<pre class="code" data-language="kotlin">val x: String? = y as? String
</pre>
<p id="c208d0b7">Note that despite the fact that the right-hand side of <code class="code ">as?</code> is a non-null type <code class="code ">String</code>, the result of the cast is nullable.</p></section><section class="chapter"><h2 id="type-erasure-and-generic-type-checks" data-toc="typecasts#type-erasure-and-generic-type-checks">Type erasure and generic type checks</h2>
<p id="2d1c71e5">Kotlin ensures type safety for operations involving <a href="generics" id="e40ce4f7">generics</a> at compile time, while, at runtime, instances of generic types don't hold information about their actual type arguments. For example, <code class="code ">List&lt;Foo&gt;</code> is erased to just <code class="code ">List&lt;*&gt;</code>. In general, there is no way to check whether an instance belongs to a generic type with certain type arguments at runtime.</p>
<p id="d9b42096">Because of that, the compiler prohibits <code class="code ">is</code>-checks that cannot be performed at runtime due to type erasure, such as <code class="code ">ints is List&lt;Int&gt;</code> or <code class="code ">list is T</code> (type parameter). You can, however, check an instance against a <a href="generics#star-projections" id="df215aa5">star-projected type</a>:</p>
<pre class="code" data-language="kotlin">if (something is List&lt;*&gt;) {
    something.forEach { println(it) } // The items are typed as `Any?`
}
</pre>
<p id="1b9fa53d">Similarly, when you already have the type arguments of an instance checked statically (at compile time), you can make an <code class="code ">is</code>-check or a cast that involves the non-generic part of the type. Note that angle brackets are omitted in this case:</p>
<pre class="code" data-language="kotlin">fun handleStrings(list: List&lt;String&gt;) {
    if (list is ArrayList) {
        // `list` is smart-cast to `ArrayList&lt;String&gt;`
    }
}
</pre>
<p id="463229c6">The same syntax but with the type arguments omitted can be used for casts that do not take type arguments into account: <code class="code ">list as ArrayList</code>.</p>
<p id="9195a233">Inline functions with <a href="inline-functions#reified-type-parameters" id="5e2813f9">reified type parameters</a> have their actual type arguments inlined at each call site. This enables <code class="code ">arg is T</code> checks for the type parameters, but if <code class="code ">arg</code> is an instance of a generic type itself, <em id="9b3f13c0" class="">its</em> type arguments are still erased.</p>
<pre class="code" data-language="kotlin">//sampleStart
inline fun &lt;reified A, reified B&gt; Pair&lt;*, *&gt;.asPairOf(): Pair&lt;A, B&gt;? {
    if (first !is A || second !is B) return null
    return first as A to second as B
}

val somePair: Pair&lt;Any?, Any?&gt; = "items" to listOf(1, 2, 3)


val stringToSomething = somePair.asPairOf&lt;String, Any&gt;()
val stringToInt = somePair.asPairOf&lt;String, Int&gt;()
val stringToList = somePair.asPairOf&lt;String, List&lt;*&gt;&gt;()
val stringToStringList = somePair.asPairOf&lt;String, List&lt;String&gt;&gt;() // Compiles but breaks type safety!
// Expand the sample for more details

//sampleEnd

fun main() {
    println("stringToSomething = " + stringToSomething)
    println("stringToInt = " + stringToInt)
    println("stringToList = " + stringToList)
    println("stringToStringList = " + stringToStringList)
    //println(stringToStringList?.second?.forEach() {it.length}) // This will throw ClassCastException as list items are not String
}
</pre></section><section class="chapter"><h2 id="unchecked-casts" data-toc="typecasts#unchecked-casts">Unchecked casts</h2>
<p id="524fc4d0">As established above, type erasure makes checking the actual type arguments of a generic type instance impossible at runtime. Additionally, generic types in the code might not be connected to each other closely enough for the compiler to ensure type safety.</p>
<p id="8ee7d0c0">Even so, sometimes we have high-level program logic that implies type safety instead. For example:</p>
<pre class="code" data-language="kotlin">fun readDictionary(file: File): Map&lt;String, *&gt; = file.inputStream().use {
   TODO("Read a mapping of strings to arbitrary elements.")
}

// We saved a map with `Int`s into this file
val intsFile = File("ints.dictionary")

// Warning: Unchecked cast: `Map&lt;String, *&gt;` to `Map&lt;String, Int&gt;`
val intsDictionary: Map&lt;String, Int&gt; = readDictionary(intsFile) as Map&lt;String, Int&gt;
</pre>
<p id="ce551167">A warning appears for the cast in the last line. The compiler can't fully check it at runtime and provides no guarantee that the values in the map are <code class="code ">Int</code>.</p>
<p id="80c77358">To avoid unchecked casts, you can redesign the program structure. In the example above, you could use the <code class="code ">DictionaryReader&lt;T&gt;</code> and <code class="code ">DictionaryWriter&lt;T&gt;</code> interfaces with type-safe implementations for different types. You can introduce reasonable abstractions to move unchecked casts from the call site to the implementation details. Proper use of <a href="generics#variance" id="25e4ee5d">generic variance</a> can also help.</p>
<p id="22f283d8">For generic functions, using <a href="inline-functions#reified-type-parameters" id="f53a7e22">reified type parameters</a> makes casts like <code class="code ">arg as T</code> checked, unless <code class="code ">arg</code>'s type has <em id="a445d29c" class="">its own</em> type arguments that are erased.</p>
<p id="e24cee2b">An unchecked cast warning can be suppressed by <a href="annotations" id="4894c38b">annotating</a> the statement or the declaration where it occurs with <code class="code ">@Suppress("UNCHECKED_CAST")</code>:</p>
<pre class="code" data-language="kotlin">inline fun &lt;reified T&gt; List&lt;*&gt;.asListOfType(): List&lt;T&gt;? =
    if (all { it is T })
        @Suppress("UNCHECKED_CAST")
        this as List&lt;T&gt; else
        null
</pre>
<aside data-type="note" class="prompt" data-title="" id="1ff5c494"><p id="ecb12eca"><b id="b975fb85" class="">On the JVM</b>: <a href="basic-types#arrays" id="4c7ec6bb">array types</a> (<code class="code ">Array&lt;Foo&gt;</code>) retain information about the erased type of their elements, and type casts to an array type are partially checked: the nullability and actual type arguments of the element type are still erased. For example, the cast <code class="code ">foo as Array&lt;List&lt;String&gt;?&gt;</code> will succeed if <code class="code ">foo</code> is an array holding any <code class="code ">List&lt;*&gt;</code>, whether it is nullable or not.</p></aside></section><div class="last-modified"> Last modified: 08 August 2022</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="basic-types">Basic types</a> <a class="navigation-links__next" href="control-flow">Conditions and loops</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/typecasts.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/typecasts.html</a>
  </p>
</div>
