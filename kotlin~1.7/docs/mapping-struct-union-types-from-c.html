<h1 data-toc="mapping-struct-union-types-from-c" id="mapping-struct-union-types-from-c.md">Mapping struct and union types from C – tutorial</h1>
<p id="26c3b5b1">This is the second post in the series. The very first tutorial of the series is <a href="mapping-primitive-data-types-from-c" id="6abd54cf">Mapping primitive data types from C</a>. There are also the <a href="mapping-function-pointers-from-c" id="e15467db">Mapping function pointers from C</a> and <a href="mapping-strings-from-c" id="c2f080c3">Mapping Strings from C</a> tutorials.</p>
<p id="25c75609">In the tutorial, you will learn:</p>
<ul class="list _ul" id="df740161">
<li class="list__item" id="cf21f0c5"><p><a href="#mapping-struct-and-union-c-types" id="fe74dbc">How struct and union types are mapped</a></p></li>
<li class="list__item" id="4de63d1b"><p><a href="#use-struct-and-union-types-from-kotlin" id="d52ef9d6">How to use struct and union type from Kotlin</a></p></li>
</ul>
<section class="chapter"><h2 id="mapping-struct-and-union-c-types" data-toc="mapping-struct-union-types-from-c#mapping-struct-and-union-c-types">Mapping struct and union C types</h2>
<p id="2a5182d6">The best way to understand the mapping between Kotlin and C is to try a tiny example. We will declare a struct and a union in the C language, to see how they are mapped into Kotlin.</p>
<p id="4806964c">Kotlin/Native comes with the <code class="code ">cinterop</code> tool, the tool generates bindings between the C language and Kotlin. It uses a <code class="code ">.def</code> file to specify a C library to import. More details are discussed in the <a href="native-c-interop" id="bd797dfa">Interop with C Libraries</a> tutorial.</p>
<p id="d0e9a2d0">In <a href="mapping-primitive-data-types-from-c" id="69f822c3">the previous tutorial</a>, you've created a <code class="code ">lib.h</code> file. This time, include those declarations directly into the <code class="code ">interop.def</code> file, after the <code class="code ">---</code> separator line:</p>
<pre class="code" data-language="c">
---

typedef struct {
  int a;
  double b;
} MyStruct;

void struct_by_value(MyStruct s) {}
void struct_by_pointer(MyStruct* s) {}

typedef union {
  int a;
  MyStruct b;
  float c;
} MyUnion;

void union_by_value(MyUnion u) {}
void union_by_pointer(MyUnion* u) {}

</pre>
<p id="8fbc9218">The <code class="code ">interop.def</code> file is enough to compile and run the application or open it in an IDE. Now it is time to create project files, open the project in <a href="https://jetbrains.com/idea" id="c022bd77" data-external="true" rel="noopener noreferrer">IntelliJ IDEA</a> and run it.</p></section><section class="chapter"><h2 id="inspect-generated-kotlin-apis-for-a-c-library" data-toc="mapping-struct-union-types-from-c#inspect-generated-kotlin-apis-for-a-c-library">Inspect Generated Kotlin APIs for a C library</h2>
<p id="8123c05b">While it is possible to use the command line, either directly or by combining it with a script file (such as <code class="code ">.sh</code> or <code class="code ">.bat</code> file), this approach doesn't scale well for big projects that have hundreds of files and libraries. It is then better to use the Kotlin/Native compiler with a build system, as it helps to download and cache the Kotlin/Native compiler binaries and libraries with transitive dependencies and run the compiler and tests. Kotlin/Native can use the <a href="https://gradle.org" id="d067dd5e" data-external="true" rel="noopener noreferrer">Gradle</a> build system through the <a href="multiplatform-discover-project#multiplatform-plugin" id="7c394659">kotlin-multiplatform</a> plugin.</p>
<p id="59fc3f98">We covered the basics of setting up an IDE compatible project with Gradle in the <a href="native-gradle" id="6c000c73">A Basic Kotlin/Native Application</a> tutorial. Please check it out if you are looking for detailed first steps and instructions on how to start a new Kotlin/Native project and open it in IntelliJ IDEA. In this tutorial, we'll look at the advanced C interop related usages of Kotlin/Native and <a href="multiplatform-discover-project#multiplatform-plugin" id="21cf120d">multiplatform</a> builds with Gradle.</p>
<p id="b1a1208e">First, create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes the missing directories will have to be created before any new files can be added.</p>
<p id="5eab81b3">Use the following <code class="code ">build.gradle(.kts)</code> Gradle build file:</p>
<div class="tabs" id="4b18a073" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="cf56c8b0" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code" data-language="kotlin">plugins {
    kotlin("multiplatform") version "1.7.10"
}

repositories {
    mavenCentral()
}

kotlin {
  linuxX64("native") { // on Linux
  // macosX64("native") { // on x86_64 macOS
  // macosArm64("native") { // on Apple Silicon macOS
  // mingwX64("native") { // on Windows
    val main by compilations.getting
    val interop by main.cinterops.creating
    
    binaries {
      executable()
    }
  }
}

tasks.wrapper {
  gradleVersion = "6.7.1"
  distributionType = Wrapper.DistributionType.BIN
}
</pre></div>
<div class="tabs__content" data-gtm="tab" id="a5893ca4" data-sync-tabs="groovy" data-title="Groovy"><pre class="code" data-language="groovy">plugins {
    id 'org.jetbrains.kotlin.multiplatform' version '1.7.10'
}

repositories {
    mavenCentral()
}

kotlin {
  linuxX64('native') { // on Linux
  // macosX64("native") { // on x86_64 macOS
  // macosArm64("native") { // on Apple Silicon macOS
  // mingwX64('native') { // on Windows
    compilations.main.cinterops {
      interop 
    }
    
    binaries {
      executable()
    }
  }
}

wrapper {
  gradleVersion = '6.7.1'
  distributionType = 'BIN'
}
</pre></div>
</div>
<p id="edfe5a3f">The project file configures the C interop as an additional step of the build. Let's move the <code class="code ">interop.def</code> file to the <code class="code ">src/nativeInterop/cinterop</code> directory. Gradle recommends using conventions instead of configurations, for example, the source files are expected to be in the <code class="code ">src/nativeMain/kotlin</code> folder. By default, all the symbols from C are imported to the <code class="code ">interop</code> package, you may want to import the whole package in our <code class="code ">.kt</code> files. Check out the <a href="multiplatform-discover-project#multiplatform-plugin" id="d10ac61b">kotlin-multiplatform</a> plugin documentation to learn about all the different ways you could configure it.</p>
<p id="d87187c6">Create a <code class="code ">src/nativeMain/kotlin/hello.kt</code> stub file with the following content to see how C struct and union declarations are visible from Kotlin:</p>
<pre class="code" data-language="kotlin">import interop.*

fun main() {
  println("Hello Kotlin/Native!")
  
  struct_by_value(/* fix me*/)
  struct_by_pointer(/* fix me*/)
  union_by_value(/* fix me*/)
  union_by_pointer(/* fix me*/)
}
</pre>
<p id="2769891c">Now you are ready to <a href="native-get-started" id="b32722b7">open the project in IntelliJ IDEA</a> and to see how to fix the example project. While doing that, see how C struct and union types are mapped into Kotlin/Native.</p></section><section class="chapter"><h2 id="struct-and-union-types-in-kotlin" data-toc="mapping-struct-union-types-from-c#struct-and-union-types-in-kotlin">Struct and union types in Kotlin</h2>
<p id="e2e5a0a5">With the help of IntelliJ IDEA's <b id="4b68f2aa" class="">Go to | Declaration</b> or compiler errors, you see the following generated API for the C functions, <code class="code ">struct</code>, and <code class="code ">union</code>:</p>
<pre class="code" data-language="kotlin">fun struct_by_value(s: CValue&lt;MyStruct&gt;)
fun struct_by_pointer(s: CValuesRef&lt;MyStruct&gt;?)

fun union_by_value(u: CValue&lt;MyUnion&gt;)
fun union_by_pointer(u: CValuesRef&lt;MyUnion&gt;?)

class MyStruct constructor(rawPtr: NativePtr /* = NativePtr */) : CStructVar {
    var a: Int
    var b: Double
    companion object : CStructVar.Type
}

class MyUnion constructor(rawPtr: NativePtr /* = NativePtr */) : CStructVar {
    var a: Int
    val b: MyStruct
    var c: Float
    companion object : CStructVar.Type
}
</pre>
<p id="a4924bd">You see that <code class="code ">cinterop</code> generated wrapper types for our <code class="code ">struct</code> and <code class="code ">union</code> types. For <code class="code ">MyStruct</code> and <code class="code ">MyUnion</code> type declarations in C, there are the Kotlin classes <code class="code ">MyStruct</code> and <code class="code ">MyUnion</code> generated respectively. The wrappers inherit from the <code class="code ">CStructVar</code> base class and declare all fields as Kotlin properties. It uses <code class="code ">CValue&lt;T&gt;</code> to represent a by-value structure parameter and <code class="code ">CValuesRef&lt;T&gt;?</code> to represent passing a pointer to a structure or a union.</p>
<p id="acfa903f">Technically, there is no difference between <code class="code ">struct</code> and <code class="code ">union</code> types on the Kotlin side. Note that <code class="code ">a</code>, <code class="code ">b</code>, and <code class="code ">c</code> properties of <code class="code ">MyUnion</code> class in Kotlin use the same memory location to read/write their value just like <code class="code ">union</code> does in C language.</p>
<p id="1e503d6">More details and advanced use-cases are presented in the<br><a href="native-c-interop" id="4f2d8514">C Interop documentation</a></p></section><section class="chapter"><h2 id="use-struct-and-union-types-from-kotlin" data-toc="mapping-struct-union-types-from-c#use-struct-and-union-types-from-kotlin">Use struct and union types from Kotlin</h2>
<p id="3c90b63b">It is easy to use the generated wrapper classes for C <code class="code ">struct</code> and <code class="code ">union</code> types from Kotlin. Thanks to the generated properties, it feels natural to use them in Kotlin code. The only question, so far, is how to create a new instance on those classes. As you see from the declarations of <code class="code ">MyStruct</code> and <code class="code ">MyUnion</code>, their constructors require a <code class="code ">NativePtr</code>. Of course, you are not willing to deal with pointers manually. Instead, you can use Kotlin API to have those objects instantiated for us.</p>
<p id="8f553b63">Let's take a look at the generated functions that take our <code class="code ">MyStruct</code> and <code class="code ">MyUnion</code> as parameters. You see that by-value parameters are represented as <code class="code ">kotlinx.cinterop.CValue&lt;T&gt;</code>. And for typed pointer parameters you see <code class="code ">kotlinx.cinterop.CValuesRef&lt;T&gt;</code>. Kotlin provides us with an API to deal with both types easily, let's try it and see.</p>
<section class="chapter"><h3 id="create-a-cvalue-lt-t-gt" data-toc="mapping-struct-union-types-from-c#create-a-cvalue-lt-t-gt">Create a CValue
</h3>
<p id="361bd3ec"><code class="code ">CValue&lt;T&gt;</code> type is used to pass by-value parameters to a C function call. Use <code class="code ">cValue</code> function to create <code class="code ">CValue&lt;T&gt;</code> object instance. The function requires a <a href="lambdas#function-literals-with-receiver" id="3f81dfe2">lambda function with a receiver</a> to initialize the underlying C type in-place. The function is declared as follows:</p>
<pre class="code" data-language="kotlin">fun &lt;reified T : CStructVar&gt; cValue(initialize: T.() -&gt; Unit): CValue&lt;T&gt;
</pre>
<p id="d81f45b9">Now it is time to see how to use <code class="code ">cValue</code> and pass by-value parameters:</p>
<pre class="code" data-language="kotlin">fun callValue() {

  val cStruct = cValue&lt;MyStruct&gt; {
    a = 42
    b = 3.14
  }
  struct_by_value(cStruct)

  val cUnion = cValue&lt;MyUnion&gt; {
    b.a = 5
    b.b = 2.7182
  }

  union_by_value(cUnion)
}
</pre></section><section class="chapter"><h3 id="create-struct-and-union-as-cvaluesref-lt-t-gt" data-toc="mapping-struct-union-types-from-c#create-struct-and-union-as-cvaluesref-lt-t-gt">Create struct and union as CValuesRef
</h3>
<p id="3ab91509"><code class="code ">CValuesRef&lt;T&gt;</code> type is used in Kotlin to pass a typed pointer parameter of a C function. First, you need an instance of <code class="code ">MyStruct</code> and <code class="code ">MyUnion</code> classes. Create them directly in the native memory. Use the</p>
<pre class="code" data-language="kotlin">fun &lt;reified T : kotlinx.cinterop.CVariable&gt; alloc(): T   
</pre>
<p id="dcf09e30">extension function on <code class="code ">kotlinx.cinterop.NativePlacement</code> type for this.</p>
<p id="af7a5cf2"><code class="code ">NativePlacement</code> represents native memory with functions similar to <code class="code ">malloc</code> and <code class="code ">free</code>. There are several implementations of <code class="code ">NativePlacement</code>. The global one is called with <code class="code ">kotlinx.cinterop.nativeHeap</code> and don't forget to call the <code class="code ">nativeHeap.free(..)</code> function to free the memory after use.</p>
<p id="37408102">Another option is to use the</p>
<pre class="code" data-language="kotlin">fun &lt;R&gt; memScoped(block: kotlinx.cinterop.MemScope.() -&gt; R): R    
</pre>
<p id="440f05fa">function. It creates a short-lived memory allocation scope, and all allocations will be cleaned up automatically at the end of the <code class="code ">block</code>.</p>
<p id="517ff43">Your code to call functions with pointers will look like this:</p>
<pre class="code" data-language="kotlin">fun callRef() {
  memScoped {
    val cStruct = alloc&lt;MyStruct&gt;()
    cStruct.a = 42
    cStruct.b = 3.14

    struct_by_pointer(cStruct.ptr)

val cUnion = alloc&lt;MyUnion&gt;()
    cUnion.b.a = 5
    cUnion.b.b = 2.7182

    union_by_pointer(cUnion.ptr)
  }
}

</pre>
<p id="a47fb83f">Note that this code uses the extension property <code class="code ">ptr</code> which comes from a <code class="code ">memScoped</code> lambda receiver type, to turn <code class="code ">MyStruct</code> and <code class="code ">MyUnion</code> instances into native pointers.</p>
<p id="c20bc968">The <code class="code ">MyStruct</code> and <code class="code ">MyUnion</code> classes have the pointer to the native memory underneath. The memory will be released when a <code class="code ">memScoped</code> function ends, which is equal to the end of its <code class="code ">block</code>. Make sure that a pointer is not used outside of the <code class="code ">memScoped</code> call. You may use <code class="code ">Arena()</code> or <code class="code ">nativeHeap</code> for pointers that should be available longer, or are cached inside a C library.</p></section><section class="chapter"><h3 id="conversion-between-cvalue-lt-t-gt-and-cvaluesref-lt-t-gt" data-toc="mapping-struct-union-types-from-c#conversion-between-cvalue-lt-t-gt-and-cvaluesref-lt-t-gt">Conversion between CValue<t> and CValuesRef</t>
</h3>
<p id="8c210f7c">Of course, there are use cases when you need to pass a struct as a value to one call, and then, to pass the same struct as a reference to another call. This is possible in Kotlin/Native too. A <code class="code ">NativePlacement</code> will be needed here.</p>
<p id="3d885e83">Let's see now <code class="code ">CValue&lt;T&gt;</code> is turned to a pointer first:</p>
<pre class="code" data-language="kotlin">fun callMix_ref() {
  val cStruct = cValue&lt;MyStruct&gt; {
    a = 42
    b = 3.14
  }
  
  memScoped { 
    struct_by_pointer(cStruct.ptr)
  }
}
</pre>
<p id="c365bad0">This code uses the extension property <code class="code ">ptr</code> which comes from <code class="code ">memScoped</code> lambda receiver type to turn <code class="code ">MyStruct</code> and <code class="code ">MyUnion</code> instances into native pointers. Those pointers are only valid inside the <code class="code ">memScoped</code> block.</p>
<p id="5218d408">For the opposite conversion, to turn a pointer into a by-value variable, we call the <code class="code ">readValue()</code> extension function:</p>
<pre class="code" data-language="kotlin">fun callMix_value() {
  memScoped {
    val cStruct = alloc&lt;MyStruct&gt;()
    cStruct.a = 42
    cStruct.b = 3.14

    struct_by_value(cStruct.readValue())
  }
}
</pre></section></section><section class="chapter"><h2 id="run-the-code" data-toc="mapping-struct-union-types-from-c#run-the-code">Run the code</h2>
<p id="5688f931">Now when you have learned how to use C declarations in your code, you are ready to try it out on a real example. Let's fix the code and see how it runs by calling the <code class="code ">runDebugExecutableNative</code> Gradle task <a href="native-get-started" id="3b549846">in the IDE</a> or by using the following console command:</p>
<pre class="code" data-language="bash">./gradlew runDebugExecutableNative
</pre>
<p id="ea54819f">The final code in the <code class="code ">hello.kt</code> file may look like this:</p>
<pre class="code" data-language="kotlin">import interop.*
import kotlinx.cinterop.alloc
import kotlinx.cinterop.cValue
import kotlinx.cinterop.memScoped
import kotlinx.cinterop.ptr
import kotlinx.cinterop.readValue

fun main() {
  println("Hello Kotlin/Native!")

  val cUnion = cValue&lt;MyUnion&gt; {
    b.a = 5
    b.b = 2.7182
  }

  memScoped {
    union_by_value(cUnion)
    union_by_pointer(cUnion.ptr)
  }

  memScoped {
    val cStruct = alloc&lt;MyStruct&gt; {
      a = 42
      b = 3.14
    }

    struct_by_value(cStruct.readValue())
    struct_by_pointer(cStruct.ptr)
  }
}
</pre></section><section class="chapter"><h2 id="next-steps" data-toc="mapping-struct-union-types-from-c#next-steps">Next steps</h2>
<p id="5bc2baef">Continue exploring the C language types and their representation in Kotlin/Native in the related tutorials:</p>
<ul class="list _ul" id="70a82235">
<li class="list__item" id="4f4d8b45"><p><a href="mapping-primitive-data-types-from-c" id="dfe666a4">Mapping primitive data types from C</a></p></li>
<li class="list__item" id="3e1ca73a"><p><a href="mapping-function-pointers-from-c" id="fcdeed0e">Mapping function pointers from C</a></p></li>
<li class="list__item" id="80ebed5d"><p><a href="mapping-strings-from-c" id="161db0f1">Mapping strings from C</a></p></li>
</ul>
<p id="c62b558b">The <a href="native-c-interop" id="a6268d89">C Interop documentation</a> covers more advanced scenarios of the interop.</p></section><div class="last-modified"> Last modified: 08 August 2022</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="mapping-primitive-data-types-from-c">Mapping primitive data types from C – tutorial</a> <a class="navigation-links__next" href="mapping-function-pointers-from-c">Mapping function pointers from C – tutorial</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/mapping-struct-union-types-from-c.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/mapping-struct-union-types-from-c.html</a>
  </p>
</div>
