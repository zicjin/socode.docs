<h1 data-toc="functions" id="functions.md">Functions</h1>
<p id="fab15400">Kotlin functions are declared using the <code class="code ">fun</code> keyword:</p>
<pre class="code" data-language="kotlin">fun double(x: Int): Int {
    return 2 * x
}
</pre>
<section class="chapter"><h2 id="function-usage" data-toc="functions#function-usage">Function usage</h2>
<p id="8a2c33d4">Functions are called using the standard approach:</p>
<pre class="code" data-language="kotlin">val result = double(2)
</pre>
<p id="827e68f7">Calling member functions uses dot notation:</p>
<pre class="code" data-language="kotlin">Stream().read() // create instance of class Stream and call read()
</pre>
<section class="chapter"><h3 id="parameters" data-toc="functions#parameters">Parameters</h3>
<p id="b86ec0e">Function parameters are defined using Pascal notation - <em id="361fb991" class="">name</em>: <em id="9ef35748" class="">type</em>. Parameters are separated using commas, and each parameter must be explicitly typed:</p>
<pre class="code" data-language="kotlin">fun powerOf(number: Int, exponent: Int): Int { /*...*/ }
</pre>
<p id="78b199f">You can use a <a href="coding-conventions#trailing-commas" id="587dcf5e">trailing comma</a> when you declare function parameters:</p>
<pre class="code" data-language="kotlin">fun powerOf(
    number: Int,
    exponent: Int, // trailing comma
) { /*...*/ }
</pre></section><section class="chapter"><h3 id="default-arguments" data-toc="functions#default-arguments">Default arguments</h3>
<p id="63c63fc9">Function parameters can have default values, which are used when you skip the corresponding argument. This reduces the number of overloads:</p>
<pre class="code" data-language="kotlin">fun read(
    b: ByteArray,
    off: Int = 0,
    len: Int = b.size,
) { /*...*/ }
</pre>
<p id="b203648a">A default value is defined using <code class="code ">=</code> after the type.</p>
<p id="2087e44d">Overriding methods always use the same default parameter values as the base method. When overriding a method that has default parameter values, the default parameter values must be omitted from the signature:</p>
<pre class="code" data-language="kotlin">open class A {
    open fun foo(i: Int = 10) { /*...*/ }
}

class B : A() {
    override fun foo(i: Int) { /*...*/ }  // No default value is allowed.
}
</pre>
<p id="86d7f265">If a default parameter precedes a parameter with no default value, the default value can only be used by calling the function with <a href="#named-arguments" id="7427125d">named arguments</a>:</p>
<pre class="code" data-language="kotlin">fun foo(
    bar: Int = 0,
    baz: Int,
) { /*...*/ }

foo(baz = 1) // The default value bar = 0 is used
</pre>
<p id="b662a9b2">If the last argument after default parameters is a <a href="lambdas#lambda-expression-syntax" id="aed1abf3">lambda</a>, you can pass it either as a named argument or <a href="lambdas#passing-trailing-lambdas" id="c1219c3a">outside the parentheses</a>:</p>
<pre class="code" data-language="kotlin">fun foo(
    bar: Int = 0,
    baz: Int = 1,
    qux: () -&gt; Unit,
) { /*...*/ }

foo(1) { println("hello") }     // Uses the default value baz = 1
foo(qux = { println("hello") }) // Uses both default values bar = 0 and baz = 1
foo { println("hello") }        // Uses both default values bar = 0 and baz = 1
</pre></section><section class="chapter"><h3 id="named-arguments" data-toc="functions#named-arguments">Named arguments</h3>
<p id="9c8de37">When calling a function, you can name one or more of its arguments. This can be helpful when a function has many arguments and it's difficult to associate a value with an argument, especially if it's a boolean or <code class="code ">null</code> value.</p>
<p id="f7fca2ad">When you use named arguments in a function call, you can freely change the order they are listed in, and if you want to use their default values, you can just leave these arguments out altogether.</p>
<p id="b4fbfca2">Consider the following function, <code class="code ">reformat()</code>, which has 4 arguments with default values.</p>
<pre class="code" data-language="kotlin">fun reformat(
    str: String,
    normalizeCase: Boolean = true,
    upperCaseFirstLetter: Boolean = true,
    divideByCamelHumps: Boolean = false,
    wordSeparator: Char = ' ',
) { /*...*/ }
</pre>
<p id="810b422f">When calling this function, you donâ€™t have to name all its arguments:</p>
<pre class="code" data-language="kotlin">reformat(
    "String!",
    false,
    upperCaseFirstLetter = false,
    divideByCamelHumps = true,
    '_'
)
</pre>
<p id="6cc19305">You can skip all the ones with default values:</p>
<pre class="code" data-language="kotlin">reformat("This is a long String!")
</pre>
<p id="3fbc9aeb">You are also able to skip specific arguments with default values, rather than omitting them all. However, after the first skipped argument, you must name all subsequent arguments:</p>
<pre class="code" data-language="kotlin">reformat("This is a short String!", upperCaseFirstLetter = false, wordSeparator = '_')
</pre>
<p id="ece0654c">You can pass a <a href="#variable-number-of-arguments-varargs" id="8ed85e19">variable number of arguments (<code class="code ">vararg</code>)</a> with names using the <code class="code ">spread</code> operator:</p>
<pre class="code" data-language="kotlin">fun foo(vararg strings: String) { /*...*/ }

foo(strings = *arrayOf("a", "b", "c"))
</pre>
<aside data-type="note" class="prompt" data-title="" id="9bde0fcb"><p id="b1a8fad7">On the JVM: You can't use the named argument syntax when calling Java functions because Java bytecode does not always preserve the names of function parameters.</p></aside></section><section class="chapter"><h3 id="unit-returning-functions" data-toc="functions#unit-returning-functions">Unit-returning functions</h3>
<p id="ee7ce53b">If a function does not return a useful value, its return type is <code class="code ">Unit</code>. <code class="code ">Unit</code> is a type with only one value - <code class="code ">Unit</code>. This value does not have to be returned explicitly:</p>
<pre class="code" data-language="kotlin">fun printHello(name: String?): Unit {
    if (name != null)
        println("Hello $name")
    else
        println("Hi there!")
    // `return Unit` or `return` is optional
}
</pre>
<p id="aaa99c0f">The <code class="code ">Unit</code> return type declaration is also optional. The above code is equivalent to:</p>
<pre class="code" data-language="kotlin">fun printHello(name: String?) { ... }
</pre></section><section class="chapter"><h3 id="single-expression-functions" data-toc="functions#single-expression-functions">Single-expression functions</h3>
<p id="1970e65">When a function returns a single expression, the curly braces can be omitted and the body is specified after a <code class="code ">=</code> symbol:</p>
<pre class="code" data-language="kotlin">fun double(x: Int): Int = x * 2
</pre>
<p id="e04876f9">Explicitly declaring the return type is <a href="#explicit-return-types" id="7cb8bf4f">optional</a> when this can be inferred by the compiler:</p>
<pre class="code" data-language="kotlin">fun double(x: Int) = x * 2
</pre></section><section class="chapter"><h3 id="explicit-return-types" data-toc="functions#explicit-return-types">Explicit return types</h3>
<p id="5361af30">Functions with block body must always specify return types explicitly, unless it's intended for them to return <code class="code ">Unit</code>, <a href="#unit-returning-functions" id="5b807780">in which case specifying the return type is optional</a>.</p>
<p id="ef2f91e5">Kotlin does not infer return types for functions with block bodies because such functions may have complex control flow in the body, and the return type will be non-obvious to the reader (and sometimes even for the compiler).</p></section><section class="chapter"><h3 id="variable-number-of-arguments-varargs" data-toc="functions#variable-number-of-arguments-varargs">Variable number of arguments (varargs)</h3>
<p id="8f7a2d85">You can mark a parameter of a function (usually the last one) with the <code class="code ">vararg</code> modifier:</p>
<pre class="code" data-language="kotlin">fun &lt;T&gt; asList(vararg ts: T): List&lt;T&gt; {
    val result = ArrayList&lt;T&gt;()
    for (t in ts) // ts is an Array
        result.add(t)
    return result
}
</pre>
<p id="9a04961b">In this case, you can pass a variable number of arguments to the function:</p>
<pre class="code" data-language="kotlin">val list = asList(1, 2, 3)
</pre>
<p id="7cd6a5b0">Inside a function, a <code class="code ">vararg</code>-parameter of type <code class="code ">T</code> is visible as an array of <code class="code ">T</code>, as in the example above, where the <code class="code ">ts</code> variable has type <code class="code ">Array&lt;out T&gt;</code>.</p>
<p id="2e240f8">Only one parameter can be marked as <code class="code ">vararg</code>. If a <code class="code ">vararg</code> parameter is not the last one in the list, values for the subsequent parameters can be passed using named argument syntax, or, if the parameter has a function type, by passing a lambda outside the parentheses.</p>
<p id="737d869e">When you call a <code class="code ">vararg</code>-function, you can pass arguments individually, for example <code class="code ">asList(1, 2, 3)</code>. If you already have an array and want to pass its contents to the function, use the <em id="c64514b7" class="">spread</em> operator (prefix the array with <code class="code ">*</code>):</p>
<pre class="code" data-language="kotlin">val a = arrayOf(1, 2, 3)
val list = asList(-1, 0, *a, 4)
</pre>
<p id="b25d4ed6">If you want to pass a <a href="basic-types#primitive-type-arrays" id="3bc7bb68">primitive type array</a> into <code class="code ">vararg</code>, you need to convert it to a regular (typed) array using the <code class="code ">toTypedArray()</code> function:</p>
<pre class="code" data-language="kotlin">val a = intArrayOf(1, 2, 3) // IntArray is a primitive type array
val list = asList(-1, 0, *a.toTypedArray(), 4)
</pre></section><section class="chapter"><h3 id="infix-notation" data-toc="functions#infix-notation">Infix notation</h3>
<p id="ffc55664">Functions marked with the <code class="code ">infix</code> keyword can also be called using the infix notation (omitting the dot and the parentheses for the call). Infix functions must meet the following requirements:</p>
<ul class="list _ul" id="7c4f233">
<li class="list__item" id="d895c711"><p>They must be member functions or <a href="extensions" id="8dc982d9">extension functions</a>.</p></li>
<li class="list__item" id="9aa0b01"><p>They must have a single parameter.</p></li>
<li class="list__item" id="226d2433"><p>The parameter must not <a href="#variable-number-of-arguments-varargs" id="ecc61a3f">accept variable number of arguments</a> and must have no <a href="#default-arguments" id="e3445f46">default value</a>.</p></li>
</ul>
<pre class="code" data-language="kotlin">infix fun Int.shl(x: Int): Int { ... }

// calling the function using the infix notation
1 shl 2

// is the same as
1.shl(2)
</pre>
<aside data-type="note" class="prompt" data-title="" id="22ab8458"><p id="5cd929fb">Infix function calls have lower precedence than arithmetic operators, type casts, and the <code class="code ">rangeTo</code> operator. The following expressions are equivalent:</p>
<ul class="list _ul" id="ae13322f">
<li class="list__item" id="4caf0ad2"><p><code class="code ">1 shl 2 + 3</code> is equivalent to <code class="code ">1 shl (2 + 3)</code></p></li>
<li class="list__item" id="e72316b2"><p><code class="code ">0 until n * 2</code> is equivalent to <code class="code ">0 until (n * 2)</code></p></li>
<li class="list__item" id="ecaaec09"><p><code class="code ">xs union ys as Set&lt;*&gt;</code> is equivalent to <code class="code ">xs union (ys as Set&lt;*&gt;)</code></p></li>
</ul>
<p id="f5d3505a">On the other hand, an infix function call's precedence is higher than that of the boolean operators <code class="code ">&amp;&amp;</code> and <code class="code ">||</code>, <code class="code ">is</code>- and <code class="code ">in</code>-checks, and some other operators. These expressions are equivalent as well:</p>
<ul class="list _ul" id="b561f528">
<li class="list__item" id="bb0527a5"><p><code class="code ">a &amp;&amp; b xor c</code> is equivalent to <code class="code ">a &amp;&amp; (b xor c)</code></p></li>
<li class="list__item" id="4a7f3300"><p><code class="code ">a xor b in c</code> is equivalent to <code class="code ">(a xor b) in c</code></p></li>
</ul></aside><p id="5a0d39f2">Note that infix functions always require both the receiver and the parameter to be specified. When you're calling a method on the current receiver using the infix notation, use <code class="code ">this</code> explicitly. This is required to ensure unambiguous parsing.</p>
<pre class="code" data-language="kotlin">class MyStringCollection {
    infix fun add(s: String) { /*...*/ }
    
    fun build() {
        this add "abc"   // Correct
        add("abc")       // Correct
        //add "abc"        // Incorrect: the receiver must be specified
    }
}
</pre></section></section><section class="chapter"><h2 id="function-scope" data-toc="functions#function-scope">Function scope</h2>
<p id="968a12cc">Kotlin functions can be declared at the top level in a file, meaning you do not need to create a class to hold a function, which you are required to do in languages such as Java, C#, and Scala. In addition to top level functions, Kotlin functions can also be declared locally as member functions and extension functions.</p>
<section class="chapter"><h3 id="local-functions" data-toc="functions#local-functions">Local functions</h3>
<p id="2d84089f">Kotlin supports local functions, which are functions inside other functions:</p>
<pre class="code" data-language="kotlin">fun dfs(graph: Graph) {
    fun dfs(current: Vertex, visited: MutableSet&lt;Vertex&gt;) {
        if (!visited.add(current)) return
        for (v in current.neighbors)
            dfs(v, visited)
    }

    dfs(graph.vertices[0], HashSet())
}
</pre>
<p id="5248757d">A local function can access local variables of outer functions (the closure). In the case above, <code class="code ">visited</code> can be a local variable:</p>
<pre class="code" data-language="kotlin">fun dfs(graph: Graph) {
    val visited = HashSet&lt;Vertex&gt;()
    fun dfs(current: Vertex) {
        if (!visited.add(current)) return
        for (v in current.neighbors)
            dfs(v)
    }

    dfs(graph.vertices[0])
}
</pre></section><section class="chapter"><h3 id="member-functions" data-toc="functions#member-functions">Member functions</h3>
<p id="983c113b">A member function is a function that is defined inside a class or object:</p>
<pre class="code" data-language="kotlin">class Sample {
    fun foo() { print("Foo") }
}
</pre>
<p id="479aff68">Member functions are called with dot notation:</p>
<pre class="code" data-language="kotlin">Sample().foo() // creates instance of class Sample and calls foo
</pre>
<p id="f67ac23a">For more information on classes and overriding members see <a href="classes" id="22d6b244">Classes</a> and <a href="classes#inheritance" id="12305a11">Inheritance</a>.</p></section></section><section class="chapter"><h2 id="generic-functions" data-toc="functions#generic-functions">Generic functions</h2>
<p id="6d1d33da">Functions can have generic parameters, which are specified using angle brackets before the function name:</p>
<pre class="code" data-language="kotlin">fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; { /*...*/ }
</pre>
<p id="70921367">For more information on generic functions, see <a href="generics" id="3a637835">Generics</a>.</p></section><section class="chapter"><h2 id="tail-recursive-functions" data-toc="functions#tail-recursive-functions">Tail recursive functions</h2>
<p id="20a44d48">Kotlin supports a style of functional programming known as <a href="https://en.wikipedia.org/wiki/Tail_call" id="eea1fb47" data-external="true" rel="noopener noreferrer">tail recursion</a>. For some algorithms that would normally use loops, you can use a recursive function instead without the risk of stack overflow. When a function is marked with the <code class="code ">tailrec</code> modifier and meets the required formal conditions, the compiler optimizes out the recursion, leaving behind a fast and efficient loop based version instead:</p>
<pre class="code" data-language="kotlin">val eps = 1E-10 // "good enough", could be 10^-15

tailrec fun findFixPoint(x: Double = 1.0): Double =
    if (Math.abs(x - Math.cos(x)) &lt; eps) x else findFixPoint(Math.cos(x))
</pre>
<p id="1717ec89">This code calculates the <code class="code ">fixpoint</code> of cosine, which is a mathematical constant. It simply calls <code class="code ">Math.cos</code> repeatedly starting at <code class="code ">1.0</code> until the result no longer changes, yielding a result of <code class="code ">0.7390851332151611</code> for the specified <code class="code ">eps</code> precision. The resulting code is equivalent to this more traditional style:</p>
<pre class="code" data-language="kotlin">val eps = 1E-10 // "good enough", could be 10^-15

private fun findFixPoint(): Double {
    var x = 1.0
    while (true) {
        val y = Math.cos(x)
        if (Math.abs(x - y) &lt; eps) return x
        x = Math.cos(x)
    }
}
</pre>
<p id="4e63bdcb">To be eligible for the <code class="code ">tailrec</code> modifier, a function must call itself as the last operation it performs. You cannot use tail recursion when there is more code after the recursive call, within <code class="code ">try</code>/<code class="code ">catch</code>/<code class="code ">finally</code> blocks, or on open functions. Currently, tail recursion is supported by Kotlin for the JVM and Kotlin/Native.</p>
<p id="3c6eeddc"><b id="2ce1e301" class="">See also</b>:</p>
<ul class="list _ul" id="c9e711a5">
<li class="list__item" id="27110d"><p><a href="inline-functions" id="d02be957">Inline functions</a></p></li>
<li class="list__item" id="4c1b4c93"><p><a href="extensions" id="ebfbd7a3">Extension functions</a></p></li>
<li class="list__item" id="358513fb"><p><a href="lambdas" id="267cd634">Higher-order functions and lambdas</a></p></li>
</ul></section><div class="last-modified"> Last modified: 08 August 2022</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="type-aliases">Type aliases</a> <a class="navigation-links__next" href="lambdas">High-order functions and lambdas</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/functions.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/functions.html</a>
  </p>
</div>
