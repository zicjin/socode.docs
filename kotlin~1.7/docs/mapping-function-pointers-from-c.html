<h1 data-toc="mapping-function-pointers-from-c" id="mapping-function-pointers-from-c.md">Mapping function pointers from C – tutorial</h1>
<p id="cfc584cf">This is the third post in the series. The very first tutorial is <a href="mapping-primitive-data-types-from-c" id="8659a6ab">Mapping primitive data types from C</a>. There are also <a href="mapping-struct-union-types-from-c" id="689e80fe">Mapping struct and union types from C</a> and <a href="mapping-strings-from-c" id="d6d159a4">Mapping strings from C</a> tutorials.</p>
<p id="f4a1e1c9">In this tutorial We will learn how to:</p>
<ul class="list _ul" id="6e43f287">
<li class="list__item" id="4b5b6f71"><p><a href="#pass-kotlin-function-as-c-function-pointer" id="5fd15bf1">Pass Kotlin function as C function pointer</a></p></li>
<li class="list__item" id="199a83f"><p><a href="#use-the-c-function-pointer-from-kotlin" id="baf39379">Use C function pointer from Kotlin</a></p></li>
</ul>
<section class="chapter"><h2 id="mapping-function-pointer-types-from-c" data-toc="mapping-function-pointers-from-c#mapping-function-pointer-types-from-c">Mapping function pointer types from C</h2>
<p id="13f28581">The best way to understand the mapping between Kotlin and C is to try a tiny example. Declare a function that accepts a function pointer as a parameter and another function that returns a function pointer.</p>
<p id="63342c9f">Kotlin/Native comes with the <code class="code ">cinterop</code> tool; the tool generates bindings between the C language and Kotlin. It uses a <code class="code ">.def</code> file to specify a C library to import. More details on this are in <a href="native-c-interop" id="bbeacaac">Interop with C Libraries</a>.</p>
<p id="d4de4b13">The quickest way to try out C API mapping is to have all C declarations in the <code class="code ">interop.def</code> file, without creating any <code class="code ">.h</code> of <code class="code ">.c</code> files at all. Then place the C declarations in a <code class="code ">.def</code> file after the special <code class="code ">---</code> separator line:</p>
<pre class="code" data-language="c">
---

int myFun(int i) {
  return i+1;
}

typedef int  (*MyFun)(int);

void accept_fun(MyFun f) {
  f(42);
}

MyFun supply_fun() {
  return myFun;
}

</pre>
<p id="d7cf84d6">The <code class="code ">interop.def</code> file is enough to compile and run the application or open it in an IDE. Now it is time to create project files, open the project in <a href="https://jetbrains.com/idea" id="96dcb759" data-external="true" rel="noopener noreferrer">IntelliJ IDEA</a> and run it.</p></section><section class="chapter"><h2 id="inspect-generated-kotlin-apis-for-a-c-library" data-toc="mapping-function-pointers-from-c#inspect-generated-kotlin-apis-for-a-c-library">Inspect generated Kotlin APIs for a C library</h2>
<p id="116eda4d">While it is possible to use the command line, either directly or by combining it with a script file (such as <code class="code ">.sh</code> or <code class="code ">.bat</code> file), this approach doesn't scale well for big projects that have hundreds of files and libraries. It is then better to use the Kotlin/Native compiler with a build system, as it helps to download and cache the Kotlin/Native compiler binaries and libraries with transitive dependencies and run the compiler and tests. Kotlin/Native can use the <a href="https://gradle.org" id="9cb0151a" data-external="true" rel="noopener noreferrer">Gradle</a> build system through the <a href="multiplatform-discover-project#multiplatform-plugin" id="25b529a1">kotlin-multiplatform</a> plugin.</p>
<p id="ba77d792">We covered the basics of setting up an IDE compatible project with Gradle in the <a href="native-gradle" id="7f532a27">A Basic Kotlin/Native Application</a> tutorial. Please check it out if you are looking for detailed first steps and instructions on how to start a new Kotlin/Native project and open it in IntelliJ IDEA. In this tutorial, we'll look at the advanced C interop related usages of Kotlin/Native and <a href="multiplatform-discover-project#multiplatform-plugin" id="dc9449f3">multiplatform</a> builds with Gradle.</p>
<p id="11b6dc2">First, create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes the missing directories will have to be created before any new files can be added.</p>
<p id="42696340">Use the following <code class="code ">build.gradle(.kts)</code> Gradle build file:</p>
<div class="tabs" id="b5c447a7" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="509168b6" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code" data-language="kotlin">plugins {
    kotlin("multiplatform") version "1.7.10"
}

repositories {
    mavenCentral()
}

kotlin {
  linuxX64("native") { // on Linux
  // macosX64("native") { // on x86_64 macOS
  // macosArm64("native") { // on Apple Silicon macOS
  // mingwX64("native") { // on Windows
    val main by compilations.getting
    val interop by main.cinterops.creating
    
    binaries {
      executable()
    }
  }
}

tasks.wrapper {
  gradleVersion = "6.7.1"
  distributionType = Wrapper.DistributionType.BIN
}
</pre></div>
<div class="tabs__content" data-gtm="tab" id="ffc5001" data-sync-tabs="groovy" data-title="Groovy"><pre class="code" data-language="groovy">plugins {
    id 'org.jetbrains.kotlin.multiplatform' version '1.7.10'
}

repositories {
    mavenCentral()
}

kotlin {
  linuxX64('native') { // on Linux
  // macosX64("native") { // on x86_64 macOS
  // macosArm64("native") { // on Apple Silicon macOS  
  // mingwX64('native') { // on Windows
    compilations.main.cinterops {
      interop 
    }
    
    binaries {
      executable()
    }
  }
}

wrapper {
  gradleVersion = '6.7.1'
  distributionType = 'BIN'
}
</pre></div>
</div>
<p id="24831f5">The project file configures the C interop as an additional step of the build. Let's move the <code class="code ">interop.def</code> file to the <code class="code ">src/nativeInterop/cinterop</code> directory. Gradle recommends using conventions instead of configurations, for example, the source files are expected to be in the <code class="code ">src/nativeMain/kotlin</code> folder. By default, all the symbols from C are imported to the <code class="code ">interop</code> package, you may want to import the whole package in our <code class="code ">.kt</code> files. Check out the <a href="multiplatform-discover-project#multiplatform-plugin" id="f7f874eb">kotlin-multiplatform</a> plugin documentation to learn about all the different ways you could configure it.</p>
<p id="167833be">Let's create a <code class="code ">src/nativeMain/kotlin/hello.kt</code> stub file with the following content to see how C function pointer declarations are visible from Kotlin:</p>
<pre class="code" data-language="kotlin">import interop.*

fun main() {
  println("Hello Kotlin/Native!")
  
  accept_fun(https://kotlinlang.org/*fix me */)
  val useMe = supply_fun()
}
</pre>
<p id="4bd94b4c">Now you are ready to <a href="native-get-started" id="ccc56210">open the project in IntelliJ IDEA</a> and to see how to fix the example project. While doing that, see how C functions are mapped into Kotlin/Native declarations.</p></section><section class="chapter"><h2 id="c-function-pointers-in-kotlin" data-toc="mapping-function-pointers-from-c#c-function-pointers-in-kotlin">C function pointers in Kotlin</h2>
<p id="88cc4314">With the help of IntelliJ IDEA's <b id="36d31cf" class="">Go To</b> | <b id="5821f890" class="">Declaration or Usages</b> or compiler errors, see the following declarations for the C functions:</p>
<pre class="code" data-language="kotlin">fun accept_fun(f: MyFun? /* = CPointer&lt;CFunction&lt;(Int) -&gt; Int&gt;&gt;? */)
fun supply_fun(): MyFun? /* = CPointer&lt;CFunction&lt;(Int) -&gt; Int&gt;&gt;? */

fun myFun(i: kotlin.Int): kotlin.Int

typealias MyFun = kotlinx.cinterop.CPointer&lt;kotlinx.cinterop.CFunction&lt;(kotlin.Int) -&gt; kotlin.Int&gt;&gt;

typealias MyFunVar = kotlinx.cinterop.CPointerVarOf&lt;lib.MyFun&gt;
</pre>
<p id="6e58576c">You see that the function's <code class="code ">typedef</code> from C has been turned into Kotlin <code class="code ">typealias</code>. It uses <code class="code ">CPointer&lt;..&gt;</code> type to represent the pointer parameters, and <code class="code ">CFunction&lt;(Int)-&gt;Int&gt;</code> to represent the function signature. There is an <code class="code ">invoke</code> operator extension function available for all <code class="code ">CPointer&lt;CFunction&lt;..&gt;</code> types, so that it is possible to call it as you would call any other function in Kotlin.</p></section><section class="chapter"><h2 id="pass-kotlin-function-as-c-function-pointer" data-toc="mapping-function-pointers-from-c#pass-kotlin-function-as-c-function-pointer">Pass Kotlin function as C function pointer</h2>
<p id="63520260">It is the time to try using C functions from the Kotlin program. Call the <code class="code ">accept_fun</code> function and pass the C function pointer to a Kotlin lambda:</p>
<pre class="code" data-language="kotlin">fun myFun() {
  accept_fun(staticCFunction&lt;Int, Int&gt; { it + 1 })
}

</pre>
<p id="21bf0992">This call uses the <code class="code ">staticCFunction{..}</code> helper function from Kotlin/Native to wrap a Kotlin lambda function into a C function pointer. It only allows having unbound and non-capturing lambda functions. For example, it is not able to use a local variable from the function. You may only use globally visible declarations. Throwing exceptions from a <code class="code ">staticCFunction{..}</code> will end up in non-deterministic side-effects. It is vital to make sure that you code is not throwing any sudden exceptions from it.</p></section><section class="chapter"><h2 id="use-the-c-function-pointer-from-kotlin" data-toc="mapping-function-pointers-from-c#use-the-c-function-pointer-from-kotlin">Use the C function pointer from Kotlin</h2>
<p id="db1bf250">The next step is to call a C function pointer from a C pointer that you have from the <code class="code ">supply_fun()</code> call:</p>
<pre class="code" data-language="kotlin">fun myFun2() {
  val functionFromC = supply_fun() ?: error("No function is returned")
  
  functionFromC(42)
}

</pre>
<p id="5ecd316a">Kotlin turns the function pointer return type into a nullable <code class="code ">CPointer&lt;CFunction&lt;..&gt;</code> object. There is the need to explicitly check for <code class="code ">null</code> first. The <a href="null-safety" id="a1b6e9de">elvis operator</a> for that in the code above. The <code class="code ">cinterop</code> tool helps us to turn a C function pointer into an easy to call object in Kotlin. This is what we did on the last line.</p></section><section class="chapter"><h2 id="fix-the-code" data-toc="mapping-function-pointers-from-c#fix-the-code">Fix the code</h2>
<p id="44dba25e">You've seen all definitions and it is time to fix and run the code. Run the <code class="code ">runDebugExecutableNative</code> Gradle task <a href="native-get-started" id="75cc4868">in the IDE</a> or use the following command to run the code:</p>
<pre class="code" data-language="bash">./gradlew runDebugExecutableNative
</pre>
<p id="d853f1ea">The code in the <code class="code ">hello.kt</code> file may look like this:</p>
<pre class="code" data-language="kotlin">import interop.*
import kotlinx.cinterop.*

fun main() {
  println("Hello Kotlin/Native!")
 
  val cFunctionPointer = staticCFunction&lt;Int, Int&gt; { it + 1 }
  accept_fun(cFunctionPointer)

  val funFromC = supply_fun() ?: error("No function is returned")
  funFromC(42)
}
</pre></section><section class="chapter"><h2 id="next-steps" data-toc="mapping-function-pointers-from-c#next-steps">Next Steps</h2>
<p id="e4d61a51">Continue exploring more C language types and their representation in Kotlin/Native in next tutorials:</p>
<ul class="list _ul" id="6bfdd740">
<li class="list__item" id="473f3894"><p><a href="mapping-primitive-data-types-from-c" id="7cf4073a">Mapping primitive data types from C</a></p></li>
<li class="list__item" id="358612e1"><p><a href="mapping-struct-union-types-from-c" id="2e414330">Mapping struct and union types from C</a></p></li>
<li class="list__item" id="9a12c2aa"><p><a href="mapping-strings-from-c" id="c7e576ab">Mapping strings from C</a></p></li>
</ul>
<p id="bb0504f8">The <a href="native-c-interop" id="651e1598">C Interop documentation</a> covers more advanced scenarios of the interop.</p></section><div class="last-modified"> Last modified: 08 August 2022</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="mapping-struct-union-types-from-c">Mapping struct and union types from C – tutorial</a> <a class="navigation-links__next" href="mapping-strings-from-c">Mapping Strings from C – tutorial</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/mapping-function-pointers-from-c.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/mapping-function-pointers-from-c.html</a>
  </p>
</div>
