<h1 data-toc="control-flow" id="control-flow.md">Conditions and loops</h1>
<section class="chapter"><h2 id="if-expression" data-toc="control-flow#if-expression">If expression</h2>
<p id="a54ff834">In Kotlin, <code class="code ">if</code> is an expression: it returns a value. Therefore, there is no ternary operator (<code class="code ">condition ? then : else</code>) because ordinary <code class="code ">if</code> works fine in this role.</p>
<pre class="code" data-language="kotlin">var max = a 
if (a &lt; b) max = b

// With else 
var max: Int
if (a &gt; b) {
    max = a
} else {
    max = b
}
 
// As expression 
val max = if (a &gt; b) a else b
</pre>
<p id="17223306">Branches of an <code class="code ">if</code> expression can be blocks. In this case, the last expression is the value of a block:</p>
<pre class="code" data-language="kotlin">val max = if (a &gt; b) {
    print("Choose a")
    a
} else {
    print("Choose b")
    b
}
</pre>
<p id="b92fc157">If you're using <code class="code ">if</code> as an expression, for example, for returning its value or assigning it to a variable, the <code class="code ">else</code> branch is mandatory.</p></section><section class="chapter"><h2 id="when-expression" data-toc="control-flow#when-expression">When expression</h2>
<p id="f8c4af9c"><code class="code ">when</code> defines a conditional expression with multiple branches. It is similar to the <code class="code ">switch</code> statement in C-like languages. Its simple form looks like this.</p>
<pre class="code" data-language="kotlin">when (x) {
    1 -&gt; print("x == 1")
    2 -&gt; print("x == 2")
    else -&gt; {
        print("x is neither 1 nor 2")
    }
}
</pre>
<p id="8fdd1813"><code class="code ">when</code> matches its argument against all branches sequentially until some branch condition is satisfied.</p>
<p id="b40e4dfa"><code class="code ">when</code> can be used either as an expression or as a statement. If it is used as an expression, the value of the first matching branch becomes the value of the overall expression. If it is used as a statement, the values of individual branches are ignored. Just like with <code class="code ">if</code>, each branch can be a block, and its value is the value of the last expression in the block.</p>
<p id="ed7e0b04">The <code class="code ">else</code> branch is evaluated if none of the other branch conditions are satisfied.</p>
<p id="435d687b">If <code class="code ">when</code> is used as an <em id="d7c38674" class="">expression</em>, the <code class="code ">else</code> branch is mandatory, unless the compiler can prove that all possible cases are covered with branch conditions, for example, with <a href="enum-classes" id="35b2e6ab"><code class="code ">enum</code> class</a> entries and <a href="sealed-classes" id="934ab31f"><code class="code ">sealed</code> class</a> subtypes).</p>
<pre class="code" data-language="kotlin">enum class Bit {
  ZERO, ONE
}

val numericValue = when (getRandomBit()) {
    Bit.ZERO -&gt; 0
    Bit.ONE -&gt; 1
    // 'else' is not required because all cases are covered
}
</pre>
<p id="75c25e22">In <code class="code ">when</code> <em id="9766532" class="">statements</em>, the <code class="code ">else</code> branch is mandatory in the following conditions:</p>
<ul class="list _ul" id="a935db59">
<li class="list__item" id="928ddc82"><p><code class="code ">when</code> has a subject of an <code class="code ">Boolean</code>, <a href="enum-classes" id="2aa2cae4"><code class="code ">enum</code></a>, or <a href="sealed-classes" id="9acb102f"><code class="code ">sealed</code></a> type, or their nullable counterparts.</p></li>
<li class="list__item" id="1a005cac"><p>branches of <code class="code ">when</code> don't cover all possible cases for this subject.</p></li>
</ul>
<pre class="code" data-language="kotlin">enum class Color {
  RED, GREEN, BLUE
}

when (getColor()) {  
    Color.RED -&gt; println("red")
    Color.GREEN -&gt; println("green")   
    Color.BLUE -&gt; println("blue")
    // 'else' is not required because all cases are covered
}

when (getColor()) {
  Color.RED -&gt; println("red") // no branches for GREEN and BLUE
  else -&gt; println("not red") // 'else' is required
}
</pre>
<p id="bfde5453">To define a common behavior for multiple cases, combine their conditions in a single line with a comma:</p>
<pre class="code" data-language="kotlin">when (x) {
    0, 1 -&gt; print("x == 0 or x == 1")
    else -&gt; print("otherwise")
}
</pre>
<p id="5cc8a459">You can use arbitrary expressions (not only constants) as branch conditions</p>
<pre class="code" data-language="kotlin">when (x) {
    s.toInt() -&gt; print("s encodes x")
    else -&gt; print("s does not encode x")
}
</pre>
<p id="fbde5a77">You can also check a value for being <code class="code ">in</code> or <code class="code ">!in</code> a <a href="ranges" id="840d5922">range</a> or a collection:</p>
<pre class="code" data-language="kotlin">when (x) {
    in 1..10 -&gt; print("x is in the range")
    in validNumbers -&gt; print("x is valid")
    !in 10..20 -&gt; print("x is outside the range")
    else -&gt; print("none of the above")
}
</pre>
<p id="f41f8336">Another option is checking that a value <code class="code ">is</code> or <code class="code ">!is</code> of a particular type. Note that, due to <a href="typecasts#smart-casts" id="36ecc88">smart casts</a>, you can access the methods and properties of the type without any extra checks.</p>
<pre class="code" data-language="kotlin">fun hasPrefix(x: Any) = when(x) {
    is String -&gt; x.startsWith("prefix")
    else -&gt; false
}
</pre>
<p id="65361cfe"><code class="code ">when</code> can also be used as a replacement for an <code class="code ">if</code>-<code class="code ">else</code> <code class="code ">if</code> chain. If no argument is supplied, the branch conditions are simply boolean expressions, and a branch is executed when its condition is true:</p>
<pre class="code" data-language="kotlin">when {
    x.isOdd() -&gt; print("x is odd")
    y.isEven() -&gt; print("y is even")
    else -&gt; print("x+y is odd")
}
</pre>
<p id="7a5865e2">You can capture <em id="3c1b892a" class="">when</em> subject in a variable using following syntax:</p>
<pre class="code" data-language="kotlin">fun Request.getBody() =
    when (val response = executeRequest()) {
        is Success -&gt; response.body
        is HttpError -&gt; throw HttpException(response.status)
    }
</pre>
<p id="6061161d">The scope of variable introduced in <em id="55f50ce6" class="">when</em> subject is restricted to the body of this <em id="ab0a36dc" class="">when</em>.</p></section><section class="chapter"><h2 id="for-loops" data-toc="control-flow#for-loops">For loops</h2>
<p id="48931c8c">The <code class="code ">for</code> loop iterates through anything that provides an iterator. This is equivalent to the <code class="code ">foreach</code> loop in languages like C#. The syntax of <code class="code ">for</code> is the following:</p>
<pre class="code" data-language="kotlin">for (item in collection) print(item)
</pre>
<p id="323af53b">The body of <code class="code ">for</code> can be a block.</p>
<pre class="code" data-language="kotlin">for (item: Int in ints) {
    // ...
}
</pre>
<p id="7bb1fa72">As mentioned before, <code class="code ">for</code> iterates through anything that provides an iterator. This means that it:</p>
<ul class="list _ul" id="a29be36b"><li class="list__item" id="17223c0">
<p>has a member or an extension function <code class="code ">iterator()</code> that returns <code class="code ">Iterator&lt;&gt;</code>: </p>
<ul class="list _ul" id="b67b2cb3">
<li class="list__item" id="7221942d"><p>has a member or an extension function <code class="code ">next()</code></p></li>
<li class="list__item" id="15482c18"><p>has a member or an extension function <code class="code ">hasNext()</code> that returns <code class="code ">Boolean</code>.</p></li>
</ul>
</li></ul>
<p id="1c67e670">All of these three functions need to be marked as <code class="code ">operator</code>.</p>
<p id="7478489a">To iterate over a range of numbers, use a <a href="ranges" id="b7ab80e7">range expression</a>:</p>
<pre class="code" data-language="kotlin">fun main() {
//sampleStart
    for (i in 1..3) {
        println(i)
    }
    for (i in 6 downTo 0 step 2) {
        println(i)
    }
//sampleEnd
}
</pre>
<p id="85bcdaba">A <code class="code ">for</code> loop over a range or an array is compiled to an index-based loop that does not create an iterator object.</p>
<p id="55e9995f">If you want to iterate through an array or a list with an index, you can do it this way:</p>
<pre class="code" data-language="kotlin">fun main() {
val array = arrayOf("a", "b", "c")
//sampleStart
    for (i in array.indices) {
        println(array[i])
    }
//sampleEnd
}
</pre>
<p id="fcf6bdd">Alternatively, you can use the <code class="code ">withIndex</code> library function:</p>
<pre class="code" data-language="kotlin">fun main() {
    val array = arrayOf("a", "b", "c")
//sampleStart
    for ((index, value) in array.withIndex()) {
        println("the element at $index is $value")
    }
//sampleEnd
}
</pre></section><section class="chapter"><h2 id="while-loops" data-toc="control-flow#while-loops">While loops</h2>
<p id="1c695d93"><code class="code ">while</code> and <code class="code ">do-while</code> loops execute their body continuously while their condition is satisfied. The difference between them is the condition checking time:</p>
<ul class="list _ul" id="f1235561">
<li class="list__item" id="e4e91666"><p><code class="code ">while</code> checks the condition and, if it's satisfied, executes the body and then returns to the condition check.</p></li>
<li class="list__item" id="b318dc54"><p><code class="code ">do-while</code> executes the body and then checks the condition. If it's satisfied, the loop repeats. So, the body of <code class="code ">do-while</code> executes at least once regardless of the condition.</p></li>
</ul>
<pre class="code" data-language="kotlin">while (x &gt; 0) {
    x--
}

do {
    val y = retrieveData()
} while (y != null) // y is visible here!
</pre></section><section class="chapter"><h2 id="break-and-continue-in-loops" data-toc="control-flow#break-and-continue-in-loops">Break and continue in loops</h2>
<p id="f8188f9f">Kotlin supports traditional <code class="code ">break</code> and <code class="code ">continue</code> operators in loops. See <a href="returns" id="5878a590">Returns and jumps</a>.</p></section><div class="last-modified"> Last modified: 08 August 2022</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="typecasts">Type checks and casts</a> <a class="navigation-links__next" href="returns">Returns and jumps</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/control-flow.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/control-flow.html</a>
  </p>
</div>
