<h1 data-toc="collection-filtering" id="collection-filtering.md">Filtering collections</h1>
<p id="4a4f2fe4">Filtering is one of the most popular tasks in collection processing. In Kotlin, filtering conditions are defined by <em id="fe8e1a46" class="">predicates</em> – lambda functions that take a collection element and return a boolean value: <code class="code ">true</code> means that the given element matches the predicate, <code class="code ">false</code> means the opposite.</p>
<p id="7e1d36da">The standard library contains a group of extension functions that let you filter collections in a single call. These functions leave the original collection unchanged, so they are available for both <a href="collections-overview#collection-types" id="e9d214be">mutable and read-only</a> collections. To operate the filtering result, you should assign it to a variable or chain the functions after filtering.</p>
<section class="chapter"><h2 id="filter-by-predicate" data-toc="collection-filtering#filter-by-predicate">Filter by predicate</h2>
<p id="f71caa2b">The basic filtering function is <a href="../api/latest/jvm/stdlib/kotlin.collections/filter" id="ad3656d3" data-external="true" rel="noopener noreferrer"><code class="code ">filter()</code></a>. When called with a predicate, <code class="code ">filter()</code> returns the collection elements that match it. For both <code class="code ">List</code> and <code class="code ">Set</code>, the resulting collection is a <code class="code ">List</code>, for <code class="code ">Map</code> it's a <code class="code ">Map</code> as well.</p>
<pre class="code" data-language="kotlin">fun main() {
//sampleStart
    val numbers = listOf("one", "two", "three", "four")  
    val longerThan3 = numbers.filter { it.length &gt; 3 }
    println(longerThan3)

    val numbersMap = mapOf("key1" to 1, "key2" to 2, "key3" to 3, "key11" to 11)
    val filteredMap = numbersMap.filter { (key, value) -&gt; key.endsWith("1") &amp;&amp; value &gt; 10}
    println(filteredMap)
//sampleEnd
}
</pre>
<p id="bff8cc8a">The predicates in <code class="code ">filter()</code> can only check the values of the elements. If you want to use element positions in the filter, use <a href="../api/latest/jvm/stdlib/kotlin.collections/filter-indexed" id="d500ee96" data-external="true" rel="noopener noreferrer"><code class="code ">filterIndexed()</code></a>. It takes a predicate with two arguments: the index and the value of an element.</p>
<p id="38168d22">To filter collections by negative conditions, use <a href="../api/latest/jvm/stdlib/kotlin.collections/filter-not" id="fe19a5b0" data-external="true" rel="noopener noreferrer"><code class="code ">filterNot()</code></a>. It returns a list of elements for which the predicate yields <code class="code ">false</code>.</p>
<pre class="code" data-language="kotlin">fun main() {
//sampleStart
    val numbers = listOf("one", "two", "three", "four")
    
    val filteredIdx = numbers.filterIndexed { index, s -&gt; (index != 0) &amp;&amp; (s.length &lt; 5)  }
    val filteredNot = numbers.filterNot { it.length &lt;= 3 }

    println(filteredIdx)
    println(filteredNot)
//sampleEnd
}
</pre>
<p id="60e20ef">There are also functions that narrow the element type by filtering elements of a given type:</p>
<ul class="list _ul" id="7d83473e">
<li class="list__item" id="eab5f1d4">
<p id="7f66d100"><a href="../api/latest/jvm/stdlib/kotlin.collections/filter-is-instance" id="3652b4f1" data-external="true" rel="noopener noreferrer"><code class="code ">filterIsInstance()</code></a> returns collection elements of a given type. Being called on a <code class="code ">List&lt;Any&gt;</code>, <code class="code ">filterIsInstance&lt;T&gt;()</code> returns a <code class="code ">List&lt;T&gt;</code>, thus allowing you to call functions of the <code class="code ">T</code> type on its items.</p>
<pre class="code" data-language="kotlin">fun main() {
//sampleStart
    val numbers = listOf(null, 1, "two", 3.0, "four")
    println("All String elements in upper case:")
    numbers.filterIsInstance&lt;String&gt;().forEach {
        println(it.uppercase())
    }
//sampleEnd
}
</pre>
</li>
<li class="list__item" id="1b49937e">
<p id="227df90b"><a href="../api/latest/jvm/stdlib/kotlin.collections/filter-not-null" id="9732eede" data-external="true" rel="noopener noreferrer"><code class="code ">filterNotNull()</code></a> returns all non-null elements. Being called on a <code class="code ">List&lt;T?&gt;</code>, <code class="code ">filterNotNull()</code> returns a <code class="code ">List&lt;T: Any&gt;</code>, thus allowing you to treat the elements as non-null objects.</p>
<pre class="code" data-language="kotlin">fun main() {
//sampleStart
    val numbers = listOf(null, "one", "two", null)
    numbers.filterNotNull().forEach {
        println(it.length)   // length is unavailable for nullable Strings
    }
//sampleEnd
}
</pre>
</li>
</ul></section><section class="chapter"><h2 id="partition" data-toc="collection-filtering#partition">Partition</h2>
<p id="849d688b">Another filtering function – <a href="../api/latest/jvm/stdlib/kotlin.collections/partition" id="daf3f5ef" data-external="true" rel="noopener noreferrer"><code class="code ">partition()</code></a> – filters a collection by a predicate and keeps the elements that don't match it in a separate list. So, you have a <code class="code ">Pair</code> of <code class="code ">List</code>s as a return value: the first list containing elements that match the predicate and the second one containing everything else from the original collection.</p>
<pre class="code" data-language="kotlin">fun main() {
//sampleStart
    val numbers = listOf("one", "two", "three", "four")
    val (match, rest) = numbers.partition { it.length &gt; 3 }

    println(match)
    println(rest)
//sampleEnd
}
</pre></section><section class="chapter"><h2 id="test-predicates" data-toc="collection-filtering#test-predicates">Test predicates</h2>
<p id="7db883c">Finally, there are functions that simply test a predicate against collection elements:</p>
<ul class="list _ul" id="30cfaba7">
<li class="list__item" id="61159d69"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/any" id="c8e0617d" data-external="true" rel="noopener noreferrer"><code class="code ">any()</code></a> returns <code class="code ">true</code> if at least one element matches the given predicate.</p></li>
<li class="list__item" id="9607ebeb"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/none" id="e7c84309" data-external="true" rel="noopener noreferrer"><code class="code ">none()</code></a> returns <code class="code ">true</code> if none of the elements match the given predicate.</p></li>
<li class="list__item" id="7c74dddc"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/all" id="243f08f3" data-external="true" rel="noopener noreferrer"><code class="code ">all()</code></a> returns <code class="code ">true</code> if all elements match the given predicate. Note that <code class="code ">all()</code> returns <code class="code ">true</code> when called with any valid predicate on an empty collection. Such behavior is known in logic as <em id="1627098b" class=""><a href="https://en.wikipedia.org/wiki/Vacuous_truth" id="1c4a8364" data-external="true" rel="noopener noreferrer">vacuous truth</a></em>.</p></li>
</ul>
<pre class="code" data-language="kotlin">fun main() {
//sampleStart
    val numbers = listOf("one", "two", "three", "four")

    println(numbers.any { it.endsWith("e") })
    println(numbers.none { it.endsWith("a") })
    println(numbers.all { it.endsWith("e") })

    println(emptyList&lt;Int&gt;().all { it &gt; 5 })   // vacuous truth
//sampleEnd
}
</pre>
<p id="980c4e1a"><code class="code ">any()</code> and <code class="code ">none()</code> can also be used without a predicate: in this case they just check the collection emptiness. <code class="code ">any()</code> returns <code class="code ">true</code> if there are elements and <code class="code ">false</code> if there aren't; <code class="code ">none()</code> does the opposite.</p>
<pre class="code" data-language="kotlin">fun main() {
//sampleStart
    val numbers = listOf("one", "two", "three", "four")
    val empty = emptyList&lt;String&gt;()

    println(numbers.any())
    println(empty.any())
    
    println(numbers.none())
    println(empty.none())
//sampleEnd
}
</pre></section><div class="last-modified"> Last modified: 08 August 2022</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="collection-transformations">Collection transformation operations</a> <a class="navigation-links__next" href="collection-plus-minus">Plus and minus operators</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/collection-filtering.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/collection-filtering.html</a>
  </p>
</div>
