<h1 data-toc="whatsnew17" id="whatsnew17.md">What's new in Kotlin 1.7.0</h1>
<p id="c6ecd29a"><em id="7f24729f" class=""><a href="releases#release-details" id="6f68acb7">Release date: 9 June 2022</a></em></p>
<p id="739469ee">Kotlin 1.7.0 has been released. It unveils the Alpha version of the new Kotlin/JVM K2 compiler, stabilizes language features, and brings performance improvements for the JVM, JS, and Native platforms.</p>
<p id="94103f54">Here is a list of the major updates in this version:</p>
<ul class="list _ul" id="63d19961">
<li class="list__item" id="dfd666c2"><p><a href="#new-kotlin-k2-compiler-for-the-jvm-in-alpha" id="ff407d13">The new Kotlin K2 compiler is in Alpha now</a>, and it offers serious performance improvements. It is available only for the JVM, and none of the compiler plugins, including kapt, work with it.</p></li>
<li class="list__item" id="e5a86b35"><p><a href="#a-new-approach-to-incremental-compilation" id="ffc9a105">A new approach to the incremental compilation in Gradle</a>. Incremental compilation is now also supported for changes made inside dependent non-Kotlin modules and is compatible with Gradle.</p></li>
<li class="list__item" id="4a4d54ec"><p>We've stabilized <a href="#stable-opt-in-requirements" id="2c9a610e">opt-in requirement annotations</a>, <a href="#stable-definitely-non-nullable-types" id="c11183c0">definitely non-nullable types</a>, and <a href="#stable-builder-inference" id="a5103795">builder inference</a>.</p></li>
<li class="list__item" id="eb54b1f8"><p><a href="#underscore-operator-for-type-arguments" id="d1e8b261">There's now an underscore operator for type args</a>. You can use it to automatically infer a type of argument when other types are specified.</p></li>
<li class="list__item" id="ff61ace0"><p><a href="#allow-implementation-by-delegation-to-an-inlined-value-of-an-inline-class" id="5bf60d3">This release allows implementation by delegation to an inlined value of an inline class</a>. You can now create lightweight wrappers that do not allocate memory in most cases.</p></li>
</ul>
<p id="d367b0b1">You can also find a short overview of the changes in this video:</p>


<section class="chapter"><h2 id="new-kotlin-k2-compiler-for-the-jvm-in-alpha" data-toc="whatsnew17#new-kotlin-k2-compiler-for-the-jvm-in-alpha">New Kotlin K2 compiler for the JVM in Alpha</h2>
<p id="642ef4f3">This Kotlin release introduces the <b id="10616de1" class="">Alpha</b> version of the new Kotlin K2 compiler. The new compiler aims to speed up the development of new language features, unify all of the platforms Kotlin supports, bring performance improvements, and provide an API for compiler extensions.</p>
<p id="ff6615c9">We've already published some detailed explanations of our new compiler and its benefits:</p>
<ul class="list _ul" id="dfaf5f55">
<li class="list__item" id="f14372dd"><p><a href="https://www.youtube.com/watch?v=iTdJJq_LyoY" id="219acb72" data-external="true" rel="noopener noreferrer">The Road to the New Kotlin Compiler</a></p></li>
<li class="list__item" id="aecbe6a"><p><a href="https://www.youtube.com/watch?v=db19VFLZqJM" id="f82896d9" data-external="true" rel="noopener noreferrer">K2 Compiler: a Top-Down View</a></p></li>
</ul>
<p id="1908913b">It's important to point out that with the Alpha version of the new K2 compiler we were primarily focused on performance improvements, and it only works with JVM projects. It doesn't support Kotlin/JS, Kotlin/Native, or other multi-platform projects, and none of compiler plugins, including <a href="kapt" id="b707f4cd">kapt</a>, work with it.</p>
<p id="2f53f9c0">Our benchmarks show some outstanding results on our internal projects:</p>
<div class="table-wrapper"><table class=" wide" id="702a43a0">
<thead><tr class="ijRowHead" id="ac92c377">
<th id="86d8fb96"><p>Project</p></th>
<th id="11f12448"><p>Current Kotlin compiler performance</p></th>
<th id="43c1489"><p>New K2 Kotlin compiler performance</p></th>
<th id="6cc5d060"><p>Performance boost</p></th>
</tr></thead>
<tbody>
<tr class="" id="ca2ac4c6">
<td id="3b2928a6"><p>Kotlin</p></td>
<td id="d582645c"><p>2.2 KLOC/s</p></td>
<td id="459db4e8"><p>4.8 KLOC/s</p></td>
<td id="d1ac879a"><p>~ x2.2</p></td>
</tr>
<tr class="" id="ec045177">
<td id="86cb95dc"><p>YouTrack</p></td>
<td id="5ad73be9"><p>1.8 KLOC/s</p></td>
<td id="af446da6"><p>4.2 KLOC/s</p></td>
<td id="d90dc4bc"><p>~ x2.3</p></td>
</tr>
<tr class="" id="6a57fc4b">
<td id="a37c94eb"><p>IntelliJ IDEA</p></td>
<td id="be2abf75"><p>1.8 KLOC/s</p></td>
<td id="caf5e1ac"><p>3.9 KLOC/s</p></td>
<td id="44645140"><p>~ x2.2</p></td>
</tr>
<tr class="" id="4a5065fd">
<td id="29f4f3d0"><p>Space</p></td>
<td id="18aed8a4"><p>1.2 KLOC/s</p></td>
<td id="a6cb9f86"><p>2.8 KLOC/s</p></td>
<td id="6cf7a6c8"><p>~ x2.3</p></td>
</tr>
</tbody>
</table></div>
<aside data-type="tip" class="prompt" data-title="" id="2bd89953"><p id="3cabef3f">The KLOC/s performance numbers stand for the number of thousands of lines of code that the compiler processes per second.</p></aside><p id="5fda1e0a">You can check out the performance boost on your JVM projects and compare it with the results of the old compiler. To enable the Kotlin K2 compiler, use the following compiler option:</p>
<pre class="code" data-language="bash">-Xuse-k2
</pre>
<p id="562726be">Also, the K2 compiler <a href="https://youtrack.jetbrains.com/issues/KT?q=tag:%20fixed-in-frontend-ir%20sort%20by:%20Priority,%20votes,%20updated" id="e9a64e5b" data-external="true" rel="noopener noreferrer">includes a number of bugfixes</a>. Please note that even issues with <b id="78227843" class="">State: Open</b> from this list are in fact fixed in K2.</p>
<p id="c3491ff5">The next Kotlin releases will improve the stability of the K2 compiler and provide more features, so stay tuned!</p>
<p id="7cc29d34">If you face any performance issues with the Kotlin K2 compiler, please <a href="https://youtrack.jetbrains.com/newIssue?project=KT&amp;c=Type%20Performance%20Problem&amp;c=Subsystems%20Frontend.%20IR" id="497d98e0" data-external="true" rel="noopener noreferrer">report them to our issue tracker</a>.</p></section><section class="chapter"><h2 id="language" data-toc="whatsnew17#language">Language</h2>
<p id="eb34042e">Kotlin 1.7.0 introduces support for implementation by delegation and a new underscore operator for type arguments. It also stabilizes several language features introduced as previews in previous releases:</p>
<ul class="list _ul" id="58249aef">
<li class="list__item" id="168837cf"><p><a href="#allow-implementation-by-delegation-to-an-inlined-value-of-an-inline-class" id="38197e59">Implementation by delegation to inlined value of inline class</a></p></li>
<li class="list__item" id="e36dd65c"><p><a href="#underscore-operator-for-type-arguments" id="f7ae715d">Underscore operator for type arguments</a></p></li>
<li class="list__item" id="ba572115"><p><a href="#stable-builder-inference" id="96490a9">Stable builder inference</a></p></li>
<li class="list__item" id="b2da5418"><p><a href="#stable-opt-in-requirements" id="4e7a87aa">Stable opt-in requirements</a></p></li>
<li class="list__item" id="d8383473"><p><a href="#stable-definitely-non-nullable-types" id="30516cd">Stable definitely non-nullable types</a></p></li>
</ul>
<section class="chapter"><h3 id="allow-implementation-by-delegation-to-an-inlined-value-of-an-inline-class" data-toc="whatsnew17#allow-implementation-by-delegation-to-an-inlined-value-of-an-inline-class">Allow implementation by delegation to an inlined value of an inline class</h3>
<p id="c6fe9703">If you want to create a lightweight wrapper for a value or class instance, it's necessary to implement all interface methods by hand. Implementation by delegation solves this issue, but it did not work with inline classes before 1.7.0. This restriction has been removed, so you can now create lightweight wrappers that do not allocate memory in most cases.</p>
<pre class="code" data-language="kotlin">interface Bar {
    fun foo() = "foo"
}

@JvmInline
value class BarWrapper(val bar: Bar): Bar by bar

fun main() {
    val bw = BarWrapper(object: Bar {})
    println(bw.foo())
}
</pre></section><section class="chapter"><h3 id="underscore-operator-for-type-arguments" data-toc="whatsnew17#underscore-operator-for-type-arguments">Underscore operator for type arguments</h3>
<p id="15925999">Kotlin 1.7.0 introduces an underscore operator, <code class="code ">_</code>, for type arguments. You can use it to automatically infer a type argument when other types are specified:</p>
<pre class="code" data-language="kotlin">abstract class SomeClass&lt;T&gt; {
    abstract fun execute(): T
}

class SomeImplementation : SomeClass&lt;String&gt;() {
    override fun execute(): String = "Test"
}

class OtherImplementation : SomeClass&lt;Int&gt;() {
    override fun execute(): Int = 42
}

object Runner {
    inline fun &lt;reified S: SomeClass&lt;T&gt;, T&gt; run(): T {
        return S::class.java.getDeclaredConstructor().newInstance().execute()
    }
}

fun main() {
    // T is inferred as String because SomeImplementation derives from SomeClass&lt;String&gt;
    val s = Runner.run&lt;SomeImplementation, _&gt;()
    assert(s == "Test")

    // T is inferred as Int because OtherImplementation derives from SomeClass&lt;Int&gt;
    val n = Runner.run&lt;OtherImplementation, _&gt;()
    assert(n == 42)
}
</pre>
<aside data-type="note" class="prompt" data-title="" id="d5df14c5"><p id="2114834e">You can use the underscore operator in any position in the variables list to infer a type argument.</p></aside></section><section class="chapter"><h3 id="stable-builder-inference" data-toc="whatsnew17#stable-builder-inference">Stable builder inference</h3>
<p id="1771b463">Builder inference is a special kind of type inference that is useful when calling generic builder functions. It helps the compiler infer the type arguments of a call using the type information about other calls inside its lambda argument.</p>
<p id="ff8f9e11">Starting with 1.7.0, builder inference is automatically activated if a regular type inference cannot get enough information about a type without specifying the <code class="code ">-Xenable-builder-inference</code> compiler option, which was <a href="whatsnew16#changes-to-builder-inference" id="148de470">introduced in 1.6.0</a>.</p>
<p id="88315843"><a href="using-builders-with-builder-inference" id="933d3832">Learn how to write custom generic builders</a>.</p></section><section class="chapter"><h3 id="stable-opt-in-requirements" data-toc="whatsnew17#stable-opt-in-requirements">Stable opt-in requirements</h3>
<p id="d6ce6873"><a href="opt-in-requirements" id="28a5f139">Opt-in requirements</a> are now <a href="components-stability" id="6b95576">Stable</a> and do not require additional compiler configuration.</p>
<p id="bf695704">Before 1.7.0, the opt-in feature itself required the argument <code class="code ">-opt-in=kotlin.RequiresOptIn</code> to avoid a warning. It no longer requires this; however, you can still use the compiler argument <code class="code ">-opt-in</code> to opt-in for other annotations, <a href="opt-in-requirements#module-wide-opt-in" id="11b834e0">module-wise</a>.</p></section><section class="chapter"><h3 id="stable-definitely-non-nullable-types" data-toc="whatsnew17#stable-definitely-non-nullable-types">Stable definitely non-nullable types</h3>
<p id="a0ff6d90">In Kotlin 1.7.0, definitely non-nullable types have been promoted to <a href="components-stability" id="58625746">Stable</a>. They provide better interoperability when extending generic Java classes and interfaces.</p>
<p id="46c022cd">You can mark a generic type parameter as definitely non-nullable at the use site with the new syntax <code class="code ">T &amp; Any.</code> The syntactic form comes from the notation for <a href="https://en.wikipedia.org/wiki/Intersection_type" id="1d7454bc" data-external="true" rel="noopener noreferrer">intersection types</a> and is now limited to a type parameter with nullable upper bounds on the left side of <code class="code ">&amp;</code> and a non-nullable <code class="code ">Any</code> on the right side:</p>
<pre class="code" data-language="kotlin">fun &lt;T&gt; elvisLike(x: T, y: T &amp; Any): T &amp; Any = x ?: y

fun main() {
    // OK
    elvisLike&lt;String&gt;("", "").length
    // Error: 'null' cannot be a value of a non-null type
    elvisLike&lt;String&gt;("", null).length

    // OK
    elvisLike&lt;String?&gt;(null, "").length
    // Error: 'null' cannot be a value of a non-null type
    elvisLike&lt;String?&gt;(null, null).length
}
</pre>
<p id="fa1d22f0">Learn more about definitely non-nullable types in <a href="https://github.com/Kotlin/KEEP/blob/c72601cf35c1e95a541bb4b230edb474a6d1d1a8/proposals/definitely-non-nullable-types.md" id="b9ad18a6" data-external="true" rel="noopener noreferrer">this KEEP</a>.</p></section></section><section class="chapter"><h2 id="kotlin-jvm" data-toc="whatsnew17#kotlin-jvm">Kotlin/JVM</h2>
<p id="fb2dce51">This release brings performance improvements for the Kotlin/JVM compiler and a new compiler option. Additionally, callable references to functional interface constructors have become Stable. Note that since 1.7.0, the default target version for Kotlin/JVM compilations is now <code class="code ">1.8</code>.</p>
<ul class="list _ul" id="a376b6ab">
<li class="list__item" id="1d1e4636"><p><a href="#compiler-performance-optimizations" id="ef2959fb">Compiler performance optimizations</a></p></li>
<li class="list__item" id="5a16e6d7"><p><a href="#new-compiler-option-xjdk-release" id="c4ea9715">New compiler option <code class="code ">-Xjdk-release</code></a></p></li>
<li class="list__item" id="a0778f38"><p><a href="#stable-callable-references-to-functional-interface-constructors" id="eacb4d4f">Stable callable references to functional interface constructors</a></p></li>
<li class="list__item" id="774fe535"><p><a href="#removed-jvm-target-version-1-6" id="691b9cd8">Removed the JVM target version 1.6</a></p></li>
</ul>
<section class="chapter"><h3 id="compiler-performance-optimizations" data-toc="whatsnew17#compiler-performance-optimizations">Compiler performance optimizations</h3>
<p id="b049f1ec">Kotlin 1.7.0 introduces performance improvements for the Kotlin/JVM compiler. According to our benchmarks, compilation time has been <a href="https://youtrack.jetbrains.com/issue/KT-48233/Switching-to-JVM-IR-backend-increases-compilation-time-by-more-t#focus=Comments-27-6114542.0-0" id="6afac14b" data-external="true" rel="noopener noreferrer">reduced by 10% on average</a> compared to Kotlin 1.6.0. Projects with lots of usages of inline functions, for example, <a href="https://youtrack.jetbrains.com/issue/KT-51416/Compilation-of-kotlinx-html-DSL-should-still-be-faster" id="b76e17a" data-external="true" rel="noopener noreferrer">projects using <code class="code ">kotlinx.html</code></a>, will compile faster thanks to the improvements to the bytecode postprocessing.</p></section><section class="chapter"><h3 id="new-compiler-option-xjdk-release" data-toc="whatsnew17#new-compiler-option-xjdk-release">New compiler option: -Xjdk-release</h3>
<p id="905253f2">Kotlin 1.7.0 presents a new compiler option, <code class="code ">-Xjdk-release</code>. This option is similar to the <a href="http://openjdk.java.net/jeps/247" id="4e6e9e92" data-external="true" rel="noopener noreferrer">javac's command-line <code class="code ">--release</code> option</a>. The <code class="code ">-Xjdk-release</code> option controls the target bytecode version and limits the API of the JDK in the classpath to the specified Java version. For example, <code class="code ">kotlinc -Xjdk-release=1.8</code> won't allow referencing <code class="code ">java.lang.Module</code> even if the JDK in the dependencies is version 9 or higher.</p>
<aside data-type="note" class="prompt" data-title="" id="bea2a399"><p id="7290adcd">This option is <a href="https://youtrack.jetbrains.com/issue/KT-29974" id="db16f90c" data-external="true" rel="noopener noreferrer">not guaranteed</a> to be effective for each JDK distribution.</p></aside><p id="3eee25ae">Please leave your feedback on <a href="https://youtrack.jetbrains.com/issue/KT-29974/Add-a-compiler-option-Xjdk-release-similar-to-javac-s-release-to" id="e4a664eb" data-external="true" rel="noopener noreferrer">this YouTrack ticket</a>.</p></section><section class="chapter"><h3 id="stable-callable-references-to-functional-interface-constructors" data-toc="whatsnew17#stable-callable-references-to-functional-interface-constructors">Stable callable references to functional interface constructors</h3>
<p id="e05f7374"><a href="reflection#callable-references" id="5ca83099">Callable references</a> to functional interface constructors are now <a href="components-stability" id="3cbf945b">Stable</a>. Learn how to <a href="fun-interfaces#migration-from-an-interface-with-constructor-function-to-a-functional-interface" id="5ca291b4">migrate</a> from an interface with a constructor function to a functional interface using callable references.</p>
<p id="1a38351a">Please report any issues you find in <a href="https://youtrack.jetbrains.com/newissue?project=kt" id="5f805abd" data-external="true" rel="noopener noreferrer">YouTrack</a>.</p></section><section class="chapter"><h3 id="removed-jvm-target-version-1-6" data-toc="whatsnew17#removed-jvm-target-version-1-6">Removed JVM target version 1.6</h3>
<p id="eb592977">The default target version for Kotlin/JVM compilations is <code class="code ">1.8</code>. The <code class="code ">1.6</code> target has been removed.</p>
<p id="cfeaf681">Please migrate to JVM target 1.8 or above. Learn how to update the JVM target version for:</p>
<ul class="list _ul" id="1ab893d6">
<li class="list__item" id="8e9f06ee"><p><a href="gradle#attributes-specific-to-jvm" id="3a5b2e4f">Gradle</a></p></li>
<li class="list__item" id="cceb41ec"><p><a href="maven#attributes-specific-to-jvm" id="37a65ba1">Maven</a></p></li>
<li class="list__item" id="ba3474c0"><p><a href="compiler-reference#jvm-target-version" id="ea72ed63">The command-line compiler</a></p></li>
</ul></section></section><section class="chapter"><h2 id="kotlin-native" data-toc="whatsnew17#kotlin-native">Kotlin/Native</h2>
<p id="4889f0fe">Kotlin 1.7.0 includes changes to Objective-C and Swift interoperability and stabilizes features that were introduced in previous releases. It also brings performance improvements for the new memory manager along with other updates:</p>
<ul class="list _ul" id="52c716b">
<li class="list__item" id="4fdf2496"><p><a href="#performance-improvements-for-the-new-memory-manager" id="a344bb5c">Performance improvements for the new memory manager</a></p></li>
<li class="list__item" id="d660d2f6"><p><a href="#unified-compiler-plugin-abi-with-jvm-and-js-ir-backends" id="83cc6a87">Unified compiler plugin ABI with JVM and JS IR backends</a></p></li>
<li class="list__item" id="e0cdaf7a"><p><a href="#support-for-standalone-android-executables" id="aec48523">Support for standalone Android executables</a></p></li>
<li class="list__item" id="98937988"><p><a href="#interop-with-swift-async-await-returning-void-instead-of-kotlinunit" id="cecc82cd">Interop with Swift async/await: returning <code class="code ">Void</code> instead of <code class="code ">KotlinUnit</code></a></p></li>
<li class="list__item" id="216550ae"><p><a href="#prohibited-undeclared-exceptions-through-objective-c-bridges" id="243eb801">Prohibited undeclared exceptions through Objective-C bridges</a></p></li>
<li class="list__item" id="569ac49b"><p><a href="#improved-cocoapods-integration" id="10e4aab8">Improved CocoaPods integration</a></p></li>
<li class="list__item" id="30a6d14d"><p><a href="#overriding-the-kotlin-native-compiler-download-url" id="2ea39a0c">Overriding of the Kotlin/Native compiler download URL</a></p></li>
</ul>
<section class="chapter"><h3 id="performance-improvements-for-the-new-memory-manager" data-toc="whatsnew17#performance-improvements-for-the-new-memory-manager">Performance improvements for the new memory manager</h3>
<aside data-type="note" class="prompt" data-title="" id="40fc37bf"><p id="b67c6bb3">The new Kotlin/Native memory manager is in <a href="components-stability" id="cc6918ae">Alpha</a>. It may change incompatibly and require manual migration in the future. We would appreciate your feedback in <a href="https://youtrack.jetbrains.com/issue/KT-48525" id="72b1e29d" data-external="true" rel="noopener noreferrer">YouTrack</a>.</p></aside><p id="b69ef956">The new memory manager is still in Alpha, but it is on its way to becoming <a href="components-stability" id="7e34415f">Stable</a>. This release delivers significant performance improvements for the new memory manager, especially in garbage collection (GC). In particular, concurrent implementation of the sweep phase, <a href="whatsnew1620" id="c5d80370">introduced in 1.6.20</a>, is now enabled by default. This helps reduce the time the application is paused for GC. The new GC scheduler is better at choosing the GC frequency, especially for larger heaps.</p>
<p id="455b2705">Also, we've specifically optimized debug binaries, ensuring that the proper optimization level and link-time optimizations are used in the implementation code of the memory manager. This helped us improve execution time by roughly 30% for debug binaries on our benchmarks.</p>
<p id="ecaa4683">Try using the new memory manager in your projects to see how it works, and share your feedback with us in <a href="https://youtrack.jetbrains.com/issue/KT-48525" id="765d27a3" data-external="true" rel="noopener noreferrer">YouTrack</a>.</p></section><section class="chapter"><h3 id="unified-compiler-plugin-abi-with-jvm-and-js-ir-backends" data-toc="whatsnew17#unified-compiler-plugin-abi-with-jvm-and-js-ir-backends">Unified compiler plugin ABI with JVM and JS IR backends</h3>
<p id="89a683c0">Starting with Kotlin 1.7.0, the Kotlin Multiplatform Gradle plugin uses the embeddable compiler jar for Kotlin/Native by default. This <a href="whatsnew16#unified-compiler-plugin-abi-with-jvm-and-js-ir-backends" id="6f4f4462">feature was announced in 1.6.0</a> as Experimental, and now it's stable and ready to use.</p>
<p id="26bca306">This improvement is very handy for library authors, as it improves the compiler plugin development experience. Before this release, you had to provide separate artifacts for Kotlin/Native, but now you can use the same compiler plugin artifacts for Native and other supported platforms.</p>
<aside data-type="warning" class="prompt" data-title="" id="b5f972dc"><p id="282da6c6">This feature might require plugin developers to take migration steps for their existing plugins.</p>
<p id="2007e9ff">Learn how to prepare your plugin for the update in this <a href="https://youtrack.jetbrains.com/issue/KT-48595" id="dd5b9dd1" data-external="true" rel="noopener noreferrer">YouTrack issue</a>.</p></aside></section><section class="chapter"><h3 id="support-for-standalone-android-executables" data-toc="whatsnew17#support-for-standalone-android-executables">Support for standalone Android executables</h3>
<p id="b5607adc">Kotlin 1.7.0 provides full support for generating standard executables for Android Native targets. It was <a href="whatsnew1620#support-for-standalone-android-executables" id="3e71fd62">introduced in 1.6.20</a>, and now it's enabled by default.</p>
<p id="9f17e5fb">If you want to roll back to the previous behavior when Kotlin/Native generated shared libraries, use the following setting:</p>
<pre class="code" data-language="kotlin">binaryOptions["androidProgramType"] = "nativeActivity"
</pre></section><section class="chapter"><h3 id="interop-with-swift-async-await-returning-void-instead-of-kotlinunit" data-toc="whatsnew17#interop-with-swift-async-await-returning-void-instead-of-kotlinunit">Interop with Swift async/await: returning Void instead of KotlinUnit</h3>
<p id="2e437234">Kotlin <code class="code ">suspend</code> functions now return the <code class="code ">Void</code> type instead of <code class="code ">KotlinUnit</code> in Swift. This is the result of the improved interop with Swift's <code class="code ">async</code>/<code class="code ">await</code>. This feature was <a href="whatsnew1620#interop-with-swift-async-await-returning-void-instead-of-kotlinunit" id="b6062f34">introduced in 1.6.20</a>, and this release enables this behavior by default.</p>
<p id="ff58545a">You don't need to use the <code class="code ">kotlin.native.binary.unitSuspendFunctionObjCExport=proper</code> property anymore to return the proper type for such functions.</p></section><section class="chapter"><h3 id="prohibited-undeclared-exceptions-through-objective-c-bridges" data-toc="whatsnew17#prohibited-undeclared-exceptions-through-objective-c-bridges">Prohibited undeclared exceptions through Objective-C bridges</h3>
<p id="d56098a0">When you call Kotlin code from Swift/Objective-C code (or vice versa) and this code throws an exception, it should be handled by the code where the exception occurred, unless you specifically allowed the forwarding of exceptions between languages with proper conversion (for example, using the <code class="code ">@Throws</code> annotation).</p>
<p id="3371f3ca">Previously, Kotlin had another unintended behavior where undeclared exceptions could "leak" from one language to another in some cases. Kotlin 1.7.0 fixes that issue, and now such cases lead to program termination.</p>
<p id="abdf0e8e">So, for example, if you have a <code class="code ">{ throw Exception() }</code> lambda in Kotlin and call it from Swift, in Kotlin 1.7.0 it will terminate as soon as the exception reaches the Swift code. In previous Kotlin versions, such an exception could leak to the Swift code.</p>
<p id="74852782">The <code class="code ">@Throws</code> annotation continues to work as before.</p></section><section class="chapter"><h3 id="improved-cocoapods-integration" data-toc="whatsnew17#improved-cocoapods-integration">Improved CocoaPods integration</h3>
<p id="648e3fec">Starting with Kotlin 1.7.0, you no longer need to install the <code class="code ">cocoapods-generate</code> plugin if you want to integrate CocoaPods in your projects.</p>
<p id="2ceab626">Previously, you needed to install both the CocoaPods dependency manager and the <code class="code ">cocoapods-generate</code> plugin to use CocoaPods, for example, to handle <a href="multiplatform-mobile-ios-dependencies#with-cocoapods" id="ca8ae46">iOS dependencies</a> in Kotlin Multiplatform Mobile projects.</p>
<p id="6c3991a9">Now setting up the CocoaPods integration is easier, and we've resolved the issue when <code class="code ">cocoapods-generate</code> couldn't be installed on Ruby 3 and later. Now the newest Ruby versions that work better on Apple M1 are also supported.</p>
<p id="13a57504">See how to set up the <a href="native-cocoapods#set-up-the-environment-to-work-with-cocoapods" id="848e7b2c">initial CocoaPods integration</a>.</p></section><section class="chapter"><h3 id="overriding-the-kotlin-native-compiler-download-url" data-toc="whatsnew17#overriding-the-kotlin-native-compiler-download-url">Overriding the Kotlin/Native compiler download URL</h3>
<p id="b30b1191">Starting with Kotlin 1.7.0, you can customize the download URL for the Kotlin/Native compiler. This is useful when external links on the CI are forbidden.</p>
<p id="bf99a548">To override the default base URL <code class="code ">https://download.jetbrains.com/kotlin/native/builds</code>, use the following Gradle property:</p>
<pre class="code" data-language="none">kotlin.native.distribution.baseDownloadUrl=https://example.com
</pre>
<aside data-type="note" class="prompt" data-title="" id="713fb610"><p id="bb86d453">The downloader will append the native version and target OS to this base URL to ensure it downloads the actual compiler distribution.</p></aside></section></section><section class="chapter"><h2 id="kotlin-js" data-toc="whatsnew17#kotlin-js">Kotlin/JS</h2>
<p id="f0b97338">Kotlin/JS is receiving further improvements to the <a href="js-ir-compiler" id="f88ad15b">JS IR compiler backend</a> along with other updates that can make your development experience better:</p>
<ul class="list _ul" id="9b26e174">
<li class="list__item" id="71f770e"><p><a href="#performance-improvements-for-the-new-ir-backend" id="a50dd35">Performance improvements for the new IR backend</a></p></li>
<li class="list__item" id="e1b63f30"><p><a href="#minification-for-member-names-when-using-ir" id="40ba630c">Minification for member names when using IR</a></p></li>
<li class="list__item" id="90cbd56e"><p><a href="#support-for-older-browsers-via-polyfills-in-the-ir-backend" id="3d33428c">Support for older browsers via polyfills in the IR backend</a></p></li>
<li class="list__item" id="2159da70"><p><a href="#dynamically-load-javascript-modules-from-js-expressions" id="955f96b1">Dynamically load JavaScript modules from js expressions</a></p></li>
<li class="list__item" id="30fcb86b"><p><a href="#specify-environment-variables-for-javascript-test-runners" id="bfac938c">Specify environment variables for JavaScript test runners</a></p></li>
</ul>
<section class="chapter"><h3 id="performance-improvements-for-the-new-ir-backend" data-toc="whatsnew17#performance-improvements-for-the-new-ir-backend">Performance improvements for the new IR backend</h3>
<p id="fc0690ff">This release has some major updates that should improve your development experience:</p>
<ul class="list _ul" id="3070d1a3">
<li class="list__item" id="16a94bb4"><p>Incremental compilation performance of Kotlin/JS has been significantly improved. It takes less time to build your JS projects. Incremental rebuilds should now be roughly on par with the legacy backend in many cases now.</p></li>
<li class="list__item" id="c1095754"><p>The Kotlin/JS final bundle requires less space, as we have significantly reduced the size of the final artifacts. We've measured up to a 20% reduction in the production bundle size compared to the legacy backend for some large projects.</p></li>
<li class="list__item" id="4d43a3d0"><p>Type checking for interfaces has been improved by orders of magnitude.</p></li>
<li class="list__item" id="ceec1daf"><p>Kotlin generates higher-quality JS code</p></li>
</ul></section><section class="chapter"><h3 id="minification-for-member-names-when-using-ir" data-toc="whatsnew17#minification-for-member-names-when-using-ir">Minification for member names when using IR</h3>
<p id="a2621864">The Kotlin/JS IR compiler now uses its internal information about the relationships of your Kotlin classes and functions to apply more efficient minification, shortening the names of functions, properties, and classes. This shrinks the resulting bundled applications.</p>
<p id="981d1d96">This type of minification is automatically applied when you build your Kotlin/JS application in production mode and is enabled by default. To disable member name minification, use the <code class="code ">-Xir-minimized-member-names</code> compiler flag:</p>
<pre class="code" data-language="kotlin">kotlin {
    js(IR) {
        compilations.all {
            compileKotlinTask.kotlinOptions.freeCompilerArgs += listOf("-Xir-minimized-member-names=false")
        }
    }
}
</pre></section><section class="chapter"><h3 id="support-for-older-browsers-via-polyfills-in-the-ir-backend" data-toc="whatsnew17#support-for-older-browsers-via-polyfills-in-the-ir-backend">Support for older browsers via polyfills in the IR backend</h3>
<p id="89ed0786">The IR compiler backend for Kotlin/JS now includes the same polyfills as the legacy backend. This allows code compiled with the new compiler to run in older browsers that do not support all the methods from ES2015 used by the Kotlin standard library. Only those polyfills actually used by the project are included in the final bundle, which minimizes their potential impact on the bundle size.</p>
<p id="e0a228d3">This feature is enabled by default when using the IR compiler, and you don't need to configure it.</p></section><section class="chapter"><h3 id="dynamically-load-javascript-modules-from-js-expressions" data-toc="whatsnew17#dynamically-load-javascript-modules-from-js-expressions">Dynamically load JavaScript modules from js expressions</h3>
<p id="9dddcd9b">When working with the JavaScript modules, most applications use static imports, whose use is covered with the <a href="js-modules" id="7eae104f">JavaScript module integration</a>. However, Kotlin/JS was missing a mechanism to load JavaScript modules dynamically at runtime in your applications.</p>
<p id="e54088db">Starting with Kotlin 1.7.0, the <code class="code ">import</code> statement from JavaScript is supported in <code class="code ">js</code> blocks, allowing you to dynamically bring packages into your application at runtime:</p>
<pre class="code" data-language="kotlin">val myPackage = js("import('my-package')")
</pre></section><section class="chapter"><h3 id="specify-environment-variables-for-javascript-test-runners" data-toc="whatsnew17#specify-environment-variables-for-javascript-test-runners">Specify environment variables for JavaScript test runners</h3>
<p id="443e1da">To tune Node.js package resolution or pass external information to Node.js tests, you can now specify environment variables used by the JavaScript test runners. To define an environment variable, use the <code class="code ">environment()</code> function with a key-value pair inside the <code class="code ">testTask</code> block in your build script:</p>
<pre class="code" data-language="kotlin">kotlin {
    js {
        nodejs {
            testTask {
                environment("key", "value")
            }
        }
    }
}
</pre></section></section><section class="chapter"><h2 id="standard-library" data-toc="whatsnew17#standard-library">Standard library</h2>
<p id="f0a26890">In Kotlin 1.7.0, the standard library has received a range of changes and improvements. They introduce new features, stabilize experimental ones, and unify support for named capturing groups for Native, JS, and the JVM:</p>
<ul class="list _ul" id="24bf3537">
<li class="list__item" id="6e96e8f7"><p><a href="#min-and-max-collection-functions-return-as-non-nullable" id="1d2ffc8a">min() and max() collection functions return as non-nullable</a></p></li>
<li class="list__item" id="9ca4c270"><p><a href="#regular-expression-matching-at-specific-indices" id="8381c87f">Regular expression matching at specific indices</a></p></li>
<li class="list__item" id="ca03b128"><p><a href="#extended-support-for-previous-language-and-api-versions" id="d37cf7a4">Extended support of previous language and API versions</a></p></li>
<li class="list__item" id="a304a4bb"><p><a href="#access-to-annotations-via-reflection" id="e59fce09">Access to annotations via reflection</a></p></li>
<li class="list__item" id="2d60e9a4"><p><a href="#stable-deep-recursive-functions" id="5d450eb9">Stable deep recursive functions</a></p></li>
<li class="list__item" id="512246a"><p><a href="#time-marks-based-on-inline-classes-for-default-time-source" id="5f60d231">Time marks based on inline classes for default time source</a></p></li>
<li class="list__item" id="34d3f5ed"><p><a href="#new-experimental-extension-functions-for-java-optionals" id="7e41394f">New experimental extension functions for Java Optionals</a></p></li>
<li class="list__item" id="cb379b90"><p><a href="#support-for-named-capturing-groups-in-js-and-native" id="7a611e3f">Support for named capturing groups in JS and Native</a></p></li>
</ul>
<section class="chapter"><h3 id="min-and-max-collection-functions-return-as-non-nullable" data-toc="whatsnew17#min-and-max-collection-functions-return-as-non-nullable">min() and max() collection functions return as non-nullable</h3>
<p id="ddce0211">In <a href="whatsnew14" id="3e67d425">Kotlin 1.4.0</a>, we renamed the <code class="code ">min()</code> and <code class="code ">max()</code> collection functions to <code class="code ">minOrNull()</code> and <code class="code ">maxOrNull()</code>. These new names better reflect their behavior – returning null if the receiver collection is empty. It also helped align the functions' behavior with naming conventions used throughout the Kotlin collections API.</p>
<p id="87c696d0">The same was true of <code class="code ">minBy()</code>, <code class="code ">maxBy()</code>, <code class="code ">minWith()</code>, and <code class="code ">maxWith()</code>, which all got their *OrNull() synonyms in Kotlin 1.4.0. Older functions affected by this change were gradually deprecated.</p>
<p id="1a564e3c">Kotlin 1.7.0 reintroduces the original function names, but with a non-nullable return type. The new <code class="code ">min()</code>, <code class="code ">max()</code>, <code class="code ">minBy()</code>, <code class="code ">maxBy()</code>, <code class="code ">minWith()</code>, and <code class="code ">maxWith()</code> functions now strictly return the collection element or throw an exception.</p>
<pre class="code" data-language="kotlin">fun main() {
    val numbers = listOf&lt;Int&gt;()
    println(numbers.maxOrNull()) // "null"
    println(numbers.max()) // "Exception in... Collection is empty."
}
</pre></section><section class="chapter"><h3 id="regular-expression-matching-at-specific-indices" data-toc="whatsnew17#regular-expression-matching-at-specific-indices">Regular expression matching at specific indices</h3>
<p id="2c37b675">The <code class="code ">Regex.matchAt()</code> and <code class="code ">Regex.matchesAt()</code> functions, <a href="whatsnew1530#matching-with-regex-at-a-particular-position" id="9e0b9d1d">introduced in 1.5.30</a>, are now Stable. They provide a way to check whether a regular expression has an exact match at a particular position in a <code class="code ">String</code> or <code class="code ">CharSequence</code>.</p>
<p id="e8fcace"><code class="code ">matchesAt()</code> checks for a match and returns a boolean result:</p>
<pre class="code" data-language="kotlin">fun main() {
    val releaseText = "Kotlin 1.7.0 is on its way!"
    // regular expression: one digit, dot, one digit, dot, one or more digits
    val versionRegex = "\\d[.]\\d[.]\\d+".toRegex()

    println(versionRegex.matchesAt(releaseText, 0)) // "false"
    println(versionRegex.matchesAt(releaseText, 7)) // "true"
}
</pre>
<p id="a460e401"><code class="code ">matchAt()</code> returns the match if it's found, or <code class="code ">null</code> if it isn't:</p>
<pre class="code" data-language="kotlin">fun main() {
    val releaseText = "Kotlin 1.7.0 is on its way!"
    val versionRegex = "\\d[.]\\d[.]\\d+".toRegex()

    println(versionRegex.matchAt(releaseText, 0)) // "null"
    println(versionRegex.matchAt(releaseText, 7)?.value) // "1.7.0"
}
</pre>
<p id="26057839">We'd be grateful for your feedback on this <a href="https://youtrack.jetbrains.com/issue/KT-34021" id="9fd391e7" data-external="true" rel="noopener noreferrer">YouTrack issue</a>.</p></section><section class="chapter"><h3 id="extended-support-for-previous-language-and-api-versions" data-toc="whatsnew17#extended-support-for-previous-language-and-api-versions">Extended support for previous language and API versions</h3>
<p id="bc5d857">To support library authors developing libraries that are meant to be consumable in a wide range of previous Kotlin versions, and to address the increased frequency of major Kotlin releases, we have extended our support for previous language and API versions.</p>
<p id="1e114c12">With Kotlin 1.7.0, we're supporting three previous language and API versions rather than two. This means Kotlin 1.7.0 supports the development of libraries targeting Kotlin versions down to 1.4.0. For more information on backward compatibility, see <a href="compatibility-modes" id="a39b44fe">Compatibility modes</a>.</p></section><section class="chapter"><h3 id="access-to-annotations-via-reflection" data-toc="whatsnew17#access-to-annotations-via-reflection">Access to annotations via reflection</h3>
<p id="2ec9d785">The <code class="code ">KAnnotatedElement.<a href="../api/latest/jvm/stdlib/kotlin.reflect.full/find-annotations" id="84c7a869" data-external="true" rel="noopener noreferrer">findAnnotations()</a></code> extension function, which was first <a href="whatsnew16#repeatable-annotations-with-runtime-retention-for-1-8-jvm-target" id="8080d973">introduced in 1.6.0</a>, is now <a href="components-stability" id="beca251d">Stable</a>. This <a href="reflection" id="172f927d">reflection</a> function returns all annotations of a given type on an element, including individually applied and repeated annotations.</p>
<pre class="code" data-language="kotlin">@Repeatable
annotation class Tag(val name: String)

@Tag("First Tag")
@Tag("Second Tag")
fun taggedFunction() {
    println("I'm a tagged function!")
}

fun main() {
    val x = ::taggedFunction
    val foo = x as KAnnotatedElement
    println(foo.findAnnotations&lt;Tag&gt;())
    // [@Tag(name=First Tag), @Tag(name=Second Tag)]
}
</pre></section><section class="chapter"><h3 id="stable-deep-recursive-functions" data-toc="whatsnew17#stable-deep-recursive-functions">Stable deep recursive functions</h3>
<p id="935dacb4">Deep recursive functions have been available as an experimental feature since <a href="https://blog.jetbrains.com/kotlin/2020/07/kotlin-1-4-rc-debugging-coroutines/#Defining_deep_recursive_functions_using_coroutines" id="57710d34" data-external="true" rel="noopener noreferrer">Kotlin 1.4.0</a>, and they are now <a href="components-stability" id="4a9b790f">Stable</a> in Kotlin 1.7.0. Using <code class="code ">DeepRecursiveFunction</code>, you can define a function that keeps its stack on the heap instead of using the actual call stack. This allows you to run very deep recursive computations. To call a deep recursive function, <code class="code ">invoke</code> it.</p>
<p id="262ad878">In this example, a deep recursive function is used to calculate the depth of a binary tree recursively. Even though this sample function calls itself recursively 100,000 times, no <code class="code ">StackOverflowError</code> is thrown:</p>
<pre class="code" data-language="kotlin">class Tree(val left: Tree?, val right: Tree?)

val calculateDepth = DeepRecursiveFunction&lt;Tree?, Int&gt; { t -&gt;
    if (t == null) 0 else maxOf(
        callRecursive(t.left),
        callRecursive(t.right)
    ) + 1
}

fun main() {
    // Generate a tree with a depth of 100_000
    val deepTree = generateSequence(Tree(null, null)) { prev -&gt;
        Tree(prev, null)
    }.take(100_000).last()

    println(calculateDepth(deepTree)) // 100000
}
</pre>
<p id="7a135fbe">Consider using deep recursive functions in your code where your recursion depth exceeds 1000 calls.</p></section><section class="chapter"><h3 id="time-marks-based-on-inline-classes-for-default-time-source" data-toc="whatsnew17#time-marks-based-on-inline-classes-for-default-time-source">Time marks based on inline classes for default time source</h3>
<p id="3d4678f0">Kotlin 1.7.0 improves the performance of time measurement functionality by changing the time marks returned by <code class="code ">TimeSource.Monotonic</code> into inline value classes. This means that calling functions like <code class="code ">markNow()</code>, <code class="code ">elapsedNow()</code>, <code class="code ">measureTime()</code>, and <code class="code ">measureTimedValue()</code> doesn't allocate wrapper classes for their <code class="code ">TimeMark</code> instances. Especially when measuring a piece of code that is part of a hot path, this can help minimize the performance impact of the measurement:</p>
<pre class="code" data-language="kotlin">@OptIn(ExperimentalTime::class)
fun main() {
    val mark = TimeSource.Monotonic.markNow() // Returned `TimeMark` is inline class
    val elapsedDuration = mark.elapsedNow()
}
</pre>
<aside data-type="note" class="prompt" data-title="" id="568b3260"><p id="fb504185">This optimization is only available if the time source from which the <code class="code ">TimeMark</code> is obtained is statically known to be <code class="code ">TimeSource.Monotonic</code>.</p></aside></section><section class="chapter"><h3 id="new-experimental-extension-functions-for-java-optionals" data-toc="whatsnew17#new-experimental-extension-functions-for-java-optionals">New experimental extension functions for Java Optionals</h3>
<p id="839e7884">Kotlin 1.7.0 comes with new convenience functions that simplify working with <code class="code ">Optional</code> classes in Java. These new functions can be used to unwrap and convert optional objects on the JVM and help make working with Java APIs more concise.</p>
<p id="a7f93e60">The <code class="code ">getOrNull()</code>, <code class="code ">getOrDefault()</code>, and <code class="code ">getOrElse()</code> extension functions allow you to get the value of an <code class="code ">Optional</code> if it's present. Otherwise, you get a default value, <code class="code ">null</code>, or a value returned by a function, respectively:</p>
<pre class="code" data-language="kotlin">val presentOptional = Optional.of("I'm here!")

println(presentOptional.getOrNull())
// "I'm here!"

val absentOptional = Optional.empty&lt;String&gt;()

println(absentOptional.getOrNull())
// null
println(absentOptional.getOrDefault("Nobody here!"))
// "Nobody here!"
println(absentOptional.getOrElse {
    println("Optional was absent!")
    "Default value!"
})
// "Optional was absent!"
// "Default value!"
</pre>
<p id="5da57fc8">The <code class="code ">toList()</code>, <code class="code ">toSet()</code>, and <code class="code ">asSequence()</code> extension functions convert the value of a present <code class="code ">Optional</code> to a list, set, or sequence, or return an empty collection otherwise. The <code class="code ">toCollection()</code> extension function appends the <code class="code ">Optional</code> value to an already existing destination collection:</p>
<pre class="code" data-language="kotlin">val presentOptional = Optional.of("I'm here!")
val absentOptional = Optional.empty&lt;String&gt;()
println(presentOptional.toList() + "," + absentOptional.toList())
// ["I'm here!"], []
println(presentOptional.toSet() + "," + absentOptional.toSet())
// ["I'm here!"], []
val myCollection = mutableListOf&lt;String&gt;()
absentOptional.toCollection(myCollection)
println(myCollection)
// []
presentOptional.toCollection(myCollection)
println(myCollection)
// ["I'm here!"]
val list = listOf(presentOptional, absentOptional).flatMap { it.asSequence() }
println(list)
// ["I'm here!"]
</pre>
<p id="a506bac6">These extension functions are being introduced as Experimental in Kotlin 1.7.0. You can learn more about <code class="code ">Optional</code> extensions in <a href="https://github.com/Kotlin/KEEP/pull/291" id="aaf48a2b" data-external="true" rel="noopener noreferrer">this KEEP</a>. As always, we welcome your feedback in the <a href="https://kotl.in/issue" id="442bed74" data-external="true" rel="noopener noreferrer">Kotlin issue tracker</a>.</p></section><section class="chapter"><h3 id="support-for-named-capturing-groups-in-js-and-native" data-toc="whatsnew17#support-for-named-capturing-groups-in-js-and-native">Support for named capturing groups in JS and Native</h3>
<p id="cbb10848">Starting with Kotlin 1.7.0, named capturing groups are supported not only on the JVM, but on the JS and Native platforms as well.</p>
<p id="9be6b622">To give a name to a capturing group, use the (<code class="code ">?&lt;name&gt;group</code>) syntax in your regular expression. To get the text matched by a group, call the newly introduced <a href="../api/latest/jvm/stdlib/kotlin.text/get" id="d0e84c54" data-external="true" rel="noopener noreferrer"><code class="code ">MatchGroupCollection.get()</code></a> function and pass the group name.</p>
<section class="chapter"><h4 id="retrieve-matched-group-value-by-name" data-toc="whatsnew17#retrieve-matched-group-value-by-name">Retrieve matched group value by name</h4>
<p id="26d2592b">Consider this example for matching city coordinates. To get a collection of groups matched by the regular expression, use <a href="../api/latest/jvm/stdlib/kotlin.text/-match-result/groups" id="2dc1fadb" data-external="true" rel="noopener noreferrer"><code class="code ">groups</code></a>. Compare retrieving a group's contents by its number (index) and by its name using <code class="code ">value</code>:</p>
<pre class="code" data-language="kotlin">fun main() {
    val regex = "\\b(?&lt;city&gt;[A-Za-z\\s]+),\\s(?&lt;state&gt;[A-Z]{2}):\\s(?&lt;areaCode&gt;[0-9]{3})\\b".toRegex()
    val input = "Coordinates: Austin, TX: 123"
    val match = regex.find(input)!!
    println(match.groups["city"]?.value) // "Austin" — by name
    println(match.groups[2]?.value) // "TX" — by number
}
</pre></section><section class="chapter"><h4 id="named-backreferencing" data-toc="whatsnew17#named-backreferencing">Named backreferencing</h4>
<p id="f7bb4b1e">You can now also use group names when backreferencing groups. Backreferences match the same text that was previously matched by a capturing group. For this, use the <code class="code ">\k&lt;name&gt;</code> syntax in your regular expression:</p>
<pre class="code" data-language="kotlin">fun backRef() {
    val regex = "(?&lt;title&gt;\\w+), yes \\k&lt;title&gt;".toRegex()
    val match = regex.find("Do you copy? Sir, yes Sir!")!!
    println(match.value) // "Sir, yes Sir"
    println(match.groups["title"]?.value) // "Sir"
}
</pre></section><section class="chapter"><h4 id="named-groups-in-replacement-expressions" data-toc="whatsnew17#named-groups-in-replacement-expressions">Named groups in replacement expressions</h4>
<p id="d0e8f076">Named group references can be used with replacement expressions. Consider the <a href="../api/latest/jvm/stdlib/kotlin.text/-regex/replace" id="d9c12e49" data-external="true" rel="noopener noreferrer"><code class="code ">replace()</code></a> function that substitutes all occurrences of the specified regular expression in the input with a replacement expression, and the <a href="../api/latest/jvm/stdlib/kotlin.text/-regex/replace-first" id="ec6fd37" data-external="true" rel="noopener noreferrer"><code class="code ">replaceFirst()</code></a> function that swaps the first match only.</p>
<p id="5ab256e2">Occurrences of <code class="code ">${name}</code> in the replacement string are substituted with the subsequences corresponding to the captured groups with the specified name. You can compare replacements in group references by name and index:</p>
<pre class="code" data-language="kotlin">fun dateReplace() {
    val dateRegex = Regex("(?&lt;dd&gt;\\d{2})-(?&lt;mm&gt;\\d{2})-(?&lt;yyyy&gt;\\d{4})")
    val input = "Date of birth: 27-04-2022"
    println(dateRegex.replace(input, "\${yyyy}-\${mm}-\${dd}")) // "Date of birth: 2022-04-27" — by name
    println(dateRegex.replace(input, "\$3-\$2-\$1")) // "Date of birth: 2022-04-27" — by number
}
</pre></section></section></section><section class="chapter"><h2 id="gradle" data-toc="whatsnew17#gradle">Gradle</h2>
<p id="dc3e47ce">This release introduces new build reports, support for Gradle plugin variants, new statistics in kapt, and a lot more:</p>
<ul class="list _ul" id="a94fd8ae">
<li class="list__item" id="18fc5cc3"><p><a href="#a-new-approach-to-incremental-compilation" id="cb0ab1aa">A new approach to incremental compilation</a></p></li>
<li class="list__item" id="41667c8"><p><a href="#build-reports-for-kotlin-compiler-tasks" id="f83fa9a">New build reports for tracking compiler performance</a></p></li>
<li class="list__item" id="296f59d7"><p><a href="#bumping-minimum-supported-versions" id="1ebce8de">Changes to the minimum supported versions of Gradle and the Android Gradle plugin</a></p></li>
<li class="list__item" id="1a49fd21"><p><a href="#support-for-gradle-plugin-variants" id="62ec682f">Support for Gradle plugin variants</a></p></li>
<li class="list__item" id="af66de7c"><p><a href="#updates-in-the-kotlin-gradle-plugin-api" id="480a57b8">Updates in the Kotlin Gradle plugin API</a></p></li>
<li class="list__item" id="6654b6c"><p><a href="#the-sam-with-receiver-plugin-is-available-via-the-plugins-api" id="db6e4d22">Availability of the sam-with-receiver plugin via the plugins API</a></p></li>
<li class="list__item" id="9ac3e98b"><p><a href="#changes-in-compile-tasks" id="99e8323c">Changes in compile tasks</a></p></li>
<li class="list__item" id="d634d714"><p><a href="#statistics-of-generated-files-by-each-annotation-processor-in-kapt" id="9dbd8569">New statistics of generated files by each annotation processor in kapt</a></p></li>
<li class="list__item" id="47707d9e"><p><a href="#deprecation-of-the-kotlin-compiler-execution-strategy-system-property" id="cc28e530">Deprecation of the kotlin.compiler.execution.strategy system property</a></p></li>
<li class="list__item" id="8ad53b48"><p><a href="#removal-of-deprecated-options-methods-and-plugins" id="e99a09a0">Removal of deprecated options, methods, and plugins</a></p></li>
</ul>
<section class="chapter"><h3 id="a-new-approach-to-incremental-compilation" data-toc="whatsnew17#a-new-approach-to-incremental-compilation">A new approach to incremental compilation</h3>
<aside data-type="warning" class="prompt" data-title="" id="d04b93e6"><p id="f98cf26b">The new approach to incremental compilation is <a href="components-stability" id="72760aee">Experimental</a>. It may be dropped or changed at any time. Opt-in is required (see the details below). We encourage you to use it only for evaluation purposes, and we would appreciate your feedback in <a href="https://youtrack.jetbrains.com/issues/KT" id="60d4eee7" data-external="true" rel="noopener noreferrer">YouTrack</a>.</p></aside><p id="6860e83b">In Kotlin 1.7.0, we've reworked incremental compilation for cross-module changes. Now incremental compilation is also supported for changes made inside dependent non-Kotlin modules, and it is compatible with the <a href="https://docs.gradle.org/current/userguide/build_cache.html" id="384ecd52" data-external="true" rel="noopener noreferrer">Gradle build cache</a>. Support for compilation avoidance has also been improved.</p>
<p id="85b54cd8">We expect you'll see the most significant benefit of the new approach if you use the build cache or frequently make changes in non-Kotlin Gradle modules. Our tests for the Kotlin project on the <code class="code ">kotlin-gradle-plugin</code> module show an improvement of greater than 80% for the changes after the cache hit.</p>
<p id="5bc8f274">To try this new approach, set the following option in your <code class="code ">gradle.properties</code>:</p>
<pre class="code" data-language="none">kotlin.incremental.useClasspathSnapshot=true
</pre>
<aside data-type="note" class="prompt" data-title="" id="ccec5ae3"><p id="227ea0f8">The new approach to incremental compilation is currently available for the JVM backend in the Gradle build system only.</p></aside><p id="551fe64">Learn how the new approach to incremental compilation is implemented under the hood in <a href="https://blog.jetbrains.com/kotlin/2022/07/a-new-approach-to-incremental-compilation-in-kotlin/" id="d7a78e49" data-external="true" rel="noopener noreferrer">this blog post</a>.</p>
<p id="b07aa0fc">Our plan is to stabilize this technology and add support for other backends (JS, for instance) and build systems. We'd appreciate your reports in <a href="https://youtrack.jetbrains.com/issues/KT" id="ce3da895" data-external="true" rel="noopener noreferrer">YouTrack</a> about any issues or strange behavior you encounter in this compilation scheme. Thank you!</p>
<p id="3b77c74f">The Kotlin team is very grateful to <a href="https://github.com/gavra0" id="c16a8a60" data-external="true" rel="noopener noreferrer">Ivan Gavrilovic</a>, <a href="https://github.com/hungvietnguyen" id="a41dc278" data-external="true" rel="noopener noreferrer">Hung Nguyen</a>, <a href="https://github.com/melix" id="1a557d8f" data-external="true" rel="noopener noreferrer">Cédric Champeau</a>, and other external contributors for their help.</p></section><section class="chapter"><h3 id="build-reports-for-kotlin-compiler-tasks" data-toc="whatsnew17#build-reports-for-kotlin-compiler-tasks">Build reports for Kotlin compiler tasks</h3>
<aside data-type="warning" class="prompt" data-title="" id="4a0be2f"><p id="1e7be8ff">Kotlin build reports are <a href="components-stability" id="13896432">Experimental</a>. They may be dropped or changed at any time. Opt-in is required (see details below). Use them only for evaluation purposes. We appreciate your feedback on them in <a href="https://youtrack.jetbrains.com/issues/KT" id="de8a49fc" data-external="true" rel="noopener noreferrer">YouTrack</a>.</p></aside><p id="adc99ab7">Kotlin 1.7.0 introduces build reports that help track compiler performance. Reports contain the durations of different compilation phases and reasons why compilation couldn't be incremental.</p>
<p id="f6452d5d">Build reports come in handy when you want to investigate issues with compiler tasks, for example:</p>
<ul class="list _ul" id="866b5a26">
<li class="list__item" id="8dde754e"><p>When the Gradle build takes too much time and you want to understand the root cause of the poor performance.</p></li>
<li class="list__item" id="b3bb9680"><p>When the compilation time for the same project differs, sometimes taking seconds, sometimes taking minutes.</p></li>
</ul>
<p id="d094d411">To enable build reports, declare where to save the build report output in <code class="code ">gradle.properties</code>:</p>
<pre class="code" data-language="none">kotlin.build.report.output=file
</pre>
<p id="adb4bb54">The following values (and their combinations) are available:</p>
<ul class="list _ul" id="f448be0b">
<li class="list__item" id="9d1e1a52"><p id="1062bf97"><code class="code ">file</code> saves build reports in a local file.</p></li>
<li class="list__item" id="9c3fd6c8">
<p id="4573141a"><code class="code ">build_scan</code> saves build reports in the <code class="code ">custom values</code> section of the <a href="https://scans.gradle.com/" id="e50369c1" data-external="true" rel="noopener noreferrer">build scan</a>.</p>
<aside data-type="note" class="prompt" data-title="" id="a33cd7c3"><p id="bb34425e">The Gradle Enterprise plugin limits the number of custom values and their length. In big projects, some values could be lost.</p></aside>
</li>
<li class="list__item" id="9b0806fd"><p id="7abdb24"><code class="code ">http</code> posts build reports using HTTP(S). The POST method sends metrics in the JSON format. Data may change from version to version. You can see the current version of the sent data in the <a href="https://github.com/JetBrains/kotlin/blob/master/libraries/tools/kotlin-gradle-plugin/src/common/kotlin/org/jetbrains/kotlin/gradle/plugin/statistics/CompileStatisticsData.kt" id="65b43448" data-external="true" rel="noopener noreferrer">Kotlin repository</a>.</p></li>
</ul>
<p id="2d0ba681">There are two common cases that analyzing build reports for long-running compilations can help you resolve:</p>
<ul class="list _ul" id="8e8bb7c6">
<li class="list__item" id="ff9dec27"><p>The build wasn't incremental. Analyze the reasons and fix underlying problems.</p></li>
<li class="list__item" id="7a9550ae"><p>The build was incremental, but took too much time. Try to reorganize source files — split big files, save separate classes in different files, refactor large classes, declare top-level functions in different files, and so on.</p></li>
</ul>
<p id="835a3757">Learn more about new build reports in <a href="https://blog.jetbrains.com/kotlin/2022/06/introducing-kotlin-build-reports/" id="79675057" data-external="true" rel="noopener noreferrer">this blog post</a>.</p>
<p id="cc681082">You are welcome to try using build reports in your infrastructure. If you have any feedback, encounter any issues, or want to suggest improvements, please don't hesitate to report them in our <a href="https://youtrack.jetbrains.com/newIssue" id="332711dd" data-external="true" rel="noopener noreferrer">issue tracker</a>. Thank you!</p></section><section class="chapter"><h3 id="bumping-minimum-supported-versions" data-toc="whatsnew17#bumping-minimum-supported-versions">Bumping minimum supported versions</h3>
<p id="decdb5e4">Starting with Kotlin 1.7.0, the minimum supported Gradle version is 6.7.1. We had to <a href="https://youtrack.jetbrains.com/issue/KT-49733/Bump-minimal-supported-Gradle-version-to-6-7-1" id="20ae53d6" data-external="true" rel="noopener noreferrer">raise the version</a> to support <a href="#support-for-gradle-plugin-variants" id="f3556e8c">Gradle plugin variants</a> and the new Gradle API. In the future, we should not have to raise the minimum supported version as often, thanks to the Gradle plugin variants feature.</p>
<p id="ef69b924">Also, the minimal supported Android Gradle plugin version is now 3.6.4.</p></section><section class="chapter"><h3 id="support-for-gradle-plugin-variants" data-toc="whatsnew17#support-for-gradle-plugin-variants">Support for Gradle plugin variants</h3>
<p id="96f6f994">Gradle 7.0 introduced a new feature for Gradle plugin authors — <a href="https://docs.gradle.org/7.0/userguide/implementing_gradle_plugins.html#plugin-with-variants" id="24901d47" data-external="true" rel="noopener noreferrer">plugins with variants</a>. This feature makes it easier to add support for new Gradle features while maintaining compatibility for Gradle versions below 7.1. Learn more about <a href="https://docs.gradle.org/current/userguide/variant_model.html" id="f6ea2421" data-external="true" rel="noopener noreferrer">variant selection in Gradle</a>.</p>
<p id="c3eb35a7">With Gradle plugin variants, we can ship different Kotlin Gradle plugin variants for different Gradle versions. The goal is to support the base Kotlin compilation in the <code class="code ">main</code> variant, which corresponds to the oldest supported versions of Gradle. Each variant will have implementations for Gradle features from a corresponding release. The latest variant will support the widest Gradle feature set. With this approach, we can extend support for older Gradle versions with limited functionality.</p>
<p id="dd1aa8a3">Currently, there are only two variants of the Kotlin Gradle plugin:</p>
<ul class="list _ul" id="b581fbe7">
<li class="list__item" id="178b2472"><p><code class="code ">main</code> for Gradle versions 6.7.1–6.9.2</p></li>
<li class="list__item" id="cf1f6310"><p><code class="code ">gradle70</code> for Gradle versions 7.0 and higher</p></li>
</ul>
<p id="28f63dd1">In future Kotlin releases, we may add more.</p>
<p id="e44ee8b">To check which variant your build uses, enable the <a href="https://docs.gradle.org/current/userguide/logging.html#sec:choosing_a_log_level" id="4d984a52" data-external="true" rel="noopener noreferrer"><code class="code ">--info</code> log level</a> and find a string in the output starting with <code class="code ">Using Kotlin Gradle plugin</code>, for example, <code class="code ">Using Kotlin Gradle plugin main variant</code>.</p>
<aside data-type="note" class="prompt" data-title="" id="bfb0f80"><p id="eda66b21">Here are workarounds for some known issues with variant selection in Gradle:</p>
<ul class="list _ul" id="13dcc65a">
<li class="list__item" id="f276b7bb"><p><a href="https://github.com/gradle/gradle/issues/20545" id="528f30fa" data-external="true" rel="noopener noreferrer">ResolutionStrategy in pluginManagement is not working for plugins with multivariants</a></p></li>
<li class="list__item" id="149bebc4"><p><a href="https://github.com/gradle/gradle/issues/20847" id="cc6a4fc0" data-external="true" rel="noopener noreferrer">Plugin variants are ignored when a plugin is added as the <code class="code ">buildSrc</code> common dependency</a></p></li>
</ul></aside><p id="4db73f9a">Leave your feedback on <a href="https://youtrack.jetbrains.com/issue/KT-49227/Support-Gradle-plugins-variants" id="62f6391a" data-external="true" rel="noopener noreferrer">this YouTrack ticket</a>.</p></section><section class="chapter"><h3 id="updates-in-the-kotlin-gradle-plugin-api" data-toc="whatsnew17#updates-in-the-kotlin-gradle-plugin-api">Updates in the Kotlin Gradle plugin API</h3>
<p id="5fccf97">The Kotlin Gradle plugin API artifact has received several improvements:</p>
<ul class="list _ul" id="c3bc960b">
<li class="list__item" id="936cc329"><p id="8421222">There are new interfaces for Kotlin/JVM and Kotlin/kapt tasks with user-configurable inputs.</p></li>
<li class="list__item" id="14565607">
<p id="544cfd32">There is a new <code class="code ">KotlinBasePlugin</code> interface that all Kotlin plugins inherit from. Use this interface when you want to trigger some configuration action whenever any Kotlin Gradle plugin (JVM, JS, Multiplatform, Native, and other platforms) is applied:</p>
<pre class="code" data-language="kotlin">project.plugins.withType&lt;org.jetbrains.kotlin.gradle.plugin.KotlinBasePlugin&gt;() {
    // Configure your action here
}
</pre>
<p id="b1e74af">You can leave your feedback about the <code class="code ">KotlinBasePlugin</code> in <a href="https://youtrack.jetbrains.com/issue/KT-48008/Consider-offering-a-KotlinBasePlugin" id="c1afb05e" data-external="true" rel="noopener noreferrer">this YouTrack ticket</a>.</p>
</li>
<li class="list__item" id="689e4c2f"><p id="682bd8b5">We've laid the groundwork for the Android Gradle plugin to configure Kotlin compilation within itself, meaning you won't need to add the Kotlin Android Gradle plugin to your build. Follow <a href="https://developer.android.com/studio/releases/gradle-plugin" id="9e127d5d" data-external="true" rel="noopener noreferrer">Android Gradle Plugin release announcements</a> to learn about the added support and try it out!</p></li>
</ul></section><section class="chapter"><h3 id="the-sam-with-receiver-plugin-is-available-via-the-plugins-api" data-toc="whatsnew17#the-sam-with-receiver-plugin-is-available-via-the-plugins-api">The sam-with-receiver plugin is available via the plugins API</h3>
<p id="426f89d8">The <a href="sam-with-receiver-plugin" id="3cf8e00b">sam-with-receiver compiler plugin</a> is now available via the <a href="https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block" id="7a04f21e" data-external="true" rel="noopener noreferrer">Gradle plugins DSL</a>:</p>
<pre class="code" data-language="kotlin">plugins {
    id("org.jetbrains.kotlin.plugin.sam.with.receiver") version "$kotlin_version"
}
</pre></section><section class="chapter"><h3 id="changes-in-compile-tasks" data-toc="whatsnew17#changes-in-compile-tasks">Changes in compile tasks</h3>
<p id="aea49b90">Compile tasks have received lots of changes in this release:</p>
<ul class="list _ul" id="a9fd43d2">
<li class="list__item" id="baf33c5f"><p>Kotlin compile tasks no longer inherit the Gradle <code class="code ">AbstractCompile</code> task. They inherit only the <code class="code ">DefaultTask</code>.</p></li>
<li class="list__item" id="e9018ef3"><p>The <code class="code ">AbstractCompile</code> task has the <code class="code ">sourceCompatibility</code> and <code class="code ">targetCompatibility</code> inputs. Since the <code class="code ">AbstractCompile</code> task is no longer inherited, these inputs are no longer available in Kotlin users' scripts.</p></li>
<li class="list__item" id="f3a86ae"><p>The <code class="code ">SourceTask.stableSources</code> input is no longer available, and you should use the <code class="code ">sources</code> input. <code class="code ">setSource(...)</code> methods that are still available.</p></li>
<li class="list__item" id="f1d6591"><p>All compile tasks now use the <code class="code ">libraries</code> input for a list of libraries required for compilation. The <code class="code ">KotlinCompile</code> task still has the deprecated Kotlin property <code class="code ">classpath</code>, which will be removed in future releases.</p></li>
<li class="list__item" id="1ab8ece0"><p>Compile tasks still implement the <code class="code ">PatternFilterable</code> interface, which allows the filtering of Kotlin sources. The <code class="code ">sourceFilesExtensions</code> input was removed in favor of using <code class="code ">PatternFilterable</code> methods.</p></li>
<li class="list__item" id="814315b2"><p>The deprecated <code class="code ">Gradle destinationDir: File</code> output was replaced with the <code class="code ">destinationDirectory: DirectoryProperty</code> output.</p></li>
<li class="list__item" id="3c3fa7b1"><p>The Kotlin/Native <code class="code ">AbstractNativeCompile</code> task now inherits the <code class="code ">AbstractKotlinCompileTool</code> base class. This is an initial step toward integrating Kotlin/Native build tools into all the other tools.</p></li>
</ul>
<p id="bd031748">Please leave your feedback in <a href="https://youtrack.jetbrains.com/issue/KT-32805" id="8f372efe" data-external="true" rel="noopener noreferrer">this YouTrack ticket</a>.</p></section><section class="chapter"><h3 id="statistics-of-generated-files-by-each-annotation-processor-in-kapt" data-toc="whatsnew17#statistics-of-generated-files-by-each-annotation-processor-in-kapt">Statistics of generated files by each annotation processor in kapt</h3>
<p id="e4e94f5f">The <code class="code ">kotlin-kapt</code> Gradle plugin already <a href="https://github.com/JetBrains/kotlin/pull/4280" id="24cac422" data-external="true" rel="noopener noreferrer">reports performance statistics for each processor</a>. Starting with Kotlin 1.7.0, it can also report statistics on the number of generated files for each annotation processor.</p>
<p id="f2471a10">This is useful to track if there are unused annotation processors as a part of the build. You can use the generated report to find modules that trigger unnecessary annotation processors and update the modules to prevent that.</p>
<p id="f21c56c9">Enable the statistics in two steps:</p>
<ul class="list _ul" id="ea0e5bd2">
<li class="list__item" id="5bc1b75e">
<p id="3b42edfc">Set the <code class="code ">showProcessorStats</code> flag to <code class="code ">true</code> in your <code class="code ">build.gradle.kts</code>:</p>
<pre class="code" data-language="kotlin">kapt {
    showProcessorStats = true
}

</pre>
</li>
<li class="list__item" id="428155e">
<p id="4bd90c5">Set the <code class="code ">kapt.verbose</code> Gradle property to <code class="code ">true</code> in your <code class="code ">gradle.properties</code>:</p>
<pre class="code" data-language="none">kapt.verbose=true
</pre>
</li>
</ul>
<aside data-type="note" class="prompt" data-title="" id="b9ca2f8"><p id="8b9e3900">You can also enable verbose output via the <a href="kapt#using-in-cli" id="ce50b296">command line option <code class="code ">verbose</code></a>.</p></aside><p id="1e212f0e">The statistics will appear in the logs with the <code class="code ">info</code> level. You'll see the <code class="code ">Annotation processor stats:</code> line followed by statistics on the execution time of each annotation processor. After these lines, there will be the <code class="code ">Generated files report:</code> line followed by statistics on the number of generated files for each annotation processor. For example:</p>
<pre class="code" data-language="plaintext">[INFO] Annotation processor stats:
[INFO] org.mapstruct.ap.MappingProcessor: total: 290 ms, init: 1 ms, 3 round(s): 289 ms, 0 ms, 0 ms
[INFO] Generated files report:
[INFO] org.mapstruct.ap.MappingProcessor: total sources: 2, sources per round: 2, 0, 0
</pre>
<p id="d2a38ef6">Please leave your feedback in <a href="https://youtrack.jetbrains.com/issue/KT-51132/KAPT-Support-reporting-the-number-of-generated-files-by-each-ann" id="c7429b10" data-external="true" rel="noopener noreferrer">this YouTrack ticket</a>.</p></section><section class="chapter"><h3 id="deprecation-of-the-kotlin-compiler-execution-strategy-system-property" data-toc="whatsnew17#deprecation-of-the-kotlin-compiler-execution-strategy-system-property">Deprecation of the kotlin.compiler.execution.strategy system property</h3>
<p id="18e9bfa5">Kotlin 1.6.20 introduced <a href="whatsnew1620#properties-for-defining-kotlin-compiler-execution-strategy" id="780e0b88">new properties for defining a Kotlin compiler execution strategy</a>. In Kotlin 1.7.0, a deprecation cycle has started for the old system property <code class="code ">kotlin.compiler.execution.strategy</code> in favor of the new properties.</p>
<p id="16f8f5fd">When using the <code class="code ">kotlin.compiler.execution.strategy</code> system property, you'll receive a warning. This property will be deleted in future releases. To preserve the old behavior, replace the system property with the Gradle property of the same name. You can do this in <code class="code ">gradle.properties</code>, for example:</p>
<pre class="code" data-language="none">kotlin.compiler.execution.strategy=out-of-process
</pre>
<p id="686c5204">You can also use the compile task property <code class="code ">compilerExecutionStrategy</code>. Learn more about this on the <a href="gradle#defining-kotlin-compiler-execution-strategy" id="188f3130">Gradle page</a>.</p></section><section class="chapter"><h3 id="removal-of-deprecated-options-methods-and-plugins" data-toc="whatsnew17#removal-of-deprecated-options-methods-and-plugins">Removal of deprecated options, methods, and plugins</h3>
<section class="chapter"><h4 id="removal-of-the-useexperimentalannotation-method" data-toc="whatsnew17#removal-of-the-useexperimentalannotation-method">Removal of the useExperimentalAnnotation method</h4>
<p id="c85ea241">In Kotlin 1.7.0, we completed the deprecation cycle for the <code class="code ">useExperimentalAnnotation</code> Gradle method. Use <code class="code ">optIn()</code> instead to opt in to using an API in a module.</p>
<p id="cc9c6400">For example, if your Gradle module is multiplatform:</p>
<pre class="code" data-language="kotlin">sourceSets {
    all {
        languageSettings.optIn("org.mylibrary.OptInAnnotation")
    }
}
</pre>
<p id="41ab2fba">Learn more about <a href="opt-in-requirements" id="35146681">opt-in requirements</a> in Kotlin.</p></section><section class="chapter"><h4 id="removal-of-deprecated-compiler-options" data-toc="whatsnew17#removal-of-deprecated-compiler-options">Removal of deprecated compiler options</h4>
<p id="86fcb67a">We've completed the deprecation cycle for several compiler options:</p>
<ul class="list _ul" id="645abedf">
<li class="list__item" id="944f47e6"><p>The <code class="code ">kotlinOptions.jdkHome</code> compiler option was deprecated in 1.5.30 and has been removed in the current release. Gradle builds now fail if they contain this option. We encourage you to use <a href="whatsnew1530#support-for-java-toolchains" id="892648c5">Java toolchains</a>, which have been supported since Kotlin 1.5.30.</p></li>
<li class="list__item" id="62024f58"><p>The deprecated 'noStdlib' compiler option has also been removed. The Gradle plugin uses the <code class="code ">kotlin.stdlib.default.dependency=true</code> property to control whether the Kotlin standard library is present.</p></li>
</ul>
<aside data-type="note" class="prompt" data-title="" id="6ef75b20"><p id="5b93d18b">The compiler arguments <code class="code ">-jdkHome</code> and <code class="code ">-no-stdlib</code> are still available.</p></aside></section><section class="chapter"><h4 id="removal-of-deprecated-plugins" data-toc="whatsnew17#removal-of-deprecated-plugins">Removal of deprecated plugins</h4>
<p id="f1ab42dd">In Kotlin 1.4.0, the <code class="code ">kotlin2js</code> and <code class="code ">kotlin-dce-plugin</code> plugins were deprecated, and they have been removed in this release. Instead of <code class="code ">kotlin2js</code>, use the new <code class="code ">org.jetbrains.kotlin.js</code> plugin. Dead code elimination (DCE) works when the Kotlin/JS Gradle plugin is <a href="javascript-dce" id="bcf9abf">properly configured</a>.</p>
<p id="e9d4a3fd">In Kotlin 1.6.0, we changed the deprecation level of the <code class="code ">KotlinGradleSubplugin</code> class to 'ERROR'. Developers used this class for writing compiler plugins. In this release, <a href="https://youtrack.jetbrains.com/issue/KT-48831/" id="f9448e0d" data-external="true" rel="noopener noreferrer">this class has been removed</a>. Use the <code class="code ">KotlinCompilerPluginSupportPlugin</code> class instead.</p>
<aside data-type="tip" class="prompt" data-title="" id="bb4236a2"><p id="e5cb00f9">The best practice is to use Kotlin plugins with versions 1.7.0 and higher throughout your project.</p></aside></section><section class="chapter"><h4 id="removal-of-the-deprecated-coroutines-dsl-option-and-property" data-toc="whatsnew17#removal-of-the-deprecated-coroutines-dsl-option-and-property">Removal of the deprecated coroutines DSL option and property</h4>
<p id="4974df64">We removed the deprecated <code class="code ">kotlin.experimental.coroutines</code> Gradle DSL option and the <code class="code ">kotlin.coroutines</code> property used in <code class="code ">gradle.properties</code>. Now you can just use <em id="c3d81693" class=""><a href="coroutines-basics#extract-function-refactoring" id="b89ad100">suspending functions</a></em> or <a href="gradle#set-a-dependency-on-a-kotlinx-library" id="639af42b">add the <code class="code ">kotlinx.coroutines</code> dependency</a> to your build script.</p>
<p id="a4c26bd7">Learn more about coroutines in the <a href="coroutines-guide" id="451e42fc">Coroutines guide</a>.</p></section><section class="chapter"><h4 id="removal-of-the-type-cast-in-the-toolchain-extension-method" data-toc="whatsnew17#removal-of-the-type-cast-in-the-toolchain-extension-method">Removal of the type cast in the toolchain extension method</h4>
<p id="ec3eaee5">Before Kotlin 1.7.0, you had to do the type cast into the <code class="code ">JavaToolchainSpec</code> class when configuring the Gradle toolchain with Kotlin DSL:</p>
<pre class="code" data-language="kotlin">kotlin {
    jvmToolchain {
        (this as JavaToolchainSpec).languageVersion.set(JavaLanguageVersion.of(&lt;MAJOR_JDK_VERSION&gt;)
    }
}
</pre>
<p id="79c9a20a">Now, you can omit the <code class="code ">(this as JavaToolchainSpec)</code> part:</p>
<pre class="code" data-language="kotlin">kotlin {
    jvmToolchain {
        languageVersion.set(JavaLanguageVersion.of(&lt;MAJOR_JDK_VERSION&gt;)
    }
}
</pre></section></section></section><section class="chapter"><h2 id="migrating-to-kotlin-1-7-0" data-toc="whatsnew17#migrating-to-kotlin-1-7-0">Migrating to Kotlin 1.7.0</h2>
<section class="chapter"><h3 id="install-kotlin-1-7-0" data-toc="whatsnew17#install-kotlin-1-7-0">Install Kotlin 1.7.0</h3>
<p id="2c0584bb">IntelliJ IDEA 2022.1 and Android Studio Chipmunk (212) automatically suggest updating the Kotlin plugin to 1.7.0.</p>
<aside data-type="note" class="prompt" data-title="" id="b8c8f43f"><p id="d8445907">For IntelliJ IDEA 2022.2, and Android Studio Dolphin (213) or Android Studio Electric Eel (221), the Kotlin plugin 1.7.0 will be delivered with upcoming IntelliJ IDEA and Android Studios updates.</p></aside><p id="99827aa7">The new command-line compiler is available for download on the <a href="https://github.com/JetBrains/kotlin/releases/tag/v1.7.0" id="4122256" data-external="true" rel="noopener noreferrer">GitHub release page</a>.</p></section><section class="chapter"><h3 id="migrate-existing-or-start-a-new-project-with-kotlin-1-7-0" data-toc="whatsnew17#migrate-existing-or-start-a-new-project-with-kotlin-1-7-0">Migrate existing or start a new project with Kotlin 1.7.0</h3>
<ul class="list _ul" id="c4853fc6">
<li class="list__item" id="5d6976e7"><p id="5336a5e9">To migrate existing projects to Kotlin 1.7.0, change the Kotlin version to <code class="code ">1.7.0</code> and reimport your Gradle or Maven project. <a href="releases#update-to-a-new-release" id="f93c2d16">Learn how to update to Kotlin 1.7.0</a>.</p></li>
<li class="list__item" id="855d3819"><p id="3acc44ed">To start a new project with Kotlin 1.7.0, update the Kotlin plugin and run the Project Wizard from <b id="8c9fba14" class="">File</b> | <b id="72331867" class="">New</b> | <b id="bc4bbc06" class="">Project</b>.</p></li>
</ul></section><section class="chapter"><h3 id="compatibility-guide-for-kotlin-1-7-0" data-toc="whatsnew17#compatibility-guide-for-kotlin-1-7-0">Compatibility guide for Kotlin 1.7.0</h3>
<p id="934bca8f">Kotlin 1.7.0 is a <a href="kotlin-evolution#feature-releases-and-incremental-releases" id="3028879f">feature release</a> and can, therefore, bring changes that are incompatible with your code written for earlier versions of the language. Find the detailed list of such changes in the <a href="compatibility-guide-17" id="61854661">Compatibility guide for Kotlin 1.7.0</a>.</p></section></section><div class="last-modified"> Last modified: 08 August 2022</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="competitive-programming">Kotlin for competitive programming</a> <a class="navigation-links__next" href="whatsnew1620">What's new in Kotlin 1.6.20</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/whatsnew17.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/whatsnew17.html</a>
  </p>
</div>
