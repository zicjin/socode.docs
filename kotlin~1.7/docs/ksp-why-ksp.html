<h1 data-toc="ksp-why-ksp" id="ksp-why-ksp.md">Why KSP</h1>
<p id="b6a35cdc">Compiler plugins are powerful metaprogramming tools that can greatly enhance how you write code. Compiler plugins call compilers directly as libraries to analyze and edit input programs. These plugins can also generate output for various uses. For example, they can generate boilerplate code, and they can even generate full implementations for specially-marked program elements, such as <code class="code ">Parcelable</code>. Plugins have a variety of other uses and can even be used to implement and fine-tune features that are not provided directly in a language.</p>
<p id="2cea5dad">While compiler plugins are powerful, this power comes at a price. To write even the simplest plugin, you need to have some compiler background knowledge, as well as a certain level of familiarity with the implementation details of your specific compiler. Another practical issue is that plugins are often closely tied to specific compiler versions, meaning you might need to update your plugin each time you want to support a newer version of the compiler.</p>
<section class="chapter"><h2 id="ksp-makes-creating-lightweight-compiler-plugins-easier" data-toc="ksp-why-ksp#ksp-makes-creating-lightweight-compiler-plugins-easier">KSP makes creating lightweight compiler plugins easier</h2>
<p id="51da6615">KSP is designed to hide compiler changes, minimizing maintenance efforts for processors that use it. KSP is designed not to be tied to the JVM so that it can be adapted to other platforms more easily in the future. KSP is also designed to minimize build times. For some processors, such as <a href="https://github.com/bumptech/glide" id="b2dff594" data-external="true" rel="noopener noreferrer">Glide</a>, KSP reduces full compilation times by up to 25% when compared to kapt.</p>
<p id="a2c4f3f5">KSP is itself implemented as a compiler plugin. There are prebuilt packages on Google's Maven repository that you can download and use without having to build the project yourself.</p></section><section class="chapter"><h2 id="comparison-to-kotlinc-compiler-plugins" data-toc="ksp-why-ksp#comparison-to-kotlinc-compiler-plugins">Comparison to kotlinc compiler plugins</h2>
<p id="5dc94ec7"><code class="code ">kotlinc</code> compiler plugins have access to almost everything from the compiler and therefore have maximum power and flexibility. On the other hand, because these plugins can potentially depend on anything in the compiler, they are sensitive to compiler changes and need to be maintained frequently. These plugins also require a deep understanding of <code class="code ">kotlinc</code>’s implementation, so the learning curve can be steep.</p>
<p id="5ff68520">KSP aims to hide most compiler changes through a well-defined API, though major changes in compiler or even the Kotlin language might still require to be exposed to API users.</p>
<p id="498d7554">KSP tries to fulfill common use cases by providing an API that trades power for simplicity. Its capability is a strict subset of a general <code class="code ">kotlinc</code> plugin. For example, while <code class="code ">kotlinc</code> can examine expressions and statements and can even modify code, KSP cannot.</p>
<p id="e24510e1">While writing a <code class="code ">kotlinc</code> plugin can be a lot of fun, it can also take a lot of time. If you aren't in a position to learn <code class="code ">kotlinc</code>’s implementation and do not need to modify source code or read expressions, KSP might be a good fit.</p></section><section class="chapter"><h2 id="comparison-to-reflection" data-toc="ksp-why-ksp#comparison-to-reflection">Comparison to reflection</h2>
<p id="8d0115bc">KSP's API looks similar to <code class="code ">kotlin.reflect</code>. The major difference between them is that type references in KSP need to be resolved explicitly. This is one of the reasons why the interfaces are not shared.</p></section><section class="chapter"><h2 id="comparison-to-kapt" data-toc="ksp-why-ksp#comparison-to-kapt">Comparison to kapt</h2>
<p id="bdfa0eb6"><a href="kapt" id="7e9b3bf2">kapt</a> is a remarkable solution which makes a large amount of Java annotation processors work for Kotlin programs out-of-box. The major advantages of KSP over kapt are improved build performance, not tied to JVM, a more idiomatic Kotlin API, and the ability to understand Kotlin-only symbols.</p>
<p id="9cc7d194">To run Java annotation processors unmodified, kapt compiles Kotlin code into Java stubs that retain information that Java annotation processors care about. To create these stubs, kapt needs to resolve all symbols in the Kotlin program. The stub generation costs roughly 1/3 of a full <code class="code ">kotlinc</code> analysis and the same order of <code class="code ">kotlinc</code> code-generation. For many annotation processors, this is much longer than the time spent in the processors themselves. For example, Glide looks at a very limited number of classes with a predefined annotation, and its code generation is fairly quick. Almost all of the build overhead resides in the stub generation phase. Switching to KSP would immediately reduce the time spent in the compiler by 25%.</p>
<p id="a210bb43">For performance evaluation, we implemented a <a href="https://github.com/google/ksp/releases/download/1.4.10-dev-experimental-20200924/miniGlide.zip" id="eaec5ba3" data-external="true" rel="noopener noreferrer">simplified version</a> of <a href="https://github.com/bumptech/glide" id="8ab8eed" data-external="true" rel="noopener noreferrer">Glide</a> in KSP to make it generate code for the <a href="https://github.com/inorichi/tachiyomi" id="7712e2b1" data-external="true" rel="noopener noreferrer">Tachiyomi</a> project. While the total Kotlin compilation time of the project is 21.55 seconds on our test device, it took 8.67 seconds for kapt to generate the code, and it took 1.15 seconds for our KSP implementation to generate the code.</p>
<p id="ad1917db">Unlike kapt, processors in KSP do not see input programs from Java's point of view. The API is more natural to Kotlin, especially for Kotlin-specific features such as top-level functions. Because KSP doesn't delegate to <code class="code ">javac</code> like kapt, it doesn't assume JVM-specific behaviors and can be used with other platforms potentially.</p></section><section class="chapter"><h2 id="limitations" data-toc="ksp-why-ksp#limitations">Limitations</h2>
<p id="32c4ef64">While KSP tries to be a simple solution for most common use cases, it has made several trade-offs compared to other plugin solutions. The following are not goals of KSP:</p>
<ul class="list _ul" id="466f6727">
<li class="list__item" id="f20f427"><p>Examining expression-level information of source code.</p></li>
<li class="list__item" id="5cca16f8"><p>Modifying source code.</p></li>
<li class="list__item" id="9773ab27"><p>100% compatibility with the Java Annotation Processing API.</p></li>
</ul>
<p id="67fc7e68">We are also exploring several additional features. These features are currently unavailable:</p>
<ul class="list _ul" id="10fbf1ba"><li class="list__item" id="272503f1"><p>IDE integration: Currently IDEs know nothing about the generated code.</p></li></ul></section><div class="last-modified"> Last modified: 08 August 2022</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="ksp-quickstart">KSP quickstart</a> <a class="navigation-links__next" href="ksp-examples">KSP examples</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/ksp-why-ksp.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/ksp-why-ksp.html</a>
  </p>
</div>
