<h1 data-toc="collection-aggregate" id="collection-aggregate.md">Aggregate operations</h1>
<p id="41119a1f">Kotlin collections contain functions for commonly used <em id="da51548a" class="">aggregate operations</em> – operations that return a single value based on the collection content. Most of them are well known and work the same way as they do in other languages:</p>
<ul class="list _ul" id="69ccaea">
<li class="list__item" id="955c5de0"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/min-or-null" id="504221c8" data-external="true" rel="noopener noreferrer"><code class="code ">minOrNull()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/max-or-null" id="f460e243" data-external="true" rel="noopener noreferrer"><code class="code ">maxOrNull()</code></a> return the smallest and the largest element respectively. On empty collections, they return <code class="code ">null</code>.</p></li>
<li class="list__item" id="e9503b59"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/average" id="f980d1c4" data-external="true" rel="noopener noreferrer"><code class="code ">average()</code></a> returns the average value of elements in the collection of numbers.</p></li>
<li class="list__item" id="4dae50b4"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/sum" id="25f84375" data-external="true" rel="noopener noreferrer"><code class="code ">sum()</code></a> returns the sum of elements in the collection of numbers.</p></li>
<li class="list__item" id="326866c1"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/count" id="ed779ac6" data-external="true" rel="noopener noreferrer"><code class="code ">count()</code></a> returns the number of elements in a collection.</p></li>
</ul>
<pre class="code" data-language="kotlin">
fun main() {
    val numbers = listOf(6, 42, 10, 4)

    println("Count: ${numbers.count()}")
    println("Max: ${numbers.maxOrNull()}")
    println("Min: ${numbers.minOrNull()}")
    println("Average: ${numbers.average()}")
    println("Sum: ${numbers.sum()}")
}
</pre>
<p id="e0272185">There are also functions for retrieving the smallest and the largest elements by certain selector function or custom <a href="../api/latest/jvm/stdlib/kotlin/-comparator/index" id="436a67ef" data-external="true" rel="noopener noreferrer"><code class="code ">Comparator</code></a>:</p>
<ul class="list _ul" id="52a3d589">
<li class="list__item" id="434c7449"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/max-by-or-null" id="77aa348f" data-external="true" rel="noopener noreferrer"><code class="code ">maxByOrNull()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/min-by-or-null" id="6e08287d" data-external="true" rel="noopener noreferrer"><code class="code ">minByOrNull()</code></a> take a selector function and return the element for which it returns the largest or the smallest value.</p></li>
<li class="list__item" id="476cd1e2"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/max-with-or-null" id="9230abad" data-external="true" rel="noopener noreferrer"><code class="code ">maxWithOrNull()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/min-with-or-null" id="ab8dd172" data-external="true" rel="noopener noreferrer"><code class="code ">minWithOrNull()</code></a> take a <code class="code ">Comparator</code> object and return the largest or smallest element according to that <code class="code ">Comparator</code>.</p></li>
<li class="list__item" id="e6dddd42"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/max-of-or-null" id="2be55ee9" data-external="true" rel="noopener noreferrer"><code class="code ">maxOfOrNull()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/min-of-or-null" id="d7598259" data-external="true" rel="noopener noreferrer"><code class="code ">minOfOrNull()</code></a> take a selector function and return the largest or the smallest return value of the selector itself.</p></li>
<li class="list__item" id="9d09b6de"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/max-of-with-or-null" id="f52558a" data-external="true" rel="noopener noreferrer"><code class="code ">maxOfWithOrNull()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/min-of-with-or-null" id="a2cd3a08" data-external="true" rel="noopener noreferrer"><code class="code ">minOfWithOrNull()</code></a> take a <code class="code ">Comparator</code> object and return the largest or smallest selector return value according to that <code class="code ">Comparator</code>.</p></li>
</ul>
<p id="e1e53ac0">These functions return <code class="code ">null</code> on empty collections. There are also alternatives – <a href="../api/latest/jvm/stdlib/kotlin.collections/max-of" id="d8f07c0" data-external="true" rel="noopener noreferrer"><code class="code ">maxOf</code></a>, <a href="../api/latest/jvm/stdlib/kotlin.collections/min-of" id="9ed44ea4" data-external="true" rel="noopener noreferrer"><code class="code ">minOf</code></a>, <a href="../api/latest/jvm/stdlib/kotlin.collections/max-of-with" id="524c3991" data-external="true" rel="noopener noreferrer"><code class="code ">maxOfWith</code></a>, and <a href="../api/latest/jvm/stdlib/kotlin.collections/min-of-with" id="7095e7e2" data-external="true" rel="noopener noreferrer"><code class="code ">minOfWith</code></a> – which do the same as their counterparts but throw a <code class="code ">NoSuchElementException</code> on empty collections.</p>
<pre class="code" data-language="kotlin">
fun main() {
//sampleStart
    val numbers = listOf(5, 42, 10, 4)
    val min3Remainder = numbers.minByOrNull { it % 3 }
    println(min3Remainder)

    val strings = listOf("one", "two", "three", "four")
    val longestString = strings.maxWithOrNull(compareBy { it.length })
    println(longestString)
//sampleEnd
}
</pre>
<p id="879f7d54">Besides regular <code class="code ">sum()</code>, there is an advanced summation function <a href="../api/latest/jvm/stdlib/kotlin.collections/sum-of" id="f841b0bb" data-external="true" rel="noopener noreferrer"><code class="code ">sumOf()</code></a> that takes a selector function and returns the sum of its application to all collection elements. Selector can return different numeric types: <code class="code ">Int</code>, <code class="code ">Long</code>, <code class="code ">Double</code>, <code class="code ">UInt</code>, and <code class="code ">ULong</code> (also <code class="code ">BigInteger</code> and <code class="code ">BigDecimal</code> on the JVM).</p>
<pre class="code" data-language="kotlin">
fun main() {
//sampleStart
    val numbers = listOf(5, 42, 10, 4)
    println(numbers.sumOf { it * 2 })
    println(numbers.sumOf { it.toDouble() / 2 })
//sampleEnd
}
</pre>
<section class="chapter"><h2 id="fold-and-reduce" data-toc="collection-aggregate#fold-and-reduce">Fold and reduce</h2>
<p id="2a4d3716">For more specific cases, there are the functions <a href="../api/latest/jvm/stdlib/kotlin.collections/reduce" id="901d675d" data-external="true" rel="noopener noreferrer"><code class="code ">reduce()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/fold" id="dd77b641" data-external="true" rel="noopener noreferrer"><code class="code ">fold()</code></a> that apply the provided operation to the collection elements sequentially and return the accumulated result. The operation takes two arguments: the previously accumulated value and the collection element.</p>
<p id="6bc44d2">The difference between the two functions is that <code class="code ">fold()</code> takes an initial value and uses it as the accumulated value on the first step, whereas the first step of <code class="code ">reduce()</code> uses the first and the second elements as operation arguments on the first step.</p>
<pre class="code" data-language="kotlin">fun main() {
//sampleStart
    val numbers = listOf(5, 2, 10, 4)

    val simpleSum = numbers.reduce { sum, element -&gt; sum + element }
    println(simpleSum)
    val sumDoubled = numbers.fold(0) { sum, element -&gt; sum + element * 2 }
    println(sumDoubled)

    //incorrect: the first element isn't doubled in the result
    //val sumDoubledReduce = numbers.reduce { sum, element -&gt; sum + element * 2 } 
    //println(sumDoubledReduce)
//sampleEnd
}
</pre>
<p id="509ddc8d">The example above shows the difference: <code class="code ">fold()</code> is used for calculating the sum of doubled elements. If you pass the same function to <code class="code ">reduce()</code>, it will return another result because it uses the list's first and second elements as arguments on the first step, so the first element won't be doubled.</p>
<p id="ed77c4ff">To apply a function to elements in the reverse order, use functions <a href="../api/latest/jvm/stdlib/kotlin.collections/reduce-right" id="cf3d5b64" data-external="true" rel="noopener noreferrer"><code class="code ">reduceRight()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/fold-right" id="d3b25260" data-external="true" rel="noopener noreferrer"><code class="code ">foldRight()</code></a>. They work in a way similar to <code class="code ">fold()</code> and <code class="code ">reduce()</code> but start from the last element and then continue to previous. Note that when folding or reducing right, the operation arguments change their order: first goes the element, and then the accumulated value.</p>
<pre class="code" data-language="kotlin">
fun main() {
//sampleStart
    val numbers = listOf(5, 2, 10, 4)
    val sumDoubledRight = numbers.foldRight(0) { element, sum -&gt; sum + element * 2 }
    println(sumDoubledRight)
//sampleEnd
}
</pre>
<p id="a9783b96">You can also apply operations that take element indices as parameters. For this purpose, use functions <a href="../api/latest/jvm/stdlib/kotlin.collections/reduce-indexed" id="d931a156" data-external="true" rel="noopener noreferrer"><code class="code ">reduceIndexed()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/fold-indexed" id="5312f4" data-external="true" rel="noopener noreferrer"><code class="code ">foldIndexed()</code></a> passing element index as the first argument of the operation.</p>
<p id="8f7995b0">Finally, there are functions that apply such operations to collection elements from right to left - <a href="../api/latest/jvm/stdlib/kotlin.collections/reduce-right-indexed" id="d26d4ba0" data-external="true" rel="noopener noreferrer"><code class="code ">reduceRightIndexed()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/fold-right-indexed" id="4fa51fbe" data-external="true" rel="noopener noreferrer"><code class="code ">foldRightIndexed()</code></a>.</p>
<pre class="code" data-language="kotlin">
fun main() {
//sampleStart
    val numbers = listOf(5, 2, 10, 4)
    val sumEven = numbers.foldIndexed(0) { idx, sum, element -&gt; if (idx % 2 == 0) sum + element else sum }
    println(sumEven)

    val sumEvenRight = numbers.foldRightIndexed(0) { idx, element, sum -&gt; if (idx % 2 == 0) sum + element else sum }
    println(sumEvenRight)
//sampleEnd
}
</pre>
<p id="4ca14127">All reduce operations throw an exception on empty collections. To receive <code class="code ">null</code> instead, use their <code class="code ">*OrNull()</code> counterparts:</p>
<ul class="list _ul" id="33ecdcc8">
<li class="list__item" id="52c709a4"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/reduce-or-null" id="8750a418" data-external="true" rel="noopener noreferrer"><code class="code ">reduceOrNull()</code></a></p></li>
<li class="list__item" id="d226cd58"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/reduce-right-or-null" id="70a260d6" data-external="true" rel="noopener noreferrer"><code class="code ">reduceRightOrNull()</code></a></p></li>
<li class="list__item" id="fe91b692"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/reduce-indexed-or-null" id="bb66e219" data-external="true" rel="noopener noreferrer"><code class="code ">reduceIndexedOrNull()</code></a></p></li>
<li class="list__item" id="b10a9b75"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/reduce-right-indexed-or-null" id="1f9de842" data-external="true" rel="noopener noreferrer"><code class="code ">reduceRightIndexedOrNull()</code></a></p></li>
</ul>
<p id="b1ea7250">For cases where you want to save intermediate accumulator values, there are functions <a href="../api/latest/jvm/stdlib/kotlin.collections/running-fold" id="5fc93052" data-external="true" rel="noopener noreferrer"><code class="code ">runningFold()</code></a> (or its synonym <a href="../api/latest/jvm/stdlib/kotlin.collections/scan" id="24a8f741" data-external="true" rel="noopener noreferrer"><code class="code ">scan()</code></a>) and <a href="../api/latest/jvm/stdlib/kotlin.collections/running-reduce" id="ee563532" data-external="true" rel="noopener noreferrer"><code class="code ">runningReduce()</code></a>.</p>
<pre class="code" data-language="kotlin">
fun main() {
//sampleStart
    val numbers = listOf(0, 1, 2, 3, 4, 5)
    val runningReduceSum = numbers.runningReduce { sum, item -&gt; sum + item }
    val runningFoldSum = numbers.runningFold(10) { sum, item -&gt; sum + item }
//sampleEnd
    val transform = { index: Int, element: Int -&gt; "N = ${index + 1}: $element" }
    println(runningReduceSum.mapIndexed(transform).joinToString("\n", "Sum of first N elements with runningReduce:\n"))
    println(runningFoldSum.mapIndexed(transform).joinToString("\n", "Sum of first N elements with runningFold:\n"))
}
</pre>
<p id="694e2dd0">If you need an index in the operation parameter, use <a href="../api/latest/jvm/stdlib/kotlin.collections/running-fold-indexed" id="a4f94fc5" data-external="true" rel="noopener noreferrer"><code class="code ">runningFoldIndexed()</code></a> or <a href="../api/latest/jvm/stdlib/kotlin.collections/running-reduce-indexed" id="6c70d1f0" data-external="true" rel="noopener noreferrer"><code class="code ">runningReduceIndexed()</code></a>.</p></section><div class="last-modified"> Last modified: 08 August 2022</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="collection-ordering">Ordering</a> <a class="navigation-links__next" href="collection-write">Collection write operations</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/collection-aggregate.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/collection-aggregate.html</a>
  </p>
</div>
