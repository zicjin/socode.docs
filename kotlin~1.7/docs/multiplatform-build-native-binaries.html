<h1 data-toc="multiplatform-build-native-binaries" id="multiplatform-build-native-binaries.md">Build final native binaries</h1>
<p id="dab7dbe8">By default, a Kotlin/Native target is compiled down to a <code class="code ">*.klib</code> library artifact, which can be consumed by Kotlin/Native itself as a dependency but cannot be executed or used as a native library.</p>
<p id="933d9ecf">To declare final native binaries such as executables or shared libraries, use the <code class="code ">binaries</code> property of a native target. This property represents a collection of native binaries built for this target in addition to the default <code class="code ">*.klib</code> artifact and provides a set of methods for declaring and configuring them.</p>
<aside data-type="note" class="prompt" data-title="" id="79447e0d"><p id="7802cc53">The <code class="code ">kotlin-multiplatform</code> plugin doesn't create any production binaries by default. The only binary available by default is a debug test executable that lets you run unit tests from the <code class="code ">test</code> compilation.</p></aside><section class="chapter"><h2 id="declare-binaries" data-toc="multiplatform-build-native-binaries#declare-binaries">Declare binaries</h2>
<p id="86bbef8">Use the following factory methods to declare elements of the <code class="code ">binaries</code> collection.</p>
<div class="table-wrapper"><table class=" wide" id="a59749d0">
<thead><tr class="ijRowHead" id="448ebc2b">
<th id="3e8fbd37"><p>Factory method</p></th>
<th id="78550eab"><p>Binary kind</p></th>
<th id="54e83062"><p>Available for</p></th>
</tr></thead>
<tbody>
<tr class="" id="e82337ac">
<td id="d8d6e2db"><p><code class="code ">executable</code></p></td>
<td id="1b8c5fc5"><p>Product executable</p></td>
<td id="55df49d8"><p>All native targets</p></td>
</tr>
<tr class="" id="e808c2c0">
<td id="48360900"><p><code class="code ">test</code></p></td>
<td id="51f50024"><p>Test executable</p></td>
<td id="d05e2c79"><p>All native targets</p></td>
</tr>
<tr class="" id="b681d3dc">
<td id="56c443db"><p><code class="code ">sharedLib</code></p></td>
<td id="c6c59396"><p>Shared native library</p></td>
<td id="7bf44998"><p>All native targets, except for <code class="code ">WebAssembly</code></p></td>
</tr>
<tr class="" id="e0d5977c">
<td id="fadcdf0"><p><code class="code ">staticLib</code></p></td>
<td id="8ec083a6"><p>Static native library</p></td>
<td id="1eb023ae"><p>All native targets, except for <code class="code ">WebAssembly</code></p></td>
</tr>
<tr class="" id="81380180">
<td id="ef123c19"><p><code class="code ">framework</code></p></td>
<td id="7f61c206"><p>Objective-C framework</p></td>
<td id="a921a6de"><p>macOS, iOS, watchOS, and tvOS targets only</p></td>
</tr>
</tbody>
</table></div>
<p id="1a1afd74">The simplest version doesn't require any additional parameters and creates one binary for each build type. Currently, two build types are available:</p>
<ul class="list _ul" id="6b4adb96">
<li class="list__item" id="aaa2c744"><p><code class="code ">DEBUG</code> – produces a non-optimized binary with debug information</p></li>
<li class="list__item" id="2a7ced6f"><p><code class="code ">RELEASE</code> – produces an optimized binary without debug information</p></li>
</ul>
<p id="fecef977">The following snippet creates two executable binaries, debug and release:</p>
<pre class="code" data-language="kotlin">kotlin {
    linuxX64 { // Define your target instead.
        binaries {
            executable {
                // Binary configuration.
            }
        }
    }
}
</pre>
<p id="8106fcf4">You can drop the lambda if there is no need for <a href="multiplatform-dsl-reference#native-targets" id="a80ac729">additional configuration</a>:</p>
<pre class="code" data-language="kotlin">binaries {
    executable()
}
</pre>
<p id="f925203">You can specify for which build types to create binaries. In the following example, only the <code class="code ">debug</code> executable is created:</p>
<div class="tabs" id="e63e820e" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="379178d8" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code" data-language="kotlin">binaries {
    executable(listOf(DEBUG)) {
        // Binary configuration.
    }
}
</pre></div>
<div class="tabs__content" data-gtm="tab" id="ed451e4b" data-sync-tabs="groovy" data-title="Groovy"><pre class="code" data-language="groovy">binaries {
    executable([DEBUG]) {
        // Binary configuration.
    }
}
</pre></div>
</div>
<p id="e08f308c">You can also declare binaries with custom names:</p>
<div class="tabs" id="673d527e" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="11dae44b" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code" data-language="kotlin">binaries {
    executable("foo", listOf(DEBUG)) {
        // Binary configuration.
    }

    // It's possible to drop the list of build types
    // (in this case, all the available build types will be used).
    executable("bar") {
        // Binary configuration.
    }
}
</pre></div>
<div class="tabs__content" data-gtm="tab" id="861305f" data-sync-tabs="groovy" data-title="Groovy"><pre class="code" data-language="groovy">binaries {
    executable('foo', [DEBUG]) {
        // Binary configuration.
    }

    // It's possible to drop the list of build types
    // (in this case, all the available build types will be used).
    executable('bar') {
        // Binary configuration.
    }
}
</pre></div>
</div>
<p id="2b3f0d29">The first argument sets a name prefix, which is the default name for the binary file. For example, for Windows the code produces the files <code class="code ">foo.exe</code> and <code class="code ">bar.exe</code>. You can also use the name prefix to <a href="#access-binaries" id="f44bfa43">access the binary in the build script</a>.</p></section><section class="chapter"><h2 id="access-binaries" data-toc="multiplatform-build-native-binaries#access-binaries">Access binaries</h2>
<p id="c0e82174">You can access binaries to <a href="multiplatform-dsl-reference#native-targets" id="cba4de3e">configure them</a> or get their properties (for example, the path to an output file).</p>
<p id="fb8baf1f">You can get a binary by its unique name. This name is based on the name prefix (if it is specified), build type, and binary kind following the pattern: <code class="code ">&lt;optional-name-prefix&gt;&lt;build-type&gt;&lt;binary-kind&gt;</code>, for example, <code class="code ">releaseFramework</code> or <code class="code ">testDebugExecutable</code>.</p>
<aside data-type="note" class="prompt" data-title="" id="dfa8e2bf"><p id="a314d956">Static and shared libraries have the suffixes static and shared respectively, for example, <code class="code ">fooDebugStatic</code> or <code class="code ">barReleaseShared</code>.</p></aside><div class="tabs" id="3434e994" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="788cf92a" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code" data-language="kotlin">// Fails if there is no such binary.
binaries["fooDebugExecutable"]
binaries.getByName("fooDebugExecutable")

// Returns null if there is no such binary.
binaries.findByName("fooDebugExecutable")
</pre></div>
<div class="tabs__content" data-gtm="tab" id="c4c2f8cf" data-sync-tabs="groovy" data-title="Groovy"><pre class="code" data-language="groovy">// Fails if there is no such binary.
binaries['fooDebugExecutable']
binaries.fooDebugExecutable
binaries.getByName('fooDebugExecutable')

// Returns null if there is no such binary.
binaries.findByName('fooDebugExecutable')
</pre></div>
</div>
<p id="9ce4f70">Alternatively, you can access a binary by its name prefix and build type using typed getters.</p>
<div class="tabs" id="36e9d477" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="ec7d92be" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code" data-language="kotlin">// Fails if there is no such binary.
binaries.getExecutable("foo", DEBUG)
binaries.getExecutable(DEBUG)          // Skip the first argument if the name prefix isn't set.
binaries.getExecutable("bar", "DEBUG") // You also can use a string for build type.

// Similar getters are available for other binary kinds:
// getFramework, getStaticLib and getSharedLib.

// Returns null if there is no such binary.
binaries.findExecutable("foo", DEBUG)

// Similar getters are available for other binary kinds:
// findFramework, findStaticLib and findSharedLib.
</pre></div>
<div class="tabs__content" data-gtm="tab" id="2c6c3734" data-sync-tabs="groovy" data-title="Groovy"><pre class="code" data-language="groovy">// Fails if there is no such binary.
binaries.getExecutable('foo', DEBUG)
binaries.getExecutable(DEBUG)          // Skip the first argument if the name prefix isn't set.
binaries.getExecutable('bar', 'DEBUG') // You also can use a string for build type.

// Similar getters are available for other binary kinds:
// getFramework, getStaticLib and getSharedLib.

// Returns null if there is no such binary.
binaries.findExecutable('foo', DEBUG)

// Similar getters are available for other binary kinds:
// findFramework, findStaticLib and findSharedLib.
</pre></div>
</div></section><section class="chapter"><h2 id="export-dependencies-to-binaries" data-toc="multiplatform-build-native-binaries#export-dependencies-to-binaries">Export dependencies to binaries</h2>
<p id="33103a1d">When building an Objective-C framework or a native library (shared or static), you may need to pack not just the classes of the current project, but also the classes of its dependencies. Specify which dependencies to export to a binary using the <code class="code ">export</code> method.</p>
<div class="tabs" id="8055fbaf" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="9f171415" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code" data-language="kotlin">kotlin {
    sourceSets {
        macosMain.dependencies {
            // Will be exported.
            api(project(":dependency"))
            api("org.example:exported-library:1.0")
            // Will not be exported.
            api("org.example:not-exported-library:1.0")
        }
    }
    macosX64("macos").binaries {
        framework {
            export(project(":dependency"))
            export("org.example:exported-library:1.0")
        }
        sharedLib {
            // It's possible to export different sets of dependencies to different binaries.
            export(project(':dependency'))
        }
    }
}
</pre></div>
<div class="tabs__content" data-gtm="tab" id="576f5b9b" data-sync-tabs="groovy" data-title="Groovy"><pre class="code" data-language="groovy">kotlin {
    sourceSets {
        macosMain.dependencies {
            // Will be exported.
            api project(':dependency')
            api 'org.example:exported-library:1.0'
            // Will not be exported.
            api 'org.example:not-exported-library:1.0'
        }
    }
    macosX64("macos").binaries {
        framework {
            export project(':dependency')
            export 'org.example:exported-library:1.0'
        }
        sharedLib {
            // It's possible to export different sets of dependencies to different binaries.
            export project(':dependency')
        }
    }
}
</pre></div>
</div>
<p id="aeec899a">For example, you implement several modules in Kotlin and want to access them from Swift. Usage of several Kotlin/Native frameworks in a Swift application is limited, but you can create an umbrella framework and export all these modules to it.</p>
<aside data-type="note" class="prompt" data-title="" id="2d3dbf8b"><p id="473f0121">You can export only <a href="gradle#dependency-types" id="378b6819"><code class="code ">api</code> dependencies</a> of the corresponding source set.</p></aside><p id="93415ef9">When you export a dependency, it includes all of its API to the framework API. The compiler adds the code from this dependency to the framework, even if you use a small fraction of it. This disables dead code elimination for the exported dependency (and for its dependencies, to some extent).</p>
<p id="38221f8e">By default, export works non-transitively. This means that if you export the library <code class="code ">foo</code> depending on the library <code class="code ">bar</code>, only methods of <code class="code ">foo</code> are added to the output framework.</p>
<p id="858eacd7">You can change this behavior using the <code class="code ">transitiveExport</code> option. If set to <code class="code ">true</code>, the declarations of the library <code class="code ">bar</code> are exported as well.</p>
<aside data-type="warning" class="prompt" data-title="" id="c8f6f104"><p id="a250afb0">It is not recommended to use <code class="code ">transitiveExport</code>: it adds all transitive dependencies of the exported dependencies to the framework. This could increase both compilation time and binary size.</p>
<p id="dc43ea9a">In most cases, you don't need to add all these dependencies to the framework API. Use <code class="code ">export</code> explicitly for the dependencies you need to directly access from your Swift or Objective-C code.</p></aside><div class="tabs" id="7232493e" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="f7dee1bf" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code" data-language="kotlin">binaries {
    framework {
        export(project(":dependency"))
        // Export transitively.
        transitiveExport = true
    }
}
</pre></div>
<div class="tabs__content" data-gtm="tab" id="8962c378" data-sync-tabs="groovy" data-title="Groovy"><pre class="code" data-language="groovy">binaries {
    framework {
        export project(':dependency')
        // Export transitively.
        transitiveExport = true
    }
}
</pre></div>
</div></section><section class="chapter"><h2 id="build-universal-frameworks" data-toc="multiplatform-build-native-binaries#build-universal-frameworks">Build universal frameworks</h2>
<p id="65fd250e">By default, an Objective-C framework produced by Kotlin/Native supports only one platform. However, you can merge such frameworks into a single universal (fat) binary using the <a href="https://llvm.org/docs/CommandGuide/llvm-lipo.html" id="a2a3c68c" data-external="true" rel="noopener noreferrer"><code class="code ">lipo</code> tool</a>. This operation especially makes sense for 32-bit and 64-bit iOS frameworks. In this case, you can use the resulting universal framework on both 32-bit and 64-bit devices.</p>
<aside data-type="warning" class="prompt" data-title="" id="c00a18a6"><p id="e18049a6">The fat framework must have the same base name as the initial frameworks. Otherwise, you'll get an error.</p></aside><div class="tabs" id="2361cdfd" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="25088d05" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code" data-language="kotlin">import org.jetbrains.kotlin.gradle.tasks.FatFrameworkTask

kotlin {
    // Create and configure the targets.
    val ios32 = iosArm32("ios32")
    val ios64 = iosArm64("ios64")
    configure(listOf(ios32, ios64)) {
        binaries.framework {
            baseName = "my_framework"
        }
    }
    // Create a task to build a fat framework.
    tasks.register&lt;FatFrameworkTask&gt;("debugFatFramework") {
        // The fat framework must have the same base name as the initial frameworks.
        baseName = "my_framework"
        // The default destination directory is "&lt;build directory&gt;/fat-framework".
        destinationDirectory = buildDir.resolve("fat-framework/debug")
        // Specify the frameworks to be merged.
        from(
            ios32.binaries.getFramework("DEBUG"),
            ios64.binaries.getFramework("DEBUG")
        )
    }
}
</pre></div>
<div class="tabs__content" data-gtm="tab" id="afd8af50" data-sync-tabs="groovy" data-title="Groovy"><pre class="code" data-language="groovy">import org.jetbrains.kotlin.gradle.tasks.FatFrameworkTask

kotlin {
    // Create and configure the targets.
    targets {
        iosArm32("ios32")
        iosArm64("ios64")
        configure([ios32, ios64]) {
            binaries.framework {
                baseName = "my_framework"
            }
        }
    }
    // Create a task building a fat framework.
    tasks.register("debugFatFramework", FatFrameworkTask) {
        // The fat framework must have the same base name as the initial frameworks.
        baseName = "my_framework"
        // The default destination directory is "&lt;build directory&gt;/fat-framework".
        destinationDirectory = file("$buildDir/fat-framework/debug")
        // Specify the frameworks to be merged.
        from(
            targets.ios32.binaries.getFramework("DEBUG"),
            targets.ios64.binaries.getFramework("DEBUG")
        )
    }
}
</pre></div>
</div></section><section class="chapter"><h2 id="build-xcframeworks" data-toc="multiplatform-build-native-binaries#build-xcframeworks">Build XCFrameworks</h2>
<p id="55d1a7d7">All Kotlin Multiplatform projects can use XCFrameworks as an output to gather logic for all the target platforms and architectures in a single bundle. Unlike <a href="#build-universal-frameworks" id="e202e5a3">universal (fat) frameworks</a>, you don't need to remove all unnecessary architectures before publishing the application to the App Store.</p>
<div class="tabs" id="56691a3a" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="74bd4815" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code" data-language="kotlin">import org.jetbrains.kotlin.gradle.plugin.mpp.apple.XCFramework

plugins {
    kotlin("multiplatform")
}

kotlin {
    val xcf = XCFramework()
  
    ios {
        binaries.framework {
            baseName = "shared"
            xcf.add(this)
        }
    }
    watchos {
        binaries.framework {
            baseName = "shared"
            xcf.add(this)
        }
    }
    tvos {
        binaries.framework {
            baseName = "shared"
            xcf.add(this)
        }
    }
}
</pre></div>
<div class="tabs__content" data-gtm="tab" id="f9af0bdb" data-sync-tabs="groovy" data-title="Groovy"><pre class="code" data-language="groovy">import org.jetbrains.kotlin.gradle.plugin.mpp.apple.XCFrameworkConfig

plugins {
    id 'org.jetbrains.kotlin.multiplatform'
}

kotlin {
    def xcf = new XCFrameworkConfig(project)

    ios {
        binaries.framework {
            baseName = "shared"
            xcf.add(it)
        }
    }
    watchos {
        binaries.framework {
            baseName = "shared"
            xcf.add(it)
        }
    }
    tvos {
        binaries.framework {
            baseName = "shared"
            xcf.add(it)
        }
    }
}
</pre></div>
</div>
<p id="919533b9">When you declare XCFrameworks, Kotlin Gradle plugin will register three Gradle tasks:</p>
<ul class="list _ul" id="78f80b0a">
<li class="list__item" id="27fb71a6"><p><code class="code ">assembleXCFramework</code></p></li>
<li class="list__item" id="bf025c46"><p><code class="code ">assembleDebugXCFramework</code> (additionally debug artifact that contains <a href="native-ios-symbolication" id="d6c8b906">dSYMs</a>)</p></li>
<li class="list__item" id="be1f068a"><p><code class="code ">assembleReleaseXCFramework</code></p></li>
</ul>
<p id="3e1a0960">If you're using <a href="native-cocoapods" id="582eecf">CocoaPods integration</a> in your projects, you can build XCFrameworks with the Kotlin CocoaPods Gradle plugin. It includes the following tasks that build XCFrameworks with all the registered targets and generate podspec files:</p>
<ul class="list _ul" id="e2b057f0">
<li class="list__item" id="cd8b63f3"><p><code class="code ">podPublishReleaseXCFramework</code>, which generates a release XCFramework along with a podspec file.</p></li>
<li class="list__item" id="a49a5cdf"><p><code class="code ">podPublishDebugXCFramework</code>, which generates a debug XCFramework along with a podspec file.</p></li>
<li class="list__item" id="b50ddf0"><p><code class="code ">podPublishXCFramework</code>, which generates both debug and release XCFrameworks along with a podspec file.</p></li>
</ul>
<p id="9f3a25c7">This can help you distribute shared parts of your project separately from mobile apps through CocoaPods. You can also use XCFrameworks for publishing to private or public podspec repositories.</p>
<aside data-type="warning" class="prompt" data-title="" id="7b1e437b"><p id="fd864488">Publishing Kotlin frameworks to public repositories is not recommended if those frameworks are built for different versions of Kotlin. Doing so might lead to conflicts in the end-users' projects.</p></aside></section><div class="last-modified"> Last modified: 08 August 2022</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="multiplatform-configure-compilations">Configure compilations</a> <a class="navigation-links__next" href="multiplatform-dsl-reference">Multiplatform Gradle DSL reference</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/multiplatform-build-native-binaries.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/multiplatform-build-native-binaries.html</a>
  </p>
</div>
