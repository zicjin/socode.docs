<h1 data-toc="js-modules" id="js-modules.md">JavaScript modules</h1>
<p id="a55d671f">You can compile your Kotlin projects to JavaScript modules for various popular module systems. We currently support the following configurations for JavaScript modules:</p>
<ul class="list _ul" id="20a82838">
<li class="list__item" id="19a162ba"><p><a href="https://github.com/umdjs/umd" id="2882f31" data-external="true" rel="noopener noreferrer">Unified Module Definitions (UMD)</a>, which is compatible with both <em id="e2b6e062" class="">AMD</em> and <em id="fd825174" class="">CommonJS</em>. UMD modules are also able to be executed without being imported or when no module system is present. This is the default option for the <code class="code ">browser</code> and <code class="code ">nodejs</code> targets.</p></li>
<li class="list__item" id="e876dafc"><p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" id="7103ce2b" data-external="true" rel="noopener noreferrer">Asynchronous Module Definitions (AMD)</a>, which is in particular used by the <a href="https://requirejs.org/" id="5ea2ec14" data-external="true" rel="noopener noreferrer">RequireJS</a> library.</p></li>
<li class="list__item" id="a8f15efc"><p><a href="http://wiki.commonjs.org/wiki/Modules/1.1" id="ba51801d" data-external="true" rel="noopener noreferrer">CommonJS</a>, widely used by Node.js/npm (<code class="code ">require</code> function and <code class="code ">module.exports</code> object)</p></li>
<li class="list__item" id="292a1ad3"><p>Plain. Don't compile for any module system. You can access a module by its name in the global scope.</p></li>
</ul>
<section class="chapter"><h2 id="browser-targets" data-toc="js-modules#browser-targets">Browser targets</h2>
<p id="8812c265">If you're targeting the browser and want to use a different module system than UMD, you can specify the desired module type in the <code class="code ">webpackTask</code> configuration block. For example, to switch to CommonJS, use:</p>
<pre class="code" data-language="groovy">kotlin {
    js {
        browser {
            webpackTask {
                output.libraryTarget = "commonjs2"
            }
        }
        binaries.executable()
    }
}

</pre>
<p id="f6467361">Webpack provides two different "flavors" of CommonJS, <code class="code ">commonjs</code> and <code class="code ">commonjs2</code>, which affect the way your declarations are made available. While in most cases, you probably want <code class="code ">commonjs2</code>, which adds the <code class="code ">module.exports</code> syntax to the generated library, you can also opt for the "pure" <code class="code ">commonjs</code> option, which implements the CommonJS specification exactly. To learn more about the difference between <code class="code ">commonjs</code> and <code class="code ">commonjs2</code>, check <a href="https://github.com/webpack/webpack/issues/1114" id="5f4a6f3a" data-external="true" rel="noopener noreferrer">here</a>.</p></section><section class="chapter"><h2 id="javascript-libraries-and-node-js-files" data-toc="js-modules#javascript-libraries-and-node-js-files">JavaScript libraries and Node.js files</h2>
<p id="948f5af2">If you are creating a library that will be consumed from JavaScript or a Node.js file, and want to use a different module system, the instructions are slightly different.</p>
<section class="chapter"><h3 id="choose-the-target-module-system" data-toc="js-modules#choose-the-target-module-system">Choose the target module system</h3>
<p id="d1111179">To select module kind, set the <code class="code ">moduleKind</code> compiler option in the Gradle build script.</p>
<div class="tabs" id="219ea3e" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="690cbe65" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code" data-language="kotlin">tasks.named&lt;KotlinJsCompile&gt;("compileKotlinJs").configure {
    kotlinOptions.moduleKind = "commonjs"
}
</pre></div>
<div class="tabs__content" data-gtm="tab" id="5814facc" data-sync-tabs="groovy" data-title="Groovy"><pre class="code" data-language="groovy">compileKotlinJs.kotlinOptions.moduleKind = "commonjs"
</pre></div>
</div>
<p id="324de264">Available values are: <code class="code ">umd</code> (default), <code class="code ">commonjs</code>, <code class="code ">amd</code>, <code class="code ">plain</code>.</p>
<aside data-type="note" class="prompt" data-title="" id="8902a7b8"><p id="4886253d">This is different from adjusting <code class="code ">webpackTask.output.libraryTarget</code>. The library target changes the output <em id="32f01e4e" class="">generated by webpack</em> (after your code has already been compiled). <code class="code ">kotlinOptions.moduleKind</code> changes the output generated <em id="193d021d" class="">by the Kotlin compiler</em>.</p></aside><p id="46764cf3">In the Kotlin Gradle DSL, there is also a shortcut for setting the CommonJS module kind:</p>
<pre class="code" data-language="kotlin">kotlin {
    js {
         useCommonJs()
         // . . .
    }
}
</pre></section></section><section class="chapter"><h2 id="jsmodule-annotation" data-toc="js-modules#jsmodule-annotation">@JsModule annotation</h2>
<p id="e975b72e">To tell Kotlin that an <code class="code ">external</code> class, package, function or property is a JavaScript module, you can use <code class="code ">@JsModule</code> annotation. Consider you have the following CommonJS module called "hello":</p>
<pre class="code" data-language="javascript">module.exports.sayHello = function(name) { alert("Hello, " + name); }
</pre>
<p id="d4ea42fe">You should declare it like this in Kotlin:</p>
<pre class="code" data-language="kotlin">@JsModule("hello")
external fun sayHello(name: String)
</pre>
<section class="chapter"><h3 id="apply-jsmodule-to-packages" data-toc="js-modules#apply-jsmodule-to-packages">Apply @JsModule to packages</h3>
<p id="98ad5903">Some JavaScript libraries export packages (namespaces) instead of functions and classes. In terms of JavaScript, it's an <em id="5e96f713" class="">object</em> that has <em id="5ce7149" class="">members</em> that are classes, functions and properties. Importing these packages as Kotlin objects often looks unnatural. The compiler can map imported JavaScript packages to Kotlin packages, using the following notation:</p>
<pre class="code" data-language="kotlin">@file:JsModule("extModule")
package ext.jspackage.name

external fun foo()

external class C
</pre>
<p id="27d8443e">where the corresponding JavaScript module is declared like this:</p>
<pre class="code" data-language="javascript">module.exports = {
    foo:  { /* some code here */ },
    C:  { /* some code here */ }
}
</pre>
<p id="9bd4c9e2">Files marked with <code class="code ">@file:JsModule</code> annotation can't declare non-external members. The example below produces a compile-time error:</p>
<pre class="code" data-language="kotlin">@file:JsModule("extModule")
package ext.jspackage.name

external fun foo()

fun bar() = "!" + foo() + "!" // error here
</pre></section><section class="chapter"><h3 id="import-deeper-package-hierarchies" data-toc="js-modules#import-deeper-package-hierarchies">Import deeper package hierarchies</h3>
<p id="7fc59df1">In the previous example the JavaScript module exports a single package. However, some JavaScript libraries export multiple packages from within a module. This case is also supported by Kotlin, though you have to declare a new <code class="code ">.kt</code> file for each package you import.</p>
<p id="3e4a042">For example, let's make the example a bit more complicated:</p>
<pre class="code" data-language="javascript">module.exports = {
    mylib: {
        pkg1: {
            foo: function() { /* some code here */ },
            bar: function() { /* some code here */ }
        },
        pkg2: {
            baz: function() { /* some code here */ }
        }
    }
}
</pre>
<p id="5f00eeb0">To import this module in Kotlin, you have to write two Kotlin source files:</p>
<pre class="code" data-language="kotlin">@file:JsModule("extModule")
@file:JsQualifier("mylib.pkg1")
package extlib.pkg1

external fun foo()

external fun bar()
</pre>
<p id="f886ca8f">and</p>
<pre class="code" data-language="kotlin">@file:JsModule("extModule")
@file:JsQualifier("mylib.pkg2")
package extlib.pkg2

external fun baz()
</pre></section><section class="chapter"><h3 id="jsnonmodule-annotation" data-toc="js-modules#jsnonmodule-annotation">@JsNonModule annotation</h3>
<p id="e0d5a1ca">When a declaration is marked as <code class="code ">@JsModule</code>, you can't use it from Kotlin code when you don't compile it to a JavaScript module. Usually, developers distribute their libraries both as JavaScript modules and downloadable <code class="code ">.js</code> files that you can copy to your project's static resources and include via a <code class="code ">&lt;script&gt;</code> tag. To tell Kotlin that it's okay to use a <code class="code ">@JsModule</code> declaration from a non-module environment, add the <code class="code ">@JsNonModule</code> annotation. For example, consider the following JavaScript code:</p>
<pre class="code" data-language="javascript">function topLevelSayHello(name) { alert("Hello, " + name); }
if (module &amp;&amp; module.exports) {
    module.exports = topLevelSayHello;
}
</pre>
<p id="38ed3e74">You could describe it from Kotlin as follows:</p>
<pre class="code" data-language="kotlin">@JsModule("hello")
@JsNonModule
@JsName("topLevelSayHello")
external fun sayHello(name: String)
</pre></section><section class="chapter"><h3 id="module-system-used-by-the-kotlin-standard-library" data-toc="js-modules#module-system-used-by-the-kotlin-standard-library">Module system used by the Kotlin Standard Library</h3>
<p id="9c2385ed">Kotlin is distributed with the Kotlin/JS standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. While for most use cases of Kotlin/JS, it is recommended to use a Gradle dependency on <code class="code ">kotlin-stdlib-js</code>, it is also available on NPM as the <a href="https://www.npmjs.com/package/kotlin" id="d9190158" data-external="true" rel="noopener noreferrer"><code class="code ">kotlin</code></a> package.</p></section></section><div class="last-modified"> Last modified: 08 August 2022</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="js-to-kotlin-interop">Use Kotlin code from JavaScript</a> <a class="navigation-links__next" href="js-reflection">Kotlin/JS reflection</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/js-modules.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/js-modules.html</a>
  </p>
</div>
