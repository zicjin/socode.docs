<h1 data-toc="native-dynamic-libraries" id="native-dynamic-libraries.md">Kotlin/Native as a dynamic library â€“ tutorial</h1>
<p id="b56ead87">Learn how you can use the Kotlin/Native code from existing native applications or libraries. For this, you need to compile the Kotlin code into a dynamic library, <code class="code ">.so</code>, <code class="code ">.dylib</code>, and <code class="code ">.dll</code>.</p>
<p id="5a152d7e">Kotlin/Native also has tight integration with Apple technologies. The <a href="apple-framework" id="30737372">Kotlin/Native as an Apple Framework</a> tutorial explains how to compile Kotlin code into a framework for Swift and Objective-C.</p>
<p id="d43882b3">In this tutorial, you will:</p>
<ul class="list _ul" id="94c12f2b">
<li class="list__item" id="4ad30f8"><p><a href="#create-a-kotlin-library" id="d13d7a9e">Compile Kotlin code to a dynamic library</a></p></li>
<li class="list__item" id="f3237cd9"><p><a href="#generated-headers-file" id="ed8cd746">Examine generated C headers</a></p></li>
<li class="list__item" id="de86d7fc"><p><a href="#use-generated-headers-from-c" id="fcb32a21">Use the Kotlin dynamic library from C</a></p></li>
<li class="list__item" id="61e45776"><p>Compile and run the example on <a href="#compile-and-run-the-example-on-linux-and-macos" id="1a6975f2">Linux and Mac</a> and <a href="#compile-and-run-the-example-on-windows" id="42819f3d">Windows</a></p></li>
</ul>
<section class="chapter"><h2 id="create-a-kotlin-library" data-toc="native-dynamic-libraries#create-a-kotlin-library">Create a Kotlin library</h2>
<p id="f2a1c1d5">Kotlin/Native compiler can produce a dynamic library out of the Kotlin code. A dynamic library often comes with a header file, a <code class="code ">.h</code> file, which you will use to call the compiled code from C.</p>
<p id="10599f02">The best way to understand these techniques is to try them out. First, create a first tiny Kotlin library and use it from a C program.</p>
<p id="80e19897">Start by creating a library file in Kotlin and save it as <code class="code ">hello.kt</code>:</p>
<pre class="code" data-language="kotlin">package example

object Object {
  val field = "A"
}

class Clazz {
  fun memberFunction(p: Int): ULong = 42UL
}

fun forIntegers(b: Byte, s: Short, i: UInt, l: Long) { }
fun forFloats(f: Float, d: Double) { }

fun strings(str: String) : String? {
  return "That is '$str' from C"
}

val globalString = "A global String"
</pre>
<p id="1c1de29a">While it is possible to use the command line, either directly or by combining it with a script file (such as <code class="code ">.sh</code> or <code class="code ">.bat</code> file), this approach doesn't scale well for big projects that have hundreds of files and libraries. It is then better to use the Kotlin/Native compiler with a build system, as it helps to download and cache the Kotlin/Native compiler binaries and libraries with transitive dependencies and run the compiler and tests. Kotlin/Native can use the <a href="https://gradle.org" id="9b9c5bd5" data-external="true" rel="noopener noreferrer">Gradle</a> build system through the <a href="multiplatform-discover-project#multiplatform-plugin" id="881aa4e9">kotlin-multiplatform</a> plugin.</p>
<p id="549aeb02">We covered the basics of setting up an IDE compatible project with Gradle in the <a href="native-gradle" id="9fc1ea8d">A Basic Kotlin/Native Application</a> tutorial. Please check it out if you are looking for detailed first steps and instructions on how to start a new Kotlin/Native project and open it in IntelliJ IDEA. In this tutorial, we'll look at the advanced C interop related usages of Kotlin/Native and <a href="multiplatform-discover-project#multiplatform-plugin" id="daf1950d">multiplatform</a> builds with Gradle.</p>
<p id="9477940c">First, create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes the missing directories will have to be created before any new files can be added.</p>
<p id="23064b61">Use the following <code class="code ">build.gradle(.kts)</code> Gradle build file:</p>
<div class="tabs" id="cffd88bc" data-group="build-script">
<div class="tabs__content" data-gtm="tab" id="8b1ab5b2" data-sync-tabs="kotlin" data-title="Kotlin"><pre class="code" data-language="kotlin">plugins {
    kotlin("multiplatform") version "1.7.10"
}

repositories {
    mavenCentral()
}

kotlin {
  linuxX64("native") { // on Linux 
  // macosX64("native") { // on x86_64 macOS
  // macosArm64("native") { // on Apple Silicon macOS
  // mingwX64("native") { // on Windows
    binaries {
      sharedLib {
        baseName = "native" // on Linux and macOS
        // baseName = "libnative" // on Windows
      }
    }
  }
}

tasks.wrapper {
  gradleVersion = "6.7.1"
  distributionType = Wrapper.DistributionType.ALL
}
</pre></div>
<div class="tabs__content" data-gtm="tab" id="789baec5" data-sync-tabs="groovy" data-title="Groovy"><pre class="code" data-language="groovy">plugins {
    id 'org.jetbrains.kotlin.multiplatform' version '1.7.10'
}

repositories {
    mavenCentral()
}

kotlin {
  linuxX64("native") { // on Linux
  // macosX64("native") { // on x86_64 macOS
  // macosArm64("native") { // on Apple Silicon macOS
  // mingwX64("native") { // on Windows
    binaries {
      sharedLib {
        baseName = "native" // on Linux and macOS
        // baseName = "libnative" // on Windows
      }
    }
  }
}

wrapper {
  gradleVersion = "6.7.1"
  distributionType = "ALL"
}
</pre></div>
</div>
<p id="814f2204">Move the sources file into the <code class="code ">src/nativeMain/kotlin</code> folder under the project. This is the default path, for where sources are located, when the <a href="multiplatform-discover-project#multiplatform-plugin" id="16c8847e">kotlin-multiplatform</a> plugin is used. Use the following block to instruct and configure the project to generate a dynamic or shared library:</p>
<pre class="code" data-language="kotlin">binaries {
  sharedLib {
    baseName = "native" // on Linux and macOS
    // baseName = "libnative" // on Windows
  }  
}
</pre>
<p id="dbbcda16">The <code class="code ">libnative</code> is used as the library name, the generated header file name prefix. It is also prefixes all declarations in the header file.</p>
<p id="1b5d771f">Now you can <a href="native-get-started" id="bb1462e8">open the project in IntelliJ IDEA</a> and to see how to fix the example project. While doing this, we'll examine how C functions are mapped into Kotlin/Native declarations.</p>
<p id="8d03577f">Run the <code class="code ">linkNative</code> Gradle task to build the library in the IDE or by calling the following console command:</p>
<pre class="code" data-language="bash">./gradlew linkNative
</pre>
<p id="2226c0bd">The build generates the following files under the <code class="code ">build/bin/native/debugShared</code> folder, depending on the host OS:</p>
<ul class="list _ul" id="f6efbcd8">
<li class="list__item" id="5e4944"><p>macOS: <code class="code ">libnative_api.h</code> and <code class="code ">libnative.dylib</code></p></li>
<li class="list__item" id="6ddbb57d"><p>Linux: <code class="code ">libnative_api.h</code> and <code class="code ">libnative.so</code></p></li>
<li class="list__item" id="debdca1a"><p>Windows: <code class="code ">libnative_api.h</code>, <code class="code ">libnative_symbols.def</code> and <code class="code ">libnative.dll</code></p></li>
</ul>
<p id="aef802ab">The same rules are used by the Kotlin/Native compiler to generate the <code class="code ">.h</code> file for all platforms.<br> Let's check out the C API of our Kotlin library.`</p></section><section class="chapter"><h2 id="generated-headers-file" data-toc="native-dynamic-libraries#generated-headers-file">Generated headers file</h2>
<p id="9fa28af8">In the <code class="code ">libnative_api.h</code>, you'll find the following code. Let's discuss the code in parts to make it easier to understand.</p>
<aside data-type="note" class="prompt" data-title="" id="a2588532"><p id="bc4c6869">The way Kotlin/Native exports symbols is subject to change without notice.</p></aside><p id="8a52dc3a">The very first part contains the standard C/C++ header and footer:</p>
<pre class="code" data-language="c">#ifndef KONAN_DEMO_H
#define KONAN_DEMO_H
#ifdef __cplusplus
extern "C" {
#endif

/// THE REST OF THE GENERATED CODE GOES HERE

#ifdef __cplusplus
}  /* extern "C" */
#endif
#endif  /* KONAN_DEMO_H */
</pre>
<p id="79c06cc7">After the rituals in the <code class="code ">libnative_api.h</code>, there is a block with the common type definitions:</p>
<pre class="code" data-language="c">#ifdef __cplusplus
typedef bool            libnative_KBoolean;
#else
typedef _Bool           libnative_KBoolean;
#endif
typedef unsigned short     libnative_KChar;
typedef signed char        libnative_KByte;
typedef short              libnative_KShort;
typedef int                libnative_KInt;
typedef long long          libnative_KLong;
typedef unsigned char      libnative_KUByte;
typedef unsigned short     libnative_KUShort;
typedef unsigned int       libnative_KUInt;
typedef unsigned long long libnative_KULong;
typedef float              libnative_KFloat;
typedef double             libnative_KDouble;
typedef void*              libnative_KNativePtr;
</pre>
<p id="8d05de10">Kotlin uses the <code class="code ">libnative_</code> prefix for all declarations in the created <code class="code ">libnative_api.h</code> file. Let's present the mapping of the types in a more readable way:</p>
<div class="table-wrapper"><table class=" wide" id="ae4edd20">
<thead><tr class="ijRowHead" id="42d6cf1b">
<th id="8b036fee"><p>Kotlin Define</p></th>
<th id="1f6fbad6"><p>C Type</p></th>
</tr></thead>
<tbody>
<tr class="" id="f3b0e5a6">
<td id="e25aab26"><p><code class="code ">libnative_KBoolean</code></p></td>
<td id="313631ef"><p><code class="code ">bool</code> or <code class="code ">_Bool</code></p></td>
</tr>
<tr class="" id="14ad1d7c">
<td id="ba053771"><p><code class="code ">libnative_KChar</code></p></td>
<td id="80d775cb"><p><code class="code ">unsigned short</code></p></td>
</tr>
<tr class="" id="c49b550a">
<td id="bc96deb6"><p><code class="code ">libnative_KByte</code></p></td>
<td id="714a4cfd"><p><code class="code ">signed char</code></p></td>
</tr>
<tr class="" id="e2a5c9a">
<td id="5a6f1444"><p><code class="code ">libnative_KShort</code></p></td>
<td id="1b06ffdc"><p><code class="code ">short</code></p></td>
</tr>
<tr class="" id="25b12b63">
<td id="85054db6"><p><code class="code ">libnative_KInt</code></p></td>
<td id="46c0c346"><p><code class="code ">int</code></p></td>
</tr>
<tr class="" id="73febb94">
<td id="f8476d82"><p><code class="code ">libnative_KLong</code></p></td>
<td id="440cb222"><p><code class="code ">long long</code></p></td>
</tr>
<tr class="" id="5b71f123">
<td id="f1a60c59"><p><code class="code ">libnative_KUByte</code></p></td>
<td id="d5b511a4"><p><code class="code ">unsigned char</code></p></td>
</tr>
<tr class="" id="ec30117c">
<td id="f18c3a11"><p><code class="code ">libnative_KUShort</code></p></td>
<td id="d405e6db"><p><code class="code ">unsigned short</code></p></td>
</tr>
<tr class="" id="545fb1ba">
<td id="55cb33cc"><p><code class="code ">libnative_KUInt</code></p></td>
<td id="8970b849"><p><code class="code ">unsigned int</code></p></td>
</tr>
<tr class="" id="987ccb39">
<td id="fc7be2ea"><p><code class="code ">libnative_KULong</code></p></td>
<td id="4a1d220b"><p><code class="code ">unsigned long long</code></p></td>
</tr>
<tr class="" id="2709ff51">
<td id="444ae38a"><p><code class="code ">libnative_KFloat</code></p></td>
<td id="dc865b81"><p><code class="code ">float</code></p></td>
</tr>
<tr class="" id="fc5bb62c">
<td id="13c58ca9"><p><code class="code ">libnative_KDouble</code></p></td>
<td id="aa43b53d"><p><code class="code ">double</code></p></td>
</tr>
<tr class="" id="d38354f3">
<td id="86f4ffbe"><p><code class="code ">libnative_KNativePtr</code></p></td>
<td id="e368becf"><p><code class="code ">void*</code></p></td>
</tr>
</tbody>
</table></div>
<p id="e69c50a9">The definitions part shows how Kotlin primitive types map into C primitive types. The reverse mapping is described in the <a href="mapping-primitive-data-types-from-c" id="5f41d34">Mapping primitive data types from C</a> tutorial.</p>
<p id="909294ee">The next part of the <code class="code ">libnative_api.h</code> file contains definitions of the types that are used in the library:</p>
<pre class="code" data-language="c">struct libnative_KType;
typedef struct libnative_KType libnative_KType;

typedef struct {
  libnative_KNativePtr pinned;
} libnative_kref_example_Object;

typedef struct {
  libnative_KNativePtr pinned;
} libnative_kref_example_Clazz;
</pre>
<p id="3727027">The <code class="code ">typedef struct { .. } TYPE_NAME</code> syntax is used in C language to declare a structure. <a href="https://stackoverflow.com/questions/1675351/typedef-struct-vs-struct-definitions" id="2bd8ad4e" data-external="true" rel="noopener noreferrer">This thread</a> on Stackoverflow provides more explanations of that pattern.</p>
<p id="c05e69aa">As you can see from these definitions, the Kotlin object <code class="code ">Object</code> is mapped into <code class="code ">libnative_kref_example_Object</code>, and <code class="code ">Clazz</code> is mapped into <code class="code ">libnative_kref_example_Clazz</code>. Both structs contain nothing but the <code class="code ">pinned</code> field with a pointer, the field type <code class="code ">libnative_KNativePtr</code> is defined as <code class="code ">void*</code> above.</p>
<p id="11e12c59">There is no namespaces support in C, so the Kotlin/Native compiler generates long names to avoid any possible clashes with other symbols in the existing native project.</p>
<p id="5535960e">A significant part of the definitions goes in the <code class="code ">libnative_api.h</code> file. It includes the definition of our Kotlin/Native library world:</p>
<pre class="code" data-language="c">typedef struct {
  /* Service functions. */
  void (*DisposeStablePointer)(libnative_KNativePtr ptr);
  void (*DisposeString)(const char* string);
  libnative_KBoolean (*IsInstance)(libnative_KNativePtr ref, const libnative_KType* type);

  /* User functions. */
  struct {
    struct {
      struct {
        void (*forIntegers)(libnative_KByte b, libnative_KShort s, libnative_KUInt i, libnative_KLong l);
        void (*forFloats)(libnative_KFloat f, libnative_KDouble d);
        const char* (*strings)(const char* str);
        const char* (*get_globalString)();
        struct {
          libnative_KType* (*_type)(void);
          libnative_kref_example_Object (*_instance)();
          const char* (*get_field)(libnative_kref_example_Object thiz);
        } Object;
        struct {
          libnative_KType* (*_type)(void);
          libnative_kref_example_Clazz (*Clazz)();
          libnative_KULong (*memberFunction)(libnative_kref_example_Clazz thiz, libnative_KInt p);
        } Clazz;
      } example;
    } root;
  } kotlin;
} libnative_ExportedSymbols;
</pre>
<p id="f71d0ed0">The code uses anonymous structure declarations. The code <code class="code ">struct { .. } foo</code> declares a field in the outer struct of that anonymous structure type, the type with no name.</p>
<p id="8b5243c6">C does not support objects either. People use function pointers to mimic object semantics. A function pointer is declared as follows <code class="code ">RETURN_TYPE (* FIELD_NAME)(PARAMETERS)</code>. It is tricky to read, but we should be able to see function pointer fields in the structures above.</p>
<section class="chapter"><h3 id="runtime-functions" data-toc="native-dynamic-libraries#runtime-functions">Runtime functions</h3>
<p id="4c4683f0">The code reads as follows. You have the <code class="code ">libnative_ExportedSymbols</code> structure, which defines all the functions that Kotlin/Native and our library provides us. It uses nested anonymous structures heavily to mimic packages. The <code class="code ">libnative_</code> prefix comes from the library name.</p>
<p id="c2af5027">The <code class="code ">libnative_ExportedSymbols</code> structure contains several helper functions:</p>
<pre class="code" data-language="c">void (*DisposeStablePointer)(libnative_KNativePtr ptr);
void (*DisposeString)(const char* string);
libnative_KBoolean (*IsInstance)(libnative_KNativePtr ref, const libnative_KType* type);
</pre>
<p id="5eb3e32c">These functions deal with Kotlin/Native objects. Call the <code class="code ">DisposeStablePointer</code> to release a Kotlin object and <code class="code ">DisposeString</code> to release a Kotlin String, which has the <code class="code ">char*</code> type in C. It is possible to use the <code class="code ">IsInstance</code> function to check if a Kotlin type or a <code class="code ">libnative_KNativePtr</code> is an instance of another type. The actual set of operations generated depends on the actual usages.</p>
<p id="86ff06e6">Kotlin/Native has garbage collection, but it does not help us deal with Kotlin objects from the C language. Kotlin/Native has interop with Objective-C and Swift and integrates with their reference counters. The <a href="native-objc-interop" id="19d0ab96">Objective-C Interop</a> documentation article contains more details on it. Also, there is the tutorial <a href="apple-framework" id="a7401f5a">Kotlin/Native as an Apple Framework</a>.</p></section><section class="chapter"><h3 id="your-library-functions" data-toc="native-dynamic-libraries#your-library-functions">Your library functions</h3>
<p id="62760e9">Let's take a look at the <code class="code ">kotlin.root.example</code> field, it mimics the package structure of our Kotlin code with a <code class="code ">kotlin.root.</code> prefix.</p>
<p id="fece3db4">There is a <code class="code ">kotlin.root.example.Clazz</code> field that represents the <code class="code ">Clazz</code> from Kotlin. The <code class="code ">Clazz#memberFunction</code> is accessible with the <code class="code ">memberFunction</code> field. The only difference is that the <code class="code ">memberFunction</code> accepts a <code class="code ">this</code> reference as the first parameter. The C language does not support objects, and this is the reason to pass a <code class="code ">this</code> pointer explicitly.</p>
<p id="8c5a01c2">There is a constructor in the <code class="code ">Clazz</code> field (aka <code class="code ">kotlin.root.example.Clazz.Clazz</code>), which is the constructor function to create an instance of the <code class="code ">Clazz</code>.</p>
<p id="e91d4a">Kotlin <code class="code ">object Object</code> is accessible as <code class="code ">kotlin.root.example.Object</code>. There is the <code class="code ">_instance</code> function to get the only instance of the object.</p>
<p id="d46e871e">Properties are translated into functions. The <code class="code ">get_</code> and <code class="code ">set_</code> prefix is used to name the getter and the setter functions respectively. For example, the read-only property <code class="code ">globalString</code> from Kotlin is turned into a <code class="code ">get_globalString</code> function in C.</p>
<p id="c814857">Global functions <code class="code ">forInts</code>, <code class="code ">forFloats</code>, or <code class="code ">strings</code> are turned into the functions pointers in the <code class="code ">kotlin.root.example</code> anonymous struct.</p></section><section class="chapter"><h3 id="entry-point" data-toc="native-dynamic-libraries#entry-point">Entry point</h3>
<p id="3c01af1d">You can see how the API is created. To start with, you need to initialize the <code class="code ">libnative_ExportedSymbols</code> structure. Let's take a look at the latest part of the <code class="code ">libnative_api.h</code> for this:</p>
<pre class="code" data-language="c">extern libnative_ExportedSymbols* libnative_symbols(void);
</pre>
<p id="6a361a4">The function <code class="code ">libnative_symbols</code> allows you to open the way from the native code to the Kotlin/Native library. This is the entry point you'll use. The library name is used as a prefix for the function name.</p>
<aside data-type="note" class="prompt" data-title="" id="421dad0a"><p id="a52b9bbc">Kotlin/Native object references do not support multi-threaded access. Hosting the returned <code class="code ">libnative_ExportedSymbols*</code> pointer per thread might be necessary.</p></aside></section></section><section class="chapter"><h2 id="use-generated-headers-from-c" data-toc="native-dynamic-libraries#use-generated-headers-from-c">Use generated headers from C</h2>
<p id="4e50a720">The usage from C is straightforward and uncomplicated. Create a <code class="code ">main.c</code> file with the following code:</p>
<pre class="code" data-language="c">#include "libnative_api.h"
#include "stdio.h"

int main(int argc, char** argv) {
  //obtain reference for calling Kotlin/Native functions
  libnative_ExportedSymbols* lib = libnative_symbols();

  lib-&gt;kotlin.root.example.forIntegers(1, 2, 3, 4);
  lib-&gt;kotlin.root.example.forFloats(1.0f, 2.0);

  //use C and Kotlin/Native strings
  const char* str = "Hello from Native!";
  const char* response = lib-&gt;kotlin.root.example.strings(str);
  printf("in: %s\nout:%s\n", str, response);
  lib-&gt;DisposeString(response);

  //create Kotlin object instance
  libnative_kref_example_Clazz newInstance = lib-&gt;kotlin.root.example.Clazz.Clazz();
  long x = lib-&gt;kotlin.root.example.Clazz.memberFunction(newInstance, 42);
  lib-&gt;DisposeStablePointer(newInstance.pinned);

  printf("DemoClazz returned %ld\n", x);

  return 0;
}
</pre></section><section class="chapter"><h2 id="compile-and-run-the-example-on-linux-and-macos" data-toc="native-dynamic-libraries#compile-and-run-the-example-on-linux-and-macos">Compile and run the example on Linux and macOS</h2>
<p id="6e8d54c7">On macOS 10.13 with Xcode, compile the C code and link it with the dynamic library with the following command:</p>
<pre class="code" data-language="bash">clang main.c libnative.dylib
</pre>
<p id="d426acc2">On Linux call a similar command:</p>
<pre class="code" data-language="bash">gcc main.c libnative.so
</pre>
<p id="e3f11dbf">The compiler generates an executable called <code class="code ">a.out</code>. Run it to see in action the Kotlin code being executed from C library. On Linux, you'll need to include <code class="code ">.</code> into the <code class="code ">LD_LIBRARY_PATH</code> to let the application know to load the <code class="code ">libnative.so</code> library from the current folder.</p></section><section class="chapter"><h2 id="compile-and-run-the-example-on-windows" data-toc="native-dynamic-libraries#compile-and-run-the-example-on-windows">Compile and run the example on Windows</h2>
<p id="2c42424e">To start with, you'll need a Microsoft Visual C++ compiler installed that supports a x64_64 target. The easiest way to do this is to have a version of Microsoft Visual Studio installed on a Windows machine.</p>
<p id="cc38d5e8">In this example, you'll be using the <code class="code ">x64 Native Tools Command Prompt &lt;VERSION&gt;</code> console. You'll see the shortcut to open the console in the start menu. It comes with a Microsoft Visual Studio package.</p>
<p id="551edb36">On Windows, Dynamic libraries are included either via a generated static library wrapper or with manual code, which deals with the <a href="https://docs.microsoft.com/en-gb/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya" id="1253ceb5" data-external="true" rel="noopener noreferrer">LoadLibrary</a> or similar Win32API functions. Follow the first option and generate the static wrapper library for the <code class="code ">libnative.dll</code> as described below.</p>
<p id="41fbc395">Call <code class="code ">lib.exe</code> from the toolchain to generate the static library wrapper <code class="code ">libnative.lib</code> that automates the DLL usage from the code:</p>
<pre class="code" data-language="bash">lib /def:libnative_symbols.def /out:libnative.lib
</pre>
<p id="c3170cde">Now you are ready to compile our <code class="code ">main.c</code> into an executable. Include the generated <code class="code ">libnative.lib</code> into the build command and start:</p>
<pre class="code" data-language="bash">cl.exe main.c libnative.lib
</pre>
<p id="854c030">The command produces the <code class="code ">main.exe</code> file, which you can run.</p></section><section class="chapter"><h2 id="next-steps" data-toc="native-dynamic-libraries#next-steps">Next steps</h2>
<p id="3d79e5aa">Dynamic libraries are the main way to use Kotlin code from existing programs. You can use them to share your code with many platforms or languages, including JVM, Python, iOS, Android, and others.</p>
<p id="f10af045">Kotlin/Native also has tight integration with Objective-C and Swift. It is covered in the <a href="apple-framework" id="c13e5d7">Kotlin/Native as an Apple Framework</a> tutorial.</p></section><div class="last-modified"> Last modified: 08 August 2022</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="native-platform-libs">Platform libraries</a> <a class="navigation-links__next" href="native-immutability">Immutability and concurrency in Kotlin/Native</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/native-dynamic-libraries.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/native-dynamic-libraries.html</a>
  </p>
</div>
