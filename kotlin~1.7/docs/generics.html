<h1 data-toc="generics" id="generics.md">Generics: in, out, where</h1>
<p id="744874da">Classes in Kotlin can have type parameters, just like in Java:</p>
<pre class="code" data-language="kotlin">class Box&lt;T&gt;(t: T) {
    var value = t
}
</pre>
<p id="85d1902e">To create an instance of such a class, simply provide the type arguments:</p>
<pre class="code" data-language="kotlin">val box: Box&lt;Int&gt; = Box&lt;Int&gt;(1)
</pre>
<p id="56a13aa">But if the parameters can be inferred, for example, from the constructor arguments, you can omit the type arguments:</p>
<pre class="code" data-language="kotlin">val box = Box(1) // 1 has type Int, so the compiler figures out that it is Box&lt;Int&gt;
</pre>
<section class="chapter"><h2 id="variance" data-toc="generics#variance">Variance</h2>
<p id="90241dc5">One of the trickiest aspects of Java's type system is the wildcard types (see <a href="http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html" id="433625eb" data-external="true" rel="noopener noreferrer">Java Generics FAQ</a>). Kotlin doesn't have these. Instead, Kotlin has declaration-site variance and type projections.</p>
<p id="d6e6fafd">Let's think about why Java needs these mysterious wildcards. The problem is explained well in <a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html" id="6f762dd4" data-external="true" rel="noopener noreferrer">Effective Java, 3rd Edition</a>, Item 31: <em id="4de91983" class="">Use bounded wildcards to increase API flexibility</em>. First, generic types in Java are <em id="7be51886" class="">invariant</em>, meaning that <code class="code ">List&lt;String&gt;</code> is <em id="4cd2377c" class="">not</em> a subtype of <code class="code ">List&lt;Object&gt;</code>. If <code class="code ">List</code> were not <em id="6df6da01" class="">invariant</em>, it would have been no better than Java's arrays, as the following code would have compiled but caused an exception at runtime:</p>
<pre class="code" data-language="java">// Java
List&lt;String&gt; strs = new ArrayList&lt;String&gt;();
List&lt;Object&gt; objs = strs; // !!! A compile-time error here saves us from a runtime exception later.
objs.add(1); // Put an Integer into a list of Strings
String s = strs.get(0); // !!! ClassCastException: Cannot cast Integer to String
</pre>
<p id="243eb6d1">Java prohibits such things in order to guarantee run-time safety. But this has implications. For example, consider the <code class="code ">addAll()</code> method from the <code class="code ">Collection</code> interface. What's the signature of this method? Intuitively, you'd write it this way:</p>
<pre class="code" data-language="java">// Java
interface Collection&lt;E&gt; ... {
    void addAll(Collection&lt;E&gt; items);
}
</pre>
<p id="5f167047">But then, you would not be able to do the following (which is perfectly safe):</p>
<pre class="code" data-language="java">// Java
void copyAll(Collection&lt;Object&gt; to, Collection&lt;String&gt; from) {
    to.addAll(from);
    // !!! Would not compile with the naive declaration of addAll:
    // Collection&lt;String&gt; is not a subtype of Collection&lt;Object&gt;
}
</pre>
<p id="3756b669">(In Java, you probably learned this the hard way, see <a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html" id="7c7f69c2" data-external="true" rel="noopener noreferrer">Effective Java, 3rd Edition</a>, Item 28: <em id="d1fb77e7" class="">Prefer lists to arrays</em>)</p>
<p id="30374f4c">That's why the actual signature of <code class="code ">addAll()</code> is the following:</p>
<pre class="code" data-language="java">// Java
interface Collection&lt;E&gt; ... {
    void addAll(Collection&lt;? extends E&gt; items);
}
</pre>
<p id="b05deb69">The <em id="b54fa70f" class="">wildcard type argument</em> <code class="code ">? extends E</code> indicates that this method accepts a collection of objects of <code class="code ">E</code> <em id="c58d5629" class="">or a subtype of</em> <code class="code ">E</code>, not just <code class="code ">E</code> itself. This means that you can safely <em id="858ef59b" class="">read</em> <code class="code ">E</code>'s from items (elements of this collection are instances of a subclass of E), but <em id="c8b525d7" class="">cannot write</em> to it as you don't know what objects comply with that unknown subtype of <code class="code ">E</code>. In return for this limitation, you get the desired behavior: <code class="code ">Collection&lt;String&gt;</code> <em id="692e7fc9" class="">is</em> a subtype of <code class="code ">Collection&lt;? extends Object&gt;</code>. In other words, the wildcard with an <em id="d69f403d" class="">extends</em>-bound (<em id="6975fe64" class="">upper</em> bound) makes the type <em id="15f91acb" class="">covariant</em>.</p>
<p id="2a85df0b">The key to understanding why this works is rather simple: if you can only <em id="27035d3b" class="">take</em> items from a collection, then using a collection of <code class="code ">String</code>s and reading <code class="code ">Object</code>s from it is fine. Conversely, if you can only <em id="b2e88e0c" class="">put</em> items into the collection, it's okay to take a collection of <code class="code ">Object</code>s and put <code class="code ">String</code>s into it: in Java there is <code class="code ">List&lt;? super String&gt;</code>, a <em id="f2bfce29" class="">supertype</em> of <code class="code ">List&lt;Object&gt;</code>.</p>
<p id="95ef40bd">The latter is called <em id="b3bcec89" class="">contravariance</em>, and you can only call methods that take <code class="code ">String</code> as an argument on <code class="code ">List&lt;? super String&gt;</code> (for example, you can call <code class="code ">add(String)</code> or <code class="code ">set(int, String)</code>). If you call something that returns <code class="code ">T</code> in <code class="code ">List&lt;T&gt;</code>, you don't get a <code class="code ">String</code>, but rather an <code class="code ">Object</code>.</p>
<p id="e168b458">Joshua Bloch gives the name <em id="5a9810e" class="">Producers</em> to objects you only <em id="7ea1a596" class="">read from</em> and <em id="bd4486df" class="">Consumers</em> to those you only <em id="2aca2848" class="">write to</em>. He recommends:</p>
<aside data-type="tip" class="prompt" data-title="" id="d6fac085"><p id="83f4bc91">"For maximum flexibility, use wildcard types on input parameters that represent producers or consumers", and proposes the following mnemonic:</p>
<p id="c0fa77ae"><em id="6063b6c5" class="">PECS stands for Producer-Extends, Consumer-Super.</em></p></aside><aside data-type="note" class="prompt" data-title="" id="e12104c4"><p id="c894ff91">If you use a producer-object, say, <code class="code ">List&lt;? extends Foo&gt;</code>, you are not allowed to call <code class="code ">add()</code> or <code class="code ">set()</code> on this object, but this does not mean that it is <em id="4ecbdb24" class="">immutable</em>: for example, nothing prevents you from calling <code class="code ">clear()</code> to remove all the items from the list, since <code class="code ">clear()</code> does not take any parameters at all.</p>
<p id="b2f89e12">The only thing guaranteed by wildcards (or other types of variance) is <em id="c5bd5f69" class="">type safety</em>. Immutability is a completely different story.</p></aside><section class="chapter"><h3 id="declaration-site-variance" data-toc="generics#declaration-site-variance">Declaration-site variance</h3>
<p id="8c0b5a01">Let's suppose that there is a generic interface <code class="code ">Source&lt;T&gt;</code> that does not have any methods that take <code class="code ">T</code> as a parameter, only methods that return <code class="code ">T</code>:</p>
<pre class="code" data-language="java">// Java
interface Source&lt;T&gt; {
    T nextT();
}
</pre>
<p id="8ad35274">Then, it would be perfectly safe to store a reference to an instance of <code class="code ">Source&lt;String&gt;</code> in a variable of type <code class="code ">Source&lt;Object&gt;</code> - there are no consumer-methods to call. But Java does not know this, and still prohibits it:</p>
<pre class="code" data-language="java">// Java
void demo(Source&lt;String&gt; strs) {
    Source&lt;Object&gt; objects = strs; // !!! Not allowed in Java
    // ...
}
</pre>
<p id="e408fe53">To fix this, you should declare objects of type <code class="code ">Source&lt;? extends Object&gt;</code>. Doing so is meaningless, because you can call all the same methods on such a variable as before, so there's no value added by the more complex type. But the compiler does not know that.</p>
<p id="8588b092">In Kotlin, there is a way to explain this sort of thing to the compiler. This is called <em id="d66be949" class="">declaration-site variance</em>: you can annotate the <em id="ee676c41" class="">type parameter</em> <code class="code ">T</code> of <code class="code ">Source</code> to make sure that it is only <em id="85865378" class="">returned</em> (produced) from members of <code class="code ">Source&lt;T&gt;</code>, and never consumed. To do this, use the <code class="code ">out</code> modifier:</p>
<pre class="code" data-language="kotlin">interface Source&lt;out T&gt; {
    fun nextT(): T
}

fun demo(strs: Source&lt;String&gt;) {
    val objects: Source&lt;Any&gt; = strs // This is OK, since T is an out-parameter
    // ...
}
</pre>
<p id="a5eea9c7">The general rule is this: when a type parameter <code class="code ">T</code> of a class <code class="code ">C</code> is declared <code class="code ">out</code>, it may occur only in the <em id="60b203b9" class="">out</em>-position in the members of <code class="code ">C</code>, but in return <code class="code ">C&lt;Base&gt;</code> can safely be a supertype of <code class="code ">C&lt;Derived&gt;</code>.</p>
<p id="e4a5d5e6">In other words, you can say that the class <code class="code ">C</code> is <em id="d75f93b3" class="">covariant</em> in the parameter <code class="code ">T</code>, or that <code class="code ">T</code> is a <em id="99d8f6da" class="">covariant</em> type parameter. You can think of <code class="code ">C</code> as being a <em id="40066d" class="">producer</em> of <code class="code ">T</code>'s, and NOT a <em id="3288bca5" class="">consumer</em> of <code class="code ">T</code>'s.</p>
<p id="2aa5f1e1">The <code class="code ">out</code> modifier is called a <em id="b0ac0b85" class="">variance annotation</em>, and since it is provided at the type parameter declaration site, it provides <em id="e0ef5494" class="">declaration-site variance</em>. This is in contrast with Java's <em id="7dbdfac6" class="">use-site variance</em> where wildcards in the type usages make the types covariant.</p>
<p id="8167de0c">In addition to <code class="code ">out</code>, Kotlin provides a complementary variance annotation: <code class="code ">in</code>. It makes a type parameter <em id="a39a22c7" class="">contravariant</em>, meaning it can only be consumed and never produced. A good example of a contravariant type is <code class="code ">Comparable</code>:</p>
<pre class="code" data-language="kotlin">interface Comparable&lt;in T&gt; {
    operator fun compareTo(other: T): Int
}

fun demo(x: Comparable&lt;Number&gt;) {
    x.compareTo(1.0) // 1.0 has type Double, which is a subtype of Number
    // Thus, you can assign x to a variable of type Comparable&lt;Double&gt;
    val y: Comparable&lt;Double&gt; = x // OK!
}
</pre>
<p id="80135380">The words <em id="2439c1c6" class="">in</em> and <em id="5136f3a5" class="">out</em> seem to be self-explanatory (as they’ve already been used successfully in C# for quite some time), and so the mnemonic mentioned above is not really needed. It can in fact be rephrased at a higher level of abstraction:</p>
<p id="b15f323"><b id="eb21d3cc" class=""><a href="https://en.wikipedia.org/wiki/Existentialism" id="fd218747" data-external="true" rel="noopener noreferrer">The Existential</a> Transformation: Consumer in, Producer out!</b>:-)</p></section></section><section class="chapter"><h2 id="type-projections" data-toc="generics#type-projections">Type projections</h2>
<section class="chapter"><h3 id="use-site-variance-type-projections" data-toc="generics#use-site-variance-type-projections">Use-site variance: type projections</h3>
<p id="63e7066b">It is very easy to declare a type parameter <code class="code ">T</code> as <code class="code ">out</code> and avoid trouble with subtyping on the use site, but some classes <em id="d427ae0f" class="">can't</em> actually be restricted to only return <code class="code ">T</code>'s! A good example of this is <code class="code ">Array</code>:</p>
<pre class="code" data-language="kotlin">class Array&lt;T&gt;(val size: Int) {
    operator fun get(index: Int): T { ... }
    operator fun set(index: Int, value: T) { ... }
}
</pre>
<p id="3a5d4608">This class can be neither co- nor contravariant in <code class="code ">T</code>. And this imposes certain inflexibilities. Consider the following function:</p>
<pre class="code" data-language="kotlin">fun copy(from: Array&lt;Any&gt;, to: Array&lt;Any&gt;) {
    assert(from.size == to.size)
    for (i in from.indices)
        to[i] = from[i]
}
</pre>
<p id="c0f345b3">This function is supposed to copy items from one array to another. Let's try to apply it in practice:</p>
<pre class="code" data-language="kotlin">val ints: Array&lt;Int&gt; = arrayOf(1, 2, 3)
val any = Array&lt;Any&gt;(3) { "" } 
copy(ints, any)
//   ^ type is Array&lt;Int&gt; but Array&lt;Any&gt; was expected
</pre>
<p id="f7c07f4c">Here you run into the same familiar problem: <code class="code ">Array&lt;T&gt;</code> is <em id="efe70d94" class="">invariant</em> in <code class="code ">T</code>, and so neither <code class="code ">Array&lt;Int&gt;</code> nor <code class="code ">Array&lt;Any&gt;</code> is a subtype of the other. Why not? Again, this is because <code class="code ">copy</code> could have an unexpected behavior, for example, it may attempt to write a <code class="code ">String</code> to <code class="code ">from</code>, and if you actually pass an array of <code class="code ">Int</code> there, a <code class="code ">ClassCastException</code> will be thrown later.</p>
<p id="47a40b4c">To prohibit the <code class="code ">copy</code> function from <em id="9e37a083" class="">writing</em> to <code class="code ">from</code>, you can do the following:</p>
<pre class="code" data-language="kotlin">fun copy(from: Array&lt;out Any&gt;, to: Array&lt;Any&gt;) { ... }
</pre>
<p id="c32b2494">This is <em id="d86ab074" class="">type projection</em>, which means that <code class="code ">from</code> is not a simple array, but is rather a restricted (<em id="f80b870b" class="">projected</em>) one. You can only call methods that return the type parameter <code class="code ">T</code>, which in this case means that you can only call <code class="code ">get()</code>. This is our approach to <em id="2474418b" class="">use-site variance</em>, and it corresponds to Java's <code class="code ">Array&lt;? extends Object&gt;</code> while being slightly simpler.</p>
<p id="f3b7aef2">You can project a type with <code class="code ">in</code> as well:</p>
<pre class="code" data-language="kotlin">fun fill(dest: Array&lt;in String&gt;, value: String) { ... }
</pre>
<p id="224d4883"><code class="code ">Array&lt;in String&gt;</code> corresponds to Java's <code class="code ">Array&lt;? super String&gt;</code>. This means that you can pass an array of <code class="code ">CharSequence</code> or an array of <code class="code ">Object</code> to the <code class="code ">fill()</code> function.</p></section><section class="chapter"><h3 id="star-projections" data-toc="generics#star-projections">Star-projections</h3>
<p id="db2bf7da">Sometimes you want to say that you know nothing about the type argument, but you still want to use it in a safe way. The safe way here is to define such a projection of the generic type, that every concrete instantiation of that generic type will be a subtype of that projection.</p>
<p id="22e2364">Kotlin provides so-called <em id="7c2fa14b" class="">star-projection</em> syntax for this:</p>
<ul class="list _ul" id="c7677688">
<li class="list__item" id="954939ae"><p>For <code class="code ">Foo&lt;out T : TUpper&gt;</code>, where <code class="code ">T</code> is a covariant type parameter with the upper bound <code class="code ">TUpper</code>, <code class="code ">Foo&lt;*&gt;</code> is equivalent to <code class="code ">Foo&lt;out TUpper&gt;</code>. This means that when the <code class="code ">T</code> is unknown you can safely <em id="fd650e8" class="">read</em> values of <code class="code ">TUpper</code> from <code class="code ">Foo&lt;*&gt;</code>.</p></li>
<li class="list__item" id="b296bcc3"><p>For <code class="code ">Foo&lt;in T&gt;</code>, where <code class="code ">T</code> is a contravariant type parameter, <code class="code ">Foo&lt;*&gt;</code> is equivalent to <code class="code ">Foo&lt;in Nothing&gt;</code>. This means there is nothing you can <em id="3e17da06" class="">write</em> to <code class="code ">Foo&lt;*&gt;</code> in a safe way when <code class="code ">T</code> is unknown.</p></li>
<li class="list__item" id="7ca9bc00"><p>For <code class="code ">Foo&lt;T : TUpper&gt;</code>, where <code class="code ">T</code> is an invariant type parameter with the upper bound <code class="code ">TUpper</code>, <code class="code ">Foo&lt;*&gt;</code> is equivalent to <code class="code ">Foo&lt;out TUpper&gt;</code> for reading values and to <code class="code ">Foo&lt;in Nothing&gt;</code> for writing values.</p></li>
</ul>
<p id="b7c316f9">If a generic type has several type parameters, each of them can be projected independently. For example, if the type is declared as <code class="code ">interface Function&lt;in T, out U&gt;</code> you could use the following star-projections:</p>
<ul class="list _ul" id="f0c210b4">
<li class="list__item" id="810a8d6d"><p><code class="code ">Function&lt;*, String&gt;</code> means <code class="code ">Function&lt;in Nothing, String&gt;</code>.</p></li>
<li class="list__item" id="a419101a"><p><code class="code ">Function&lt;Int, *&gt;</code> means <code class="code ">Function&lt;Int, out Any?&gt;</code>.</p></li>
<li class="list__item" id="9c3498f4"><p><code class="code ">Function&lt;*, *&gt;</code> means <code class="code ">Function&lt;in Nothing, out Any?&gt;</code>.</p></li>
</ul>
<aside data-type="note" class="prompt" data-title="" id="2b159e08"><p id="55a9110a">Star-projections are very much like Java's raw types, but safe.</p></aside></section></section><section class="chapter"><h2 id="generic-functions" data-toc="generics#generic-functions">Generic functions</h2>
<p id="7393ef9c">Classes aren’t the only declarations that can have type parameters. Functions can, too. Type parameters are placed <em id="d12bc1cf" class="">before</em> the name of the function:</p>
<pre class="code" data-language="kotlin">fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; {
    // ...
}

fun &lt;T&gt; T.basicToString(): String { // extension function
    // ...
}
</pre>
<p id="2a4e03aa">To call a generic function, specify the type arguments at the call site <em id="1617e27" class="">after</em> the name of the function:</p>
<pre class="code" data-language="kotlin">val l = singletonList&lt;Int&gt;(1)
</pre>
<p id="845f51fa">Type arguments can be omitted if they can be inferred from the context, so the following example works as well:</p>
<pre class="code" data-language="kotlin">val l = singletonList(1)
</pre></section><section class="chapter"><h2 id="generic-constraints" data-toc="generics#generic-constraints">Generic constraints</h2>
<p id="62a9d9a5">The set of all possible types that can be substituted for a given type parameter may be restricted by <em id="8c09a2c4" class="">generic constraints</em>.</p>
<section class="chapter"><h3 id="upper-bounds" data-toc="generics#upper-bounds">Upper bounds</h3>
<p id="56b9bee4">The most common type of constraint is an <em id="dd1a0943" class="">upper bound</em>, which corresponds to Java's <code class="code ">extends</code> keyword:</p>
<pre class="code" data-language="kotlin">fun &lt;T : Comparable&lt;T&gt;&gt; sort(list: List&lt;T&gt;) {  ... }
</pre>
<p id="f9fb5c0d">The type specified after a colon is the <em id="826ef8c0" class="">upper bound</em>, indicating that only a subtype of <code class="code ">Comparable&lt;T&gt;</code> can be substituted for <code class="code ">T</code>. For example:</p>
<pre class="code" data-language="kotlin">sort(listOf(1, 2, 3)) // OK. Int is a subtype of Comparable&lt;Int&gt;
sort(listOf(HashMap&lt;Int, String&gt;())) // Error: HashMap&lt;Int, String&gt; is not a subtype of Comparable&lt;HashMap&lt;Int, String&gt;&gt;
</pre>
<p id="99da54c7">The default upper bound (if there was none specified) is <code class="code ">Any?</code>. Only one upper bound can be specified inside the angle brackets. If the same type parameter needs more than one upper bound, you need a separate <em id="42e7d746" class="">where</em>-clause:</p>
<pre class="code" data-language="kotlin">fun &lt;T&gt; copyWhenGreater(list: List&lt;T&gt;, threshold: T): List&lt;String&gt;
    where T : CharSequence,
          T : Comparable&lt;T&gt; {
    return list.filter { it &gt; threshold }.map { it.toString() }
}
</pre>
<p id="8e780981">The passed type must satisfy all conditions of the <code class="code ">where</code> clause simultaneously. In the above example, the <code class="code ">T</code> type must implement <em id="136afcc9" class="">both</em> <code class="code ">CharSequence</code> and <code class="code ">Comparable</code>.</p></section></section><section class="chapter"><h2 id="type-erasure" data-toc="generics#type-erasure">Type erasure</h2>
<p id="4c49bb28">The type safety checks that Kotlin performs for generic declaration usages are done at compile time. At runtime, the instances of generic types do not hold any information about their actual type arguments. The type information is said to be <em id="a0f4993" class="">erased</em>. For example, the instances of <code class="code ">Foo&lt;Bar&gt;</code> and <code class="code ">Foo&lt;Baz?&gt;</code> are erased to just <code class="code ">Foo&lt;*&gt;</code>.</p>
<p id="a5adfc3b">Therefore, there is no general way to check whether an instance of a generic type was created with certain type arguments at runtime, and the compiler <a href="typecasts#type-erasure-and-generic-type-checks" id="d9159ab7">prohibits such <code class="code ">is</code>-checks</a>.</p>
<p id="d5bdb7e5">Type casts to generic types with concrete type arguments, for example, <code class="code ">foo as List&lt;String&gt;</code>, cannot be checked at runtime. These <a href="typecasts#unchecked-casts" id="952af2b8">unchecked casts</a> can be used when type safety is implied by high-level program logic but cannot be inferred directly by the compiler. The compiler issues a warning on unchecked casts, and at runtime, only the non-generic part is checked (equivalent to <code class="code ">foo as List&lt;*&gt;</code>).</p>
<p id="123a8315">The type arguments of generic function calls are also only checked at compile time. Inside the function bodies, the type parameters cannot be used for type checks, and type casts to type parameters (<code class="code ">foo as T</code>) are unchecked. However, <a href="inline-functions#reified-type-parameters" id="c8034019">reified type parameters</a> of inline functions are substituted by the actual type arguments in the inlined function body at the call sites and so can be used for type checks and casts, with the same restrictions for instances of generic types as described above.</p></section><section class="chapter"><h2 id="underscore-operator-for-type-arguments" data-toc="generics#underscore-operator-for-type-arguments">Underscore operator for type arguments</h2>
<p id="5a2c86cf">The underscore operator <code class="code ">_</code> can be used for type arguments. Use it to automatically infer a type of the argument when other types are explicitly specified:</p>
<pre class="code" data-language="kotlin">abstract class SomeClass&lt;T&gt; {
    abstract fun execute() : T
}

class SomeImplementation : SomeClass&lt;String&gt;() {
    override fun execute(): String = "Test"
}

class OtherImplementation : SomeClass&lt;Int&gt;() {
    override fun execute(): Int = 42
}

object Runner {
    inline fun &lt;reified S: SomeClass&lt;T&gt;, T&gt; run() : T {
        return S::class.java.getDeclaredConstructor().newInstance().execute()
    }
}

fun main() {
    // T is inferred as String because SomeImplementation derives from SomeClass&lt;String&gt;
    val s = Runner.run&lt;SomeImplementation, _&gt;()
    assert(s == "Test")

    // T is inferred as Int because OtherImplementation derives from SomeClass&lt;Int&gt;
    val n = Runner.run&lt;OtherImplementation, _&gt;()
    assert(n == 42)
}
</pre></section><div class="last-modified"> Last modified: 08 August 2022</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="sealed-classes">Sealed classes</a> <a class="navigation-links__next" href="nested-classes">Nested and inner classes</a> </div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://kotlinlang.org/docs/generics.html" class="_attribution-link" target="_blank">https://kotlinlang.org/docs/generics.html</a>
  </p>
</div>
