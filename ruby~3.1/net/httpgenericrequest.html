<h1 id="class-Net::HTTPGenericRequest" class="class"> class Net::HTTPGenericRequest </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="../object">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="httpheader">Net::HTTPHeader</a></dd>
</dl> <section class="description"> <p><a href="httpgenericrequest"><code>HTTPGenericRequest</code></a> is the parent of the <a href="httprequest"><code>Net::HTTPRequest</code></a> class. Do not use this directly; use a subclass of <a href="httprequest"><code>Net::HTTPRequest</code></a>.</p> <p>Mixes in the <a href="httpheader"><code>Net::HTTPHeader</code></a> module to provide easier access to HTTP headers.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-body"> <span class="method-name">body</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-body_stream"> <span class="method-name">body_stream</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-decode_content"> <span class="method-name">decode_content</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Automatically set to false if the user sets the Accept-Encoding header. This indicates they wish to handle Content-encoding in responses themselves.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-method"> <span class="method-name">method</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-path"> <span class="method-name">path</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-uri"> <span class="method-name">uri</span><span class="attribute-access-type">[R]</span> </div>  </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-name">new</span><span class="method-args">(m, reqbody, resbody, uri_or_path, initheader = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/net/http/generic_request.rb, line 11
def initialize(m, reqbody, resbody, uri_or_path, initheader = nil)
  @method = m
  @request_has_body = reqbody
  @response_has_body = resbody

  if URI === uri_or_path then
    raise ArgumentError, "not an HTTP URI" unless URI::HTTP === uri_or_path
    raise ArgumentError, "no host component for URI" unless uri_or_path.hostname
    @uri = uri_or_path.dup
    host = @uri.hostname.dup
    host &lt;&lt; ":".freeze &lt;&lt; @uri.port.to_s if @uri.port != @uri.default_port
    @path = uri_or_path.request_uri
    raise ArgumentError, "no HTTP request path given" unless @path
  else
    @uri = nil
    host = nil
    raise ArgumentError, "no HTTP request path given" unless uri_or_path
    raise ArgumentError, "HTTP request path is empty" if uri_or_path.empty?
    @path = uri_or_path.dup
  end

  @decode_content = false

  if Net::HTTP::HAVE_ZLIB then
    if !initheader ||
       !initheader.keys.any? { |k|
         %w[accept-encoding range].include? k.downcase
       } then
      @decode_content = true if @response_has_body
      initheader = initheader ? initheader.dup : {}
      initheader["accept-encoding"] =
        "gzip;q=1.0,deflate;q=0.6,identity;q=0.3"
    end
  end

  initialize_http_header initheader
  self['Accept'] ||= '*/*'
  self['User-Agent'] ||= 'Ruby'
  self['Host'] ||= host if host
  @body = nil
  @body_stream = nil
  @body_data = nil
end</pre> </div>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-body-3D"> <span class="method-name">body=</span><span class="method-args">(str)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="body-3D-source"> <pre class="ruby" data-language="ruby"># File lib/net/http/generic_request.rb, line 93
def body=(str)
  @body = str
  @body_stream = nil
  @body_data = nil
  str
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-body_exist-3F"> <span class="method-name">body_exist?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="body_exist-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/http/generic_request.rb, line 86
def body_exist?
  warn "Net::HTTPRequest#body_exist? is obsolete; use response_body_permitted?", uplevel: 1 if $VERBOSE
  response_body_permitted?
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-body_stream-3D"> <span class="method-name">body_stream=</span><span class="method-args">(input)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="body_stream-3D-source"> <pre class="ruby" data-language="ruby"># File lib/net/http/generic_request.rb, line 102
def body_stream=(input)
  @body = nil
  @body_stream = input
  @body_data = nil
  input
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inspect"> <span class="method-name">inspect</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="ruby" data-language="ruby"># File lib/net/http/generic_request.rb, line 64
def inspect
  "\#&lt;#{self.class} #{@method}&gt;"
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-request_body_permitted-3F"> <span class="method-name">request_body_permitted?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="request_body_permitted-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/http/generic_request.rb, line 78
def request_body_permitted?
  @request_has_body
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-response_body_permitted-3F"> <span class="method-name">response_body_permitted?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="response_body_permitted-3F-source"> <pre class="ruby" data-language="ruby"># File lib/net/http/generic_request.rb, line 82
def response_body_permitted?
  @response_has_body
end</pre> </div>  </div> </div> </section> <section id="private-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Private Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-encode_multipart_form_data"> <span class="method-name">encode_multipart_form_data</span><span class="method-args">(out, params, opt)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="encode_multipart_form_data-source"> <pre class="ruby" data-language="ruby"># File lib/net/http/generic_request.rb, line 235
def encode_multipart_form_data(out, params, opt)
  charset = opt[:charset]
  boundary = opt[:boundary]
  require 'securerandom' unless defined?(SecureRandom)
  boundary ||= SecureRandom.urlsafe_base64(40)
  chunked_p = chunked?

  buf = ''
  params.each do |key, value, h={}|
    key = quote_string(key, charset)
    filename =
      h.key?(:filename) ? h[:filename] :
      value.respond_to?(:to_path) ? File.basename(value.to_path) :
      nil

    buf &lt;&lt; "--#{boundary}\r\n"
    if filename
      filename = quote_string(filename, charset)
      type = h[:content_type] || 'application/octet-stream'
      buf &lt;&lt; "Content-Disposition: form-data; " \
        "name=\"#{key}\"; filename=\"#{filename}\"\r\n" \
        "Content-Type: #{type}\r\n\r\n"
      if !out.respond_to?(:write) || !value.respond_to?(:read)
        # if +out+ is not an IO or +value+ is not an IO
        buf &lt;&lt; (value.respond_to?(:read) ? value.read : value)
      elsif value.respond_to?(:size) &amp;&amp; chunked_p
        # if +out+ is an IO and +value+ is a File, use IO.copy_stream
        flush_buffer(out, buf, chunked_p)
        out &lt;&lt; "%x\r\n" % value.size if chunked_p
        IO.copy_stream(value, out)
        out &lt;&lt; "\r\n" if chunked_p
      else
        # +out+ is an IO, and +value+ is not a File but an IO
        flush_buffer(out, buf, chunked_p)
        1 while flush_buffer(out, value.read(4096), chunked_p)
      end
    else
      # non-file field:
      #   HTML5 says, "The parts of the generated multipart/form-data
      #   resource that correspond to non-file fields must not have a
      #   Content-Type header specified."
      buf &lt;&lt; "Content-Disposition: form-data; name=\"#{key}\"\r\n\r\n"
      buf &lt;&lt; (value.respond_to?(:read) ? value.read : value)
    end
    buf &lt;&lt; "\r\n"
  end
  buf &lt;&lt; "--#{boundary}--\r\n"
  flush_buffer(out, buf, chunked_p)
  out &lt;&lt; "0\r\n\r\n" if chunked_p
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-flush_buffer"> <span class="method-name">flush_buffer</span><span class="method-args">(out, buf, chunked_p)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="flush_buffer-source"> <pre class="ruby" data-language="ruby"># File lib/net/http/generic_request.rb, line 291
def flush_buffer(out, buf, chunked_p)
  return unless buf
  out &lt;&lt; "%x\r\n"%buf.bytesize if chunked_p
  out &lt;&lt; buf
  out &lt;&lt; "\r\n" if chunked_p
  buf.clear
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-quote_string"> <span class="method-name">quote_string</span><span class="method-args">(str, charset)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="quote_string-source"> <pre class="ruby" data-language="ruby"># File lib/net/http/generic_request.rb, line 286
def quote_string(str, charset)
  str = str.encode(charset, fallback:-&gt;(c){'&amp;#%d;'%c.encode("UTF-8").ord}) if charset
  str.gsub(/[\\"]/, '\\\\\&amp;')
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-send_request_with_body"> <span class="method-name">send_request_with_body</span><span class="method-args">(sock, ver, path, body)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="send_request_with_body-source"> <pre class="ruby" data-language="ruby"># File lib/net/http/generic_request.rb, line 183
def send_request_with_body(sock, ver, path, body)
  self.content_length = body.bytesize
  delete 'Transfer-Encoding'
  supply_default_content_type
  write_header sock, ver, path
  wait_for_continue sock, ver if sock.continue_timeout
  sock.write body
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-send_request_with_body_data"> <span class="method-name">send_request_with_body_data</span><span class="method-args">(sock, ver, path, params)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="send_request_with_body_data-source"> <pre class="ruby" data-language="ruby"># File lib/net/http/generic_request.rb, line 209
def send_request_with_body_data(sock, ver, path, params)
  if /\Amultipart\/form-data\z/i !~ self.content_type
    self.content_type = 'application/x-www-form-urlencoded'
    return send_request_with_body(sock, ver, path, URI.encode_www_form(params))
  end

  opt = @form_option.dup
  require 'securerandom' unless defined?(SecureRandom)
  opt[:boundary] ||= SecureRandom.urlsafe_base64(40)
  self.set_content_type(self.content_type, boundary: opt[:boundary])
  if chunked?
    write_header sock, ver, path
    encode_multipart_form_data(sock, params, opt)
  else
    require 'tempfile'
    file = Tempfile.new('multipart')
    file.binmode
    encode_multipart_form_data(file, params, opt)
    file.rewind
    self.content_length = file.size
    write_header sock, ver, path
    IO.copy_stream(file, sock)
    file.close(true)
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-send_request_with_body_stream"> <span class="method-name">send_request_with_body_stream</span><span class="method-args">(sock, ver, path, f)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="send_request_with_body_stream-source"> <pre class="ruby" data-language="ruby"># File lib/net/http/generic_request.rb, line 192
def send_request_with_body_stream(sock, ver, path, f)
  unless content_length() or chunked?
    raise ArgumentError,
        "Content-Length not given and Transfer-Encoding is not `chunked'"
  end
  supply_default_content_type
  write_header sock, ver, path
  wait_for_continue sock, ver if sock.continue_timeout
  if chunked?
    chunker = Chunker.new(sock)
    IO.copy_stream(f, chunker)
    chunker.finish
  else
    IO.copy_stream(f, sock)
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-supply_default_content_type"> <span class="method-name">supply_default_content_type</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="supply_default_content_type-source"> <pre class="ruby" data-language="ruby"># File lib/net/http/generic_request.rb, line 299
def supply_default_content_type
  return if content_type()
  warn 'net/http: Content-Type did not set; using application/x-www-form-urlencoded', uplevel: 1 if $VERBOSE
  set_content_type 'application/x-www-form-urlencoded'
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-wait_for_continue"> <span class="method-name">wait_for_continue</span><span class="method-args">(sock, ver)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="wait_for_continue-source"> <pre class="ruby" data-language="ruby"># File lib/net/http/generic_request.rb, line 309
def wait_for_continue(sock, ver)
  if ver &gt;= '1.1' and @header['expect'] and
      @header['expect'].include?('100-continue')
    if sock.io.to_io.wait_readable(sock.continue_timeout)
      res = Net::HTTPResponse.read_new(sock)
      unless res.kind_of?(Net::HTTPContinue)
        res.decode_content = @decode_content
        throw :response, res
      end
    end
  end
end</pre> </div> <p>Waits up to the continue timeout for a response from the server provided we’re speaking HTTP 1.1 and are expecting a 100-continue response.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-write_header"> <span class="method-name">write_header</span><span class="method-args">(sock, ver, path)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="write_header-source"> <pre class="ruby" data-language="ruby"># File lib/net/http/generic_request.rb, line 322
def write_header(sock, ver, path)
  reqline = "#{@method} #{path} HTTP/#{ver}"
  if /[\r\n]/ =~ reqline
    raise ArgumentError, "A Request-Line must not contain CR or LF"
  end
  buf = ""
  buf &lt;&lt; reqline &lt;&lt; "\r\n"
  each_capitalized do |k,v|
    buf &lt;&lt; "#{k}: #{v}\r\n"
  end
  buf &lt;&lt; "\r\n"
  sock.write buf
end</pre> </div>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
