<h1 id="class-MatchData" class="class"> class MatchData </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object">Object</a></dd>
</dl> <section class="description"> <p><a href="matchdata"><code>MatchData</code></a> encapsulates the result of matching a <a href="regexp"><code>Regexp</code></a> against string. It is returned by <a href="regexp#method-i-match"><code>Regexp#match</code></a> and <a href="string#method-i-match"><code>String#match</code></a>, and also stored in a global variable returned by <a href="regexp#method-c-last_match"><code>Regexp.last_match</code></a>.</p> <p>Usage:</p> <pre class="ruby" data-language="ruby">url = 'https://docs.ruby-lang.org/en/2.5.0/MatchData.html'
m = url.match(/(\d\.?)+/)   # =&gt; #&lt;MatchData "2.5.0" 1:"0"&gt;
m.string                    # =&gt; "https://docs.ruby-lang.org/en/2.5.0/MatchData.html"
m.regexp                    # =&gt; /(\d\.?)+/
# entire matched substring:
m[0]                        # =&gt; "2.5.0"

# Working with unnamed captures
m = url.match(%r{([^/]+)/([^/]+)\.html$})
m.captures                  # =&gt; ["2.5.0", "MatchData"]
m[1]                        # =&gt; "2.5.0"
m.values_at(1, 2)           # =&gt; ["2.5.0", "MatchData"]

# Working with named captures
m = url.match(%r{(?&lt;version&gt;[^/]+)/(?&lt;module&gt;[^/]+)\.html$})
m.captures                  # =&gt; ["2.5.0", "MatchData"]
m.named_captures            # =&gt; {"version"=&gt;"2.5.0", "module"=&gt;"MatchData"}
m[:version]                 # =&gt; "2.5.0"
m.values_at(:version, :module)
                            # =&gt; ["2.5.0", "MatchData"]
# Numerical indexes are working, too
m[1]                        # =&gt; "2.5.0"
m.values_at(1, 2)           # =&gt; ["2.5.0", "MatchData"]
</pre> <h2 id="class-MatchData-label-Global+variables+equivalence">Global variables equivalence</h2> <p>Parts of last <a href="matchdata"><code>MatchData</code></a> (returned by <a href="regexp#method-c-last_match"><code>Regexp.last_match</code></a>) are also aliased as global variables:</p> <ul>
<li> <p><code>$~</code> is <a href="regexp#method-c-last_match"><code>Regexp.last_match</code></a>;</p> </li>
<li> <p><code>$&amp;</code> is <a href="regexp#method-c-last_match"><code>Regexp.last_match</code></a><code>[ 0 ]</code>;</p> </li>
<li> <p><code>$1</code>, <code>$2</code>, and so on are <a href="regexp#method-c-last_match"><code>Regexp.last_match</code></a><code>[ i ]</code> (captures by number);</p> </li>
<li> <p><code>$`</code> is <a href="regexp#method-c-last_match"><code>Regexp.last_match</code></a><code>.pre_match</code>;</p> </li>
<li> <p><code>$'</code> is <a href="regexp#method-c-last_match"><code>Regexp.last_match</code></a><code>.post_match</code>;</p> </li>
<li> <p><code>$+</code> is <a href="regexp#method-c-last_match"><code>Regexp.last_match</code></a><code>[ -1 ]</code> (the last capture).</p> </li>
</ul> <p>See also “Special global variables” section in <a href="regexp"><code>Regexp</code></a> documentation.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-3D-3D"> <span class="method-callseq"> mtch == mtch2 → true or false </span> </div> <div class="method-description"> <p>Equality—Two matchdata are equal if their target strings, patterns, and matched positions are identical.</p> </div> <div class="aliases"> Alias for: <a href="matchdata#method-i-eql-3F">eql?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-5B-5D"> <span class="method-callseq"> mtch[i] → str or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> mtch[start, length] → array </span> </div> <div class="method-heading"> <span class="method-callseq"> mtch[range] → array </span> </div> <div class="method-heading"> <span class="method-callseq"> mtch[name] → str or nil </span> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="c" data-language="c">static VALUE
match_aref(int argc, VALUE *argv, VALUE match)
{
    VALUE idx, length;

    match_check(match);
    rb_scan_args(argc, argv, "11", &amp;idx, &amp;length);

    if (NIL_P(length)) {
        if (FIXNUM_P(idx)) {
            return rb_reg_nth_match(FIX2INT(idx), match);
        }
        else {
            int num = namev_to_backref_number(RMATCH_REGS(match), RMATCH(match)-&gt;regexp, idx);
            if (num &gt;= 0) {
                return rb_reg_nth_match(num, match);
            }
            else {
                return match_ary_aref(match, idx, Qnil);
            }
        }
    }
    else {
        long beg = NUM2LONG(idx);
        long len = NUM2LONG(length);
        long num_regs = RMATCH_REGS(match)-&gt;num_regs;
        if (len &lt; 0) {
            return Qnil;
        }
        if (beg &lt; 0) {
            beg += num_regs;
            if (beg &lt; 0) return Qnil;
        }
        else if (beg &gt; num_regs) {
            return Qnil;
        }
        else if (beg+len &gt; num_regs) {
            len = num_regs - beg;
        }
        return match_ary_subseq(match, beg, len, Qnil);
    }
}</pre> </div> <p>Match Reference – <a href="matchdata"><code>MatchData</code></a> acts as an array, and may be accessed using the normal array indexing techniques. <code>mtch[0]</code> is equivalent to the special variable <code>$&amp;</code>, and returns the entire matched string. <code>mtch[1]</code>, <code>mtch[2]</code>, and so on return the values of the matched backreferences (portions of the pattern between parentheses).</p> <pre class="ruby" data-language="ruby">m = /(.)(.)(\d+)(\d)/.match("THX1138.")
m          #=&gt; #&lt;MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8"&gt;
m[0]       #=&gt; "HX1138"
m[1, 2]    #=&gt; ["H", "X"]
m[1..3]    #=&gt; ["H", "X", "113"]
m[-3, 2]   #=&gt; ["X", "113"]

m = /(?&lt;foo&gt;a+)b/.match("ccaaab")
m          #=&gt; #&lt;MatchData "aaab" foo:"aaa"&gt;
m["foo"]   #=&gt; "aaa"
m[:foo]    #=&gt; "aaa"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-begin"> <span class="method-callseq"> begin(n) → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="begin-source"> <pre class="c" data-language="c">static VALUE
match_begin(VALUE match, VALUE n)
{
    int i = match_backref_number(match, n);
    struct re_registers *regs = RMATCH_REGS(match);

    match_check(match);
    backref_number_check(regs, i);

    if (BEG(i) &lt; 0)
        return Qnil;

    update_char_offset(match);
    return INT2FIX(RMATCH(match)-&gt;rmatch-&gt;char_offset[i].beg);
}</pre> </div> <p>Returns the offset of the start of the <em>n</em>th element of the match array in the string. <em>n</em> can be a string or symbol to reference a named capture.</p> <pre class="ruby" data-language="ruby">m = /(.)(.)(\d+)(\d)/.match("THX1138.")
m.begin(0)       #=&gt; 1
m.begin(2)       #=&gt; 2

m = /(?&lt;foo&gt;.)(.)(?&lt;bar&gt;.)/.match("hoge")
p m.begin(:foo)  #=&gt; 0
p m.begin(:bar)  #=&gt; 2
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-captures"> <span class="method-callseq"> captures → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="captures-source"> <pre class="c" data-language="c">static VALUE
match_captures(VALUE match)
{
    return match_array(match, 1);
}</pre> </div> <p>Returns the array of captures; equivalent to <code>mtch.to_a[1..-1]</code>.</p> <pre class="ruby" data-language="ruby">f1,f2,f3,f4 = /(.)(.)(\d+)(\d)/.match("THX1138.").captures
f1    #=&gt; "H"
f2    #=&gt; "X"
f3    #=&gt; "113"
f4    #=&gt; "8"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-end"> <span class="method-callseq"> end(n) → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="end-source"> <pre class="c" data-language="c">static VALUE
match_end(VALUE match, VALUE n)
{
    int i = match_backref_number(match, n);
    struct re_registers *regs = RMATCH_REGS(match);

    match_check(match);
    backref_number_check(regs, i);

    if (BEG(i) &lt; 0)
        return Qnil;

    update_char_offset(match);
    return INT2FIX(RMATCH(match)-&gt;rmatch-&gt;char_offset[i].end);
}</pre> </div> <p>Returns the offset of the character immediately following the end of the <em>n</em>th element of the match array in the string. <em>n</em> can be a string or symbol to reference a named capture.</p> <pre class="ruby" data-language="ruby">m = /(.)(.)(\d+)(\d)/.match("THX1138.")
m.end(0)         #=&gt; 7
m.end(2)         #=&gt; 3

m = /(?&lt;foo&gt;.)(.)(?&lt;bar&gt;.)/.match("hoge")
p m.end(:foo)    #=&gt; 1
p m.end(:bar)    #=&gt; 3
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-eql-3F"> <span class="method-callseq"> eql?(mtch2) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="eql-3F-source"> <pre class="c" data-language="c">static VALUE
match_equal(VALUE match1, VALUE match2)
{
    const struct re_registers *regs1, *regs2;

    if (match1 == match2) return Qtrue;
    if (!RB_TYPE_P(match2, T_MATCH)) return Qfalse;
    if (!RMATCH(match1)-&gt;regexp || !RMATCH(match2)-&gt;regexp) return Qfalse;
    if (!rb_str_equal(RMATCH(match1)-&gt;str, RMATCH(match2)-&gt;str)) return Qfalse;
    if (!rb_reg_equal(match_regexp(match1), match_regexp(match2))) return Qfalse;
    regs1 = RMATCH_REGS(match1);
    regs2 = RMATCH_REGS(match2);
    if (regs1-&gt;num_regs != regs2-&gt;num_regs) return Qfalse;
    if (memcmp(regs1-&gt;beg, regs2-&gt;beg, regs1-&gt;num_regs * sizeof(*regs1-&gt;beg))) return Qfalse;
    if (memcmp(regs1-&gt;end, regs2-&gt;end, regs1-&gt;num_regs * sizeof(*regs1-&gt;end))) return Qfalse;
    return Qtrue;
}</pre> </div> <p>Equality—Two matchdata are equal if their target strings, patterns, and matched positions are identical.</p>  </div> <div class="aliases"> Also aliased as: <a href="matchdata#method-i-3D-3D">==</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-hash"> <span class="method-callseq"> hash → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="hash-source"> <pre class="c" data-language="c">static VALUE
match_hash(VALUE match)
{
    const struct re_registers *regs;
    st_index_t hashval;

    match_check(match);
    hashval = rb_hash_start(rb_str_hash(RMATCH(match)-&gt;str));
    hashval = rb_hash_uint(hashval, reg_hash(match_regexp(match)));
    regs = RMATCH_REGS(match);
    hashval = rb_hash_uint(hashval, regs-&gt;num_regs);
    hashval = rb_hash_uint(hashval, rb_memhash(regs-&gt;beg, regs-&gt;num_regs * sizeof(*regs-&gt;beg)));
    hashval = rb_hash_uint(hashval, rb_memhash(regs-&gt;end, regs-&gt;num_regs * sizeof(*regs-&gt;end)));
    hashval = rb_hash_end(hashval);
    return ST2FIX(hashval);
}</pre> </div> <p>Produce a hash based on the target string, regexp and matched positions of this matchdata.</p> <p>See also <a href="object#method-i-hash"><code>Object#hash</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inspect"> <span class="method-callseq"> inspect → str </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="c" data-language="c">static VALUE
match_inspect(VALUE match)
{
    VALUE cname = rb_class_path(rb_obj_class(match));
    VALUE str;
    int i;
    struct re_registers *regs = RMATCH_REGS(match);
    int num_regs = regs-&gt;num_regs;
    struct backref_name_tag *names;
    VALUE regexp = RMATCH(match)-&gt;regexp;

    if (regexp == 0) {
        return rb_sprintf("#&lt;%"PRIsVALUE":%p&gt;", cname, (void*)match);
    }
    else if (NIL_P(regexp)) {
        return rb_sprintf("#&lt;%"PRIsVALUE": %"PRIsVALUE"&gt;",
                          cname, rb_reg_nth_match(0, match));
    }

    names = ALLOCA_N(struct backref_name_tag, num_regs);
    MEMZERO(names, struct backref_name_tag, num_regs);

    onig_foreach_name(RREGEXP_PTR(regexp),
            match_inspect_name_iter, names);

    str = rb_str_buf_new2("#&lt;");
    rb_str_append(str, cname);

    for (i = 0; i &lt; num_regs; i++) {
        VALUE v;
        rb_str_buf_cat2(str, " ");
        if (0 &lt; i) {
            if (names[i].name)
                rb_str_buf_cat(str, (const char *)names[i].name, names[i].len);
            else {
                rb_str_catf(str, "%d", i);
            }
            rb_str_buf_cat2(str, ":");
        }
        v = rb_reg_nth_match(i, match);
        if (NIL_P(v))
            rb_str_buf_cat2(str, "nil");
        else
            rb_str_buf_append(str, rb_str_inspect(v));
    }
    rb_str_buf_cat2(str, "&gt;");

    return str;
}</pre> </div> <p>Returns a printable version of <em>mtch</em>.</p> <pre class="ruby" data-language="ruby">puts /.$/.match("foo").inspect
#=&gt; #&lt;MatchData "o"&gt;

puts /(.)(.)(.)/.match("foo").inspect
#=&gt; #&lt;MatchData "foo" 1:"f" 2:"o" 3:"o"&gt;

puts /(.)(.)?(.)/.match("fo").inspect
#=&gt; #&lt;MatchData "fo" 1:"f" 2:nil 3:"o"&gt;

puts /(?&lt;foo&gt;.)(?&lt;bar&gt;.)(?&lt;baz&gt;.)/.match("hoge").inspect
#=&gt; #&lt;MatchData "hog" foo:"h" bar:"o" baz:"g"&gt;
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-length"> <span class="method-callseq"> length → integer </span> </div> <div class="method-description"> <p>Returns the number of elements in the match array.</p> <pre class="ruby" data-language="ruby">m = /(.)(.)(\d+)(\d)/.match("THX1138.")
m.length   #=&gt; 5
m.size     #=&gt; 5
</pre> </div> <div class="aliases"> Alias for: <a href="matchdata#method-i-size">size</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-match"> <span class="method-callseq"> match(n) → string or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="match-source"> <pre class="c" data-language="c">static VALUE
match_nth(VALUE match, VALUE n)
{
    int i = match_backref_number(match, n);
    struct re_registers *regs = RMATCH_REGS(match);

    backref_number_check(regs, i);

    long start = BEG(i), end = END(i);
    if (start &lt; 0)
        return Qnil;

    return rb_str_subseq(RMATCH(match)-&gt;str, start, end - start);
}</pre> </div> <p>Returns the captured substring corresponding to the argument. <em>n</em> can be a string or symbol to reference a named capture.</p> <pre class="ruby" data-language="ruby">m = /(.)(.)(\d+)(\d)(\w)?/.match("THX1138.")
m.match(0)       #=&gt; "HX1138"
m.match(4)       #=&gt; "8"
m.match(5)       #=&gt; nil

m = /(?&lt;foo&gt;.)(.)(?&lt;bar&gt;.+)/.match("hoge")
m.match(:foo)    #=&gt; "h"
m.match(:bar)    #=&gt; "ge"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-match_length"> <span class="method-callseq"> match_length(n) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="match_length-source"> <pre class="c" data-language="c">static VALUE
match_nth_length(VALUE match, VALUE n)
{
    int i = match_backref_number(match, n);
    struct re_registers *regs = RMATCH_REGS(match);

    match_check(match);
    backref_number_check(regs, i);

    if (BEG(i) &lt; 0)
        return Qnil;

    update_char_offset(match);
    const struct rmatch_offset *const ofs =
        &amp;RMATCH(match)-&gt;rmatch-&gt;char_offset[i];
    return LONG2NUM(ofs-&gt;end - ofs-&gt;beg);
}</pre> </div> <p>Returns the length of the captured substring corresponding to the argument. <em>n</em> can be a string or symbol to reference a named capture.</p> <pre class="ruby" data-language="ruby">m = /(.)(.)(\d+)(\d)(\w)?/.match("THX1138.")
m.match_length(0)       #=&gt; 6
m.match_length(4)       #=&gt; 1
m.match_length(5)       #=&gt; nil

m = /(?&lt;foo&gt;.)(.)(?&lt;bar&gt;.+)/.match("hoge")
m.match_length(:foo)    #=&gt; 1
m.match_length(:bar)    #=&gt; 2
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-named_captures"> <span class="method-callseq"> named_captures → hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="named_captures-source"> <pre class="c" data-language="c">static VALUE
match_named_captures(VALUE match)
{
    VALUE hash;
    struct MEMO *memo;

    match_check(match);
    if (NIL_P(RMATCH(match)-&gt;regexp))
        return rb_hash_new();

    hash = rb_hash_new();
    memo = MEMO_NEW(hash, match, 0);

    onig_foreach_name(RREGEXP(RMATCH(match)-&gt;regexp)-&gt;ptr, match_named_captures_iter, (void*)memo);

    return hash;
}</pre> </div> <p>Returns a <a href="hash"><code>Hash</code></a> using named capture.</p> <p>A key of the hash is a name of the named captures. A value of the hash is a string of last successful capture of corresponding group.</p> <pre class="ruby" data-language="ruby">m = /(?&lt;a&gt;.)(?&lt;b&gt;.)/.match("01")
m.named_captures #=&gt; {"a" =&gt; "0", "b" =&gt; "1"}

m = /(?&lt;a&gt;.)(?&lt;b&gt;.)?/.match("0")
m.named_captures #=&gt; {"a" =&gt; "0", "b" =&gt; nil}

m = /(?&lt;a&gt;.)(?&lt;a&gt;.)/.match("01")
m.named_captures #=&gt; {"a" =&gt; "1"}

m = /(?&lt;a&gt;x)|(?&lt;a&gt;y)/.match("x")
m.named_captures #=&gt; {"a" =&gt; "x"}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-names"> <span class="method-callseq"> names → [name1, name2, ...] </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="names-source"> <pre class="c" data-language="c">static VALUE
match_names(VALUE match)
{
    match_check(match);
    if (NIL_P(RMATCH(match)-&gt;regexp))
        return rb_ary_new_capa(0);
    return rb_reg_names(RMATCH(match)-&gt;regexp);
}</pre> </div> <p>Returns a list of names of captures as an array of strings. This is the same as mtch.regexp.names.</p> <pre class="ruby" data-language="ruby">/(?&lt;foo&gt;.)(?&lt;bar&gt;.)(?&lt;baz&gt;.)/.match("hoge").names
#=&gt; ["foo", "bar", "baz"]

m = /(?&lt;x&gt;.)(?&lt;y&gt;.)?/.match("a") #=&gt; #&lt;MatchData "a" x:"a" y:nil&gt;
m.names                          #=&gt; ["x", "y"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-offset"> <span class="method-callseq"> offset(n) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="offset-source"> <pre class="c" data-language="c">static VALUE
match_offset(VALUE match, VALUE n)
{
    int i = match_backref_number(match, n);
    struct re_registers *regs = RMATCH_REGS(match);

    match_check(match);
    backref_number_check(regs, i);

    if (BEG(i) &lt; 0)
        return rb_assoc_new(Qnil, Qnil);

    update_char_offset(match);
    return rb_assoc_new(INT2FIX(RMATCH(match)-&gt;rmatch-&gt;char_offset[i].beg),
                        INT2FIX(RMATCH(match)-&gt;rmatch-&gt;char_offset[i].end));
}</pre> </div> <p>Returns a two-element array containing the beginning and ending offsets of the <em>n</em>th match. <em>n</em> can be a string or symbol to reference a named capture.</p> <pre class="ruby" data-language="ruby">m = /(.)(.)(\d+)(\d)/.match("THX1138.")
m.offset(0)      #=&gt; [1, 7]
m.offset(4)      #=&gt; [6, 7]

m = /(?&lt;foo&gt;.)(.)(?&lt;bar&gt;.)/.match("hoge")
p m.offset(:foo) #=&gt; [0, 1]
p m.offset(:bar) #=&gt; [2, 3]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-post_match"> <span class="method-callseq"> post_match → str </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="post_match-source"> <pre class="c" data-language="c">VALUE
rb_reg_match_post(VALUE match)
{
    VALUE str;
    long pos;
    struct re_registers *regs;

    if (NIL_P(match)) return Qnil;
    match_check(match);
    regs = RMATCH_REGS(match);
    if (BEG(0) == -1) return Qnil;
    str = RMATCH(match)-&gt;str;
    pos = END(0);
    str = rb_str_subseq(str, pos, RSTRING_LEN(str) - pos);
    return str;
}</pre> </div> <p>Returns the portion of the original string after the current match. Equivalent to the special variable <code>$'</code>.</p> <pre class="ruby" data-language="ruby">m = /(.)(.)(\d+)(\d)/.match("THX1138: The Movie")
m.post_match   #=&gt; ": The Movie"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pre_match"> <span class="method-callseq"> pre_match → str </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pre_match-source"> <pre class="c" data-language="c">VALUE
rb_reg_match_pre(VALUE match)
{
    VALUE str;
    struct re_registers *regs;

    if (NIL_P(match)) return Qnil;
    match_check(match);
    regs = RMATCH_REGS(match);
    if (BEG(0) == -1) return Qnil;
    str = rb_str_subseq(RMATCH(match)-&gt;str, 0, BEG(0));
    return str;
}</pre> </div> <p>Returns the portion of the original string before the current match. Equivalent to the special variable <code>$`</code>.</p> <pre class="ruby" data-language="ruby">m = /(.)(.)(\d+)(\d)/.match("THX1138.")
m.pre_match   #=&gt; "T"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-regexp"> <span class="method-callseq"> regexp → regexp </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="regexp-source"> <pre class="c" data-language="c">static VALUE
match_regexp(VALUE match)
{
    VALUE regexp;
    match_check(match);
    regexp = RMATCH(match)-&gt;regexp;
    if (NIL_P(regexp)) {
        VALUE str = rb_reg_nth_match(0, match);
        regexp = rb_reg_regcomp(rb_reg_quote(str));
        RMATCH(match)-&gt;regexp = regexp;
    }
    return regexp;
}</pre> </div> <p>Returns the regexp.</p> <pre class="ruby" data-language="ruby">m = /a.*b/.match("abc")
m.regexp #=&gt; /a.*b/
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-size"> <span class="method-callseq"> size → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="size-source"> <pre class="c" data-language="c">static VALUE
match_size(VALUE match)
{
    match_check(match);
    return INT2FIX(RMATCH_REGS(match)-&gt;num_regs);
}</pre> </div> <p>Returns the number of elements in the match array.</p> <pre class="ruby" data-language="ruby">m = /(.)(.)(\d+)(\d)/.match("THX1138.")
m.length   #=&gt; 5
m.size     #=&gt; 5
</pre>  </div> <div class="aliases"> Also aliased as: <a href="matchdata#method-i-length">length</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-string"> <span class="method-callseq"> string → str </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="string-source"> <pre class="c" data-language="c">static VALUE
match_string(VALUE match)
{
    match_check(match);
    return RMATCH(match)-&gt;str;  /* str is frozen */
}</pre> </div> <p>Returns a frozen copy of the string passed in to <code>match</code>.</p> <pre class="ruby" data-language="ruby">m = /(.)(.)(\d+)(\d)/.match("THX1138.")
m.string   #=&gt; "THX1138."
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_a"> <span class="method-callseq"> to_a → anArray </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_a-source"> <pre class="c" data-language="c">static VALUE
match_to_a(VALUE match)
{
    return match_array(match, 0);
}</pre> </div> <p>Returns the array of matches.</p> <pre class="ruby" data-language="ruby">m = /(.)(.)(\d+)(\d)/.match("THX1138.")
m.to_a   #=&gt; ["HX1138", "H", "X", "113", "8"]
</pre> <p>Because <code>to_a</code> is called when expanding <code>*</code><em>variable</em>, there’s a useful assignment shortcut for extracting matched fields. This is slightly slower than accessing the fields directly (as an intermediate array is generated).</p> <pre class="ruby" data-language="ruby">all,f1,f2,f3 = * /(.)(.)(\d+)(\d)/.match("THX1138.")
all   #=&gt; "HX1138"
f1    #=&gt; "H"
f2    #=&gt; "X"
f3    #=&gt; "113"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_s"> <span class="method-callseq"> to_s → str </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_s-source"> <pre class="c" data-language="c">static VALUE
match_to_s(VALUE match)
{
    VALUE str = rb_reg_last_match(match);

    match_check(match);
    if (NIL_P(str)) str = rb_str_new(0,0);
    return str;
}</pre> </div> <p>Returns the entire matched string.</p> <pre class="ruby" data-language="ruby">m = /(.)(.)(\d+)(\d)/.match("THX1138.")
m.to_s   #=&gt; "HX1138"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-values_at"> <span class="method-callseq"> values_at(index, ...) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="values_at-source"> <pre class="c" data-language="c">static VALUE
match_values_at(int argc, VALUE *argv, VALUE match)
{
    VALUE result;
    int i;

    match_check(match);
    result = rb_ary_new2(argc);

    for (i=0; i&lt;argc; i++) {
        if (FIXNUM_P(argv[i])) {
            rb_ary_push(result, rb_reg_nth_match(FIX2INT(argv[i]), match));
        }
        else {
            int num = namev_to_backref_number(RMATCH_REGS(match), RMATCH(match)-&gt;regexp, argv[i]);
            if (num &gt;= 0) {
                rb_ary_push(result, rb_reg_nth_match(num, match));
            }
            else {
                match_ary_aref(match, argv[i], result);
            }
        }
    }
    return result;
}</pre> </div> <p>Uses each <em>index</em> to access the matching values, returning an array of the corresponding matches.</p> <pre class="ruby" data-language="ruby">m = /(.)(.)(\d+)(\d)/.match("THX1138: The Movie")
m.to_a               #=&gt; ["HX1138", "H", "X", "113", "8"]
m.values_at(0, 2, -2)   #=&gt; ["HX1138", "X", "113"]
m.values_at(1..2, -1)   #=&gt; ["H", "X", "8"]

m = /(?&lt;a&gt;\d+) *(?&lt;op&gt;[+\-*\/]) *(?&lt;b&gt;\d+)/.match("1 + 2")
m.to_a               #=&gt; ["1 + 2", "1", "+", "2"]
m.values_at(:a, :b, :op) #=&gt; ["1", "2", "+"]
</pre>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
