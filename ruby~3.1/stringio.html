<h1 id="class-StringIO" class="class"> class StringIO </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes">
<a class="include" href="enumerable">Enumerable</a>, <a class="include" href="io/generic_readable">IO::generic_readable</a>, <a class="include" href="io/generic_writable">IO::generic_writable</a>
</dd>
</dl> <section class="description"> <p>Pseudo I/O on <a href="string"><code>String</code></a> object, with interface corresponding to <a href="io"><code>IO</code></a>.</p> <p>Commonly used to simulate <code>$stdio</code> or <code>$stderr</code></p> <h3 id="class-StringIO-label-Examples">Examples</h3> <pre class="ruby" data-language="ruby">require 'stringio'

# Writing stream emulation
io = StringIO.new
io.puts "Hello World"
io.string #=&gt; "Hello World\n"

# Reading stream emulation
io = StringIO.new "first\nsecond\nlast\n"
io.getc #=&gt; "f"
io.gets #=&gt; "irst\n"
io.read #=&gt; "second\nlast\n"
</pre> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="VERSION">VERSION </dt>

</dl> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new(string=""[, mode]) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
strio_initialize(int argc, VALUE *argv, VALUE self)
{
    struct StringIO *ptr = check_strio(self);

    if (!ptr) {
        DATA_PTR(self) = ptr = strio_alloc();
    }
    rb_call_super(0, 0);
    return strio_init(argc, argv, ptr, self);
}</pre> </div> <p>Creates new <a href="stringio"><code>StringIO</code></a> instance from with <em>string</em> and <em>mode</em>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-open"> <span class="method-callseq"> open(string=""[, mode]) {|strio| ...} </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="open-source"> <pre class="c" data-language="c">static VALUE
strio_s_open(int argc, VALUE *argv, VALUE klass)
{
    VALUE obj = rb_class_new_instance_kw(argc, argv, klass, RB_PASS_CALLED_KEYWORDS);
    if (!rb_block_given_p()) return obj;
    return rb_ensure(rb_yield, obj, strio_finalize, obj);
}</pre> </div> <p>Equivalent to <a href="stringio#method-c-new"><code>StringIO.new</code></a> except that when it is called with a block, it yields with the new instance and closes it, and returns the result which returned from the block.</p>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-binmode"> <span class="method-callseq"> binmode → stringio </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="binmode-source"> <pre class="c" data-language="c">static VALUE
strio_binmode(VALUE self)
{
    struct StringIO *ptr = StringIO(self);
    rb_encoding *enc = rb_ascii8bit_encoding();

    ptr-&gt;enc = enc;
    if (WRITABLE(self)) {
        rb_enc_associate(ptr-&gt;string, enc);
    }
    return self;
}</pre> </div> <p>Puts stream into binary mode. See <a href="io#method-i-binmode"><code>IO#binmode</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-close"> <span class="method-callseq"> close → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="close-source"> <pre class="c" data-language="c">static VALUE
strio_close(VALUE self)
{
    StringIO(self);
    RBASIC(self)-&gt;flags &amp;= ~STRIO_READWRITE;
    return Qnil;
}</pre> </div> <p>Closes a <a href="stringio"><code>StringIO</code></a>. The stream is unavailable for any further data operations; an <code>IOError</code> is raised if such an attempt is made.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-close_read"> <span class="method-callseq"> close_read → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="close_read-source"> <pre class="c" data-language="c">static VALUE
strio_close_read(VALUE self)
{
    struct StringIO *ptr = StringIO(self);
    if (!(ptr-&gt;flags &amp; FMODE_READABLE)) {
        rb_raise(rb_eIOError, "closing non-duplex IO for reading");
    }
    RBASIC(self)-&gt;flags &amp;= ~STRIO_READABLE;
    return Qnil;
}</pre> </div> <p>Closes the read end of a <a href="stringio"><code>StringIO</code></a>. Will raise an <code>IOError</code> if the receiver is not readable.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-close_write"> <span class="method-callseq"> close_write → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="close_write-source"> <pre class="c" data-language="c">static VALUE
strio_close_write(VALUE self)
{
    struct StringIO *ptr = StringIO(self);
    if (!(ptr-&gt;flags &amp; FMODE_WRITABLE)) {
        rb_raise(rb_eIOError, "closing non-duplex IO for writing");
    }
    RBASIC(self)-&gt;flags &amp;= ~STRIO_WRITABLE;
    return Qnil;
}</pre> </div> <p>Closes the write end of a <a href="stringio"><code>StringIO</code></a>. Will raise an <code>IOError</code> if the receiver is not writeable.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-closed-3F"> <span class="method-callseq"> closed? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="closed-3F-source"> <pre class="c" data-language="c">static VALUE
strio_closed(VALUE self)
{
    StringIO(self);
    if (!CLOSED(self)) return Qfalse;
    return Qtrue;
}</pre> </div> <p>Returns <code>true</code> if the stream is completely closed, <code>false</code> otherwise.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-closed_read-3F"> <span class="method-callseq"> closed_read? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="closed_read-3F-source"> <pre class="c" data-language="c">static VALUE
strio_closed_read(VALUE self)
{
    StringIO(self);
    if (READABLE(self)) return Qfalse;
    return Qtrue;
}</pre> </div> <p>Returns <code>true</code> if the stream is not readable, <code>false</code> otherwise.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-closed_write-3F"> <span class="method-callseq"> closed_write? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="closed_write-3F-source"> <pre class="c" data-language="c">static VALUE
strio_closed_write(VALUE self)
{
    StringIO(self);
    if (WRITABLE(self)) return Qfalse;
    return Qtrue;
}</pre> </div> <p>Returns <code>true</code> if the stream is not writable, <code>false</code> otherwise.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each"> <span class="method-callseq"> each(sep=$/, chomp: false) {|line| block } → strio </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each(limit, chomp: false) {|line| block } → strio </span> </div> <div class="method-heading"> <span class="method-callseq"> each(sep, limit, chomp: false) {|line| block } → strio </span> </div> <div class="method-heading"> <span class="method-callseq"> each(...) → anEnumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each-source"> <pre class="c" data-language="c">static VALUE
strio_each(int argc, VALUE *argv, VALUE self)
{
    VALUE line;
    struct getline_arg arg;

    StringIO(self);
    RETURN_ENUMERATOR(self, argc, argv);

    if (prepare_getline_args(&amp;arg, argc, argv)-&gt;limit == 0) {
        rb_raise(rb_eArgError, "invalid limit: 0 for each_line");
    }

    while (!NIL_P(line = strio_getline(&amp;arg, readable(self)))) {
        rb_yield(line);
    }
    return self;
}</pre> </div> <p>See <a href="io#method-i-each"><code>IO#each</code></a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="stringio#method-i-each_line">each_line</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_byte"> <span class="method-callseq"> each_byte {|byte| block } → strio </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_byte → anEnumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_byte-source"> <pre class="c" data-language="c">static VALUE
strio_each_byte(VALUE self)
{
    struct StringIO *ptr;

    RETURN_ENUMERATOR(self, 0, 0);

    while ((ptr = strio_to_read(self)) != NULL) {
        char c = RSTRING_PTR(ptr-&gt;string)[ptr-&gt;pos++];
        rb_yield(CHR2FIX(c));
    }
    return self;
}</pre> </div> <p>See <a href="io#method-i-each_byte"><code>IO#each_byte</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_char"> <span class="method-callseq"> each_char {|char| block } → strio </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_char → anEnumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_char-source"> <pre class="c" data-language="c">static VALUE
strio_each_char(VALUE self)
{
    VALUE c;

    RETURN_ENUMERATOR(self, 0, 0);

    while (!NIL_P(c = strio_getc(self))) {
        rb_yield(c);
    }
    return self;
}</pre> </div> <p>See <a href="io#method-i-each_char"><code>IO#each_char</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_codepoint"> <span class="method-callseq"> each_codepoint {|c| block } → strio </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_codepoint → anEnumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_codepoint-source"> <pre class="c" data-language="c">static VALUE
strio_each_codepoint(VALUE self)
{
    struct StringIO *ptr;
    rb_encoding *enc;
    unsigned int c;
    int n;

    RETURN_ENUMERATOR(self, 0, 0);

    ptr = readable(self);
    enc = get_enc(ptr);
    while ((ptr = strio_to_read(self)) != NULL) {
        c = rb_enc_codepoint_len(RSTRING_PTR(ptr-&gt;string)+ptr-&gt;pos,
                                 RSTRING_END(ptr-&gt;string), &amp;n, enc);
        ptr-&gt;pos += n;
        rb_yield(UINT2NUM(c));
    }
    return self;
}</pre> </div> <p>See <a href="io#method-i-each_codepoint"><code>IO#each_codepoint</code></a>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-each_line"> <span class="method-name">each_line</span><span class="method-args">(*args)</span> </div> <div class="method-description"> <p>See <a href="io#method-i-each"><code>IO#each</code></a>.</p> </div> <div class="aliases"> Alias for: <a href="stringio#method-i-each">each</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-eof"> <span class="method-callseq"> eof → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="eof-source"> <pre class="c" data-language="c">static VALUE
strio_eof(VALUE self)
{
    if (strio_to_read(self)) return Qfalse;
    return Qtrue;
}</pre> </div> <p>Returns true if the stream is at the end of the data (underlying string). The stream must be opened for reading or an <code>IOError</code> will be raised.</p>  </div> <div class="aliases"> Also aliased as: <a href="stringio#method-i-eof-3F">eof?</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-eof-3F"> <span class="method-name">eof?</span><span class="method-args">()</span> </div> <div class="method-description"> <p>Returns true if the stream is at the end of the data (underlying string). The stream must be opened for reading or an <code>IOError</code> will be raised.</p> </div> <div class="aliases"> Alias for: <a href="stringio#method-i-eof">eof</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-external_encoding"> <span class="method-callseq"> external_encoding → encoding </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="external_encoding-source"> <pre class="c" data-language="c">static VALUE
strio_external_encoding(VALUE self)
{
    struct StringIO *ptr = StringIO(self);
    return rb_enc_from_encoding(get_enc(ptr));
}</pre> </div> <p>Returns the <a href="encoding"><code>Encoding</code></a> object that represents the encoding of the file. If the stream is write mode and no encoding is specified, returns <code>nil</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fcntl"> <span class="method-name">fcntl</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="fcntl-source"> <pre class="c" data-language="c">static VALUE
strio_unimpl(int argc, VALUE *argv, VALUE self)
{
    StringIO(self);
    rb_notimplement();

    UNREACHABLE;
}</pre> </div> <p>Raises <a href="notimplementederror"><code>NotImplementedError</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fileno"> <span class="method-name">fileno</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="fileno-source"> <pre class="c" data-language="c">static VALUE
strio_nil(VALUE self)
{
    StringIO(self);
    return Qnil;
}</pre> </div> <p>Returns <code>nil</code>. Just for compatibility to <a href="io"><code>IO</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-flush"> <span class="method-name">flush</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="flush-source"> <pre class="c" data-language="c">static VALUE
strio_self(VALUE self)
{
    StringIO(self);
    return self;
}</pre> </div> <p>Returns an object itself. Just for compatibility to <a href="io"><code>IO</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fsync"> <span class="method-name">fsync</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="fsync-source"> <pre class="c" data-language="c">static VALUE
strio_0(VALUE self)
{
    StringIO(self);
    return INT2FIX(0);
}</pre> </div> <p>Returns 0. Just for compatibility to <a href="io"><code>IO</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-getbyte"> <span class="method-callseq"> getbyte → fixnum or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="getbyte-source"> <pre class="c" data-language="c">static VALUE
strio_getbyte(VALUE self)
{
    struct StringIO *ptr = readable(self);
    int c;
    if (ptr-&gt;pos &gt;= RSTRING_LEN(ptr-&gt;string)) {
        return Qnil;
    }
    c = RSTRING_PTR(ptr-&gt;string)[ptr-&gt;pos++];
    return CHR2FIX(c);
}</pre> </div> <p>See <a href="io#method-i-getbyte"><code>IO#getbyte</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-getc"> <span class="method-callseq"> getc → string or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="getc-source"> <pre class="c" data-language="c">static VALUE
strio_getc(VALUE self)
{
    struct StringIO *ptr = readable(self);
    rb_encoding *enc = get_enc(ptr);
    VALUE str = ptr-&gt;string;
    long pos = ptr-&gt;pos;
    int len;
    char *p;

    if (pos &gt;= RSTRING_LEN(str)) {
        return Qnil;
    }
    p = RSTRING_PTR(str)+pos;
    len = rb_enc_mbclen(p, RSTRING_END(str), enc);
    ptr-&gt;pos += len;
    return enc_subseq(str, pos, len, enc);
}</pre> </div> <p>See <a href="io#method-i-getc"><code>IO#getc</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-gets"> <span class="method-callseq"> gets(sep=$/, chomp: false) → string or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> gets(limit, chomp: false) → string or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> gets(sep, limit, chomp: false) → string or nil </span> </div> <div class="method-description">
<div class="method-source-code" id="gets-source"> <pre class="c" data-language="c">static VALUE
strio_gets(int argc, VALUE *argv, VALUE self)
{
    struct getline_arg arg;
    VALUE str;

    if (prepare_getline_args(&amp;arg, argc, argv)-&gt;limit == 0) {
        struct StringIO *ptr = readable(self);
        return rb_enc_str_new(0, 0, get_enc(ptr));
    }

    str = strio_getline(&amp;arg, readable(self));
    rb_lastline_set(str);
    return str;
}</pre> </div> <p>See <a href="io#method-i-gets"><code>IO#gets</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-internal_encoding"> <span class="method-callseq"> internal_encoding → encoding </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="internal_encoding-source"> <pre class="c" data-language="c">static VALUE
strio_internal_encoding(VALUE self)
{
    return Qnil;
}</pre> </div> <p>Returns the <a href="encoding"><code>Encoding</code></a> of the internal string if conversion is specified. Otherwise returns <code>nil</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-isatty"> <span class="method-name">isatty</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="isatty-source"> <pre class="c" data-language="c">static VALUE
strio_false(VALUE self)
{
    StringIO(self);
    return Qfalse;
}</pre> </div> <p>Returns <code>false</code>. Just for compatibility to <a href="io"><code>IO</code></a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="stringio#method-i-tty-3F">tty?</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-length"> <span class="method-callseq"> length → integer </span> </div> <div class="method-description"> <p>Returns the size of the buffer string.</p> </div> <div class="aliases"> Alias for: <a href="stringio#method-i-size">size</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-lineno"> <span class="method-callseq"> lineno → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="lineno-source"> <pre class="c" data-language="c">static VALUE
strio_get_lineno(VALUE self)
{
    return LONG2NUM(StringIO(self)-&gt;lineno);
}</pre> </div> <p>Returns the current line number. The stream must be opened for reading. <code>lineno</code> counts the number of times <code>gets</code> is called, rather than the number of newlines encountered. The two values will differ if <code>gets</code> is called with a separator other than newline. See also the <code>$.</code> variable.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-lineno-3D"> <span class="method-callseq"> lineno = integer → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="lineno-3D-source"> <pre class="c" data-language="c">static VALUE
strio_set_lineno(VALUE self, VALUE lineno)
{
    StringIO(self)-&gt;lineno = NUM2LONG(lineno);
    return lineno;
}</pre> </div> <p>Manually sets the current line number to the given value. <code>$.</code> is updated only on the next read.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pid"> <span class="method-name">pid</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pid-source"> <pre class="c" data-language="c">static VALUE
strio_nil(VALUE self)
{
    StringIO(self);
    return Qnil;
}</pre> </div> <p>Returns <code>nil</code>. Just for compatibility to <a href="io"><code>IO</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pos"> <span class="method-callseq"> pos → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> tell → integer </span> </div> <div class="method-description">
<div class="method-source-code" id="pos-source"> <pre class="c" data-language="c">static VALUE
strio_get_pos(VALUE self)
{
    return LONG2NUM(StringIO(self)-&gt;pos);
}</pre> </div> <p>Returns the current offset (in bytes).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pos-3D"> <span class="method-callseq"> pos = integer → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pos-3D-source"> <pre class="c" data-language="c">static VALUE
strio_set_pos(VALUE self, VALUE pos)
{
    struct StringIO *ptr = StringIO(self);
    long p = NUM2LONG(pos);
    if (p &lt; 0) {
        error_inval(0);
    }
    ptr-&gt;pos = p;
    return pos;
}</pre> </div> <p>Seeks to the given position (in bytes).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-putc"> <span class="method-callseq"> putc(obj) → obj </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="putc-source"> <pre class="c" data-language="c">static VALUE
strio_putc(VALUE self, VALUE ch)
{
    struct StringIO *ptr = writable(self);
    VALUE str;

    check_modifiable(ptr);
    if (RB_TYPE_P(ch, T_STRING)) {
        str = rb_str_substr(ch, 0, 1);
    }
    else {
        char c = NUM2CHR(ch);
        str = rb_str_new(&amp;c, 1);
    }
    strio_write(self, str);
    return ch;
}</pre> </div> <p>See <a href="io#method-i-putc"><code>IO#putc</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-read"> <span class="method-callseq"> read([length [, outbuf]]) → string, outbuf, or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="read-source"> <pre class="c" data-language="c">static VALUE
strio_read(int argc, VALUE *argv, VALUE self)
{
    struct StringIO *ptr = readable(self);
    VALUE str = Qnil;
    long len;
    int binary = 0;

    switch (argc) {
      case 2:
        str = argv[1];
        if (!NIL_P(str)) {
            StringValue(str);
            rb_str_modify(str);
        }
        /* fall through */
      case 1:
        if (!NIL_P(argv[0])) {
            len = NUM2LONG(argv[0]);
            if (len &lt; 0) {
                rb_raise(rb_eArgError, "negative length %ld given", len);
            }
            if (len &gt; 0 &amp;&amp; ptr-&gt;pos &gt;= RSTRING_LEN(ptr-&gt;string)) {
                if (!NIL_P(str)) rb_str_resize(str, 0);
                return Qnil;
            }
            binary = 1;
            break;
        }
        /* fall through */
      case 0:
        len = RSTRING_LEN(ptr-&gt;string);
        if (len &lt;= ptr-&gt;pos) {
            rb_encoding *enc = get_enc(ptr);
            if (NIL_P(str)) {
                str = rb_str_new(0, 0);
            }
            else {
                rb_str_resize(str, 0);
            }
            rb_enc_associate(str, enc);
            return str;
        }
        else {
            len -= ptr-&gt;pos;
        }
        break;
      default:
        rb_error_arity(argc, 0, 2);
    }
    if (NIL_P(str)) {
        rb_encoding *enc = binary ? rb_ascii8bit_encoding() : get_enc(ptr);
        str = strio_substr(ptr, ptr-&gt;pos, len, enc);
    }
    else {
        long rest = RSTRING_LEN(ptr-&gt;string) - ptr-&gt;pos;
        if (len &gt; rest) len = rest;
        rb_str_resize(str, len);
        MEMCPY(RSTRING_PTR(str), RSTRING_PTR(ptr-&gt;string) + ptr-&gt;pos, char, len);
        if (binary)
            rb_enc_associate(str, rb_ascii8bit_encoding());
        else
            rb_enc_copy(str, ptr-&gt;string);
    }
    ptr-&gt;pos += RSTRING_LEN(str);
    return str;
}</pre> </div> <p>See <a href="io#method-i-read"><code>IO#read</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-readlines"> <span class="method-callseq"> readlines(sep=$/, chomp: false) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> readlines(limit, chomp: false) → array </span> </div> <div class="method-heading"> <span class="method-callseq"> readlines(sep, limit, chomp: false) → array </span> </div> <div class="method-description">
<div class="method-source-code" id="readlines-source"> <pre class="c" data-language="c">static VALUE
strio_readlines(int argc, VALUE *argv, VALUE self)
{
    VALUE ary, line;
    struct getline_arg arg;

    StringIO(self);
    ary = rb_ary_new();
    if (prepare_getline_args(&amp;arg, argc, argv)-&gt;limit == 0) {
        rb_raise(rb_eArgError, "invalid limit: 0 for readlines");
    }

    while (!NIL_P(line = strio_getline(&amp;arg, readable(self)))) {
        rb_ary_push(ary, line);
    }
    return ary;
}</pre> </div> <p>See <a href="io#method-i-readlines"><code>IO#readlines</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-reopen"> <span class="method-callseq"> reopen(other_StrIO) → strio </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> reopen(string, mode) → strio </span> </div> <div class="method-description">
<div class="method-source-code" id="reopen-source"> <pre class="c" data-language="c">static VALUE
strio_reopen(int argc, VALUE *argv, VALUE self)
{
    rb_io_taint_check(self);
    if (argc == 1 &amp;&amp; !RB_TYPE_P(*argv, T_STRING)) {
        return strio_copy(self, *argv);
    }
    return strio_init(argc, argv, StringIO(self), self);
}</pre> </div> <p>Reinitializes the stream with the given <em>other_StrIO</em> or <em>string</em> and <em>mode</em> (see StringIO#new).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rewind"> <span class="method-callseq"> rewind → 0 </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rewind-source"> <pre class="c" data-language="c">static VALUE
strio_rewind(VALUE self)
{
    struct StringIO *ptr = StringIO(self);
    ptr-&gt;pos = 0;
    ptr-&gt;lineno = 0;
    return INT2FIX(0);
}</pre> </div> <p>Positions the stream to the beginning of input, resetting <code>lineno</code> to zero.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-seek"> <span class="method-callseq"> seek(amount, whence=SEEK_SET) → 0 </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="seek-source"> <pre class="c" data-language="c">static VALUE
strio_seek(int argc, VALUE *argv, VALUE self)
{
    VALUE whence;
    struct StringIO *ptr = StringIO(self);
    long amount, offset;

    rb_scan_args(argc, argv, "11", NULL, &amp;whence);
    amount = NUM2LONG(argv[0]);
    if (CLOSED(self)) {
        rb_raise(rb_eIOError, "closed stream");
    }
    switch (NIL_P(whence) ? 0 : NUM2LONG(whence)) {
      case 0:
        offset = 0;
        break;
      case 1:
        offset = ptr-&gt;pos;
        break;
      case 2:
        offset = RSTRING_LEN(ptr-&gt;string);
        break;
      default:
        error_inval("invalid whence");
    }
    if (amount &gt; LONG_MAX - offset || amount + offset &lt; 0) {
        error_inval(0);
    }
    ptr-&gt;pos = amount + offset;
    return INT2FIX(0);
}</pre> </div> <p>Seeks to a given offset <em>amount</em> in the stream according to the value of <em>whence</em> (see <a href="io#method-i-seek"><code>IO#seek</code></a>).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-set_encoding"> <span class="method-callseq"> set_encoding(ext_enc, [int_enc[, opt]]) → strio </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="set_encoding-source"> <pre class="c" data-language="c">static VALUE
strio_set_encoding(int argc, VALUE *argv, VALUE self)
{
    rb_encoding* enc;
    struct StringIO *ptr = StringIO(self);
    VALUE ext_enc, int_enc, opt;

    argc = rb_scan_args(argc, argv, "11:", &amp;ext_enc, &amp;int_enc, &amp;opt);

    if (NIL_P(ext_enc)) {
        enc = rb_default_external_encoding();
    }
    else {
        enc = rb_to_encoding(ext_enc);
    }
    ptr-&gt;enc = enc;
    if (WRITABLE(self)) {
        rb_enc_associate(ptr-&gt;string, enc);
    }

    return self;
}</pre> </div> <p>Specify the encoding of the <a href="stringio"><code>StringIO</code></a> as <em>ext_enc</em>. Use the default external encoding if <em>ext_enc</em> is nil. 2nd argument <em>int_enc</em> and optional hash <em>opt</em> argument are ignored; they are for API compatibility to <a href="io"><code>IO</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-set_encoding_by_bom"> <span class="method-name">set_encoding_by_bom</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="set_encoding_by_bom-source"> <pre class="c" data-language="c">static VALUE
strio_set_encoding_by_bom(VALUE self)
{
    struct StringIO *ptr = StringIO(self);

    if (!set_encoding_by_bom(ptr)) return Qnil;
    return rb_enc_from_encoding(ptr-&gt;enc);
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-size"> <span class="method-callseq"> size → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="size-source"> <pre class="c" data-language="c">static VALUE
strio_size(VALUE self)
{
    VALUE string = StringIO(self)-&gt;string;
    if (NIL_P(string)) {
        rb_raise(rb_eIOError, "not opened");
    }
    return ULONG2NUM(RSTRING_LEN(string));
}</pre> </div> <p>Returns the size of the buffer string.</p>  </div> <div class="aliases"> Also aliased as: <a href="stringio#method-i-length">length</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-string"> <span class="method-callseq"> string → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="string-source"> <pre class="c" data-language="c">static VALUE
strio_get_string(VALUE self)
{
    return StringIO(self)-&gt;string;
}</pre> </div> <p>Returns underlying <a href="string"><code>String</code></a> object, the subject of <a href="io"><code>IO</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-string-3D"> <span class="method-callseq"> string = string → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="string-3D-source"> <pre class="c" data-language="c">static VALUE
strio_set_string(VALUE self, VALUE string)
{
    struct StringIO *ptr = StringIO(self);

    rb_io_taint_check(self);
    ptr-&gt;flags &amp;= ~FMODE_READWRITE;
    StringValue(string);
    ptr-&gt;flags = OBJ_FROZEN(string) ? FMODE_READABLE : FMODE_READWRITE;
    ptr-&gt;pos = 0;
    ptr-&gt;lineno = 0;
    return ptr-&gt;string = string;
}</pre> </div> <p>Changes underlying <a href="string"><code>String</code></a> object, the subject of <a href="io"><code>IO</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-sync"> <span class="method-callseq"> sync → true </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="sync-source"> <pre class="c" data-language="c">static VALUE
strio_get_sync(VALUE self)
{
    StringIO(self);
    return Qtrue;
}</pre> </div> <p>Returns <code>true</code> always.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-sync-3D"> <span class="method-name">sync=</span><span class="method-args">(p1)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="sync-3D-source"> <pre class="c" data-language="c">static VALUE
strio_first(VALUE self, VALUE arg)
{
    StringIO(self);
    return arg;
}</pre> </div> <p>Returns the argument unchanged. Just for compatibility to <a href="io"><code>IO</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-tell"> <span class="method-callseq"> pos → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> tell → integer </span> </div> <div class="method-description">
<div class="method-source-code" id="tell-source"> <pre class="c" data-language="c">static VALUE
strio_get_pos(VALUE self)
{
    return LONG2NUM(StringIO(self)-&gt;pos);
}</pre> </div> <p>Returns the current offset (in bytes).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-truncate"> <span class="method-callseq"> truncate(integer) → 0 </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="truncate-source"> <pre class="c" data-language="c">static VALUE
strio_truncate(VALUE self, VALUE len)
{
    VALUE string = writable(self)-&gt;string;
    long l = NUM2LONG(len);
    long plen = RSTRING_LEN(string);
    if (l &lt; 0) {
        error_inval("negative length");
    }
    rb_str_resize(string, l);
    if (plen &lt; l) {
        MEMZERO(RSTRING_PTR(string) + plen, char, l - plen);
    }
    return len;
}</pre> </div> <p>Truncates the buffer string to at most <em>integer</em> bytes. The stream must be opened for writing.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-tty-3F"> <span class="method-name">tty?</span><span class="method-args">()</span> </div> <div class="method-description"> <p>Returns <code>false</code>. Just for compatibility to <a href="io"><code>IO</code></a>.</p> </div> <div class="aliases"> Alias for: <a href="stringio#method-i-isatty">isatty</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ungetbyte"> <span class="method-callseq"> ungetbyte(fixnum) → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ungetbyte-source"> <pre class="c" data-language="c">static VALUE
strio_ungetbyte(VALUE self, VALUE c)
{
    struct StringIO *ptr = readable(self);

    check_modifiable(ptr);
    if (NIL_P(c)) return Qnil;
    if (RB_INTEGER_TYPE_P(c)) {
        /* rb_int_and() not visible from exts */
        VALUE v = rb_funcall(c, '&amp;', 1, INT2FIX(0xff));
        const char cc = NUM2INT(v) &amp; 0xFF;
        strio_unget_bytes(ptr, &amp;cc, 1);
    }
    else {
        long cl;
        SafeStringValue(c);
        cl = RSTRING_LEN(c);
        if (cl &gt; 0) {
            strio_unget_bytes(ptr, RSTRING_PTR(c), cl);
            RB_GC_GUARD(c);
        }
    }
    return Qnil;
}</pre> </div> <p>See <a href="io#method-i-ungetbyte"><code>IO#ungetbyte</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ungetc"> <span class="method-callseq"> ungetc(string) → nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ungetc-source"> <pre class="c" data-language="c">static VALUE
strio_ungetc(VALUE self, VALUE c)
{
    struct StringIO *ptr = readable(self);
    rb_encoding *enc, *enc2;

    check_modifiable(ptr);
    if (NIL_P(c)) return Qnil;
    if (RB_INTEGER_TYPE_P(c)) {
        int len, cc = NUM2INT(c);
        char buf[16];

        enc = rb_enc_get(ptr-&gt;string);
        len = rb_enc_codelen(cc, enc);
        if (len &lt;= 0) rb_enc_uint_chr(cc, enc);
        rb_enc_mbcput(cc, buf, enc);
        return strio_unget_bytes(ptr, buf, len);
    }
    else {
        SafeStringValue(c);
        enc = rb_enc_get(ptr-&gt;string);
        enc2 = rb_enc_get(c);
        if (enc != enc2 &amp;&amp; enc != rb_ascii8bit_encoding()) {
            c = rb_str_conv_enc(c, enc2, enc);
        }
        strio_unget_bytes(ptr, RSTRING_PTR(c), RSTRING_LEN(c));
        RB_GC_GUARD(c);
        return Qnil;
    }
}</pre> </div> <p>Pushes back one character (passed as a parameter) such that a subsequent buffered read will return it. There is no limitation for multiple pushbacks including pushing back behind the beginning of the buffer string.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-write"> <span class="method-callseq"> write(string, ...) → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> syswrite(string) → integer </span> </div> <div class="method-description">
<div class="method-source-code" id="write-source"> <pre class="c" data-language="c">static VALUE
strio_write_m(int argc, VALUE *argv, VALUE self)
{
    long len = 0;
    while (argc-- &gt; 0) {
        /* StringIO can't exceed long limit */
        len += strio_write(self, *argv++);
    }
    return LONG2NUM(len);
}</pre> </div> <p>Appends the given string to the underlying buffer string. The stream must be opened for writing. If the argument is not a string, it will be converted to a string using <code>to_s</code>. Returns the number of bytes written. See <a href="io#method-i-write"><code>IO#write</code></a>.</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
