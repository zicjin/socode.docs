<h1 id="using">Using importlib.metadata</h1> <div class="versionadded" id="module-importlib.metadata"> <p><span class="versionmodified added">New in version 3.8.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span><code>importlib.metadata</code> is no longer provisional.</p> </div> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/importlib/metadata/__init__.py">Lib/importlib/metadata/__init__.py</a></p> <p><code>importlib.metadata</code> is a library that provides for access to installed package metadata. Built in part on Python’s import system, this library intends to replace similar functionality in the <a class="reference external" href="https://setuptools.readthedocs.io/en/latest/pkg_resources.html#entry-points">entry point API</a> and <a class="reference external" href="https://setuptools.readthedocs.io/en/latest/pkg_resources.html#metadata-api">metadata API</a> of <code>pkg_resources</code>. Along with <a class="reference internal" href="importlib#module-importlib.resources" title="importlib.resources: Package resource reading, opening, and access"><code>importlib.resources</code></a> in Python 3.7 and newer (backported as <a class="reference external" href="https://importlib-resources.readthedocs.io/en/latest/index.html">importlib_resources</a> for older versions of Python), this can eliminate the need to use the older and less efficient <code>pkg_resources</code> package.</p> <p>By “installed package” we generally mean a third-party package installed into Python’s <code>site-packages</code> directory via tools such as <a class="reference external" href="https://pypi.org/project/pip/">pip</a>. Specifically, it means a package with either a discoverable <code>dist-info</code> or <code>egg-info</code> directory, and metadata defined by <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0566" id="index-0"><strong>PEP 566</strong></a> or its older specifications. By default, package metadata can live on the file system or in zip archives on <a class="reference internal" href="sys#sys.path" title="sys.path"><code>sys.path</code></a>. Through an extension mechanism, the metadata can live almost anywhere.</p>  <h2 id="overview">Overview</h2> <p>Let’s say you wanted to get the version string for a package you’ve installed using <code>pip</code>. We start by creating a virtual environment and installing something into it:</p> <pre data-language="shell">$ python3 -m venv example
$ source example/bin/activate
(example) $ pip install wheel
</pre> <p>You can get the version string for <code>wheel</code> by running the following:</p> <pre data-language="pycon">(example) $ python
&gt;&gt;&gt; from importlib.metadata import version  
&gt;&gt;&gt; version('wheel')  
'0.32.3'
</pre> <p>You can also get the set of entry points keyed by group, such as <code>console_scripts</code>, <code>distutils.commands</code> and others. Each group contains a sequence of <a class="reference internal" href="#entry-points"><span class="std std-ref">EntryPoint</span></a> objects.</p> <p>You can get the <a class="reference internal" href="#metadata"><span class="std std-ref">metadata for a distribution</span></a>:</p> <pre data-language="python">&gt;&gt;&gt; list(metadata('wheel'))  
['Metadata-Version', 'Name', 'Version', 'Summary', 'Home-page', 'Author', 'Author-email', 'Maintainer', 'Maintainer-email', 'License', 'Project-URL', 'Project-URL', 'Project-URL', 'Keywords', 'Platform', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Classifier', 'Requires-Python', 'Provides-Extra', 'Requires-Dist', 'Requires-Dist']
</pre> <p>You can also get a <a class="reference internal" href="#version"><span class="std std-ref">distribution’s version number</span></a>, list its <a class="reference internal" href="#files"><span class="std std-ref">constituent files</span></a>, and get a list of the distribution’s <a class="reference internal" href="#requirements"><span class="std std-ref">Distribution requirements</span></a>.</p>   <h2 id="functional-api">Functional API</h2> <p>This package provides the following functionality via its public API.</p>  <h3 id="id1">Entry points</h3> <p id="entry-points">The <code>entry_points()</code> function returns a collection of entry points. Entry points are represented by <code>EntryPoint</code> instances; each <code>EntryPoint</code> has a <code>.name</code>, <code>.group</code>, and <code>.value</code> attributes and a <code>.load()</code> method to resolve the value. There are also <code>.module</code>, <code>.attr</code>, and <code>.extras</code> attributes for getting the components of the <code>.value</code> attribute.</p> <p>Query all entry points:</p> <pre data-language="python">&gt;&gt;&gt; eps = entry_points()  
</pre> <p>The <code>entry_points()</code> function returns an <code>EntryPoints</code> object, a sequence of all <code>EntryPoint</code> objects with <code>names</code> and <code>groups</code> attributes for convenience:</p> <pre data-language="python">&gt;&gt;&gt; sorted(eps.groups)  
['console_scripts', 'distutils.commands', 'distutils.setup_keywords', 'egg_info.writers', 'setuptools.installation']
</pre> <p><code>EntryPoints</code> has a <code>select</code> method to select entry points matching specific properties. Select entry points in the <code>console_scripts</code> group:</p> <pre data-language="python">&gt;&gt;&gt; scripts = eps.select(group='console_scripts')  
</pre> <p>Equivalently, since <code>entry_points</code> passes keyword arguments through to select:</p> <pre data-language="python">&gt;&gt;&gt; scripts = entry_points(group='console_scripts')  
</pre> <p>Pick out a specific script named “wheel” (found in the wheel project):</p> <pre data-language="python">&gt;&gt;&gt; 'wheel' in scripts.names  
True
&gt;&gt;&gt; wheel = scripts['wheel']  
</pre> <p>Equivalently, query for that entry point during selection:</p> <pre data-language="python">&gt;&gt;&gt; (wheel,) = entry_points(group='console_scripts', name='wheel')  
&gt;&gt;&gt; (wheel,) = entry_points().select(group='console_scripts', name='wheel')  
</pre> <p>Inspect the resolved entry point:</p> <pre data-language="python">&gt;&gt;&gt; wheel  
EntryPoint(name='wheel', value='wheel.cli:main', group='console_scripts')
&gt;&gt;&gt; wheel.module  
'wheel.cli'
&gt;&gt;&gt; wheel.attr  
'main'
&gt;&gt;&gt; wheel.extras  
[]
&gt;&gt;&gt; main = wheel.load()  
&gt;&gt;&gt; main  
&lt;function main at 0x103528488&gt;
</pre> <p>The <code>group</code> and <code>name</code> are arbitrary values defined by the package author and usually a client will wish to resolve all entry points for a particular group. Read <a class="reference external" href="https://setuptools.readthedocs.io/en/latest/setuptools.html#dynamic-discovery-of-services-and-plugins">the setuptools docs</a> for more information on entry points, their definition, and usage.</p> <p><em>Compatibility Note</em></p> <p>The “selectable” entry points were introduced in <code>importlib_metadata</code> 3.6 and Python 3.10. Prior to those changes, <code>entry_points</code> accepted no parameters and always returned a dictionary of entry points, keyed by group. For compatibility, if no parameters are passed to entry_points, a <code>SelectableGroups</code> object is returned, implementing that dict interface. In the future, calling <code>entry_points</code> with no parameters will return an <code>EntryPoints</code> object. Users should rely on the selection interface to retrieve entry points by group.</p>   <h3 id="metadata">Distribution metadata</h3> <p id="distribution-metadata">Every distribution includes some metadata, which you can extract using the <code>metadata()</code> function:</p> <pre data-language="python">&gt;&gt;&gt; wheel_metadata = metadata('wheel')  
</pre> <p>The keys of the returned data structure, a <code>PackageMetadata</code>, name the metadata keywords, and the values are returned unparsed from the distribution metadata:</p> <pre data-language="python">&gt;&gt;&gt; wheel_metadata['Requires-Python']  
'&gt;=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*'
</pre> <p><code>PackageMetadata</code> also presents a <code>json</code> attribute that returns all the metadata in a JSON-compatible form per <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0566" id="index-1"><strong>PEP 566</strong></a>:</p> <pre data-language="python">&gt;&gt;&gt; wheel_metadata.json['requires_python']
'&gt;=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*'
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.10: </span>The <code>Description</code> is now included in the metadata when presented through the payload. Line continuation characters have been removed.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.10: </span>The <code>json</code> attribute was added.</p> </div>   <h3 id="version">Distribution versions</h3> <p id="distribution-versions">The <code>version()</code> function is the quickest way to get a distribution’s version number, as a string:</p> <pre data-language="python">&gt;&gt;&gt; version('wheel')  
'0.32.3'
</pre>   <h3 id="files">Distribution files</h3> <p id="distribution-files">You can also get the full set of files contained within a distribution. The <code>files()</code> function takes a distribution package name and returns all of the files installed by this distribution. Each file object returned is a <code>PackagePath</code>, a <a class="reference internal" href="pathlib#pathlib.PurePath" title="pathlib.PurePath"><code>pathlib.PurePath</code></a> derived object with additional <code>dist</code>, <code>size</code>, and <code>hash</code> properties as indicated by the metadata. For example:</p> <pre data-language="python">&gt;&gt;&gt; util = [p for p in files('wheel') if 'util.py' in str(p)][0]  
&gt;&gt;&gt; util  
PackagePath('wheel/util.py')
&gt;&gt;&gt; util.size  
859
&gt;&gt;&gt; util.dist  
&lt;importlib.metadata._hooks.PathDistribution object at 0x101e0cef0&gt;
&gt;&gt;&gt; util.hash  
&lt;FileHash mode: sha256 value: bYkw5oMccfazVCoYQwKkkemoVyMAFoR34mmKBx8R1NI&gt;
</pre> <p>Once you have the file, you can also read its contents:</p> <pre data-language="python">&gt;&gt;&gt; print(util.read_text())  
import base64
import sys
...
def as_bytes(s):
    if isinstance(s, text_type):
        return s.encode('utf-8')
    return s
</pre> <p>You can also use the <code>locate</code> method to get a the absolute path to the file:</p> <pre data-language="python">&gt;&gt;&gt; util.locate()  
PosixPath('/home/gustav/example/lib/site-packages/wheel/util.py')
</pre> <p>In the case where the metadata file listing files (RECORD or SOURCES.txt) is missing, <code>files()</code> will return <code>None</code>. The caller may wish to wrap calls to <code>files()</code> in <a class="reference external" href="https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.always_iterable">always_iterable</a> or otherwise guard against this condition if the target distribution is not known to have the metadata present.</p>   <h3 id="requirements">Distribution requirements</h3> <p id="distribution-requirements">To get the full set of requirements for a distribution, use the <code>requires()</code> function:</p> <pre data-language="python">&gt;&gt;&gt; requires('wheel')  
["pytest (&gt;=3.0.0) ; extra == 'test'", "pytest-cov ; extra == 'test'"]
</pre>   <h3 id="package-distributions">Package distributions</h3> <p>A convenience method to resolve the distribution or distributions (in the case of a namespace package) for top-level Python packages or modules:</p> <pre data-language="python">&gt;&gt;&gt; packages_distributions()
{'importlib_metadata': ['importlib-metadata'], 'yaml': ['PyYAML'], 'jaraco': ['jaraco.classes', 'jaraco.functools'], ...}
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.10.</span></p> </div>    <h2 id="id2">Distributions</h2> <p id="distributions">While the above API is the most common and convenient usage, you can get all of that information from the <code>Distribution</code> class. A <code>Distribution</code> is an abstract object that represents the metadata for a Python package. You can get the <code>Distribution</code> instance:</p> <pre data-language="python">&gt;&gt;&gt; from importlib.metadata import distribution  
&gt;&gt;&gt; dist = distribution('wheel')  
</pre> <p>Thus, an alternative way to get the version number is through the <code>Distribution</code> instance:</p> <pre data-language="python">&gt;&gt;&gt; dist.version  
'0.32.3'
</pre> <p>There are all kinds of additional metadata available on the <code>Distribution</code> instance:</p> <pre data-language="python">&gt;&gt;&gt; dist.metadata['Requires-Python']  
'&gt;=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*'
&gt;&gt;&gt; dist.metadata['License']  
'MIT'
</pre> <p>The full set of available metadata is not described here. See <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0566" id="index-2"><strong>PEP 566</strong></a> for additional details.</p>   <h2 id="extending-the-search-algorithm">Extending the search algorithm</h2> <p>Because package metadata is not available through <a class="reference internal" href="sys#sys.path" title="sys.path"><code>sys.path</code></a> searches, or package loaders directly, the metadata for a package is found through import system <a class="reference internal" href="../reference/import#finders-and-loaders"><span class="std std-ref">finders</span></a>. To find a distribution package’s metadata, <code>importlib.metadata</code> queries the list of <a class="reference internal" href="https://docs.python.org/3.10/glossary.html#term-meta-path-finder"><span class="xref std std-term">meta path finders</span></a> on <a class="reference internal" href="sys#sys.meta_path" title="sys.meta_path"><code>sys.meta_path</code></a>.</p> <p>The default <code>PathFinder</code> for Python includes a hook that calls into <code>importlib.metadata.MetadataPathFinder</code> for finding distributions loaded from typical file-system-based paths.</p> <p>The abstract class <a class="reference internal" href="importlib#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code>importlib.abc.MetaPathFinder</code></a> defines the interface expected of finders by Python’s import system. <code>importlib.metadata</code> extends this protocol by looking for an optional <code>find_distributions</code> callable on the finders from <a class="reference internal" href="sys#sys.meta_path" title="sys.meta_path"><code>sys.meta_path</code></a> and presents this extended interface as the <code>DistributionFinder</code> abstract base class, which defines this abstract method:</p> <pre data-language="python">@abc.abstractmethod
def find_distributions(context=DistributionFinder.Context()):
    """Return an iterable of all Distribution instances capable of
    loading the metadata for packages for the indicated ``context``.
    """
</pre> <p>The <code>DistributionFinder.Context</code> object provides <code>.path</code> and <code>.name</code> properties indicating the path to search and name to match and may supply other relevant context.</p> <p>What this means in practice is that to support finding distribution package metadata in locations other than the file system, subclass <code>Distribution</code> and implement the abstract methods. Then from a custom finder, return instances of this derived <code>Distribution</code> in the <code>find_distributions()</code> method.</p>   <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2022 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.10/library/importlib.metadata.html" class="_attribution-link">https://docs.python.org/3.10/library/importlib.metadata.html</a>
  </p>
</div>
