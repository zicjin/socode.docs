<h1 class="module-name">Function</h1>  <h3 role="link" id="hasMany">  <span class="method-name">hasMany</span> <span class="args"> (type, options) </span> <span class="return-type">Ember.computed</span> <span class="access">public</span>  </h3> <table> <tr> <th>Module:</th> <td><a href="../../modules/@ember-data/model">@ember-data/model</a></td> </tr> </table> <p class="github-link"> Defined in <a href="https://github.com/emberjs/data/tree/v3.25.0/packages/-ember-data/../model/addon/-private/has-many.js#L12" target="_blank" rel="noopener noreferrer"> ../model/addon/-private/has-many.js:12 </a> </p>  <dl class="parameters">  <dt>type</dt> <dd class="parameter-type">String</dd> <dd>(optional) type of the relationship</dd>   <dt>options</dt> <dd class="parameter-type">Object</dd> <dd>(optional) a hash of options</dd>   <dt>returns</dt> <dd class="return-type">Ember.computed</dd> <dd>relationship</dd>  </dl> <p><code>hasMany</code> is used to define One-To-Many and Many-To-Many relationships on a <a href="https://api.emberjs.com/ember-data/release/classes/Model">Model</a>.</p> <p><code>hasMany</code> takes an optional hash as a second parameter, currently supported options are:</p> <ul> <li>
<code>async</code>: A boolean value used to explicitly declare this to be an async relationship. The default is true.</li> <li>
<code>inverse</code>: A string used to identify the inverse property on a related model.</li> <li>
<code>polymorphic</code> A boolean value to mark the relationship as polymorphic</li> </ul> <h4 id="one-to-many">One-To-Many</h4> <p>To declare a one-to-many relationship between two models, use <code>belongsTo</code> in combination with <code>hasMany</code>, like this:</p> <div class="pre-title"><code>app/models/post.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Model, { hasMany } from '@ember-data/model';

export default class PostModel extends Model {
  @hasMany('comment') comments; 
}</pre> <div class="pre-title"><code>app/models/comment.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Model, { belongsTo } from '@ember-data/model';

export default class CommentModel extends Model {
  @belongsTo('post') post; 
}</pre> <h4 id="many-to-many">Many-To-Many</h4> <p>To declare a many-to-many relationship between two models, use <code>hasMany</code>:</p> <div class="pre-title"><code>app/models/post.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Model, { hasMany } from '@ember-data/model';

export default class PostModel extends Model {
  @hasMany('tag') tags;
}</pre> <div class="pre-title"><code>app/models/tag.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Model, { hasMany } from '@ember-data/model';

export default class TagModel extends Model {
  @hasMany('post') posts; 
}</pre> <p>You can avoid passing a string as the first parameter. In that case Ember Data will infer the type from the singularized key name.</p> <div class="pre-title"><code>app/models/post.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Model, { hasMany } from '@ember-data/model';

export default class PostModel extends Model {
  @hasMany tags;
}</pre> <p>will lookup for a Tag type.</p> <h4 id="explicit-inverses">Explicit Inverses</h4> <p>Ember Data will do its best to discover which relationships map to one another. In the one-to-many code above, for example, Ember Data can figure out that changing the <code>comments</code> relationship should update the <code>post</code> relationship on the inverse because post is the only relationship to that model.</p> <p>However, sometimes you may have multiple <code>belongsTo</code>/<code>hasMany</code> for the same type. You can specify which property on the related model is the inverse using <code>hasMany</code>'s <code>inverse</code> option:</p> <div class="pre-title"><code>app/models/comment.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Model, { belongsTo } from '@ember-data/model';

export default class CommentModel extends Model {
  @belongsTo('post') onePost;
  @belongsTo('post') twoPost
  @belongsTo('post') redPost;
  @belongsTo('post') bluePost;
}</pre> <div class="pre-title"><code>app/models/post.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Model from '@ember-data/model';
import { hasMany } from '@ember-decorators/data';

export default class PostModel extends Model {
  @hasMany('comment', {
    inverse: 'redPost'
  })
  comments;
}</pre> <p>You can also specify an inverse on a <code>belongsTo</code>, which works how you'd expect.</p> <h4 id="sync-relationships">Sync relationships</h4> <p>Ember Data resolves sync relationships with the related resources available in its local store, hence it is expected these resources to be loaded before or along-side the primary resource.</p> <div class="pre-title"><code>app/models/post.js</code></div>
<pre class="highlight javascript" data-language="javascript">import Model, { hasMany } from '@ember-data/model';

export default class PostModel extends Model {
  @hasMany('comment', {
    async: false
  })
  comments;
}</pre> <p>In contrast to async relationship, accessing a sync relationship will always return a <a href="https://api.emberjs.com/ember-data/release/classes/ManyArray">ManyArray</a> instance containing the existing local resources. But it will error on access when any of the known related resources have not been loaded.</p> <pre class="highlight " data-language="">post.get('comments').forEach((comment) =&gt; {

});</pre> <p>If you are using <code>links</code> with sync relationships, you have to use <code>ref.reload</code> to fetch the resources.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://api.emberjs.com/ember-data/3.25/functions/@ember-data%2Fmodel/hasMany" class="_attribution-link" target="_blank">https://api.emberjs.com/ember-data/3.25/functions/@ember-data%2Fmodel/hasMany</a>
  </p>
</div>
