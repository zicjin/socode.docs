 <h1 id="import-tfstate">  Import: tfstate </h1> <blockquote class="alert alert-info" role="alert"> <p><strong>Note:</strong> Sentinel policies are a paid feature, available as part of the <strong>Team &amp; Governance</strong> upgrade package. <a href="https://www.hashicorp.com/products/terraform/pricing">Learn more about Terraform Cloud pricing here</a>.</p> </blockquote> <p>The <code>tfstate</code> import provides access to the Terraform state.</p> <p>The <em>state</em> is the data that Terraform has recorded about a workspace at a particular point in its lifecycle, usually after an apply. You can read more general information about how Terraform uses state <a href="../../../language/state/index">here</a>.</p> <blockquote class="alert alert-info" role="alert"> <p><strong>Note:</strong> Since Terraform Cloud currently only supports policy checks at plan time, the usefulness of this import is somewhat limited, as it will usually give you the state <em>prior</em> to the plan the policy check is currently being run for. Depending on your needs, you may find the <a href="tfplan#value-applied"><code>applied</code></a> collection in <code>tfplan</code> more useful, which will give you a <em>predicted</em> state by applying plan data to the data found here. The one exception to this rule is <em>data sources</em>, which will always give up to date data here, as long as the data source could be evaluated at plan time.</p> </blockquote> <h2 id="namespace-overview">  Namespace Overview </h2> <p>The following is a tree view of the import namespace. For more detail on a particular part of the namespace, see below.</p> <blockquote class="alert alert-info" role="alert"> <p>Note that the root-level alias keys shown here (<code>data</code>, <code>outputs</code>, <code>path</code>, and <code>resources</code>) are shortcuts to a <a href="#namespace-module">module namespace</a> scoped to the root module. For more details, see the section on <a href="#root-namespace-aliases">root namespace aliases</a>.</p> </blockquote> <pre>tfstate
├── module() (function)
│   └── (module namespace)
│       ├── path ([]string)
│       ├── data
│       │   └── TYPE.NAME[NUMBER]
│       │       ├── attr (map of keys)
│       │       ├── depends_on ([]string)
│       │       ├── id (string)
│       │       └── tainted (boolean)
│       ├── outputs (root module only in TF 0.12 or later)
│       │   └── NAME
│       │       ├── sensitive (bool)
│       │       ├── type (string)
│       │       └── value (value)
│       └── resources
│           └── TYPE.NAME[NUMBER]
│               ├── attr (map of keys)
│               ├── depends_on ([]string)
│               ├── id (string)
│               └── tainted (boolean)
│
├── module_paths ([][]string)
├── terraform_version (string)
│
├── data (root module alias)
├── outputs (root module alias)
├── path (root module alias)
└── resources (root module alias)
</pre>
<h2 id="namespace-root">  Namespace: Root </h2> <p>The root-level namespace consists of the values and functions documented below.</p> <p>In addition to this, the root-level <code>data</code>, <code>outputs</code>, <code>path</code>, and <code>resources</code> keys alias to their corresponding namespaces or values within the <a href="#namespace-module">module namespace</a>.</p> <h3 id="function-module-">  Function: <code>module()</code> </h3> <pre>module = func(ADDR)
</pre> <ul> <li>
<strong>Return Type:</strong> A <a href="#namespace-module">module namespace</a>. </li> </ul> <p>The <code>module()</code> function in the <a href="#namespace-root">root namespace</a> returns the <a href="#namespace-module">module namespace</a> for a particular module address.</p> <p>The address must be a list and is the module address, split on the period (<code>.</code>), excluding the root module.</p> <p>Hence, a module with an address of simply <code>foo</code> (or <code>root.foo</code>) would be <code>["foo"]</code>, and a module within that (so address <code>foo.bar</code>) would be read as <code>["foo", "bar"]</code>.</p> <p><a href="https://docs.hashicorp.com/sentinel/language/spec#null"><code>null</code></a> is returned if a module address is invalid, or if the module is not present in the state.</p> <p>As an example, given the following module block:</p> <pre data-language="ruby">module "foo" {
  # ...
}
</pre>
<p>If the module contained the following content:</p> <pre data-language="ruby">resource "null_resource" "foo" {
  triggers = {
    foo = "bar"
  }
}
</pre>
<p>The following policy would evaluate to <code>true</code> if the resource was present in the state:</p> <pre>import "tfstate"

main = rule { tfstate.module(["foo"]).resources.null_resource.foo[0].attr.triggers.foo is "bar" }
</pre>
<h3 id="value-module_paths">  Value: <code>module_paths</code> </h3> <ul> <li>
<strong>Value Type:</strong> List of a list of strings. </li> </ul> <p>The <code>module_paths</code> value within the <a href="#namespace-root">root namespace</a> is a list of all of the modules within the Terraform state at plan-time.</p> <p>Modules not present in the state will not be present here, even if they are present in the configuration or the diff.</p> <p>This data is represented as a list of a list of strings, with the inner list being the module address, split on the period (<code>.</code>).</p> <p>The root module is included in this list, represented as an empty inner list, as long as it is present in state.</p> <p>As an example, if the following module block was present within a Terraform configuration:</p> <pre data-language="ruby">module "foo" {
  # ...
}
</pre>
<p>The value of <code>module_paths</code> would be:</p> <pre>[
    [],
    ["foo"],
]
</pre>
<p>And the following policy would evaluate to <code>true</code>:</p> <pre>import "tfstate"

main = rule { tfstate.module_paths contains ["foo"] }
</pre>
<blockquote class="alert alert-info" role="alert"> <p>Note the above example only applies if the module is present in the state.</p> </blockquote> <h4 id="iterating-through-modules">  Iterating Through Modules </h4> <p>Iterating through all modules to find particular resources can be useful. This <a href="index#iterate-over-modules-and-find-resources">example</a> shows how to use <code>module_paths</code> with the <a href="#function-module-"><code>module()</code> function</a> to find all resources of a particular type from all modules using the <code>tfplan</code> import. By changing <code>tfplan</code> in this function to <code>tfstate</code>, you could make a similar function find all resources of a specific type in the current state.</p> <h3 id="value-terraform_version">  Value: <code>terraform_version</code> </h3> <ul> <li>
<strong>Value Type:</strong> String. </li> </ul> <p>The <code>terraform_version</code> value within the <a href="#namespace-root">root namespace</a> represents the version of Terraform in use when the state was saved. This can be used to enforce a specific version of Terraform in a policy check.</p> <p>As an example, the following policy would evaluate to <code>true</code> as long as the state was made with a version of Terraform in the 0.11.x series, excluding any pre-release versions (example: <code>-beta1</code> or <code>-rc1</code>):</p> <pre>import "tfstate"

main = rule { tfstate.terraform_version matches "^0\\.11\\.\\d+$" }
</pre>
<blockquote class="alert alert-info" role="alert"> <p><strong>NOTE:</strong> This value is also available via the <a href="tfplan"><code>tfplan</code></a> import, which will be more current when a policy check is run against a plan. It's recommended you use the value in <code>tfplan</code> until Terraform Cloud supports policy checks in other stages of the workspace lifecycle. See the <a href="tfplan#value-terraform_version"><code>terraform_version</code></a> reference within the <code>tfplan</code> import for more details.</p> </blockquote> <h2 id="namespace-module">  Namespace: Module </h2> <p>The <strong>module namespace</strong> can be loaded by calling <a href="#function-module-"><code>module()</code></a> for a particular module.</p> <p>It can be used to load the following child namespaces, in addition to the values documented below:</p> <ul> <li>
<a href="#data"><code>data</code></a> - Loads the <a href="#namespace-resources-data-sources">resource namespace</a>, filtered against data sources. </li> <li>
<a href="#outputs"><code>outputs</code></a> - Loads the <a href="#namespace-outputs">output namespace</a>, which supply the outputs present in this module's state. Note that with Terraform 0.12 or later, this value is only available for the root namespace. </li> <li>
<a href="#resources"><code>resources</code></a> - Loads the <a href="#namespace-resources-data-sources">resource namespace</a>, filtered against resources. </li> </ul> <h3 id="root-namespace-aliases">  Root Namespace Aliases </h3> <p>The root-level <code>data</code>, <code>outputs</code>, and <code>resources</code> keys both alias to their corresponding namespaces within the module namespace, loaded for the root module. They are the equivalent of running <code>module([]).KEY</code>.</p> <h3 id="value-path">  Value: <code>path</code> </h3> <ul> <li>
<strong>Value Type:</strong> List of strings. </li> </ul> <p>The <code>path</code> value within the <a href="#namespace-module">module namespace</a> contains the path of the module that the namespace represents. This is represented as a list of strings.</p> <p>As an example, if the following module block was present within a Terraform configuration:</p> <pre data-language="ruby">module "foo" {
  # ...
}
</pre>
<p>The following policy would evaluate to <code>true</code>, <em>only</em> if the module was present in the state:</p> <pre>import "tfstate"

main = rule { tfstate.module(["foo"]).path contains "foo" }
</pre>
<h2 id="namespace-resources-data-sources">  Namespace: Resources/Data Sources </h2> <p>The <strong>resource namespace</strong> is a namespace <em>type</em> that applies to both resources (accessed by using the <code>resources</code> namespace key) and data sources (accessed using the <code>data</code> namespace key).</p> <p>Accessing an individual resource or data source within each respective namespace can be accomplished by specifying the type, name, and resource number (as if the resource or data source had a <code>count</code> value in it) in the syntax <code>[resources|data].TYPE.NAME[NUMBER]</code>. Note that NUMBER is always needed, even if you did not use <code>count</code> in the resource.</p> <p>In addition, each of these namespace levels is a map, allowing you to filter based on type and name.</p> <blockquote class="alert alert-info" role="alert"> <p>The (somewhat strange) notation here of <code>TYPE.NAME[NUMBER]</code> may imply that the inner resource index map is actually a list, but it's not - using the square bracket notation over the dotted notation (<code>TYPE.NAME.NUMBER</code>) is required here as an identifier cannot start with number.</p> </blockquote> <p>Some examples of multi-level access are below:</p> <ul> <li>To fetch all <code>aws_instance.foo</code> resource instances within the root module, you can specify <code>tfstate.resources.aws_instance.foo</code>. This would then be indexed by resource count index (<code>0</code>, <code>1</code>, <code>2</code>, and so on). Note that as mentioned above, these elements must be accessed using square-bracket map notation (so <code>[0]</code>, <code>[1]</code>, <code>[2]</code>, and so on) instead of dotted notation. </li> <li>To fetch all <code>aws_instance</code> resources within the root module, you can specify <code>tfstate.resources.aws_instance</code>. This would be indexed from the names of each resource (<code>foo</code>, <code>bar</code>, and so on), with each of those maps containing instances indexed by resource count index as per above. </li> <li>To fetch all resources within the root module, irrespective of type, use <code>tfstate.resources</code>. This is indexed by type, as shown above with <code>tfstate.resources.aws_instance</code>, with names being the next level down, and so on. </li> </ul> <p>Further explanation of the namespace will be in the context of resources. As mentioned, when operating on data sources, use the same syntax, except with <code>data</code> in place of <code>resources</code>.</p> <h3 id="value-attr">  Value: <code>attr</code> </h3> <ul> <li>
<strong>Value Type:</strong> A string-keyed map of values. </li> </ul> <p>The <code>attr</code> value within the <a href="#namespace-resources-data-sources">resource namespace</a> is a direct mapping to the state of the resource.</p> <p>The map is a complex representation of these values with data going as far down as needed to represent any state values such as maps, lists, and sets.</p> <p>As an example, given the following resource:</p> <pre data-language="ruby">resource "null_resource" "foo" {
  triggers = {
    foo = "bar"
  }
}
</pre>
<p>The following policy would evaluate to <code>true</code> if the resource was in the state:</p> <pre>import "tfstate"

main = rule { tfstate.resources.null_resource.foo[0].attr.triggers.foo is "bar" }
</pre>
<h3 id="value-depends_on">  Value: <code>depends_on</code> </h3> <ul> <li>
<strong>Value Type:</strong> A list of strings. </li> </ul> <p>The <code>depends_on</code> value within the <a href="#namespace-resources-data-sources">resource namespace</a> contains the dependencies for the resource.</p> <p>This is a list of full resource addresses, relative to the module (example: <code>null_resource.foo</code>).</p> <p>As an example, given the following resources:</p> <pre data-language="ruby">resource "null_resource" "foo" {
  triggers = {
    foo = "bar"
  }
}

resource "null_resource" "bar" {
  # ...

  depends_on = [
    "null_resource.foo",
  ]
}
</pre>
<p>The following policy would evaluate to <code>true</code> if the resource was in the state:</p> <pre>import "tfstate"

main = rule { tfstate.resources.null_resource.bar[0].depends_on contains "null_resource.foo" }
</pre>
<h3 id="value-id">  Value: <code>id</code> </h3> <ul> <li>
<strong>Value Type:</strong> String. </li> </ul> <p>The <code>id</code> value within the <a href="#namespace-resources-data-sources">resource namespace</a> contains the id of the resource.</p> <blockquote class="alert alert-info" role="alert"> <p><strong>NOTE:</strong> The example below uses a <em>data source</em> here because the <a href="https://registry.terraform.io/providers/hashicorp/null/latest/docs/data-sources/data_source"><code>null_data_source</code></a> data source gives a static ID, which makes documenting the example easier. As previously mentioned, data sources share the same namespace as resources, but need to be loaded with the <code>data</code> key. For more information, see the <a href="#namespace-resources-data-sources">synopsis</a> for the namespace itself.</p> </blockquote> <p>As an example, given the following data source:</p> <pre data-language="ruby">data "null_data_source" "foo" {
  # ...
}
</pre>
<p>The following policy would evaluate to <code>true</code>:</p> <pre>import "tfstate"

main = rule { tfstate.data.null_data_source.foo[0].id is "static" }
</pre>
<h3 id="value-tainted">  Value: <code>tainted</code> </h3> <ul> <li>
<strong>Value Type:</strong> Boolean. </li> </ul> <p>The <code>tainted</code> value within the <a href="#namespace-resources-data-sources">resource namespace</a> is <code>true</code> if the resource is marked as tainted in Terraform state.</p> <p>As an example, given the following resource:</p> <pre data-language="ruby">resource "null_resource" "foo" {
  triggers = {
    foo = "bar"
  }
}
</pre>
<p>The following policy would evaluate to <code>true</code>, if the resource was marked as tainted in the state:</p> <pre>import "tfstate"

main = rule { tfstate.resources.null_resource.foo[0].tainted }
</pre>
<h2 id="namespace-outputs">  Namespace: Outputs </h2> <p>The <strong>output namespace</strong> represents all of the outputs present within a <a href="#namespace-module">module</a>. Outputs are present in a state if they were saved during a previous apply, or if they were updated with known values during the pre-plan refresh.</p> <p><strong>With Terraform 0.11 or earlier</strong> this can be used to fetch both the outputs of the root module, and the outputs of any module in the state below the root. This makes it possible to see outputs that have not been threaded to the root module.</p> <p><strong>With Terraform 0.12 or later</strong> outputs are available in the top-level (root module) namespace only and not accessible within submodules.</p> <p>This namespace is indexed by output name.</p> <h3 id="value-sensitive">  Value: <code>sensitive</code> </h3> <ul> <li>
<strong>Value Type:</strong> Boolean. </li> </ul> <p>The <code>sensitive</code> value within the <a href="#namespace-outputs">output namespace</a> is <code>true</code> when the output has been <a href="../../../language/values/outputs#sensitive-suppressing-values-in-cli-output">marked as sensitive</a>.</p> <p>As an example, given the following output:</p> <pre data-language="ruby">output "foo" {
  sensitive = true
  value     = "bar"
}
</pre>
<p>The following policy would evaluate to <code>true</code>:</p> <pre>import "tfstate"

main = rule { tfstate.outputs.foo.sensitive }
</pre>
<h3 id="value-type">  Value: <code>type</code> </h3> <ul> <li>
<strong>Value Type:</strong> String. </li> </ul> <p>The <code>type</code> value within the <a href="#namespace-outputs">output namespace</a> gives the output's type. This will be one of <code>string</code>, <code>list</code>, or <code>map</code>. These are currently the only types available for outputs in Terraform.</p> <p>As an example, given the following output:</p> <pre data-language="ruby">output "string" {
  value = "foo"
}

output "list" {
  value = [
    "foo",
    "bar",
  ]
}

output "map" {
  value = {
    foo = "bar"
  }
}
</pre>
<p>The following policy would evaluate to <code>true</code>:</p> <pre>import "tfstate"

type_string = rule { tfstate.outputs.string.type is "string" }
type_list = rule { tfstate.outputs.list.type is "list" }
type_map = rule { tfstate.outputs.map.type is "map" }

main = rule { type_string and type_list and type_map }
</pre>
<h3 id="value-value">  Value: <code>value</code> </h3> <ul> <li>
<strong>Value Type:</strong> String, list, or map. </li> </ul> <p>The <code>value</code> value within the <a href="#namespace-outputs">output namespace</a> is the value of the output in question.</p> <p>Note that the only valid primitive output type in Terraform is currently a string, which means that any int, float, or boolean value will need to be converted before it can be used in comparison. This does not apply to primitives within maps and lists, which will be their original types.</p> <p>As an example, given the following output blocks:</p> <pre data-language="ruby">output "foo" {
  value = "bar"
}

output "number" {
  value = "42"
}

output "map" {
  value = {
    foo    = "bar"
    number = 42
  }
}
</pre>
<p>The following policy would evaluate to <code>true</code>:</p> <pre>import "tfstate"

value_foo = rule { tfstate.outputs.foo.value is "bar" }
value_number = rule { int(tfstate.outputs.number.value) is 42 }
value_map_string = rule { tfstate.outputs.map.value["foo"] is "bar" }
value_map_int = rule { tfstate.outputs.map.value["number"] is 42 }

main = rule { value_foo and value_number and value_map_string and value_map_int }
</pre><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.terraform.io/docs/cloud/sentinel/import/tfstate.html" class="_attribution-link" target="_blank">https://www.terraform.io/docs/cloud/sentinel/import/tfstate.html</a>
  </p>
</div>
