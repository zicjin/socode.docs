 <h1 id="import-tfconfig">  Import: tfconfig </h1> <blockquote class="alert alert-info" role="alert"> <p><strong>Note:</strong> Sentinel policies are a paid feature, available as part of the <strong>Team &amp; Governance</strong> upgrade package. <a href="https://www.hashicorp.com/products/terraform/pricing">Learn more about Terraform Cloud pricing here</a>.</p> </blockquote> <p>The <code>tfconfig</code> import provides access to a Terraform configuration.</p> <p>The Terraform configuration is the set of <code>*.tf</code> files that are used to describe the desired infrastructure state. Policies using the <code>tfconfig</code> import can access all aspects of the configuration: providers, resources, data sources, modules, and variables.</p> <p>Some use cases for <code>tfconfig</code> include:</p> <ul> <li>
<strong>Organizational naming conventions</strong>: requiring that configuration elements are named in a way that conforms to some organization-wide standard. </li> <li>
<strong>Required inputs and outputs</strong>: organizations may require a particular set of input variable names across all workspaces or may require a particular set of outputs for asset management purposes. </li> <li>
<strong>Enforcing particular modules</strong>: organizations may provide a number of "building block" modules and require that each workspace be built only from combinations of these modules. </li> <li>
<strong>Enforcing particular providers or resources</strong>: an organization may wish to require or prevent the use of providers and/or resources so that configuration authors cannot use alternative approaches to work around policy restrictions. </li> </ul> <p>Note with these use cases that this import is concerned with object <em>names</em> in the configuration. Since this is the configuration and not an invocation of Terraform, you can't see values for variables, the state, or the diff for a pending plan. If you want to write policy around expressions used within configuration blocks, you likely want to use the <a href="tfplan"><code>tfplan</code></a> import.</p> <h2 id="namespace-overview">  Namespace Overview </h2> <p>The following is a tree view of the import namespace. For more detail on a particular part of the namespace, see below.</p> <blockquote class="alert alert-info" role="alert"> <p><strong>Note:</strong> The root-level alias keys shown here (<code>data</code>, <code>modules</code>, <code>providers</code>, <code>resources</code>, and <code>variables</code>) are shortcuts to a <a href="#namespace-module">module namespace</a> scoped to the root module. For more details, see the section on <a href="#root-namespace-aliases">root namespace aliases</a>.</p> </blockquote> <pre>tfconfig
├── module() (function)
│   └── (module namespace)
│       ├── data
│       │   └── TYPE.NAME
│       │       ├── config (map of keys)
│       │       ├── references (map of keys) (TF 0.12 and later)
│       │       └── provisioners
│       │           └── NUMBER
│       │               ├── config (map of keys)
│       │               ├── references (map of keys) (TF 0.12 and later)
│       │               └── type (string)
│       ├── modules
│       │   └── NAME
│       │       ├── config (map of keys)
│       │       ├── references (map of keys) (TF 0.12 and later)
│       │       ├── source (string)
│       │       └── version (string)
│       ├──outputs
│       │   └── NAME
│       │       ├── depends_on (list of strings)
│       │       ├── description (string)
│       │       ├── sensitive (boolean)
│       │       ├── references (list of strings) (TF 0.12 and later)
│       │       └── value (value)
│       ├── providers
│       │   └── TYPE
│       │       ├── alias
│       │       │   └── ALIAS
│       │       │       ├── config (map of keys)
│       │       |       ├── references (map of keys) (TF 0.12 and later)
│       │       │       └── version (string)
│       │       ├── config (map of keys)
│       │       ├── references (map of keys) (TF 0.12 and later)
│       │       └── version (string)
│       ├── resources
│       │   └── TYPE.NAME
│       │       ├── config (map of keys)
│       │       ├── references (map of keys) (TF 0.12 and later)
│       │       └── provisioners
│       │           └── NUMBER
│       │               ├── config (map of keys)
│       │               ├── references (map of keys) (TF 0.12 and later)
│       │               └── type (string)
│       └── variables
│           └── NAME
│               ├── default (value)
│               └── description (string)
├── module_paths ([][]string)
│
├── data (root module alias)
├── modules (root module alias)
├── outputs (root module alias)
├── providers (root module alias)
├── resources (root module alias)
└── variables (root module alias)
</pre>
<h3 id="references-with-terraform-0-12">  <code>references</code> with Terraform 0.12 </h3> <p><strong>With Terraform 0.11 or earlier</strong>, if a configuration value is defined as an expression (and not a static value), the value will be accessible in its raw, non-interpolated string (just as with a constant value).</p> <p>As an example, consider the following resource block:</p> <pre data-language="ruby">resource "local_file" "accounts" {
  content  = "some text"
  filename = "${var.subdomain}.${var.domain}/accounts.txt"
}
</pre>
<p>In this example, one might want to ensure <code>domain</code> and <code>subdomain</code> input variables are used within <code>filename</code> in this configuration. With Terraform 0.11 or earlier, the following policy would evaluate to <code>true</code>:</p> <pre>import "tfconfig"

# filename_value is the raw, non-interpolated string
filename_value = tfconfig.resources.local_file.accounts.config.filename

main = rule {
    filename_value contains "${var.domain}" and
    filename_value contains "${var.subdomain}"
}
</pre>
<p><strong>With Terraform 0.12 or later</strong>, any non-static values (such as interpolated strings) are not present within the configuration value and <code>references</code> should be used instead:</p> <pre>import "tfconfig"

# filename_references is a list of string values containing the references used in the expression
filename_references = tfconfig.resources.local_file.accounts.references.filename

main = rule {
  filename_references contains "var.domain" and
  filename_references contains "var.subdomain"
}
</pre>
<p>The <code>references</code> value is present in any namespace where non-constant configuration values can be expressed. This is essentially every namespace which has a <code>config</code> value as well as the <code>outputs</code> namespace.</p> <blockquote class="alert alert-info" role="alert"> <p><strong>Note:</strong> Remember, this import enforces policy around the literal Terraform configuration and not the final values as a result of invoking Terraform. If you want to write policy around the <em>result</em> of expressions used within configuration blocks (for example, if you wanted to ensure the final value of <code>filename</code> above includes <code>accounts.txt</code>), you likely want to use the <a href="tfplan"><code>tfplan</code></a> import.</p> </blockquote> <h2 id="namespace-root">  Namespace: Root </h2> <p>The root-level namespace consists of the values and functions documented below.</p> <p>In addition to this, the root-level <code>data</code>, <code>modules</code>, <code>providers</code>, <code>resources</code>, and <code>variables</code> keys all alias to their corresponding namespaces within the <a href="#namespace-module">module namespace</a>.</p>  <h3 id="function-module-">  Function: <code>module()</code> </h3> <pre>module = func(ADDR)
</pre> <ul> <li>
<strong>Return Type:</strong> A <a href="#namespace-module">module namespace</a>. </li> </ul> <p>The <code>module()</code> function in the <a href="#namespace-root">root namespace</a> returns the <a href="#namespace-module">module namespace</a> for a particular module address.</p> <p>The address must be a list and is the module address, split on the period (<code>.</code>), excluding the root module.</p> <p>Hence, a module with an address of simply <code>foo</code> (or <code>root.foo</code>) would be <code>["foo"]</code>, and a module within that (so address <code>foo.bar</code>) would be read as <code>["foo", "bar"]</code>.</p> <p><a href="https://docs.hashicorp.com/sentinel/language/spec#null"><code>null</code></a> is returned if a module address is invalid, or if the module is not present in the configuration.</p> <p>As an example, given the following module block:</p> <pre data-language="ruby">module "foo" {
  # ...
}
</pre>
<p>If the module contained the following content:</p> <pre data-language="ruby">resource "null_resource" "foo" {
  triggers = {
    foo = "bar"
  }
}
</pre>
<p>The following policy would evaluate to <code>true</code>:</p> <pre>import "tfconfig"

main = rule { subject.module(["foo"]).resources.null_resource.foo.config.triggers[0].foo is "bar" }
</pre>
 <h3 id="value-module_paths">  Value: <code>module_paths</code> </h3> <ul> <li>
<strong>Value Type:</strong> List of a list of strings. </li> </ul> <p>The <code>module_paths</code> value within the <a href="#namespace-root">root namespace</a> is a list of all of the modules within the Terraform configuration.</p> <p>Modules not present in the configuration will not be present here, even if they are present in the diff or state.</p> <p>This data is represented as a list of a list of strings, with the inner list being the module address, split on the period (<code>.</code>).</p> <p>The root module is included in this list, represented as an empty inner list.</p> <p>As an example, if the following module block was present within a Terraform configuration:</p> <pre data-language="ruby">module "foo" {
  # ...
}
</pre>
<p>The value of <code>module_paths</code> would be:</p> <pre>[
    [],
    ["foo"],
]
</pre>
<p>And the following policy would evaluate to <code>true</code>:</p> <pre>import "tfconfig"

main = rule { tfconfig.module_paths contains ["foo"] }
</pre>
<h4 id="iterating-through-modules">  Iterating Through Modules </h4> <p>Iterating through all modules to find particular resources can be useful. This <a href="index#iterate-over-modules-and-find-resources">example</a> shows how to use <code>module_paths</code> with the <a href="#function-module-"><code>module()</code> function</a> to find all resources of a particular type from all modules using the <code>tfplan</code> import. By changing <code>tfplan</code> in this function to <code>tfconfig</code>, you could make a similar function find all resources of a specific type in the Terraform configuration.</p> <h2 id="namespace-module">  Namespace: Module </h2> <p>The <strong>module namespace</strong> can be loaded by calling <a href="#root-function-module"><code>module()</code></a> for a particular module.</p> <p>It can be used to load the following child namespaces:</p> <ul> <li>
<a href="#data"><code>data</code></a> - Loads the <a href="#namespace-resources-data-sources">resource namespace</a>, filtered against data sources. </li> <li>
<a href="#modules"><code>modules</code></a> - Loads the <a href="#namespace-module-configuration">module configuration namespace</a>. </li> <li>
<a href="#outputs"><code>outputs</code></a> - Loads the <a href="#namespace-outputs">output namespace</a>. </li> <li>
<a href="#providers"><code>providers</code></a> - Loads the <a href="#namespace-providers">provider namespace</a>. </li> <li>
<a href="#resources"><code>resources</code></a> - Loads the <a href="#namespace-resources-data-sources">resource namespace</a>, filtered against resources. </li> <li>
<a href="#variables"><code>variables</code></a> - Loads the <a href="#namespace-variables">variable namespace</a>. </li> </ul> <h3 id="root-namespace-aliases">  Root Namespace Aliases </h3> <p>The root-level <code>data</code>, <code>modules</code>, <code>providers</code>, <code>resources</code>, and <code>variables</code> keys all alias to their corresponding namespaces within the module namespace, loaded for the root module. They are the equivalent of running <code>module([]).KEY</code>.</p>  <h2 id="namespace-resources-data-sources">  Namespace: Resources/Data Sources </h2> <p>The <strong>resource namespace</strong> is a namespace <em>type</em> that applies to both resources (accessed by using the <code>resources</code> namespace key) and data sources (accessed using the <code>data</code> namespace key).</p> <p>Accessing an individual resource or data source within each respective namespace can be accomplished by specifying the type and name, in the syntax <code>[resources|data].TYPE.NAME</code>.</p> <p>In addition, each of these namespace levels is a map, allowing you to filter based on type and name. Some examples of multi-level access are below:</p> <ul> <li>To fetch all <code>aws_instance</code> resources within the root module, you can specify <code>tfconfig.resources.aws_instance</code>. This would give you a map of resource namespaces indexed from the names of each resource (<code>foo</code>, <code>bar</code>, and so on). </li> <li>To fetch all resources within the root module, irrespective of type, use <code>tfconfig.resources</code>. This is indexed by type, as shown above with <code>tfconfig.resources.aws_instance</code>, with names being the next level down. </li> </ul> <p>As an example, perhaps you wish to deny use of the <code>local_file</code> resource in your configuration. Consider the following resource block:</p> <pre data-language="ruby">resource "local_file" "foo" {
    content     = "foo!"
    filename = "${path.module}/foo.bar"
}
</pre>
<p>The following policy would fail:</p> <pre>import "tfconfig"

main = rule { tfconfig.resources not contains "local_file" }
</pre>
<p>Further explanation of the namespace will be in the context of resources. As mentioned, when operating on data sources, use the same syntax, except with <code>data</code> in place of <code>resources</code>.</p>  <h3 id="value-config">  Value: <code>config</code> </h3> <ul> <li>
<strong>Value Type:</strong> A string-keyed map of values. </li> </ul> <p>The <code>config</code> value within the <a href="#namespace-resources-data-sources">resource namespace</a> is a map of key-value pairs that directly map to Terraform config keys and values.</p> <blockquote class="alert alert-info" role="alert"> <p><strong>With Terraform 0.11 or earlier</strong>, if the config value is defined as an expression (and not a static value), the value will be in its raw, non-interpolated string. <strong>With Terraform 0.12 or later</strong>, any non-static values (such as interpolated strings) are not present and <a href="#resources-value-references"><code>references</code></a> should be used instead.</p> </blockquote> <p>As an example, consider the following resource block:</p> <pre data-language="ruby">resource "local_file" "accounts" {
  content  = "some text"
  filename = "accounts.txt"
}
</pre>
<p>In this example, one might want to access <code>filename</code> to validate that the correct file name is used. Given the above example, the following policy would evaluate to <code>true</code>:</p> <pre>import "tfconfig"

main = rule {
    tfconfig.resources.local_file.accounts.config.filename is "accounts.txt"
}
</pre>
 <h3 id="value-references">  Value: <code>references</code> </h3> <ul> <li>
<strong>Value Type:</strong> A string-keyed map of list values containing strings. </li> </ul> <blockquote class="alert alert-info" role="alert"> <p><strong>Note:</strong> This value is only present when using Terraform 0.12 or later.</p> </blockquote> <p>The <code>references</code> value within the <a href="#namespace-resources-data-sources">resource namespace</a> contains the identifiers within non-constant expressions found in <a href="#resources-value-config"><code>config</code></a>. See the <a href="#references-with-terraform-0-12">documentation on <code>references</code></a> for more information.</p>  <h3 id="value-provisioners">  Value: <code>provisioners</code> </h3> <ul> <li>
<strong>Value Type:</strong> List of <a href="#namespace-provisioners">provisioner namespaces</a>. </li> </ul> <p>The <code>provisioners</code> value within the <a href="#namespace-resources">resource namespace</a> represents the <a href="../../../language/resources/provisioners/syntax">provisioners</a> within a specific resource.</p> <p>Provisioners are listed in the order they were provided in the configuration file.</p> <p>While the <code>provisioners</code> value will be present within data sources, it will always be an empty map (in Terraform 0.11) or <code>null</code> (in Terraform 0.12) since data sources cannot actually have provisioners.</p> <p>The data within a provisioner can be inspected via the returned <a href="#namespace-provisioners">provisioner namespace</a>.</p> <h2 id="namespace-provisioners">  Namespace: Provisioners </h2> <p>The <strong>provisioner namespace</strong> represents the configuration for a particular <a href="../../../language/resources/provisioners/syntax">provisioner</a> within a specific resource.</p>  <h3 id="value-config-1">  Value: <code>config</code> </h3> <ul> <li>
<strong>Value Type:</strong> A string-keyed map of values. </li> </ul> <p>The <code>config</code> value within the <a href="#namespace-provisioners">provisioner namespace</a> represents the values of the keys within the provisioner.</p> <blockquote class="alert alert-info" role="alert"> <p><strong>With Terraform 0.11 or earlier</strong>, if the config value is defined as an expression (and not a static value), the value will be in its raw, non-interpolated string. <strong>With Terraform 0.12 or later</strong>, any non-static values (such as interpolated strings) are not present and <a href="#provisioners-value-references"><code>references</code></a> should be used instead.</p> </blockquote> <p>As an example, given the following resource block:</p> <pre data-language="ruby">resource "null_resource" "foo" {
  # ...

  provisioner "local-exec" {
    command = "echo ${self.private_ip} &gt; file.txt"
  }
}
</pre>
<p>The following policy would evaluate to <code>true</code>:</p> <pre>import "tfconfig"

main = rule {
    tfconfig.resources.null_resource.foo.provisioners[0].config.command is "echo ${self.private_ip} &gt; file.txt"
}
</pre>
 <h3 id="value-references-1">  Value: <code>references</code> </h3> <ul> <li>
<strong>Value Type:</strong> A string-keyed map of list values containing strings. </li> </ul> <blockquote class="alert alert-info" role="alert"> <p><strong>Note:</strong> This value is only present when using Terraform 0.12 or later.</p> </blockquote> <p>The <code>references</code> value within the <a href="#namespace-provisioners">provisioner namespace</a> contains the identifiers within non-constant expressions found in <a href="#provisioners-value-config"><code>config</code></a>. See the <a href="#references-with-terraform-0-12">documentation on <code>references</code></a> for more information.</p>  <h3 id="value-type">  Value: <code>type</code> </h3> <ul> <li>
<strong>Value Type:</strong> String. </li> </ul> <p>The <code>type</code> value within the <a href="#namespace-provisioners">provisioner namespace</a> represents the type of the specific provisioner.</p> <p>As an example, in the following resource block:</p> <pre data-language="ruby">resource "null_resource" "foo" {
  # ...

  provisioner "local-exec" {
    command = "echo ${self.private_ip} &gt; file.txt"
  }
}
</pre>
<p>The following policy would evaluate to <code>true</code>:</p> <pre>import "tfconfig"

main = rule { tfconfig.resources.null_resource.foo.provisioners[0].type is "local-exec" }
</pre>
<h2 id="namespace-module-configuration">  Namespace: Module Configuration </h2> <p>The <strong>module configuration</strong> namespace displays data on <em>module configuration</em> as it is given within a <code>module</code> block. This means that the namespace concerns itself with the contents of the declaration block (example: the <code>source</code> parameter and variable assignment keys), not the data within the module (example: any contained resources or data sources). For the latter, the module instance would need to be looked up with the <a href="#root-function-module"><code>module()</code> function</a>.</p>  <h3 id="value-source">  Value: <code>source</code> </h3> <ul> <li>
<strong>Value Type:</strong> String. </li> </ul> <p>The <code>source</code> value within the <a href="#namespace-module-configuration">module configuration namespace</a> represents the module source path as supplied to the module configuration.</p> <p>As an example, given the module declaration block:</p> <pre data-language="ruby">module "foo" {
  source = "./foo"
}
</pre>
<p>The following policy would evaluate to <code>true</code>:</p> <pre>import "tfconfig"

main = rule { tfconfig.modules.foo.source is "./foo" }
</pre>
 <h3 id="value-version">  Value: <code>version</code> </h3> <ul> <li>
<strong>Value Type:</strong> String. </li> </ul> <p>The <code>version</code> value within the <a href="#namespace-module-configuration">module configuration namespace</a> represents the <a href="../../../configuration/modules#module-versions">version constraint</a> for modules that support it, such as modules within the <a href="https://registry.terraform.io/">Terraform Module Registry</a> or the <a href="../../registry/index">Terraform Cloud private module registry</a>.</p> <p>As an example, given the module declaration block:</p> <pre data-language="ruby">module "foo" {
  source  = "foo/bar"
  version = "~&gt; 1.2"
}
</pre>
<p>The following policy would evaluate to <code>true</code>:</p> <pre>import "tfconfig"

main = rule { tfconfig.modules.foo.version is "~&gt; 1.2" }
</pre>
 <h3 id="value-config-2">  Value: <code>config</code> </h3> <ul> <li>
<strong>Value Type:</strong> A string-keyed map of values. </li> </ul> <blockquote class="alert alert-info" role="alert"> <p><strong>With Terraform 0.11 or earlier</strong>, if the config value is defined as an expression (and not a static value), the value will be in its raw, non-interpolated string. <strong>With Terraform 0.12 or later</strong>, any non-static values (such as interpolated strings) are not present and <a href="#modules-value-references"><code>references</code></a> should be used instead.</p> </blockquote> <p>The <code>config</code> value within the <a href="#namespace-module-configuration">module configuration namespace</a> represents the values of the keys within the module configuration. This is every key within a module declaration block except <a href="#modules-value-source"><code>source</code></a> and <a href="#modules-value-version"><code>version</code></a>, which have their own values.</p> <p>As an example, given the module declaration block:</p> <pre data-language="ruby">module "foo" {
  source = "./foo"

  bar = "baz"
}
</pre>
<p>The following policy would evaluate to <code>true</code>:</p> <pre>import "tfconfig"

main = rule { tfconfig.modules.foo.config.bar is "baz" }
</pre>
 <h3 id="value-references-2">  Value: <code>references</code> </h3> <ul> <li>
<strong>Value Type:</strong> A string-keyed map of list values containing strings. </li> </ul> <blockquote class="alert alert-info" role="alert"> <p><strong>Note:</strong> This value is only present when using Terraform 0.12 or later.</p> </blockquote> <p>The <code>references</code> value within the <a href="#namespace-module-configuration">module configuration namespace</a> contains the identifiers within non-constant expressions found in <a href="#modules-value-config"><code>config</code></a>. See the <a href="#references-with-terraform-0-12">documentation on <code>references</code></a> for more information.</p> <h2 id="namespace-outputs">  Namespace: Outputs </h2> <p>The <strong>output namespace</strong> represents <em>declared</em> output data within a configuration. As such, configuration for the <a href="#outputs-value-value"><code>value</code></a> attribute will be in its raw form, and not yet interpolated. For fully interpolated output values, see the <a href="tfstate"><code>tfstate</code> import</a>.</p> <p>This namespace is indexed by output name.</p>  <h3 id="value-depends_on">  Value: <code>depends_on</code> </h3> <ul> <li>
<strong>Value Type:</strong> A list of strings. </li> </ul> <p>The <code>depends_on</code> value within the <a href="#namespace-outputs">output namespace</a> represents any <em>explicit</em> dependencies for this output. For more information, see the <a href="../../../language/values/outputs#depends_on">depends_on output setting</a> within the general Terraform documentation.</p> <p>As an example, given the following output declaration block:</p> <pre data-language="ruby">output "id" {
  depends_on = ["null_resource.bar"]
  value      = "${null_resource.foo.id}"
}
</pre>
<p>The following policy would evaluate to <code>true</code>:</p> <pre>import "tfconfig"

main = rule { tfconfig.outputs.id.depends_on[0] is "null_resource.bar" }
</pre>
 <h3 id="value-description">  Value: <code>description</code> </h3> <ul> <li>
<strong>Value Type:</strong> String. </li> </ul> <p>The <code>description</code> value within the <a href="#namespace-outputs">output namespace</a> represents the defined description for this output.</p> <p>As an example, given the following output declaration block:</p> <pre data-language="ruby">output "id" {
  description = "foobar"
  value       = "${null_resource.foo.id}"
}
</pre>
<p>The following policy would evaluate to <code>true</code>:</p> <pre>import "tfconfig"

main = rule { tfconfig.outputs.id.description is "foobar" }
</pre>
 <h3 id="value-sensitive">  Value: <code>sensitive</code> </h3> <ul> <li>
<strong>Value Type:</strong> Boolean. </li> </ul> <p>The <code>sensitive</code> value within the <a href="#namespace-outputs">output namespace</a> represents if this value has been marked as sensitive or not.</p> <p>As an example, given the following output declaration block:</p> <pre data-language="ruby">output "id" {
  sensitive = true
  value     = "${null_resource.foo.id}"
}
</pre>
<p>The following policy would evaluate to <code>true</code>:</p> <pre>import "tfconfig"

main = rule { subject.outputs.id.sensitive }
</pre>
 <h3 id="value-value">  Value: <code>value</code> </h3> <ul> <li>
<strong>Value Type:</strong> Any primitive type, list or map. </li> </ul> <p>The <code>value</code> value within the <a href="#namespace-outputs">output namespace</a> represents the defined value for the output as declared in the configuration. Primitives will bear the implicit type of their declaration (string, int, float, or bool), and maps and lists will be represented as such.</p> <blockquote class="alert alert-info" role="alert"> <p><strong>With Terraform 0.11 or earlier</strong>, if the config value is defined as an expression (and not a static value), the value will be in its raw, non-interpolated string. <strong>With Terraform 0.12 or later</strong>, any non-static values (such as interpolated strings) are not present and <a href="#outputs-value-references"><code>references</code></a> should be used instead.</p> </blockquote> <p>As an example, given the following output declaration block:</p> <pre data-language="ruby">output "id" {
  value = "${null_resource.foo.id}"
}
</pre>
<p>With Terraform 0.11 or earlier the following policy would evaluate to <code>true</code>:</p> <pre>import "tfconfig"

main = rule { tfconfig.outputs.id.value is "${null_resource.foo.id}" }
</pre>
 <h3 id="value-references-3">  Value: <code>references</code> </h3> <ul> <li>
<strong>Value Type:</strong>. List of strings. </li> </ul> <blockquote class="alert alert-info" role="alert"> <p><strong>Note:</strong> This value is only present when using Terraform 0.12 or later.</p> </blockquote> <p>The <code>references</code> value within the <a href="#namespace-outputs">output namespace</a> contains the names of any referenced identifiers when <a href="#outputs-value-value"><code>value</code></a> is a non-constant expression.</p> <p>As an example, given the following output declaration block:</p> <pre data-language="ruby">output "id" {
  value = "${null_resource.foo.id}"
}
</pre>
<p>The following policy would evaluate to <code>true</code>:</p> <pre>import "tfconfig"

main = rule { tfconfig.outputs.id.references contains "null_resource.foo.id" }
</pre>
<h2 id="namespace-providers">  Namespace: Providers </h2> <p>The <strong>provider namespace</strong> represents data on the declared providers within a namespace.</p> <p>This namespace is indexed by provider type and <em>only</em> contains data about providers when actually declared. If you are using a completely implicit provider configuration, this namespace will be empty.</p> <p>This namespace is populated based on the following criteria:</p> <ul> <li>The top-level namespace <a href="#providers-value-config"><code>config</code></a> and <a href="#providers-value-version"><code>version</code></a> values are populated with the configuration and version information from the default provider (the provider declaration that lacks an alias). </li> <li>Any aliased providers are added as namespaces within the <a href="#providers-value-alias"><code>alias</code></a> value. </li> <li>If a module lacks a default provider configuration, the top-level <code>config</code> and <code>version</code> values will be empty. </li> </ul>  <h3 id="value-alias">  Value: <code>alias</code> </h3> <ul> <li>
<strong>Value Type:</strong> A map of <a href="#namespace-providers">provider namespaces</a>, indexed by alias. </li> </ul> <p>The <code>alias</code> value within the <a href="#namespace-providers">provider namespace</a> represents all declared <a href="../../../language/providers/configuration#alias-multiple-provider-configurations">non-default provider instances</a> for a specific provider type, indexed by their specific alias.</p> <p>The return type is a provider namespace with the data for the instance in question loaded. The <code>alias</code> key will not be available within this namespace.</p> <p>As an example, given the following provider declaration block:</p> <pre data-language="ruby">provider "aws" {
  alias  = "east"
  region = "us-east-1"
}
</pre>
<p>The following policy would evaluate to <code>true</code>:</p> <pre>import "tfconfig"

main = rule { tfconfig.providers.aws.alias.east.config.region is "us-east-1" }
</pre>
 <h3 id="value-config-3">  Value: <code>config</code> </h3> <ul> <li>
<strong>Value Type:</strong> A string-keyed map of values. </li> </ul> <blockquote class="alert alert-info" role="alert"> <p><strong>With Terraform 0.11 or earlier</strong>, if the config value is defined as an expression (and not a static value), the value will be in its raw, non-interpolated string. <strong>With Terraform 0.12 or later</strong>, any non-static values (such as interpolated strings) are not present and <a href="#providers-value-references"><code>references</code></a> should be used instead.</p> </blockquote> <p>The <code>config</code> value within the <a href="#namespace-providers">provider namespace</a> represents the values of the keys within the provider's configuration, with the exception of the provider version, which is represented by the <a href="#providers-value-version"><code>version</code></a> value. <a href="#providers-value-alias"><code>alias</code></a> is also not included when the provider is aliased.</p> <p>As an example, given the following provider declaration block:</p> <pre data-language="ruby">provider "aws" {
  region = "us-east-1"
}
</pre>
<p>The following policy would evaluate to <code>true</code>:</p> <pre>import "tfconfig"

main = rule { tfconfig.providers.aws.config.region is "us-east-1" }
</pre>
 <h3 id="value-references-4">  Value: <code>references</code> </h3> <ul> <li>
<strong>Value Type:</strong> A string-keyed map of list values containing strings. </li> </ul> <blockquote class="alert alert-info" role="alert"> <p><strong>Note:</strong> This value is only present when using Terraform 0.12 or later.</p> </blockquote> <p>The <code>references</code> value within the <a href="#namespace-providers">provider namespace</a> contains the identifiers within non-constant expressions found in <a href="#providers-value-config"><code>config</code></a>. See the <a href="#references-with-terraform-0-12">documentation on <code>references</code></a> for more information.</p>  <h3 id="value-version-1">  Value: <code>version</code> </h3> <ul> <li>
<strong>Value Type:</strong> String. </li> </ul> <p>The <code>version</code> value within the <a href="#namespace-providers">provider namespace</a> represents the explicit expected version of the supplied provider. This includes the pessimistic operator.</p> <p>As an example, given the following provider declaration block:</p> <pre data-language="ruby">provider "aws" {
  version = "~&gt; 1.34"
}
</pre>
<p>The following policy would evaluate to <code>true</code>:</p> <pre>import "tfconfig"

main = rule { tfconfig.providers.aws.version is "~&gt; 1.34" }
</pre>
<h2 id="namespace-variables">  Namespace: Variables </h2> <p>The <strong>variable namespace</strong> represents <em>declared</em> variable data within a configuration. As such, static data can be extracted, such as defaults, but not dynamic data, such as the current value of a variable within a plan (although this can be extracted within the <a href="tfplan"><code>tfplan</code> import</a>).</p> <p>This namespace is indexed by variable name.</p>  <h3 id="value-default">  Value: <code>default</code> </h3> <ul> <li>
<strong>Value Type:</strong> Any primitive type, list, map, or <code>null</code>. </li> </ul> <p>The <code>default</code> value within the <a href="#namespace-variables">variable namespace</a> represents the default for the variable as declared in the configuration.</p> <p>The actual value will be as configured. Primitives will bear the implicit type of their declaration (string, int, float, or bool), and maps and lists will be represented as such.</p> <p>If no default is present, the value will be <a href="https://docs.hashicorp.com/sentinel/language/spec#null"><code>null</code></a> (not to be confused with <a href="https://docs.hashicorp.com/sentinel/language/undefined"><code>undefined</code></a>).</p> <p>As an example, given the following variable blocks:</p> <pre data-language="ruby">variable "foo" {
  default = "bar"
}

variable "number" {
  default = 42
}
</pre>
<p>The following policy would evaluate to <code>true</code>:</p> <pre>import "tfconfig"

default_foo = rule { tfconfig.variables.foo.default is "bar" }
default_number = rule { tfconfig.variables.number.default is 42 }

main = rule { default_foo and default_number }
</pre>
 <h3 id="value-description-1">  Value: <code>description</code> </h3> <ul> <li>
<strong>Value Type:</strong> String. </li> </ul> <p>The <code>description</code> value within the <a href="#namespace-variables">variable namespace</a> represents the description of the variable, as provided in configuration.</p> <p>As an example, given the following variable block:</p> <pre data-language="ruby">variable "foo" {
  description = "foobar"
}
</pre>
<p>The following policy would evaluate to <code>true</code>:</p> <pre>import "tfconfig"

main = rule { tfconfig.variables.foo.description is "foobar" }
</pre><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.terraform.io/docs/cloud/sentinel/import/tfconfig.html" class="_attribution-link" target="_blank">https://www.terraform.io/docs/cloud/sentinel/import/tfconfig.html</a>
  </p>
</div>
