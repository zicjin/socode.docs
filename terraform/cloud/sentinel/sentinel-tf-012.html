 <h1 id="using-sentinel-with-terraform-0-12">  Using Sentinel with Terraform 0.12 </h1> <blockquote class="alert alert-info" role="alert"> <p><strong>Note:</strong> Sentinel policies are a paid feature, available as part of the <strong>Team &amp; Governance</strong> upgrade package. <a href="https://www.hashicorp.com/products/terraform/pricing">Learn more about Terraform Cloud pricing here</a>.</p> </blockquote> <p>The Terraform Sentinel imports (<a href="import/tfconfig"><code>tfconfig</code></a>, <a href="import/tfplan"><code>tfplan</code></a>, and <a href="import/tfstate"><code>tfstate</code></a>) have been updated to work with Terraform 0.12. Care has been taken to ensure that the API is as backwards compatible as possible and most policies will continue to work without modification.</p> <p>However, due to fundamental changes introduced in Terraform 0.12, some API changes were required. While <code>tfconfig</code> was most impacted, there have been notable changes to both <code>tfplan</code> and <code>tfstate</code> as well. These are described below. Your policies will need to be adjusted if they are affected by these changes.</p> <p>One change that affects the <code>tfconfig</code>, <code>tfplan</code>, and <code>tfstate</code> imports is that numeric attributes of resources are now treated as floats in Terraform 0.12. This could require some modifications if your current policies treat these attributes as strings. In particular, you might have to modify existence checks and comparisons done against numeric attributes.</p> <p>There are no explicit changes in the <a href="import/tfrun"><code>tfrun</code></a> import for Terrraform 0.12, but the <a href="import/tfrun#namespace-cost_estimate"><code>cost_estimate</code> namespace</a> does not appear in it for Terraform 0.11 since cost estimates are not available in workspaces that use Terraform 0.11.</p> <h2 id="changes-to-tfconfig">  Changes to <code>tfconfig</code> </h2> <p>Terraform 0.12 no longer exports raw configuration to Sentinel, so the <a href="import/tfconfig"><code>tfconfig</code></a> import has seen the most profound changes, with the introduction of the <code>references</code> key in several of the namespaces within the import. Certain block values (such as maps) are also referenced slightly differently on part of the greater emphasis on correctness in their definition in Terraform 0.12.</p> <h3 id="the-references-key">  The <code>references</code> Key </h3> <p>In Terraform 0.12, configuration values that do not contain static, constant values can no longer be referenced directly within their respective <code>config</code> or <code>value</code> keys. Attempting to do so will yield an <code>undefined</code> value.</p> <p>Instead, any identifiers referenced directly in an expression or via interpolation are now added to a <code>references</code> value, mirroring the structure of <code>config</code> or <code>value</code>, depending on the namespace.</p> <p>This affects resources, data sources, module calls, outputs, providers, and provisioners. Variables are not affected by this change as they cannot contain referenced expressions.</p> <p><strong>With Terraform 0.11 and Earlier:</strong></p> <pre>import "tfconfig"

# filename_value is the raw, non-interpolated string
filename_value = tfconfig.resources.local_file.accounts.config.filename

main = rule {
    filename_value contains "${var.domain}" and
    filename_value contains "${var.subdomain}"
}
</pre>
<p><strong>With Terraform 0.12 or Later:</strong></p> <pre>import "tfconfig"

# filename_references is a list of string values containing the references used in the expression
filename_references = tfconfig.resources.local_file.accounts.references.filename

main = rule {
  filename_references contains "var.domain" and
  filename_references contains "var.subdomain"
}
</pre>
<p>You can read more about <code>references</code> in <code>tfconfig</code> For more information, see <a href="import/tfconfig#references-with-terraform-0-12"><code>references</code> in the <code>tfconfig</code> import</a>.</p> <h3 id="referencing-map-values">  Referencing Map Values </h3> <p>As a consequence of no longer receiving raw Terraform configuration, map values are no longer represented as lists separated by their block index.</p> <p>This can be best demonstrated with a simple Sentinel policy for <a href="https://registry.terraform.io/providers/hashicorp/null/latest/docs/resources/resource"><code>null_resource</code></a>. In Terraform 0.11 and earlier, this is a valid <code>null_resource</code> declaration, and the two map values would be merged:</p> <p><strong>Valid <code>null_resource</code> Configuration for Terraform 0.11 or Earlier</strong></p> <pre data-language="ruby">resource "null_resource" "foo" {
  triggers {
    foo = "bar"
  }

  triggers {
    baz = "qux"
  }
}
</pre>
<p>When using <code>tfconfig</code> in Terraform 0.11 and earlier, you need to reference the values in each configuration block separately. This is done by referring to each block index of the list representation, within <code>triggers</code> in this case:</p> <p><strong>Sentinel Policy for <code>null_resource</code> in Terraform 0.11 or Earlier</strong></p> <pre>main = rule {
    tfconfig.resources.null_resource.foo.config.triggers[0].foo is "bar" and
    tfconfig.resources.null_resource.foo.config.triggers[1].baz is "qux"
}
</pre>
<p>In Terraform 0.12, this is no longer valid configuration for maps. The (previously optional) <code>=</code> assignment operator is now required, and as map values are technically not configuration sub-blocks, they can only be defined once.</p> <p><strong>Valid <code>null_resource</code> Configuration for Terraform 0.12 or Earlier</strong></p> <pre data-language="ruby">resource "null_resource" "foo" {
  triggers = {
    foo = "bar"
    baz = "qux"
  }
}
</pre>
<p>This configuration is also now correctly defined in Sentinel as an actual map. As this value is no longer a block, it is no longer referenced by a block index.</p> <p><strong>Sentinel Policy for <code>null_resource</code> in Terraform 0.12 or Later</strong></p> <pre>main = rule {
    tfconfig.resources.null_resource.foo.config.triggers.foo is "bar" and
    tfconfig.resources.null_resource.foo.config.triggers.baz is "qux"
}
</pre>
<p>Note that this does not affect <em>actual</em> blocks, which are generally represented as lists or sets - configuration for these cases will still need to be checked for at the expected block index for the relevant data.</p> <h2 id="changes-to-tfplan">  Changes to <code>tfplan</code> </h2> <p>When used as directed, the <a href="import/tfplan"><code>tfplan</code></a> import generally behaves the same way with Terraform 0.12 as it does with Terraform 0.11 with the following exceptions:</p> <ol> <li>The behavior of unknown values within the <a href="import/tfplan#value-applied"><code>applied</code></a> value when creating or changing resources. </li> <li>The behavior when destroying resources without re-creating them. </li> </ol> <h3 id="changes-to-unknown-values-in-applied">  Changes to Unknown Values in <code>applied</code> </h3> <p>Unknown values within <code>applied</code> in the <a href="import/tfplan#namespace-resources-data-sources">resource namespace</a> no longer return values with interpolation sequences, or the magic UUID (defined as <code>74D93920-ED26-11E3-AC10-0800200C9A66</code> in Terraform 0.11 or earlier). Instead, unknown values are now returned as <code>undefined</code>.</p> <p>As mentioned within the documentation for <code>tfplan</code>, relying on specific behavior of unknown data within <code>applied</code> is not supported. Instead, it is recommended to check the <a href="import/tfplan#value-computed"><code>computed</code></a> key within the <a href="import/tfplan#namespace-resource-diff">diff namespace</a> to validate whether or not a value is unknown before looking for it in <code>applied</code>.</p> <h3 id="changes-affecting-resources-being-destroyed-but-not-re-created">  Changes Affecting Resources Being Destroyed but not Re-created </h3> <p>In Terraform 0.11, when a resource is being destroyed but not re-created, it's <a href="import/tfplan#value-diff"><code>diff</code></a> value in the <code>tfplan</code> import is empty. In Terraform 0.12, however, the <code>diff</code> value does have data. Existing policies that test the condition <code>length(r.diff) == 0</code> to determine whether a resource is being destroyed but not re-created need to be updated for use with Terraform 0.12.</p> <p>Additionally, a change made in the <code>tfplan</code> import means that the <code>applied</code> value is absent when a resource is being destroyed but not re-created for both versions of Terraform. It is therefore very important to check whether this is the case in all Sentinel policies that use the <code>tfplan</code> import and the <code>applied</code> value to avoid <code>undefined</code> values in functions and rules.</p> <p>New <a href="import/tfplan#value-destroy"><code>destroy</code></a> and <a href="import/tfplan#value-requires_new"><code>requires_new</code></a> values have been added to the <code>tfplan</code> import to enable this check. Since these values are available both for Terraform 0.11 and 0.12, you can now test <code>r.destroy and not r.requires_new</code> to determine if a resource is being destroyed but not re-created with both versions of Terraform.</p> <p>Please note that if you are using Terraform Enterprise, you must use version v201909-1 or higher in order to use the <code>destroy</code> and <code>requires_new</code> values.</p> <h2 id="changes-to-tfstate">  Changes to <code>tfstate</code> </h2> <p>The <a href="import/tfstate"><code>tfstate</code></a> import has had the availability of outputs restricted to the top-level of the namespace, effectively restricting it to the root module only.</p> <h3 id="non-root-outputs-are-no-longer-available">  Non-Root <code>outputs</code> are no Longer Available </h3> <p>The <a href="import/tfstate#namespace-outputs">output namespace</a> is no longer available within <code>tfstate</code>'s <a href="import/tfstate#namespace-module">module namespace</a>. The namespace must now be accessed from the top-level <code>tfstate</code> namespace, effectively allowing outputs to be viewed for the root module only.</p> <p><strong>Valid</strong></p> <pre>main = rule { tfstate.outputs.foo is "bar" }
</pre>
<p><strong>No Longer Valid</strong></p> <pre>main = rule {
    tfstate.module([]).outputs.foo is "bar" or
    tfstate.module(["foo"]).outputs.foo is "bar"
}
</pre>
<h2 id="testing-a-policy-with-0-11-and-0-12-simultaneously">  Testing a Policy With 0.11 and 0.12 Simultaneously </h2> <p>It's strongly advised that you test your Sentinel policies after upgrading to Terraform 0.12 to ensure they continue to work as expected. <a href="mock">Mock generation</a> has also been updated to produce mock data for the Sentinel imports as they appear in Terraform 0.12.</p> <p>It's possible to set up a policy to be tested against both 0.11 and 0.12 simultaneously by generating the mock data necessary for both configurations, and setting up your Sentinel repository appropriately.</p> <h3 id="generating-mock-data-for-both-terraform-versions">  Generating Mock Data for Both Terraform Versions </h3> <blockquote class="alert alert-warning" role="alert"> <p><strong>NOTE:</strong> The following steps will <strong>permanently</strong> upgrade your workspace's state file to Terraform 0.12. This cannot be rolled back! Only carry these steps out on a workspace that you are okay with upgrading, or use a workspace solely devoted to testing.</p> </blockquote> <p>Use the steps below to generate mock data for both Terraform versions:</p> <ol> <li>Follow the instructions on <a href="../workspaces/settings#terraform-version">configuring the Terraform version of the workspace</a> and ensure that it set to the latest 0.11 release. </li> <li>
<a href="../run/ui#manually-starting-runs">Start a run</a> for the workspace and let it finish the plan phase. </li> <li>Follow the instructions to <a href="mock#generating-mock-data-using-the-ui">generate mock data using the UI</a> for a plan on the workspace. Save this data to a file reflective of its version, example: <code>run-abcdEFgH-sentinel-mocks-011.tar.gz</code>. </li> <li>
<a href="../run/ui#confirming-or-discarding-plans">Discard the plan</a>. </li> <li>Re-configure the Terraform version for the workspace, this time selecting the latest 0.12 release. </li> <li>Start a run for the workspace again. </li> <li>Generate the mock data for the plan again, this time saving it in something similar to <code>run-abcdEFgH-sentinel-mocks-012.tar.gz</code>. </li> <li>Discard the plan again. </li> </ol> <h3 id="data-and-test-structure">  Data and Test Structure </h3> <p>Once you have the mock data for both versions, it needs to be laid out properly so that it can be utilized by the tests that require a specific version.</p> <p>Building on the file layout we use in <a href="mock#using-mock-data">using mock data</a> section of our <a href="mock">mocking guide</a>, the following layout will allow you to have mock data for two versions co-exist at the same time:</p> <pre>.
├── test
│   └── test_tf_011_012
│       ├── tf011.json
│       └── tf012.json
├── test_tf_011_012.sentinel
└── testdata
    ├── tf-011
    │   ├── mock-tfconfig.sentinel
    │   ├── mock-tfplan.sentinel
    │   └── mock-tfstate.sentinel
    └── tf-012
        ├── mock-tfconfig.sentinel
        ├── mock-tfplan.sentinel
        └── mock-tfstate.sentinel
</pre>
<p>In this example, the <code>test_tf_011_012.sentinel</code> policy is a poilcy that would work for both Terraform 0.11 and Terraform 0.12. In the test suite (<code>test/test_tf_011_012</code>), we have two tests, one for each Terraform version, <code>tf011.json</code> (for Terraform 0.11) and <code>tf012.json</code> (for Terraform 0.12).</p> <p>The contents of each file indicates the test data to be used:</p> <p><code>tf011.json</code>:</p> <pre>{
  "mock": {
    "tfconfig": "../../testdata/tf-011/mock-tfconfig.sentinel",
    "tfplan": "../../testdata/tf-011/mock-tfplan.sentinel",
    "tfstate": "../../testdata/tf-011/mock-tfstate.sentinel"
  },
  "test": {
    "main": true
  }
}
</pre>
<p><code>tf012.json</code>:</p> <pre>{
  "mock": {
    "tfconfig": "../../testdata/tf-012/mock-tfconfig.sentinel",
    "tfplan": "../../testdata/tf-012/mock-tfplan.sentinel",
    "tfstate": "../../testdata/tf-012/mock-tfstate.sentinel"
  },
  "test": {
    "main": true
  }
}
</pre>
<p>With this setup, you can now run <code>sentinel test</code> and have the test assert against both sets of mock data at once:</p> <pre>$ sentinel test
PASS - test_tf_011_012.sentinel
  PASS - test/test_tf_011_012/tf011.json
  PASS - test/test_tf_011_012/tf012.json
</pre><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.terraform.io/docs/cloud/sentinel/sentinel-tf-012.html" class="_attribution-link" target="_blank">https://www.terraform.io/docs/cloud/sentinel/sentinel-tf-012.html</a>
  </p>
</div>
