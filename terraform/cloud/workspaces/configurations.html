 <h1 id="terraform-configurations-in-terraform-cloud-workspaces">  Terraform Configurations in Terraform Cloud Workspaces </h1> <p>Each Terraform Cloud workspace is associated with a particular <a href="../../language/index">Terraform configuration</a>, which is expected to change and evolve over time.</p> <p>Since every organization has its own preferred source code control practices, Terraform Cloud does not provide integrated version management. Instead, it expects Terraform configurations to be managed in your existing version control system (VCS).</p> <p>In order to perform <a href="../run/index">remote Terraform runs</a> for a given workspace, Terraform Cloud needs to periodically receive new versions of its configuration. Usually, this can be handled automatically by connecting a workspace to a VCS repository.</p> <blockquote class="alert alert-info" role="alert"> <p><strong>Note:</strong> If a workspace's <a href="settings#execution-mode">execution mode is set to local</a>, it doesn't require configuration versions, since Terraform Cloud won't perform runs for that workspace.</p> </blockquote> <h2 id="providing-configuration-versions">  Providing Configuration Versions </h2> <p>There are two ways to provide configuration versions for a workspace:</p> <ul> <li>
<p><strong>With a connected VCS repository.</strong> Terraform Cloud can automatically fetch content from supported VCS providers, and uses webhooks to get notified of code changes. This is the most convenient way to use Terraform Cloud. See <a href="../run/ui">The UI- and VCS-driven Run Workflow</a> for more information.</p> <p>A VCS connection can be configured <a href="creating">when a workspace is created</a>, or later in its <a href="vcs">version control settings</a>.</p> <blockquote class="alert alert-info" role="alert"> <p><strong>Note:</strong> When a workspace is connected to a VCS repository, directly uploaded configuration versions can only be used for <a href="../run/index#speculative-plans">speculative plans</a>. This helps ensure your VCS remains the source of truth for all real infrastructure changes.</p> </blockquote> </li> <li>
<p><strong>With direct uploads.</strong> You can use a variety of tools to directly upload configuration content to Terraform Cloud:</p> <ul> <li>
<strong>Terraform CLI:</strong> With <a href="../../language/settings/backends/remote">the <code>remote</code> backend</a> configured, the <code>terraform plan</code> and <code>terraform apply</code> commands will perform remote runs by uploading a configuration from a local working directory. See <a href="../run/cli">The CLI-driven Run Workflow</a> for more information. </li> <li>
<strong>API:</strong> Terraform Cloud's API can accept configurations as <code>.tar.gz</code> files, which can be uploaded by a CI system or other workflow tools. See <a href="../run/api">The API-driven Run Workflow</a> for more information. </li> </ul> <p>When configuration versions are provided via the CLI or API, Terraform Cloud can't automatically react to code changes in the underlying VCS repository.</p> </li> </ul> <h2 id="code-organization-and-repository-structure">  Code Organization and Repository Structure </h2> <h3 id="organizing-separate-configurations">  Organizing Separate Configurations </h3> <p>Most organizations either keep each Terraform configuration in a separate repository, or keep many Terraform configurations as separate directories in a single repository (often called a "monorepo").</p> <p>Terraform Cloud works well with either approach, but monorepos require some extra configuration:</p> <ul> <li>Each workspace must <a href="settings#terraform-working-directory">specify a Terraform working directory</a>, so Terraform Cloud knows which configuration to use. </li> <li>If the repository includes any shared Terraform modules, you must add those directories to the <a href="vcs#automatic-run-triggering">automatic run triggering setting</a> for any workspace that uses those modules. </li> </ul> <blockquote class="alert alert-info" role="alert"> <p><strong>Note:</strong> If your organization does not have a strong preference, we recommend using separate repositories for each configuration and using the private module registry to share modules. This allows for faster module development, since you don't have to update every configuration that consumes a module at the same time as the module itself.</p> </blockquote> <h3 id="organizing-multiple-environments-for-a-configuration">  Organizing Multiple Environments for a Configuration </h3> <p>There are also a variety of ways to handle multiple environments. The most common approaches are:</p> <ul> <li>All environments use the same main branch, and environment differences are handled with Terraform variables. To protect production environments, wait to apply runs until their changes are verified in staging. </li> <li>Different environments use different long-lived VCS branches. To protect production environments, merge changes to the production branch after they have been verified in staging. </li> <li>Different environments use completely separate configurations, and shared behaviors are handled with shared Terraform modules. To protect production environments, verify new module versions in staging before updating the version used in production. </li> </ul> <p>Terraform Cloud works well with all of these approaches. If you used long-lived branches, be sure to specify which branch to use in each workspace's VCS connection settings.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.terraform.io/docs/cloud/workspaces/configurations.html" class="_attribution-link" target="_blank">https://www.terraform.io/docs/cloud/workspaces/configurations.html</a>
  </p>
</div>
