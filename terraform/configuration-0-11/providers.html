 <h1 id="providers">  Providers </h1> <blockquote class="alert alert-info" role="alert"> <p><strong>Note:</strong> This page is about Terraform 0.11 and earlier. For Terraform 0.12 and later, see <a href="../language/providers/index">Configuration Language: Providers</a>.</p> </blockquote> <p>Providers are responsible in Terraform for managing the lifecycle of a <a href="resources">resource</a>: create, read, update, delete.</p> <p>Most providers require some sort of configuration to provide authentication information, endpoint URLs, etc. Where explicit configuration is required, a <code>provider</code> block is used within the configuration as illustrated in the following sections.</p> <p>By default, resources are matched with provider configurations by matching the start of the resource name. For example, a resource of type <code>vsphere_virtual_machine</code> is associated with a provider called <code>vsphere</code>.</p> <p>This page assumes you're familiar with the <a href="syntax">configuration syntax</a> already.</p> <h2 id="example">  Example </h2> <p>A provider configuration looks like the following:</p> <pre data-language="ruby">provider "aws" {
  access_key = "foo"
  secret_key = "bar"
  region     = "us-east-1"
}
</pre>
<h2 id="description">  Description </h2> <p>A <code>provider</code> block represents a configuration for the provider named in its header. For example, <code>provider "aws"</code> above is a configuration for the <code>aws</code> provider.</p> <p>Within the block body (between <code>{ }</code>) is configuration for the provider. The configuration is dependent on the type. Consult the <a href="https://registry.terraform.io/browse/providers">provider's documentation</a> for details. in each provider's documentation.</p> <p>The arguments <code>alias</code> and <code>version</code>, if present, are special arguments handled by Terraform Core for their respective features described above. All other arguments are defined by the provider itself.</p> <p>A <code>provider</code> block may be omitted if its body would be empty. Using a resource in configuration implicitly creates an empty provider configuration for it unless a <code>provider</code> block is explicitly provided.</p> <h2 id="initialization">  Initialization </h2> <p>Each time a new provider is added to configuration -- either explicitly via a <code>provider</code> block or by adding a resource from that provider -- it's necessary to initialize that provider before use. Initialization downloads and installs the provider's plugin and prepares it to be used.</p> <p>Provider initialization is one of the actions of <code>terraform init</code>. Running this command will download and initialize any providers that are not already initialized.</p> <p>Providers downloaded by <code>terraform init</code> are only installed for the current working directory; other working directories can have their own installed provider versions.</p> <p>Note that <code>terraform init</code> cannot automatically download providers that are not distributed by HashiCorp. See <a href="#third-party-plugins">Third-party Plugins</a> below for installation instructions.</p> <p>For more information, see <a href="../cli/commands/init">the <code>terraform init</code> command</a>.</p> <h2 id="provider-versions">  Provider Versions </h2> <p>Providers are released on a separate rhythm from Terraform itself, and thus have their own version numbers. For production use, it is recommended to constrain the acceptable provider versions via configuration, to ensure that new versions with breaking changes will not be automatically installed by <code>terraform init</code> in future.</p> <p>When <code>terraform init</code> is run <em>without</em> provider version constraints, it prints a suggested version constraint string for each provider:</p> <pre>The following providers do not have any version constraints in configuration,
so the latest version was installed.

To prevent automatic upgrades to new major versions that may contain breaking
changes, it is recommended to add version = "..." constraints to the
corresponding provider blocks in configuration, with the constraint strings
suggested below.

* provider.aws: version = "~&gt; 1.0"
</pre>
<p>To constrain the provider version as suggested, add a <code>version</code> argument to the provider configuration block:</p> <pre data-language="ruby">provider "aws" {
  version = "~&gt; 1.0"

  access_key = "foo"
  secret_key = "bar"
  region     = "us-east-1"
}
</pre>
<p>This special argument applies to <em>all</em> providers. <a href="../cli/commands/providers"><code>terraform providers</code></a> can be used to view the specified version constraints for all providers used in the current configuration.</p> <p>The <code>version</code> attribute value may either be a single explicit version or a version constraint expression. Constraint expressions use the following syntax to specify a <em>range</em> of versions that are acceptable:</p> <ul> <li>
<a href="#gt-1-2-0"><code>&gt;= 1.2.0</code></a>: version 1.2.0 or newer </li> <li>
<a href="#lt-1-2-0"><code>&lt;= 1.2.0</code></a>: version 1.2.0 or older </li> <li>
<a href="#gt-1-2-0-1"><code>~&gt; 1.2.0</code></a>: any non-beta version <code>&gt;= 1.2.0</code> and <code>&lt; 1.3.0</code>, e.g. <code>1.2.X</code> </li> <li>
<a href="#gt-1-2"><code>~&gt; 1.2</code></a>: any non-beta version <code>&gt;= 1.2.0</code> and <code>&lt; 2.0.0</code>, e.g. <code>1.X.Y</code> </li> <li>
<a href="#gt-1-0-0-lt-2-0-0"><code>&gt;= 1.0.0, &lt;= 2.0.0</code></a>: any version between 1.0.0 and 2.0.0 inclusive </li> </ul> <p>When <code>terraform init</code> is re-run with providers already installed, it will use an already-installed provider that meets the constraints in preference to downloading a new version. To upgrade to the latest acceptable version of each provider, run <code>terraform init -upgrade</code>. This command also upgrades to the latest versions of all Terraform modules.</p> <h2 id="multiple-provider-instances">  Multiple Provider Instances </h2> <p>You can define multiple configurations for the same provider in order to support multiple regions, multiple hosts, etc. The primary use case for this is using multiple cloud regions. Other use-cases include targeting multiple Docker hosts, multiple Consul hosts, etc.</p> <p>To include multiple configurations for a given provider, include multiple <code>provider</code> blocks with the same provider name, but set the <code>alias</code> field to an instance name to use for each additional instance. For example:</p> <pre data-language="ruby"># The default provider configuration
provider "aws" {
  # ...
}

# Additional provider configuration for west coast region
provider "aws" {
  alias  = "west"
  region = "us-west-2"
}
</pre>
<p>A <code>provider</code> block with out <code>alias</code> set is known as the <em>default</em> provider configuration. When <code>alias</code> is set, it creates an <em>additional</em> provider configuration. For providers that have no required configuration arguments, the implied <em>empty</em> configuration is also considered to be a <em>default</em> provider configuration.</p> <p>Resources are normally associated with the default provider configuration inferred from the resource type name. For example, a resource of type <code>aws_instance</code> uses the <em>default</em> (un-aliased) <code>aws</code> provider configuration unless otherwise stated.</p> <p>The <code>provider</code> argument within any <code>resource</code> or <code>data</code> block overrides this default behavior and allows an additional provider configuration to be selected using its alias:</p> <pre data-language="ruby">resource "aws_instance" "foo" {
  provider = "aws.west"

  # ...
}
</pre>
<p>The value of the <code>provider</code> argument is always the provider name and an alias separated by a period, such as <code>"aws.west"</code> above.</p> <p>Provider configurations may also be passed from a parent module into a child module, as described in <a href="modules#providers-within-modules"><em>Providers within Modules</em></a>.</p> <h2 id="interpolation">  Interpolation </h2> <p>Provider configurations may use <a href="interpolation">interpolation syntax</a> to allow dynamic configuration:</p> <pre data-language="ruby">provider "aws" {
  region = "${var.aws_region}"
}
</pre>
<p>Interpolation is supported only for the per-provider configuration arguments. It is not supported for the special <code>alias</code> and <code>version</code> arguments.</p> <p>Although in principle it is possible to use any interpolation expression within a provider configuration argument, providers must be configurable to perform almost all operations within Terraform, and so it is not possible to use expressions whose value cannot be known until after configuration is applied, such as the id of a resource.</p> <p>It is always valid to use <a href="variables">input variables</a> and <a href="data-sources">data sources</a> whose configurations do not in turn depend on as-yet-unknown values. <a href="locals">Local values</a> may also be used, but currently may cause errors when running <code>terraform destroy</code>.</p> <h2 id="third-party-plugins">  Third-party Plugins </h2> <p>Anyone can develop and distribute their own Terraform providers. (See <a href="https://learn.hashicorp.com/collections/terraform/providers?utm_source=WEBSITE/docs/extend/writing-custom-providers.htmlutm_medium=WEB_IO/docs/extend/writing-custom-providers.htmlutm_offer=ARTICLE_PAGE/docs/extend/writing-custom-providers.htmlutm_content=DOCS">Writing Custom Providers</a> for more about provider development.) These third-party providers must be manually installed, since <code>terraform init</code> cannot automatically download them.</p> <p>Install third-party providers by placing their plugin executables in the user plugins directory. The user plugins directory is in one of the following locations, depending on the host operating system:</p> <table>
<thead> <tr> <th>Operating system</th> <th>User plugins directory</th> </tr> </thead>
<tbody> <tr> <td>Windows</td> <td><code>%APPDATA%\terraform.d\plugins</code></td> </tr> <tr> <td>All other systems</td> <td><code>~/.terraform.d/plugins</code></td> </tr> </tbody>
</table> <p>Once a plugin is installed, <code>terraform init</code> can initialize it normally.</p> <p>Providers distributed by HashiCorp can also go in the user plugins directory. If a manually installed version meets the configuration's version constraints, Terraform will use it instead of downloading that provider. This is useful in airgapped environments and when testing pre-release provider builds.</p> <h3 id="plugin-names-and-versions">  Plugin Names and Versions </h3> <p>The naming scheme for provider plugins is <code>terraform-provider-&lt;NAME&gt;_vX.Y.Z</code>, and Terraform uses the name to understand the name and version of a particular provider binary.</p> <p>If multiple versions of a plugin are installed, Terraform will use the newest version that meets the configuration's version constraints.</p> <p>Third-party plugins are often distributed with an appropriate filename already set in the distribution archive, so that they can be extracted directly into the user plugins directory.</p> <h3 id="os-and-architecture-directories">  OS and Architecture Directories </h3> <p>Terraform plugins are compiled for a specific operating system and architecture, and any plugins in the root of the user plugins directory must be compiled for the current system.</p> <p>If you use the same plugins directory on multiple systems, you can install plugins into subdirectories with a naming scheme of <code>&lt;OS&gt;_&lt;ARCH&gt;</code> (for example, <code>darwin_amd64</code>). Terraform uses plugins from the root of the plugins directory and from the subdirectory that corresponds to the current system, ignoring other subdirectories.</p> <p>Terraform's OS and architecture strings are the standard ones used by the Go language. The following are the most common:</p> <ul> <li>
<a href="#darwin_amd64"><code>darwin_amd64</code></a> </li> <li>
<a href="#freebsd_386"><code>freebsd_386</code></a> </li> <li>
<a href="#freebsd_amd64"><code>freebsd_amd64</code></a> </li> <li>
<a href="#freebsd_arm"><code>freebsd_arm</code></a> </li> <li>
<a href="#linux_386"><code>linux_386</code></a> </li> <li>
<a href="#linux_amd64"><code>linux_amd64</code></a> </li> <li>
<a href="#linux_arm"><code>linux_arm</code></a> </li> <li>
<a href="#openbsd_386"><code>openbsd_386</code></a> </li> <li>
<a href="#openbsd_amd64"><code>openbsd_amd64</code></a> </li> <li>
<a href="#solaris_amd64"><code>solaris_amd64</code></a> </li> <li>
<a href="#windows_386"><code>windows_386</code></a> </li> <li>
<a href="#windows_amd64"><code>windows_amd64</code></a> </li> </ul> <h2 id="provider-plugin-cache">  Provider Plugin Cache </h2> <p>By default, <code>terraform init</code> downloads plugins into a subdirectory of the working directory so that each working directory is self-contained. As a consequence, if you have multiple configurations that use the same provider then a separate copy of its plugin will be downloaded for each configuration.</p> <p>Given that provider plugins can be quite large (on the order of hundreds of megabytes), this default behavior can be inconvenient for those with slow or metered Internet connections. Therefore Terraform optionally allows the use of a local directory as a shared plugin cache, which then allows each distinct plugin binary to be downloaded only once.</p> <p>To enable the plugin cache, use the <code>plugin_cache_dir</code> setting in <a href="../cli/config/config-file">the CLI configuration file</a>. For example:</p> <pre data-language="ruby"># (Note that the CLI configuration file is _not_ the same as the .tf files
#  used to configure infrastructure.)

plugin_cache_dir = "$HOME/.terraform.d/plugin-cache"
</pre>
<p>This directory must already exist before Terraform will cache plugins; Terraform will not create the directory itself.</p> <p>Please note that on Windows it is necessary to use forward slash separators (<code>/</code>) rather than the conventional backslash (<code>\</code>) since the configuration file parser considers a backslash to begin an escape sequence.</p> <p>Setting this in the configuration file is the recommended approach for a persistent setting. Alternatively, the <code>TF_PLUGIN_CACHE_DIR</code> environment variable can be used to enable caching or to override an existing cache directory within a particular shell session:</p> <pre data-language="shell">export TF_PLUGIN_CACHE_DIR="$HOME/.terraform.d/plugin-cache"
</pre>
<p>When a plugin cache directory is enabled, the <code>terraform init</code> command will still access the plugin distribution server to obtain metadata about which plugins are available, but once a suitable version has been selected it will first check to see if the selected plugin is already available in the cache directory. If so, the already-downloaded plugin binary will be used.</p> <p>If the selected plugin is not already in the cache, it will be downloaded into the cache first and then copied from there into the correct location under your current working directory.</p> <p>When possible, Terraform will use hardlinks or symlinks to avoid storing a separate copy of a cached plugin in multiple directories. At present, this is not supported on Windows and instead a copy is always created.</p> <p>The plugin cache directory must <em>not</em> be the third-party plugin directory or any other directory Terraform searches for pre-installed plugins, since the cache management logic conflicts with the normal plugin discovery logic when operating on the same directory.</p> <p>Please note that Terraform will never itself delete a plugin from the plugin cache once it's been placed there. Over time, as plugins are upgraded, the cache directory may grow to contain several unused versions which must be manually deleted.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.terraform.io/docs/configuration-0-11/providers.html" class="_attribution-link" target="_blank">https://www.terraform.io/docs/configuration-0-11/providers.html</a>
  </p>
</div>
