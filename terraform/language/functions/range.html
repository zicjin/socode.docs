 <h1 id="range-function">  <code>range</code> Function </h1> <p><code>range</code> generates a list of numbers using a start value, a limit value, and a step value.</p> <pre data-language="ruby">range(max)
range(start, limit)
range(start, limit, step)
</pre>
<p>The <code>start</code> and <code>step</code> arguments can be omitted, in which case <code>start</code> defaults to zero and <code>step</code> defaults to either one or negative one depending on whether <code>limit</code> is greater than or less than <code>start</code>.</p> <p>The resulting list is created by starting with the given <code>start</code> value and repeatedly adding <code>step</code> to it until the result is equal to or beyond <code>limit</code>.</p> <p>The interpretation of <code>limit</code> depends on the direction of <code>step</code>: for a positive step, the sequence is complete when the next number is greater than or equal to <code>limit</code>. For a negative step, it's complete when less than or equal.</p> <p>The sequence-building algorithm follows the following pseudocode:</p> <pre>let num = start
while num &lt; limit: (or, for negative step, num &gt;= limit)
  append num to the sequence
  num = num + step
return the sequence
</pre>
<p>Because the sequence is created as a physical list in memory, Terraform imposes an artificial limit of 1024 numbers in the resulting sequence in order to avoid unbounded memory usage if, for example, a very large value were accidentally passed as the limit or a very small value as the step. If the algorithm above would append the 1025th number to the sequence, the function immediately exits with an error.</p> <p>We recommend iterating over existing collections where possible, rather than creating ranges. However, creating small numerical sequences can sometimes be useful when combined with other collections in collection-manipulation functions or <code>for</code> expressions.</p> <h2 id="examples">  Examples </h2> <pre>&gt; range(3)
[
  0,
  1,
  2,
]

&gt; range(1, 4)
[
  1,
  2,
  3,
]

&gt; range(1, 8, 2)
[
  1,
  3,
  5,
  7,
]

&gt; range(1, 4, 0.5)
[
  1,
  1.5,
  2,
  2.5,
  3,
  3.5,
]

&gt; range(4, 1)
[
  4,
  3,
  2,
]

&gt; range(10, 5, -2)
[
  10,
  8,
  6,
]
</pre>
<p>The <code>range</code> function is primarily useful when working with other collections to produce a certain number of instances of something. For example:</p> <pre data-language="ruby">variable "name_counts" {
  type    = map(number)
  default = {
    "foo" = 2
    "bar" = 4
  }
}

locals {
  expanded_names = {
    for name, count in var.name_counts : name =&gt; [
      for i in range(count) : format("%s%02d", name, i)
    ]
  }
}

output "expanded_names" {
  value = local.expanded_names
}

# Produces the following expanded_names value when run with the default
# "name_counts":
#
# {
#   "bar" = [
#     "bar00",
#     "bar01",
#     "bar02",
#     "bar03",
#   ]
#   "foo" = [
#     "foo00",
#     "foo01",
#   ]
# }
</pre><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.terraform.io/docs/language/functions/range.html" class="_attribution-link" target="_blank">https://www.terraform.io/docs/language/functions/range.html</a>
  </p>
</div>
