 <h1 id="defaults-function">  <code>defaults</code> Function </h1> <blockquote class="alert alert-info" role="alert"> <p><strong>Note:</strong> This function is available only in Terraform 0.15 and later.</p> </blockquote> <blockquote class="alert alert-warning" role="alert"> <p><strong>Experimental:</strong> This function is part of <a href="../expressions/type-constraints#experimental-optional-object-type-attributes">the optional attributes experiment</a> and is only available in modules where the <code>module_variable_optional_attrs</code> experiment is explicitly enabled.</p> </blockquote> <p>The <code>defaults</code> function is a specialized function intended for use with input variables whose type constraints are object types or collections of object types that include optional attributes.</p> <p>When you define an attribute as optional and the caller doesn't provide an explicit value for it, Terraform will set the attribute to <code>null</code> to represent that it was omitted. If you want to use a placeholder value other than <code>null</code> when an attribute isn't set, you can use the <code>defaults</code> function to concisely assign default values only where an attribute value was set to <code>null</code>.</p> <pre>defaults(input_value, defaults)
</pre>
<p>The <code>defaults</code> function expects that the <code>input_value</code> argument will be the value of an input variable with an exact <a href="../expressions/types">type constraint</a> (not containing <code>any</code>). The function will then visit every attribute in the data structure, including attributes of nested objects, and apply the default values given in the defaults object.</p> <p>The interpretation of attributes in the <code>defaults</code> argument depends on what type an attribute has in the <code>input_value</code>:</p> <ul> <li>
<strong>Primitive types</strong> (<code>string</code>, <code>number</code>, <code>bool</code>): if a default value is given then it will be used only if the <code>input_value</code>'s attribute of the same name has the value <code>null</code>. The default value's type must match the input value's type. </li> <li>
<strong>Structural types</strong> (<code>object</code> and <code>tuple</code> types): Terraform will recursively visit all of the attributes or elements of the nested value and repeat the same defaults-merging logic one level deeper. The default value's type must be of the same kind as the input value's type, and a default value for an object type must only contain attribute names that appear in the input value's type. </li> <li>
<strong>Collection types</strong> (<code>list</code>, <code>map</code>, and <code>set</code> types): Terraform will visit each of the collection elements in turn and apply defaults to them. In this case the default value is only a single value to be applied to <em>all</em> elements of the collection, so it must have a type compatible with the collection's element type rather than with the collection type itself. </li> </ul> <p>The above rules may be easier to follow with an example. Consider the following Terraform configuration:</p> <pre data-language="ruby">terraform {
  # Optional attributes and the defaults function are
  # both experimental, so we must opt in to the experiment.
  experiments = [module_variable_optional_attrs]
}

variable "storage" {
  type = object({
    name    = string
    enabled = optional(bool)
    website = object({
      index_document = optional(string)
      error_document = optional(string)
    })
    documents = map(
      object({
        source_file  = string
        content_type = optional(string)
      })
    )
  })
}

locals {
  storage = defaults(var.storage, {
    # If "enabled" isn't set then it will default
    # to true.
    enabled = true

    # The "website" attribute is required, but
    # it's here to provide defaults for the
    # optional attributes inside.
    website = {
      index_document = "index.html"
      error_document = "error.html"
    }

    # The "documents" attribute has a map type,
    # so the default value represents defaults
    # to be applied to all of the elements in
    # the map, not for the map itself. Therefore
    # it's a single object matching the map
    # element type, not a map itself.
    documents = {
      # If _any_ of the map elements omit
      # content_type then this default will be
      # used instead.
      content_type = "application/octet-stream"
    }
  })
}

output "storage" {
  value = local.storage
}
</pre>
<p>To test this out, we can create a file <code>terraform.tfvars</code> to provide an example value for <code>var.storage</code>:</p> <pre data-language="ruby">storage = {
  name = "example"

  website = {
    error_document = "error.txt"
  }
  documents = {
    "index.html" = {
      source_file  = "index.html.tmpl"
      content_type = "text/html"
    }
    "error.txt" = {
      source_file  = "error.txt.tmpl"
      content_type = "text/plain"
    }
    "terraform.exe" = {
      source_file  = "terraform.exe"
    }
  }
}
</pre>
<p>The above value conforms to the variable's type constraint because it only omits attributes that are declared as optional. Terraform will automatically populate those attributes with the value <code>null</code> before evaluating anything else, and then the <code>defaults</code> function in <code>local.storage</code> will substitute default values for each of them.</p> <p>The result of this <code>defaults</code> call would therefore be the following object:</p> <pre>storage = {
  "documents" = tomap({
    "error.txt" = {
      "content_type" = "text/plain"
      "source_file"  = "error.txt.tmpl"
    }
    "index.html" = {
      "content_type" = "text/html"
      "source_file"  = "index.html.tmpl"
    }
    "terraform.exe" = {
      "content_type" = "application/octet-stream"
      "source_file"  = "terraform.exe"
    }
  })
  "enabled" = true
  "name" = "example"
  "website" = {
    "error_document" = "error.txt"
    "index_document" = "index.html"
  }
}
</pre>
<p>Notice that <code>enabled</code> and <code>website.index_document</code> were both populated directly from the defaults. Notice also that the <code>"terraform.exe"</code> element of <code>documents</code> had its <code>content_type</code> attribute populated from the <code>documents</code> default, but the default value didn't need to predict that there would be an element key <code>"terraform.exe"</code> because the default values apply equally to all elements of the map where the optional attributes are <code>null</code>.</p> <h2 id="using-defaults-elsewhere">  Using <code>defaults</code> elsewhere </h2> <p>The design of the <code>defaults</code> function depends on input values having well-specified type constraints, so it can reliably recognize the difference between similar types: maps vs. objects, lists vs. tuples. The type constraint causes Terraform to convert the caller's value to conform to the constraint and thus <code>defaults</code> can rely on the input to conform.</p> <p>Elsewhere in the Terraform language it's typical to be less precise about types, for example using the object construction syntax <code>{ ... }</code> to construct values that will be used as if they are maps. Because <code>defaults</code> uses the type information of <code>input_value</code>, an <code>input_value</code> that <em>doesn't</em> originate in an input variable will tend not to have an appropriate value type and will thus not be interpreted as expected by <code>defaults</code>.</p> <p>We recommend using <code>defaults</code> only with fully-constrained input variable values in the first argument, so you can use the variable's type constraint to explicitly distinguish between collection and structural types.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.terraform.io/docs/language/functions/defaults.html" class="_attribution-link" target="_blank">https://www.terraform.io/docs/language/functions/defaults.html</a>
  </p>
</div>
