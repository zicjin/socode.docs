 <h1 id="flatten-function">  <code>flatten</code> Function </h1> <p><code>flatten</code> takes a list and replaces any elements that are lists with a flattened sequence of the list contents.</p> <h2 id="examples">  Examples </h2> <pre>&gt; flatten([["a", "b"], [], ["c"]])
["a", "b", "c"]
</pre>
<p>If any of the nested lists also contain directly-nested lists, these too are flattened recursively:</p> <pre>&gt; flatten([[["a", "b"], []], ["c"]])
["a", "b", "c"]
</pre>
<p>Indirectly-nested lists, such as those in maps, are <em>not</em> flattened.</p> <h2 id="flattening-nested-structures-for-for_each">  Flattening nested structures for <code>for_each</code> </h2> <p>The <a href="../meta-arguments/for_each">resource <code>for_each</code></a> and <a href="../expressions/dynamic-blocks"><code>dynamic</code> block</a> language features both require a collection value that has one element for each repetition.</p> <p>Sometimes your input data structure isn't naturally in a suitable shape for use in a <code>for_each</code> argument, and <code>flatten</code> can be a useful helper function when reducing a nested data structure into a flat one.</p> <p>For example, consider a module that declares a variable like the following:</p> <pre data-language="ruby">variable "networks" {
  type = map(object({
    cidr_block = string
    subnets    = map(object({ cidr_block = string }))
  }))
}
</pre>
<p>The above is a reasonable way to model objects that naturally form a tree, such as top-level networks and their subnets. The repetition for the top-level networks can use this variable directly, because it's already in a form where the resulting instances match one-to-one with map elements:</p> <pre data-language="ruby">resource "aws_vpc" "example" {
  for_each = var.networks

  cidr_block = each.value.cidr_block
}
</pre>
<p>However, in order to declare all of the <em>subnets</em> with a single <code>resource</code> block, we must first flatten the structure to produce a collection where each top-level element represents a single subnet:</p> <pre data-language="ruby">locals {
  # flatten ensures that this local value is a flat list of objects, rather
  # than a list of lists of objects.
  network_subnets = flatten([
    for network_key, network in var.networks : [
      for subnet_key, subnet in network.subnets : {
        network_key = network_key
        subnet_key  = subnet_key
        network_id  = aws_vpc.example[network_key].id
        cidr_block  = subnet.cidr_block
      }
    ]
  ])
}

resource "aws_subnet" "example" {
  # local.network_subnets is a list, so we must now project it into a map
  # where each key is unique. We'll combine the network and subnet keys to
  # produce a single unique key per instance.
  for_each = {
    for subnet in local.network_subnets : "${subnet.network_key}.${subnet.subnet_key}" =&gt; subnet
  }

  vpc_id            = each.value.network_id
  availability_zone = each.value.subnet_key
  cidr_block        = each.value.cidr_block
}
</pre>
<p>The above results in one subnet instance per subnet object, while retaining the associations between the subnets and their containing networks.</p> <h2 id="related-functions">  Related Functions </h2> <ul> <li>
<a href="setproduct"><code>setproduct</code></a> finds all of the combinations of multiple lists or sets of values, which can also be useful when preparing collections for use with <code>for_each</code> constructs. </li> </ul><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.terraform.io/docs/language/functions/flatten.html" class="_attribution-link" target="_blank">https://www.terraform.io/docs/language/functions/flatten.html</a>
  </p>
</div>
