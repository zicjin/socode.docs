 <h1 id="setproduct-function">  <code>setproduct</code> Function </h1> <p>The <code>setproduct</code> function finds all of the possible combinations of elements from all of the given sets by computing the <a href="https://en.wikipedia.org/wiki/Cartesian_product">Cartesian product</a>.</p> <pre data-language="ruby">setproduct(sets...)
</pre>
<p>This function is particularly useful for finding the exhaustive set of all combinations of members of multiple sets, such as per-application-per-environment resources.</p> <pre>&gt; setproduct(["development", "staging", "production"], ["app1", "app2"])
[
  [
    "development",
    "app1",
  ],
  [
    "development",
    "app2",
  ],
  [
    "staging",
    "app1",
  ],
  [
    "staging",
    "app2",
  ],
  [
    "production",
    "app1",
  ],
  [
    "production",
    "app2",
  ],
]
</pre>
<p>You must pass at least two arguments to this function.</p> <p>Although defined primarily for sets, this function can also work with lists. If all of the given arguments are lists then the result is a list, preserving the ordering of the given lists. Otherwise the result is a set. In either case, the result's element type is a list of values corresponding to each given argument in turn.</p> <h2 id="examples">  Examples </h2> <p>There is an example of the common usage of this function above. There are some other situations that are less common when hand-writing but may arise in reusable module situations.</p> <p>If any of the arguments is empty then the result is always empty itself, similar to how multiplying any number by zero gives zero:</p> <pre>&gt; setproduct(["development", "staging", "production"], [])
[]
</pre>
<p>Similarly, if all of the arguments have only one element then the result has only one element, which is the first element of each argument:</p> <pre>&gt; setproduct(["a"], ["b"])
[
  [
    "a",
    "b",
  ],
]
</pre>
<p>Each argument must have a consistent type for all of its elements. If not, Terraform will attempt to convert to the most general type, or produce an error if such a conversion is impossible. For example, mixing both strings and numbers results in the numbers being converted to strings so that the result elements all have a consistent type:</p> <pre>&gt; setproduct(["staging", "production"], ["a", 2])
[
  [
    "staging",
    "a",
  ],
  [
    "staging",
    "2",
  ],
  [
    "production",
    "a",
  ],
  [
    "production",
    "2",
  ],
]
</pre>
<h2 id="finding-combinations-for-for_each">  Finding combinations for <code>for_each</code> </h2> <p>The <a href="../meta-arguments/for_each">resource <code>for_each</code></a> and <a href="../expressions/dynamic-blocks"><code>dynamic</code> block</a> language features both require a collection value that has one element for each repetition.</p> <p>Sometimes your input data comes in separate values that cannot be directly used in a <code>for_each</code> argument, and <code>setproduct</code> can be a useful helper function for the situation where you want to find all unique combinations of elements in a number of different collections.</p> <p>For example, consider a module that declares variables like the following:</p> <pre data-language="ruby">variable "networks" {
  type = map(object({
    base_cidr_block = string
  }))
}

variable "subnets" {
  type = map(object({
    number = number
  }))
}
</pre>
<p>If the goal is to create each of the defined subnets per each of the defined networks, creating the top-level networks can directly use <code>var.networks</code> because it's already in a form where the resulting instances match one-to-one with map elements:</p> <pre data-language="ruby">resource "aws_vpc" "example" {
  for_each = var.networks

  cidr_block = each.value.base_cidr_block
}
</pre>
<p>However, in order to declare all of the <em>subnets</em> with a single <code>resource</code> block, we must first produce a collection whose elements represent all of the combinations of networks and subnets, so that each element itself represents a subnet:</p> <pre data-language="ruby">locals {
  # setproduct works with sets and lists, but our variables are both maps
  # so we'll need to convert them first.
  networks = [
    for key, network in var.networks : {
      key        = key
      cidr_block = network.cidr_block
    }
  ]
  subnets = [
    for key, subnet in var.subnets : {
      key    = key
      number = subnet.number
    }
  ]

  network_subnets = [
    # in pair, element zero is a network and element one is a subnet,
    # in all unique combinations.
    for pair in setproduct(local.networks, local.subnets) : {
      network_key = pair[0].key
      subnet_key  = pair[1].key
      network_id  = aws_vpc.example[pair[0].key].id

      # The cidr_block is derived from the corresponding network. See the
      # cidrsubnet function for more information on how this calculation works.
      cidr_block = cidrsubnet(pair[0].cidr_block, 4, pair[1].number)
    }
  ]
}

resource "aws_subnet" "example" {
  # local.network_subnets is a list, so we must now project it into a map
  # where each key is unique. We'll combine the network and subnet keys to
  # produce a single unique key per instance.
  for_each = {
    for subnet in local.network_subnets : "${subnet.network_key}.${subnet.subnet_key}" =&gt; subnet
  }

  vpc_id            = each.value.network_id
  availability_zone = each.value.subnet_key
  cidr_block        = each.value.cidr_block
}
</pre>
<p>The above results in one subnet instance per combination of network and subnet elements in the input variables.</p> <h2 id="related-functions">  Related Functions </h2> <ul> <li>
<a href="contains"><code>contains</code></a> tests whether a given list or set contains a given element value. </li> <li>
<a href="flatten"><code>flatten</code></a> is useful for flattening hierarchical data into a single list, for situations where the relationships between two object types are defined explicitly. </li> <li>
<a href="setintersection"><code>setintersection</code></a> computes the <em>intersection</em> of multiple sets. </li> <li>
<a href="setsubtract"><code>setsubtract</code></a> computes the <em>relative complement</em> of two sets </li> <li>
<a href="setunion"><code>setunion</code></a> computes the <em>union</em> of multiple sets. </li> </ul><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.terraform.io/docs/language/functions/setproduct.html" class="_attribution-link" target="_blank">https://www.terraform.io/docs/language/functions/setproduct.html</a>
  </p>
</div>
