 <h1 id="type-constraints">  Type Constraints </h1> <p>Terraform module authors and provider developers can use detailed type constraints to validate user-provided values for their input variables and resource arguments. This requires some additional knowledge about Terraform's type system, but allows you to build a more resilient user interface for your modules and resources.</p> <h2 id="type-keywords-and-constructors">  Type Keywords and Constructors </h2> <p>Type constraints are expressed using a mixture of <em>type keywords</em> and function-like constructs called <em>type constructors.</em></p> <ul> <li>Type keywords are unquoted symbols that represent a static type. </li> <li>Type constructors are unquoted symbols followed by a pair of parentheses, which contain an argument that specifies more information about the type. Without its argument, a type constructor does not fully represent a type; instead, it represents a <em>kind</em> of similar types. </li> </ul> <p>Type constraints look like other kinds of Terraform <a href="index">expressions</a>, but are a special syntax. Within the Terraform language, they are only valid in the <code>type</code> argument of an <a href="../values/variables">input variable</a>.</p> <h2 id="primitive-types">  Primitive Types </h2> <p>A <em>primitive</em> type is a simple type that isn't made from any other types. All primitive types in Terraform are represented by a type keyword. The available primitive types are:</p> <ul> <li>
<a href="#string"><code>string</code></a>: a sequence of Unicode characters representing some text, such as <code>"hello"</code>. </li> <li>
<a href="#number"><code>number</code></a>: a numeric value. The <code>number</code> type can represent both whole numbers like <code>15</code> and fractional values such as <code>6.283185</code>. </li> <li>
<a href="#bool"><code>bool</code></a>: either <code>true</code> or <code>false</code>. <code>bool</code> values can be used in conditional logic. </li> </ul> <h3 id="conversion-of-primitive-types">  Conversion of Primitive Types </h3> <p>The Terraform language will automatically convert <code>number</code> and <code>bool</code> values to <code>string</code> values when needed, and vice-versa as long as the string contains a valid representation of a number or boolean value.</p> <ul> <li>
<a href="#true"><code>true</code></a> converts to <code>"true"</code>, and vice-versa </li> <li>
<a href="#false"><code>false</code></a> converts to <code>"false"</code>, and vice-versa </li> <li>
<a href="#15"><code>15</code></a> converts to <code>"15"</code>, and vice-versa </li> </ul> <h2 id="complex-types">  Complex Types </h2> <p>A <em>complex</em> type is a type that groups multiple values into a single value. Complex types are represented by type constructors, but several of them also have shorthand keyword versions.</p> <p>There are two categories of complex types: collection types (for grouping similar values), and structural types (for grouping potentially dissimilar values).</p> <h3 id="collection-types">  Collection Types </h3> <p>A <em>collection</em> type allows multiple values of <em>one</em> other type to be grouped together as a single value. The type of value <em>within</em> a collection is called its <em>element type.</em> All collection types must have an element type, which is provided as the argument to their constructor.</p> <p>For example, the type <code>list(string)</code> means "list of strings", which is a different type than <code>list(number)</code>, a list of numbers. All elements of a collection must always be of the same type.</p> <p>The three kinds of collection type in the Terraform language are:</p> <ul> <li>
<p><a href="#list-"><code>list(...)</code></a>: a sequence of values identified by consecutive whole numbers starting with zero.</p> <p>The keyword <code>list</code> is a shorthand for <code>list(any)</code>, which accepts any element type as long as every element is the same type. This is for compatibility with older configurations; for new code, we recommend using the full form.</p> </li> <li>
<p><a href="#map-"><code>map(...)</code></a>: a collection of values where each is identified by a string label.</p> <p>The keyword <code>map</code> is a shorthand for <code>map(any)</code>, which accepts any element type as long as every element is the same type. This is for compatibility with older configurations; for new code, we recommend using the full form.</p> <p>Maps can be made with braces ({}) and colons (:) or equals signs (=): { "foo": "bar", "bar": "baz" } OR { foo = "bar", bar = "baz" }. Quotes may be omitted on keys, unless the key starts with a number, in which case quotes are required. Commas are required between key/value pairs for single line maps. A newline between key/value pairs is sufficient in multi-line maps.</p> <p>Note: although colons are valid delimiters between keys and values, they are currently ignored by <code>terraform fmt</code> (whereas <code>terraform fmt</code> will attempt vertically align equals signs).</p> </li> <li>
<p><a href="#set-"><code>set(...)</code></a>: a collection of unique values that do not have any secondary identifiers or ordering.</p> </li> </ul> <h3 id="structural-types">  Structural Types </h3> <p>A <em>structural</em> type allows multiple values of <em>several distinct types</em> to be grouped together as a single value. Structural types require a <em>schema</em> as an argument, to specify which types are allowed for which elements.</p> <p>The two kinds of structural type in the Terraform language are:</p> <ul> <li>
<p><a href="#object-"><code>object(...)</code></a>: a collection of named attributes that each have their own type.</p> <p>The schema for object types is <code>{ &lt;KEY&gt; = &lt;TYPE&gt;, &lt;KEY&gt; = &lt;TYPE&gt;, ... }</code> — a pair of curly braces containing a comma-separated series of <code>&lt;KEY&gt; = &lt;TYPE&gt;</code> pairs. Values that match the object type must contain <em>all</em> of the specified keys, and the value for each key must match its specified type. (Values with <em>additional</em> keys can still match an object type, but the extra attributes are discarded during type conversion.)</p> </li> <li>
<p><a href="#tuple-"><code>tuple(...)</code></a>: a sequence of elements identified by consecutive whole numbers starting with zero, where each element has its own type.</p> <p>The schema for tuple types is <code>[&lt;TYPE&gt;, &lt;TYPE&gt;, ...]</code> — a pair of square brackets containing a comma-separated series of types. Values that match the tuple type must have <em>exactly</em> the same number of elements (no more and no fewer), and the value in each position must match the specified type for that position.</p> </li> </ul> <p>For example: an object type of <code>object({ name=string, age=number })</code> would match a value like the following:</p> <pre data-language="ruby">{
  name = "John"
  age  = 52
}
</pre>
<p>Also, an object type of <code>object({ id=string, cidr_block=string })</code> would match the object produced by a reference to an <code>aws_vpc</code> resource, like <code>aws_vpc.example_vpc</code>; although the resource has additional attributes, they would be discarded during type conversion.</p> <p>Finally, a tuple type of <code>tuple([string, number, bool])</code> would match a value like the following:</p> <pre data-language="ruby">["a", 15, true]
</pre>
<h3 id="complex-type-literals">  Complex Type Literals </h3> <p>The Terraform language has literal expressions for creating tuple and object values, which are described in <a href="types#literal-expressions">Expressions: Literal Expressions</a> as "list/tuple" literals and "map/object" literals, respectively.</p> <p>Terraform does <em>not</em> provide any way to directly represent lists, maps, or sets. However, due to the automatic conversion of complex types (described below), the difference between similar complex types is almost never relevant to a normal user, and most of the Terraform documentation conflates lists with tuples and maps with objects. The distinctions are only useful when restricting input values for a module or resource.</p> <h3 id="conversion-of-complex-types">  Conversion of Complex Types </h3> <p>Similar kinds of complex types (list/tuple/set and map/object) can usually be used interchangeably within the Terraform language, and most of Terraform's documentation glosses over the differences between the kinds of complex type. This is due to two conversion behaviors:</p> <ul> <li>Whenever possible, Terraform converts values between similar kinds of complex types if the provided value is not the exact type requested. "Similar kinds" is defined as follows: <ul> <li>Objects and maps are similar. <ul> <li>A map (or a larger object) can be converted to an object if it has <em>at least</em> the keys required by the object schema. Any additional attributes are discarded during conversion, which means map -&gt; object -&gt; map conversions can be lossy. </li> </ul> </li> <li>Tuples and lists are similar. <ul> <li>A list can only be converted to a tuple if it has <em>exactly</em> the required number of elements. </li> </ul> </li> <li>Sets are <em>almost</em> similar to both tuples and lists: <ul> <li>When a list or tuple is converted to a set, duplicate values are discarded and the ordering of elements is lost. </li> <li>When a <code>set</code> is converted to a list or tuple, the elements will be in an arbitrary order. If the set's elements were strings, they will be in lexicographical order; sets of other element types do not guarantee any particular order of elements. </li> </ul> </li> </ul> </li> <li>Whenever possible, Terraform converts <em>element values</em> within a complex type, either by converting complex-typed elements recursively or as described above in <a href="#conversion-of-primitive-types">Conversion of Primitive Types</a>. </li> </ul> <p>For example: if a module argument requires a value of type <code>list(string)</code> and a user provides the tuple <code>["a", 15, true]</code>, Terraform will internally transform the value to <code>["a", "15", "true"]</code> by converting the elements to the required <code>string</code> element type. Later, if the module uses those elements to set different resource arguments that require a string, a number, and a bool (respectively), Terraform will automatically convert the second and third strings back to the required types at that time, since they contain valid representations of a number and a bool.</p> <p>On the other hand, automatic conversion will fail if the provided value (including any of its element values) is incompatible with the required type. If an argument requires a type of <code>map(string)</code> and a user provides the object <code>{name = ["Kristy", "Claudia", "Mary Anne", "Stacey"], age = 12}</code>, Terraform will raise a type mismatch error, since a tuple cannot be converted to a string.</p> <h2 id="dynamic-types-the-quot-any-quot-constraint">  Dynamic Types: The "any" Constraint </h2> <p>The keyword <code>any</code> is a special construct that serves as a placeholder for a type yet to be decided. <code>any</code> is not <em>itself</em> a type: when interpreting a value against a type constraint containing <code>any</code>, Terraform will attempt to find a single actual type that could replace the <code>any</code> keyword to produce a valid result.</p> <p>For example, given the type constraint <code>list(any)</code>, Terraform will examine the given value and try to choose a replacement for the <code>any</code> that would make the result valid.</p> <p>If the given value were <code>["a", "b", "c"]</code> -- whose physical type is <code>tuple([string, string, string])</code>, Terraform analyzes this as follows:</p> <ul> <li>Tuple types and list types are <em>similar</em> per the previous section, so the tuple-to-list conversion rule applies. </li> <li>All of the elements in the tuple are strings, so the type constraint <code>string</code> would be valid for all of the list elements. </li> <li>Therefore in this case the <code>any</code> argument is replaced with <code>string</code>, and the final concrete value type is <code>list(string)</code>. </li> </ul> <p>All of the elements of a collection must have the same type, so conversion to <code>list(any)</code> requires that all of the given elements must be convertible to a common type. This implies some other behaviors that result from the conversion rules described in earlier sections.</p> <ul> <li>If the given value were instead <code>["a", 1, "b"]</code> then Terraform would still select <code>list(string)</code>, because of the primitive type conversion rules, and the resulting value would be <code>["a", "1", "b"]</code> due to the string conversion implied by that type constraint. </li> <li>If the given value were instead <code>["a", [], "b"]</code> then the value cannot conform to the type constraint: there is no single type that both a string and an empty tuple can convert to. Terraform would reject this value, complaining that all elements must have the same type. </li> </ul> <p>Although the above examples use <code>list(any)</code>, a similar principle applies to <code>map(any)</code> and <code>set(any)</code>.</p> <p>If you wish to apply absolutely no constraint to the given value, the <code>any</code> keyword can be used in isolation:</p> <pre data-language="ruby">variable "no_type_constraint" {
  type = any
}
</pre>
<p>In this case, Terraform will replace <code>any</code> with the exact type of the given value and thus perform no type conversion whatsoever.</p> <h2 id="experimental-optional-object-type-attributes">  Experimental: Optional Object Type Attributes </h2> <p>From Terraform v0.14 there is <em>experimental</em> support for marking particular attributes as optional in an object type constraint.</p> <p>To mark an attribute as optional, use the additional <code>optional(...)</code> modifier around its type declaration:</p> <pre data-language="ruby">variable "with_optional_attribute" {
  type = object({
    a = string           # a required attribute
    b = optional(string) # an optional attribute
  })
}
</pre>
<p>By default, for required attributes, Terraform will return an error if the source value has no matching attribute. Marking an attribute as optional changes the behavior in that situation: Terraform will instead just silently insert <code>null</code> as the value of the attribute, allowing the recieving module to describe an appropriate fallback behavior.</p> <p>Because this feature is currently experimental, it requires an explicit opt-in on a per-module basis. To use it, write a <code>terraform</code> block with the <code>experiments</code> argument set as follows:</p> <pre data-language="ruby">terraform {
  experiments = [module_variable_optional_attrs]
}
</pre>
<p>Until the experiment is concluded, the behavior of this feature may see breaking changes even in minor releases. We recommend using this feature only in prerelease versions of modules as long as it remains experimental.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.terraform.io/docs/language/expressions/type-constraints.html" class="_attribution-link" target="_blank">https://www.terraform.io/docs/language/expressions/type-constraints.html</a>
  </p>
</div>
