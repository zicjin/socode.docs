 <h1 id="terraform-language-documentation">  Terraform Language Documentation </h1> <p>This is the documentation for Terraform's configuration language. It is relevant to users of <a href="../cli/index">Terraform CLI</a>, <a href="../cloud/index">Terraform Cloud</a>, and <a href="https://www.terraform.io/docs/enterprise/index.html">Terraform Enterprise</a>.</p> <blockquote> <p><strong>Hands-on:</strong> Try the <a href="https://learn.hashicorp.com/collections/terraform/aws-get-started?utm_source=WEBSITE&amp;utm_medium=WEB_IO&amp;utm_offer=ARTICLE_PAGE&amp;utm_content=DOCS">Terraform: Get Started</a> collection on HashiCorp Learn.</p> </blockquote> <p><em>The Terraform language is Terraform's primary user interface.</em> In every edition of Terraform, a configuration written in the Terraform language is always at the heart of the workflow.</p> <h2 id="about-the-terraform-language">  About the Terraform Language </h2> <p>The main purpose of the Terraform language is declaring <a href="resources/index">resources</a>, which represent infrastructure objects. All other language features exist only to make the definition of resources more flexible and convenient.</p> <p>A <em>Terraform configuration</em> is a complete document in the Terraform language that tells Terraform how to manage a given collection of infrastructure. A configuration can consist of multiple files and directories.</p> <p>The syntax of the Terraform language consists of only a few basic elements:</p> <pre data-language="ruby">resource "aws_vpc" "main" {
  cidr_block = var.base_cidr_block
}

&lt;BLOCK TYPE&gt; "&lt;BLOCK LABEL&gt;" "&lt;BLOCK LABEL&gt;" {
  # Block body
  &lt;IDENTIFIER&gt; = &lt;EXPRESSION&gt; # Argument
}
</pre> <ul> <li>
<em>Blocks</em> are containers for other content and usually represent the configuration of some kind of object, like a resource. Blocks have a <em>block type,</em> can have zero or more <em>labels,</em> and have a <em>body</em> that contains any number of arguments and nested blocks. Most of Terraform's features are controlled by top-level blocks in a configuration file. </li> <li>
<em>Arguments</em> assign a value to a name. They appear within blocks. </li> <li>
<em>Expressions</em> represent a value, either literally or by referencing and combining other values. They appear as values for arguments, or within other expressions. </li> </ul> <p>The Terraform language is declarative, describing an intended goal rather than the steps to reach that goal. The ordering of blocks and the files they are organized into are generally not significant; Terraform only considers implicit and explicit relationships between resources when determining an order of operations.</p> <h3 id="example">  Example </h3> <p>The following example describes a simple network topology for Amazon Web Services, just to give a sense of the overall structure and syntax of the Terraform language. Similar configurations can be created for other virtual network services, using resource types defined by other providers, and a practical network configuration will often contain additional elements not shown here.</p> <pre data-language="ruby">terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~&gt; 1.0.4"
    }
  }
}

variable "aws_region" {}

variable "base_cidr_block" {
  description = "A /16 CIDR range definition, such as 10.1.0.0/16, that the VPC will use"
  default = "10.1.0.0/16"
}

variable "availability_zones" {
  description = "A list of availability zones in which to create subnets"
  type = list(string)
}

provider "aws" {
  region = var.aws_region
}

resource "aws_vpc" "main" {
  # Referencing the base_cidr_block variable allows the network address
  # to be changed without modifying the configuration.
  cidr_block = var.base_cidr_block
}

resource "aws_subnet" "az" {
  # Create one subnet for each given availability zone.
  count = length(var.availability_zones)

  # For each subnet, use one of the specified availability zones.
  availability_zone = var.availability_zones[count.index]

  # By referencing the aws_vpc.main object, Terraform knows that the subnet
  # must be created only after the VPC is created.
  vpc_id = aws_vpc.main.id

  # Built-in functions and operators can be used for simple transformations of
  # values, such as computing a subnet address. Here we create a /20 prefix for
  # each subnet, using consecutive addresses for each availability zone,
  # such as 10.1.16.0/20 .
  cidr_block = cidrsubnet(aws_vpc.main.cidr_block, 4, count.index+1)
}
</pre><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.terraform.io/docs/language/index.html" class="_attribution-link" target="_blank">https://www.terraform.io/docs/language/index.html</a>
  </p>
</div>
