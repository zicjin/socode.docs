 <h1 id="deprecations-removals-and-renames">  Deprecations, Removals, and Renames </h1> <p>Terraform is trusted for managing many facets of infrastructure across many organizations. Part of that trust is due to consistent versioning guidelines and setting expectations for various levels of upgrades. Ensuring backwards compatibility for all patch and minor releases, potentially in concert with any upcoming major changes, is recommended and supported by the Terraform development framework. This allows operators to iteratively update their Terraform configurations rather than require massive refactoring.</p> <p>This guide is designed to walk through various scenarios where existing Terraform functionality requires future removal, while maintaining backwards compatibility. Further information about the versioning terminology (e.g. <code>MAJOR</code>.<code>MINOR</code>.<code>PATCH</code>) in this guide can be found in <a href="versioning">the versioning guidelines documentation</a>.</p> <blockquote class="alert alert-warning" role="alert"> <p><strong>NOTE:</strong> Removals should only ever occur in <code>MAJOR</code> version upgrades.</p> </blockquote> <h2 id="table-of-contents">  Table of Contents </h2> <ul> <li>
<a href="#provider-attribute-removal">Provider Attribute Removal</a> </li> <li>
<a href="#provider-attribute-rename">Provider Attribute Rename</a> <ul> <li>
<a href="#renaming-a-required-attribute">Renaming a Required Attribute</a> </li> <li>
<a href="#renaming-an-optional-attribute">Renaming an Optional Attribute</a> </li> <li>
<a href="#renaming-a-computed-attribute">Renaming a Computed Attribute</a> </li> </ul> </li> <li>
<a href="#provider-data-source-or-resource-removal">Provider Data Source or Resource Removal</a> </li> <li>
<a href="#provider-data-source-or-resource-rename">Provider Data Source or Resource Rename</a> </li> </ul> <h2 id="provider-attribute-removal">  Provider Attribute Removal </h2> <p>The recommended process for removing an attribute from a data source or resource in a provider is as follows:</p> <ol> <li>Add <code>Deprecated</code> in the attribute schema definition. After an operator upgrades to this version, they will be shown a warning with the message provided when using the attribute, but the Terraform run will still complete. </li> <li>Ensure the changelog has an entry noting the deprecation. </li> <li>Release a <code>MINOR</code> version with the deprecation. </li> <li>In the next <code>MAJOR</code> version, remove all code associated with the attribute including the schema definition. </li> <li>Ensure the changelog has an entry noting the removal. </li> <li>Release the <code>MAJOR</code> version. </li> </ol> <h2 id="provider-attribute-rename">  Provider Attribute Rename </h2> <p>When renaming an attribute from one name to another, it is important to keep backwards compatibility with both existing Terraform configurations and the <a href="../../language/state/index">Terraform state</a> while operators migrate. To accomplish this, there will be some duplicated logic to support both attributes until the next <code>MAJOR</code> release. Once both attributes are appropriately handled, the process for deprecating and removing the old attribute is the same as noted in the <a href="#provider-attribute-removal">Provider Attribute Removal section</a>.</p> <p>The procedure for renaming an attribute depends on what type of attribute it is:</p> <ul> <li>
<a href="#renaming-a-required-attribute">Renaming a Required Attribute</a> </li> <li>
<a href="#renaming-an-optional-attribute">Renaming an Optional Attribute</a> </li> <li>
<a href="#renaming-a-computed-attribute">Renaming a Computed Attribute</a> </li> </ul> <h3 id="renaming-a-required-attribute">  Renaming a Required Attribute </h3> <blockquote class="alert alert-warning" role="alert"> <p><strong>NOTE:</strong> If the schema definition does not contain <code>Optional</code> or <code>Required</code>, see the <a href="#renaming-a-computed-attribute">Renaming a Computed Attribute section</a> instead. If the schema definition contains <code>Optional</code> instead of <code>Required</code>, see the <a href="#renaming-an-optional-attribute">Renaming an Optional Attribute section</a>.</p> </blockquote> <blockquote class="alert alert-info" role="alert"> <p><a href="../schemas/schema-behaviors#required">Required attributes</a> are also referred to as required "arguments" throughout the Terraform documentation.</p> </blockquote> <p>In general, the procedure here does two things:</p> <ul> <li>Prevents the operator from needing to define two attributes with the same value. </li> <li>Allows the operator to migrate the configuration to the new attribute at the same time requiring that any other references only work with the new attribute. This is to prevent a situation with Terraform showing a difference when the existing attribute is configured, but the new attribute is saved into the Terraform state. For example, in <code>terraform plan</code> output format: </li> </ul> <pre>existing_attribute: "" =&gt; "value"
new_attribute:      "value" =&gt; ""
</pre>
<p>The recommended process is as follows:</p> <ol> <li>Replace <code>Required: true</code> with <code>Optional: true</code> in the existing attribute schema definition. </li> <li>Replace <code>Required</code> with <code>Optional</code> in the existing attribute documentation. </li> <li>Duplicate the schema definition of the existing attribute, renaming one of them with the new attribute name. </li> <li>Duplicate the documentation of the existing attribute, renaming one of them with the new attribute name. </li> <li>Add <code>Deprecated</code> to the schema definition of the existing (now the "old") attribute, noting to use the new attribute in the message. </li> <li>Add <code>**Deprecated**</code> to the documentation of the existing (now the "old") attribute, noting to use the new attribute. </li> <li>Add a note to the documentation that either the existing (now the "old") attribute or new attribute must be configured. </li> <li>Add <code>ConflictsWith</code> to the schema definitions of both the old and new attributes so they will present an error to the operator if both are configured at the same time. </li> <li>Add conditional logic in the <code>Create</code>, <code>Read</code>, and <code>Update</code> functions of the data source or resource to handle both attributes. Generally, this involves using <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-sdk/helper/schema#ResourceData.GetOk"><code>ResourceData.GetOk()</code></a> (commonly <code>d.GetOk()</code> in HashiCorp maintained providers). </li> <li>Add conditional logic in the <code>Create</code> and <code>Update</code> function that returns an error if both the old and new attributes are not defined. </li> <li>Follow the rest of the procedures in the <a href="#provider-attribute-removal">Provider Attribute Removal section</a>. When the old attribute is removed, update the schema definition and documentation of the new attribute back to <code>Required</code>. </li> </ol> <h4 id="example-renaming-of-a-required-attribute">  Example Renaming of a Required Attribute </h4> <p>Given this sample resource:</p> <pre>func resourceExampleWidget() *schema.Resource {
    return &amp;schema.Resource{
        // ... other configuration ...

        Create: resourceExampleWidgetCreate,
        Read:   resourceExampleWidgetRead,
        Update: resourceExampleWidgetUpdate,

        Schema: map[string]*schema.Schema{
            // ... other attributes ...

            "existing_attribute": {
                Type:     schema.TypeString,
                Required: true,
            },
        },
    }
}

func resourceExampleWidgetCreate(d *schema.ResourceData, meta interface{}) error {
    // ... other logic ...

    existingAttribute := d.Get("existing_attribute").(string)
    // add attribute to provider create API call

    // ... other logic ...
    return resourceExampleWidgetRead(d, meta)
}

func resourceExampleWidgetRead(d *schema.ResourceData, meta interface{}) error {
    // ... other logic ...

    d.Set("existing_attribute", /* ... */)

    // ... other logic ...
    return nil
}

func resourceExampleWidgetUpdate(d *schema.ResourceData, meta interface{}) error {
    // ... other logic ...

    existingAttribute := d.Get("existing_attribute").(string)
    // add attribute to provider update API call

    // ... other logic ...
    return resourceExampleWidgetRead(d, meta)
}
</pre>
<p>In order to support renaming <code>existing_attribute</code> to <code>new_attribute</code>, this sample can be written as the following to support both attributes simultaneously until the <code>existing_attribute</code> is removed:</p> <pre>func resourceExampleWidget() *schema.Resource {
    return &amp;schema.Resource{
        // ... other configuration ...

        Create: resourceExampleWidgetCreate,
        Read:   resourceExampleWidgetRead,
        Update: resourceExampleWidgetUpdate,

        Schema: map[string]*schema.Schema{
            // ... other attributes ...

            "existing_attribute": {
                Type:          schema.TypeString,
                Optional:      true,
                ConflictsWith: []string{"new_attribute"},
                Deprecated:    "use new_attribute instead",
            },
            "new_attribute": {
                Type:          schema.TypeString,
                Optional:      true,
                ConflictsWith: []string{"existing_attribute"},
            },
        },
    }
}

func resourceExampleWidgetCreate(d *schema.ResourceData, meta interface{}) error {
    // ... other logic ...

    existingAttribute, existingAttributeOk := d.GetOk("existing_attribute")
    newAttribute, newAttributeOk := d.GetOk("new_attribute")
    if !existingAttributeOk &amp;&amp; !newAttributeOk {
        return errors.New("one of existing_attribute or new_attribute must be configured")
    }
    if existingAttributeOk {
        // add existingAttribute to provider create API call
    } else {
        // add newAttribute to provider create API call
    }

    // ... other logic ...
    return resourceExampleWidgetRead(d, meta)
}

func resourceExampleWidgetRead(d *schema.ResourceData, meta interface{}) error {
    // ... other logic ...

    if _, ok := d.GetOk("existing_attribute"); ok {
        d.Set("existing_attribute", /* ... */)
    } else {
        d.Set("new_attribute", /* ... */)
    }

    // ... other logic ...
    return nil
}

func resourceExampleWidgetUpdate(d *schema.ResourceData, meta interface{}) error {
    // ... other logic ...

    existingAttribute, existingAttributeOk := d.GetOk("existing_attribute")
    newAttribute, newAttributeOk := d.GetOk("new_attribute")
    if !existingAttributeOk &amp;&amp; !newAttributeOk {
        return errors.New("one of existing_attribute or new_attribute must be configured")
    }
    if existingAttributeOk {
        // add existingAttribute to provider update API call
    } else {
        // add newAttribute to provider update API call
    }

    // ... other logic ...
    return resourceExampleWidgetRead(d, meta)
}
</pre>
<p>When the <code>existing_attribute</code> is ready for removal, then this can be written as:</p> <pre>func resourceExampleWidget() *schema.Resource {
    return &amp;schema.Resource{
        // ... other configuration ...

        Create: resourceExampleWidgetCreate,
        Read:   resourceExampleWidgetRead,
        Update: resourceExampleWidgetUpdate,

        Schema: map[string]*schema.Schema{
            // ... other attributes ...

            "new_attribute": {
                Type:     schema.TypeString,
                Required: true,
            },
        },
    }
}

func resourceExampleWidgetCreate(d *schema.ResourceData, meta interface{}) error {
    // ... other logic ...

    newAttribute := d.Get("new_attribute").(string)
    // add attribute to provider create API call

    // ... other logic ...
    return resourceExampleWidgetRead(d, meta)
}

func resourceExampleWidgetRead(d *schema.ResourceData, meta interface{}) error {
    // ... other logic ...

    d.Set("new_attribute", /* ... */)

    // ... other logic ...
    return nil
}

func resourceExampleWidgetUpdate(d *schema.ResourceData, meta interface{}) error {
    // ... other logic ...

    newAttribute := d.Get("new_attribute").(string)
    // add attribute to provider update API call

    // ... other logic ...
    return resourceExampleWidgetRead(d, meta)
}
</pre>
<h3 id="renaming-an-optional-attribute">  Renaming an Optional Attribute </h3> <blockquote class="alert alert-warning" role="alert"> <p><strong>NOTE:</strong> If the schema definition does not contain <code>Optional</code> or <code>Required</code>, see the <a href="#renaming-a-computed-attribute">Renaming a Computed Attribute section</a> instead. If the schema definition contains <code>Required</code> instead of <code>Optional</code>, see the <a href="#renaming-a-required-attribute">Renaming a Required Attribute section</a>.</p> </blockquote> <blockquote class="alert alert-info" role="alert"> <p><a href="../schemas/schema-behaviors#optional">Optional attributes</a> are also referred to as optional "arguments" throughout the Terraform documentation.</p> </blockquote> <p>In general, the procedure here allows the operator to migrate the configuration to the new attribute at the same time requiring that any other references only work with the new attribute. This is to prevent a situation with Terraform showing a difference when the existing attribute is configured, but the new attribute is saved into the Terraform state. For example, in <code>terraform plan</code> output format:</p> <pre>existing_attribute: "" =&gt; "value"
new_attribute:      "value" =&gt; ""
</pre>
<p>The recommended process is as follows:</p> <ol> <li>Duplicate the schema definition of the existing attribute, renaming one of them with the new attribute name. </li> <li>Duplicate the documentation of the existing attribute, renaming one of them with the new attribute name. </li> <li>Add <code>Deprecated</code> to the schema definition of the existing (now the "old") attribute, noting to use the new attribute in the message. </li> <li>Add <code>**Deprecated**</code> to the documentation of the existing (now the "old") attribute, noting to use the new attribute. </li> <li>Add <code>ConflictsWith</code> to the schema definitions of both the old and new attributes so they will present an error to the operator if both are configured at the same time. </li> <li>Add conditional logic in the <code>Create</code>, <code>Read</code>, and <code>Update</code> functions of the data source or resource to handle both attributes. Generally, this involves using <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-sdk/helper/schema#ResourceData.GetOk"><code>ResourceData.GetOk()</code></a> (commonly <code>d.GetOk()</code> in HashiCorp maintained providers). </li> <li>Follow the rest of the procedures in the <a href="#provider-attribute-removal">Provider Attribute Removal section</a>. </li> </ol> <h4 id="example-renaming-of-an-optional-attribute">  Example Renaming of an Optional Attribute </h4> <p>Given this sample resource:</p> <pre>func resourceExampleWidget() *schema.Resource {
    return &amp;schema.Resource{
        // ... other configuration ...

        Create: resourceExampleWidgetCreate,
        Read:   resourceExampleWidgetRead,
        Update: resourceExampleWidgetUpdate,

        Schema: map[string]*schema.Schema{
            // ... other attributes ...

            "existing_attribute": {
                Type:     schema.TypeString,
                Optional: true,
            },
        },
    }
}

func resourceExampleWidgetCreate(d *schema.ResourceData, meta interface{}) error {
    // ... other logic ...

    if v, ok := d.GetOk("existing_attribute"); ok {
        // add attribute to provider create API call
    }

    // ... other logic ...
    return resourceExampleWidgetRead(d, meta)
}

func resourceExampleWidgetRead(d *schema.ResourceData, meta interface{}) error {
    // ... other logic ...

    d.Set("existing_attribute", /* ... */)

    // ... other logic ...
    return nil
}

func resourceExampleWidgetUpdate(d *schema.ResourceData, meta interface{}) error {
    // ... other logic ...

    if v, ok := d.GetOk("existing_attribute"); ok {
        // add attribute to provider update API call
    }

    // ... other logic ...
    return resourceExampleWidgetRead(d, meta)
}
</pre>
<p>In order to support renaming <code>existing_attribute</code> to <code>new_attribute</code>, this sample can be written as the following to support both attributes simultaneously until the <code>existing_attribute</code> is removed:</p> <pre>func resourceExampleWidget() *schema.Resource {
    return &amp;schema.Resource{
        // ... other configuration ...

        Create: resourceExampleWidgetCreate,
        Read:   resourceExampleWidgetRead,
        Update: resourceExampleWidgetUpdate,

        Schema: map[string]*schema.Schema{
            // ... other attributes ...

            "existing_attribute": {
                Type:          schema.TypeString,
                Optional:      true,
                ConflictsWith: []string{"new_attribute"},
                Deprecated:    "use new_attribute instead",
            },
            "new_attribute": {
                Type:          schema.TypeString,
                Optional:      true,
                ConflictsWith: []string{"existing_attribute"},
            },
        },
    }
}

func resourceExampleWidgetCreate(d *schema.ResourceData, meta interface{}) error {
    // ... other logic ...

    if v, ok := d.GetOk("existing_attribute"); ok {
        // add attribute to provider create API call
    } else if v, ok := d.GetOk("new_attribute"); ok {
        // add attribute to provider create API call
    }

    // ... other logic ...
    return resourceExampleWidgetRead(d, meta)
}

func resourceExampleWidgetRead(d *schema.ResourceData, meta interface{}) error {
    // ... other logic ...

    if v, ok := d.GetOk("existing_attribute"); ok {
        d.Set("existing_attribute", /* ... */)
    } else {
        d.Set("new_attribute", /* ... */)
    }

    // ... other logic ...
    return nil
}

func resourceExampleWidgetUpdate(d *schema.ResourceData, meta interface{}) error {
    // ... other logic ...

    if v, ok := d.GetOk("existing_attribute"); ok {
        // add attribute to provider update API call
    } else if v, ok := d.GetOk("new_attribute"); ok {
        // add attribute to provider update API call
    }

    // ... other logic ...
    return resourceExampleWidgetRead(d, meta)
}
</pre>
<p>When the <code>existing_attribute</code> is ready for removal, then this can be written as:</p> <pre>func resourceExampleWidget() *schema.Resource {
    return &amp;schema.Resource{
        // ... other configuration ...

        Create: resourceExampleWidgetCreate,
        Read:   resourceExampleWidgetRead,
        Update: resourceExampleWidgetUpdate,

        Schema: map[string]*schema.Schema{
            // ... other attributes ...

            "new_attribute": {
                Type:     schema.TypeString,
                Optional: true,
            },
        },
    }
}

func resourceExampleWidgetCreate(d *schema.ResourceData, meta interface{}) error {
    // ... other logic ...

    if v, ok := d.GetOk("new_attribute"); ok {
        // add attribute to provider create API call
    }

    // ... other logic ...
    return resourceExampleWidgetRead(d, meta)
}

func resourceExampleWidgetRead(d *schema.ResourceData, meta interface{}) error {
    // ... other logic ...

    d.Set("new_attribute", /* ... */)

    // ... other logic ...
    return nil
}

func resourceExampleWidgetUpdate(d *schema.ResourceData, meta interface{}) error {
    // ... other logic ...

    if v, ok := d.GetOk("new_attribute"); ok {
        // add attribute to provider update API call
    }

    // ... other logic ...
    return resourceExampleWidgetRead(d, meta)
}
</pre>
<h3 id="renaming-a-computed-attribute">  Renaming a Computed Attribute </h3> <blockquote class="alert alert-warning" role="alert"> <p><strong>NOTE:</strong> If the schema definition contains <code>Optional</code> see the <a href="#renaming-an-optional-attribute">Renaming an Optional Attribute section</a> instead. If the schema definition contains <code>Required</code> see the <a href="#renaming-a-required-attribute">Renaming a Required Attribute section</a> instead.</p> </blockquote> <p>The recommended process is as follows:</p> <ol> <li>Duplicate the schema definition of the existing attribute, renaming one of them with the new attribute name. </li> <li>Duplicate the documentation of the existing attribute, renaming one of them with the new attribute name. </li> <li>Add <code>Deprecated</code> to the schema definition of the existing (now the "old") attribute, noting to use the new attribute in the message. </li> <li>Add <code>**Deprecated**</code> to the documentation of the existing (now the "old") attribute, noting to use the new attribute. </li> <li>Set both attributes in the Terraform state in the <code>Read</code> functions of the data source or resource. </li> <li>Follow the rest of the procedures in the <a href="#provider-attribute-removal">Provider Attribute Removal section</a>. </li> </ol> <h4 id="example-renaming-of-a-computed-attribute">  Example Renaming of a Computed Attribute </h4> <p>Given this sample resource:</p> <pre>func resourceExampleWidget() *schema.Resource {
    return &amp;schema.Resource{
        // ... other configuration ...

        Read: resourceExampleWidgetRead,

        Schema: map[string]*schema.Schema{
            // ... other attributes ...

            "existing_attribute": {
                Type:     schema.TypeString,
                Computed: true,
            },
        },
    }
}

func resourceExampleWidgetRead(d *schema.ResourceData, meta interface{}) error {
    // ... other logic ...

    d.Set("existing_attribute", /* ... */)

    // ... other logic ...
    return nil
}
</pre>
<p>In order to support renaming <code>existing_attribute</code> to <code>new_attribute</code>, this sample can be written as the following to support both attributes simultaneously until the <code>existing_attribute</code> is removed:</p> <pre>func resourceExampleWidget() *schema.Resource {
    return &amp;schema.Resource{
        // ... other configuration ...

        Read: resourceExampleWidgetRead,

        Schema: map[string]*schema.Schema{
            // ... other attributes ...

            "existing_attribute": {
                Type:       schema.TypeString,
                Computed:   true,
                Deprecated: "use new_attribute instead",
            },
            "new_attribute": {
                Type:     schema.TypeString,
                Computed: true,
            },
        },
    }
}

func resourceExampleWidgetRead(d *schema.ResourceData, meta interface{}) error {
    // ... other logic ...

    d.Set("existing_attribute", /* ... */)
    d.Set("new_attribute", /* ... */)

    // ... other logic ...
    return nil
}
</pre>
<p>When the <code>existing_attribute</code> is ready for removal, then this can be written as:</p> <pre>func resourceExampleWidget() *schema.Resource {
    return &amp;schema.Resource{
        // ... other configuration ...

        Read: resourceExampleWidgetRead,

        Schema: map[string]*schema.Schema{
            // ... other attributes ...

            "new_attribute": {
                Type:     schema.TypeString,
                Computed: true,
            },
        },
    }
}

func resourceExampleWidgetRead(d *schema.ResourceData, meta interface{}) error {
    // ... other logic ...

    d.Set("new_attribute", /* ... */)

    // ... other logic ...
    return nil
}
</pre>
<h2 id="provider-data-source-or-resource-removal">  Provider Data Source or Resource Removal </h2> <p>The recommended process for removing a data source or resource from a provider is as follows:</p> <ol> <li>Add <code>DeprecationMessage</code> in the data source or resource schema definition. After an operator upgrades to this version, they will be shown a warning with the message provided when using the deprecated data source or resource, but the Terraform run will still complete. </li> <li>Ensure the changelog has an entry noting the deprecation. </li> <li>Release a <code>MINOR</code> version with the deprecation. </li> <li>In the next <code>MAJOR</code> version, remove all code associated with the deprecated data source or resource except for the schema and replace the <code>Create</code> and <code>Read</code> functions to always return an error. Remove the documentation sidebar link and update the resource or data source documentation page to include information about the removal and any potential migration infromation. After an operator upgrades to this version, they will be shown an error about the missing data source or resource. </li> <li>Ensure the changelog has an entry noting the removal. </li> <li>Release the <code>MAJOR</code> version. </li> <li>In the next <code>MAJOR</code> version, remove all code associated with the removed data source or resource. Remove the resource or data source documentation page. </li> <li>Release the <code>MAJOR</code> version. </li> </ol> <h3 id="example-resource-removal">  Example Resource Removal </h3> <p>Given this sample provider and resource:</p> <pre>func Provider() terraform.ResourceProvider {
    return &amp;schema.Provider{
        // ... other configuration ...

        ResourcesMap: map[string]*schema.Resource{
            // ... other resources ...
            "example_widget": resourceExampleWidget(),
        },
    }
}

func resourceExampleWidget() *schema.Resource {
    return &amp;schema.Resource{
        // ... other configuration ...
    }
}
</pre>
<p>In order to deprecate <code>example_widget</code>, this sample can be written as:</p> <pre>func Provider() terraform.ResourceProvider {
    return &amp;schema.Provider{
        // ... other configuration ...

        ResourcesMap: map[string]*schema.Resource{
            // ... other resources ...
            "example_widget": resourceExampleWidget(),
        },
    }
}

func resourceExampleWidget() *schema.Resource {
    return &amp;schema.Resource{
        // ... other configuration ...

        DeprecationMessage: "use example_thing resource instead"
    }
}
</pre>
<p>To soft remove <code>example_widget</code> with a friendly error message, this sample can be written as:</p> <pre>func Provider() terraform.ResourceProvider {
    return &amp;schema.Provider{
        // ... other configuration ...

        ResourcesMap: map[string]*schema.Resource{
            // ... other resources ...
            "example_widget": resourceExampleWidget(),
        },
    }
}

func resourceExampleWidget() *schema.Resource {
    return &amp;schema.Resource{
        // ... other configuration ...

        Create: func(d *schema.ResourceData, meta interface{}) error {
            return errors.New("use example_thing resource instead")
        },
        Read: func(d *schema.ResourceData, meta interface{}) error {
            return errors.New("use example_thing resource instead")
        },
    }
}
</pre>
<p>To remove <code>example_widget</code>:</p> <pre>func Provider() terraform.ResourceProvider {
    return &amp;schema.Provider{
        // ... other configuration ...

        ResourcesMap: map[string]*schema.Resource{
            // ... other resources ...
        },
    }
}
</pre>
<h2 id="provider-data-source-or-resource-rename">  Provider Data Source or Resource Rename </h2> <p>When renaming a resource from one name to another, it is important to keep backwards compatibility with both existing Terraform configurations and the Terraform state while operators migrate. To accomplish this, there will be some duplicated logic to support both resources until the next <code>MAJOR</code> release. Once both resources are appropriately handled, the process for deprecating and removing the old resource is the same as noted in the <a href="#provider-data-source-or-resource-removal">Provider Data Source or Resource Removal section</a>.</p> <p>The recommended process is as follows:</p> <ol> <li>Duplicate the code of the existing resource, renaming (and potentially modifying) functions as necessary. </li> <li>Duplicate the documentation of the existing resource, renaming (and potentially modifying) as necessary. </li> <li>Add <code>DeprecatedMessage</code> to the schema definition of the existing (now the "old") resource, noting to use the new resource in the message. </li> <li>Add <code>!&gt; **WARNING:** This resource is deprecated and will be removed in the next major version</code> to the documentation of the existing (now the "old") resource, noting to use the new resource. </li> <li>Add the new resource to the provider <code>ResourcesMap</code> </li> <li>Follow the rest of the procedures in the <a href="#provider-attribute-removal">Provider Attribute Removal section</a>. </li> </ol> <h3 id="example-resource-renaming">  Example Resource Renaming </h3> <p>Given this sample provider and resource:</p> <pre>func Provider() terraform.ResourceProvider {
    return &amp;schema.Provider{
        // ... other configuration ...

        ResourcesMap: map[string]*schema.Resource{
            // ... other resources ...

            "example_existing_widget": resourceExampleExistingWidget(),
        },
    }
}

func resourceExampleExistingWidget() *schema.Resource {
    return &amp;schema.Resource{
        // ... other configuration ...
    }
}
</pre>
<p>In order to support renaming <code>example_existing_widget</code> to <code>example_new_widget</code>, this sample can be written as the following to support both attributes simultaneously until the <code>existing_attribute</code> is removed:</p> <pre>func Provider() terraform.ResourceProvider {
    return &amp;schema.Provider{
        // ... other configuration ...

        ResourcesMap: map[string]*schema.Resource{
            // ... other resources ...

            "example_existing_widget": resourceExampleExistingWidget(),
            "example_new_widget":      resourceExampleNewWidget(),
        },
    }
}

func resourceExampleExistingWidget() *schema.Resource {
    return &amp;schema.Resource{
        // ... other configuration ...

        DeprecationMessage: "use example_new_widget resource instead"
    }
}

func resourceExampleNewWidget() *schema.Resource {
    return &amp;schema.Resource{
        // ... other configuration ...
    }
}
</pre>
<p>To soft remove <code>example_existing_widget</code> with a friendly error message:</p> <pre>func Provider() terraform.ResourceProvider {
    return &amp;schema.Provider{
        // ... other configuration ...

        ResourcesMap: map[string]*schema.Resource{
            // ... other resources ...

            "example_existing_widget": resourceExampleExistingWidget(),
            "example_new_widget":      resourceExampleNewWidget(),
        },
    }
}

func resourceExampleExistingWidget() *schema.Resource {
    return &amp;schema.Resource{
        // ... other configuration ...

        Create: func(d *schema.ResourceData, meta interface{}) error {
            return errors.New("use example_new_widget resource instead")
        },
        Read: func(d *schema.ResourceData, meta interface{}) error {
            return errors.New("use example_new_widget resource instead")
        },
    }
}

func resourceExampleNewWidget() *schema.Resource {
    return &amp;schema.Resource{
        // ... other configuration ...
    }
}
</pre>
<p>To remove <code>example_existing_widget</code>:</p> <pre>func Provider() terraform.ResourceProvider {
    return &amp;schema.Provider{
        // ... other configuration ...

        ResourcesMap: map[string]*schema.Resource{
            // ... other resources ...

            "example_new_widget": resourceExampleNewWidget(),
        },
    }
}

func resourceExampleNewWidget() *schema.Resource {
    return &amp;schema.Resource{
        // ... other configuration ...
    }
}
</pre><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.terraform.io/docs/extend/best-practices/deprecations.html" class="_attribution-link" target="_blank">https://www.terraform.io/docs/extend/best-practices/deprecations.html</a>
  </p>
</div>
