 <h1 id="debugging-providers">  Debugging Providers </h1> <p>This guide documents a few different ways to access more information about the runtime operations of Terraform providers. It is intended for Terraform provider developers, though sufficiently advanced users may also be able to use it.</p> <p>There are two available approaches to debugging Terraform providers. We'll talk about each of them separately and in turn.</p> <h2 id="log-based-debugging">  Log-Based Debugging </h2> <p>Log-based debugging is a method of using logging calls to record what is happening in a provider as it happens, and then examining that record to piece together what happened after the fact. Usefully, end users can capture logs and share them with developers, allowing developers to sometimes debug providers without needing access to the environment or configuration. Unfortunately, developers need to think ahead about what information they'll need when debugging, because the log lines need to be injected into the provider when it's built and cannot be inserted into the binary after it has been built. This makes it harder to ask new questions when doing log-based debugging, as the log line needs to be added and the provider needs to be recompiled before new information can be surfaced.</p> <h3 id="inserting-log-lines-into-a-provider">  Inserting Log Lines Into A Provider </h3> <p>Terraform providers all log to <code>stderr</code>. Any output to <code>stderr</code> will be passed over the gRPC protocol to Terraform, which will then write it to its destination.</p> <blockquote class="alert alert-warning" role="alert"> <p><strong>Important:</strong> Don't write to <code>stdout</code> on any Terraform providers! It can cause problems with our plugin system, which uses <code>stdout</code> as a communication channel.</p> </blockquote> <p>We recommend using the standard library <code>log</code> package to achieve this, via <code>log.Println</code> or <code>log.Printf</code> or similar functions.</p> <p>Log lines must be prefixed with the level of the log in square brackets. Valid levels, in decreasing order of severity, are:</p> <ul> <li>ERROR </li> <li>WARN </li> <li>INFO </li> <li>DEBUG </li> <li>TRACE </li> </ul> <p>A full log line, then, may look like this:</p> <pre>log.Println("[DEBUG] Something happened!")
</pre>
<h3 id="turning-on-logging">  Turning On Logging </h3> <p>Terraform controls which log levels are recorded for all providers and Terraform itself using the <code>TF_LOG</code> environment variable. Set it to <code>TRACE</code> to output all log lines, <code>DEBUG</code> to output all log lines except <code>TRACE</code> lines, etc.</p> <blockquote class="alert alert-warning" role="alert"> <p><strong>NOTE:</strong> prior to v0.15.0 of Terraform, levels besides <code>TRACE</code> may not be entirely reliable. See <a href="https://github.com/hashicorp/terraform/pull/26632">this PR</a> for more details.</p> </blockquote> <p>By default, log output will be recorded to <code>stderr</code> when <code>TF_LOG</code> is set. To write log output to a file instead, set <code>TF_LOG_PATH</code> to a file's path. Log output will be appended there. It's worth noting that this file will not be truncated before log output is written.</p> <h4 id="separating-out-provider-logs">  Separating Out Provider Logs </h4> <p>Terraform can have some verbose logging and it can be difficult to parse log files when both Terraform and providers are writing to the same log file. In Terraform 0.15.0 and later, you can address this by setting the <code>TF_LOG_CORE</code> and <code>TF_LOG_PROVIDER</code> environment variables to different log levels. Set either to <code>off</code> to turn off its logging entirely.</p> <h2 id="debugger-based-debugging">  Debugger-Based Debugging </h2> <p>Debugger-based debugging is a method of using a debugging tool similar to <a href="https://github.com/go-delve/delve">delve</a> to inspect what is happening in a provider as it is happening, often using breakpoints to pause execution of the provider and examine the values of variables. This method of debugging must be done contemporaneously; the developer doing the debugging needs to actively run Terraform using the appropriate configuration and in the appropriate environment to induce the behavior being examined. It is therefore most useful when a bug is reliably reproducible. This level of analysis enables developers to ask arbitrary questions and step through provider executions, allowing them to explore what is happening in the provider during runtime.</p> <blockquote class="alert alert-info" role="alert"> <p><strong>Note</strong>: Debugger-based debugging only works with Terraform versions 0.12.26 and higher.</p> </blockquote> <h3 id="enabling-debugging-in-a-provider">  Enabling Debugging In A Provider </h3> <p>Debugging is available for providers using Terraform Plugin SDK versions 2.0.0 and above. The plugin must also be started in debug mode, called <code>plugin.Debug</code> instead of <code>plugin.Serve</code>. We recommend that you enable this using a flag, as the provider should use <code>plugin.Serve</code> under normal operation, when not being debugged.</p> <pre>func main() {
    var debugMode bool

    flag.BoolVar(&amp;debugMode, "debug", false, "set to true to run the provider with support for debuggers like delve")
    flag.Parse()

    opts := &amp;plugin.ServeOpts{ProviderFunc: provider.New}

    if debugMode {
        // TODO: update this string with the full name of your provider as used in your configs
        err := plugin.Debug(context.Background(), "registry.terraform.io/my-org/my-provider", opts)
        if err != nil {
            log.Fatal(err.Error())
        }
        return
    }

    plugin.Serve(opts)
}
</pre>
<p>It is important to start a provider in debug mode only when you intend to debug it, as its behavior will change in minor ways from normal operation of providers. The main differences are:</p> <ul> <li>Terraform will not start the provider process; it must be run manually. </li> <li>The provider's constraints will no longer be checked as part of <code>terraform
init</code>. </li> <li>The provider will no longer be restarted once per walk of the Terraform graph; instead the same provider process will be reused until the command is completed. </li> </ul> <blockquote class="alert alert-warning" role="alert"> <p><strong>Important:</strong> You may need to disable compiler optimization and <a href="https://en.wikipedia.org/wiki/Inline_expansion">inlining</a> to have the debugger work efficiently with the provider binary. To do so, build the provider binary with the necessary <a href="https://golang.org/cmd/compile/">Go compiler flags (gcflags)</a>: <code>go build -gcflags="all=-N -l"</code></p> </blockquote> <h3 id="starting-a-provider-in-debug-mode">  Starting A Provider In Debug Mode </h3> <p>Once a provider has a debug mode added to its <code>main</code> function, it can be activated. Run your debugger, and pass it the provider binary as the command to run, specifying whatever flags, environment variables, or other input is necessary to start your provider in debug mode:</p> <pre data-language="shell">$ dlv exec --headless ./terraform-provider-my-provider -- --debug
</pre>
<p>Connect your debugger (whether it's your IDE or the debugger client) to the debugger server. Have it continue execution (it pauses the process by default) and it will print output like the following to <code>stdout</code>:</p> <pre>Provider started, to attach Terraform set the TF_REATTACH_PROVIDERS env var:

        TF_REATTACH_PROVIDERS='{"registry.terraform.io/my-org/my-provider":{"Protocol":"grpc","Pid":3382870,"Test":true,"Addr":{"Network":"unix","String":"/tmp/plugin713096927"}}}'
</pre>
<h3 id="running-terraform-with-a-provider-in-debug-mode">  Running Terraform With A Provider In Debug Mode </h3> <p>Copy the line starting with <code>TF_REATTACH_PROVIDERS</code> from your provider's output. Either export it, or prefix every Terraform command with it:</p> <pre data-language="shell">TF_REATTACH_PROVIDERS='{"registry.terraform.io/my-org/my-provider":{"Protocol":"grpc","Pid":3382870,"Test":true,"Addr":{"Network":"unix","String":"/tmp/plugin713096927"}}}' terraform apply
</pre>
<p>Run Terraform as usual. Any breakpoints you have set will halt execution and show you the current variable values.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.terraform.io/docs/extend/debugging.html" class="_attribution-link" target="_blank">https://www.terraform.io/docs/extend/debugging.html</a>
  </p>
</div>
