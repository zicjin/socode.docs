 <h1 id="acceptance-tests">  Acceptance Tests </h1> <p>In order to deliver on our promise to be safe and predictable, we need to be able to easily and routinely verify that Terraform Plugins produce the expected outcome. The most common usage of an acceptance test is in Terraform Providers, where each Resource is tested with configuration files and the resulting infrastructure is verified. Terraform includes a framework for constructing acceptance tests that imitate the execution of one or more steps of applying one or more configuration files, allowing multiple scenarios to be tested.</p> <blockquote class="alert alert-warning" role="alert"> <p><strong>Note</strong>: Apart from the <em>Testing in v1.x of the SDK</em> section below, information in this page covers version 2.x of the Plugin SDK. While the public API is largely unchanged between versions, the internal architecture and implementation of the testing framework is very different.</p> </blockquote> <p>Terraform acceptance tests use real Terraform configurations to exercise the code in real plan, apply, refresh, and destroy life cycles. When run from the root of a Terraform Provider codebase, Terraform’s testing framework compiles the current provider in-memory and executes the provided configuration in developer defined steps, creating infrastructure along the way. At the conclusion of all the steps, Terraform automatically destroys the infrastructure. It’s important to note that during development, it’s possible for Terraform to leave orphaned or “dangling” resources behind, depending on the correctness of the code in development. The testing framework provides means to validate all resources are destroyed, alerting developers if any fail to destroy. It is the developer's responsibility to clean up any dangling resources left over from testing and development.</p> <blockquote class="alert alert-warning" role="alert"> <p><strong>Acceptance tests require <code>terraform</code> version 0.12.26 or above.</strong></p> </blockquote> <h2 id="how-acceptance-tests-work">  How Acceptance Tests Work </h2> <p>Provider acceptance tests run real Terraform commands using a Terraform CLI binary, approximating as closely as possible the experience of using the provider under test with Terraform in production. We refer to this functionality as the "binary test driver".</p> <p>Terraform Core and Terraform Plugins act as gRPC client and server, implemented using HashiCorp's <a href="https://github.com/hashicorp/go-plugin">go-plugin</a> system (see the <a href="https://github.com/hashicorp/terraform/tree/main/docs/plugin-protocol">RPC Plugin Model</a> section of the Terraform Core documentation). When <code>go test</code> is run, the SDK's acceptance test framework starts a plugin server in the same process as the Go test framework. This plugin server runs for the duration of the test case, and each Terraform command (<code>terraform plan</code>, <code>terraform apply</code>, etc) creates a client that reattaches to this server.</p> <p>Real-world Terraform usage requires a config file and Terraform working directory on the local filesystem. The framework uses the <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-sdk/v2/internal/plugintest"><code>internal/plugintest</code> package</a> to manage temporary directories and files during test runs. This library is not intended for use directly by provider developers.</p> <p>While the test framework provides a reasonable simulation of real-world usage, there are some differences, the major one being in the lifecycle of the plugin gRPC server. During normal Terraform operation, the plugin server starts and stops once per graph walk, of which there may be several during one Terraform command. The acceptance test framework, however, maintains one plugin gRPC server for the duration of each test case. In theory, it is possible for providers to carry internal state between operations during tests - but providers would have to go out of their way (and the SDK's public API) to do this.</p> <h2 id="testing-in-v1-x-of-the-sdk">  Testing in v1.x of the SDK </h2> <p>From version 1.0.0 to 1.6.0 of the SDK, the only acceptance test driver available is the legacy test driver, which embeds part of the Terraform Core codebase inside the SDK. This duplicated code cannot be said to represent the production behaviour of any given version of Terraform.</p> <p>In version 1.7.0 of the SDK, an initial version of the binary test driver described above was added to the SDK. The internal architecture of this test driver differs from that in v2.x, but it provides similar functionality, running real Terraform CLI commands during acceptance tests. From version 1.7.0 onwards until the legacy test driver is removed in v2.0.0, provider developers can choose to use the legacy test driver or the binary test driver.</p> <p>In order to use the binary test driver in v1.7.0+, you should add code similar to the following to <code>provider_test.go</code>:</p> <pre>func TestMain(m *testing.M) {
  acctest.UseBinaryDriver("provider_name", Provider)
  resource.TestMain(m)
}
</pre>
<p>For more details, please see the <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-sdk/acctest"><code>github.com/hashicorp/terraform-plugin-sdk/acctest</code> package documentation</a>.</p> <h2 id="test-files">  Test files </h2> <p>Terraform follows many of the Go programming language conventions with regards to testing, with both acceptance tests and unit tests being placed in a file that matches the file under test, with an added <code>_test.go</code> suffix. Here’s an example file structure:</p> <pre>terraform-plugin-example/
├── provider.go
├── provider_test.go
├── example/
│   ├── resource_example_compute.go
│   ├── resource_example_compute_test.go
</pre>
<p>To create an acceptance test in the example <code>resource_example_compute_test.go</code> file, the function name must begin with <code>TestAccXxx</code>, and have the following signature:</p> <pre>func TestAccXxx(*testing.T)
</pre>
<h2 id="running-acceptance-tests">  Running Acceptance Tests </h2> <p>A <code>terraform</code> binary of version 0.12.26 or above must be available on the local system for the acceptance test driver to run, either on the system <code>$PATH</code> or supplied via the <code>TF_ACC_TERRAFORM_PATH</code> environment variable described below. If you are running acceptance tests in a CI environment, we recommend that you download and install Terraform with a prior build step.</p> <p>Terraform requires an environment variable <code>TF_ACC</code> be set in order to run acceptance tests. This is by design, and intended to prevent developers from incurring unintended charges when running tests. The easiest way to run acceptance tests is to use the built in <code>make</code> step <code>testacc</code>, which explicitly sets the <code>TF_ACC=true</code> value for you. Example:</p> <pre>$ make testacc
</pre>
<p><strong>It’s important to reiterate that acceptance tests create actual cloud resources</strong>, possibly incurring expenses which are the responsibility of the user running the tests. Creating real infrastructure in tests verifies the described behavior of Terraform Plugins in real world use cases against the actual APIs, and verifies both local state and remote values match. Acceptance tests require a network connection and often require credentials to access an account for the given API.</p> <blockquote class="alert alert-warning" role="alert"> <p>Note: When developing or testing Terraform plugins, we highly recommend running acceptance tests with an account dedicated to testing. This ensures no infrastructure is created or destroyed in error during development or validation of any Provider Resources in any environment that cannot be completely and safely destroyed.</p> </blockquote> <h2 id="environment-variables">  Environment Variables </h2> <p>A number of environment variables are available to control aspects of acceptance test execution.</p> <ul> <li>
<a href="#tf_acc_terraform_path"><code>TF_ACC_TERRAFORM_PATH</code></a>: Used to specify the path to a Terraform binary on the local filesystem to be used during testing. </li> <li>
<a href="#tf_acc_log_path"><code>TF_ACC_LOG_PATH</code></a>: Used to specify a path for Terraform logs during testing. </li> <li>
<a href="#tf_acc_temp_dir"><code>TF_ACC_TEMP_DIR</code></a>: Used to specify a temporary directory used by the test driver. If this is not set, the default system temporary directory (as identified by <code>os.TempDir()</code>) will be used. </li> <li>
<a href="#tf_acc_provider_namespace"><code>TF_ACC_PROVIDER_NAMESPACE</code></a>: Used to control the namespace of the provider under test; only needed if config specifies a namespace for provider source. </li> <li>
<a href="#tf_acc_provider_host"><code>TF_ACC_PROVIDER_HOST</code></a>: Used to control the host of the provider under test; only needed if config specifies a host for provider source. </li> <li>
<a href="#tf_acc_state_lineage"><code>TF_ACC_STATE_LINEAGE</code></a>: Set to "1" to enable state lineage debug logs, which are normally suppressed during acceptance testing. </li> </ul> <h2 id="troubleshooting">  Troubleshooting </h2> <p>This section lists common errors encountered during testing.</p> <h3 id="unrecognized-remote-plugin-message">  Unrecognized remote plugin message </h3> <pre>terraform failed: exit status 1

        stderr:

        Error: Failed to instantiate provider "random" to obtain schema: Unrecognized remote plugin message: --- FAIL: TestAccResourceID (4.28s)

        This usually means that the plugin is either invalid or simply
        needs to be recompiled to support the latest protocol.
</pre>
<p>This error indicates that the provider server could not connect to Terraform Core. Verify that the output of <code>terraform version</code> is v0.12.26 or above.</p> <h2 id="next-steps">  Next Steps </h2> <p>Terraform relies heavily on acceptance tests to ensure we keep our promise of helping users safely and predictably create, change, and improve infrastructure. In our next section we detail how to create “Test Cases”, individual acceptance tests using Terraform’s testing framework, in order to build and verify real infrastructure. <a href="testcase">Proceed to Test Cases</a></p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.terraform.io/docs/extend/testing/acceptance-tests/index.html" class="_attribution-link" target="_blank">https://www.terraform.io/docs/extend/testing/acceptance-tests/index.html</a>
  </p>
</div>
