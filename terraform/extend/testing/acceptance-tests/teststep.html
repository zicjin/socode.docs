 <h1 id="acceptance-tests-teststeps">  Acceptance Tests: TestSteps </h1> <p><code>TestStep</code>s represent the application of an actual Terraform configuration file to a given state. Each step requires a configuration as input and provides developers several means of validating the behavior of the specific resource under test.</p> <h2 id="test-modes">  Test Modes </h2> <p>Terraform’s test framework facilitates two distinct modes of acceptance tests, <em>Lifecycle</em> and <em>Import</em>.</p> <p><em>Lifecycle</em> mode is the most common mode, and is used for testing plugins by providing one or more configuration files with the same logic as would be used when running <code>terraform apply</code>.</p> <p><em>Import</em> mode is used for testing resource functionality to import existing infrastructure into a Terraform statefile, using the same logic as would be used when running <code>terraform import</code>.</p> <p>An acceptance test’s mode is implicitly determined by the fields provided in the <code>TestStep</code> definition. The applicable fields are defined in the <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-sdk/helper/resource#TestStep">TestStep Reference API</a>.</p> <h2 id="steps">  Steps </h2> <p><code>Steps</code> is slice property of <a href="testcase">TestCase</a>, the object used to construct acceptance tests. Each step represents a full <code>terraform apply</code> of a given configuration language, followed by zero or more checks (defined later) to verify the application. Each <code>Step</code> is applied in order, and require its own configuration and optional check functions.</p> <p>Below is a code example of a lifecycle test that provides two <code>TestStep</code> objects:</p> <pre>package example

// example.Widget represents a concrete Go type that represents an API resource
func TestAccExampleWidget_basic(t *testing.T) {
    var widgetBefore, widgetAfter example.Widget
    rName := acctest.RandStringFromCharSet(10, acctest.CharSetAlphaNum)

    resource.Test(t, resource.TestCase{
        PreCheck:     func() { testAccPreCheck(t) },
        Providers:    testAccProviders,
        CheckDestroy: testAccCheckExampleResourceDestroy,
        Steps: []resource.TestStep{
            {
                Config: testAccExampleResource(rName),
                Check: resource.ComposeTestCheckFunc(
                    testAccCheckExampleResourceExists("example_widget.foo", &amp;widgetBefore),
                ),
            },
            {
                Config: testAccExampleResource_removedPolicy(rName),
                Check: resource.ComposeTestCheckFunc(
                    testAccCheckExampleResourceExists("example_widget.foo", &amp;widgetAfter),
                ),
            },
        },
    })
}
</pre>
<p>In the above example each <code>TestCase</code> invokes a function to retrieve it’s desired configuration, based on a randomized name provided, however an in-line string or constant string would work as well, so long as they contain valid Terraform configuration for the plugin or resource under test. This pattern of first applying and checking a basic configuration, followed by applying a modified configuration with updated or additional checks is a common pattern used to test update functionality.</p> <h2 id="check-functions">  Check Functions </h2> <p>After the configuration for a <code>TestStep</code> is applied, Terraform’s testing framework provides developers an opportunity to check the results by providing a “Check” function. While possible to only supply a single function, it is recommended you use multiple functions to validate specific information about the results of the <code>terraform apply</code> ran in each <code>TestStep</code>. The <code>Check</code> attribute of <code>TestStep</code> is singular, so in order to include multiple checks developers should use either <code>ComposeTestCheckFunc</code> or <code>ComposeAggregateTestCheckFunc</code> (defined below) to group multiple check functions, defined below:</p> <h3 id="composetestcheckfunc">  ComposeTestCheckFunc </h3> <p>ComposeTestCheckFunc lets you compose multiple TestCheckFunc functions into a single check. As a user testing their provider, this lets you decompose your checks into smaller pieces more easily, with individual methods for checking specific attributes. Each check is ran in the order provided, and on failure the entire <code>TestCase</code> is stopped, and Terraform attempts to destroy any resources created.</p> <p>Example:</p> <pre>Steps: []resource.TestStep{
  {
    Config: testAccExampleResource(rName),
    Check: resource.ComposeTestCheckFunc(
        // if testAccCheckExampleResourceExists fails to find the resource, 
        // the parent TestStep and TestCase fail
      testAccCheckExampleResourceExists("example_widget.foo", &amp;widgetBefore), 
      resource.TestCheckResourceAttr("example_widget.foo", "size", "expected size"),
    ),
  },
},
</pre>
<h3 id="composeaggregatetestcheckfunc">  ComposeAggregateTestCheckFunc </h3> <p>ComposeAggregateTestCheckFunc lets you compose multiple TestCheckFunc functions into a single check. It’s purpose and usage is identical to ComposeTestCheckFunc, however each check is ran in order even if a previous check failed, collecting the errors returned from any checks and returning a single aggregate error. The entire <code>TestCase</code> is still stopped, and Terraform attempts to destroy any resources created.</p> <p>Example:</p> <pre>Steps: []resource.TestStep{
  {
    Config: testAccExampleResource(rName),
    Check: resource.ComposeAggregateTestCheckFunc(
      testAccCheckExampleResourceExists("example_widget.foo", &amp;widgetBefore), // if testAccCheckExampleResourceExists fails to find the resource, the following TestCheckResourceAttr is still ran, with any errors aggregated
      resource.TestCheckResourceAttr("example_widget.foo", "active", "true"),
    ),
  },
},
</pre>
<h2 id="builtin-check-functions">  Builtin check functions </h2> <p>Terraform has several TestCheckFunc functions built in for developers to use for common checks, such as verifying the status and value of a specific attribute in the resulting state. Developers are encouraged to use as many as reasonable to verify the behavior of the plugin/resource, and should combine them with the above mentioned <code>ComposeTestCheckFunc</code> or <code>ComposeAggregateTestCheckFunc</code> functions.</p> <p>Most builtin functions accept <code>name</code>, <code>key</code>, and/or <code>value</code> fields, derived from the typical Terraform configuration stanzas:</p> <pre data-language="ruby">resource "example_widget" "foo" {
  active = true
}
</pre>
<p>Here the <code>name</code> represents the resource name in state (<code>example_widget.foo</code>), the <code>key</code> represents the attribute to check (<code>active</code>), and <code>value</code> represents the desired value to check against (<code>true</code>). In this case, an equality check would be:</p> <pre>resource.TestCheckResourceAttr("example_widget.foo", "active", "true"),
</pre>
<p>The full list of functions can be seen in the <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"><code>helper/resource</code> package</a>. Names for these begin with <code>TestCheck...</code> and <code>TestMatch...</code>. The most common checks for non-<code>TypeSet</code> attributes are below.</p> <table>
<thead> <tr> <th>Function</th> <th>Purpose</th> </tr> </thead>
<tbody> <tr> <td><a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-sdk/helper/resource#TestCheckResourceAttr"><code>TestCheckResourceAttr(name string, key string, value string)</code></a></td> <td>Value equality checks</td> </tr> <tr> <td><a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-sdk/helper/resource#TestMatchResourceAttr"><code>TestMatchResourceAttr(name string, key string, regex *regexp.Regexp)</code></a></td> <td></td> </tr> <tr> <td>Value regular expression checks</td> <td></td> </tr> <tr> <td><a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-sdk/helper/resource#TestCheckResourceAttrPair"><code>TestCheckResourceAttrPair(nameFirst string, keyFirst string, nameSecond string, keySecond string)</code></a></td> <td>Value equality across two attributes (usually in different resources)</td> </tr> <tr> <td><a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-sdk/helper/resource#TestCheckResourceAttrSet"><code>TestCheckResourceAttrSet(name string, key string)</code></a></td> <td>Passes if any value was set</td> </tr> <tr> <td><a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-sdk/helper/resource#TestCheckNoResourceAttr"><code>TestCheckNoResourceAttr(name string, key string)</code></a></td> <td>Passes if no value was set</td> </tr> </tbody>
</table> <p>For <code>TypeSet</code> attributes, there are some additional functions that accept a <code>*</code> placeholder in attribute keys for indexing into the set.</p> <table>
<thead> <tr> <th>Function</th> <th>Purpose</th> </tr> </thead>
<tbody> <tr> <td><a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource#TestCheckTypeSetElemAttr"><code>TestCheckTypeSetElemAttr(name string, key string, value string)</code></a></td> <td>Value is contained in set</td> </tr> <tr> <td><a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource#TestCheckTypeSetElemAttrPair"><code>TestCheckTypeSetElemAttrPair(nameFirst string, keyFirst string, nameSecond string, keySecond string)</code></a></td> <td>Value is contained in set from another attribute (usually in different resources)</td> </tr> <tr> <td><a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource#TestCheckTypeSetElemNestedAttrs"><code>TestCheckTypeSetElemNestedAttrs(name string, key string, values map[string]string)</code></a></td> <td>Map of values is contained in set (usually checking multiple attributes of a block)</td> </tr> </tbody>
</table> <p>All of these functions also accept the below syntax in attribute keys to enable additional behaviors.</p> <table>
<thead> <tr> <th>Syntax</th> <th>Purpose</th> <th>Example</th> </tr> </thead>
<tbody> <tr> <td><code>.{NUMBER}</code></td> <td>List index</td> <td><code>TestCheckResourceAttr("example_widget.foo", "some_block.0", "first value")</code></td> </tr> <tr> <td><code>.{KEY}</code></td> <td>Map key</td> <td><code>TestCheckResourceAttr("example_widget.foo", "some_map.some_key", "map value")</code></td> </tr> <tr> <td><code>.#</code></td> <td>Number of elements in list or set</td> <td><code>TestCheckResourceAttr("example_widget.foo", "some_list.#", "2")</code></td> </tr> <tr> <td><code>.%</code></td> <td>Number of keys in map</td> <td><code>TestCheckResourceAttr("example_widget.foo", "some_map.%", "2")</code></td> </tr> </tbody>
</table> <h2 id="custom-check-functions">  Custom check functions </h2> <p>The <code>Check</code> field of <code>TestStep</code> accepts any function of type <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-sdk/helper/resource#TestCheckFunc">TestCheckFunc</a>. Developers are free to write their own <code>check</code> functions to create customized validation functions for their plugin. Any function that matches the <code>TestCheckFunc</code> function signature of <code>func(*terraform.State) error</code> can be used individually, or with other <code>TestCheckFunc</code> functions with one of the above Aggregate functions.</p> <p>It's common to write custom <code>TestCheckFunc</code> functions to validate resources were created correctly by using SDKs directly to verify identity and properties of resources. These functions can retrieve information by SDKs and provide the results to other <code>TestCheckFunc</code> methods. The below example uses <code>ComposeTestCheckFunc</code> to group a set of <code>TestCheckFunc</code> functions together. The first function <code>testAccCheckExampleWidgetExists</code> uses the <code>Example</code> service SDK directly, and queries it for the ID of the widget we have in state. Once found, the result is stored into the <code>widget</code> struct declared at the beginning of the test function. The next check function <code>testAccCheckExampleWidgetAttributes</code> receives the updated <code>widget</code> and checks its attributes. The final check <code>TestCheckResourceAttr</code> verifies that the same value is stored in state.</p> <pre>func TestAccExampleWidget_basic(t *testing.T) {
    var widget example.WidgetDescription

    resource.Test(t, resource.TestCase{
        PreCheck:     func() { testAccPreCheck(t) },
        Providers:    testAccProviders,
        CheckDestroy: testAccCheckExampleWidgetDestroy,
        Steps: []resource.TestStep{
            {
                Config: testAccExampleWidgetConfig,
                Check: resource.ComposeTestCheckFunc(
                    testAccCheckExampleWidgetExists("example_widget.bar", &amp;widget),
                    testAccCheckExampleWidgetAttributes(&amp;widget),
                    resource.TestCheckResourceAttr("example_widget.bar", "active", "true"),
                ),
            },
        },
    })
}

// testAccCheckExampleWidgetAttributes verifies attributes are set correctly by 
// Terraform
func testAccCheckExampleWidgetAttributes(widget *example.WidgetDescription) resource.TestCheckFunc {
    return func(s *terraform.State) error {
        if *widget.active != true {
            return fmt.Errorf("widget is not active")
        }

        return nil
    }
}

// testAccCheckExampleWidgetExists uses the Example SDK directly to retrieve 
// the Widget description, and stores it in the provided 
// *example.WidgetDescription
func testAccCheckExampleWidgetExists(resourceName string, widget *example.WidgetDescription) resource.TestCheckFunc {
    return func(s *terraform.State) error {
        // retrieve the resource by name from state
        rs, ok := s.RootModule().Resources[resourceName]
        if !ok {
            return fmt.Errorf("Not found: %s", resourceName)
        }

        if rs.Primary.ID == "" {
            return fmt.Errorf("Widget ID is not set")
        }

        // retrieve the client from the test provider
        client := testAccProvider.Meta().(*ExampleClient)

        response, err := client.DescribeWidgets(&amp;example.DescribeWidgetsInput{
            WidgetIDs: []string{rs.Primary.ID},
        })

        if err != nil {
            return err
        }

        // we expect only a single widget by this ID. If we find zero, or many, 
        // then we consider this an error
        if len(response.WidgetDescriptions) != 1 ||
            *response.WidgetDescriptions[0].WidgetID != rs.Primary.ID {
            return fmt.Errorf("Widget not found")
        }

        // store the resulting widget in the *example.WidgetDescription pointer
        *widget = *response.WidgetDescriptions[0]
        return nil
    }
}
</pre>
<h2 id="next-steps">  Next Steps </h2> <p>Acceptance Testing is an essential approach to validating the implementation of a Terraform Provider. Using actual APIs to provision resources for testing can leave behind real infrastructure that costs money between tests. The reasons for these leaks can vary, regardless Terraform provides a mechanism known as <a href="sweepers">Sweepers</a> to help keep the testing account clean.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.terraform.io/docs/extend/testing/acceptance-tests/teststep.html" class="_attribution-link" target="_blank">https://www.terraform.io/docs/extend/testing/acceptance-tests/teststep.html</a>
  </p>
</div>
