 <h1 id="cli-configuration-file-terraformrc-or-terraform-rc-">  CLI Configuration File (<code>.terraformrc</code> or <code>terraform.rc</code>) </h1> <p>The CLI configuration file configures per-user settings for CLI behaviors, which apply across all Terraform working directories. This is separate from <a href="../../language/index">your infrastructure configuration</a>.</p> <h2 id="location">  Location </h2> <p>The configuration is placed in a single file whose location depends on the host operating system:</p> <ul> <li>On Windows, the file must be named <code>terraform.rc</code> and placed in the relevant user's <code>%APPDATA%</code> directory. The physical location of this directory depends on your Windows version and system configuration; use <code>$env:APPDATA</code> in PowerShell to find its location on your system. </li> <li>On all other systems, the file must be named <code>.terraformrc</code> (note the leading period) and placed directly in the home directory of the relevant user. </li> </ul> <p>On Windows, beware of Windows Explorer's default behavior of hiding filename extensions. Terraform will not recognize a file named <code>terraform.rc.txt</code> as a CLI configuration file, even though Windows Explorer may <em>display</em> its name as just <code>terraform.rc</code>. Use <code>dir</code> from PowerShell or Command Prompt to confirm the filename.</p> <p>The location of the Terraform CLI configuration file can also be specified using the <code>TF_CLI_CONFIG_FILE</code> <a href="environment-variables">environment variable</a>.</p> <h2 id="configuration-file-syntax">  Configuration File Syntax </h2> <p>The configuration file uses the same <em>HCL</em> syntax as <code>.tf</code> files, but with different attributes and blocks. The following example illustrates the general syntax; see the following section for information on the meaning of each of these settings:</p> <pre data-language="ruby">plugin_cache_dir   = "$HOME/.terraform.d/plugin-cache"
disable_checkpoint = true
</pre>
<h2 id="available-settings">  Available Settings </h2> <p>The following settings can be set in the CLI configuration file:</p> <ul> <li>
<p><a href="#credentials"><code>credentials</code></a> - configures credentials for use with Terraform Cloud or Terraform Enterprise. See <a href="#credentials">Credentials</a> below for more information.</p> </li> <li>
<p><a href="#credentials_helper"><code>credentials_helper</code></a> - configures an external helper program for the storage and retrieval of credentials for Terraform Cloud or Terraform Enterprise. See <a href="#credentials-helpers">Credentials Helpers</a> below for more information.</p> </li> <li>
<p><a href="#disable_checkpoint"><code>disable_checkpoint</code></a> — when set to <code>true</code>, disables <a href="../commands/index#upgrade-and-security-bulletin-checks">upgrade and security bulletin checks</a> that require reaching out to HashiCorp-provided network services.</p> </li> <li>
<p><a href="#disable_checkpoint_signature"><code>disable_checkpoint_signature</code></a> — when set to <code>true</code>, allows the upgrade and security bulletin checks described above but disables the use of an anonymous id used to de-duplicate warning messages.</p> </li> <li>
<p><a href="#plugin_cache_dir"><code>plugin_cache_dir</code></a> — enables <a href="#provider-plugin-cache">plugin caching</a> and specifies, as a string, the location of the plugin cache directory.</p> </li> <li>
<p><a href="#provider_installation"><code>provider_installation</code></a> - customizes the installation methods used by <code>terraform init</code> when installing provider plugins. See <a href="#provider-installation">Provider Installation</a> below for more information.</p> </li> </ul> <h2 id="credentials-1">  Credentials </h2> <p><a href="../../cloud/index">Terraform Cloud</a> provides a number of remote network services for use with Terraform, and <a href="https://www.terraform.io/docs/enterprise/index.html">Terraform Enterprise</a> allows hosting those services inside your own infrastructure. For example, these systems offer both <a href="../../cloud/run/cli">remote operations</a> and a <a href="../../cloud/registry/index">private module registry</a>.</p> <p>When interacting with Terraform-specific network services, Terraform expects to find API tokens in CLI configuration files in <code>credentials</code> blocks:</p> <pre data-language="ruby">credentials "app.terraform.io" {
  token = "xxxxxx.atlasv1.zzzzzzzzzzzzz"
}
</pre>
<p>If you are running the Terraform CLI interactively on a computer with a web browser, you can use <a href="../commands/login">the <code>terraform login</code> command</a> to get credentials and automatically save them in the CLI configuration. If not, you can manually write <code>credentials</code> blocks.</p> <p>You can have multiple <code>credentials</code> blocks if you regularly use services from multiple hosts. Many users will configure only one, for either Terraform Cloud (at <code>app.terraform.io</code>) or for their organization's own Terraform Enterprise host. Each <code>credentials</code> block contains a <code>token</code> argument giving the API token to use for that host.</p> <blockquote class="alert alert-warning" role="alert"> <p><strong>Important:</strong> If you are using Terraform Cloud or Terraform Enterprise, the token provided must be either a <a href="../../cloud/users-teams-organizations/users#api-tokens">user token</a> or a <a href="../../cloud/users-teams-organizations/api-tokens#team-api-tokens">team token</a>; organization tokens cannot be used for command-line Terraform actions.</p> </blockquote> <blockquote class="alert alert-info" role="alert"> <p><strong>Note:</strong> The credentials hostname must match the hostname in your module sources and/or backend configuration. If your Terraform Enterprise instance is available at multiple hostnames, use only one of them consistently. Terraform Cloud responds to API calls at both its current hostname <code>app.terraform.io</code>, and its historical hostname <code>atlas.hashicorp.com</code>.</p> </blockquote> <h3 id="credentials-helpers">  Credentials Helpers </h3> <p>If you would prefer not to store your API tokens directly in the CLI configuration as described in the previous section, you can optionally instruct Terraform to use a different credentials storage mechanism by configuring a special kind of plugin program called a <em>credentials helper</em>.</p> <pre data-language="ruby">credentials_helper "example" {
  args = []
}
</pre>
<p><code>credentials_helper</code> is a configuration block that can appear at most once in the CLI configuration. Its label (<code>"example"</code> above) is the name of the credentials helper to use. The <code>args</code> argument is optional and allows passing additional arguments to the helper program, for example if it needs to be configured with the address of a remote host to access for credentials.</p> <p>A configured credentials helper will be consulted only to retrieve credentials for hosts that are <em>not</em> explicitly configured in a <code>credentials</code> block as described in the previous section. Conversely, this means you can override the credentials returned by the helper for a specific hostname by writing a <code>credentials</code> block alongside the <code>credentials_helper</code> block.</p> <p>Terraform does not include any credentials helpers in the main distribution. To learn how to write and install your own credentials helpers to integrate with existing in-house credentials management systems, see <a href="../../internals/credentials-helpers">the guide to Credentials Helper internals</a>.</p> <h2 id="provider-installation">  Provider Installation </h2> <p>The default way to install provider plugins is from a provider registry. The origin registry for a provider is encoded in the provider's source address, like <code>registry.terraform.io/hashicorp/aws</code>. For convenience in the common case, Terraform allows omitting the hostname portion for providers on <code>registry.terraform.io</code>, so you can write shorter public provider addresses like <code>hashicorp/aws</code>.</p> <p>Downloading a plugin directly from its origin registry is not always appropriate, though. For example, the system where you are running Terraform may not be able to access an origin registry due to firewall restrictions within your organization or your locality.</p> <p>To allow using Terraform providers in these situations, there are some alternative options for making provider plugins available to Terraform which we'll describe in the following sections.</p> <h3 id="explicit-installation-method-configuration">  Explicit Installation Method Configuration </h3> <p>A <code>provider_installation</code> block in the CLI configuration allows overriding Terraform's default installation behaviors, so you can force Terraform to use a local mirror for some or all of the providers you intend to use.</p> <p>The general structure of a <code>provider_installation</code> block is as follows:</p> <pre data-language="ruby">provider_installation {
  filesystem_mirror {
    path    = "/usr/share/terraform/providers"
    include = ["example.com/*/*"]
  }
  direct {
    exclude = ["example.com/*/*"]
  }
}
</pre>
<p>Each of the nested blocks inside the <code>provider_installation</code> block specifies one installation method. Each installation method can take both <code>include</code> and <code>exclude</code> patterns that specify which providers a particular installation method can be used for. In the example above, we specify that any provider whose origin registry is at <code>example.com</code> can be installed only from the filesystem mirror at <code>/usr/share/terraform/providers</code>, while all other providers can be installed only directly from their origin registries.</p> <p>If you set both <code>include</code> and <code>exclude</code> for a particular installation method, the exclusion patterns take priority. For example, including <code>registry.terraform.io/hashicorp/*</code> but also excluding <code>registry.terraform.io/hashicorp/dns</code> will make that installation method apply to everything in the <code>hashicorp</code> namespace with the exception of <code>hashicorp/dns</code>.</p> <p>As with provider source addresses in the main configuration, you can omit the <code>registry.terraform.io/</code> prefix for providers distributed through the public Terraform registry, even when using wildcards. For example, <code>registry.terraform.io/hashicorp/*</code> and <code>hashicorp/*</code> are equivalent. <code>*/*</code> is a shorthand for <code>registry.terraform.io/*/*</code>, not for <code>*/*/*</code>.</p> <p>The following are the two supported installation method types:</p> <ul> <li>
<p><a href="#direct"><code>direct</code></a>: request information about the provider directly from its origin registry and download over the network from the location that registry indicates. This method expects no additional arguments.</p> </li> <li>
<p><a href="#filesystem_mirror"><code>filesystem_mirror</code></a>: consult a directory on the local disk for copies of providers. This method requires the additional argument <code>path</code> to indicate which directory to look in.</p> <p>Terraform expects the given directory to contain a nested directory structure where the path segments together provide metadata about the available providers. The following two directory structures are supported:</p> <ul> <li>Packed layout: <code>HOSTNAME/NAMESPACE/TYPE/terraform-provider-TYPE_VERSION_TARGET.zip</code> is the distribution zip file obtained from the provider's origin registry. </li> <li>Unpacked layout: <code>HOSTNAME/NAMESPACE/TYPE/VERSION/TARGET</code> is a directory containing the result of extracting the provider's distribution zip file. </li> </ul> <p>In both layouts, the <code>VERSION</code> is a string like <code>2.0.0</code> and the <code>TARGET</code> specifies a particular target platform using a format like <code>darwin_amd64</code>, <code>linux_arm</code>, <code>windows_amd64</code>, etc.</p> <p>If you use the unpacked layout, Terraform will attempt to create a symbolic link to the mirror directory when installing the provider, rather than creating a deep copy of the directory. The packed layout prevents this because Terraform must extract the zip file during installation.</p> <p>You can include multiple <code>filesystem_mirror</code> blocks in order to specify several different directories to search.</p> </li> <li>
<p><a href="#network_mirror"><code>network_mirror</code></a>: consult a particular HTTPS server for copies of providers, regardless of which registry host they belong to. This method requires the additional argument <code>url</code> to indicate the mirror base URL, which should use the <code>https:</code> scheme and end with a trailing slash.</p> <p>Terraform expects the given URL to be a base URL for an implementation of <a href="../../internals/provider-network-mirror-protocol">the provider network mirror protocol</a>, which is designed to be relatively easy to implement using typical static website hosting mechanisms.</p> </li> </ul> <blockquote class="alert alert-warning" role="alert"> <p><strong>Warning:</strong> Don't configure <code>network_mirror</code> URLs that you do not trust. Provider mirror servers are subject to TLS certificate checks to verify identity, but a network mirror with a TLS certificate can potentially serve modified copies of upstream providers with malicious content.</p> </blockquote> <p>Terraform will try all of the specified methods whose include and exclude patterns match a given provider, and select the newest version available across all of those methods that matches the version constraint given in each Terraform configuration. If you have a local mirror of a particular provider and intend Terraform to use that local mirror exclusively, you must either remove the <code>direct</code> installation method altogether or use its <code>exclude</code> argument to disable its use for specific providers.</p> <h3 id="implied-local-mirror-directories">  Implied Local Mirror Directories </h3> <p>If your CLI configuration does not include a <code>provider_installation</code> block at all, Terraform produces an <em>implied</em> configuration. The implied configuration includes a selection of <code>filesystem_mirror</code> methods and then the <code>direct</code> method.</p> <p>The set of directories Terraform can select as filesystem mirrors depends on the operating system where you are running Terraform:</p> <ul> <li>
<strong>Windows:</strong> <code>%APPDATA%/terraform.d/plugins</code> and <code>%APPDATA%/HashiCorp/Terraform/plugins</code> </li> <li>
<strong>Mac OS X:</strong> <code>$HOME/.terraform.d/plugins/</code>, <code>~/Library/Application Support/io.terraform/plugins</code>, and <code>/Library/Application Support/io.terraform/plugins</code> </li> <li>
<strong>Linux and other Unix-like systems</strong>:<code>$HOME/.terraform.d/plugins/</code>, and <a href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html">XDG Base Directory</a> data directories as configured, after appending <code>terraform/plugins</code>. Without any XDG environment variables set, Terraform will use <code>~/.local/share/terraform/plugins</code>, <code>/usr/local/share/terraform/plugins</code>, and <code>/usr/share/terraform/plugins</code>. </li> </ul> <p>Terraform will create an implied <code>filesystem_mirror</code> method block for each of the directories indicated above that exists when Terraform starts up. In addition, if a <code>terraform.d/plugins</code> directory exists in the current working directory, it will be added as a filesystem mirror.</p> <p>In addition to the zero or more implied <code>filesystem_mirror</code> blocks, Terraform also creates an implied <code>direct</code> block. Terraform will scan all of the filesystem mirror directories to see which providers are placed there and automatically exclude all of those providers from the implied <code>direct</code> block. (This automatic <code>exclude</code> behavior applies only to <em>implicit</em> <code>direct</code> blocks; if you use explicit <code>provider_installation</code> you will need to write the intended exclusions out yourself.)</p> <h3 id="provider-plugin-cache">  Provider Plugin Cache </h3> <p>By default, <code>terraform init</code> downloads plugins into a subdirectory of the working directory so that each working directory is self-contained. As a consequence, if you have multiple configurations that use the same provider then a separate copy of its plugin will be downloaded for each configuration.</p> <p>Given that provider plugins can be quite large (on the order of hundreds of megabytes), this default behavior can be inconvenient for those with slow or metered Internet connections. Therefore Terraform optionally allows the use of a local directory as a shared plugin cache, which then allows each distinct plugin binary to be downloaded only once.</p> <p>To enable the plugin cache, use the <code>plugin_cache_dir</code> setting in the CLI configuration file. For example:</p> <pre data-language="ruby">plugin_cache_dir = "$HOME/.terraform.d/plugin-cache"
</pre>
<p>This directory must already exist before Terraform will cache plugins; Terraform will not create the directory itself.</p> <p>Please note that on Windows it is necessary to use forward slash separators (<code>/</code>) rather than the conventional backslash (<code>\</code>) since the configuration file parser considers a backslash to begin an escape sequence.</p> <p>Setting this in the configuration file is the recommended approach for a persistent setting. Alternatively, the <code>TF_PLUGIN_CACHE_DIR</code> environment variable can be used to enable caching or to override an existing cache directory within a particular shell session:</p> <pre data-language="shell">export TF_PLUGIN_CACHE_DIR="$HOME/.terraform.d/plugin-cache"
</pre>
<p>When a plugin cache directory is enabled, the <code>terraform init</code> command will still use the configured or implied installation methods to obtain metadata about which plugins are available, but once a suitable version has been selected it will first check to see if the chosen plugin is already available in the cache directory. If so, Terraform will use the previously-downloaded copy.</p> <p>If the selected plugin is not already in the cache, Terraform will download it into the cache first and then copy it from there into the correct location under your current working directory. When possible Terraform will use symbolic links to avoid storing a separate copy of a cached plugin in multiple directories.</p> <p>The plugin cache directory <em>must not</em> also be one of the configured or implied filesystem mirror directories, since the cache management logic conflicts with the filesystem mirror logic when operating on the same directory.</p> <p>Terraform will never itself delete a plugin from the plugin cache once it has been placed there. Over time, as plugins are upgraded, the cache directory may grow to contain several unused versions which you must delete manually.</p> <blockquote class="alert alert-info" role="alert"> <p><strong>Note:</strong> The plugin cache directory is not guaranteed to be concurrency safe. The provider installer's behavior in environments with multiple <code>terraform
init</code> calls is undefined.</p> </blockquote> <h3 id="development-overrides-for-provider-developers">  Development Overrides for Provider Developers </h3> <blockquote class="alert alert-info" role="alert"> <p><strong>Note:</strong> Development overrides work only in Terraform v0.14 and later. Using a <code>dev_overrides</code> block in your CLI configuration will cause Terraform v0.13 to reject the configuration as invalid.</p> </blockquote> <p>Normally Terraform verifies version selections and checksums for providers in order to help ensure that all operations are made with the intended version of a provider, and that authors can gradually upgrade to newer provider versions in a controlled manner.</p> <p>These version and checksum rules are inconvenient when developing a provider though, because we often want to try a test configuration against a development build of a provider that doesn't even have an associated version number yet, and doesn't have an official set of checksums listed in a provider registry.</p> <p>As a convenience for provider development, Terraform supports a special additional block <code>dev_overrides</code> in <code>provider_installation</code> blocks. The contents of this block effectively override all of the other configured installation methods, so a block of this type must always appear first in the sequence:</p> <pre data-language="ruby">provider_installation {

  # Use /home/developer/tmp/terraform-null as an overridden package directory
  # for the hashicorp/null provider. This disables the version and checksum
  # verifications for this provider and forces Terraform to look for the
  # null provider plugin in the given directory.
  dev_overrides {
    "hashicorp/null" = "/home/developer/tmp/terraform-null"
  }

  # For all other providers, install them directly from their origin provider
  # registries as normal. If you omit this, Terraform will _only_ use
  # the dev_overrides block, and so no other providers will be available.
  direct {}
}
</pre>
<p>With development overrides in effect, the <code>terraform init</code> command will still attempt to select a suitable published version of your provider to install and record in <a href="../../language/dependency-lock">the dependency lock file</a> for future use, but other commands like <code>terraform apply</code> will disregard the lock file's entry for <code>hashicorp/null</code> and will use the given directory instead. Once your new changes are included in a published release of the provider, you can use <code>terraform init -upgrade</code> to select the new version in the dependency lock file and remove your development override.</p> <p>The override path for a particular provider should be a directory similar to what would be included in a <code>.zip</code> file when distributing the provider. At minimum that includes an executable file named with a prefix like <code>terraform-provider-null</code>, where <code>null</code> is the provider type. If your provider makes use of other files in its distribution package then you can copy those files into the override directory too.</p> <p>You may wish to enable a development override only for shell sessions where you are actively working on provider development. If so, you can write a local CLI configuration file with content like the above in your development directory, perhaps called <code>dev.tfrc</code> for the sake of example, and then use the <code>TF_CLI_CONFIG_FILE</code> environment variable to instruct Terraform to use that localized CLI configuration instead of the default one:</p> <pre>export TF_CLI_CONFIG_FILE=/home/developer/tmp/dev.tfrc
</pre>
<p>Development overrides are not intended for general use as a way to have Terraform look for providers on the local filesystem. If you wish to put copies of <em>released</em> providers in your local filesystem, see <a href="#implied-local-mirror-directories">Implied Local Mirror Directories</a> or <a href="#explicit-installation-method-configuration">Explicit Installation Method Configuration</a> instead.</p> <p>This development overrides mechanism is intended as a pragmatic way to enable smoother provider development. The details of how it behaves, how to configure it, and how it interacts with the dependency lock file may all evolve in future Terraform releases, including possible breaking changes. We therefore recommend using development overrides only temporarily during provider development work.</p> <h2 id="removed-settings">  Removed Settings </h2> <p>The following settings are supported in Terraform 0.12 and earlier but are no longer recommended for use:</p> <ul> <li>
<a href="#providers"><code>providers</code></a> - a configuration block that allows specifying the locations of specific plugins for each named provider. This mechanism is deprecated because it is unable to specify a version number and source for each provider. See <a href="#provider-installation">Provider Installation</a> above for the replacement of this setting in Terraform 0.13 and later. </li> </ul><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.terraform.io/docs/cli/config/config-file.html" class="_attribution-link" target="_blank">https://www.terraform.io/docs/cli/config/config-file.html</a>
  </p>
</div>
