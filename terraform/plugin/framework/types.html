 <h1 id="attribute-types">  Attribute Types </h1> <p>Attributes are the fields in a resource, data source, or provider. They hold the values that end up in state. Every attribute has an attribute type, which describes the constraints on the data the attribute can hold. When you access an attribute from the configuration, state, or plan, you are accessing attribute values, which are the actual data that was found in the configuration, state, or plan.</p> <p>You can either use the built-in attribute type and value implementations or implement your own.</p> <h2 id="null-and-unknown-values">  Null and Unknown Values </h2> <p>There are two values every attribute in Terraform can hold, regardless of their type: null and unknown.</p> <h3 id="null">  Null </h3> <p>Null represents the absence of a Terraform value. It is usually encountered with optional attributes that the practitioner neglected to specify a value for, but can show up on any non-required attribute. Required attributes can never be null.</p> <h3 id="unknown">  Unknown </h3> <p>Unknown represents a Terraform value that is not yet known. Terraform uses a graph of providers, resources, and data sources to do things in the right order, and when a provider, resource, or data source relies on a value from another provider, resource, or data source that has not been resolved yet, it represents that state by using the unknown value. For example:</p> <pre data-language="ruby">resource "example_foo" "bar" {
  hello = "world"
  demo = true
}

resource "example_baz" "quux" {
  foo_id = example_foo.bar.id
}
</pre>
<p>In the example above, <code>example_baz.quux</code> is relying on the <code>id</code> attribute of <code>example_foo.bar</code>. The <code>id</code> attribute of <code>example_foo.bar</code> isn't known until after the apply. The plan would list it as <code>(known after apply)</code>. During the plan phase, <code>example_baz.quux</code> would get an unknown value as the value for <code>foo_id</code>.</p> <p>Because they can result from interpolations in the practitioner's config, you have no control over what attributes may contain an unknown value. However, by the time a resource is expected to be created, read, updated, or deleted, only its computed attributes can be unknown. The rest are guaranteed to have known values (or be null).</p> <p>Provider configuration values can be unknown, and providers should handle that situation, even if that means just returning an error.</p> <h2 id="built-in-types-and-values">  Built-In Types and Values </h2> <p>A collection of attribute type and attribute value implementations is available in the <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-framework/types"><code>types</code></a> package.</p> <h3 id="stringtype-and-string">  StringType and String </h3> <p>Strings are a UTF-8 encoded collection of bytes.</p> <pre data-language="ruby">hello = "world"
</pre>
<p>They are used by specifying the <code>types.StringType</code> constant in your <code>schema.Attribute</code>'s <code>Type</code> property, and are represented by a <code>types.String</code> struct in config, state, and plan. The <code>types.String</code> struct has the following properties:</p> <ul> <li>
<a href="#value"><code>Value</code></a> contains the string's value as a Go <code>string</code> type. </li> <li>
<a href="#null-1"><code>Null</code></a> is set to <code>true</code> when the string's value is null. </li> <li>
<a href="#unknown-1"><code>Unknown</code></a> is set to <code>true</code> when the string's value is unknown. </li> </ul> <h3 id="numbertype-and-number">  NumberType and Number </h3> <p>Numbers are numeric values, both whole values like <code>12</code> or fractional values like <code>3.14</code>.</p> <pre data-language="ruby">hello = 123
</pre>
<p>They are used by specifying the <code>types.NumberType</code> constant in your <code>schema.Attribute</code>'s <code>Type</code> property, and are represented by a <code>types.Number</code> struct in config, state, and plan. The <code>types.Number</code> struct has the following properties:</p> <ul> <li>
<a href="#value-1"><code>Value</code></a> contains the number's value as a Go <a href="https://pkg.go.dev/math/big#Float"><code>*big.Float</code></a> type. </li> <li>
<a href="#null-2"><code>Null</code></a> is set to <code>true</code> when the number's value is null. </li> <li>
<a href="#unknown-2"><code>Unknown</code></a> is set to <code>true</code> when the number's value is unknown. </li> </ul> <h3 id="booltype-and-bool">  BoolType and Bool </h3> <p>Bools are boolean values that can either be true or false.</p> <pre data-language="ruby">hello = true
</pre>
<p>They are used by specifying the <code>types.BoolType</code> constant in your <code>schema.Attribute</code>'s <code>Type</code> property, and are represented by a <code>types.Bool</code> struct in config, state, and plan. The <code>types.Bool</code> struct has the following properties:</p> <ul> <li>
<a href="#value-2"><code>Value</code></a> contains the boolean's value as a Go <code>bool</code> type. </li> <li>
<a href="#null-3"><code>Null</code></a> is set to <code>true</code> when the boolean's value is null. </li> <li>
<a href="#unknown-3"><code>Unknown</code></a> is set to <code>true</code> when the boolean's value is unknown. </li> </ul> <h3 id="listtype-and-list">  ListType and List </h3> <p>Lists are ordered collections of other types. Their elements, the values inside the list, must all be of the same type.</p> <pre data-language="ruby">hello = ["red", "blue", "green"]
</pre>
<p>They are used by specifying a <code>types.ListType</code> value in your <code>schema.Attribute</code>'s <code>Type</code> property. You must specify an <code>ElemType</code> property for your list, indicating what type the elements should be. Lists are represented by a <code>types.List</code> struct in config, state, and plan. The <code>types.List</code> struct has the following properties:</p> <ul> <li>
<a href="#elemtype"><code>ElemType</code></a> will always contain the same type as the <code>ElemType</code> property of the <code>types.ListType</code> that created the <code>types.List</code>. </li> <li>
<a href="#elem"><code>Elem</code></a> contains a list of values, one for each element in the list. The values will all be of the value type produced by the <code>ElemType</code> for the list. </li> <li>
<a href="#null-4"><code>Null</code></a> is set to <code>true</code> when the entire list's value is null. Individual elements may still be null even if the list's <code>Null</code> property is <code>false</code>. </li> <li>
<a href="#unknown-4"><code>Unknown</code></a> is set to <code>true</code> when the entire list's value is unknown. Individual elements may still be unknown even if the list's <code>Unknown</code> property is <code>false</code>. </li> </ul> <p>Elements of a <code>types.List</code> with a non-null, non-unknown value can be accessed without using type assertions by using the <code>types.List</code>'s <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-framework/types#List.ElementsAs"><code>ElementsAs</code> method</a>, which uses the same conversion rules as the <code>Get</code> methods described in <a href="accessing-values">Access State, Config, and Plan</a>.</p> <h3 id="maptype-and-map">  MapType and Map </h3> <p>Maps are unordered collections of other types with unique string indexes. Their elements, the values inside the map, must all be of the same type. The keys used to index the elements must be strings, but there are (theoretically) no limitations on what keys are acceptable or how many there can be.</p> <pre data-language="ruby">hello = {
  pi = 3.14
  random = 4
  "meaning of life" = 42
}
</pre>
<p>They are used by specifying a <code>types.MapType</code> value in your <code>schema.Attribute</code>'s <code>Type</code> property. You must specify an <code>ElemType</code> property for your map, indicating what type the elements should be. Maps are represented by a <code>types.Map</code> struct in config, state, and plan. The <code>types.Map</code> struct has the following properties:</p> <ul> <li>
<a href="#elemtype-1"><code>ElemType</code></a> will always contain the same type as the <code>ElemType</code> property of the <code>types.MapType</code> that created the <code>types.Map</code>. </li> <li>
<a href="#elem-1"><code>Elem</code></a> contains a map of values, one for each element in the map. The keys will be the keys defined in the config, state, or plan, and the values will all be of the value type produced by the <code>ElemType</code> for the map. </li> <li>
<a href="#null-5"><code>Null</code></a> is set to <code>true</code> when the entire map's value is null. Individual elements may still be null even if the map's <code>Null</code> property is <code>false</code>. </li> <li>
<a href="#unknown-5"><code>Unknown</code></a> is set to <code>true</code> when the entire map's value is unknown. Individual elements may still be unknown even if the map's <code>Unknown</code> property is <code>false</code>. </li> </ul> <p>Elements of a <code>types.Map</code> with a non-null, non-unknown value can be accessed without using type assertions by using the <code>types.Map</code>'s <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-framework/types#Map.ElementsAs"><code>ElementsAs</code> method</a>, which uses the same conversion rules as the <code>Get</code> methods described in <a href="accessing-values">Access State, Config, and Plan</a>.</p> <h3 id="objecttype-and-object">  ObjectType and Object </h3> <p>Objects are unordered collections of other types with unique, pre-specified attributes. The attributes have names represented by strings, and each attribute can specify its own type, similar to a Go <code>struct</code> type. The attributes and their types are considered part of the object's type; two objects are not the same type unless they have the same attributes, and those attributes have the same types.</p> <pre data-language="ruby">hello = {
  pi = 3.14
  demo = true
  color = "red"
}
</pre>
<p>They are used by specifying a <code>types.ObjectType</code> value in your <code>schema.Attribute</code>'s <code>Type</code> property. You must specify an <code>AttrTypes</code> property for your object, indicating a map of the attribute names and the types of those attributes. Objects are represented by a <code>types.Object</code> struct in config, state, and plan. The <code>types.Object</code> struct has the following properties:</p> <ul> <li>
<a href="#attrtypes"><code>AttrTypes</code></a> will always contain the same attribute names and associated types as the <code>AttrTypes</code> property of the <code>types.ObjectType</code> that created the <code>types.Object</code>. </li> <li>
<a href="#attrs"><code>Attrs</code></a> contains a map of attribute names to values. Each attribute is guaranteed to always be present in the map. The values will always be of the value type for that attribute in the <code>AttrTypes</code> of the object. </li> <li>
<a href="#null-6"><code>Null</code></a> is set to <code>true</code> when the entire object's value is null. Individual attributes may still be null even if the object's <code>Null</code> property is false. </li> <li>
<a href="#unknown-6"><code>Unknown</code></a> is set to <code>true</code> when the entire object's value is unknown. Individual attributes may still be unknown even if the object's <code>Unknown</code> property is <code>false</code>. </li> </ul> <p>A non-null, non-unknown <code>types.Object</code> value can be converted to a Go struct without using type assertions by using the <code>types.Object</code>'s <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-framework/types#Object.As"><code>As</code> method</a>, which uses the same conversion rules as the <code>Get</code> methods described in <a href="accessing-values">Access State, Config, and Plan</a>.</p> <h2 id="create-your-own-types-and-values">  Create Your Own Types and Values </h2> <p>You may want to build your own attribute value and type implementations to allow your provider to combine validation, description, and plan customization behaviors into a reusable bundle. This helps avoid duplication or reimplementation and ensures consistency.</p> <blockquote class="alert alert-warning" role="alert"> <p><strong>Important:</strong> Specifying validation and plan customization for attribute types is not yet supported, limiting their utility. Support is expected in the near future.</p> </blockquote> <h3 id="implement-the-attr-type-interface">  Implement the <code>attr.Type</code> Interface </h3> <p>Use the <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-framework/attr#Type"><code>attr.Type</code> interface</a> to implement an attribute type. It tells Terraform about its constraints and tells the framework how to create new attribute values from the information Terraform supplies. <code>attr.Type</code> has the following methods.</p> <h4 id="terraformtype">  TerraformType </h4> <p><code>TerraformType</code> is expected to return the <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-go/tftypes#Type"><code>tftypes.Type</code> value</a> that describes its type constraints. This is how Terraform will know what type of values it can accept.</p> <h4 id="valuefromterraform">  ValueFromTerraform </h4> <p><code>ValueFromTerraform</code> is expected to return an attribute value from the <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-go/tftypes#Value"><code>tftypes.Value</code></a> that Terraform supplies, or to return an error if it cannot. This error should not be used for validation purposes, and is expected to indicate programmer error, not practitioner error.</p> <h4 id="equal">  Equal </h4> <p><code>Equal</code> is expected to return true if the attribute type is considered equal to the passed attribute type.</p> <h3 id="implement-the-attributepathstepper-interface">  Implement the <code>AttributePathStepper</code> Interface </h3> <p>All attribute types must implement the <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-go/tftypes#AttributePathStepper"><code>tftypes.AttributePathStepper</code> interface</a>, so the framework can access element or attribute types using attribute paths.</p> <h3 id="implement-type-specific-interfaces">  Implement Type-Specific Interfaces </h3> <h4 id="contain-elements-of-the-same-type">  Contain Elements of the Same Type </h4> <p>Attribute types that contain elements of the same type, like maps and lists, are required to implement the <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-framework/attr#TypeWithElementType"><code>attr.TypeWithElementType</code> interface</a>, which adds <code>WithElementType</code> and <code>ElementType</code> methods to the <code>attr.Type</code> interface. <code>WithElementType</code> must return a copy of the attribute type, but with its element type set to the passed type. <code>ElementType</code> must return the attribute type's element type.</p> <h4 id="contain-elements-of-different-types">  Contain Elements of Different Types </h4> <p>Attribute types that contain elements of differing types, like tuples, are required to implement the <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-framework/attr#TypeWithElementTypes"><code>attr.TypeWithElementTypes</code> interface</a>, which adds <code>WithElementTypes</code> and <code>ElementTypes</code> methods to the <code>attr.Type</code> interface. <code>WithElementTypes</code> must return a copy of the attribute type, but with its element types set to the passed element types. <code>ElementTypes</code> must return the attribute type's element types.</p> <h4 id="contain-attributes">  Contain Attributes </h4> <p>Attribute types that contain attributes, like objects, are required to implement the <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-framework/attr#TypeWithAttributeTypes"><code>attr.TypeWithAttributeTypes</code> interface</a>, which adds <code>WithAttributeTypes</code> and <code>AttributeTypes</code> methods to the <code>attr.Type</code> interface. <code>WithAttributeTypes</code> must return a copy of the attribute type, but with its attribute types set to the passed attribute types. <code>AttributeTypes</code> must return the attribute type's attribute types.</p> <h3 id="implement-the-attr-value-interface">  Implement the <code>attr.Value</code> Interface </h3> <p>Use the <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-framework/attr#Value"><code>attr.Value</code> interface</a> to implement an attribute value. It tells the framework how to express that attribute value in a way that Terraform will understand. <code>attr.Value</code> has the following methods.</p> <h4 id="toterraformvalue">  ToTerraformValue </h4> <p><code>ToTerraformValue</code> returns a Go type that is valid input for <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-go/tftypes#NewValue"><code>tftypes.NewValue</code></a> for the <code>tftypes.Type</code> specified by the <code>attr.Type</code> that creates the <code>attr.Value</code>.</p> <h4 id="equal-1">  Equal </h4> <p><code>Equal</code> returns true if the passed attribute value should be considered to the attribute value the method is being called on. The passed attribute value is not guaranteed to be of the same Go type.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.terraform.io/docs/plugin/framework/types.html" class="_attribution-link" target="_blank">https://www.terraform.io/docs/plugin/framework/types.html</a>
  </p>
</div>
