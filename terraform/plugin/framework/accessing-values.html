 <h1 id="access-state-config-and-plan">  Access State, Config, and Plan </h1> <p>There are various points at which the provider needs access to the data from the practitioner's configuration, Terraform's state, or generated plan. The same patterns are used for accessing this data, regardless of its source.</p> <p>The data is usually stored in a request object:</p> <pre>func (m myResource) Create(ctx context.Context,
    req tfsdk.CreateResourceRequest, resp *tfsdk.CreateResourceResponse)
</pre>
<p>In this example, <code>req</code> holds the configuration and plan, and there is no state value because the resource does not yet exist in state.</p> <h2 id="get-the-entire-configuration-plan-or-state">  Get the Entire Configuration, Plan, or State </h2> <p>One way to interact with configuration, plan, and state values is to convert the entire configuration, plan, or state into a Go type, then treat them as regular Go values. This has the benefit of letting the compiler check all your code that accesses values, but requires defining a type to contain the values.</p> <pre>type resourceData struct {
    Name types.String `tfsdk:"name"`
    Age types.Number `tfsdk:"age"`
    Registered types.Bool `tfsdk:"registered"`
    Pets types.List `tfsdk:"pets"`
    Tags types.Map `tfsdk:"tags"`
    Address types.Object `tfsdk:"address"`
}

func (m myResource) Create(ctx context.Context,
    req tfsdk.CreateResourceRequest, resp *tfsdk.CreateResourceResponse) {
    var plan resourceData
    err := req.Plan.Get(ctx, &amp;plan)
    if err != nil {
        // TODO: handle error
    }
    // values can now be accessed like plan.Name.Value
    // check if things are null with plan.Name.Null
    // check if things are unknown with plan.Name.Unknown
}
</pre>
<p>The configuration, plan, and state data is represented as an object, and accessed like an object. See the <a href="#conversion-rules">conversion rules</a> for an explanation on how objects can be converted into Go types.</p> <p>However, using the <a href="types"><code>attr.Value</code> implementations</a> can surface unnecessary complexity. For example, in a create function, non-computed values are guaranteed to be defined. Likewise, a required value will never be null.</p> <p>To aid in this, <code>Get</code> can do some conversion to Go types that can hold the data:</p> <pre>type resourceData struct {
  Name string `tfsdk:"name"`
  Age int64 `tfsdk:"age"`
  Registered bool `tfsdk:"registered"`
  Pets []string `tfsdk:"pets"`
  Tags map[string]string `tfsdk:"tags"`
  Address struct{
    Street string `tfsdk:"street"`
    City string `tfsdk:"city"`
    State string `tfsdk:"state"`
    Zip int64 `tfsdk:"zip"`
  } `tfsdk:"address"`
}
</pre>
<p>See <a href="#conversion-rules">below</a> for the rules about conversion.</p> <h2 id="get-a-single-attribute-39-s-value">  Get a Single Attribute's Value </h2> <p>Another way to interact with configuration, plan, and state values is to retrieve a single value from the configuration, plan, or state and convert it into a Go type. This does not require defining a type (except for objects), but means each attribute access steps outside of what the compiler can check, and may return an error at runtime. It also requires a type assertion, though the type will always be the type produced by that attribute's <code>attr.Type</code>.</p> <pre>func (m myResource) Create(ctx context.Context,
    req tfsdk.CreateResourceRequest, resp *tfsdk.CreateResourceResponse) {
    attr, err := req.Config.GetAttribute(ctx, tftypes.NewAttributePath().WithAttributeName("age"))
    if err != nil {
        // TODO: handle error
    }
    age := attr.(types.Number)
}
</pre>
<blockquote class="alert alert-info" role="alert"> <p><strong>Note:</strong> The call to <code>tftypes.NewAttributePath</code> is creating an <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-go/tftypes#AttributePath">attribute path</a> pointing to the specific attribute. A less-verbose way to specify attribute paths is coming soon.</p> </blockquote> <blockquote class="alert alert-info" role="alert"> <p><strong>Note:</strong> Helpers to access <code>attr.Value</code>s using the same reflection rules <code>Get</code> has are planned, to avoid the need to type assert. We hope to release them soon.</p> </blockquote> <h2 id="when-can-a-value-be-unknown-or-null-">  When Can a Value Be Unknown or Null? </h2> <p>A lot of conversion rules say an error will be returned if a value is unknown or null. It is safe to assume:</p> <ul> <li>Required attributes will never be null or unknown in Create, Read, Update, or Delete methods. </li> <li>Optional attributes that are not computed will never be unknown in Create, Read, Update, or Delete methods. </li> <li>Computed attributes, whether optional or not, will never be null in the plan for Create, Read, Update, or Delete methods. </li> <li>Computed attributes that are read-only (<code>Optional</code> is not <code>true</code>) will always be unknown in the plan for Create, Read, Update, or Delete methods. They will always be null in the configuration for Create, Read, Update, and Delete methods. </li> <li>Required attributes will never be null in a provider's Configure method. They may be unknown. </li> <li>The state never contains unknown values. </li> <li>The configuration for Create, Read, Update, and Delete methods never contains unknown values. </li> </ul> <p>In any other circumstances, the provider is responsible for handling the possibility that an unknown or null value may be presented to it.</p> <h2 id="conversion-rules">  Conversion Rules </h2> <blockquote class="alert alert-danger" role="alert"> <p><strong>Warning:</strong> It can be tempting to use Go types instead of <code>attr.Value</code> implementations when the provider doesn't care about the distinction between an empty value, unknown, and null. But if Terraform has a null or unknown value and the provider asks the framework to store it in a type that can't hold it, <code>Get</code> will return an error. Make sure the types you are using can hold the values they might contain! An opt-in conversion of null or unknown values to the empty value is coming in the future.</p> </blockquote> <h3 id="string">  String </h3> <p>Strings can be automatically converted to Go's <code>string</code> type (or any aliases of it, like <code>type MyString string</code>) as long as the string value is not null or unknown.</p> <h3 id="number">  Number </h3> <p>Numbers can be automatically converted to the following numeric types (or any aliases of them, like <code>type MyNumber int</code>) as long as the number value is not null or unknown:</p> <ul> <li>
<a href="#int"><code>int</code></a>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code> </li> <li>
<a href="#uint"><code>uint</code></a>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code> </li> <li>
<a href="#float32"><code>float32</code></a>, <code>float64</code> </li> <li>
<a href="https://pkg.go.dev/math/big#Int"><code>*big.Int</code></a>, <a href="https://pkg.go.dev/math/big#Float"><code>*big.Float</code></a> </li> </ul> <p>An error will be returned if the value of the number cannot be stored in the numeric type supplied because of an overflow or other loss of precision.</p> <h3 id="boolean">  Boolean </h3> <p>Booleans can be automatically converted to Go's <code>bool</code> type (or any aliases of it, like <code>type MyBoolean bool</code>) as long as the boolean value is not null or unknown.</p> <h3 id="list">  List </h3> <p>Lists can be automatically converted to any Go slice type (or alias of a Go slice type, like <code>type MyList []string</code>), with the elements either being <code>attr.Value</code> implementations or being converted according to these rules. Go slice types are considered capable of handling null values; the slice will be set to nil. The <code>Get</code> method will still return an error for unknown list values.</p> <h3 id="map">  Map </h3> <p>Maps can be automatically converted to any Go map type with string keys (or any alias of a Go map type with string keys, like <code>type MyMap map[string]int</code>), with the elements either being <code>attr.Value</code> implementations or being converted according to these rules. Go map types are considered capable of handling null values; the map will be set to nil. The <code>Get</code> method will still return an error for unknown map values.</p> <h3 id="object">  Object </h3> <p>Objects can be automatically converted to any Go struct type with that follows these constraints:</p> <ul> <li>Every property on the struct must have a <code>tfsdk</code> struct tag. </li> <li>The <code>tfsdk</code> struct tag must name an attribute in the object that it is being mapped to or be set to <code>-</code> to explicitly declare it does not map to an attribute in the object. </li> <li>Every attribute in the object must have a corresponding struct tag. </li> </ul> <p>These rules help prevent typos and human error from unwittingly discarding information by failing as early, consistently, and loudly as possible.</p> <p>Properties can either be <code>attr.Value</code> implementations or will be converted according to these rules.</p> <p>Unknown and null objects cannot be represented as structs and will return an error. Their attributes may contain unknown or null values if the attribute's type can hold them.</p> <h3 id="pointers">  Pointers </h3> <p>Pointers behave exactly like the type they are referencing, except they can hold null values. A pointer will be set to <code>nil</code> when representing a null value; otherwise, the conversion rules for that type will apply.</p> <h3 id="detected-interfaces">  Detected Interfaces </h3> <p><code>Get</code> detects and utilizes the following interfaces, if the target implements them.</p> <h4 id="valueconverter">  ValueConverter </h4> <p>If a value is being set on a Go type that implements the <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-go/tftypes#ValueConverter"><code>tftypes.ValueConverter</code> interface</a>, that interface will be delegated to to handle the conversion.</p> <h4 id="unknownable">  Unknownable </h4> <p>If the value is being set on a Go type that fills the <code>Unknownable</code> interface:</p> <pre>type Unknownable interface {
    SetUnknown(context.Context, bool) error
    SetValue(context.Context, interface{}) error
    GetUnknown(context.Context) bool
    GetValue(context.Context) interface{}
}
</pre>
<p>It will be considered capable of handling unknown values, and those methods will be used to populate it and retrieve its value. The <code>interface{}</code> being passed and retrieved will be of a type that can be passed to <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-go/tftypes#NewValue"><code>tftypes.NewValue</code></a>.</p> <h4 id="nullable">  Nullable </h4> <p>If the value is being set on a Go type that fills the <code>Nullable</code> interface:</p> <pre>type Nullable interface {
    SetNull(context.Context, bool) error
    SetValue(context.Context, interface{}) error
    GetNull(context.Context) bool
    GetValue(context.Context) interface{}
}
</pre>
<p>It will be considered capable of handling null values, and those methods will be used to populate it and retrieve its value. The <code>interface{}</code> being passed and retrieved will be of a type that can be passed to <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-go/tftypes#NewValue"><code>tftypes.NewValue</code></a>.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.terraform.io/docs/plugin/framework/accessing-values.html" class="_attribution-link" target="_blank">https://www.terraform.io/docs/plugin/framework/accessing-values.html</a>
  </p>
</div>
