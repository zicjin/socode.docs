 <h1 id="resources">  Resources </h1> <p><a href="../../language/resources/index">Resources</a> are an abstraction that allow Terraform to manage infrastructure objects, such as a compute instance, an access policy, or disk. Terraform assumes that every resource:</p> <ul> <li> operates as a pure key/value store, with values getting returned exactly as they were written. </li> <li>needs only one API call to update or return its state. </li> <li>can be be created, read, updated, and deleted. </li> </ul> <p>Providers act as a translation layer between Terraform and an API, offering one or more resources for practitioners to define in a configuration. To create resources for your provider, you need to define both the resource archetype and actions on specific resource instances.</p> <h2 id="define-resource-archetype">  Define Resource Archetype </h2> <p>Implement the <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-framework/tfsdk#ResourceType"><code>tfsdk.ResourceType</code> interface</a> for every type of resource you want to support: compute instances, disks, access policies, etc. It allows you to describe the resource archetype, which is the functionality related to all instances of that resource type in the configuration, state, plan, and API. <code>ResourceType</code> has the following methods:</p> <h3 id="getschema">  GetSchema </h3> <p><code>GetSchema</code> returns a <a href="schemas">schema</a> describing what fields are available in the resource's configuration and state.</p> <h3 id="newresource">  NewResource </h3> <p><code>NewResource</code> returns a new instance of that resource type. It instantiates a new <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-framework/tfsdk#Resource"><code>tfsdk.Resource</code> implementation</a> that expects to operate on data with the structure defined in <code>GetSchema</code>. It does not need to create the instance on the API.</p> <p>The <code>NewResource</code> method is passed a <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-framework/tfsdk#Provider"><code>tfsdk.Provider</code> implementation</a>. This is the <a href="providers">provider type</a> after its <code>Configure</code> method was called. The <code>NewResource</code> method can type-assert on this and inject it into the <code>Resource</code>, allowing the <code>Resource</code> to have strongly-typed access to the configured API client or other provider configuration data.</p> <p><br> <strong>Example</strong></p> <pre>type computeInstanceResourceType struct{}

func (c computeInstanceResourceType) GetSchema(_ context.Context) (schema.Schema,
    []*tfprotov6.Diagnostic) {
    return schema.Schema{
        Attributes: map[string]tfsdk.Attribute{
            "name": {
                Type: types.StringType,
                Required: true,
            },
        },
    }, nil
}

func (c computeInstanceResourceType) NewResource(_ context.Context,
    p tfsdk.Provider) (tfsdk.Resource, []*tfprotov6.Diagnostic) {
    return computeInstanceResource{
        client: p.(*provider).client,
    }, nil
}
</pre>
<h2 id="define-resources">  Define Resources </h2> <p>Resources are scoped to a single instance of a resource type. They modify a specific resource in the API and in the state, given that resource's configuration, state, and plan values. They do this through the following methods.</p> <h3 id="create">  Create </h3> <p><code>Create</code> makes the necessary API calls to create the resource and then persist that resource's data into the Terraform state. This is usually accomplished by:</p> <ol> <li>
<a href="accessing-values">Reading the plan data</a> from the <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-framework/tfsdk#CreateResourceRequest"><code>tfsdk.CreateResourceRequest</code></a> </li> <li>Using the configured API client injected into the resource by the resource type's <code>NewResource</code> method </li> <li>
<a href="writing-state">Writing to the state</a>. </li> </ol> <p>It is very important that every known value in the plan ends up in state as a byte-for-byte match, or Terraform will throw errors. The plan is the provider's contract with Terraform: the provider can only change values that are <a href="types#unknown">unknown</a> in the plan. It's also very important that every unknown value in the plan gets a known, concrete value when it's set in the state; the state can never hold any unknown values.</p> <h3 id="read">  Read </h3> <p><code>Read</code> updates Terraform's state to reflect the latest state of the resource in the API.</p> <p>There is no plan or config to work with in <code>Read</code>. Resources should <a href="accessing-values">retrieve the data they need</a> from the current state included in the <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-framework/tfsdk#ReadResourceRequest"><code>tfsdk.ReadResourceRequest</code></a>. They can then use the configured API client injected into the resource by the resource type's <code>NewResource</code> method, and <a href="writing-state">write the results to the state</a>.</p> <p>The provider can set any value in state, but you should be mindful of values that:</p> <ul> <li>represent "drift," or instances when the API's state has deviated from the source of truth defined in the configuration file. This is usually (but not always) the result of someone or something other than Terraform modifying a resource Terraform "owns". When this happens, the value should always be updated in state to reflect the drifted value. </li> <li>are semantically equivalent with values currently in state. Some values are semantically the same even if they are not a byte-for-byte match. JSON strings that change the order of keys or change the semantically-insignificant whitespace, for example, may not represent drift but are just different representations of the same value. When this happens, the <em>existing</em> value should always be maintained in state and should not be replaced with the new representation that the API is returning. </li> </ul> <h3 id="update">  Update </h3> <p><code>Update</code> makes the necessary API calls to modify the existing resource to match the configuration and then to persist that resource's data into the Terraform state. This is usually accomplished by:</p> <ol> <li>
<a href="accessing-values">Reading the plan data</a> from the <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-framework/tfsdk#UpdateResourceRequest"><code>tfsdk.UpdateResourceRequest</code></a> </li> <li>Using the configured API client injected into the resource by the resource type's <code>NewResource</code> method </li> <li>
<a href="writing-state">Writing to the state</a>. </li> </ol> <p>It is very important that every known value in the plan ends up in state as a byte-for-byte match, or Terraform will throw errors. The plan is the provider's contract with Terraform: the provider can only change values that are <a href="types#unknown">unknown</a> in the plan. It's also very important that every unknown value in the plan gets a known, concrete value when it's set in the state; the state can never hold any unknown values.</p> <h3 id="delete">  Delete </h3> <p><code>Delete</code> makes the necessary API calls to destroy a resource and then to remove that resource from the Terraform state. This is usually accomplished by:</p> <ol> <li>
<a href="accessing-values">Reading the prior state data</a> from the <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-framework/tfsdk#DeleteResourceRequest"><code>tfsdk.DeleteResourceRequest</code></a> </li> <li>Using the configured API client injected into the resource by the resource type's <code>NewResource</code> method </li> <li>Calling the <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-framework/tfsdk#State.RemoveResource"><code>State.RemoveResource</code> method</a> on the state in the <a href="https://pkg.go.dev/github.com/hashicorp/terraform-plugin-framework/tfsdk#DeleteResourceResponse"><code>tfsdk.DeleteResourceResponse</code></a>. </li> </ol> <h2 id="add-resource-to-provider">  Add Resource to Provider </h2> <p>To make new resources available to practitioners, add them to the <code>GetResources</code> method on the <a href="providers">provider</a>. The key must be the name of the resource, including the provider prefix, and the value must be an instance of the resource type.</p> <p><strong>Example</strong></p> <pre>func (p *provider) GetResources(_ context.Context) (map[string]tfsdk.ResourceType,
    []*tfprotov6.Diagnostic) {
    return map[string]tfsdk.ResourceType{
        "example_compute_instance": computeInstanceResourceType{},
    }, nil
}
</pre><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://www.terraform.io/docs/plugin/framework/resources.html" class="_attribution-link" target="_blank">https://www.terraform.io/docs/plugin/framework/resources.html</a>
  </p>
</div>
