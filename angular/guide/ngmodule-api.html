  <h1 id="ngmodule-api">NgModule API</h1> <p>At a high level, NgModules are a way to organize Angular applications and they accomplish this through the metadata in the <code>@<a href="../api/core/ngmodule" class="code-anchor">NgModule</a></code> decorator. The metadata falls into three categories:</p> <ul> <li>
<strong>Static:</strong> Compiler configuration which tells the compiler about directive selectors and where in templates the directives should be applied through selector matching. This is configured using the <code>declarations</code> array.</li> <li>
<strong>Runtime:</strong> Injector configuration using the <code>providers</code> array.</li> <li>
<strong>Composability/Grouping:</strong> Bringing NgModules together and making them available using the <code>imports</code> and <code>exports</code> arrays.</li> </ul> <pre data-language="typescript">@NgModule({
  // Static, that is compiler configuration
  declarations: [], // Configure the selectors

  // Runtime, or injector configuration
  providers: [], // Runtime injector configuration

  // Composability / Grouping
  imports: [], // composing NgModules together
  exports: [] // making NgModules available to other parts of the app
})</pre> <h2 id="ngmodule-metadata">
<code>@<a href="../api/core/ngmodule" class="code-anchor">NgModule</a></code> metadata</h2> <p>The following table summarizes the <code>@<a href="../api/core/ngmodule" class="code-anchor">NgModule</a></code> metadata properties.</p> <table> <tbody>
<tr> <th> Property </th> <th> Description </th> </tr> <tr> <td style="vertical-align: top"> <code>declarations</code> </td> <td> <p> A list of <a href="ngmodule-faq#q-declarable">declarable</a> classes, (<em>components</em>, <em>directives</em>, and <em>pipes</em>) that <em>belong to this module</em>.</p> <ol> <li>When compiling a template, you need to determine a set of selectors which should be used for triggering their corresponding directives.</li> <li> The template is compiled within the context of an NgModule—the NgModule within which the template's component is declared—which determines the set of selectors using the following rules: <ul> <li>All selectors of directives listed in `declarations`.</li> <li>All selectors of directives exported from imported NgModules.</li> </ul> </li> </ol> <p> Components, directives, and pipes must belong to <em>exactly</em> one module. The compiler emits an error if you try to declare the same class in more than one module. Be careful not to re-declare a class that is imported directly or indirectly from another module.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>providers</code> </td> <td> <p> A list of dependency-injection providers.</p> <p> Angular registers these providers with the NgModule's injector. If it is the NgModule used for bootstrapping then it is the root injector.</p> <p> These services become available for injection into any component, directive, pipe or service which is a child of this injector.</p> <p> A lazy-loaded module has its own injector which is typically a child of the application root injector.</p> <p> Lazy-loaded services are scoped to the lazy module's injector. If a lazy-loaded module also provides the <code>UserService</code>, any component created within that module's context (such as by router navigation) gets the local instance of the service, not the instance in the root application injector.</p> <p> Components in external modules continue to receive the instance provided by their injectors.</p> <p> For more information on injector hierarchy and scoping, see <a href="providers">Providers</a> and the <a href="dependency-injection">DI Guide</a>.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>imports</code> </td> <td> <p> A list of modules which should be folded into this module. Folded means it is as if all the imported NgModule's exported properties were declared here.</p> <p> Specifically, it is as if the list of modules whose exported components, directives, or pipes are referenced by the component templates were declared in this module.</p> <p> A component template can <a href="ngmodule-faq#q-template-reference">reference</a> another component, directive, or pipe when the reference is declared in this module or if the imported module has exported it. For example, a component can use the <code><a href="../api/common/ngif" class="code-anchor">NgIf</a></code> and <code>NgFor</code> directives only if the module has imported the Angular <code><a href="../api/common/commonmodule" class="code-anchor">CommonModule</a></code> (perhaps indirectly by importing <code><a href="../api/platform-browser/browsermodule" class="code-anchor">BrowserModule</a></code>).</p> <p> You can import many standard directives from the <code><a href="../api/common/commonmodule" class="code-anchor">CommonModule</a></code> but some familiar directives belong to other modules. For example, you can use <code>[(<a href="../api/forms/ngmodel" class="code-anchor">ngModel</a>)]</code> only after importing the Angular <code><a href="../api/forms/formsmodule" class="code-anchor">FormsModule</a></code>.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>exports</code> </td> <td> <p> A list of declarations—<em>component</em>, <em>directive</em>, and <em>pipe</em> classes—that an importing module can use.</p> <p> Exported declarations are the module's <em>public API</em>. A component in another module can <a href="ngmodule-faq#q-template-reference">use</a> <em>this</em> module's <code>UserComponent</code> if it imports this module and this module exports <code>UserComponent</code>.</p> <p> Declarations are private by default. If this module does <em>not</em> export <code>UserComponent</code>, then only the components within <em>this</em> module can use <code>UserComponent</code>.</p> <p> Importing a module does <em>not</em> automatically re-export the imported module's imports. Module 'B' can't use <code><a href="../api/common/ngif" class="code-anchor">ngIf</a></code> just because it imported module 'A' which imported <code><a href="../api/common/commonmodule" class="code-anchor">CommonModule</a></code>. Module 'B' must import <code><a href="../api/common/commonmodule" class="code-anchor">CommonModule</a></code> itself.</p> <p> A module can list another module among its <code>exports</code>, in which case all of that module's public components, directives, and pipes are exported.</p> <p> <a href="ngmodule-faq#q-reexport">Re-export</a> makes module transitivity explicit. If Module 'A' re-exports <code><a href="../api/common/commonmodule" class="code-anchor">CommonModule</a></code> and Module 'B' imports Module 'A', Module 'B' components can use <code><a href="../api/common/ngif" class="code-anchor">ngIf</a></code> even though 'B' itself didn't import <code><a href="../api/common/commonmodule" class="code-anchor">CommonModule</a></code>.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>bootstrap</code> </td> <td> <p> A list of components that are automatically bootstrapped.</p> <p> Usually there's only one component in this list, the <em>root component</em> of the application.</p> <p> Angular can launch with multiple bootstrap components, each with its own location in the host web page.</p> </td> </tr> </tbody>
</table> <h2 id="more-on-ngmodules">More on NgModules</h2> <p>You may also be interested in the following:</p> <ul> <li>
<a href="feature-modules">Feature Modules</a>.</li> <li>
<a href="entry-components">Entry Components</a>.</li> <li>
<a href="providers">Providers</a>.</li> <li>
<a href="module-types">Types of Feature Modules</a>.</li> </ul><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://angular.io/guide/ngmodule-api" class="_attribution-link" target="_blank">https://angular.io/guide/ngmodule-api</a>
  </p>
</div>
