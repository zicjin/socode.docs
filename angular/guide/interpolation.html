  <h1 id="text-interpolation">Text interpolation</h1> <p>Text interpolation lets you incorporate dynamic string values into your HTML templates. Use interpolation to dynamically change what appears in an application view, such as displaying a custom greeting that includes the user's name.</p> <blockquote class="alert is-helpful"> <p>See the live example for all of the syntax and code snippets in this guide.</p> </blockquote> <h2 id="displaying-values-with-interpolation">Displaying values with interpolation</h2> <p>Interpolation refers to embedding expressions into marked up text. By default, interpolation uses the double curly braces <code>{{</code> and <code>}}</code> as delimiters.</p> <p>To illustrate how interpolation works, consider an Angular component that contains a <code>currentCustomer</code> variable:</p> <pre header="src/app/app.component.ts" data-language="typescript">currentCustomer = 'Maria';</pre> <p>Use interpolation to display the value of this variable in the corresponding component template:</p> <pre header="src/app/app.component.html" data-language="html">&lt;h3&gt;Current customer: {{ currentCustomer }}&lt;/h3&gt;</pre> <p>Angular replaces <code>currentCustomer</code> with the string value of the corresponding component property. In this case, the value is <code>Maria</code>.</p> <p>In the following example, Angular evaluates the <code>title</code> and <code>itemImageUrl</code> properties to display some title text and an image.</p> <pre header="src/app/app.component.html" data-language="html">&lt;p&gt;{{title}}&lt;/p&gt;
&lt;div&gt;&lt;img src="{{itemImageUrl}}"&gt;&lt;/div&gt;</pre> <h2 id="template-expressions">Template expressions</h2> <p>A template <strong>expression</strong> produces a value and appears within double curly braces, <code>{{ }}</code>. Angular resolves the expression and assigns it to a property of a binding target. The target could be an HTML element, a component, or a directive.</p> <h3 id="resolving-expressions-with-interpolation">Resolving expressions with interpolation</h3> <p>More generally, the text between the braces is a template expression that Angular first evaluates and then converts to a string. The following interpolation illustrates the point by adding two numbers:</p> <pre header="src/app/app.component.html" data-language="html">&lt;!-- "The sum of 1 + 1 is 2" --&gt;
&lt;p&gt;The sum of 1 + 1 is {{1 + 1}}.&lt;/p&gt;</pre> <p>Expressions can also invoke methods of the host component such as <code>getVal()</code> in the following example:</p> <pre header="src/app/app.component.html" data-language="html">&lt;!-- "The sum of 1 + 1 is not 4" --&gt;
&lt;p&gt;The sum of 1 + 1 is not {{1 + 1 + getVal()}}.&lt;/p&gt;</pre> <p>With interpolation, Angular performs the following tasks:</p> <ol> <li>Evaluates all expressions in double curly braces.</li> <li>Converts the expression results to strings.</li> <li>Links the results to any adjacent literal strings.</li> <li>Assigns the composite to an element or directive property.</li> </ol> <blockquote class="alert is-helpful"> <p>Configure the interpolation delimiter with the <a href="../api/core/component#interpolation">interpolation</a> option in the <code>@<a href="../api/core/component" class="code-anchor">Component</a>()</code> metadata.</p> </blockquote> <h3 id="syntax">Syntax</h3> <p>Template expressions are similar to JavaScript. Many JavaScript expressions are legal template expressions, with the following exceptions.</p> <p>You can't use JavaScript expressions that have or promote side effects, including:</p> <ul> <li>Assignments (<code>=</code>, <code>+=</code>, <code>-=</code>, <code>...</code>)</li> <li>Operators such as <code>new</code>, <code>typeof</code>, or <code>instanceof</code>
</li> <li>Chaining expressions with <code>;</code> or <code>,</code>
</li> <li>The increment and decrement operators <code>++</code> and <code>--</code>
</li> <li>Some of the ES2015+ operators</li> </ul> <p>Other notable differences from JavaScript syntax include:</p> <ul> <li>No support for the bitwise operators such as <code>|</code> and <code>&amp;</code>
</li> <li>New <a href="template-expression-operators">template expression operators</a>, such as <code>|</code>, <code>?.</code> and <code>!</code>
</li> </ul> <h2 id="expression-context">Expression context</h2> <p>Interpolated expressions have a context—a particular part of the application to which the expression belongs. Typically, this context is the component instance.</p> <p>In the following snippet, the expression <code>recommended</code> and the expression <code>itemImageUrl2</code> refer to properties of the <code>AppComponent</code>.</p> <pre header="src/app/app.component.html" data-language="html">&lt;h4&gt;{{recommended}}&lt;/h4&gt;
&lt;img [src]="itemImageUrl2"&gt;</pre> <p>An expression can also refer to properties of the <em>template's</em> context such as a <a href="structural-directives#shorthand">template input variable</a> or a <a href="template-reference-variables">template reference variable</a>.</p> <p>The following example uses a template input variable of <code>customer</code>.</p> <pre header="src/app/app.component.html (template input variable)" data-language="html">&lt;ul&gt;
  &lt;li *ngFor="let customer of customers"&gt;{{customer.name}}&lt;/li&gt;
&lt;/ul&gt;</pre> <p>This next example features a template reference variable, <code>#customerInput</code>.</p> <pre header="src/app/app.component.html (template reference variable)" data-language="html">&lt;label&gt;Type something:
  &lt;input #customerInput&gt;{{customerInput.value}}
&lt;/label&gt;</pre> <blockquote class="alert is-helpful"> <p>Template expressions cannot refer to anything in the global namespace, except <code>undefined</code>. They can't refer to <code>window</code> or <code>document</code>. Additionally, they can't call <code>console.log()</code> or <code>Math.max()</code> and they are restricted to referencing members of the expression context.</p> </blockquote> <h3 id="preventing-name-collisions">Preventing name collisions</h3> <p>The context against which an expression evaluates is the union of the template variables, the directive's context object—if it has one—and the component's members. If you reference a name that belongs to more than one of these namespaces, Angular applies the following logic to determine the context:</p> <ol> <li>The template variable name.</li> <li>A name in the directive's context.</li> <li>The component's member names.</li> </ol> <p>To avoid variables shadowing variables in another context, keep variable names unique. In the following example, the <code>AppComponent</code> template greets the <code>customer</code>, Padma.</p> <p>An <code><a href="../api/common/ngforof" class="code-anchor">ngFor</a></code> then lists each <code>customer</code> in the <code>customers</code> array.</p> <pre header="src/app/app.component.ts" data-language="typescript">@Component({
  template: `
    &lt;div&gt;
      &lt;!-- Hello, Padma --&gt;
      &lt;h1&gt;Hello, {{customer}}&lt;/h1&gt;
      &lt;ul&gt;
        &lt;!-- Ebony and Chiho in a list--&gt;
        &lt;li *ngFor="let customer of customers"&gt;{{ customer.value }}&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  `
})
class AppComponent {
  customers = [{value: 'Ebony'}, {value: 'Chiho'}];
  customer = 'Padma';
}</pre> <p>The <code>customer</code> within the <code><a href="../api/common/ngforof" class="code-anchor">ngFor</a></code> is in the context of an <code><a href="../api/core/ng-template" class="code-anchor">&lt;ng-template&gt;</a></code> and so refers to the <code>customer</code> in the <code>customers</code> array, in this case Ebony and Chiho. This list does not feature Padma because <code>customer</code> outside of the <code><a href="../api/common/ngforof" class="code-anchor">ngFor</a></code> is in a different context. Conversely, <code>customer</code> in the <code>&lt;h1&gt;</code> doesn't include Ebony or Chiho because the context for this <code>customer</code> is the class and the class value for <code>customer</code> is Padma.</p> <h2 id="expression-best-practices">Expression best practices</h2> <p>When using template expressions, follow these best practices:</p> <ul> <li> <p><strong>Use short expressions</strong></p> <p>Use property names or method calls whenever possible. Keep application and business logic in the component, where it is accessible to develop and test.</p> </li> <li> <p><strong>Quick execution</strong></p> <p>Angular executes template expressions after every <a href="glossary#change-detection">change detection</a> cycle. Many asynchronous activities trigger change detection cycles, such as promise resolutions, HTTP results, timer events, key presses and mouse moves.</p> <p>Expressions should finish quickly to keep the user experience as efficient as possible, especially on slower devices. Consider caching values when their computation requires greater resources.</p> </li> <li> <p><strong>No visible side effects</strong></p> <p>According to Angular's <a href="glossary#unidirectional-data-flow">unidirectional data flow model</a>, a template expression should not change any application state other than the value of the target property. Reading a component value should not change some other displayed value. The view should be stable throughout a single rendering pass.</p> <div class="callout is-important"> <header>Idempotent expressions reduce side effects</header> <p> An <a href="https://en.wikipedia.org/wiki/Idempotence">idempotent</a> expression is free of side effects and improves Angular's change detection performance. In Angular terms, an idempotent expression always returns <em>exactly the same thing</em> until one of its dependent values changes.</p> <p> Dependent values should not change during a single turn of the event loop. If an idempotent expression returns a string or a number, it returns the same string or number if you call it twice consecutively. If the expression returns an object, including an <code>array</code>, it returns the same object <em>reference</em> if you call it twice consecutively.</p> </div> <blockquote class="alert is-important"> <p>There is one exception to this behavior that applies to <code>*<a href="../api/common/ngforof" class="code-anchor">ngFor</a></code>. <code>*<a href="../api/common/ngforof" class="code-anchor">ngFor</a></code> has <code>trackBy</code> functionality that can deal with changing values in objects when iterating over them. See <a href="built-in-directives#ngfor-with-trackby">*ngFor with <code>trackBy</code></a> for details.</p> </blockquote> </li> </ul><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://angular.io/guide/interpolation" class="_attribution-link" target="_blank">https://angular.io/guide/interpolation</a>
  </p>
</div>
