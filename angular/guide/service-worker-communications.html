  <h1 id="service-worker-communication">Service worker communication</h1> <p>Importing <code><a href="../api/service-worker/serviceworkermodule" class="code-anchor">ServiceWorkerModule</a></code> into your <code>AppModule</code> doesn't just register the service worker, it also provides a few services you can use to interact with the service worker and control the caching of your application.</p> <h4 id="prerequisites">Prerequisites</h4> <p>A basic understanding of the following:</p> <ul> <li>
<a href="service-worker-getting-started">Getting Started with Service Workers</a>.</li> </ul> <h2 id="swupdate-service">
<code><a href="../api/service-worker/swupdate" class="code-anchor">SwUpdate</a></code> service</h2> <p>The <code><a href="../api/service-worker/swupdate" class="code-anchor">SwUpdate</a></code> service gives you access to events that indicate when the service worker discovers an available update for your application or when it activates such an update—meaning it is now serving content from that update to your application.</p> <p>The <code><a href="../api/service-worker/swupdate" class="code-anchor">SwUpdate</a></code> service supports four separate operations:</p> <ul> <li>Getting notified of <em>available</em> updates. These are new versions of the application to be loaded if the page is refreshed.</li> <li>Getting notified of update <em>activation</em>. This is when the service worker starts serving a new version of the application immediately.</li> <li>Asking the service worker to check the server for new updates.</li> <li>Asking the service worker to activate the latest version of the application for the current tab.</li> </ul> <h3 id="available-and-activated-updates">Available and activated updates</h3> <p>The two update events, <code>available</code> and <code>activated</code>, are <code>Observable</code> properties of <code><a href="../api/service-worker/swupdate" class="code-anchor">SwUpdate</a></code>:</p> <pre header="log-update.service.ts" data-language="typescript">@Injectable()
export class LogUpdateService {

  constructor(updates: SwUpdate) {
    updates.available.subscribe(event =&gt; {
      console.log('current version is', event.current);
      console.log('available version is', event.available);
    });
    updates.activated.subscribe(event =&gt; {
      console.log('old version was', event.previous);
      console.log('new version is', event.current);
    });
  }
}</pre> <p>Use these events to notify the user of a pending update or to refresh their pages when the code they are running is out of date.</p> <h3 id="checking-for-updates">Checking for updates</h3> <p>It's possible to ask the service worker to check if any updates have been deployed to the server. The service worker checks for updates during initialization and on each navigation request—that is, when the user navigates from a different address to your application. However, you might choose to manually check for updates if you have a site that changes frequently or want updates to happen on a schedule.</p> <p>Do this with the <code>checkForUpdate()</code> method:</p> <pre header="check-for-update.service.ts" data-language="typescript">import { ApplicationRef, Injectable } from '@angular/core';
import { SwUpdate } from '@angular/service-worker';
import { concat, interval } from 'rxjs';
import { first } from 'rxjs/operators';

@Injectable()
export class CheckForUpdateService {

  constructor(appRef: ApplicationRef, updates: SwUpdate) {
    // Allow the app to stabilize first, before starting
    // polling for updates with `interval()`.
    const appIsStable$ = appRef.isStable.pipe(first(isStable =&gt; isStable === true));
    const everySixHours$ = interval(6 * 60 * 60 * 1000);
    const everySixHoursOnceAppIsStable$ = concat(appIsStable$, everySixHours$);

    everySixHoursOnceAppIsStable$.subscribe(() =&gt; updates.checkForUpdate());
  }
}</pre> <p>This method returns a <code>Promise&lt;boolean&gt;</code> which indicates if an update is available for activation. The check might fail, which will cause a rejection of the <code>Promise</code>.</p> <blockquote class="alert is-important"> <p>In order to avoid negatively affecting the initial rendering of the page, <code><a href="../api/service-worker/serviceworkermodule" class="code-anchor">ServiceWorkerModule</a></code> waits for up to 30 seconds by default for the application to stabilize, before registering the ServiceWorker script. Constantly polling for updates, for example, with <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval">setInterval()</a> or RxJS' <a href="https://rxjs.dev/api/index/function/interval">interval()</a>, prevents the application from stabilizing and the ServiceWorker script is not registered with the browser until the 30 seconds upper limit is reached.</p> <p>Note that this is true for any kind of polling done by your application. Check the <a href="../api/core/applicationref#isStable">isStable</a> documentation for more information.</p> <p>Avoid that delay by waiting for the application to stabilize first, before starting to poll for updates, as shown in the preceding example. Alternatively, you might want to define a different <a href="../api/service-worker/swregistrationoptions#registrationStrategy">registration strategy</a> for the ServiceWorker.</p> </blockquote> <h3 id="forcing-update-activation">Forcing update activation</h3> <p>If the current tab needs to be updated to the latest application version immediately, it can ask to do so with the <code>activateUpdate()</code> method:</p> <pre header="prompt-update.service.ts" data-language="typescript">@Injectable()
export class PromptUpdateService {

  constructor(updates: SwUpdate) {
    updates.available.subscribe(event =&gt; {
      if (promptUser(event)) {
        updates.activateUpdate().then(() =&gt; document.location.reload());
      }
    });
  }
}</pre> <blockquote class="alert is-important"> <p>Calling <code>activateUpdate()</code> without reloading the page could break lazy-loading in a currently running app, especially if the lazy-loaded chunks use filenames with hashes, which change every version. Therefore, it is recommended to reload the page once the promise returned by <code>activateUpdate()</code> is resolved.</p> </blockquote> <h3 id="handling-an-unrecoverable-state">Handling an unrecoverable state</h3> <p>In some cases, the version of the application used by the service worker to serve a client might be in a broken state that cannot be recovered from without a full page reload.</p> <p>For example, imagine the following scenario:</p> <ul> <li>A user opens the application for the first time and the service worker caches the latest version of the application. Assume the application's cached assets include <code>index.html</code>, <code>main.&lt;main-hash-1&gt;.js</code> and <code>lazy-chunk.&lt;lazy-hash-1&gt;.js</code>.</li> <li>The user closes the application and does not open it for a while.</li> <li>After some time, a new version of the application is deployed to the server. This newer version includes the files <code>index.html</code>, <code>main.&lt;main-hash-2&gt;.js</code> and <code>lazy-chunk.&lt;lazy-hash-2&gt;.js</code> (note that the hashes are different now, because the content of the files changed). The old version is no longer available on the server.</li> <li>In the meantime, the user's browser decides to evict <code>lazy-chunk.&lt;lazy-hash-1&gt;.js</code> from its cache. Browsers might decide to evict specific (or all) resources from a cache in order to reclaim disk space.</li> <li>The user opens the application again. The service worker serves the latest version known to it at this point, namely the old version (<code>index.html</code> and <code>main.&lt;main-hash-1&gt;.js</code>).</li> <li>At some later point, the application requests the lazy bundle, <code>lazy-chunk.&lt;lazy-hash-1&gt;.js</code>.</li> <li>The service worker is unable to find the asset in the cache (remember that the browser evicted it). Nor is it able to retrieve it from the server (because the server now only has <code>lazy-chunk.&lt;lazy-hash-2&gt;.js</code> from the newer version).</li> </ul> <p>In the preceding scenario, the service worker is not able to serve an asset that would normally be cached. That particular application version is broken and there is no way to fix the state of the client without reloading the page. In such cases, the service worker notifies the client by sending an <code><a href="../api/service-worker/unrecoverablestateevent" class="code-anchor">UnrecoverableStateEvent</a></code> event. Subscribe to <code><a href="../api/service-worker/swupdate" class="code-anchor">SwUpdate</a>#unrecoverable</code> to be notified and handle these errors.</p> <pre header="handle-unrecoverable-state.service.ts" data-language="typescript">@Injectable()
export class HandleUnrecoverableStateService {
  constructor(updates: SwUpdate) {
    updates.unrecoverable.subscribe(event =&gt; {
      notifyUser(
        'An error occurred that we cannot recover from:\n' +
        event.reason +
        '\n\nPlease reload the page.'
      );
    });
  }
}</pre> <h2 id="more-on-angular-service-workers">More on Angular service workers</h2> <p>You might also be interested in the following:</p> <ul> <li>
<a href="service-worker-notifications">Service Worker Notifications</a>.</li> </ul><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://angular.io/guide/service-worker-communications" class="_attribution-link" target="_blank">https://angular.io/guide/service-worker-communications</a>
  </p>
</div>
