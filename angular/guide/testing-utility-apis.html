  <h1 id="testing-utility-apis">Testing Utility APIs</h1> <p>This page describes the most useful Angular testing features.</p> <p>The Angular testing utilities include the <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code>, the <code><a href="../api/core/testing/componentfixture" class="code-anchor">ComponentFixture</a></code>, and a handful of functions that control the test environment. The <a href="testing-utility-apis#testbed-api-summary"><em>TestBed</em></a> and <a href="testing-utility-apis#component-fixture-api-summary"><em>ComponentFixture</em></a> classes are covered separately.</p> <p>Here's a summary of the stand-alone functions, in order of likely utility:</p> <table> <tbody>
<tr> <th> Function </th> <th> Description </th> </tr> <tr> <td style="vertical-align: top"> <code><a href="../api/core/testing/waitforasync" class="code-anchor">waitForAsync</a></code> </td> <td> <p> Runs the body of a test (<code>it</code>) or setup (<code>beforeEach</code>) function within a special <em>async test zone</em>. See <a href="testing-components-scenarios#waitForAsync">waitForAsync</a>.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code><a href="../api/core/testing/fakeasync" class="code-anchor">fakeAsync</a></code> </td> <td> <p> Runs the body of a test (<code>it</code>) within a special <em>fakeAsync test zone</em>, enabling a linear control flow coding style. See <a href="testing-components-scenarios#fake-async">fakeAsync</a>.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code><a href="../api/core/testing/tick" class="code-anchor">tick</a></code> </td> <td> <p> Simulates the passage of time and the completion of pending asynchronous activities by flushing both <em>timer</em> and <em>micro-task</em> queues within the <em>fakeAsync test zone</em>.</p> <blockquote class="alert is-helpful"> <p> The curious, dedicated reader might enjoy this lengthy blog post, <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">"<em>Tasks, microtasks, queues and schedules</em>"</a>.</p> </blockquote> <p> Accepts an optional argument that moves the virtual clock forward by the specified number of milliseconds, clearing asynchronous activities scheduled within that timeframe. See <a href="testing-components-scenarios#tick">tick</a>.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>inject</code> </td> <td> <p> Injects one or more services from the current <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> injector into a test function. It cannot inject a service provided by the component itself. See discussion of the <a href="testing-components-scenarios#get-injected-services">debugElement.injector</a>.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code><a href="../api/core/testing/discardperiodictasks" class="code-anchor">discardPeriodicTasks</a></code> </td> <td> <p> When a <code><a href="../api/core/testing/fakeasync" class="code-anchor">fakeAsync</a>()</code> test ends with pending timer event <em>tasks</em> (queued <code>setTimeOut</code> and <code>setInterval</code> callbacks), the test fails with a clear error message.</p> <p> In general, a test should end with no queued tasks. When pending timer tasks are expected, call <code><a href="../api/core/testing/discardperiodictasks" class="code-anchor">discardPeriodicTasks</a></code> to flush the <em>task</em> queue and avoid the error.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code><a href="../api/core/testing/flushmicrotasks" class="code-anchor">flushMicrotasks</a></code> </td> <td> <p> When a <code><a href="../api/core/testing/fakeasync" class="code-anchor">fakeAsync</a>()</code> test ends with pending <em>micro-tasks</em> such as unresolved promises, the test fails with a clear error message.</p> <p> In general, a test should wait for micro-tasks to finish. When pending microtasks are expected, call <code><a href="../api/core/testing/flushmicrotasks" class="code-anchor">flushMicrotasks</a></code> to flush the <em>micro-task</em> queue and avoid the error.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code><a href="../api/core/testing/componentfixtureautodetect" class="code-anchor">ComponentFixtureAutoDetect</a></code> </td> <td> <p> A provider token for a service that turns on <a href="testing-components-scenarios#automatic-change-detection">automatic change detection</a>.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code><a href="../api/core/testing/gettestbed" class="code-anchor">getTestBed</a></code> </td> <td> <p> Gets the current instance of the <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code>. Usually unnecessary because the static class methods of the <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> class are typically sufficient. The <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> instance exposes a few rarely used members that are not available as static methods.</p> </td> </tr> </tbody>
</table>  <h2 id="testbed-class-summary">
<code>TestBed</code> class summary</h2> <p>The <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> class is one of the principal Angular testing utilities. Its API is quite large and can be overwhelming until you've explored it, a little at a time. Read the early part of this guide first to get the basics before trying to absorb the full API.</p> <p>The module definition passed to <code>configureTestingModule</code> is a subset of the <code>@<a href="../api/core/ngmodule" class="code-anchor">NgModule</a></code> metadata properties.</p> <pre data-language="javascript">type TestModuleMetadata = {
    providers?: any[];
    declarations?: any[];
    imports?: any[];
    schemas?: Array&lt;SchemaMetadata | any[]&gt;;
  };</pre>  <p>Each override method takes a <code><a href="../api/core/testing/metadataoverride" class="code-anchor">MetadataOverride</a>&lt;T&gt;</code> where <code>T</code> is the kind of metadata appropriate to the method, that is, the parameter of an <code>@<a href="../api/core/ngmodule" class="code-anchor">NgModule</a></code>, <code>@<a href="../api/core/component" class="code-anchor">Component</a></code>, <code>@<a href="../api/core/directive" class="code-anchor">Directive</a></code>, or <code>@<a href="../api/core/pipe" class="code-anchor">Pipe</a></code>.</p> <pre data-language="javascript">type MetadataOverride&lt;T&gt; = {
    add?: Partial&lt;T&gt;;
    remove?: Partial&lt;T&gt;;
    set?: Partial&lt;T&gt;;
  };</pre>   <p>The <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> API consists of static class methods that either update or reference a <em>global</em> instance of the <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code>.</p> <p>Internally, all static methods cover methods of the current runtime <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> instance, which is also returned by the <code><a href="../api/core/testing/gettestbed" class="code-anchor">getTestBed</a>()</code> function.</p> <p>Call <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> methods <em>within</em> a <code>beforeEach()</code> to ensure a fresh start before each individual test.</p> <p>Here are the most important static methods, in order of likely utility.</p> <table> <tbody>
<tr> <th> Methods </th> <th> Description </th> </tr> <tr> <td style="vertical-align: top"> <code>configureTestingModule</code> </td> <td> <p> The testing shims (<code>karma-test-shim</code>, <code>browser-test-shim</code>) establish the <a href="testing">initial test environment</a> and a default testing module. The default testing module is configured with basic declaratives and some Angular service substitutes that every tester needs.</p> <p> Call <code>configureTestingModule</code> to refine the testing module configuration for a particular set of tests by adding and removing imports, declarations (of components, directives, and pipes), and providers.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>compileComponents</code> </td> <td> <p> Compile the testing module asynchronously after you've finished configuring it. You <strong>must</strong> call this method if <em>any</em> of the testing module components have a <code>templateUrl</code> or <code>styleUrls</code> because fetching component template and style files is necessarily asynchronous. See <a href="testing-components-scenarios#compile-components">compileComponents</a>.</p> <p> After calling <code>compileComponents</code>, the <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> configuration is frozen for the duration of the current spec.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>createComponent</code> </td> <td> <p> Create an instance of a component of type <code>T</code> based on the current <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> configuration. After calling <code>compileComponent</code>, the <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> configuration is frozen for the duration of the current spec.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>overrideModule</code> </td> <td> <p> Replace metadata for the given <code><a href="../api/core/ngmodule" class="code-anchor">NgModule</a></code>. Recall that modules can import other modules. The <code>overrideModule</code> method can reach deeply into the current testing module to modify one of these inner modules.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>overrideComponent</code> </td> <td> <p> Replace metadata for the given component class, which could be nested deeply within an inner module.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>overrideDirective</code> </td> <td> <p> Replace metadata for the given directive class, which could be nested deeply within an inner module.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>overridePipe</code> </td> <td> <p> Replace metadata for the given pipe class, which could be nested deeply within an inner module.</p> </td> </tr> <tr> <td style="vertical-align: top">  <code>inject</code> </td> <td> <p> Retrieve a service from the current <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> injector.</p> <p> The <code>inject</code> function is often adequate for this purpose. But <code>inject</code> throws an error if it can't provide the service.</p> <p> What if the service is optional?</p> <p> The <code>TestBed.inject()</code> method takes an optional second parameter, the object to return if Angular can't find the provider (<code>null</code> in this example):</p> 
<pre header="app/demo/demo.testbed.spec.ts" data-language="typescript">expect(TestBed.inject(NotProvided, null)).toBeNull();</pre> <p> After calling <code>TestBed.inject</code>, the <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> configuration is frozen for the duration of the current spec.</p> </td> </tr> <tr> <td style="vertical-align: top">  <code>initTestEnvironment</code> </td> <td> <p> Initialize the testing environment for the entire test run.</p> <p> The testing shims (<code>karma-test-shim</code>, <code>browser-test-shim</code>) call it for you so there is rarely a reason for you to call it yourself.</p> <p> Call this method <em>exactly once</em>. To change this default in the middle of a test run, call <code>resetTestEnvironment</code> first.</p> <p> Specify the Angular compiler factory, a <code><a href="../api/core/platformref" class="code-anchor">PlatformRef</a></code>, and a default Angular testing module. Alternatives for non-browser platforms are available in the general form <code>@angular/platform-&lt;platform_name&gt;/testing/&lt;platform_name&gt;</code>.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>resetTestEnvironment</code> </td> <td> <p> Reset the initial test environment, including the default testing module.</p> </td> </tr> </tbody>
</table> <p>A few of the <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> instance methods are not covered by static <code><a href="../api/core/testing/testbed" class="code-anchor">TestBed</a></code> <em>class</em> methods. These are rarely needed.</p>  <h2 id="the-componentfixture">The <code>ComponentFixture</code>
</h2> <p>The <code>TestBed.createComponent&lt;T&gt;</code> creates an instance of the component <code>T</code> and returns a strongly typed <code><a href="../api/core/testing/componentfixture" class="code-anchor">ComponentFixture</a></code> for that component.</p> <p>The <code><a href="../api/core/testing/componentfixture" class="code-anchor">ComponentFixture</a></code> properties and methods provide access to the component, its DOM representation, and aspects of its Angular environment.</p>  <h3 id="componentfixture-properties">
<code>ComponentFixture</code> properties</h3> <p>Here are the most important properties for testers, in order of likely utility.</p> <table> <tbody>
<tr> <th> Properties </th> <th> Description </th> </tr> <tr> <td style="vertical-align: top"> <code>componentInstance</code> </td> <td> <p> The instance of the component class created by <code>TestBed.createComponent</code>.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>debugElement</code> </td> <td> <p> The <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code> associated with the root element of the component.</p> <p> The <code>debugElement</code> provides insight into the component and its DOM element during test and debugging. It's a critical property for testers. The most interesting members are covered <a href="testing-utility-apis#debug-element-details">below</a>.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>nativeElement</code> </td> <td> <p> The native DOM element at the root of the component.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>changeDetectorRef</code> </td> <td> <p> The <code><a href="../api/core/changedetectorref" class="code-anchor">ChangeDetectorRef</a></code> for the component.</p> <p> The <code><a href="../api/core/changedetectorref" class="code-anchor">ChangeDetectorRef</a></code> is most valuable when testing a component that has the <code><a href="../api/core/changedetectionstrategy#OnPush" class="code-anchor">ChangeDetectionStrategy.OnPush</a></code> method or the component's change detection is under your programmatic control.</p> </td> </tr> </tbody>
</table>  <h3 id="componentfixture-methods">
<code>ComponentFixture</code> methods</h3> <p>The <em>fixture</em> methods cause Angular to perform certain tasks on the component tree. Call these method to trigger Angular behavior in response to simulated user action.</p> <p>Here are the most useful methods for testers.</p> <table> <tbody>
<tr> <th> Methods </th> <th> Description </th> </tr> <tr> <td style="vertical-align: top"> <code>detectChanges</code> </td> <td> <p> Trigger a change detection cycle for the component.</p> <p> Call it to initialize the component (it calls <code>ngOnInit</code>) and after your test code, change the component's data bound property values. Angular can't see that you've changed <code>personComponent.name</code> and won't update the <code>name</code> binding until you call <code>detectChanges</code>.</p> <p> Runs <code>checkNoChanges</code> afterwards to confirm that there are no circular updates unless called as <code>detectChanges(false)</code>;</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>autoDetectChanges</code> </td> <td> <p> Set this to <code>true</code> when you want the fixture to detect changes automatically.</p> <p> When autodetect is <code>true</code>, the test fixture calls <code>detectChanges</code> immediately after creating the component. Then it listens for pertinent zone events and calls <code>detectChanges</code> accordingly. When your test code modifies component property values directly, you probably still have to call <code>fixture.detectChanges</code> to trigger data binding updates.</p> <p> The default is <code>false</code>. Testers who prefer fine control over test behavior tend to keep it <code>false</code>.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>checkNoChanges</code> </td> <td> <p> Do a change detection run to make sure there are no pending changes. Throws an exceptions if there are.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>isStable</code> </td> <td> <p> If the fixture is currently <em>stable</em>, returns <code>true</code>. If there are async tasks that have not completed, returns <code>false</code>.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>whenStable</code> </td> <td> <p> Returns a promise that resolves when the fixture is stable.</p> <p> To resume testing after completion of asynchronous activity or asynchronous change detection, hook that promise. See <a href="testing-components-scenarios#when-stable">whenStable</a>.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>destroy</code> </td> <td> <p> Trigger component destruction.</p> </td> </tr> </tbody>
</table>  <h4 id="debugelement"><em>DebugElement</em></h4> <p>The <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code> provides crucial insights into the component's DOM representation.</p> <p>From the test root component's <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code> returned by <code>fixture.debugElement</code>, you can walk (and query) the fixture's entire element and component subtrees.</p> <p>Here are the most useful <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code> members for testers, in approximate order of utility:</p> <table> <tbody>
<tr> <th> Member </th> <th> Description </th> </tr> <tr> <td style="vertical-align: top"> <code>nativeElement</code> </td> <td> <p> The corresponding DOM element in the browser (null for WebWorkers).</p> </td> </tr> <tr> <td style="vertical-align: top"> <code><a href="../api/animations/query" class="code-anchor">query</a></code> </td> <td> <p> Calling <code><a href="../api/animations/query" class="code-anchor">query</a>(predicate: <a href="../api/core/predicate" class="code-anchor">Predicate</a>&lt;<a href="../api/core/debugelement" class="code-anchor">DebugElement</a>&gt;)</code> returns the first <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code> that matches the <a href="testing-utility-apis#query-predicate">predicate</a> at any depth in the subtree.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>queryAll</code> </td> <td> <p> Calling <code>queryAll(predicate: <a href="../api/core/predicate" class="code-anchor">Predicate</a>&lt;<a href="../api/core/debugelement" class="code-anchor">DebugElement</a>&gt;)</code> returns all <code>DebugElements</code> that matches the <a href="testing-utility-apis#query-predicate">predicate</a> at any depth in subtree.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>injector</code> </td> <td> <p> The host dependency injector. For example, the root element's component instance injector.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>componentInstance</code> </td> <td> <p> The element's own component instance, if it has one.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>context</code> </td> <td> <p> An object that provides parent context for this element. Often an ancestor component instance that governs this element.</p> <p> When an element is repeated within <code>*<a href="../api/common/ngforof" class="code-anchor">ngFor</a></code>, the context is an <code><a href="../api/common/ngforof" class="code-anchor">NgForOf</a></code> whose <code>$implicit</code> property is the value of the row instance value. For example, the <code>hero</code> in <code>*<a href="../api/common/ngforof" class="code-anchor">ngFor</a>="let hero of heroes"</code>.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>children</code> </td> <td> <p> The immediate <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code> children. Walk the tree by descending through <code>children</code>.</p> <blockquote class="alert is-helpful"> <p> <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code> also has <code>childNodes</code>, a list of <code><a href="../api/core/debugnode" class="code-anchor">DebugNode</a></code> objects. <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code> derives from <code><a href="../api/core/debugnode" class="code-anchor">DebugNode</a></code> objects and there are often more nodes than elements. Testers can usually ignore plain nodes.</p> </blockquote> </td> </tr> <tr> <td style="vertical-align: top"> <code>parent</code> </td> <td> <p> The <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code> parent. Null if this is the root element.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>name</code> </td> <td> <p> The element tag name, if it is an element.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>triggerEventHandler</code> </td> <td> <p> Triggers the event by its name if there is a corresponding listener in the element's <code>listeners</code> collection. The second parameter is the <em>event object</em> expected by the handler. See <a href="testing-components-scenarios#trigger-event-handler">triggerEventHandler</a>.</p> <p> If the event lacks a listener or there's some other problem, consider calling <code>nativeElement.dispatchEvent(eventObject)</code>.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>listeners</code> </td> <td> <p> The callbacks attached to the component's <code>@<a href="../api/core/output" class="code-anchor">Output</a></code> properties and/or the element's event properties.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>providerTokens</code> </td> <td> <p> This component's injector lookup tokens. Includes the component itself plus the tokens that the component lists in its <code>providers</code> metadata.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>source</code> </td> <td> <p> Where to find this element in the source component template.</p> </td> </tr> <tr> <td style="vertical-align: top"> <code>references</code> </td> <td> <p> Dictionary of objects associated with template local variables (e.g. <code>#foo</code>), keyed by the local variable name.</p> </td> </tr> </tbody>
</table>  <p>The <code>DebugElement.query(predicate)</code> and <code>DebugElement.queryAll(predicate)</code> methods take a predicate that filters the source element's subtree for matching <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code>.</p> <p>The predicate is any method that takes a <code><a href="../api/core/debugelement" class="code-anchor">DebugElement</a></code> and returns a <em>truthy</em> value. The following example finds all <code>DebugElements</code> with a reference to a template local variable named "content":</p> <pre header="app/demo/demo.testbed.spec.ts" data-language="typescript">// Filter for DebugElements with a #content reference
const contentRefs = el.queryAll( de =&gt; de.references['content']);</pre> <p>The Angular <code><a href="../api/platform-browser/by" class="code-anchor">By</a></code> class has three static methods for common predicates:</p> <ul> <li>
<code>By.all</code> - return all elements.</li> <li>
<code>By.css(selector)</code> - return elements with matching CSS selectors.</li> <li>
<code>By.directive(directive)</code> - return elements that Angular matched to an instance of the directive class.</li> </ul> <pre header="app/hero/hero-list.component.spec.ts" data-language="typescript">// Can find DebugElement either by css selector or by directive
const h2 = fixture.debugElement.query(By.css('h2'));
const directive = fixture.debugElement.query(By.directive(HighlightDirective));</pre><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://angular.io/guide/testing-utility-apis" class="_attribution-link" target="_blank">https://angular.io/guide/testing-utility-apis</a>
  </p>
</div>
