<h1>Deno.ReaderSync</h1>
<pre data-language="typescript"><span>interface</span> ReaderSync {<div>readSync(<span>p<span>: <span>Uint8Array</span></span></span>)<span>: <span><span>number</span><span> | </span><span>null</span>;</span></span>
</div>}</pre>
<div><div>
<h2 id="Methods">Methods</h2>
<div id="readSync"><div>
<div><div>readSync(<span>p<span>: <span>Uint8Array</span></span></span>)<span>: <span><span>number</span><span> | </span><span>null</span></span></span>
</div></div>
<div><div>
<p>Reads up to <code>p.byteLength</code> bytes into <code>p</code>. It resolves to the number of bytes read (<code>0</code> &lt; <code>n</code> &lt;= <code>p.byteLength</code>) and rejects if any error encountered. Even if <code>readSync()</code> returns <code>n</code> &lt; <code>p.byteLength</code>, it may use all of <code>p</code> as scratch space during the call. If some data is available but not <code>p.byteLength</code> bytes, <code>readSync()</code> conventionally returns what is available instead of waiting for more.</p> <p>When <code>readSync()</code> encounters end-of-file condition, it returns EOF (<code>null</code>).</p> <p>When <code>readSync()</code> encounters an error, it throws with an error.</p> <p>Callers should always process the <code>n</code> &gt; <code>0</code> bytes returned before considering the EOF (<code>null</code>). Doing so correctly handles I/O errors that happen after reading some bytes and also both of the allowed EOF behaviors.</p> <p>Implementations should not retain a reference to <code>p</code>.</p> <p>Use <code>iterateReaderSync()</code> from from <a href="https://deno.land/std/streams/conversion.ts">https://deno.land/std/streams/conversion.ts</a> to turn a ReaderSync into an Iterator.</p> </div></div>
</div></div>
</div></div><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://doc.deno.land/deno/stable/~/Deno.ReaderSync" class="_attribution-link" target="_blank">https://doc.deno.land/deno/stable/~/Deno.ReaderSync</a>
  </p>
</div>
