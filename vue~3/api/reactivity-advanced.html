<h1 id="reactivity-api-advanced" tabindex="-1">Reactivity API: Advanced </h1>
<h2 id="shallowref" tabindex="-1">shallowRef() </h2>
<p>Shallow version of <a href="reactivity-core#ref"><code>ref()</code></a>.</p>
<ul>
<li>
<p><strong>Type</strong></p>
<div class="language-ts"><pre data-language="javascript">function shallowRef&lt;T&gt;(value: T): ShallowRef&lt;T&gt;

interface ShallowRef&lt;T&gt; {
  value: T
}</pre></div>
</li>
<li>
<p><strong>Details</strong></p>
<p>Unlike <code>ref()</code>, the inner value of a shallow ref is stored and exposed as-is, and will not be made deeply reactive. Only the <code>.value</code> access is reactive.</p>
<p><code>shallowRef()</code> is typically used for performance optimizations of large data structures, or integration with external state management systems.</p>
</li>
<li>
<p><strong>Example</strong></p>
<div class="language-js"><pre data-language="javascript">const state = shallowRef({ count: 1 })

// does NOT trigger change
state.value.count = 2

// does trigger change
state.value = { count: 2 }</pre></div>
</li>
<li>
<p><strong>See also:</strong></p>
<ul>
<li><a href="../guide/best-practices/performance#reduce-reactivity-overhead-for-large-immutable-structures">Guide - Reduce Reactivity Overhead for Large Immutable Structures</a></li>
<li><a href="../guide/extras/reactivity-in-depth#integration-with-external-state-systems">Guide - Integration with External State Systems</a></li>
</ul>
</li>
</ul>
<h2 id="triggerref" tabindex="-1">triggerRef() </h2>
<p>Force trigger effects that depends on a <a href="#shallowref">shallow ref</a>. This is typically used after making deep mutations to the inner value of a shallow ref.</p>
<ul>
<li>
<p><strong>Type</strong></p>
<div class="language-ts"><pre data-language="javascript">function triggerRef(ref: ShallowRef): void</pre></div>
</li>
<li>
<p><strong>Example</strong></p>
<div class="language-js"><pre data-language="javascript">const shallow = shallowRef({
  greet: 'Hello, world'
})

// Logs "Hello, world" once for the first run-through
watchEffect(() =&gt; {
  console.log(shallow.value.greet)
})

// This won't trigger the effect because the ref is shallow
shallow.value.greet = 'Hello, universe'

// Logs "Hello, universe"
triggerRef(shallow)</pre></div>
</li>
</ul>
<h2 id="customref" tabindex="-1">customRef() </h2>
<p>Creates a customized ref with explicit control over its dependency tracking and updates triggering.</p>
<ul>
<li>
<p><strong>Type</strong></p>
<div class="language-ts"><pre data-language="javascript">function customRef&lt;T&gt;(factory: CustomRefFactory&lt;T&gt;): Ref&lt;T&gt;

type CustomRefFactory&lt;T&gt; = (
  track: () =&gt; void,
  trigger: () =&gt; void
) =&gt; {
  get: () =&gt; T
  set: (value: T) =&gt; void
}</pre></div>
</li>
<li>
<p><strong>Details</strong></p>
<p><code>customRef()</code> expects a factory function, which receives <code>track</code> and <code>trigger</code> functions as arguments and should return an object with <code>get</code> and <code>set</code> methods.</p>
<p>In general, <code>track()</code> should be called inside <code>get()</code>, and <code>trigger()</code> should be called inside <code>set()</code>. However, you have full control over when they should be called, or whether they should be called at all.</p>
</li>
<li>
<p><strong>Example</strong></p>
<p>Creating a debounced ref that only updates the value after a certain timeout after the latest set call:</p>
<div class="language-js"><pre data-language="javascript">import { customRef } from 'vue'

export function useDebouncedRef(value, delay = 200) {
  let timeout
  return customRef((track, trigger) =&gt; {
    return {
      get() {
        track()
        return value
      },
      set(newValue) {
        clearTimeout(timeout)
        timeout = setTimeout(() =&gt; {
          value = newValue
          trigger()
        }, delay)
      }
    }
  })
}</pre></div>
<p>Usage in component:</p>
<div class="language-vue"><pre data-language="javascript">&lt;script setup&gt;
import { useDebouncedRef } from './debouncedRef'
const text = useDebouncedRef('hello')
&lt;/script&gt;

&lt;template&gt;
  &lt;input v-model="text" /&gt;
&lt;/template&gt;</pre></div>
<p><a href="https://sfc.vuejs.org/#eyJBcHAudnVlIjoiPHNjcmlwdCBzZXR1cD5cbmltcG9ydCB7IHVzZURlYm91bmNlZFJlZiB9IGZyb20gJy4vZGVib3VuY2VkUmVmLmpzJ1xuY29uc3QgdGV4dCA9IHVzZURlYm91bmNlZFJlZignaGVsbG8nLCAxMDAwKVxuPC9zY3JpcHQ+XG5cbjx0ZW1wbGF0ZT5cbiAgPHA+XG4gICAgVGhpcyB0ZXh0IG9ubHkgdXBkYXRlcyAxIHNlY29uZCBhZnRlciB5b3UndmUgc3RvcHBlZCB0eXBpbmc6XG4gIDwvcD5cbiAgPHA+e3sgdGV4dCB9fTwvcD5cbiAgPGlucHV0IHYtbW9kZWw9XCJ0ZXh0XCIgLz5cbjwvdGVtcGxhdGU+IiwiaW1wb3J0LW1hcC5qc29uIjoie1xuICBcImltcG9ydHNcIjoge1xuICAgIFwidnVlXCI6IFwiaHR0cHM6Ly9zZmMudnVlanMub3JnL3Z1ZS5ydW50aW1lLmVzbS1icm93c2VyLmpzXCJcbiAgfVxufSIsImRlYm91bmNlZFJlZi5qcyI6ImltcG9ydCB7IGN1c3RvbVJlZiB9IGZyb20gJ3Z1ZSdcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZURlYm91bmNlZFJlZih2YWx1ZSwgZGVsYXkgPSAyMDApIHtcbiAgbGV0IHRpbWVvdXRcbiAgcmV0dXJuIGN1c3RvbVJlZigodHJhY2ssIHRyaWdnZXIpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0KCkge1xuICAgICAgICB0cmFjaygpXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgfSxcbiAgICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dClcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHZhbHVlID0gbmV3VmFsdWVcbiAgICAgICAgICB0cmlnZ2VyKClcbiAgICAgICAgfSwgZGVsYXkpXG4gICAgICB9XG4gICAgfVxuICB9KVxufSJ9" target="_blank" rel="noopener noreferrer">Try it in the Playground</a></p>
</li>
</ul>
<h2 id="shallowreactive" tabindex="-1">shallowReactive() </h2>
<p>Shallow version of <a href="reactivity-core#reactive"><code>reactive()</code></a>.</p>
<ul>
<li>
<p><strong>Type</strong></p>
<div class="language-ts"><pre data-language="javascript">function shallowReactive&lt;T extends object&gt;(target: T): T</pre></div>
</li>
<li>
<p><strong>Details</strong></p>
<p>Unlike <code>reactive()</code>, there is no deep conversion: only root-level properties are reactive for a shallow reactive object. Property values are stored and exposed as-is - this also means properties with ref values will <strong>not</strong> be automatically unwrapped.</p>
<div class="warning custom-block">
<strong class="custom-block-title">Use with Caution</strong><p>Shallow data structures should only be used for root level state in a component. Avoid nesting it inside a deep reactive object as it creates a tree with inconsistent reactivity behavior which can be difficult to understand and debug.</p>
</div>
</li>
<li>
<p><strong>Example</strong></p>
<div class="language-js"><pre data-language="javascript">const state = shallowReactive({
  foo: 1,
  nested: {
    bar: 2
  }
})

// mutating state's own properties is reactive
state.foo++

// ...but does not convert nested objects
isReactive(state.nested) // false

// NOT reactive
state.nested.bar++</pre></div>
</li>
</ul>
<h2 id="shallowreadonly" tabindex="-1">shallowReadonly() </h2>
<p>Shallow version of <a href="reactivity-core#readonly"><code>readonly()</code></a>.</p>
<ul>
<li>
<p><strong>Type</strong></p>
<div class="language-ts"><pre data-language="javascript">function shallowReadonly&lt;T extends object&gt;(target: T): Readonly&lt;T&gt;</pre></div>
</li>
<li>
<p><strong>Details</strong></p>
<p>Unlike <code>readonly()</code>, there is no deep conversion: only root-level properties are made readonly. Property values are stored and exposed as-is - this also means properties with ref values will <strong>not</strong> be automatically unwrapped.</p>
<div class="warning custom-block">
<strong class="custom-block-title">Use with Caution</strong><p>Shallow data structures should only be used for root level state in a component. Avoid nesting it inside a deep reactive object as it creates a tree with inconsistent reactivity behavior which can be difficult to understand and debug.</p>
</div>
</li>
<li>
<p><strong>Example</strong></p>
<div class="language-js"><pre data-language="javascript">const state = shallowReadonly({
  foo: 1,
  nested: {
    bar: 2
  }
})

// mutating state's own properties will fail
state.foo++

// ...but works on nested objects
isReadonly(state.nested) // false

// works
state.nested.bar++</pre></div>
</li>
</ul>
<h2 id="toraw" tabindex="-1">toRaw() </h2>
<p>Returns the raw, original object of a Vue-created proxy.</p>
<ul>
<li>
<p><strong>Type</strong></p>
<div class="language-ts"><pre data-language="javascript">function toRaw&lt;T&gt;(proxy: T): T</pre></div>
</li>
<li>
<p><strong>Details</strong></p>
<p><code>toRaw()</code> can return the original object from proxies created by <a href="reactivity-core#reactive"><code>reactive()</code></a>, <a href="reactivity-core#readonly"><code>readonly()</code></a>, <a href="#shallowreactive"><code>shallowReactive()</code></a> or <a href="#shallowreadonly"><code>shallowReadonly()</code></a>.</p>
<p>This is an escape hatch that can be used to temporarily read without incurring proxy access / tracking overhead or write without triggering changes. It is <strong>not</strong> recommended to hold a persistent reference to the original object. Use with caution.</p>
</li>
<li>
<p><strong>Example</strong></p>
<div class="language-js"><pre data-language="javascript">const foo = {}
const reactiveFoo = reactive(foo)

console.log(toRaw(reactiveFoo) === foo) // true</pre></div>
</li>
</ul>
<h2 id="markraw" tabindex="-1">markRaw() </h2>
<p>Marks an object so that it will never be converted to a proxy. Returns the object itself.</p>
<ul>
<li>
<p><strong>Type</strong></p>
<div class="language-ts"><pre data-language="javascript">function markRaw&lt;T extends object&gt;(value: T): T</pre></div>
</li>
<li>
<p><strong>Example</strong></p>
<div class="language-js"><pre data-language="javascript">const foo = markRaw({})
console.log(isReactive(reactive(foo))) // false

// also works when nested inside other reactive objects
const bar = reactive({ foo })
console.log(isReactive(bar.foo)) // false</pre></div>
<div class="warning custom-block">
<strong class="custom-block-title">Use with Caution</strong><p><code>markRaw()</code> and shallow APIs such as <code>shallowReactive()</code> allow you to selectively opt-out of the default deep reactive/readonly conversion and embed raw, non-proxied objects in your state graph. They can be used for various reasons:</p>
<ul>
<li><p>Some values simply should not be made reactive, for example a complex 3rd party class instance, or a Vue component object.</p></li>
<li><p>Skipping proxy conversion can provide performance improvements when rendering large lists with immutable data sources.</p></li>
</ul>
<p>They are considered advanced because the raw opt-out is only at the root level, so if you set a nested, non-marked raw object into a reactive object and then access it again, you get the proxied version back. This can lead to <strong>identity hazards</strong> - i.e. performing an operation that relies on object identity but using both the raw and the proxied version of the same object:</p>
<div class="language-js"><pre data-language="javascript">const foo = markRaw({
  nested: {}
})

const bar = reactive({
  // although `foo` is marked as raw, foo.nested is not.
  nested: foo.nested
})

console.log(foo.nested === bar.nested) // false</pre></div>
<p>Identity hazards are in general rare. However, to properly utilize these APIs while safely avoiding identity hazards requires a solid understanding of how the reactivity system works.</p>
</div>
</li>
</ul>
<h2 id="effectscope" tabindex="-1">effectScope() </h2>
<p>Creates an effect scope object which can capture the reactive effects (i.e. computed and watchers) created within it so that these effects can be disposed together. For detailed use cases of this API, please consult its corresponding <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0041-reactivity-effect-scope.md" target="_blank" rel="noopener noreferrer">RFC</a>.</p>
<ul>
<li>
<p><strong>Type</strong></p>
<div class="language-ts"><pre data-language="javascript">function effectScope(detached?: boolean): EffectScope

interface EffectScope {
  run&lt;T&gt;(fn: () =&gt; T): T | undefined // undefined if scope is inactive
  stop(): void
}</pre></div>
</li>
<li>
<p><strong>Example</strong></p>
<div class="language-js"><pre data-language="javascript">const scope = effectScope()

scope.run(() =&gt; {
  const doubled = computed(() =&gt; counter.value * 2)

  watch(doubled, () =&gt; console.log(doubled.value))

  watchEffect(() =&gt; console.log('Count: ', doubled.value))
})

// to dispose all effects in the scope
scope.stop()</pre></div>
</li>
</ul>
<h2 id="getcurrentscope" tabindex="-1">getCurrentScope() </h2>
<p>Returns the current active <a href="#effectscope">effect scope</a> if there is one.</p>
<ul><li>
<p><strong>Type</strong></p>
<div class="language-ts"><pre data-language="javascript">function getCurrentScope(): EffectScope | undefined</pre></div>
</li></ul>
<h2 id="onscopedispose" tabindex="-1">onScopeDispose() </h2>
<p>Registers a dispose callback on the current active <a href="#effectscope">effect scope</a>. The callback will be invoked when the associated effect scope is stopped.</p>
<p>This method can be used as a non-component-coupled replacement of <code>onUnmounted</code> in reusable composition functions, since each Vue component's <code>setup()</code> function is also invoked in an effect scope.</p>
<ul><li>
<p><strong>Type</strong></p>
<div class="language-ts"><pre data-language="javascript">function onScopeDispose(fn: () =&gt; void): void</pre></div>
</li></ul><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://vuejs.org/api/reactivity-advanced.html" class="_attribution-link" target="_blank">https://vuejs.org/api/reactivity-advanced.html</a>
  </p>
</div>
