 <div class="theme-default-content content__default">
<h1 id="application-api"> Application API</h1> <p>In Vue 3, APIs that globally mutate Vue's behavior are now moved to application instances created by the new <code>createApp</code> method. In addition, their effects are now scoped to that specific application's instance:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { createApp } from 'vue'

const app = createApp({})</pre> </div>
<p>Calling <code>createApp</code> returns an application instance. This instance provides an application context. The entire component tree mounted by the application instance share the same context, which provides the configurations that were previously "global" in Vue 2.x.</p> <p>In addition, since the <code>createApp</code> method returns the application instance itself, you can chain other methods after it which can be found in the following sections.</p> <h2 id="component"> component</h2> <ul>
<li>
<p><strong>Arguments:</strong></p> <ul>
<li><code>{string} name</code></li> <li><code>{Function | Object} definition (optional)</code></li>
</ul>
</li> <li>
<p><strong>Returns:</strong></p> <ul>
<li>The application instance if a <code>definition</code> argument was passed</li> <li>The component definition if a <code>definition</code> argument was not passed</li>
</ul>
</li> <li>
<p><strong>Usage:</strong></p> <p>Register or retrieve a global component. Registration also automatically sets the component's <code>name</code> with the given <code>name</code> parameter.</p>
</li> <li><p><strong>Example:</strong></p></li>
</ul> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { createApp } from 'vue'

const app = createApp({})

// register an options object
app.component('my-component', {
  /* ... */
})

// retrieve a registered component
const MyComponent = app.component('my-component')</pre> </div>
<ul><li>
<strong>See also:</strong> <a href="../guide/component-basics">Components</a>
</li></ul> <h2 id="config"> config</h2> <ul><li><strong>Usage:</strong></li></ul> <p>An object containing application configurations.</p> <ul><li><strong>Example:</strong></li></ul> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { createApp } from 'vue'
const app = createApp({})

app.config = {...}</pre> </div>
<ul><li>
<strong>See also:</strong> <a href="application-config">Application Config</a>
</li></ul> <h2 id="directive"> directive</h2> <ul>
<li>
<p><strong>Arguments:</strong></p> <ul>
<li><code>{string} name</code></li> <li><code>{Function | Object} definition (optional)</code></li>
</ul>
</li> <li>
<p><strong>Returns:</strong></p> <ul>
<li>The application instance if a <code>definition</code> argument was passed</li> <li>The directive definition if a <code>definition</code> argument was not passed</li>
</ul>
</li> <li>
<p><strong>Usage:</strong></p> <p>Register or retrieve a global directive.</p>
</li> <li><p><strong>Example:</strong></p></li>
</ul> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { createApp } from 'vue'
const app = createApp({})

// register
app.directive('my-directive', {
  // Directive has a set of lifecycle hooks:
  // called before bound element's attributes or event listeners are applied
  created() {},
  // called before bound element's parent component is mounted
  beforeMount() {},
  // called when bound element's parent component is mounted
  mounted() {},
  // called before the containing component's VNode is updated
  beforeUpdate() {},
  // called after the containing component's VNode and the VNodes of its
  // children have updated
  updated() {},
  // called before the bound element's parent component is unmounted
  beforeUnmount() {},
  // called when the bound element's parent component is unmounted
  unmounted() {}
})

// register (function directive)
app.directive('my-directive', () =&gt; {
  // this will be called as `mounted` and `updated`
})

// getter, return the directive definition if registered
const myDirective = app.directive('my-directive')</pre> </div>
<p>Directive hooks are passed these arguments:</p> <h4 id="el"> el</h4> <p>The element the directive is bound to. This can be used to directly manipulate the DOM.</p> <h4 id="binding"> binding</h4> <p>An object containing the following properties.</p> <ul>
<li>
<code>instance</code>: The instance of the component where directive is used.</li> <li>
<code>value</code>: The value passed to the directive. For example in <code>v-my-directive="1 + 1"</code>, the value would be <code>2</code>.</li> <li>
<code>oldValue</code>: The previous value, only available in <code>beforeUpdate</code> and <code>updated</code>. It is available whether or not the value has changed.</li> <li>
<code>arg</code>: The argument passed to the directive, if any. For example in <code>v-my-directive:foo</code>, the arg would be <code>"foo"</code>.</li> <li>
<code>modifiers</code>: An object containing modifiers, if any. For example in <code>v-my-directive.foo.bar</code>, the modifiers object would be <code>{ foo: true, bar: true }</code>.</li> <li>
<code>dir</code>: an object, passed as a parameter when directive is registered. For example, in the directive</li>
</ul> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">app.directive('focus', {
  mounted(el) {
    el.focus()
  }
})</pre> </div>
<p><code>dir</code> would be the following object:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">{
  mounted(el) {
    el.focus()
  }
}</pre> </div>
<h4 id="vnode"> vnode</h4> <p>A blueprint of the real DOM element received as el argument above.</p> <h4 id="prevnode"> prevNode</h4> <p>The previous virtual node, only available in the <code>beforeUpdate</code> and <code>updated</code> hooks.</p> <div class="custom-block tip">
<strong class="custom-block-title">Note</strong> <p>Apart from <code>el</code>, you should treat these arguments as read-only and never modify them. If you need to share information across hooks, it is recommended to do so through element's <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset" target="_blank" rel="noopener noreferrer">dataset<span> <span class="sr-only">(opens new window)</span></span></a>.</p>
</div> <ul><li>
<strong>See also:</strong> <a href="../guide/custom-directive">Custom Directives</a>
</li></ul> <h2 id="mixin"> mixin</h2> <ul>
<li>
<p><strong>Arguments:</strong></p> <ul><li><code>{Object} mixin</code></li></ul>
</li> <li>
<p><strong>Returns:</strong></p> <ul><li>The application instance</li></ul>
</li> <li>
<p><strong>Usage:</strong></p> <p>Apply a mixin in the whole application scope. Once registered they can be used in the template of any component within the current application. This can be used by plugin authors to inject custom behavior into components. <strong>Not recommended in application code</strong>.</p>
</li> <li><p><strong>See also:</strong> <a href="../guide/mixins#global-mixin">Global Mixin</a></p></li>
</ul> <h2 id="mount"> mount</h2> <ul>
<li>
<p><strong>Arguments:</strong></p> <ul>
<li><code>{Element | string} rootContainer</code></li> <li><code>{boolean} isHydrate (optional)</code></li>
</ul>
</li> <li>
<p><strong>Returns:</strong></p> <ul><li>The root component instance</li></ul>
</li> <li>
<p><strong>Usage:</strong></p> <p>The <code>innerHTML</code> of the provided DOM element will be replaced with the rendered template of the application root component.</p>
</li> <li><p><strong>Example:</strong></p></li>
</ul> <div class="language-html line-numbers-mode">
<pre class="language-html" data-language="javascript">&lt;body&gt;
  &lt;div id="my-app"&gt;&lt;/div&gt;
&lt;/body&gt;</pre> </div>
<div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { createApp } from 'vue'

const app = createApp({})
// do some necessary preparations
app.mount('#my-app')</pre> </div>
<ul><li>
<strong>See also:</strong> <ul><li><a href="../guide/instance#lifecycle-diagram">Lifecycle Diagram</a></li></ul>
</li></ul> <h2 id="provide"> provide</h2> <ul>
<li>
<p><strong>Arguments:</strong></p> <ul>
<li><code>{string | Symbol} key</code></li> <li><code>value</code></li>
</ul>
</li> <li>
<p><strong>Returns:</strong></p> <ul><li>The application instance</li></ul>
</li> <li>
<p><strong>Usage:</strong></p> <p>Sets a value that can be injected into all components within the application. Components should use <code>inject</code> to receive the provided values.</p> <p>From a <code>provide</code>/<code>inject</code> perspective, the application can be thought of as the root-level ancestor, with the root component as its only child.</p> <p>This method should not be confused with the <a href="options-composition#provide-inject">provide component option</a> or the <a href="composition-api#provide-inject">provide function</a> in the composition API. While those are also part of the same <code>provide</code>/<code>inject</code> mechanism, they are used to configure values provided by a component rather than an application.</p> <p>Providing values via the application is especially useful when writing plugins, as plugins typically wouldn't be able to provide values using components. It is an alternative to using <a href="application-config#globalproperties">globalProperties</a>.</p> <div class="custom-block tip">
<strong class="custom-block-title">Note</strong> <p>The <code>provide</code> and <code>inject</code> bindings are NOT reactive. This is intentional. However, if you pass down a reactive object, properties on that object do remain reactive.</p>
</div>
</li> <li>
<p><strong>Example:</strong></p> <p>Injecting a property into the root component, with a value provided by the application:</p>
</li>
</ul> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { createApp } from 'vue'

const app = createApp({
  inject: ['user'],
  template: `
    &lt;div&gt;
      {{ user }}
    &lt;/div&gt;
  `
})

app.provide('user', 'administrator')</pre> </div>
<ul><li>
<strong>See also:</strong> <ul><li><a href="../guide/component-provide-inject">Provide / Inject</a></li></ul>
</li></ul> <h2 id="unmount"> unmount</h2> <ul>
<li>
<p><strong>Usage:</strong></p> <p>Unmounts a root component of the application instance.</p>
</li> <li><p><strong>Example:</strong></p></li>
</ul> <div class="language-html line-numbers-mode">
<pre class="language-html" data-language="javascript">&lt;body&gt;
  &lt;div id="my-app"&gt;&lt;/div&gt;
&lt;/body&gt;</pre> </div>
<div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { createApp } from 'vue'

const app = createApp({})
// do some necessary preparations
app.mount('#my-app')

// Application will be unmounted 5 seconds after mount
setTimeout(() =&gt; app.unmount(), 5000)</pre> </div>
<h2 id="use"> use</h2> <ul>
<li>
<p><strong>Arguments:</strong></p> <ul>
<li><code>{Object | Function} plugin</code></li> <li><code>...options (optional)</code></li>
</ul>
</li> <li>
<p><strong>Returns:</strong></p> <ul><li>The application instance</li></ul>
</li> <li>
<p><strong>Usage:</strong></p> <p>Install a Vue.js plugin. If the plugin is an Object, it must expose an <code>install</code> method. If it is a function itself, it will be treated as the <code>install</code> method.</p> <p>The <code>install</code> method will be called with the application as its first argument. Any <code>options</code> passed to <code>use</code> will be passed on in subsequent arguments.</p> <p>When this method is called on the same plugin multiple times, the plugin will be installed only once.</p>
</li> <li>
<p><strong>Example:</strong></p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { createApp } from 'vue'
import MyPlugin from './plugins/MyPlugin'

const app = createApp({})

app.use(MyPlugin)
app.mount('#app')</pre> </div>
</li> <li><p><strong>See also:</strong> <a href="../guide/plugins">Plugins</a></p></li>
</ul> <h2 id="version"> version</h2> <ul>
<li>
<p><strong>Usage:</strong></p> <p>Provides the installed version of Vue as a string. This is especially useful for community <a href="../guide/plugins">plugins</a>, where you might use different strategies for different versions.</p>
</li> <li>
<p><strong>Example:</strong></p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">export default {
  install(app) {
    const version = Number(app.version.split('.')[0])

    if (version &lt; 3) {
      console.warn('This plugin requires Vue 3')
    }

    // ...
  }
}</pre> </div>
</li> <li><p><strong>See also</strong>: <a href="global-api#version">Global API - version</a></p></li>
</ul>
</div>   <div class="_attribution">
  <p class="_attribution-p">
    <a href="https://v3.vuejs.org/api/application-api.html" class="_attribution-link" target="_blank">https://v3.vuejs.org/api/application-api.html</a>
  </p>
</div>
