 <div class="theme-default-content content__default">
<h1 id="global-api"> Global API</h1> <p>If you're using a CDN build then the functions of the global API are accessible via the global <code>Vue</code> object. e.g.:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const { createApp, h, nextTick } = Vue</pre> </div>
<p>If you're using ES modules then they can be imported directly:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { createApp, h, nextTick } from 'vue'</pre> </div>
<p>Global functions that handle reactivity, such as <code>reactive</code> and <code>ref</code>, are documented separately. See <a href="reactivity-api">Reactivity API</a> for those functions.</p> <h2 id="createapp"> createApp</h2> <p>Returns an application instance which provides an application context. The entire component tree mounted by the application instance share the same context.</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const app = createApp({})</pre> </div>
<p>You can chain other methods after <code>createApp</code>, they can be found in <a href="application-api">Application API</a></p> <h3 id="arguments"> Arguments</h3> <p>The function receives a root component options object as a first parameter:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const app = createApp({
  data() {
    return {
      ...
    }
  },
  methods: {...},
  computed: {...}
  ...
})</pre> </div>
<p>With the second parameter, we can pass root props to the application:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const app = createApp(
  {
    props: ['username']
  },
  { username: 'Evan' }
)</pre> </div>
<div class="language-html line-numbers-mode">
<pre class="language-html" data-language="javascript">&lt;div id="app"&gt;
  &lt;!-- Will display 'Evan' --&gt;
  {{ username }}
&lt;/div&gt;</pre> </div>
<p>The root props are raw props, much like those passed to <a href="#h"><code>h</code></a> to create a VNode. In addition to component props, they can also include attributes and event listeners to be applied to the root component.</p> <h3 id="typing"> Typing</h3> <div class="language-ts line-numbers-mode">
<pre class="language-ts" data-language="javascript">interface Data {
  [key: string]: unknown
}

export type CreateAppFunction&lt;HostElement&gt; = (
  rootComponent: PublicAPIComponent,
  rootProps?: Data | null
) =&gt; App&lt;HostElement&gt;</pre> </div>
<h2 id="h"> h</h2> <p>Returns a "virtual node", usually abbreviated to <strong>VNode</strong>: a plain object which contains information describing to Vue what kind of node it should render on the page, including descriptions of any child nodes. It is intended for manually written <a href="../guide/render-function">render functions</a>:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">render() {
  return h('h1', {}, 'Some title')
}</pre> </div>
<h3 id="arguments-2"> Arguments</h3> <p>Accepts three arguments: <code>type</code>, <code>props</code> and <code>children</code></p> <h4 id="type"> type</h4> <ul>
<li><p><strong>Type:</strong> <code>String | Object | Function</code></p></li> <li>
<p><strong>Details:</strong></p> <p>An HTML tag name, a component, an async component, or a functional component. Using function returning null would render a comment. This parameter is required</p>
</li>
</ul> <h4 id="props"> props</h4> <ul>
<li><p><strong>Type:</strong> <code>Object</code></p></li> <li>
<p><strong>Details:</strong></p> <p>An object corresponding to the attributes, props and events we would use in a template. Optional</p>
</li>
</ul> <h4 id="children"> children</h4> <ul>
<li><p><strong>Type:</strong> <code>String | Array | Object</code></p></li> <li>
<p><strong>Details:</strong></p> <p>Children VNodes, built using <code>h()</code>, or using strings to get "text VNodes" or an object with slots. Optional</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">h('div', {}, [
  'Some text comes first.',
  h('h1', 'A headline'),
  h(MyComponent, {
    someProp: 'foobar'
  })
])</pre> </div>
</li>
</ul> <h2 id="definecomponent"> defineComponent</h2> <p>Implementation-wise <code>defineComponent</code> does nothing but return the object passed to it. However, in terms of typing, the returned value has a synthetic type of a constructor for manual render function, TSX and IDE tooling support.</p> <h3 id="arguments-3"> Arguments</h3> <p>An object with component options</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { defineComponent } from 'vue'

const MyComponent = defineComponent({
  data() {
    return { count: 1 }
  },
  methods: {
    increment() {
      this.count++
    }
  }
})</pre> </div>
<p>Or a <code>setup</code> function, function name will be used as component name</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { defineComponent, ref } from 'vue'

const HelloWorld = defineComponent(function HelloWorld() {
  const count = ref(0)
  return { count }
})</pre> </div>
<h2 id="defineasynccomponent"> defineAsyncComponent</h2> <p>Creates an async component that will be loaded only when it's necessary.</p> <h3 id="arguments-4"> Arguments</h3> <p>For basic usage, <code>defineAsyncComponent</code> can accept a factory function returning a <code>Promise</code>. Promise's <code>resolve</code> callback should be called when you have retrieved your component definition from the server. You can also call <code>reject(reason)</code> to indicate the load has failed.</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { defineAsyncComponent } from 'vue'

const AsyncComp = defineAsyncComponent(() =&gt;
  import('./components/AsyncComponent.vue')
)

app.component('async-component', AsyncComp)</pre> </div>
<p>When using <a href="../guide/component-registration#local-registration">local registration</a>, you can also directly provide a function that returns a <code>Promise</code>:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { createApp, defineAsyncComponent } from 'vue'

createApp({
  // ...
  components: {
    AsyncComponent: defineAsyncComponent(() =&gt;
      import('./components/AsyncComponent.vue')
    )
  }
})</pre> </div>
<p>For advanced usage, <code>defineAsyncComponent</code> can accept an object:</p> <p>The <code>defineAsyncComponent</code> method can also return an object of the following format:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { defineAsyncComponent } from 'vue'

const AsyncComp = defineAsyncComponent({
  // The factory function
  loader: () =&gt; import('./Foo.vue'),
  // A component to use while the async component is loading
  loadingComponent: LoadingComponent,
  // A component to use if the load fails
  errorComponent: ErrorComponent,
  // Delay before showing the loading component. Default: 200ms.
  delay: 200,
  // The error component will be displayed if a timeout is
  // provided and exceeded. Default: Infinity.
  timeout: 3000,
  // Defining if component is suspensible. Default: true.
  suspensible: false,
  /**
   *
   * @param {*} error Error message object
   * @param {*} retry A function that indicating whether the async component should retry when the loader promise rejects
   * @param {*} fail  End of failure
   * @param {*} attempts Maximum allowed retries number
   */
  onError(error, retry, fail, attempts) {
    if (error.message.match(/fetch/) &amp;&amp; attempts &lt;= 3) {
      // retry on fetch errors, 3 max attempts
      retry()
    } else {
      // Note that retry/fail are like resolve/reject of a promise:
      // one of them must be called for the error handling to continue.
      fail()
    }
  },
})</pre> </div>
<p><strong>See also</strong>: <a href="../guide/component-dynamic-async">Dynamic and Async components</a></p> <h2 id="definecustomelement"> defineCustomElement <span class="badge tip" style="vertical-align:top;" data-v-0cc74adb>3.2+</span>
</h2> <p>This method accepts the same argument as <a href="#definecomponent"><code>defineComponent</code></a>, but instead returns a native <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements" target="_blank" rel="noopener noreferrer">Custom Element<span> <span class="sr-only">(opens new window)</span></span></a> that can be used within any framework, or with no frameworks at all.</p> <p>Usage example:</p> <div class="language-html line-numbers-mode">
<pre class="language-html" data-language="javascript">&lt;my-vue-element&gt;&lt;/my-vue-element&gt;</pre> </div>
<div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { defineCustomElement } from 'vue'

const MyVueElement = defineCustomElement({
  // normal Vue component options here
  props: {},
  emits: {},
  template: `...`,

  // defineCustomElement only: CSS to be injected into shadow root
  styles: [`/* inlined css */`]
})

// Register the custom element.
// After registration, all `&lt;my-vue-element&gt;` tags on the page will be upgraded.
customElements.define('my-vue-element', MyVueElement)

// You can also programmatically instantiate the element:
// (can only be done after registration)
document.body.appendChild(
  new MyVueElement({
    // initial props (optional)
  })
)</pre> </div>
<p>For more details on building Web Components with Vue, especially with Single File Components, see <a href="../guide/web-components#building-custom-elements-with-vue">Vue and Web Components</a>.</p> <h2 id="resolvecomponent"> resolveComponent</h2> <div class="custom-block warning">
<strong class="custom-block-title">WARNING</strong> <p><code>resolveComponent</code> can only be used within <code>render</code> or <code>setup</code> functions.</p>
</div> <p>Allows resolving a <code>component</code> by its name, if it is available in the current application instance.</p> <p>Returns a <code>Component</code> or the argument <code>name</code> when not found.</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const app = createApp({})
app.component('MyComponent', {
  /* ... */
})</pre> </div>
<div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { resolveComponent } from 'vue'
render() {
  const MyComponent = resolveComponent('MyComponent')
}</pre> </div>
<h3 id="arguments-5"> Arguments</h3> <p>Accepts one argument: <code>name</code></p> <h4 id="name"> name</h4> <ul>
<li><p><strong>Type:</strong> <code>String</code></p></li> <li>
<p><strong>Details:</strong></p> <p>The name of a loaded component.</p>
</li>
</ul> <h2 id="resolvedynamiccomponent"> resolveDynamicComponent</h2> <div class="custom-block warning">
<strong class="custom-block-title">WARNING</strong> <p><code>resolveDynamicComponent</code> can only be used within <code>render</code> or <code>setup</code> functions.</p>
</div> <p>Allows resolving a <code>component</code> by the same mechanism that <code>&lt;component :is=""&gt;</code> employs.</p> <p>Returns the resolved <code>Component</code> or a newly created <code>VNode</code> with the component name as the node tag. Will raise a warning if the <code>Component</code> was not found.</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { resolveDynamicComponent } from 'vue'
render () {
  const MyComponent = resolveDynamicComponent('MyComponent')
}</pre> </div>
<h3 id="arguments-6"> Arguments</h3> <p>Accepts one argument: <code>component</code></p> <h4 id="component"> component</h4> <ul>
<li><p><strong>Type:</strong> <code>String | Object (component’s options object)</code></p></li> <li>
<p><strong>Details:</strong></p> <p>For more details, refer to the documentation on <a href="../guide/component-dynamic-async">Dynamic Components</a>.</p>
</li>
</ul> <h2 id="resolvedirective"> resolveDirective</h2> <div class="custom-block warning">
<strong class="custom-block-title">WARNING</strong> <p><code>resolveDirective</code> can only be used within <code>render</code> or <code>setup</code> functions.</p>
</div> <p>Allows resolving a <code>directive</code> by its name, if it is available in the current application instance.</p> <p>Returns a <code>Directive</code> or <code>undefined</code> when not found.</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const app = createApp({})
app.directive('highlight', {})</pre> </div>
<div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { resolveDirective } from 'vue'
render () {
  const highlightDirective = resolveDirective('highlight')
}</pre> </div>
<h3 id="arguments-7"> Arguments</h3> <p>Accepts one argument: <code>name</code></p> <h4 id="name-2"> name</h4> <ul>
<li><p><strong>Type:</strong> <code>String</code></p></li> <li>
<p><strong>Details:</strong></p> <p>The name of a loaded directive.</p>
</li>
</ul> <h2 id="withdirectives"> withDirectives</h2> <div class="custom-block warning">
<strong class="custom-block-title">WARNING</strong> <p><code>withDirectives</code> can only be used within <code>render</code> or <code>setup</code> functions.</p>
</div> <p>Allows applying directives to a <strong>VNode</strong>. Returns a VNode with the applied directives.</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { withDirectives, resolveDirective } from 'vue'
const foo = resolveDirective('foo')
const bar = resolveDirective('bar')

return withDirectives(h('div'), [
  [foo, this.x],
  [bar, this.y]
])</pre> </div>
<h3 id="arguments-8"> Arguments</h3> <p>Accepts two arguments: <code>vnode</code> and <code>directives</code>.</p> <h4 id="vnode"> vnode</h4> <ul>
<li><p><strong>Type:</strong> <code>vnode</code></p></li> <li>
<p><strong>Details:</strong></p> <p>A virtual node, usually created with <code>h()</code>.</p>
</li>
</ul> <h4 id="directives"> directives</h4> <ul>
<li><p><strong>Type:</strong> <code>Array</code></p></li> <li>
<p><strong>Details:</strong></p> <p>An array of directives.</p> <p>Each directive itself is an array, which allows for up to 4 indexes to be defined as seen in the following examples.</p> <ul><li>
<code>[directive]</code> - The directive by itself. Required.</li></ul> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const MyDirective = resolveDirective('MyDirective')
const nodeWithDirectives = withDirectives(h('div'), [[MyDirective]])</pre> </div>
<ul><li>
<code>[directive, value]</code> - The above, plus a value of type <code>any</code> to be assigned to the directive</li></ul> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const MyDirective = resolveDirective('MyDirective')
const nodeWithDirectives = withDirectives(h('div'), [[MyDirective, 100]])</pre> </div>
<ul><li>
<code>[directive, value, arg]</code> - The above, plus a <code>String</code> argument, ie. <code>click</code> in <code>v-on:click</code>
</li></ul> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const MyDirective = resolveDirective('MyDirective')
const nodeWithDirectives = withDirectives(h('div'), [
  [MyDirective, 100, 'click']
])</pre> </div>
<ul><li>
<code>[directive, value, arg, modifiers]</code> - The above, plus a <code>key: value</code> pair <code>Object</code> defining any modifiers.</li></ul> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const MyDirective = resolveDirective('MyDirective')
const nodeWithDirectives = withDirectives(h('div'), [
  [MyDirective, 100, 'click', { prevent: true }]
])</pre> </div>
</li>
</ul> <h2 id="createrenderer"> createRenderer</h2> <p>The createRenderer function accepts two generic arguments: <code>HostNode</code> and <code>HostElement</code>, corresponding to Node and Element types in the host environment.</p> <p>For example, for runtime-dom, HostNode would be the DOM <code>Node</code> interface and HostElement would be the DOM <code>Element</code> interface.</p> <p>Custom renderers can pass in the platform specific types like this:</p> <div class="language-ts line-numbers-mode">
<pre class="language-ts" data-language="javascript">import { createRenderer } from 'vue'
const { render, createApp } = createRenderer&lt;Node, Element&gt;({
  patchProp,
  ...nodeOps
})</pre> </div>
<h3 id="arguments-9"> Arguments</h3> <p>Accepts two arguments: <code>HostNode</code> and <code>HostElement</code></p> <h4 id="hostnode"> HostNode</h4> <ul>
<li><p><strong>Type:</strong> <code>Node</code></p></li> <li>
<p><strong>Details:</strong></p> <p>The node in the host environment.</p>
</li>
</ul> <h4 id="hostelement"> HostElement</h4> <ul>
<li><p><strong>Type:</strong> <code>Element</code></p></li> <li>
<p><strong>Details:</strong></p> <p>The element in the host environment.</p>
</li>
</ul> <h2 id="nexttick"> nextTick</h2> <p>Defer the callback to be executed after the next DOM update cycle. Use it immediately after you’ve changed some data to wait for the DOM update.</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { createApp, nextTick } from 'vue'

const app = createApp({
  setup() {
    const message = ref('Hello!')
    const changeMessage = async newMessage =&gt; {
      message.value = newMessage
      await nextTick()
      console.log('Now DOM is updated')
    }
  }
})</pre> </div>
<p><strong>See also</strong>: <a href="instance-methods#nexttick"><code>$nextTick</code> instance method</a></p> <h2 id="mergeprops"> mergeProps</h2> <p>Takes multiple objects containing VNode props and merges them into a single object. A newly created object is returned, the objects passed as arguments are not modified.</p> <p>Any number of objects can be passed, with properties from later arguments taking precedence. Event listeners are handled specially, as are <code>class</code> and <code>style</code>, with the values of these properties being merged rather than overwritten.</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { h, mergeProps } from 'vue'

export default {
  inheritAttrs: false,

  render() {
    const props = mergeProps(
      {
        // The class will be merged with any class from $attrs
        class: 'active'
      },
      this.$attrs
    )

    return h('div', props)
  }
}</pre> </div>
<h2 id="usecssmodule"> useCssModule</h2> <div class="custom-block warning">
<strong class="custom-block-title">WARNING</strong> <p><code>useCssModule</code> can only be used within <code>render</code> or <code>setup</code> functions.</p>
</div> <p>Allows CSS modules to be accessed within the <a href="composition-api#setup"><code>setup</code></a> function of a <a href="../guide/single-file-component">single-file component</a>:</p> <div class="language-vue line-numbers-mode">
<pre class="language-vue" data-language="javascript">&lt;script&gt;
import { h, useCssModule } from 'vue'

export default {
  setup() {
    const style = useCssModule()

    return () =&gt;
      h(
        'div',
        {
          class: style.success
        },
        'Task complete!'
      )
  }
}
&lt;/script&gt;

&lt;style module&gt;
.success {
  color: #090;
}
&lt;/style&gt;</pre> </div>
<p>For more information about using CSS modules, see <a href="sfc-style#style-module">SFC Style Features: <code>&lt;style module&gt;</code></a>.</p> <h3 id="arguments-10"> Arguments</h3> <p>Accepts one argument: <code>name</code></p> <h4 id="name-3"> name</h4> <ul>
<li><p><strong>Type:</strong> <code>String</code></p></li> <li>
<p><strong>Details:</strong></p> <p>The name of the CSS module. Defaults to <code>'$style'</code>.</p>
</li>
</ul> <h2 id="version"> version</h2> <p>Provides the installed version of Vue as a string.</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const version = Number(Vue.version.split('.')[0])

if (version === 3) {
  // Vue 3
} else if (version === 2) {
  // Vue 2
} else {
  // Unsupported versions of Vue
}</pre> </div>
<p><strong>See also</strong>: <a href="application-api#version">Application API - version</a></p>
</div>   <div class="_attribution">
  <p class="_attribution-p">
    <a href="https://v3.vuejs.org/api/global-api.html" class="_attribution-link" target="_blank">https://v3.vuejs.org/api/global-api.html</a>
  </p>
</div>
