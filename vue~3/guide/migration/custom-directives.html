 <div class="theme-default-content content__default">
<h1 id="custom-directives"> Custom Directives <div class="migration-badge-wrapper" data-v-cb310528><span class="migration-badge is-breaking" data-v-cb310528> breaking </span></div>
</h1> <h2 id="overview"> Overview</h2> <p>The hook functions for directives have been renamed to better align with the component lifecycle.</p> <p>Additionally, the <code>expression</code> string is no longer passed as part of the <code>binding</code> object.</p> <h2 id="_2-x-syntax"> 2.x Syntax</h2> <p>In Vue 2, custom directives were created by using the hooks listed below to target an element’s lifecycle, all of which are optional:</p> <ul>
<li>
<strong>bind</strong> - Occurs once the directive is bound to the element. Occurs only once.</li> <li>
<strong>inserted</strong> - Occurs once the element is inserted into the parent DOM.</li> <li>
<strong>update</strong> - This hook is called when the element updates, but children haven't been updated yet.</li> <li>
<strong>componentUpdated</strong> - This hook is called once the component and the children have been updated.</li> <li>
<strong>unbind</strong> - This hook is called once the directive is removed. Also called only once.</li>
</ul> <p>Here’s an example of this:</p> <div class="language-html line-numbers-mode">
<pre class="language-html" data-language="javascript">&lt;p v-highlight="'yellow'"&gt;Highlight this text bright yellow&lt;/p&gt;</pre> </div>
<div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">Vue.directive('highlight', {
  bind(el, binding, vnode) {
    el.style.background = binding.value
  }
})</pre> </div>
<p>Here, in the initial setup for this element, the directive binds a style by passing in a value, that can be updated to different values through the application.</p> <h2 id="_3-x-syntax"> 3.x Syntax</h2> <p>In Vue 3, however, we’ve created a more cohesive API for custom directives. As you can see, they differ greatly from our component lifecycle methods even though we’re hooking into similar events. We’ve now unified them like so:</p> <ul>
<li>
<strong>created</strong> - new! This is called before the element's attributes or event listeners are applied.</li> <li>bind → <strong>beforeMount</strong>
</li> <li>inserted → <strong>mounted</strong>
</li> <li>
<strong>beforeUpdate</strong>: new! This is called before the element itself is updated, much like the component lifecycle hooks.</li> <li>update → removed! There were too many similarities to updated, so this is redundant. Please use updated instead.</li> <li>componentUpdated → <strong>updated</strong>
</li> <li>
<strong>beforeUnmount</strong>: new! Similar to component lifecycle hooks, this will be called right before an element is unmounted.</li> <li>unbind -&gt; <strong>unmounted</strong>
</li>
</ul> <p>The final API is as follows:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const MyDirective = {
  created(el, binding, vnode, prevVnode) {}, // new
  beforeMount() {},
  mounted() {},
  beforeUpdate() {}, // new
  updated() {},
  beforeUnmount() {}, // new
  unmounted() {}
}</pre> </div>
<p>The resulting API could be used like this, mirroring the example from earlier:</p> <div class="language-html line-numbers-mode">
<pre class="language-html" data-language="javascript">&lt;p v-highlight="'yellow'"&gt;Highlight this text bright yellow&lt;/p&gt;</pre> </div>
<div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const app = Vue.createApp({})

app.directive('highlight', {
  beforeMount(el, binding, vnode) {
    el.style.background = binding.value
  }
})</pre> </div>
<p>Now that the custom directive lifecycle hooks mirror those of the components themselves, they become easier to reason about and remember!</p> <h3 id="edge-case-accessing-the-component-instance"> Edge Case: Accessing the component instance</h3> <p>It's generally recommended to keep directives independent of the component instance they are used in. Accessing the instance from within a custom directive is often a sign that the directive should rather be a component itself. However, there are situations where this actually makes sense.</p> <p>In Vue 2, the component instance had to be accessed through the <code>vnode</code> argument:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">bind(el, binding, vnode) {
  const vm = vnode.context
}</pre> </div>
<p>In Vue 3, the instance is now part of the <code>binding</code>:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">mounted(el, binding, vnode) {
  const vm = binding.instance
}</pre> </div>
<div class="custom-block warning">
<strong class="custom-block-title">WARNING</strong> <p>With <a href="fragments#overview">fragments</a> support, components can potentially have more than one root node. When applied to a multi-root component, a custom directive will be ignored and a warning will be logged.</p>
</div> <h2 id="migration-strategy"> Migration Strategy</h2> <p><a href="migration-build#compat-configuration">Migration build flag: <code>CUSTOM_DIR</code></a></p>
</div>   <div class="_attribution">
  <p class="_attribution-p">
    <a href="https://v3.vuejs.org/guide/migration/custom-directives.html" class="_attribution-link" target="_blank">https://v3.vuejs.org/guide/migration/custom-directives.html</a>
  </p>
</div>
