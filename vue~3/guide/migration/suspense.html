 <div class="theme-default-content content__default">
<h1 id="suspense"> Suspense <div class="migration-badge-wrapper" data-v-cb310528><span class="migration-badge is-new" data-v-cb310528> new </span></div>
</h1> <div class="custom-block warning">
<strong class="custom-block-title">Experimental</strong> <p>Suspense is an experimental new feature and the API could change at any time. It is documented here so that the community can provide feedback on the current implementation.</p> <p>It should not be used in production applications.</p>
</div> <h2 id="introduction"> Introduction</h2> <p>It is common for components to need to perform some kind of asynchronous request before they can be rendered properly. Components often handle this locally and in many cases that is a perfectly good approach.</p> <p>The <code>&lt;suspense&gt;</code> component provides an alternative, allowing for the waiting to be handled further up the component tree rather than in each individual component.</p> <p>A common use case involves <a href="../component-dynamic-async#async-components">async components</a>:</p> <div class="language-vue line-numbers-mode">
<div class="highlight-lines">
<br>


<br>
<br><br><br><br><br><br><br><br><br><br>
<br><br><br><br>
</div>
<pre class="language-vue" data-language="javascript">&lt;template&gt;
  &lt;suspense&gt;
    &lt;template #default&gt;
      &lt;todo-list /&gt;
    &lt;/template&gt;
    &lt;template #fallback&gt;
      &lt;div&gt;
        Loading...
      &lt;/div&gt;
    &lt;/template&gt;
  &lt;/suspense&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  components: {
    TodoList: defineAsyncComponent(() =&gt; import('./TodoList.vue'))
  }
}
&lt;/script&gt;</pre>
</div>
<p>The <code>&lt;suspense&gt;</code> component has two slots. Both slots only allow for one immediate child node. The node in the <code>default</code> slot is shown if possible. If not, the node in the <code>fallback</code> slot will be shown instead.</p> <p>Importantly, the async component doesn't need to be the immediate child of the <code>&lt;suspense&gt;</code>. It can be at any depth within the component tree and doesn't need to appear in the same template as the <code>&lt;suspense&gt;</code> itself. The content is only considered resolved once all descendants are ready.</p> <p>The other way to trigger the <code>fallback</code> slot is for a descendant component to return a promise from its <code>setup</code> function. This is typically implemented using <code>async</code> rather than explicitly returning a promise:</p> <div class="language-js line-numbers-mode">
<div class="highlight-lines">
<br>
<br><br><br><br><br><br><br><br><br><br><br><br><br>
</div>
<pre class="language-js" data-language="javascript">export default {
  async setup() {
    // Be very careful using `await` inside `setup` as
    // most Composition API functions will only work
    // prior to the first `await`
    const data = await loadData()

    // This is implicitly wrapped in a promise because
    // the function is `async`
    return {
      // ...
    }
  }
}</pre>
</div>
<h2 id="child-updates"> Child Updates</h2> <p>Once a <code>&lt;suspense&gt;</code> has resolved the contents of its <code>default</code> slot, it can only be triggered again if the <code>default</code> root node is replaced. New components nested deeper in the tree are not sufficient to move the <code>&lt;suspense&gt;</code> back into a pending state.</p> <p>If the root node does change it will trigger the <code>pending</code> event. However, by default, it won't update the DOM to show the <code>fallback</code> content. Instead, it will continue to show the old DOM until the new components are ready. This can be controlled using the <code>timeout</code> prop. This value, expressed in milliseconds, tells the <code>&lt;suspense&gt;</code> component how long to wait before showing the <code>fallback</code>. A value of <code>0</code> will show it immediately when the <code>&lt;suspense&gt;</code> enters the pending state.</p> <h2 id="events"> Events</h2> <p>In addition to the <code>pending</code> event, the <code>&lt;suspense&gt;</code> component also has <code>resolve</code> and <code>fallback</code> events. The <code>resolve</code> event is emitted when new content has finished resolving in the <code>default</code> slot. The <code>fallback</code> event is fired when the contents of the <code>fallback</code> slot are shown.</p> <p>The events could be used, for example, to show a loading indicator in front of the old DOM while new components are loading.</p> <h2 id="combining-with-other-components"> Combining with Other Components</h2> <p>It is common to want to use <code>&lt;suspense&gt;</code> in combination with the <a href="../../api/built-in-components#transition"><code>&lt;transition&gt;</code></a> and <a href="../../api/built-in-components#keep-alive"><code>&lt;keep-alive&gt;</code></a> components. The nesting order of these components is important to get them all working correctly.</p> <p>In addition, these components are often used in conjunction with the <code>&lt;router-view&gt;</code> component from <a href="https://next.router.vuejs.org/" target="_blank" rel="noopener noreferrer">Vue Router<span> <span class="sr-only">(opens new window)</span></span></a>.</p> <p>The following example shows how to nest these components so that they all behave as expected. For simpler combinations you can remove the components that you don't need:</p> <div class="language-html line-numbers-mode">
<pre class="language-html" data-language="javascript">&lt;router-view v-slot="{ Component }"&gt;
  &lt;template v-if="Component"&gt;
    &lt;transition mode="out-in"&gt;
      &lt;keep-alive&gt;
        &lt;suspense&gt;
          &lt;component :is="Component"&gt;&lt;/component&gt;
          &lt;template #fallback&gt;
            &lt;div&gt;
              Loading...
            &lt;/div&gt;
          &lt;/template&gt;
        &lt;/suspense&gt;
      &lt;/keep-alive&gt;
    &lt;/transition&gt;
  &lt;/template&gt;
&lt;/router-view&gt;</pre> </div>
<p>Vue Router has built-in support for <a href="https://next.router.vuejs.org/guide/advanced/lazy-loading.html" target="_blank" rel="noopener noreferrer">lazily loading components<span> <span class="sr-only">(opens new window)</span></span></a> using dynamic imports. These are distinct from async components and currently they will not trigger <code>&lt;suspense&gt;</code>. However, they can still have async components as descendants and those can trigger <code>&lt;suspense&gt;</code> in the usual way.</p>
</div>   <div class="_attribution">
  <p class="_attribution-p">
    <a href="https://v3.vuejs.org/guide/migration/suspense.html" class="_attribution-link" target="_blank">https://v3.vuejs.org/guide/migration/suspense.html</a>
  </p>
</div>
