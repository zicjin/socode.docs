 <div class="theme-default-content content__default">
<h1 id="typescript-support"> TypeScript Support</h1> <blockquote><p><a href="https://cli.vuejs.org" target="_blank" rel="noopener noreferrer">Vue CLI<span> <span class="sr-only">(opens new window)</span></span></a> provides built-in TypeScript tooling support.</p></blockquote> <h2 id="official-declaration-in-npm-packages"> Official Declaration in NPM Packages</h2> <p>A static type system can help prevent many potential runtime errors as applications grow, which is why Vue 3 is written in TypeScript. This means you don't need any additional tooling to use TypeScript with Vue - it has first-class citizen support.</p> <h2 id="recommended-configuration"> Recommended Configuration</h2> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">// tsconfig.json
{
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    // this enables stricter inference for data properties on `this`
    "strict": true,
    "jsx": "preserve",
    "moduleResolution": "node"
  }
}</pre> </div>
<p>Note that you have to include <code>strict: true</code> (or at least <code>noImplicitThis: true</code> which is a part of <code>strict</code> flag) to leverage type checking of <code>this</code> in component methods otherwise it is always treated as <code>any</code> type.</p> <p>See <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" target="_blank" rel="noopener noreferrer">TypeScript compiler options docs<span> <span class="sr-only">(opens new window)</span></span></a> for more details.</p> <h2 id="webpack-configuration"> Webpack Configuration</h2> <p>If you are using a custom Webpack configuration <code>ts-loader</code> needs to be configured to parse <code>&lt;script lang="ts"&gt;</code> blocks in <code>.vue</code> files:</p> <div class="language-js line-numbers-mode">
<div class="highlight-lines">
<br><br><br><br><br><br><br><br><br>
<br><br><br><br><br><br><br><br><br>
</div>
<pre class="language-js" data-language="javascript">// webpack.config.js
module.exports = {
  ...
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        loader: 'ts-loader',
        options: {
          appendTsSuffixTo: [/\.vue$/],
        },
        exclude: /node_modules/,
      },
      {
        test: /\.vue$/,
        loader: 'vue-loader',
      }
      ...</pre>
</div>
<h2 id="development-tooling"> Development Tooling</h2> <h3 id="project-creation"> Project Creation</h3> <p><a href="https://github.com/vuejs/vue-cli" target="_blank" rel="noopener noreferrer">Vue CLI<span> <span class="sr-only">(opens new window)</span></span></a> can generate new projects that use TypeScript. To get started:</p> <div class="language-bash line-numbers-mode">
<pre class="language-bash" data-language="javascript"># 1. Install Vue CLI, if it's not already installed
npm install --global @vue/cli

# 2. Create a new project, then choose the "Manually select features" option
vue create my-project-name

# If you already have a Vue CLI project without TypeScript, please add a proper Vue CLI plugin:
vue add typescript</pre> </div>
<p>Make sure that <code>script</code> part of the component has TypeScript set as a language:</p> <div class="language-html line-numbers-mode">
<pre class="language-html" data-language="javascript">&lt;script lang="ts"&gt;
  ...
&lt;/script&gt;</pre> </div>
<p>Or, if you want to combine TypeScript with a <a href="render-function#jsx">JSX <code>render</code> function</a>:</p> <div class="language-html line-numbers-mode">
<pre class="language-html" data-language="javascript">&lt;script lang="tsx"&gt;
  ...
&lt;/script&gt;</pre> </div>
<h3 id="editor-support"> Editor Support</h3> <p>For developing Vue applications with TypeScript, we strongly recommend using <a href="https://code.visualstudio.com/" target="_blank" rel="noopener noreferrer">Visual Studio Code<span> <span class="sr-only">(opens new window)</span></span></a>, which provides great out-of-the-box support for TypeScript. If you are using <a href="single-file-component">single-file components</a> (SFCs), get the awesome <a href="https://github.com/johnsoncodehk/volar" target="_blank" rel="noopener noreferrer">Volar extension<span> <span class="sr-only">(opens new window)</span></span></a>, which provides TypeScript inference inside SFCs and many other great features.</p> <p><a href="https://www.jetbrains.com/webstorm/" target="_blank" rel="noopener noreferrer">WebStorm<span> <span class="sr-only">(opens new window)</span></span></a> provides out of the box support for both TypeScript and Vue. Other JetBrains IDEs also support them, either out of the box or via <a href="https://plugins.jetbrains.com/plugin/9442-vue-js" target="_blank" rel="noopener noreferrer">this free plugin<span> <span class="sr-only">(opens new window)</span></span></a>.</p> <h2 id="defining-vue-components"> Defining Vue Components</h2> <p>To let TypeScript properly infer types inside Vue component options, you need to define components with <code>defineComponent</code> global method:</p> <div class="language-ts line-numbers-mode">
<pre class="language-ts" data-language="javascript">import { defineComponent } from 'vue'

const Component = defineComponent({
  // type inference enabled
})</pre> </div>
<p>If you're using <a href="single-file-component">single-file components</a> then this would typically be written as:</p> <div class="language-vue line-numbers-mode">
<pre class="language-vue" data-language="javascript">&lt;script lang="ts"&gt;
import { defineComponent } from 'vue'

export default defineComponent({
  // type inference enabled
})
&lt;/script&gt;</pre> </div>
<h2 id="using-with-options-api"> Using with Options API</h2> <p>TypeScript should be able to infer most of the types without defining types explicitly. For example, if you have a component with a number <code>count</code> property, you will have an error if you try to call a string-specific method on it:</p> <div class="language-ts line-numbers-mode">
<pre class="language-ts" data-language="javascript">const Component = defineComponent({
  data() {
    return {
      count: 0
    }
  },
  mounted() {
    const result = this.count.split('') // =&gt; Property 'split' does not exist on type 'number'
  }
})</pre> </div>
<p>If you have a complex type or interface, you can cast it using <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions" target="_blank" rel="noopener noreferrer">type assertion<span> <span class="sr-only">(opens new window)</span></span></a>:</p> <div class="language-ts line-numbers-mode">
<pre class="language-ts" data-language="javascript">interface Book {
  title: string
  author: string
  year: number
}

const Component = defineComponent({
  data() {
    return {
      book: {
        title: 'Vue 3 Guide',
        author: 'Vue Team',
        year: 2020
      } as Book
    }
  }
})</pre> </div>
<h3 id="augmenting-types-for-globalproperties"> Augmenting Types for <code>globalProperties</code>
</h3> <p>Vue 3 provides a <a href="../api/application-config#globalproperties"><code>globalProperties</code> object</a> that can be used to add a global property that can be accessed in any component instance. For example, a <a href="plugins#writing-a-plugin">plugin</a> might want to inject a shared global object or function.</p> <div class="language-ts line-numbers-mode">
<pre class="language-ts" data-language="javascript">// User Definition
import axios from 'axios'

const app = Vue.createApp({})
app.config.globalProperties.$http = axios

// Plugin for validating some data
export default {
  install(app, options) {
    app.config.globalProperties.$validate = (data: object, rule: object) =&gt; {
      // check whether the object meets certain rules
    }
  }
}</pre> </div>
<p>In order to tell TypeScript about these new properties, we can use <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation" target="_blank" rel="noopener noreferrer">module augmentation<span> <span class="sr-only">(opens new window)</span></span></a>.</p> <p>In the above example, we could add the following type declaration:</p> <div class="language-ts line-numbers-mode">
<pre class="language-ts" data-language="javascript">import axios from 'axios'

declare module '@vue/runtime-core' {
  export interface ComponentCustomProperties {
    $http: typeof axios
    $validate: (data: object, rule: object) =&gt; boolean
  }
}</pre> </div>
<p>We can put this type declaration in the same file, or in a project-wide <code>*.d.ts</code> file (for example, in the <code>src/typings</code> folder that is automatically loaded by TypeScript). For library/plugin authors, this file should be specified in the <code>types</code> property in <code>package.json</code>.</p> <div class="custom-block warning">
<strong class="custom-block-title">Make sure the declaration file is a TypeScript module</strong> <p>In order to take advantage of module augmentation, you will need to ensure there is at least one top-level <code>import</code> or <code>export</code> in your file, even if it is just <code>export {}</code>.</p> <p><a href="https://www.typescriptlang.org/docs/handbook/modules.html" target="_blank" rel="noopener noreferrer">In TypeScript<span> <span class="sr-only">(opens new window)</span></span></a>, any file containing a top-level <code>import</code> or <code>export</code> is considered a 'module'. If type declaration is made outside of a module, it will overwrite the original types rather than augmenting them.</p>
</div> <p>For more information about the <code>ComponentCustomProperties</code> type, see its <a href="https://github.com/vuejs/vue-next/blob/2587f36fe311359e2e34f40e8e47d2eebfab7f42/packages/runtime-core/src/componentOptions.ts#L64-L80" target="_blank" rel="noopener noreferrer">definition in <code>@vue/runtime-core</code><span> <span class="sr-only">(opens new window)</span></span></a> and <a href="https://github.com/vuejs/vue-next/blob/master/test-dts/componentTypeExtensions.test-d.tsx" target="_blank" rel="noopener noreferrer">the TypeScript unit tests<span> <span class="sr-only">(opens new window)</span></span></a> to learn more.</p> <h3 id="annotating-return-types"> Annotating Return Types</h3> <p>Because of the circular nature of Vue’s declaration files, TypeScript may have difficulties inferring the types of computed. For this reason, you may need to annotate the return type of computed properties.</p> <div class="language-ts line-numbers-mode">
<pre class="language-ts" data-language="javascript">import { defineComponent } from 'vue'

const Component = defineComponent({
  data() {
    return {
      message: 'Hello!'
    }
  },
  computed: {
    // needs an annotation
    greeting(): string {
      return this.message + '!'
    },

    // in a computed with a setter, getter needs to be annotated
    greetingUppercased: {
      get(): string {
        return this.greeting.toUpperCase()
      },
      set(newValue: string) {
        this.message = newValue.toUpperCase()
      }
    }
  }
})</pre> </div>
<h3 id="annotating-props"> Annotating Props</h3> <p>Vue does a runtime validation on props with a <code>type</code> defined. To provide these types to TypeScript, we need to cast the constructor with <code>PropType</code>:</p> <div class="language-ts line-numbers-mode">
<pre class="language-ts" data-language="javascript">import { defineComponent, PropType } from 'vue'

interface Book {
  title: string
  author: string
  year: number
}

const Component = defineComponent({
  props: {
    name: String,
    id: [Number, String],
    success: { type: String },
    callback: {
      type: Function as PropType&lt;() =&gt; void&gt;
    },
    book: {
      type: Object as PropType&lt;Book&gt;,
      required: true
    },
    metadata: {
      type: null // metadata is typed as any
    }
  }
})</pre> </div>
<div class="custom-block warning">
<strong class="custom-block-title">WARNING</strong> <p>Because of a <a href="https://github.com/microsoft/TypeScript/issues/38845" target="_blank" rel="noopener noreferrer">design limitation<span> <span class="sr-only">(opens new window)</span></span></a> in TypeScript when it comes to type inference of function expressions, you have to be careful with <code>validator</code> and <code>default</code> values for objects and arrays:</p>
</div> <div class="language-ts line-numbers-mode">
<pre class="language-ts" data-language="javascript">import { defineComponent, PropType } from 'vue'

interface Book {
  title: string
  year?: number
}

const Component = defineComponent({
  props: {
    bookA: {
      type: Object as PropType&lt;Book&gt;,
      // Make sure to use arrow functions
      default: () =&gt; ({
        title: 'Arrow Function Expression'
      }),
      validator: (book: Book) =&gt; !!book.title
    },
    bookB: {
      type: Object as PropType&lt;Book&gt;,
      // Or provide an explicit this parameter
      default(this: void) {
        return {
          title: 'Function Expression'
        }
      },
      validator(this: void, book: Book) {
        return !!book.title
      }
    }
  }
})</pre> </div>
<h3 id="annotating-emits"> Annotating Emits</h3> <p>We can annotate a payload for the emitted event. Also, all non-declared emitted events will throw a type error when called:</p> <div class="language-ts line-numbers-mode">
<pre class="language-ts" data-language="javascript">const Component = defineComponent({
  emits: {
    addBook(payload: { bookName: string }) {
      // perform runtime validation
      return payload.bookName.length &gt; 0
    }
  },
  methods: {
    onSubmit() {
      this.$emit('addBook', {
        bookName: 123 // Type error!
      })

      this.$emit('non-declared-event') // Type error!
    }
  }
})</pre> </div>
<h2 id="using-with-composition-api"> Using with Composition API</h2> <p>On <code>setup()</code> function, you don't need to pass a typing to <code>props</code> parameter as it will infer types from <code>props</code> component option.</p> <div class="language-ts line-numbers-mode">
<pre class="language-ts" data-language="javascript">import { defineComponent } from 'vue'

const Component = defineComponent({
  props: {
    message: {
      type: String,
      required: true
    }
  },

  setup(props) {
    const result = props.message.split('') // correct, 'message' is typed as a string
    const filtered = props.message.filter(p =&gt; p.value) // an error will be thrown: Property 'filter' does not exist on type 'string'
  }
})</pre> </div>
<h3 id="typing-refs"> Typing <code>refs</code>
</h3> <p>Refs infer the type from the initial value:</p> <div class="language-ts line-numbers-mode">
<pre class="language-ts" data-language="javascript">import { defineComponent, ref } from 'vue'

const Component = defineComponent({
  setup() {
    const year = ref(2020)

    const result = year.value.split('') // =&gt; Property 'split' does not exist on type 'number'
  }
})</pre> </div>
<p>Sometimes we may need to specify complex types for a ref's inner value. We can do that by simply passing a generic argument when calling ref to override the default inference:</p> <div class="language-ts line-numbers-mode">
<pre class="language-ts" data-language="javascript">const year = ref&lt;string | number&gt;('2020') // year's type: Ref&lt;string | number&gt;

year.value = 2020 // ok!</pre> </div>
<div class="custom-block tip">
<strong class="custom-block-title">Note</strong> <p>If the type of the generic is unknown, it's recommended to cast <code>ref</code> to <code>Ref&lt;T&gt;</code>.</p>
</div> <h3 id="typing-template-refs"> Typing Template Refs</h3> <p>Sometimes you might need to annotate a template ref for a child component in order to call its public method. For example, we have a <code>MyModal</code> child component with a method that opens the modal:</p> <div class="language-ts line-numbers-mode">
<pre class="language-ts" data-language="javascript">import { defineComponent, ref } from 'vue'

const MyModal = defineComponent({
  setup() {
    const isContentShown = ref(false)
    const open = () =&gt; (isContentShown.value = true)

    return {
      isContentShown,
      open
    }
  }
})</pre> </div>
<p>We want to call this method via a template ref from the parent component:</p> <div class="language-ts line-numbers-mode">
<pre class="language-ts" data-language="javascript">import { defineComponent, ref } from 'vue'

const MyModal = defineComponent({
  setup() {
    const isContentShown = ref(false)
    const open = () =&gt; (isContentShown.value = true)

    return {
      isContentShown,
      open
    }
  }
})

const app = defineComponent({
  components: {
    MyModal
  },
  template: `
    &lt;button @click="openModal"&gt;Open from parent&lt;/button&gt;
    &lt;my-modal ref="modal" /&gt;
  `,
  setup() {
    const modal = ref()
    const openModal = () =&gt; {
      modal.value.open()
    }

    return { modal, openModal }
  }
})</pre> </div>
<p>While this will work, there is no type information about <code>MyModal</code> and its available methods. To fix this, you should use <code>InstanceType</code> when creating a ref:</p> <div class="language-ts line-numbers-mode">
<pre class="language-ts" data-language="javascript">setup() {
  const modal = ref&lt;InstanceType&lt;typeof MyModal&gt;&gt;()
  const openModal = () =&gt; {
    modal.value?.open()
  }

  return { modal, openModal }
}</pre> </div>
<p>Please note that you would also need to use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" target="_blank" rel="noopener noreferrer">optional chaining<span> <span class="sr-only">(opens new window)</span></span></a> or any other way to check that <code>modal.value</code> is not undefined.</p> <h3 id="typing-reactive"> Typing <code>reactive</code>
</h3> <p>When typing a <code>reactive</code> property, we can use interfaces:</p> <div class="language-ts line-numbers-mode">
<pre class="language-ts" data-language="javascript">import { defineComponent, reactive } from 'vue'

interface Book {
  title: string
  year?: number
}

export default defineComponent({
  name: 'HelloWorld',
  setup() {
    const book = reactive&lt;Book&gt;({ title: 'Vue 3 Guide' })
    // or
    const book: Book = reactive({ title: 'Vue 3 Guide' })
    // or
    const book = reactive({ title: 'Vue 3 Guide' }) as Book
  }
})</pre> </div>
<h3 id="typing-computed"> Typing <code>computed</code>
</h3> <p>Computed values will automatically infer the type from returned value</p> <div class="language-ts line-numbers-mode">
<pre class="language-ts" data-language="javascript">import { defineComponent, ref, computed } from 'vue'

export default defineComponent({
  name: 'CounterButton',
  setup() {
    let count = ref(0)

    // read-only
    const doubleCount = computed(() =&gt; count.value * 2)

    const result = doubleCount.value.split('') // =&gt; Property 'split' does not exist on type 'number'
  }
})</pre> </div>
<h3 id="typing-event-handlers"> Typing Event Handlers</h3> <p>When dealing with native DOM events, it might be useful to type the argument we pass to the handler correctly. Let's take a look at this example:</p> <div class="language-vue line-numbers-mode">
<pre class="language-vue" data-language="javascript">&lt;template&gt;
  &lt;input type="text" @change="handleChange" /&gt;
&lt;/template&gt;

&lt;script lang="ts"&gt;
import { defineComponent } from 'vue'

export default defineComponent({
  setup() {
    // `evt` will be of type `any`
    const handleChange = evt =&gt; {
      console.log(evt.target.value) // TS will throw an error here
    }

    return { handleChange }
  }
})
&lt;/script&gt;</pre> </div>
<p>As you can see, without annotating the <code>evt</code> argument correctly, TypeScript will throw an error when we try to access the value of the <code>&lt;input&gt;</code> element. The solution is to cast the event target with a correct type:</p> <div class="language-ts line-numbers-mode">
<pre class="language-ts" data-language="javascript">const handleChange = (evt: Event) =&gt; {
  console.log((evt.target as HTMLInputElement).value)
}</pre> </div>
</div>   <div class="_attribution">
  <p class="_attribution-p">
    <a href="https://v3.vuejs.org/guide/typescript-support.html" class="_attribution-link" target="_blank">https://v3.vuejs.org/guide/typescript-support.html</a>
  </p>
</div>
