 <div class="theme-default-content content__default">
<h1 id="dynamic-async-components"> Dynamic &amp; Async Components</h1> <blockquote><p>This page assumes you've already read the <a href="component-basics">Components Basics</a>. Read that first if you are new to components.</p></blockquote> <h2 id="dynamic-components-with-keep-alive"> Dynamic Components with <code>keep-alive</code>
</h2> <p>Earlier, we used the <code>is</code> attribute to switch between components in a tabbed interface:</p> <div class="language-vue-html line-numbers-mode">
<pre class="language-vue-html" data-language="javascript">&lt;component :is="currentTabComponent"&gt;&lt;/component&gt;</pre> </div>
<p>When switching between these components though, you'll sometimes want to maintain their state or avoid re-rendering for performance reasons. For example, when expanding our tabbed interface a little: <span>See the Pen <a href="https://codepen.io/teamVue/pen/jOPjZOe">Dynamic components: without keep-alive</a> by Vue (<a href="https://codepen.io/Vue">@Vue</a>) on <a href="https://codepen.io">CodePen</a>.</span></p>  <p>You'll notice that if you select a post, switch to the <em>Archive</em> tab, then switch back to <em>Posts</em>, it's no longer showing the post you selected. That's because each time you switch to a new tab, Vue creates a new instance of the <code>currentTabComponent</code>.</p> <p>Recreating dynamic components is normally useful behavior, but in this case, we'd really like those tab component instances to be cached once they're created for the first time. To solve this problem, we can wrap our dynamic component with a <code>&lt;keep-alive&gt;</code> element:</p> <div class="language-vue-html line-numbers-mode">
<pre class="language-vue-html" data-language="javascript">&lt;!-- Inactive components will be cached! --&gt;
&lt;keep-alive&gt;
  &lt;component :is="currentTabComponent"&gt;&lt;/component&gt;
&lt;/keep-alive&gt;</pre> </div>
<p>Check out the result below: <span>See the Pen <a href="https://codepen.io/teamVue/pen/VwLJQvP">Dynamic components: with keep-alive</a> by Vue (<a href="https://codepen.io/Vue">@Vue</a>) on <a href="https://codepen.io">CodePen</a>.</span></p>  <p>Now the <em>Posts</em> tab maintains its state (the selected post) even when it's not rendered.</p> <p>Check out more details on <code>&lt;keep-alive&gt;</code> in the <a href="../api/built-in-components#keep-alive">API reference</a>.</p> <h2 id="async-components"> Async Components</h2> <p>In large applications, we may need to divide the app into smaller chunks and only load a component from the server when it's needed. To make that possible, Vue has a <code>defineAsyncComponent</code> method:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const { createApp, defineAsyncComponent } = Vue

const app = createApp({})

const AsyncComp = defineAsyncComponent(
  () =&gt;
    new Promise((resolve, reject) =&gt; {
      resolve({
        template: '&lt;div&gt;I am async!&lt;/div&gt;'
      })
    })
)

app.component('async-example', AsyncComp)</pre> </div>
<p>As you can see, this method accepts a factory function returning a <code>Promise</code>. Promise's <code>resolve</code> callback should be called when you have retrieved your component definition from the server. You can also call <code>reject(reason)</code> to indicate the load has failed.</p> <p>You can also return a <code>Promise</code> in the factory function, so with Webpack 2 or later and ES2015 syntax you can do:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { defineAsyncComponent } from 'vue'

const AsyncComp = defineAsyncComponent(() =&gt;
  import('./components/AsyncComponent.vue')
)

app.component('async-component', AsyncComp)</pre> </div>
<p>You can also use <code>defineAsyncComponent</code> when <a href="component-registration#local-registration">registering a component locally</a>:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { createApp, defineAsyncComponent } from 'vue'

createApp({
  // ...
  components: {
    AsyncComponent: defineAsyncComponent(() =&gt;
      import('./components/AsyncComponent.vue')
    )
  }
})</pre> </div>
<h3 id="using-with-suspense"> Using with Suspense</h3> <p>Async components are <em>suspensible</em> by default. This means if it has a <code>&lt;Suspense&gt;</code> in the parent chain, it will be treated as an async dependency of that <code>&lt;Suspense&gt;</code>. In this case, the loading state will be controlled by the <code>&lt;Suspense&gt;</code>, and the component's own loading, error, delay and timeout options will be ignored.</p> <p>The async component can opt-out of <code>Suspense</code> control and let the component always control its own loading state by specifying <code>suspensible: false</code> in its options.</p> <p>You can check the list of available options in the <a href="../api/global-api#arguments-4">API Reference</a></p>
</div>   <div class="_attribution">
  <p class="_attribution-p">
    <a href="https://v3.vuejs.org/guide/component-dynamic-async.html" class="_attribution-link" target="_blank">https://v3.vuejs.org/guide/component-dynamic-async.html</a>
  </p>
</div>
