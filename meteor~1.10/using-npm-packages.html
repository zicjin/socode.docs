<h2 id="npm-searching">Searching for packages</h2> <p>You can use the official search at <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npmjs.com</a> or see results sorted by package quality (code quality, maintenance status, development velocity, popularity etc.) at <a href="https://npms.io/" target="_blank" rel="noopener">npms.io</a>. There are also sites that search certain types of packages, like <a href="https://js.coach/" target="_blank" rel="noopener">js.coach</a>‘s <a href="https://js.coach/react" target="_blank" rel="noopener">React</a> and <a href="https://js.coach/react-native" target="_blank" rel="noopener">React Native</a> sections.</p> <h2 id="client-npm">npm on the client</h2> <p>Tools like <a href="http://browserify.org" target="_blank" rel="noopener">browserify</a> and <a href="https://webpack.github.io" target="_blank" rel="noopener">webpack</a> are designed to provide a Node-like environment on the client so that many npm packages, even ones originally intended for the server, can run unmodified. In most cases, you can import npm dependencies from a client file, just as you would on the server.</p> <p>When creating a new application Meteor installs the <code>meteor-node-stubs</code> npm package to help provide this client browser compatibility. If you are upgrading an application to Meteor 1.3 you may have to run <code>meteor npm install --save meteor-node-stubs</code> manually.</p> <p>The <code>meteor-node-stubs</code> npm package provides browser-friendly implementations of Node’s built-in modules, like <code>path</code>, <code>buffer</code>, <code>util</code>, etc. Meteor’s module system avoids actually bundling any stub modules (and their dependencies) if they are not used, so there is no cost to keeping <code>meteor-node-stubs</code> in the dependencies. In other words, leave <code>meteor-node-stubs</code> installed unless you really know what you’re doing.</p> <h2 id="installing-npm">Installing npm packages</h2> <p>npm packages are configured in a <code>package.json</code> file at the root of your project. If you create a new Meteor project, you will have such a file created for you. If not you can run <code>meteor npm init</code> to create one.</p> <p>To install a package into your app you run the <code>npm install</code> command with the <code>--save</code> flag:</p>  <pre class="line-numbers" style><code class="language-bash">meteor npm install --save moment
</code></pre> <p>This will both update your <code>package.json</code> with information about the dependency and download the package into your app’s local <code>node_modules</code> directory. Typically, you don’t check the <code>node_modules</code> directory into source control and your teammates run <code>meteor npm install</code> to get up to date when dependencies change:</p>  <pre class="line-numbers" style><code class="language-bash">meteor npm install
</code></pre> <p>If the package is just a development dependency (i.e. it’s used for testing, linting or the like) then you should use <code>--save-dev</code>. That way if you have some kind of build script, it can do <code>npm install --production</code> and avoid installing packages it doesn’t need.</p> <p>For more information about <code>npm install</code>, check out the <a href="https://docs.npmjs.com/getting-started/installing-npm-packages-locally" target="_blank" rel="noopener">official documentation</a>.</p> <blockquote> <p>Meteor comes with npm bundled so that you can type <code>meteor npm</code> without worrying about installing it yourself. If you like, you can also use a globally installed npm to manage your packages.</p> </blockquote> <h2 id="using-npm">Using npm packages</h2> <p>To use an npm package from a file in your application you <code>import</code> the name of the package:</p>  <pre class="line-numbers" style><code class="language-js">import moment from 'moment';

// this is equivalent to the standard node require:
const moment = require('moment');
</code></pre> <p>This imports the default export from the package into the symbol <code>moment</code>.</p> <p>You can also import specific functions from a package using the destructuring syntax:</p>  <pre class="line-numbers" style><code class="language-js">import { isArray } from 'lodash';
</code></pre> <p>You can also import other files or JS entry points from a package:</p>  <pre class="line-numbers" style><code class="language-js">import { parse } from 'graphql/language';
</code></pre> <p>Some Meteor apps contain local Meteor packages (packages defined in the <code>packages/</code> directory of your app tree); this was an older recommendation from before Meteor had full ECMAScript support. If your app is laid out this way, you can also <code>require</code> or <code>import</code> npm packages installed in your app from within your local Meteor packages.</p> <h3 id="npm-styles">Importing styles from npm</h3> <p>Using any of Meteor’s <a href="build-tool#css">supported CSS pre-processors</a> you can import other style files provided by an NPM into your application using both relative and absolute paths. However, this will only work for the top-level app and will not work inside an Atmosphere package.</p> <p>Importing styles from an npm package with an absolute path using the <code>{}</code> syntax, for instance with Less:</p>  <pre class="line-numbers" style><code class="language-less">@import '{}/node_modules/npm-package-name/button.less';
</code></pre> <p>Importing styles from an npm package with a relative path:</p>  <pre class="line-numbers" style><code class="language-less">@import '../../node_modules/npm-package-name/colors.less';
</code></pre> <p>You can also import CSS directly from a JavaScript file to control load order if you have the <code>ecmascript</code> package installed:</p>  <pre class="line-numbers" style><code class="language-js">import 'npm-package-name/stylesheets/styles.css';
</code></pre> <blockquote> <p>When importing CSS from a JavaScript file, that CSS is not bundled with the rest of the CSS processed with the Meteor build tool, but instead is put in your app’s <code>&lt;head&gt;</code> tag inside <code>&lt;style&gt;...&lt;/style&gt;</code> after the main concatenated CSS file.</p> </blockquote> <h3 id="npm-assets">Building with other assets from npm</h3> <p>Meteor also supports building other assets into your app, such as fonts, that are located in your <code>node_modules</code> directory by symbolic linking to those assets from either the <code>/public</code> or <code>/private</code> directories. For example, <code>font-awesome</code> is a very popular font library that provides lots of font-based icons. New icons appear frequently as the library is developed and it would be difficult to manage all the updates if you were to copy the entire <code>font-awesome</code> code base to your own app and git repository. Instead use the following to include these fonts:</p>  <pre class="line-numbers" style><code class="language-clike">cd /public
ln -ls ../node_modules/font-awesome/fonts ./fonts
</code></pre> <p>Any assets made available via symlinks in the <code>/public</code> and <code>/private</code> directories of an application will be copied into the Meteor application bundles when using the <code>meteor build</code> command.</p> <h2 id="recompile">Recompiling npm packages</h2> <p>Meteor does not recompile packages installed in your <code>node_modules</code> by default. However, compilation of specific npm packages (for example, to support older browsers that the package author neglected), can be achieved through the <code>meteor.nodeModules.recompile</code> configuration object in your <code>package.json</code> file.</p> <p>For example:</p>  <pre class="line-numbers" style><code class="language-clike">{
  "name": "your-application",
  ...
  "meteor": {
    "mainModule": ...,
    "testModule": ...,
    "nodeModules": {
      "recompile": {
        "very-modern-package": ["client", "server"],
        "alternate-notation-for-client-and-server": true,
        "somewhat-modern-package": "legacy",
        "another-package": ["legacy", "server"]
      }
    }
  }
}
</code></pre> <p>The keys of the <code>meteor.nodeModules.recompile</code> configuration object are npm package names, and the values specify for which bundles those packages should be recompiled using the Meteor compiler plugins system, as if the packages were part of the Meteor application.</p> <p>For example, if an npm package uses const/let syntax or arrow functions, that’s fine for modern and server code, but you would probably want to recompile the package when building the legacy bundle. To accomplish this, specify <code>"legacy"</code> or <code>["legacy"]</code> as the value of the package’s property, similar to <code>somewhat-modern-package</code> above. These strings and arrays of strings have the same meaning as the second argument to <code>api.addFiles(files, where)</code> in a <code>package.js</code> file.</p> <p>This configuration serves pretty much the same purpose as symlinking an application directory into <code>node_modules/</code>, but without any symlinking: <a href="https://forums.meteor.com/t/litelement-import-litelement-html/45042/8?u=benjamn" target="_blank" rel="noopener">https://forums.meteor.com/t/litelement-import-litelement-html/45042/8?u=benjamn</a></p> <p>The <code>meteor.nodeModules.recompile</code> configuration currently applies to the application <code>node_modules/</code> directory only (not to <code>Npm.depends</code> dependencies in Meteor packages). Recompiled packages must be direct dependencies of the application.</p> <p>Meteor will compile the exposed code as if it was part of your application, using whatever compiler plugins you have installed. You can influence this compilation using <code>.babelrc</code> files or any other techniques you would normally use to configure compilation of application code.</p> <h2 id="npm-shrinkwrap">npm Shrinkwrap</h2> <p><code>package.json</code> typically encodes a version range, and so each <code>npm install</code> command can sometimes lead to a different result if new versions have been published in the meantime. In order to ensure that you and the rest of your team are using the same exact same version of each package, it’s a good idea to use <code>npm shrinkwrap</code> after making any dependency changes to <code>package.json</code>:</p>  <pre class="line-numbers" style><code class="language-bash"># after installing
meteor npm install --save moment
meteor npm shrinkwrap
</code></pre> <p>This will create an <code>npm-shrinkwrap.json</code> file containing the exact versions of each dependency, and you should check this file into source control. For even more precision (the contents of a given version of a package <em>can</em> change), and to avoid a reliance on the npm server during deployment, you should consider using <a href="#npm-shrinkpack"><code>npm shrinkpack</code></a>.</p> <h2 id="async-callbacks">Asyncronous callbacks</h2> <p>Many npm packages rely on an asynchronous, callback or promise-based coding style. For several reasons, Meteor is currently built around a synchronous-looking but still non-blocking style using <a href="https://github.com/laverdet/node-fibers" target="_blank" rel="noopener">Fibers</a>.</p> <p>The global Meteor server context and every method and publication initialize a new fiber so that they can run concurrently. Many Meteor APIs, for example collections, rely on running inside a fiber. They also rely on an internal Meteor mechanism that tracks server “environment” state, like the currently executing method. This means you need to initialize your own fiber and environment to use asynchronous Node code inside a Meteor app. Let’s look at an example of some code that won’t work, using the code example from the <a href="https://github.com/mikedeboer/node-github" target="_blank" rel="noopener">node-github repository</a>:</p>  <pre class="line-numbers" style><code class="language-js">// Inside a Meteor method definition
updateGitHubFollowers() {
  github.user.getFollowingFromUser({
    user: 'stubailo'
  }, (err, res) =&gt; {
    // Using a collection here will throw an error
    // because the asynchronous code is not in a fiber
    Followers.insert(res);
  });
}
</code></pre> <p>Let’s look at a few ways to resolve this issue.</p> <h3 id="bind-environment">`Meteor.bindEnvironment`</h3> <p>In most cases, wrapping the callback in <code>Meteor.bindEnvironment</code> will do the trick. This function both wraps the callback in a fiber, and does some work to maintain Meteor’s server-side environment tracking. Here’s the same code with <code>Meteor.bindEnvironment</code>:</p>  <pre class="line-numbers" style><code class="language-js">// Inside a Meteor method definition
updateGitHubFollowers() {
  github.user.getFollowingFromUser({
    user: 'stubailo'
  }, Meteor.bindEnvironment((err, res) =&gt; {
    // Everything is good now
    Followers.insert(res);
  }));
}
</code></pre> <p>However, this won’t work in all cases - since the code runs asynchronously, we can’t use anything we got from an API in the method return value. We need a different approach that will convert the async API to a synchronous-looking one that will allow us to return a value.</p> <h3 id="wrap-async">`Meteor.wrapAsync`</h3> <p>Many npm packages adopt the convention of taking a callback that accepts <code>(err, res)</code> arguments. If your asynchronous function fits this description, like the one above, you can use <code>Meteor.wrapAsync</code> to convert to a fiberized API that uses return values and exceptions instead of callbacks, like so:</p>  <pre class="line-numbers" style><code class="language-js">// Setup sync API
const getFollowingFromUserFiber =
  Meteor.wrapAsync(github.user.getFollowingFromUser, github.user);

// Inside a Meteor method definition
updateGitHubFollowers() {
  const res = getFollowingFromUserFiber({
    user: 'stubailo'
  });

  Followers.insert(res);

  // Return how many followers we have
  return res.length;
}
</code></pre> <p>If you wanted to refactor this and create a completely fiber-wrapper GitHub client, you could write some logic to loop over all of the methods available and call <code>Meteor.wrapAsync</code> on them, creating a new object with the same shape but with a more Meteor-compatible API.</p> <h3 id="promises">Promises</h3> <p>Recently, a lot of npm packages have been moving to Promises instead of callbacks for their API. This means you actually get a return value from the asynchronous function, but it’s just an empty shell where the real value is filled in later.</p> <p>The good news is that Promises can be used with the new ES2015 <code>async/await</code> syntax (available in the <code>ecmascript</code> package since Meteor 1.3) in a natural and synchronous-looking style on both the client and the server.</p> <p>If you declare your function <code>async</code> (which ends up meaning it returns a Promise itself), then you can use the <code>await</code> keyword to wait on other promise inside. This makes it very easy to serially call Promise-based libraries:</p>  <pre class="line-numbers" style><code class="language-js">async function sendTextMessage(user) {
  const toNumber = await phoneLookup.findFromEmail(user.emails[0].address);
  return await client.sendMessage({
    to: toNumber,
    from: '+14506667788',
    body: 'Hello world!'
  });
}
</code></pre> <h2 id="npm-shrinkpack">Shrinkpack</h2> <p><a href="https://github.com/JamieMason/shrinkpack" target="_blank" rel="noopener">Shrinkpack</a> is a tool that gives you more bulletproof and repeatable builds than you get by using <a href="#npm-shrinkwrap"><code>npm shrinkwrap</code></a> alone.</p> <p>Essentially it copies a tarball of the contents of each of your npm dependencies into your application source repository. This is essentially a more robust version of the <code>npm-shrinkwrap.json</code> file that shrinkwrap creates, because it means your application’s npm dependencies can be assembled without the need or reliance on the npm servers being available or reliable. This is good for repeatable builds especially when deploying.</p> <p>To use shrinkpack, first globally install it:</p>  <pre class="line-numbers" style><code class="language-bash">npm install -g shrinkpack
</code></pre> <p>Then use it directly after you shrinkwrap</p>  <pre class="line-numbers" style><code class="language-bash">meteor npm install --save moment
meteor npm shrinkwrap
shrinkpack
</code></pre> <p>You should then check the generated <code>node_shrinkwrap/</code> directory into source control, but ensure it is ignored by your text editor.</p> <blockquote> <p>NOTE: Although this is a good idea for projects with a lot of npm dependencies, it will not affect Atmosphere dependencies, even if they themselves have direct npm dependencies.</p> </blockquote><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://guide.meteor.com/using-npm-packages.html" class="_attribution-link" target="_blank">https://guide.meteor.com/using-npm-packages.html</a>
  </p>
</div>
