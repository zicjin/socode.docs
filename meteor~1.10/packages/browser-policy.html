<p>The <code>browser-policy</code> family of packages, part of <a href="https://github.com/meteor/meteor/tree/master/packages/webapp" target="_blank" rel="noopener">Webapp</a>, lets you set security-related policies that will be enforced by newer browsers. These policies help you prevent and mitigate common attacks like cross-site scripting and clickjacking.</p> <h2 id="Details">Details</h2>
<p>When you add <code>browser-policy</code> to your app, you get default configurations for the HTTP headers X-Frame-Options and Content-Security-Policy. X-Frame-Options tells the browser which websites are allowed to frame your app. You should only let trusted websites frame your app, because malicious sites could harm your users with <a href="https://www.owasp.org/index.php/Clickjacking" target="_blank" rel="noopener">clickjacking attacks</a>. <a href="https://developer.mozilla.org/en-US/docs/Security/CSP/Introducing_Content_Security_Policy" target="_blank" rel="noopener">Content-Security-Policy</a> tells the browser where your app can load content from, which encourages safe practices and mitigates the damage of a cross-site-scripting attack. <code>browser-policy</code> also provides functions for you to configure these policies if the defaults are not suitable.</p> <p>If you only want to use Content-Security-Policy or X-Frame-Options but not both, you can add the individual packages <code>browser-policy-content</code> or <code>browser-policy-framing</code> instead of <code>browser-policy</code>.</p> <p>For most apps, we recommend that you take the following steps:</p> <ul> <li>Add <code>browser-policy</code> to your app to enable a starter policy. With this starter policy, your app’s client code will be able to load content (images, scripts, fonts, etc.) only from its own origin, except that XMLHttpRequests and WebSocket connections can go to any origin. Further, your app’s client code will not be able to use functions such as <code>eval()</code> that convert strings to code. Users’ browsers will only let your app be framed by web pages on the same origin as your app.</li> <li>You can use the functions described below to customize the policies. If your app does not need any inline Javascript such as inline <code>&lt;script&gt;</code> tags, we recommend that you modify the policy by calling <code>BrowserPolicy.content.disallowInlineScripts()</code> in server code. This will result in one extra round trip when your app is loaded, but will help prevent cross-site scripting attacks by disabling all scripts except those loaded from a <code>script src</code> attribute.</li> </ul> <p>Meteor determines the browser policy when the server starts up, so you should call <code>BrowserPolicy</code> functions on the server in top-level application code or in <code>Meteor.startup</code>. <code>BrowserPolicy</code> functions cannot be used in client code.</p> <h2 id="Usage">Usage</h2>
<h3 id="Frame-options">
Frame options</h3>
<p>By default, if you add <code>browser-policy</code> or <code>browser-policy-framing</code>, only web pages on the same origin as your app are allowed to frame your app. You can use the following functions to modify this policy.</p> <dl> <dt>
<code>BrowserPolicy.framing.disallow()</code>
</dt>
<dd>Your app will never render inside a frame or iframe.</dd> <dt><code>BrowserPolicy.framing.restrictToOrigin(origin)</code></dt> <dd> Your app will only render inside frames loaded by <code>origin</code>. You can only call this function once with a single origin, and cannot use wildcards or specify multiple origins that are allowed to frame your app. (This is a limitation of the X-Frame-Options header.) Example values of <code>origin</code> include "http://example.com" and "https://foo.example.com". <b>This value of the X-Frame-Options header is not yet supported in Chrome or Safari and will be ignored in those browsers. If you need Chrome and/or Safari support, or need to allow multiple domains to frame your application, you can use the frame-ancestors CSP option via the BrowserPolicy.content.allowFrameAncestorsOrigin() function </b> </dd> <dt>
<code>BrowserPolicy.framing.allowAll()</code>
</dt>
<dd> This unsets the X-Frame-Options header, so that your app can be framed by any webpage. </dd> </dl> <h3 id="Content-options">
Content options</h3>
<p>You can use the functions in this section to control how different types of content can be loaded on your site.</p> <p>You can use the following functions to adjust policies on where Javascript and CSS can be run:</p> <dl> <dt><code>BrowserPolicy.content.allowInlineScripts()</code></dt> <dd> Allows inline <code>&lt;script&gt;</code> tags, <code>javascript:</code> URLs, and inline event handlers. The default policy already allows inline scripts. </dd> <dt><code>BrowserPolicy.content.disallowInlineScripts()</code></dt> <dd> Disallows inline Javascript. Calling this function results in an extra round-trip on page load to retrieve Meteor runtime configuration that is usually part of an inline script tag. </dd> <dt><code>BrowserPolicy.content.allowEval()</code></dt> <dd> Allows the creation of Javascript code from strings using function such as <code>eval()</code>. </dd> <dt><code>BrowserPolicy.content.disallowEval()</code></dt> <dd> Disallows eval and related functions. Note: The default policy disallows eval, though for almost all Meteor apps it is enabled by the `dynamic-imports` package </dd> <dt><code>BrowserPolicy.content.allowInlineStyles()</code></dt> <dd> Allows inline style tags and style attributes. The default policy already allows inline styles. </dd> <dt><code>BrowserPolicy.content.disallowInlineStyles()</code></dt> <dd> Disallows inline CSS. </dd> </dl> <p>Finally, you can configure a whitelist of allowed requests that various types of content can make. The following functions are defined for the content types script, object, image, media, font, frame, frame-ancestors, style, and connect.</p> <dl> <dt><code>BrowserPolicy.content.allow&lt;ContentType&gt;Origin(origin)</code></dt> <dd> Allows this type of content to be loaded from the given origin. <code>origin</code> is a string and can include an optional scheme (such as <code>http</code> or <code>https</code>), an optional wildcard at the beginning, and an optional port which can be a wildcard. Examples include <code>example.com</code>, <code>https://*.example.com</code>, and <code>example.com:*</code>. You can call these functions multiple times with different origins to specify a whitelist of allowed origins. Origins that don't specify a protocol will allow content over both HTTP and HTTPS: passing <code>example.com</code> will allow content from both <code>http://example.com</code> and <code>https://example.com</code>. 
</dd>
<dt><code>BrowserPolicy.content.allow&lt;ContentType&gt;DataUrl()</code></dt> <dd> Allows this type of content to be loaded from a <code>data:</code> URL. </dd> <dt><code>BrowserPolicy.content.allow&lt;ContentType&gt;SameOrigin()</code></dt> <dd> Allows this type of content to be loaded from the same origin as your app. </dd> <dt><code>BrowserPolicy.content.disallow&lt;ContentType&gt;()</code></dt> <dd> Disallows this type of content on your app. </dd> </dl> <p>You can also set policies for all these types of content at once, using these functions:</p> <ul> <li>
<code>BrowserPolicy.content.allowSameOriginForAll()</code>,</li> <li>
<code>BrowserPolicy.content.allowDataUrlForAll()</code>,</li> <li><code>BrowserPolicy.content.allowOriginForAll(origin)</code></li> <li><code>BrowserPolicy.content.disallowAll()</code></li> </ul> <p>For example, if you want to allow the origin <code>https://foo.com</code> for all types of content but you want to disable <code>&lt;object&gt;</code> tags, you can call <code>BrowserPolicy.content.allowOriginForAll("https://foo.com")</code> followed by <code>BrowserPolicy.content.disallowObject()</code>.</p> <p>Other examples of using the <code>BrowserPolicy.content</code> API:</p> <ul> <li>
<code>BrowserPolicy.content.disallowFont()</code> causes the browser to disallow all <code>&lt;font&gt;</code> tags.</li> <li>
<code>BrowserPolicy.content.allowImageOrigin("https://example.com")</code> allows images to have their <code>src</code> attributes point to images served from <code>https://example.com</code>.</li> <li>
<code>BrowserPolicy.content.allowConnectOrigin("https://example.com")</code> allows XMLHttpRequest and WebSocket connections to <code>https://example.com</code>.</li> <li>
<code>BrowserPolicy.content.allowFrameOrigin("https://example.com")</code> allows your site to load the origin <code>https://example.com</code> in a frame or iframe. The <code>BrowserPolicy.framing</code> API allows you to control which sites can frame your site, while <code>BrowserPolicy.content.allowFrameOrigin</code> allows you to control which sites can be loaded inside frames on your site.</li> </ul> <p>Adding <code>browser-policy-content</code> to your app also tells certain browsers to avoid sniffing content types away from the declared type (for example, interpreting a text file as JavaScript), using the <a href="http://msdn.microsoft.com/en-us/library/ie/gg622941%28v=vs.85%29.aspx" target="_blank" rel="noopener">X-Content-Type-Options</a> header. To re-enable content sniffing, you can call <code>BrowserPolicy.content.allowContentTypeSniffing()</code>.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://docs.meteor.com/packages/browser-policy.html" class="_attribution-link" target="_blank">https://docs.meteor.com/packages/browser-policy.html</a>
  </p>
</div>
