<p>The <code>webapp</code> package is what lets your Meteor app serve content to a web browser. It is included in the <code>meteor-base</code> set of packages that is automatically added when you run <code>meteor create</code>. You can easily build a Meteor app without it - for example if you wanted to make a command-line tool that still used the Meteor package system and DDP.</p> <p>This package also allows you to add handlers for HTTP requests. This lets other services access your app’s data through an HTTP API, allowing it to easily interoperate with tools and frameworks that don’t yet support DDP.</p> <p><code>webapp</code> exposes the <a href="https://github.com/senchalabs/connect" target="_blank" rel="noopener">connect</a> API for handling requests through <code>WebApp.connectHandlers</code>. Here’s an example that will let you handle a specific URL:</p>  <pre class="line-numbers" style><code class="language-js">// Listen to incoming HTTP requests (can only be used on the server).
WebApp.connectHandlers.use('/hello', (req, res, next) =&gt; {
  res.writeHead(200);
  res.end(`Hello world from: ${Meteor.release}`);
});
</code></pre>  <h2 class="api-heading" id="WebApp-connectHandlers"> <div class="locus"> Server </div> <code>WebApp.connectHandlers([path], handler)</code> <div class="subtext-api"> <code>import { WebApp } from 'meteor/webapp'</code> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/webapp/webapp_server.js#L1163" target="_blank"> (webapp/webapp_server.js, line 1163) </a> </div> </h2>   <p>Register a handler for all HTTP requests.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>path</code> <span class="type">String</span> </dt> <dd> <p>This handler will only be called on paths that match this string. The match has to border on a <code>/</code> or a <code>.</code>.</p> <p>For example, <code>/hello</code> will match <code>/hello/world</code> and <code>/hello.world</code>, but not <code>/hello_world</code>.</p> </dd> <dt> <code>handler</code> <span class="type">connectHandlersCallback</span> </dt> <dd> <p>A handler function that will be called on HTTP requests. See <code>connectHandlersCallback</code></p> </dd> </dl>    <h2 class="api-heading" id="connectHandlersCallback(req,"> <div class="locus"> Server </div> <code>connectHandlersCallback(req, res, next)</code>  </h2>   <p>callback handler for <code>WebApp.connectHandlers</code></p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>req</code> <span class="type">Object</span> </dt> <dd> <p>a Node.js <a href="https://nodejs.org/api/http.html#http_class_http_incomingmessage" target="_blank" rel="noopener">IncomingMessage</a> object with some extra properties. This argument can be used to get information about the incoming request.</p> </dd> <dt> <code>res</code> <span class="type">Object</span> </dt> <dd> <p>a Node.js <a href="http://nodejs.org/api/http.html#http_class_http_serverresponse" target="_blank" rel="noopener">ServerResponse</a> object. Use this to write data that should be sent in response to the request, and call <code>res.end()</code> when you are done.</p> </dd> <dt> <code>next</code> <span class="type">Function</span> </dt> <dd> <p>Calling this function will pass on the handling of this request to the next relevant handler.</p> </dd> </dl>   <h3 id="Serving-a-Static-Landing-Page">
Serving a Static Landing Page</h3>
<p>One of the really cool things you can do with WebApp is serve static HTML for a landing page where TTFB (time to first byte) is of utmost importance.</p> <p>The <a href="bundle-visualizer">Bundle Visualizer</a> and <a href="dynamic-import">Dynamic Imports</a> are great tools to help you minimize initial page load times. But sometimes you just need to skinny down your initial page load to bare metal.</p> <p>The good news is that WebApp makes this is really easy to do.</p> <p>Step one is to create a your static HTML file and place it in the <em>private</em> folder at the root of your application.</p> <p>Here’s a sample <em>index.html</em> you might use to get started:</p>  <pre class="line-numbers" style><code class="language-clike">&lt;head&gt;
    &lt;title&gt;Fast Landing Page&lt;/title&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;meta http-equiv="x-ua-compatible" content="ie=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0 user-scalable=no" /&gt;   
    &lt;link rel="stylesheet" href="path to your style sheet etc"&gt;
&lt;/head&gt;

    &lt;body&gt;
        &lt;!-- your content --&gt;
    &lt;/body&gt;

    &lt;script&gt;

    // any functions you need to support your landing page
 
    &lt;/script&gt;

&lt;/html&gt;
</code></pre> <p>Then using the connectHandlers method described above serve up your static HTML on app-root/ page load as shown below.</p>  <pre class="line-numbers" style><code class="language-clike">/* global WebApp Assets */
import crypto from 'crypto'
import connectRoute from 'connect-route'

WebApp.connectHandlers.use(connectRoute(function (router) {
    router.get('/', function (req, res, next) {
        const buf = Assets.getText('index.html')

        if (buf.length &gt; 0) {
            const eTag = crypto.createHash('md5').update(buf).digest('hex')

            if (req.headers['if-none-match'] === eTag) {
                res.writeHead(304, 'Not Modified')
                return res.end()
            }

            res.writeHead(200, {
                ETag: eTag,
                'Content-Type': 'text/html'
            })

            return res.end(buf);
        }

        return res.end('&lt;html&gt;&lt;body&gt;Index page not found!&lt;/body&gt;&lt;/html&gt;')
    })
}))
</code></pre> <p>There are a couple things to think about with this approach.</p> <p>We’re reading the contents of index.html using the <a href="../api/assets">Assets</a> module that makes it really easy to read files out of the <em>private</em> root folder.</p> <p>We’re using the <a href="https://www.npmjs.com/package/connect-route" target="_blank" rel="noopener">connect-route</a> NPM package to simplify WebApp route processing. But you can use any package you want to understand what is being requested.</p> <p>And finally, if you decide to use this technique you’ll want to make sure you understand how conflicting client side routing will affect user experience.</p> <h3 id="Dynamic-Runtime-Configuration">
Dynamic Runtime Configuration</h3>
<p>In some cases it is valuable to be able to control the <strong>meteor_runtime_config</strong> variable that initializes Meteor at runtime.</p> <h4 id="Example">
Example</h4>
<p>There are occasions when a single Meteor server would like to serve multiple cordova applications that each have a unique <code>ROOT_URL</code>. But there are 2 problems:</p> <ol> <li>The Meteor server can only be configured to serve a single <code>ROOT_URL</code>.</li> <li>The <code>cordova</code> applications are build time configured with a specific <code>ROOT_URL</code>.</li> </ol> <p>These 2 conditions break <code>autoupdate</code> for the cordova applications. <code>cordova-plugin-meteor-webapp</code> will fail the update if the <code>ROOT_URL</code> from the server does not match the build time configured <code>ROOT_URL</code> of the cordova application.</p> <p>To remedy this problem <code>webapp</code> has a hook for dynamically configuring <code>__meteor_runtime_config__</code> on the server.</p> <h4 id="Dynamic-Runtime-Configuration-Hook">
Dynamic Runtime Configuration Hook</h4>  <pre class="line-numbers" style><code class="language-js">WebApp.addRuntimeConfigHook(({arch, request, encodedCurrentConfig, updated}) =&gt; {
 // check the request to see if this is a request that requires
 // modifying the runtime configuration
  if(request.headers.domain === 'calling.domain') {
    // make changes to the config for this domain
    // decode the current runtime config string into an object
    const config = WebApp.decodeRuntimeConfig(current);
    // make your changes
    config.newVar = 'some value';
    config.oldVar = 'new value';
    // encode the modified object to the runtime config string
    // and return it
    return WebApp.encodeRuntimeConfig(config);
  }
  // Not modifying other domains so return undefined
  return undefined;
})
</code></pre>  <h2 class="api-heading" id="WebApp-addRuntimeConfigHook"> <div class="locus"> Server </div> <code>WebApp.addRuntimeConfigHook(callback)</code> <div class="subtext-api"> <code>import { WebApp } from 'meteor/webapp'</code> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/webapp/webapp_server.js#L419" target="_blank"> (webapp/webapp_server.js, line 419) </a> </div> </h2>   <p>Hook that calls back when the meteor runtime configuration, <code>__meteor_runtime_config__</code> is being sent to any client.</p> <p><strong>returns</strong>: <small><em>Object</em></small> <code>{ stop: function, callback: function }</code></p> <ul> <li>
<code>stop</code> <small><em>Function</em></small> Call <code>stop()</code> to stop getting callbacks.</li> <li>
<code>callback</code> <small><em>Function</em></small> The passed in <code>callback</code>.</li> </ul>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>callback</code> <span class="type">addRuntimeConfigHookCallback</span> </dt> <dd> <p>See <code>addRuntimeConfigHookCallback</code> description.</p> </dd> </dl>    <h2 class="api-heading" id="addRuntimeConfigHookCallback(options)"> <div class="locus"> Server </div> <code>addRuntimeConfigHookCallback(options)</code>  </h2>   <p>Callback for <code>addRuntimeConfigHook</code>.</p> <p>If the handler returns a <em>falsy</em> value the hook will not modify the runtime configuration.</p> <p>If the handler returns a <em>String</em> the hook will substitute the string for the encoded configuration string.</p> <p><strong>Warning:</strong> the hook does not check the return value at all it is the responsibility of the caller to get the formatting correct using the helper functions.</p> <p><code>addRuntimeConfigHookCallback</code> takes only one <code>Object</code> argument with the following fields:</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>options.arch</code> <span class="type">String</span> </dt> <dd> <p>The architecture of the client requesting a new runtime configuration. This can be one of <code>web.browser</code>, <code>web.browser.legacy</code> or <code>web.cordova</code>.</p> </dd> <dt> <code>options.request</code> <span class="type">Object</span> </dt> <dd> <p>A NodeJs <a href="https://nodejs.org/api/http.html#http_class_http_incomingmessage" target="_blank" rel="noopener">IncomingMessage</a> https://nodejs.org/api/http.html#http_class_http_incomingmessage <code>Object</code> that can be used to get information about the incoming request.</p> </dd> <dt> <code>options.encodedCurrentConfig</code> <span class="type">String</span> </dt> <dd> <p>The current configuration object encoded as a string for inclusion in the root html.</p> </dd> <dt> <code>options.updated</code> <span class="type">Boolean</span> </dt> <dd> <p><code>true</code> if the config for this architecture has been updated since last called, otherwise <code>false</code>. This flag can be used to cache the decoding/encoding for each architecture.</p> </dd> </dl>   <p>Additionally, 2 helper functions are available to decode the runtime config string and encode the runtime config object.</p>  <h2 class="api-heading" id="WebApp-decodeRuntimeConfig"> <div class="locus"> Server </div> <code>WebApp.decodeRuntimeConfig(rtimeConfigString)</code> <div class="subtext-api"> <code>import { WebApp } from 'meteor/webapp'</code> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/webapp/webapp_server.js#L350" target="_blank"> (webapp/webapp_server.js, line 350) </a> </div> </h2>   <p>Takes an encoded runtime string and returns a runtime configuration object.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>rtimeConfigString</code> <span class="type">String</span> </dt>  </dl>    <h2 class="api-heading" id="WebApp-encodeRuntimeConfig"> <div class="locus"> Server </div> <code>WebApp.encodeRuntimeConfig(rtimeConfig)</code> <div class="subtext-api"> <code>import { WebApp } from 'meteor/webapp'</code> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/webapp/webapp_server.js#L339" target="_blank"> (webapp/webapp_server.js, line 339) </a> </div> </h2>   <p>Takes a runtime configuration object and returns an encoded runtime string.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>rtimeConfig</code> <span class="type">Object</span> </dt>  </dl>   <h3 id="Updated-Runtime-Configuration-Hook">
Updated Runtime Configuration Hook</h3>  <pre class="line-numbers" style><code class="language-js">const autoupdateCache;
// Get a notification when the runtime configuration is updated
// for each arch
WebApp.addUpdatedNotifyHook(({arch, manifest, runtimeConfig}) =&gt; {
  // Example, see if runtimeConfig.autoupdate has changed and if so
  // do something
  if(!_.isEqual(autoupdateCache, runtimeConfig.autoupdate)) {
    autoupdateCache = runtimeConfig.autoupdate;
    // do something...
  }
})
</code></pre>  <h2 class="api-heading" id="WebApp-addUpdatedNotifyHook"> <div class="locus"> Server </div> <code>WebApp.addUpdatedNotifyHook(handler)</code> <div class="subtext-api"> <code>import { WebApp } from 'meteor/webapp'</code> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/webapp/webapp_server.js#L494" target="_blank"> (webapp/webapp_server.js, line 494) </a> </div> </h2>   <p>Hook that runs when the meteor runtime configuration is updated. Typically the configuration only changes during development mode.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>handler</code> <span class="type">addUpdatedNotifyHookCallback</span> </dt> <dd> <p>The <code>handler</code> is called on every change to an <code>arch</code> runtime configuration. See <code>addUpdatedNotifyHookCallback</code>.</p> </dd> </dl>    <h2 class="api-heading" id="addUpdatedNotifyHookCallback(options)"> <div class="locus"> Server </div> <code>addUpdatedNotifyHookCallback(options)</code>  </h2>   <p>callback handler for <code>addupdatedNotifyHook</code></p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>options.arch</code> <span class="type">String</span> </dt> <dd> <p>The architecture that is being updated. This can be one of <code>web.browser</code>, <code>web.browser.legacy</code> or <code>web.cordova</code>.</p> </dd> <dt> <code>options.manifest</code> <span class="type">Object</span> </dt> <dd> <p>The new updated manifest object for this <code>arch</code>.</p> </dd> <dt> <code>options.runtimeConfig</code> <span class="type">Object</span> </dt> <dd> <p>The new updated configuration object for this <code>arch</code>.</p> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://docs.meteor.com/packages/webapp.html" class="_attribution-link" target="_blank">https://docs.meteor.com/packages/webapp.html</a>
  </p>
</div>
