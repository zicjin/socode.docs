<blockquote> <p><strong>Note:</strong> Dynamic imports require Meteor 1.5 or higher.</p> </blockquote> <p>The <code>dynamic-import</code> package provides an implementation of <code>Module.prototype.dynamicImport</code>, an extension of the module runtime which powers the <a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">dynamic <code>import(...)</code></a> statement, an up-and-coming (ECMA2020) addition to the ECMAScript standard.</p> <p>The dynamic <code>import(...)</code> statement is a complementary method to the static <code>import</code> technique of requiring a module. While a statically <nobr><code>import</code>-ed </nobr>module would be bundled into the initial JavaScript bundle, a dynamically <nobr><code>import()</code>-ed</nobr> module is fetched from the server at runtime.</p> <p>Once a module is fetched dynamically from the server, it is cached permanently on the client and additional requests for the same version of the module will not incur the round-trip request to the server. If the module is changed then a fresh copy will always be retrieved from the server.</p> <h2 id="Usage">Usage</h2>
<p>The <code>import(...)</code> statement returns a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises" target="_blank" rel="noopener"><code>Promise</code></a> which is resolved with the <code>exports</code> of the module when it has been successfully fetched from the server and is ready to be used.</p> <p>Because it’s a <code>Promise</code>, there are a couple methods developers can use to dictate what will happen upon the availability of the dynamically loaded module:</p> <h3 id="The-then-method-of-the-Promise">
The <code>.then()</code> method of the <code>Promise</code>
</h3>  <pre class="line-numbers" style><code class="language-js">import("tool").then(tool =&gt; tool.task());
</code></pre> <h3 id="By-await-ing-in-an-asynchronous-function">
By <code>await</code>-ing in an asynchronous function</h3>
<p>Meteor supports <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener"><code>async</code> and <code>await</code></a>, which provide a straightforward approach to asynchronously wait for the module to be ready without the need to provide a callback:</p>  <pre class="line-numbers" style><code class="language-js">async function performTask() {
  const tool = await import("tool");
  tool.task();
}
</code></pre> <blockquote>
<p><strong>Default exports</strong></p> <p>The <code>import(...)</code> <code>Promise</code> is resolved with the <code>exports</code> of the module. If it’s necessary to use the “default” export from a module, it will be available on the <code>default</code> property of the resulting object. In the above examples, this means it will be available as <code>tool.default</code>. It can be helpful to use parameter de-structuring to provide additional clarity:</p>  <pre class="line-numbers" style><code class="language-js">import("another-tool").then(({ default: thatTool }) =&gt; thatTool.go());
</code></pre> </blockquote> <h3 id="Using-import-with-dynamic-expressions">
Using <code>import()</code> with dynamic expressions</h3>
<p>If you try to import using any computed expression, such as:</p>  <pre class="line-numbers" style><code class="language-js">let path = 'example';
const module = await import(`/libs/${path}.js`);
</code></pre> <p>You’ll get an error like so:</p>  <pre class="line-numbers" style><code class="language-js">Error: Cannot find module '/libs/example.js'
</code></pre> <p>Meteor’s build process builds a graph of all files that are imported or required using static analysis. It then creates exact bundles of the referenced files and makes them available to the client for <code>import()</code>.</p> <p>Without a complete import statement (static, dynamic or <code>require</code>), Meteor won’t make that module available for <code>import()</code>.</p> <p>The solution to make dynamic expressions work is to create a module “whitelist” that can be read by the build process, but does not actually run. For example:</p>  <pre class="line-numbers" style><code class="language-js">if (false) {
  import("/libs/example.js");
  import("/libs/another-example.js");
  import("/libs/yet-another-example.js");
}
</code></pre> <p>Make sure the whitelist is imported from both the client and server entry points.</p> <h2 id="Difference-to-other-bundling-systems">Difference to other bundling systems</h2>
<p>In Meteor’s implementation, the client has perfect information about which modules were in the initial bundle, which modules are in the local cache, and which modules still need to be fetched. There is never any overlap between requests made by a single client, nor will there be any unneeded modules in the response from the server. You might call this strategy <strong>exact code splitting</strong>, to differentiate it from bundling.</p> <p>Moreover, the initial bundle includes the hashes of all available dynamic modules, so the client doesn’t have to ask the server if it can use a cached version of a module, and the same version of the module never needs to be downloaded again by the same client. This caching system has all the benefits of immutable caching.</p> <p>Meteor also allows dynamic expressions as long as the dependency is expressed statically somewhere else in your code. This is possible because Meteor’s client-side module system understands how to resolve dynamic strings at runtime (which is not true in webpack or browserify, because they replace module identifier strings with numbers). However, the set of available modules is constrained by the string literals that you, the programmer, explicitly decided to allow to be imported (either directly or in a whitelist).</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://docs.meteor.com/packages/dynamic-import.html" class="_attribution-link" target="_blank">https://docs.meteor.com/packages/dynamic-import.html</a>
  </p>
</div>
