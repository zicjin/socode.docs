<p>The Meteor build system is the actual command line tool that you get when you install Meteor. You run it by typing the <code>meteor</code> command in your terminal, possibly followed by a set of arguments. Read the <a href="https://docs.meteor.com/commandline.html" target="_blank" rel="noopener">docs about the command line tool</a> or type <code>meteor help</code> in your terminal to learn about all of the commands.</p> <h2 id="what-it-does">What does it do?</h2> <p>The Meteor build tool is what compiles, runs, deploys, and publishes all of your Meteor apps and packages. It’s Meteor’s built-in solution to the problems also solved by tools like Grunt, Gulp, Webpack, Browserify, Nodemon, and many others, and uses many popular Node.js tools like Babel and UglifyJS internally to enable a seamless experience.</p> <h3 id="reload-on-file-change">Reloads app on file change</h3> <p>After executing the <code>meteor</code> command to start the build tool you should leave it running while further developing your app. The build tool automatically detects any relevant file changes using a file watching system and recompiles the necessary changes, restarting your client or server environment as needed. <a href="#hot-module-replacement">Hot module replacement</a> can optionally be used so you can view and test your changes even quicker.</p> <h3 id="compiles-with-build-plugins">Compiles files with build plugins</h3> <p>The main function of the Meteor build tool is to run “build plugins”. These plugins define different parts of your app build process. Meteor puts heavy emphasis on reducing or removing build configuration files, so you won’t see any large build process config files like you would in Gulp or Webpack. The Meteor build process is configured almost entirely through adding and removing packages to your app and putting files in specially named directories. For example, to get all of the newest stable ES2015 JavaScript features in your app, you add the <a href="http://docs.meteor.com/#/full/ecmascript" target="_blank" rel="noopener"><code>ecmascript</code> package</a>. This package provides support for ES2015 modules, which gives you even more fine grained control over file load order using ES2015 <code>import</code> and <code>export</code>. As new Meteor releases add new features to this package you get them for free.</p> <h4 id="controlling-build-files">Controlling which files to build</h4> <p>By default Meteor will build certain files as controlled by your application <a href="structure#javascript-structure">file structure</a> and Meteor’s <a href="structure#load-order">default file load order</a> rules. However, you may override the default behavior using <code>.meteorignore</code> files, which cause the build system to ignore certain files and directories using the same pattern syntax as <code>.gitignore</code> files. These files may appear in any directory of your app or package, specifying rules for the directory tree below them. These <code>.meteorignore</code> files are also fully integrated with Meteor’s file watching system, so they can be added, removed, or modified during development.</p> <h3 id="concatenate-and-minify">Combines and minifies code</h3> <p>Another important feature of the Meteor build tool is that it automatically concatenates your application asset files, and in production minifies these bundles. This lets you add all of the comments and whitespace you want to your source code and split your code into as many files as necessary, all without worrying about app performance and load times. This is enabled by the <a href="https://atmospherejs.com/meteor/standard-minifiers-js" target="_blank" rel="noopener"><code>standard-minifier-js</code></a> and <a href="https://atmospherejs.com/meteor/standard-minifiers-css" target="_blank" rel="noopener"><code>standard-minifier-css</code></a> packages, which are included in all Meteor apps by default. If you need different minification behavior, you can replace these packages. See adding <a href="#postcss">PostCSS to your build process</a> as an example.</p> <h3 id="dev-vs-prod">Development vs. production</h3> <p>Running an app in development is all about fast iteration time. All kinds of different parts of your app are handled differently and instrumented to enable better reloads and debugging. In production, the app is reduced to the necessary code and functions just like any standard Node.js app. Therefore, you shouldn’t run your app in production by executing the <code>meteor run</code> command. Instead, follow the directions in <a href="deployment#deploying">Deploying Meteor Applications</a>. If you find an error in production that you suspect is related to minification, you can run the minified version of your app locally for testing with <code>meteor --production</code>.</p> <h2 id="javascript-transpilation">JavaScript transpilation</h2> <p>These days, the landscape of JavaScript tools and frameworks is constantly shifting, and the language itself is evolving just as rapidly. It’s no longer reasonable to wait for web browsers to implement the language features you want to use. Most JavaScript development workflows rely on compiling code to work on the lowest common denominator of environments, while letting you use the newest features in development. Meteor has support for some of the most popular tools out of the box.</p> <h3 id="es2015">ES2015+ (recommended)</h3> <p>The <code>ecmascript</code> package (which is installed into all new apps and packages by default, but can be removed), allows support for many ES2015 features. We recommend using it. You can read more about it in the <a href="code-style#ecmascript">Code Style</a> article.</p> <h3 id="es2015">Babel</h3> <p>Babeljs is a configurable transpiler, which allows you write code in the latest version of JavaScript even when your supported environments don’t support certain features natively. Babel will compile those features down to a supported version.</p> <p> Meteor provides a set appropriate core plugins for each environment (Node 8, modern browsers, and legacy browsers) and React to support most modern Javascript code practices. In addition, Meteor (as of 1.3.3) supports custom .babelrc files which allows developers to further customise their Babel configuration to suit there needs (e.g. Stage 0 proposals).</p> <p> Developers are encouraged to avoid adding large presets (such as babel-preset-env &amp; babel-preset-react) and adding specific plugins as needed (even though it seems to work). You will avoid unnecessary Babel compilation and you’ll be less likely to experience plugin ordering issues.</p> <h3 id="coffeescript">CoffeeScript</h3> <p>While we recommend using ES2015 with the <code>ecmascript</code> package as the best development experience for Meteor, everything in the platform is 100% compatible with <a href="http://coffeescript.org/" target="_blank" rel="noopener">CoffeeScript</a> and many people in the Meteor community prefer it.</p> <p>All you need to do to use CoffeeScript is add the right Meteor package:</p>  <pre class="line-numbers" style><code class="language-sh">meteor add coffeescript
</code></pre> <p>All code written in CoffeeScript compiles to JavaScript under the hood, and is completely compatible with any code in other packages that is written in JS or ES2015.</p> <h3 id="typescript">TypeScript</h3> <p><a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">TypeScript</a> is modern JavaScript with optional types and more.</p> <p>Adding types will make your code more readable and less prone to runtime errors.</p> <p>TypeScript can be installed with:</p>  <pre class="line-numbers" style><code class="language-sh">meteor add typescript
</code></pre> <p>It is necessary to configure the TypeScript compiler with a <code>tsconfig.json</code> file. Here’s the one generated by <code>meteor create --typescript</code>:</p>  <pre class="line-numbers" style><code class="language-clike">{
  "compilerOptions": {
    /* Basic Options */
    "target": "es2018",
    "module": "esNext",
    "lib": ["esnext", "dom"],
    "allowJs": true,
    "checkJs": false,
    "jsx": "preserve",
    "incremental": true,
    "noEmit": true,

    /* Strict Type-Checking Options */
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,

    /* Additional Checks */
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": false,
    "noFallthroughCasesInSwitch": false,

    /* Module Resolution Options */
    "baseUrl": ".",
    "paths": {
      /* Support absolute /imports/* with a leading '/' */
      "/*": ["*"]
    },
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "types": ["node", "mocha"],
    "esModuleInterop": true,
    "preserveSymlinks": true
  },
  "exclude": [
    "./.meteor/**",
    "./packages/**"
  ]
}
</code></pre> <p>If you want to add TypeScript from the point of project creation, as of Meteor 1.8.2, you can run the create command with the –typescript flag:</p>  <pre class="line-numbers" style><code class="language-clike">meteor create --typescript name-of-my-new-typescript-app
</code></pre> <h4 id="typescript-conditional-imports">Conditional imports</h4> <p>TypeScript does not support nested <code>import</code> statements, therefore conditionally importing modules requires you to use the <code>require</code> statement (see <a href="structure#using-require">Using <code>require</code></a>).</p> <p>To maintain type safety, you can take advantage of TypeScript’s import elision and reference the types using the <code>typeof</code> keyword. See the <a href="https://www.typescriptlang.org/docs/handbook/modules.html#optional-module-loading-and-other-advanced-loading-scenarios" target="_blank" rel="noopener">TypeScript handbook article</a> for details or <a href="http://ideasintosoftware.com/typescript-conditional-imports/" target="_blank" rel="noopener">this blog post</a> for a concrete Meteor example.</p> <h2 id="blaze-templates">Templates and HTML</h2> <p>Since Meteor uses client-side rendering for your app’s UI, all of your HTML code, UI components, and templates need to be compiled to JavaScript. There are a few options at your disposal to write your UI code.</p> <h3 id="blaze-spacebars">Blaze HTML templates</h3> <p>The aptly named <code>blaze-html-templates</code> package that comes with every new Meteor app by default compiles your <code>.html</code> files written using <a href="http://blazejs.org/api/spacebars.html" target="_blank" rel="noopener">Spacebars</a> into Blaze-compatible JavaScript code. You can also add <code>blaze-html-templates</code> to any of your packages to compile template files located in the package.</p> <p><a href="http://blazejs.org/guide/spacebars.html" target="_blank" rel="noopener">Read about how to use Blaze and Spacebars in the Blaze article.</a></p> <h3 id="blaze-jade">Blaze Jade templates</h3> <p>If you don’t like the Spacebars syntax Meteor uses by default and want something more concise, you can give Jade a try by using <a href="https://atmospherejs.com/pacreach/jade" target="_blank" rel="noopener"><code>pacreach:jade</code></a>. This package will compile all files in your app with the <code>.jade</code> extension into Blaze-compatible code, and can be used side-by-side with <code>blaze-html-templates</code> if you want to have some of your code in Spacebars and some in Jade.</p> <h3 id="react-jsx">JSX for React</h3> <p>If you’re building your app’s UI with React, currently the most popular way to write your UI components involves JSX, an extension to JavaScript that allows you to type HTML tags that are converted to React DOM elements. JSX code is handled automatically by the <code>ecmascript</code> package.</p> <h4 id="react-other">Other options for React</h4> <p>If you want to use React but don’t want to deal with JSX and prefer a more HTML-like syntax, there are a few community options available. One that stands out in particular is <a href="https://github.com/timbrandin/blaze-react" target="_blank" rel="noopener">Blaze-React</a>, which simulates the entire Blaze API using React as a rendering engine.</p> <h2 id="css">CSS processing</h2> <p>All your CSS style files will be processed using Meteor’s default file load order rules along with any import statements and concatenated into a single stylesheet, <code>merged-stylesheets.css</code>. In a production build this file is also minified. By default this single stylesheet is injected at the beginning of the HTML <code>&lt;head /&gt;</code> section of your application.</p> <p>However, this can potentially be an issue for some applications that use a third party UI framework, such as Bootstrap, which is loaded from a CDN. This could cause Bootstrap’s CSS to come after your CSS and override your user-defined styles.</p> <p>To get around this problem Meteor supports the use of a pseudo tag <code>&lt;meteor-bundled-css /&gt;</code> that if placed anywhere in the <code>&lt;head /&gt;</code> section your app will be replaced by a link to this concatenated CSS file. If this pseudo tag isn’t used, the CSS file will be placed at the beginning of the </p>
<meta name="generator" content="Hexo 3.9.0"> section as before. <h3 id="css-which-preprocessor">CSS pre-processors</h3> <p>It’s no secret that writing plain CSS can often be a hassle as there’s no way to share common CSS code between different selectors or have a consistent color scheme between different elements. CSS compilers, or pre-processors, solve these issues by adding extra features on top of the CSS language like variables, mixins, math, and more, and in some cases also significantly change the syntax of CSS to be easier to read and write.</p> <p>Here are three example CSS pre-processors supported by Meteor:</p> <ol> <li><a href="http://sass-lang.com/" target="_blank" rel="noopener">Sass</a></li> <li><a href="http://lesscss.org/" target="_blank" rel="noopener">Less.js</a></li> <li><a href="https://learnboost.github.io/stylus/" target="_blank" rel="noopener">Stylus</a></li> </ol> <p>They all have their pros and cons, and different people have different preferences, just like with JavaScript transpiled languages. Sass with the SCSS syntax is quite popular as CSS frameworks like Bootstrap 4 have switched to Sass, and the C++ LibSass implementation appears to be faster than some of the other compilers available.</p> <p>CSS framework compatibility should be a primary concern when picking a pre-processor, because a framework written with Less won’t be compatible with one written in Sass.</p> <h3 id="css-source-vs-import">Source vs. import files</h3> <p>An important feature shared by all of the available CSS pre-processors is the ability to import files. This lets you split your CSS into smaller pieces, and provides a lot of the same benefits that you get from JavaScript modules:</p> <ol> <li>You can control the load order of files by encoding dependencies through imports, since the load order of CSS matters.</li> <li>You can create reusable CSS “modules” that only have variables and mixins and don’t actually generate any CSS.</li> </ol> <p>In Meteor, each of your <code>.scss</code>, <code>.less</code>, or <code>.styl</code> source files will be one of two types: “source” or “import”.</p> <p>A “source” file is evaluated eagerly and adds its compiled form to the CSS of the app immediately.</p> <p>An “import” file is evaluated only if imported from some other file and can be used to share common mixins and variables between different CSS files in your app.</p> <p>Read the documentation for each package listed below to see how to indicate which files are source files vs. imports.</p> <h3 id="css-importing">Importing styles</h3> <p>In all three Meteor supported CSS pre-processors you can import other style files from both relative and absolute paths in your app and from both npm and Meteor Atmosphere packages.</p>  <pre class="line-numbers" style><code class="language-less">@import '../stylesheets/colors.less';   // a relative path
@import '{}/imports/ui/stylesheets/button.less';   // absolute path with `{}` syntax
</code></pre> <p>You can also import CSS from a JavaScript file if you have the <code>ecmascript</code> package installed:</p>  <pre class="line-numbers" style><code class="language-js">import '../stylesheets/styles.css';
</code></pre> <blockquote> <p>When importing CSS from a JavaScript file, that CSS is not bundled with the rest of the CSS processed with the Meteor build tool, but instead is put in your app’s <code>&lt;head&gt;</code> tag inside <code>&lt;style&gt;...&lt;/style&gt;</code> after the main concatenated CSS file.</p> </blockquote> <p>Importing styles from an Atmosphere package using the <code>{}</code> package name syntax:</p>  <pre class="line-numbers" style><code class="language-less">@import '{my-package:pretty-buttons}/buttons/styles.import.less';
</code></pre> <blockquote> <p>CSS files in an Atmosphere package are declared with <a href="http://docs.meteor.com/#/full/pack_addFiles" target="_blank" rel="noopener"><code>api.addFiles</code></a>, and therefore will be eagerly evaluated, and automatically bundled with all the other CSS in your app.</p> </blockquote> <p>Importing styles from an npm package using the <code>{}</code> syntax:</p>  <pre class="line-numbers" style><code class="language-less">@import '{}/node_modules/npm-package-name/button.less';
</code></pre>  <pre class="line-numbers" style><code class="language-js">import 'npm-package-name/stylesheets/styles.css';
</code></pre> <p>For more examples and details on importing styles and using <code>@imports</code> with packages see the <a href="https://guide.meteor.com/using-packages.html#npm-styles">Using Packages</a> article.</p> <h3 id="sass">Sass</h3> <p>The best Sass build plugin for Meteor is <a href="https://atmospherejs.com/fourseven/scss" target="_blank" rel="noopener"><code>fourseven:scss</code></a>.</p> <h3 id="less">Less</h3> <p>Less is maintained as a <a href="https://atmospherejs.com/meteor/less" target="_blank" rel="noopener">Meteor core package called <code>less</code></a>.</p> <h3 id="stylus">Stylus</h3> <p>The best Stylus build plugin for Meteor is <a href="https://atmospherejs.com/coagmano/stylus" target="_blank" rel="noopener">coagmano:stylus</a></p> <h2 id="postcss">PostCSS and Autoprefixer</h2> <p>In addition to CSS pre-processors like Sass, Less, and Stylus, there is now an ecosystem of CSS post-processors. Regardless of which CSS pre-processor you use, a post-processor can give you additional benefits like cross-browser compatibility.</p> <p>The most popular CSS post-processor right now is <a href="https://github.com/postcss/postcss" target="_blank" rel="noopener">PostCSS</a>, which supports a variety of plugins. <a href="https://github.com/postcss/autoprefixer" target="_blank" rel="noopener">Autoprefixer</a> is perhaps the most useful plugin, since it enables you to stop worrying about browser prefixes and compatibility and write standards-compliant CSS. No more copying 5 different statements every time you want a CSS gradient - you can write a standard gradient without any prefixes and Autoprefixer handles it for you.</p> <p>Currently, Meteor doesn’t have a separate build step for post-processing CSS, so the only way to integrate it is to build it into the minifier. Thankfully, there is a community package that has integrated PostCSS with plugin support into a replacement for Meteor’s standard minification package.</p> <h3 id="juliancwirko-postcss">juliancwirko:postcss</h3> <blockquote> <p>Note: This package is no longer actively maintained, therefore compatibility with newer versions of Meteor is not guaranteed. If you encouter problems with this, please let us know by <a href="https://github.com/meteor/guide/issues" target="_blank" rel="noopener">opening an issue on the Guide</a>.</p> </blockquote> <p>Use the package <a href="https://atmospherejs.com/juliancwirko/postcss" target="_blank" rel="noopener">juliancwirko:postcss</a> to your app to enable PostCSS for your Meteor app. To do so, we remove the standard CSS minifier and replace it with the postcss package:</p>  <pre class="line-numbers" style><code class="language-clike">meteor remove standard-minifier-css
meteor add juliancwirko:postcss
</code></pre> <p>As well as installing the postcss NPM package:</p>  <pre class="line-numbers" style><code class="language-clike">meteor npm install postcss@^6.0.22  --save-dev
meteor npm install postcss-load-config@^1.2.0 --save-dev
</code></pre> <p>Then we can install any npm CSS processing packages that we’d like to use and reference them from a <code>postcss</code> section of our <code>package.json</code>. In the Todos example app, we use <code>autoprefixer</code> package to increase browser support:</p>  <pre class="line-numbers" style><code class="language-clike">{
  "devDependencies": {
    "autoprefixer": "^6.3.1"
  },
  "postcss": {
    "plugins": {
      "autoprefixer": {"browsers": ["last 2 versions"]}
    }
  }
}
</code></pre> <p>After doing the above, you’ll need to ensure you <code>npm install</code> and restart the <code>meteor</code> process running your app to make sure the PostCSS system has had a chance to set itself up.</p> <h2 id="hot-module-replacement">Hot Module Replacement</h2> <p>In Meteor apps, javascript, typescript, css files that are dynamically imported, and many other types of files are converted into javascript modules during the build process. Instead of reloading the client after a rebuild, Meteor is able to update the javascript modules within the running application that were modified. This reduces the feedback cycle while developing by allowing you to view and test your changes quicker.</p> <p>Hot module replacement (HMR) can be enabled by adding the <a href="https://docs.meteor.com/packages/hot-module-replacement.html" target="_blank" rel="noopener">hot-module-replacement</a> package to your app:</p>  <pre class="line-numbers" style><code class="language-clike">meteor add hot-module-replacement
</code></pre> <p>Many types of javascript modules can not be updated with HMR, so HMR has to be configured to know which modules can be replaced and how to replace them. Most apps never need to do this manually. Instead, you can use integrations that configure HMR for you:</p> <ul> <li>React components are automatically updated using <a href="https://atmospherejs.com/meteor/react-fast-refresh" target="_blank" rel="noopener">React Fast Refresh</a>. This integration is enabled for all Meteor apps that use HMR and a supported react version.</li> <li>An integration for Blaze templates is in <a href="https://github.com/meteor/blaze/pull/313" target="_blank" rel="noopener">beta</a>.</li> <li>Svelte files can be automatically updated with HMR by using the <a href="https://atmospherejs.com/zodern/melte" target="_blank" rel="noopener">zodern:melte</a> compiler package.</li> <li>
<a href="https://atmospherejs.com/akryum/vue-component" target="_blank" rel="noopener">akryum:vue-component</a> uses its own implementation of HMR to update vue components.</li> <li>Some packages are able to help automatically dispose old versions of modules. For example, <a href="https://atmospherejs.com/zodern/pure-admin" target="_blank" rel="noopener">zodern:pure-admin</a> removes menu items and pages added in the old version of the module so you don’t end up with duplicate or outdated items when the new version of the module is ran.</li> </ul> <p>To further control how HMR applies updates in your app, you can use the <a href="https://docs.meteor.com/packages/hot-module-replacement.html" target="_blank" rel="noopener">hot API</a>. This can be used to accept updates for additional types of files, help dispose a module so the old version no longer affects the app (such as stopping Tracker.autorun computations), or creating your own integrations with other view layers or libraries.</p> <p>If a change was made to the app that can not be applied with HMR, it reloads the page with hot code push, as is done when HMR is not enabled. It currently only supports app code in the modern client architecture. Future versions of Meteor will add support for packages and other architectures.</p> <h2 id="build-plugins">Build plugins</h2> <p>The most powerful feature of Meteor’s build system is the ability to define custom build plugins. If you find yourself writing scripts that mangle one type of file into another, merge multiple files, or something else, it’s likely that these scripts would be better implemented as a build plugin. The <code>ecmascript</code>, <code>templating</code>, and <code>coffeescript</code> packages are all implemented as build plugins, so you can replace them with your own versions if you want to!</p> <p><a href="https://docs.meteor.com/api/packagejs.html#build-plugin-api" target="_blank" rel="noopener">Read the documentation about build plugins.</a></p> <h3 id="types-of-build-plugins">Types of build plugins</h3> <p>There are three types of build plugins supported by Meteor today:</p> <ol> <li>Compiler plugin - compiles source files (LESS, CoffeeScript) into built output (JS, CSS, asset files, and HTML). Only one compiler plugin can handle a single file extension.</li> <li>Minifier plugin - compiles lots of built CSS or JS files into one or more minified files, for example <code>standard-minifiers</code>. Only one minifier can handle each of <code>js</code> and <code>css</code>.</li> <li>Linter plugin - processes any number of files, and can print lint errors. Multiple linters can process the same files.</li> </ol> <h3 id="writing-build-plugins">Writing your own build plugin</h3> <p>Writing a build plugin is a very advanced task that only the most advanced Meteor users should get into. The best place to start is to copy a different plugin that is the most similar to what you are trying to do. For example, if you wanted to make a new CSS compiler plugin, you could fork the <code>less</code> package; if you wanted to make your own JS transpiler, you could fork <code>ecmascript</code>. A good example of a linter is the <code>jshint</code> package, and for a minifier you can look at <code>standard-minifiers-js</code> and <code>standard-minifiers-css</code>.</p> <h3 id="caching-build-plugins">Caching</h3> <p>The best way to make your build plugin fast is to use caching anywhere you can - the best way to save time is to do less work! Check out the <a href="https://docs.meteor.com/api/packagejs.html#build-plugin-caching" target="_blank" rel="noopener">documentation about CachingCompiler</a> to learn more. It’s used in all of the above examples, so you can see how to use it by looking at them.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://guide.meteor.com/build-tool.html" class="_attribution-link" target="_blank">https://guide.meteor.com/build-tool.html</a>
  </p>
</div>
