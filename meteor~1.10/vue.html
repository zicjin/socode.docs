<p>After reading this guide, you’ll know:</p> <ol> <li><a href="#introduction">What Vue is, and why you should consider using it with Meteor</a></li> <li><a href="#integrating-vue-with-meteor">How to install Vue in your Meteor application, and how to use it correctly</a></li> <li><a href="#using-meteors-data-system">How to integrate Vue with Meteor’s realtime data layer</a></li> <li><a href="#style-guide">How to structure Meteor with Vue</a></li> <li><a href="#ssr-code-splitting">How to Server-side Render (SSR) Vue with Meteor</a></li> </ol> <p>Vue already has an excellent guide with many advanced topics already covered. Some of them are <a href="https://ssr.vuejs.org/" target="_blank" rel="noopener">SSR (Server-side Rendering)</a>, <a href="https://router.vuejs.org/" target="_blank" rel="noopener">Routing</a>, <a href="https://vuejs.org/v2/style-guide/" target="_blank" rel="noopener">Code Structure and Style Guide</a> and <a href="https://vuex.vuejs.org/" target="_blank" rel="noopener">State Management with Vuex</a>.</p> <p>This documentation is purely focused on integrating it with Meteor.</p> <blockquote> <p>Meteor has a Vue skeleton which will prepare for you a basic Vue Meteor app. You can create one by running <code>meteor create vue-meteor-app --vue</code> There is also a <a href="https://vue-tutorial.meteor.com/" target="_blank" rel="noopener">Vue tutorial</a> which covers the basics of this section. </p> </blockquote> <h2 id="introduction">Introduction</h2> [Vue](https://vuejs.org/v2/guide/) (pronounced /vjuː/, like view) is a progressive framework for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with [modern tooling](https://vuejs.org/v2/guide/single-file-components.html) and [supporting libraries](https://github.com/vuejs/awesome-vue#components--libraries). <p>Vue has an excellent <a href="https://vuejs.org/v2/guide/" target="_blank" rel="noopener">guide and documentation</a>. This guide is about integrating it with Meteor.</p> <h3 id="why-use-vue-with-meteor">Why use Vue with Meteor</h3> <p>Vue is a frontend library, like React, Blaze and Angular. </p> <p>Some really nice frameworks are built around Vue. <a href="https://nuxtjs.org" target="_blank" rel="noopener">Nuxt.js</a> for example, aims to create a framework flexible enough that you can use it as a main project base or in addition to your current project based on Node.js. Though Nuxt.js is full-stack and very pluggable. It lacks the an API to communicate data from and to the server. Also unlike Meteor, Nuxt still relies on a configuration file. </p> <p>Meteor’s build tool and Pub/Sub API (or Apollo) provides Vue with this API that you would normally have to integrate yourself, greatly reducing the amount of boilerplate code you have to write.</p> <h3 id="integrating-vue-with-meteor">Integrating Vue With Meteor</h3> <p>To start a new project: </p>  <pre class="line-numbers" style><code class="language-sh">meteor create vue-meteor-app
</code></pre> <p>To install Vue in Meteor, you should add it as an npm dependency:</p>  <pre class="line-numbers" style><code class="language-sh">meteor npm install --save vue
</code></pre> <p>To support <a href="https://vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener">Vue’s Single File Components</a> with the .vue file extensions, install the following Meteor package created by Vue Core developer <a href="https://github.com/meteor-vue/vue-meteor/tree/master/packages/vue-component" target="_blank" rel="noopener">Akryum (Guillaume Chau)</a>.</p>  <pre class="line-numbers" style><code class="language-sh">meteor add akryum:vue-component
</code></pre> <p>You will end up with at least 3 files:</p> <ol> <li>a <code>/client/App.vue</code> The root component of your app</li> <li>a <code>/client/main.js</code> Initializing the Vue app in Meteor startup</li> <li>a <code>/client/main.html</code> containing the body with the #app div</li> </ol> <p>We need a base HTML document that has the <code>app</code> id. If you created a new project from <code>meteor create .</code>, put this in your <code>/client/main.html</code>.</p>  <pre class="line-numbers" style><code class="language-html">&lt;body&gt;
  &lt;div id="app"&gt;&lt;/div&gt;
&lt;/body&gt;
</code></pre> <p>You can now start writing .vue files in your app with the following format. If you created a new project from <code>meteor create .</code>, put this in your <code>/client/App.vue</code>.</p>  <pre class="line-numbers" style><code class="language-vuejs">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;This is a Vue component and below is the current date:&lt;br /&gt;{{date}}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      date: new Date(),
    };
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
  p {
    font-size: 2em;
    text-align: center;
  }
&lt;/style&gt;
</code></pre> <p>You can render the Vue component hierarchy to the DOM by using the below snippet in you client startup file. If you created a new project from <code>meteor create .</code>, put this in your <code>/client/main.js</code>.</p>  <pre class="line-numbers" style><code class="language-javascript">import Vue from 'vue';
import App from './App.vue';
import './main.html';

Meteor.startup(() =&gt; {
  new Vue({
    el: '#app',
    ...App,
  });
});
</code></pre> <p>Run your new Vue+Meteor app with this command: <code>NO_HMR=1 meteor</code></p> <h2 id="using-meteors-data-system">Using Meteor's data system</h2> <p>One of the biggest advantages of Meteor is definitely it’s realtime data layer. It allows for so called full-stack reactivity and <a href="https://blog.meteor.com/optimistic-ui-with-meteor-67b5a78c3fcf" target="_blank" rel="noopener">optimistic UI</a> functionality. To accomplish full-stack reactivity, Meteor uses <a href="https://docs.meteor.com/api/tracker.html" target="_blank" rel="noopener">Tracker</a>. In this section we will explain how to integrate Meteor Tracker with Vue to leverage the best of both tools.</p> <ol> <li>Install the <a href="https://github.com/meteor-vue/vue-meteor-tracker" target="_blank" rel="noopener">vue-meteor-tracker</a> package from NPM:</li> </ol>  <pre class="line-numbers" style><code class="language-sh">meteor npm install --save vue-meteor-tracker
</code></pre> <p>Next, the package needs to be plugged into Vue as a plugin. Add the following to your <code>/client/main.js</code>:</p>  <pre class="line-numbers" style><code class="language-javascript">import Vue from 'vue';
import VueMeteorTracker from 'vue-meteor-tracker'; // import the integration package!
import App from './App.vue';
import './main.html';

Vue.use(VueMeteorTracker);                         // Add the plugin to Vue!

Meteor.startup(() =&gt; {
  new Vue({
    el: '#app',
    ...App,
  });
});
</code></pre> <h3>Example app</h3> <p>If you’ve followed the <a href="#integrating-vue-with-meteor">integration guide</a>, then your Vue application shows the time it was loaded.</p> <p>Let’s add some functionality that makes this part dynamic. To flex Meteor’s plumbing, we’ll create:</p> <ol> <li>A <a href="https://docs.meteor.com/api/collections.html" target="_blank" rel="noopener">Meteor Collection</a> called <code>Time</code> with a <code>currentTime</code> doc.</li> <li>A <a href="data-loading#publications-and-subscriptions">Meteor Publication</a> called <code>Time</code> that sends all documents</li> <li>A <a href="methods#what-is-a-method">Meteor Method</a> called <code>UpdateTime</code> to update the <code>currentTime</code> doc.</li> <li>A <a href="https://docs.meteor.com/api/pubsub.html" target="_blank" rel="noopener">Meteor Subscription</a> to <code>Time</code>
</li> <li>
<a href="https://github.com/meteor-vue/vue-meteor-tracker" target="_blank" rel="noopener">Vue/Meteor Reactivity</a> to update the Vue component</li> </ol> <p>The first 3 steps are basic Meteor:</p> <p>1) In <code>/imports/collections/Time.js</code></p>  <pre class="line-numbers" style><code class="language-javascript">Time = new Mongo.Collection("time");
</code></pre> <p>2) In <code>/imports/publications/Time.js</code></p>  <pre class="line-numbers" style><code class="language-javascript">Meteor.publish('Time', function () {
  return Time.find({});
});
</code></pre> <p>3) In <code>/imports/methods/UpdateTime.js</code></p>  <pre class="line-numbers" style><code class="language-javascript">Meteor.methods({
  UpdateTime() {
    Time.upsert('currentTime', { $set: { time: new Date() } });
  },
});
</code></pre> <p>Now, let’s add these to our server. First <a href="security#checklist">remove autopublish</a> so our publications matter:</p>  <pre class="line-numbers" style><code class="language-bash">meteor remove autopublish
</code></pre> <p>For fun, let’s make a <a href="https://galaxy-guide.meteor.com/environment-variables.html#settings-example" target="_blank" rel="noopener"><code>settings.json</code> file</a>:</p>  <pre class="line-numbers" style><code class="language-json">{ "public": { "hello": "world" } }
</code></pre> <p>Now, let’s update our <code>/server/main.js</code> to use our new stuff:</p>  <pre class="line-numbers" style><code class="language-javascript">import { Meteor } from 'meteor/meteor';

import '/imports/collections/Time';
import '/imports/publications/Time';
import '/imports/methods/UpdateTime';

Meteor.startup(() =&gt; {
  // Update the current time
  Meteor.call('UpdateTime');
  // Add a new doc on each start.
  Time.insert({ time: new Date() });
  // Print the current time from the database
  console.log(`The time is now ${Time.findOne().time}`);
});
</code></pre> <p>Start your Meteor app, your should see a message pulling data from Mongo. We haven’t made any changes to the client, so you should just see some startup messages.</p>  <pre class="line-numbers" style><code class="language-sh">meteor
</code></pre> <p>4) and 5) Great, let’s integrate this with Vue using <a href="https://github.com/meteor-vue/vue-meteor-tracker" target="_blank" rel="noopener">Vue Meteor Tracker</a> and update our <code>/client/App.vue</code> file:</p>  <pre class="line-numbers" style><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;div v-if="!$subReady.Time"&gt;Loading...&lt;/div&gt;
    &lt;div v-else&gt;
      &lt;p&gt;Hello {{hello}},
        &lt;br&gt;The time is now: {{currentTime}}
      &lt;/p&gt;
      &lt;button @click="updateTime"&gt;Update Time&lt;/button&gt;
      &lt;p&gt;Startup times:&lt;/p&gt;
      &lt;ul&gt;
        &lt;li v-for="t in TimeCursor"&gt;
          {{t.time}}  -  {{t._id}}
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;Meteor settings&lt;/p&gt;
      &lt;pre&gt;&lt;code&gt;
        {{settings}}
      &lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import '/imports/collections/Time';

export default {
  data() {
    console.log('Sending non-Meteor data to Vue component');
    return {
      hello: 'World',
      settings: Meteor.settings.public,   // not Meteor reactive
    }
  },
  // Vue Methods
  methods: {  
    updateTime() {
      console.log('Calling Meteor Method UpdateTime');
      Meteor.call('UpdateTime');          // not Meteor reactive
    }
  },
  // Meteor reactivity
  meteor: {
    // Subscriptions - Errors not reported spelling and capitalization.
    $subscribe: {
      'Time': []
    },
    // A helper function to get the current time
    currentTime () {
      console.log('Calculating currentTime');
      var t = Time.findOne('currentTime') || {};
      return t.time;
    },
    // A Minimongo cursor on the Time collection is added to the Vue instance
    TimeCursor () {
      // Here you can use Meteor reactive sources like cursors or reactive vars
      // as you would in a Blaze template helper
      return Time.find({}, {
        sort: {time: -1}
      })
    },
  }
}
&lt;/script&gt;

&lt;style scoped&gt;
  p {
    font-size: 2em;
  }
&lt;/style&gt;
</code></pre> <p>Restart your server to use the <code>settings.json</code> file.</p>  <pre class="line-numbers" style><code class="language-sh">meteor --settings=settings.json 
</code></pre> <p>Then refresh your browser to reload the client.</p> <p>You should see:</p> <ul> <li>the current time</li> <li>a button to Update the current time</li> <li>startup times for the server (added to the Time collection on startup)</li> <li>The Meteor settings from your settings file</li> </ul> <p>Excellent! That’s a tour of some of Meteor’s features, and how to integrate with Vue. Have a better approach? Please send a PR.</p> <h2 id="style-guide">Style Guide and File Structure</h2> <p>Like code linting and style guides are tools for making code easier and more fun to work with.</p> <p>These are practical means to practical ends.</p> <ol> <li>Leverage existing tools</li> <li>Leverage existing configurations</li> </ol> <p><a href="code-style">Meteor’s style guide</a> and <a href="https://vuejs.org/v2/style-guide/" target="_blank" rel="noopener">Vue’s style guide</a> can be overlapped like this:</p> <ol> <li><a href="code-style#eslint-editor">Configure your Editor</a></li> <li><a href="code-style#eslint-installing">Configure eslint for Meteor</a></li> <li><a href="https://vuejs.org/v2/style-guide/#Rule-Categories" target="_blank" rel="noopener">Review the Vue Style Guide</a></li> <li>Open up the <a href="https://eslint.org/docs/rules/" target="_blank" rel="noopener">ESLint rules</a> as needed.</li> </ol> <p>Application Structure is documented here:</p> <ol> <li>
<a href="structure#example-app-structure">Meteor’s Application Structure</a> is the default start.</li> <li>
<a href="https://vuex.vuejs.org/guide/structure.html" target="_blank" rel="noopener">Vuex’s Application Structure</a> may be interesting.</li> </ol> <h2 id="ssr-code-splitting">SSR and Code Splitting</h2> Vue has [an excellent guide on how to render your Vue application on the server](https://vuejs.org/v2/guide/ssr.html). It includes code splitting, async data fetching and many other practices that are used in most apps that require this. <h3 id="basic-example">Basic Example</h3> Making Vue SSR to work with Meteor is not more complex then for example with [Express](https://expressjs.com/). However instead of defining a wildcard route, Meteor uses its own [server-render](https://docs.meteor.com/packages/server-render.html) package that exposes an `onPageLoad` function. Every time a call is made to the server side, this function is triggered. This is where we should put our code like how its described on the [VueJS SSR Guide](https://ssr.vuejs.org/guide/#integrating-with-a-server). <p>To add the packages, run:</p>  <pre class="line-numbers" style><code class="language-sh">meteor add server-render
meteor npm install --save vue-server-renderer
</code></pre> <p>then connect to Vue in <code>/server/main.js</code>:</p>  <pre class="line-numbers" style><code class="language-javascript">import { Meteor } from 'meteor/meteor';
import Vue from 'vue';
import { onPageLoad } from 'meteor/server-render';
import { createRenderer } from 'vue-server-renderer';

const renderer = createRenderer();

onPageLoad(sink =&gt; {
  console.log('onPageLoad');
  
  const url = sink.request.url.path;
  
  const app = new Vue({
    data: {
      url
    },
    template: `&lt;div&gt;The visited URL is: {{ url }}&lt;/div&gt;`
  });

  renderer.renderToString(app, (err, html) =&gt; {
    if (err) {
      res.status(500).end('Internal Server Error');
      return
    }
    console.log('html', html);
    
    sink.renderIntoElementById('app', html);
  })
})
</code></pre> <p>Luckily <a href="https://github.com/akryum" target="_blank" rel="noopener">Akryum</a> has us covered and provided us with a Meteor package for this: <a href="https://github.com/meteor-vue/vue-meteor/tree/master/packages/vue-ssr" target="_blank" rel="noopener">akryum:vue-ssr</a> allows us to write our server-side code like below:</p>  <pre class="line-numbers" style><code class="language-javascript">import { VueSSR } from 'meteor/akryum:vue-ssr';
import createApp from './app';

VueSSR.createApp = function () {
  // Initialize the Vue app instance and return the app instance
  const { app } = createApp(); 
  return { app };
}
</code></pre> <h4 id="serverside-routes">Server-side Routing</h4> <p>Sweet, but most apps have some sort of routing functionality. We can use the VueSSR context parameter for this. It simply passes the Meteor server-render request url which we need to push into our router instance:</p>  <pre class="line-numbers" style><code class="language-javascript">import { VueSSR } from 'meteor/akryum:vue-ssr';
import createApp from './app';

VueSSR.createApp = function (context) {
  // Initialize the Vue app instance and return the app + router instance
  const { app, router } = createApp(); 
  
  // Set router's location from the context
  router.push(context.url);
  
  return { app };
}
</code></pre> <h3 id="async-data-and-hydration">Async data and Hydration</h3> <p>Hydration is the the word for loading state into components on the serverside and then reusing that data on the clientside. This allows components to fully render their markup on the server and prevents a ‘re-render’ on the clientside when the bundle is loaded.</p> <p><a href="https://nuxtjs.org/" target="_blank" rel="noopener">Nuxt</a> solves this gracefully with a feature called <a href="https://nuxtjs.org/guide/async-data" target="_blank" rel="noopener">asyncData</a>.</p> <p>Meteor’s pub/sub system is at this moment not suitable for SSR which means that if we want the same functionality, we will have to implement it ourselves. How that can be done is exactly what we are going to explain here!</p> <blockquote> <p>Important reminder here is the fact that Server Rendering on its own is already worth a guide - <a href="https://ssr.vuejs.org/" target="_blank" rel="noopener">which is exactly what the guys from Vue did</a>. Most of the code is needed in any platform except Nuxt (Vue based) and Next (React based). We simply describe the best way to do this for Meteor. To really understand what is happening read that SSR guide from Vue.</p> </blockquote> <p>SSR follows a couple of steps that are almost always the same for any frontend library (React, Vue or Angular).</p> <ol> <li>Resolve the url with the router</li> <li>Fetch any matching components from the router</li> <li>Filter out components that have no asyncData</li> <li>Map the components into a list of promises by return the asyncData method’s result</li> <li>Resolve all promises</li> <li>Store the resulting data in the HTML for later hydration of the client bundle</li> <li>Hydrate the clientside </li> </ol> <p>Its better documented in code:</p>  <pre class="line-numbers" style><code class="language-javascript">VueSSR.createApp = function (context) {

  // Wait with sending the app to the client until the promise resolves (thanks Akryum)
  return new Promise((resolve, reject) =&gt; {
    const { app, router, store } = createApp({
      ssr: true,
    });

    // 1. Resolve the URL with the router
    router.push(context.url);
    
    router.onReady(async () =&gt; {
      // 2, Fetch any matching components from the router
      const matchedComponents = router.getMatchedComponents();
      
      const route = router.currentRoute;
    
      // No matched routes
      if (!matchedComponents.length) {
        reject(new Error('not-found'));
      }
      
      // 3. Filter out components that have no asyncData
      const componentsWithAsyncData = matchedComponents.filter(component =&gt; component.asyncData);

      // 4. Map the components into a list of promises 
      // by returning the asyncData method's result
      const asyncDataPromises = componentsWithAsyncData.map(component =&gt; (
        component.asyncData({ store, route })
      ));
      
      // You can have the asyncData methods resolve promises with data. 
      // However to avoid complexity its recommended to leverage Vuex
      // In our case we're simply calling Vuex actions in our methods 
      // that do the fetching and storing of the data. This makes the below 
      // step really simple
      
      // 5. Resolve all promises. (that's it)
      await Promise.all(asyncDataPromises);
      
      // From this point on we can assume that all the needed data is stored 
      // in the Vuex store. Now we simply need to grap it and push it into 
      // the HTML as a "javascript string"
      
      // 6. Store the data in the HTML for later hydration of the client bundle
      const js = `window.__INITIAL_STATE__=${JSON.stringify(store.state)};`;
      
      // Resolve the promise with the same object as the simple version
      // Push our javascript string into the resolver. 
      // The VueSSR package takes care of the rest
      resolve({
        app,
        js, 
      });      
    });
  }); 
};
</code></pre> <p>Awesome. When we load our app in the browser you should see a weird effect. The app seems to load correctly. That’s the server-side rendering doing its job well. However, after a split second the app suddenly is empty again.</p> <p>That’s because when the client-side bundle takes over, it doesn’t have its data yet. It will override the HTML with an empty app! We need to hydrate the bundle with the JSON data in the HTML.</p> <p>If you inspect the HTML via the source code view, you will see the HTML source of your app accompanied by the <code>__INITIAL_STATE=""</code> filled with the JSON string. We need to use this to hydrate the clientside. Luckily this is fairly easy, because we have only one place that needs hydration: the Vuex store!</p>  <pre class="line-numbers" style><code class="language-javascript">import { Meteor } from 'meteor/meteor';
import createApp from './app';

Meteor.startup(() =&gt; {
  const { store, router } = createApp({ // Same function as the server
    ssr: false,
  });

  // Hydrate the Vuex store with the JSON string
  if (window.__INITIAL_STATE__) {
    store.replaceState(window.__INITIAL_STATE__);
  }
});
</code></pre> <p>Now when we load our bundle, the components should have data from the store. All fine. However there is one more thing to do. If we navigate, our newly rendered clientside components will again not have any data. This is because the <code>asyncData</code> method is not yet being called on the client side. We can fix this using a mixin like below as documented in the <a href="https://ssr.vuejs.org/guide/data.html#client-data-fetching" target="_blank" rel="noopener">Vue SSR Guide</a>.</p>  <pre class="line-numbers" style><code class="language-javascript">Vue.mixin({
  beforeMount () {
    const { asyncData } = this.$options
    if (asyncData) {
      // assign the fetch operation to a promise
      // so that in components we can do `this.dataPromise.then(...)` to
      // perform other tasks after data is ready
      this.dataPromise = asyncData({
        store: this.$store,
        route: this.$route
      })
    }
  }
})
</code></pre> <p>We now have a fully functioning and server-rendered Vue app in Meteor! </p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://guide.meteor.com/vue.html" class="_attribution-link" target="_blank">https://guide.meteor.com/vue.html</a>
  </p>
</div>
