<p>A ReactiveDict stores an arbitrary set of key-value pairs. Use it to manage internal state in your components, ie. like the currently selected item in a list. Each key is individully reactive such that calling <code>set</code> for a key will invalidate any Computations that called <code>get</code> with that key, according to the usual contract for reactive data sources.</p> <p>That means if you call <a href="#ReactiveDict-get"><code>ReactiveDict#get</code></a><code>('currentList')</code> from inside a Blaze template helper, the template will automatically be rerendered whenever <a href="#ReactiveDict-set"><code>ReactiveDict#set</code></a><code>('currentList', x)</code> is called.</p> <p>To use <code>ReactiveDict</code>, add the <code>reactive-dict</code> package to your project by running in your terminal:</p>  <pre class="line-numbers" style><code class="language-bash">meteor add reactive-dict
</code></pre>  <h2 class="api-heading" id="ReactiveDict"> <div class="locus"> Client </div> <code>new ReactiveDict([name], [initialValue])</code> <div class="subtext-api"> <code>import { ReactiveDict } from 'meteor/reactive-dict'</code> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/reactive-dict/reactive-dict.js#L32" target="_blank"> (reactive-dict/reactive-dict.js, line 32) </a> </div> </h2>   <p>Constructor for a ReactiveDict, which represents a reactive dictionary of key/value pairs.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>name</code> <span class="type">String</span> </dt> <dd> <p>Optional. When a name is passed, preserves contents across Hot Code Pushes</p> </dd> <dt> <code>initialValue</code> <span class="type">Object</span> </dt> <dd> <p>Optional. The default values for the dictionary</p> </dd> </dl>   <p>If you provide a name to its constructor, its contents will be saved across Hot Code Push client code updates.</p>  <h3 class="api-heading" id="ReactiveDict-set"> <div class="locus"> Client </div> <code>ReactiveDict#set(key, value)</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/reactive-dict/reactive-dict.js#L84" target="_blank"> (reactive-dict/reactive-dict.js, line 84) </a> </div> </h3>   <p>Set a value for a key in the ReactiveDict. Notify any listeners that the value has changed (eg: redraw templates, and rerun any <a href="#tracker_autorun"><code>Tracker.autorun</code></a> computations, that called <a href="#ReactiveDict_get"><code>ReactiveDict.get</code></a> on this <code>key</code>.)</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>key</code> <span class="type">String</span> </dt> <dd> <p>The key to set, eg, <code>selectedItem</code></p> </dd> <dt> <code>value</code> <span class="type"><a href="#ejson">EJSON-able Object</a> or undefined</span> </dt> <dd> <p>The new value for <code>key</code></p> </dd> </dl>   <p>Example:</p>  <pre class="line-numbers" style><code class="language-js">const state = new ReactiveDict();
state.set('currentRoomId', 'random')

Tracker.autorun(() =&gt; {
  Meteor.subscribe('chatHistory', { room: state.get('currentRoomId') });
});

// Causes the function passed to `Tracker.autorun` to be rerun, so that the
// 'chatHistory' subscription is moved to the room 'general'.
state.set('currentRoomId', 'general');
</code></pre> <p><code>ReactiveDict.set</code> can also be called with an object of keys and values, which is equivalent to calling <code>ReactiveDict.set</code> individually on each key/value pair.</p>  <pre class="line-numbers" style><code class="language-js">const state = new ReactiveDict();
state.set({
  a: 'foo',
  b: 'bar'
});
</code></pre>  <h3 class="api-heading" id="ReactiveDict-setDefault"> <div class="locus"> Client </div> <code>ReactiveDict#setDefault(key, value)</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/reactive-dict/reactive-dict.js#L126" target="_blank"> (reactive-dict/reactive-dict.js, line 126) </a> </div> </h3>   <p>Set a value for a key if it hasn't been set before. Otherwise works exactly the same as <a href="#ReactiveDict-set"><code>ReactiveDict.set</code></a>.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>key</code> <span class="type">String</span> </dt> <dd> <p>The key to set, eg, <code>selectedItem</code></p> </dd> <dt> <code>value</code> <span class="type"><a href="#ejson">EJSON-able Object</a> or undefined</span> </dt> <dd> <p>The new value for <code>key</code></p> </dd> </dl>   <p>This is useful in initialization code, to avoid re-initializing your state every time a new version of your app is loaded.</p>  <h3 class="api-heading" id="ReactiveDict-get"> <div class="locus"> Client </div> <code>ReactiveDict#get(key)</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/reactive-dict/reactive-dict.js#L152" target="_blank"> (reactive-dict/reactive-dict.js, line 152) </a> </div> </h3>   <p>Get the value assiciated with a key. If inside a <a href="#reactivity">reactive computation</a>, invalidate the computation the next time the value associated with this key is changed by <a href="#ReactiveDict-set"><code>ReactiveDict.set</code></a>. This returns a clone of the value, so if it's an object or an array, mutating the returned value has no effect on the value stored in the ReactiveDict.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>key</code> <span class="type">String</span> </dt> <dd> <p>The key of the element to return</p> </dd> </dl>   <p>Example:</p>  <pre class="line-numbers" style><code class="language-html">&lt;!-- main.html --&gt;
&lt;template name="main"&gt;
  &lt;p&gt;We've always been at war with {{theEnemy}}.&lt;/p&gt;
  &lt;button class="change-enemy"&gt;Change Enemy&lt;/button&gt;
&lt;/template&gt;
</code></pre>  <pre class="line-numbers" style><code class="language-js">// main.js
Template.main.onCreated(function () {
    this.state = new ReactiveDict();
    this.state.set('enemy', 'Eastasia');
});
Template.main.helpers({
  theEnemy() {
    const inst = Template.instance();
    return inst.state.get('enemy');
  }
});
Template.main.events({
  'click .change-enemy'(event, inst) {
    inst.state.set('enemy', 'Eurasia')
  }
});

// Clicking the button will change the page to say "We've always been at war with Eurasia"
</code></pre>  <h3 class="api-heading" id="ReactiveDict-equals"> <div class="locus"> Client </div> <code>ReactiveDict#equals(key, value)</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/reactive-dict/reactive-dict.js#L167" target="_blank"> (reactive-dict/reactive-dict.js, line 167) </a> </div> </h3>   <p>Test if the stored entry for a key is equal to a value. If inside a <a href="#reactivity">reactive computation</a>, invalidate the computation the next time the variable changes to or from the value.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>key</code> <span class="type">String</span> </dt> <dd> <p>The name of the session variable to test</p> </dd> <dt> <code>value</code> <span class="type">String, Number, Boolean, null, or undefined</span> </dt> <dd> <p>The value to test against</p> </dd> </dl>   <p>If value is a scalar, then these two expressions do the same thing:</p>  <pre class="line-numbers" style><code class="language-js">const state = new ReactiveDict()
// ... 
state.get('key') === value
state.equals('key', value)
</code></pre> <p>However, the second is recommended, as it triggers fewer invalidations (template redraws), making your program more efficient.</p>  <h3 class="api-heading" id="ReactiveDict-all"> <div class="locus"> Client </div> <code>ReactiveDict#all()</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/reactive-dict/reactive-dict.js#L229" target="_blank"> (reactive-dict/reactive-dict.js, line 229) </a> </div> </h3>   <p>Get all key-value pairs as a plain object. If inside a <a href="#reactivity">reactive computation</a>, invalidate the computation the next time the value associated with any key is changed by <a href="#ReactiveDict-set"><code>ReactiveDict.set</code></a>. This returns a clone of each value, so if it's an object or an array, mutating the returned value has no effect on the value stored in the ReactiveDict.</p>     <h3 class="api-heading" id="ReactiveDict-clear"> <div class="locus"> Client </div> <code>ReactiveDict#clear()</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/reactive-dict/reactive-dict.js#L245" target="_blank"> (reactive-dict/reactive-dict.js, line 245) </a> </div> </h3>   <p>remove all key-value pairs from the ReactiveDict. Notify any listeners that the value has changed (eg: redraw templates, and rerun any <a href="#tracker_autorun"><code>Tracker.autorun</code></a> computations, that called <a href="#ReactiveDict_get"><code>ReactiveDict.get</code></a> on this <code>key</code>.)</p>     <h3 class="api-heading" id="ReactiveDict-destroy"> <div class="locus"> Client </div> <code>ReactiveDict#destroy()</code> <div class="subtext-api"> <a class="src-code link secondary" href="https://github.com/meteor/meteor/blob/master/packages/reactive-dict/reactive-dict.js#L293" target="_blank"> (reactive-dict/reactive-dict.js, line 293) </a> </div> </h3>   <p>Clear all values from the reactiveDict and prevent it from being migrated on a Hot Code Pushes. Notify any listeners that the value has changed (eg: redraw templates, and rerun any <a href="#tracker_autorun"><code>Tracker.autorun</code></a> computations, that called <a href="#ReactiveDict_get"><code>ReactiveDict.get</code></a> on this <code>key</code>.)</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://docs.meteor.com/api/reactive-dict.html" class="_attribution-link" target="_blank">https://docs.meteor.com/api/reactive-dict.html</a>
  </p>
</div>
